LastEarlyPosition + m_lLastLatePosition);
		si.nPage = unsigned int((double)MAX_SCROLL * dbl);
	}
	else
	{
		si.nPage = 0;
	}

	// Fill out the structure to update the horizontal scroll bar with
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_ALL;
	si.nMin = 0;
	si.nMax = MAX_SCROLL;
	si.nPos = siH.nPos;
	m_ScrollHorizontal.SetScrollInfo( &si, TRUE );

	// Get the rectangle containing the horizontal scroll bar
	m_ScrollHorizontal.GetClientRect(&rectS);

	// Compute the total height of all strips
	lTemp = TotalStripHeight();

	// Check that the total height is greather than 0
	if( lTemp > 0 )
	{
		// Compute the visible portion of the window (subtact off the horizontal scrollbar)
		rect.bottom -= rectS.bottom;

		// Determine how much of the window is visible, vertically
		double dbl = (double)max( rect.bottom, 0 ) / (double)lTemp;
		si.nPage = unsigned int ((double)MAX_SCROLL * dbl);
	}
	else
	{
		si.nPage = 0;
	}

	// Fill out the structure to update the vertical scroll bar with
	si.nPos = siV.nPos;
	m_ScrollVertical.SetScrollInfo( &si, TRUE );

	// set the scroll position of the horizontal scroll bar
	ScrollToPosition( m_lXScrollPos );
}

LRESULT CTimelineCtl::OnCreate(UINT /* nMsg */, WPARAM /* wParam */,
	LPARAM /* lParam */, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( !m_wnd.Attach( m_hWndCD ) )
	{
		return -1; // failed to attach window
	}

	// Clip out the scrollbars (and windows the strips create) when we redraw.
	// This gets rid of most of their flicker.
	m_wnd.ModifyStyle( 0, WS_CLIPCHILDREN, 0 );

	CRect rect, rectSB;

	// initialize popup menu's window
	rect.top = 0;
	rect.bottom = 0;
	rect.left = 0;
	rect.right = 0;

	m_MenuHandler.Create( NULL, "Hidden command strip menu handler",
		WS_CHILD, rect, &m_wnd, 0 );
	m_MenuHandler.m_pTimeline = this;

	// create horizontal scroll bar
	m_wnd.GetWindowRect(&rect);
	rect.bottom = rect.bottom - rect.top;
	rect.top = 0;
	rect.right = rect.right - rect.left;
	rect.left = 0;
	m_ScrollHorizontal.Create( SBS_HORZ | SBS_BOTTOMALIGN | WS_CHILD | WS_VISIBLE, rect, &m_wnd, SB_HORIZONTAL );

	// create vertical scroll bar
	m_ScrollHorizontal.GetClientRect( &rectSB );
	rect.bottom -= rectSB.bottom;
	m_ScrollVertical.Create( SBS_VERT | SBS_RIGHTALIGN | WS_CHILD | WS_VISIBLE, rect, &m_wnd, SB_VERTICAL );

	// Load the bitmaps, if necessary
	if( ::InterlockedIncrement( &m_lBitmapRefCount ) == 1 )
	{
		m_BitmapZoomIn.LoadBitmap( IDB_ZOOMIN );
		m_BitmapZoomOut.LoadBitmap( IDB_ZOOMOUT );
		m_BitmapMinimize.LoadOEMBitmap( OBM_REDUCE );
		m_BitmapMinimized.LoadOEMBitmap( OBM_REDUCED );
		m_BitmapMaximize.LoadOEMBitmap( OBM_ZOOM );
		m_BitmapMaximized.LoadOEMBitmap( OBM_ZOOMD );
	}

	// create zoom in and zoom out buttons
	m_ScrollHorizontal.GetClientRect( &rect );
	rect.right = rect.bottom; // make the buttons square
	m_BtnZoomIn.Create( "Z", BS_PUSHBUTTON | BS_BITMAP | WS_CHILD | WS_VISIBLE, rect, &m_wnd, BTN_ZOOMIN );
	m_BtnZoomIn.SetBitmap( m_BitmapZoomIn );
	m_BtnZoomOut.Create( "z", BS_PUSHBUTTON | BS_BITMAP | WS_CHILD | WS_VISIBLE, rect, &m_wnd, BTN_ZOOMOUT );
	m_BtnZoomOut.SetBitmap( m_BitmapZoomOut );

	BITMAP bitmap;
	if( m_BitmapMaximized.GetBitmap( &bitmap ) )
	{
		m_sizeMinMaxButton.cx = bitmap.bmWidth;
		m_sizeMinMaxButton.cy = bitmap.bmHeight;
	}
	// create the time display strip
	IDMUSProdStripMgr*	pSM;
	if( SUCCEEDED( CoCreateInstance( CLSID_TimeStripMgr, NULL, CLSCTX_INPROC_SERVER,
		IID_IDMUSProdStripMgr, (void**)&pSM )))
	{
		AddStripMgr( pSM, 0xffffffff );
		pSM->Release();
	}
	else
	{
		ASSERT(FALSE); // couldn't create time display mgr.
	}
	
	HRESULT hr;
	hr = RegisterDragDrop(m_hWndCD, (IDropTarget *) this);
	ASSERT(SUCCEEDED(hr));

	m_MenuHandler.m_hwndDeleteTracks = GetParent();

	return 0;
}

LRESULT CTimelineCtl::OnDestroy( UINT nMsg, WPARAM /*wParam*/,
		LPARAM /*lParam*/, BOOL& lResult )
{
	UNREFERENCED_PARAMETER( nMsg );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;
	hr = RevokeDragDrop(m_hWndCD);
	ASSERT(SUCCEEDED(hr));

	lResult = FALSE;
	return 0;
}

LRESULT CTimelineCtl::OnDrawItem(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& lResult )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UINT	idCtl;
	idCtl = (UINT) wParam;             // control identifier 
	if( idCtl == BTN_ZOOMIN )
	{
		m_BtnZoomIn.SendMessage( nMsg, wParam, lParam );
	}
	else if( idCtl == BTN_ZOOMOUT )
	{
		m_BtnZoomOut.SendMessage( nMsg, wParam, lParam );
	}
	else
	{
		if (m_pStripList)
		{
			CallStripWMMessage( m_pStripList, nMsg, wParam, lParam );
		}
		else
		{
			lResult = FALSE;
		}
	}
 	return 0;
}

LRESULT CTimelineCtl::OnRealTime(WORD /*wNotifyCode*/, WORD wID, 
		HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	UNREFERENCED_PARAMETER( wID );
	if (m_pStripList)
	{
		CallStripWMMessage( m_pStripList, BN_CLICKED, BTN_REALTIME, 0 );
	}
 	return 0;
}

LRESULT CTimelineCtl::OnMusicTime(WORD /*wNotifyCode*/, WORD /*wID*/, 
		HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	if (m_pStripList)
	{
		CallStripWMMessage( m_pStripList, BN_CLICKED, BTN_MUSICTIME, 0 );
	}
 	return 0;
}

LRESULT CTimelineCtl::OnSize(UINT nMsg, WPARAM /* wParam */,
	LPARAM lParam, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	RECT rectSH, rectSV;
	RECT rectZoomIn, rectZoomOut;
	int nWidth = LOWORD(lParam);
	int nHeight = HIWORD(lParam);

	m_ScrollHorizontal.GetClientRect(&rectSH);
	m_ScrollVertical.GetClientRect(&rectSV);
	// move the vertical scroll bar to where it needs to go
	rectSV.bottom = nHeight - rectSH.bottom;
	rectSV.left = nWidth - rectSV.right;
	rectSV.right = nWidth;
	if( m_pStripList )
	{
		rectSV.top += m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH*2; // top of scroll bar begins at 2nd strip down
	}
	m_ScrollVertical.MoveWindow(&rectSV,TRUE);
	// move the horizontal scroll bar and zoom buttons to where they need to go
	m_BtnZoomIn.GetClientRect(&rectZoomIn);
	m_BtnZoomOut.GetClientRect(&rectZoomOut);
	rectSH.top = nHeight - rectSH.bottom;
	rectSH.bottom = nHeight;
	rectSH.right = nWidth - rectZoomIn.right - rectZoomOut.right;
	m_ScrollHorizontal.MoveWindow(&rectSH,TRUE);
	rectZoomIn.left = nWidth - rectZoomIn.right - rectZoomOut.right;
	rectZoomIn.right = nWidth - rectZoomOut.right;
	rectZoomIn.top = nHeight - rectZoomIn.bottom;
	rectZoomIn.bottom = nHeight;
	m_BtnZoomIn.MoveWindow(&rectZoomIn,TRUE);
	rectZoomOut.left = nWidth - rectZoomOut.right;
	rectZoomOut.right = nWidth;
	rectZoomOut.top = nHeight - rectZoomOut.bottom;
	rectZoomOut.bottom = nHeight;
	m_BtnZoomOut.MoveWindow(&rectZoomOut,TRUE);

	// resize the thumb
	ComputeScrollBars();
	int iTemp = 0;
	OnHScroll( 0, MAKELONG( SB_THUMBPOSITION, m_ScrollHorizontal.GetScrollPos() ), (LPARAM) ((HWND) m_ScrollHorizontal), iTemp );
	iTemp = 0;
	OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, m_ScrollVertical.GetScrollPos() ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );

	StripList* pTempSL;
	for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
	{
		CallStripWMMessage( pTempSL, nMsg, 0, 0 );
	}
	return 0;
}

void CTimelineCtl::GetStripClientRect( StripList* pSL, LPRECT pRect )
{
	// Display format:
	// BORDER_HORIZ_DRAWWIDTH
	// Strip
	// BORDER_HORIZ_DRAWWIDTH
	// Strip
	// BORDER_HORIZ_DRAWWIDTH
	// Strip
	// BORDER_HORIZ_DRAWWIDTH

	// BORDER_HORIZ_WIDTH == BORDER_HORIZ_DRAWWIDTH

	StripList* pList;
	RECT rect, rectSV, rectSH;
	long lMaxBottom;

	// Get a rect defining our window
	GetClientRect( &rect );
	// Get areas to exclude from the strip's rect
	m_ScrollVertical.GetClientRect( &rectSV );
	m_ScrollHorizontal.GetClientRect( &rectSH );
	// We want to include the function bar in the strip's rect
//	rect.left += m_lFunctionBarWidth;
	// Exclude the vertical scroll bar
	rect.right -= ( BORDER_VERT_WIDTH + rectSV.right );
	// Set a maximum limit on how far down a strip can display so it doesn't overwrite the
	// horizontal scrollbar
	lMaxBottom = rect.bottom - rectSH.bottom;
	// If we're getting the rect for the top strip
	if( pSL == m_pStripList )
	{
		rect.top = BORDER_HORIZ_WIDTH;
		rect.bottom = rect.top + pSL->m_lHeight;
	}
	else
	{
		// Set a minimum limit on how far up a strip can display so it doesn't overwrite the 
		// top strip.
		long lMinTop;
		lMinTop  = BORDER_HORIZ_WIDTH + m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH;
		// Offset everything by the timeline's vertical scroll position
		rect.top = -m_lYScrollPos;
		// Add up the heights of all strips above ours to set rect.top and rect.bottom
		for( pList = m_pStripList; pList; pList = pList->m_pNext )
		{
			rect.bottom = rect.top + pList->m_lHeight + BORDER_HORIZ_WIDTH;
			if( pList == pSL )
			{
				break;
			}
			// The previous's strip bottom is our top, except if the previous strip is the first
			// strip and there is a vertical scroll
			rect.top = rect.bottom;
		}
		rect.top += BORDER_HORIZ_WIDTH;
		// Ensure we don't overwrite the top strip
		if (rect.top < lMinTop)
		{
			rect.top = lMinTop;
		}
	}
	// Ensure we don't overwrite the horizontal scroll bar
	if (rect.bottom > lMaxBottom)
	{
		rect.bottom = lMaxBottom;
	}
	if (rect.top > rect.bottom)
	{
		rect.top = rect.bottom;
	}
	*pRect = rect;
}

void CTimelineCtl::SetMouseMode( long xPos, long yPos)
{
	StripList*	pSL;
	long yOrg = -m_lYScrollPos; // eventually this will need to take into account vertical scrolling
	VARIANT	var;

	// If we're beyond the end of time, set the cusor to MM_NORMAL, NULL m_pMouseStripList and return.
	if( xPos > m_lFunctionBarWidth )
	{
		long lXTime;
		PositionToClocks( xPos - m_lFunctionBarWidth + m_lXScrollPos - m_lLastEarlyPosition - m_lLastLatePosition, &lXTime );

		if( lXTime >= m_lLength )
		{
			m_MouseMode = MM_NORMAL;
			m_pMouseStripList = NULL;
			return;
		}
	}

	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( pSL == m_pStripList )
		{
			// the top strip doesn't scroll
			yOrg += m_lYScrollPos;
		}
		else if( pSL == m_pStripList->m_pNext )
		{
			yOrg -= m_lYScrollPos;
		}
		yOrg += pSL->m_lHeight + BORDER_HORIZ_WIDTH;

	// If the mouse is in the left gutter change to a right facing arrow. Return.
		if( ( xPos <= GUTTER_WIDTH ) && 
			( yPos > yOrg - pSL->m_lHeight - BORDER_HORIZ_WIDTH ) && 
			( yPos < yOrg + BORDER_HORIZ_WIDTH ) )
		{
			m_MouseMode = MM_GUTTER;
			m_pMouseStripList = pSL;
			return;
		}

	// If the mouse is between Strips, ask the top Strip if it can be resized.
	// If it can, change to a resize cursor. Return.
		else if( (yPos <= yOrg + BORDER_HORIZ_WIDTH) && (yPos >= yOrg) )
		{
			m_pMouseStripList = NULL;
			if (pSL->m_sv != SV_MINIMIZED)
			{
				if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_RESIZEABLE, &var )))
				{
					if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
					{
						m_MouseMode = MM_RESIZE;
						m_pMouseStripList = pSL;
						m_lResizeYPos = yOrg;
						m_lResizeOriginalYPos = m_lResizeYPos;
					}
				}
			}
			return;
		}

	// If the mouse is over where the minimize icon would be, ask the strip if it
	// is min/maxable.  If it is, change our state to MM_MINIMIZE. Return.
		else if( (yPos >= yOrg - pSL->m_lHeight ) && (yPos < yOrg - pSL->m_lHeight + m_sizeMinMaxButton.cy) )
		{
			// check for minimize if the strip is MinMaxable and is not already minimized
			VARIANT var;
			if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_MINMAXABLE, &var )))
			{
				if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
				{
					if ((pSL->m_sv == SV_NORMAL) || (pSL->m_sv == SV_MINIMIZED))
					{
						RECT rect, rectSV;
						GetClientRect( &rect );
						m_ScrollVertical.GetClientRect( &rectSV );
						rect.right -= ( BORDER_VERT_WIDTH + rectSV.right );
						long posLength;
						ClocksToPosition( m_lLength, &posLength );
						if( rect.right + m_lXScrollPos > posLength + m_lFunctionBarWidth + m_lLastEarlyPosition)
						{
							rect.right = posLength - m_lXScrollPos + m_lFunctionBarWidth + m_lLastEarlyPosition + MEASURE_LINE_WIDTH;
						}
						if ((xPos < rect.right) && (xPos > rect.right - m_sizeMinMaxButton.cx))
						{
							m_MouseMode = MM_MINMAX;
							m_pMouseStripList = pSL;
							return;
						}
					}
				}
			}
		}

	// if the mouse is inside of a strip, set a pointer to that strip so we
	// can capture it inside OnLButtonDown
		if ( ( yPos > yOrg - pSL->m_lHeight - BORDER_HORIZ_WIDTH ) && 
			( yPos < yOrg + BORDER_HORIZ_WIDTH ) )
		{
			// If the cursor is over the line between the fuction bar and strip, change to a resize cursor
			if ( abs(xPos - (m_lFunctionBarWidth-2)) < 2 )
			{
				m_pMouseStripList = NULL;
				m_MouseMode = MM_RESIZE_FN;
				// resize FunctionBar
				return;
			}

			// Otherwise, set m_pMouseStripList to the strip we're over
			m_pMouseStripList = pSL;
			break; // this break must be here or else the top strip might not get selected
		}
	}

	// Change back to a normal cursor.
	// This shouldn't be blithely overwriting somebody else's cursor because
	// if a strip wants its own cursor, m_MouseMode will be changed back
	// to MM_UNKNOWN in OnSetCursor (and the correct cursor will be
	// displayed there)
	if( m_MouseMode != MM_NORMAL )
	{
		m_MouseMode = MM_NORMAL;
	}

	if( pSL != NULL ) // Found a strip
	{
		if( xPos > m_lFunctionBarWidth )
		{
			VARIANT varTemp;

			// Check if we're in the pick-up bar
			if( xPos - m_lFunctionBarWidth < max( 0, m_lLastEarlyPosition - m_lXScrollPos ) )
			{
				// Check if the strip supports pick-up measures
				if( FAILED( pSL->m_pStrip->GetStripProperty( SP_EARLY_TIME, &varTemp ) ) )
				{
					// No - treat it as if the mouse is below all strips
					m_pMouseStripList = NULL;
					m_MouseMode = MM_NORMAL;
					return;
				}

				// Check if we're before the strip's pick-up measure
				long lEarlyPosition;
				ClocksToPosition( V_I4(&varTemp), &lEarlyPosition );
				if( xPos - m_lFunctionBarWidth < max( 0, m_lLastEarlyPosition - lEarlyPosition - m_lXScrollPos ) )
				{
					// Before the strip's pick-up bar - treat it as if the mouse is below all strips
					m_pMouseStripList = NULL;
					m_MouseMode = MM_NORMAL;
					return;
				}
			}
			// Check if we're in the extension bar
			else
			{
				long lTimelineLength;
				ClocksToPosition( m_lLength, &lTimelineLength );

				if( xPos - m_lFunctionBarWidth + m_lXScrollPos - m_lLastEarlyPosition >= lTimelineLength )
				{
					// Check if the strip supports extension measures
					if( FAILED( pSL->m_pStrip->GetStripProperty( SP_LATE_TIME, &varTemp ) ) )
					{
						// No - treat it as if the mouse is below all strips
						m_pMouseStripList = NULL;
						m_MouseMode = MM_NORMAL;
						return;
					}

					// Check if we're after the strip's extension measure
					long lLatePosition;
					ClocksToPosition( V_I4(&varTemp), &lLatePosition );
					if( xPos - m_lFunctionBarWidth + m_lXScrollPos - m_lLastEarlyPosition >= lLatePosition + lTimelineLength )
					{
						// After the strip's extension bar - treat it as if the mouse is below all strips
						m_pMouseStripList = NULL;
						m_MouseMode = MM_NORMAL;
						return;
					}
				}
			}
		}
	}
	else //if ( pSL == NULL ) // mouse is below all strips
	{
		m_pMouseStripList = NULL;
		m_MouseMode = MM_NORMAL;
	}
}

LRESULT CTimelineCtl::OnMouseMove(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	long yPos = HIWORD(lParam);
	long xPos = LOWORD(lParam);
	long yOrg = -m_lYScrollPos; // eventually this will need to take into account vertical scrolling
	long lResizeYOffset;
	RECT rect;

	// This message may belong to the Timeline or one of the Strips.

	// If a Strip has the mouse capture, send this message to the Strip. Return.
	if( m_fStripMouseCapture && m_pMouseStripList )
	{
		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
		return 0;
	}

	// if X position is negative, make xPos negative
	if( lParam & 0x8000 )
	{
		xPos = xPos | 0xFFFF0000;
	}

	// Compute which Strip is below the cursor.
	// If we're resizing a Strip we need to redraw the splitter line. Return.
	if( m_MouseMode == MM_ACTIVERESIZE )
	{
		if( yPos > 0xFF00 || !m_pMouseStripList )
		{
			return 0; // this is assuredly the mouse pointer going above the top of the window
		}
 
		VARIANT var;
		long lMinStripHeight = MIN_STRIP_HEIGHT;
		if( SUCCEEDED( m_pMouseStripList->m_pStrip->GetStripProperty( SP_MINHEIGHT, &var )))
		{
			lMinStripHeight = V_INT(&var);
		}

		// don't allow resize to go smaller than the minimum strip height
		if( yPos < m_lResizeOriginalYPos + lMinStripHeight - m_pMouseStripList->m_lHeight )
		{
			lResizeYOffset = m_lResizeOriginalYPos + lMinStripHeight
				- m_pMouseStripList->m_lHeight - m_lResizeYPos;
		}
		else
		{
			// don't allow resize to go greater than the maximum strip height
			if( SUCCEEDED( m_pMouseStripList->m_pStrip->GetStripProperty( SP_MAXHEIGHT, &var )))
			{
				if( yPos > m_lResizeOriginalYPos + V_INT(&var) - m_pMouseStripList->m_lHeight )
				{
					lResizeYOffset = m_lResizeOriginalYPos + V_INT(&var)
						- m_pMouseStripList->m_lHeight - m_lResizeYPos;
				}
				else
				{
					lResizeYOffset = yPos - m_lResizeYPos;
				}
			}
			else
			{
				lResizeYOffset = yPos - m_lResizeYPos;
			}
		}
		// Invalidate rect to erase old xor line and draw new one
		if( lResizeYOffset )
		{
			RECT rectSV;
			GetClientRect( &rect );
			m_ScrollVertical.GetClientRect( &rectSV );
			// invalidate area to draw xor line
			rect.right -= rectSV.right;
			rect.left = LEFT_DRAW_OFFSET;
			rect.top = m_lResizeYPos;
			rect.bottom = m_lResizeYPos + BORDER_HORIZ_WIDTH;
//			InvalidateRect( &rect, TRUE );
			InvalidateRect( &rect, FALSE );
			m_lResizeYPos += lResizeYOffset;
			rect.top = m_lResizeYPos;
			rect.bottom = m_lResizeYPos + BORDER_HORIZ_WIDTH;
//			InvalidateRect( &rect, TRUE );
			InvalidateRect( &rect, FALSE );
		}
		return 0;
	}
	// If we're resizing the function bar we need to redraw the splitter line. Return.
	else if( m_MouseMode == MM_ACTIVERESIZE_FN )
	{
		// don't allow resize to go smaller than the minimum function bar
		// width or larger than the maximum function bar widht
		if(( xPos >= MIN_FNBAR_WIDTH ) && ( xPos <= MAX_FNBAR_WIDTH))
		{
			m_lFunctionBarWidth = xPos;

			// Probably should calculate the area that will be affected
			// and only invalidate it.
			// Perhaps we could just 'scroll' the affected area to the
			// right and invalidate the small new area to be displayed

			// send WM_SIZE to all strips, letting them know something has changed size
			StripList* pSL = m_pStripList;
			while (pSL)
			{
				// BUGBUG: Should have meaningful values for lParam.
				CallStripWMMessage( pSL, WM_SIZE, SIZE_RESTORED, MAKELONG(0, pSL->m_lHeight) );
				pSL = pSL->m_pNext;
			}

			ComputeScrollBars();
			GetClientRect( &rect );
//			InvalidateRect( &rect, TRUE );
			InvalidateRect( &rect, FALSE );
		}
		return 0;
	}
	// if we've clicked in a gutter, set whichever strip we're on to m_fActiveGutterState.
	else if( m_MouseMode == MM_ACTIVEGUTTER )
	{
		SetMouseMode(xPos,yPos);
		if(m_pMouseStripList)
		{
			GetStripClientRect( m_pMouseStripList, &rect );
			yOrg = rect.bottom;
			if( ( xPos <= GUTTER_WIDTH ) && 
				( yPos > yOrg - m_pMouseStripList->m_lHeight - BORDER_HORIZ_WIDTH ) && 
				( yPos < yOrg + BORDER_HORIZ_WIDTH ) )
			{
				SetStripGutter( m_pMouseStripList, m_fActiveGutterState );
			}
		}

		// Reset m_MouseMode
		m_MouseMode = MM_ACTIVEGUTTER;
		return 0;
	}
	// If we're moving a Strip we need to see if we're over a different
	// Strip than before, and if so we need to redraw the splitter line
	// which appears across the lower border of the Strip where the Strip
	// we are dragging will go. (I.e. when we click a Strip's drag bar,
	// the bottom border of the Strip above the current Strip highlights.) Return.
	// If we've clicked on the minimize/maximize button, ignore all events until the
	// mouse button is released.
	else if( m_MouseMode == MM_ACTIVEMINMAX )
	{
		return 0;
	}

	SetMouseMode(xPos,yPos);
	// Then, send this message to the Strip beneath the cursor, if there is one.
	// Pass the message to the Strip below the cursor.
	if( m_pMouseStripList )
	{
		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
	}
	return 0;
}

LRESULT CTimelineCtl::OnMouseWheel(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	/*short fwKeys = LOWORD(wParam);
	short zDelta = HIWORD(wParam);
	short xPos = LOWORD(lParam);
	short yPos = HIWORD(lParam);*/
		
	if( m_pMouseStripList )
	{
		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
	}
	return 0;
}

bool IsStripInPatternTrack( IDMUSProdStrip *pStrip )
{
	bool fResult = false;
	if( pStrip )
	{
		VARIANT varStripMgr;
		if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
		&&	V_UNKNOWN(&varStripMgr) )
		{
			// Get an IDMUSProdStripMgr interface
			IDMUSProdStripMgr *pIStripMgr;
			if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pIStripMgr ) ) )
			{
				DMUS_IO_TRACK_HEADER ioTrackHeader;
				ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
				VARIANT varTrackHeader;
				varTrackHeader.vt = VT_BYREF;
				V_BYREF(&varTrackHeader) = &ioTrackHeader;
				if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
				{
					if( ioTrackHeader.guidClassID == CLSID_DirectMusicPatternTrack )
					{
						fResult = true;
					}
				}
				pIStripMgr->Release();

			}
			V_UNKNOWN(&varStripMgr)->Release();
		}
	}

	return fResult;
}

LRESULT CTimelineCtl::OnKeyDown(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	if( m_pTimeStrip )
	{
		long lNewCursorPos = LONG_MIN;
		switch( wParam )
		{
		case VK_INSERT:
		case VK_DELETE:
			// If the Ctrl key is down, but the shift and alt keys are up
			if( (0x8000 & GetKeyState( VK_CONTROL ))
			&&	!(0x8000 & GetKeyState( VK_SHIFT ))
			&&	!(0x8000 & GetKeyState( VK_MENU )) )
			{
				WPARAM wNewParam = MAKELONG( wParam == VK_DELETE ? ID_EDIT_DELETE_TRACK : ID_EDIT_ADD_TRACK, 1 );
				::SendMessage( GetParent(), WM_COMMAND, wNewParam, 0 );
				return 0;
			}
			break;
		case VK_HOME:
			lNewCursorPos = 0;
			break;
		case VK_END:
			lNewCursorPos = m_lLength - 1;
			break;
		case VK_LEFT:
		case VK_RIGHT:
			if( (m_pActiveStripList == NULL)
			||	!IsStripInPatternTrack(m_pActiveStripList->m_pStrip) )
			{
				// If the Ctrl key is down
				if( GetKeyState( VK_CONTROL ) & 0x8000 )
				{
					// Move by a measures
					if( BumpTimeCursor( wParam == VK_RIGHT, DMUSPROD_TIMELINE_SNAP_BAR ) )
					{
						return 0;
					}
				}
				else
				{
					// Otherwise, move by the snap-to setting
					if( BumpTimeCursor( wParam == VK_RIGHT, m_pTimeStrip->m_stSetting ) )
					{
						return 0;
					}
				}
			}
			break;
		}

		if( lNewCursorPos != LONG_MIN )
		{
			SetTimeCursor( min( lNewCursorPos, m_lLength - 1), m_pTimeStrip->m_fScrollWhenSettingTimeCursor, true );
			return 0;
		}
	}

	if( m_pActiveStripList )
	{
		CallStripWMMessage( m_pActiveStripList, nMsg, wParam, lParam );
	}
	return 0;
}

LRESULT CTimelineCtl::OnChar(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	static COLORREF acrCustomColors[16];
	static COLORREF crGreyColor = RGB( SHADING_DARK_COLOR, SHADING_DARK_COLOR, SHADING_DARK_COLOR );
	static COLORREF crYellowColor = RGB( 255, 255, 192 );

	if( m_strZoomInChars.Find( (TCHAR)wParam, 0 ) >= 0 )
	{
		BOOL bReturn;
		OnZoomIn( 0, 0, 0, bReturn );
		return 0;
	}
	else if( m_strZoomOutChars.Find( (TCHAR)wParam, 0 ) >= 0 )
	{
		BOOL bReturn;
		OnZoomOut( 0, 0, 0, bReturn );
		return 0;
	}
	else if( (wParam == 'g') || (wParam == 'G') )
	{
		CHOOSECOLOR cc;

		cc.lStructSize = sizeof(CHOOSECOLOR);
		cc.hwndOwner = m_hWnd;
		cc.hInstance = NULL;
		cc.rgbResult = crGreyColor; // initial color
		cc.lpCustColors = acrCustomColors;
		cc.Flags = CC_ANYCOLOR | CC_RGBINIT;
		cc.lCustData = NULL;
		cc.lpfnHook = NULL;
		cc.lpTemplateName = NULL;

		HWND hwndFocus = ::GetFocus();
		if (ChooseColor( &cc ))
		{
			// User chose a color
			crGreyColor = cc.rgbResult;

			// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
			DWORD dwColorBase = RGB( GetBValue(crGreyColor), GetGValue(crGreyColor), GetRValue(crGreyColor) );
			int iBScale = 255 - GetBValue(crGreyColor);
			int iGScale = 255 - GetGValue(crGreyColor);
			int iRScale = 255 - GetRValue(crGreyColor);
			for( long lIndex = 0; lIndex < 256; lIndex++ )
			{
				// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
				const DWORD dwColor = dwColorBase + RGB( (iBScale * lIndex) / 255, (iGScale * lIndex) / 255, (iRScale * lIndex) / 255 );
				m_adwNormalColor[lIndex] = dwColor;
			}

			Invalidate( FALSE );
		}
		if( ::GetFocus() != hwndFocus )
		{
			::SetFocus( hwndFocus );
		}
	}
	else if( (wParam == 'y') || (wParam == 'Y') )
	{
		CHOOSECOLOR cc;

		cc.lStructSize = sizeof(CHOOSECOLOR);
		cc.hwndOwner = m_hWnd;
		cc.hInstance = NULL;
		cc.rgbResult = crYellowColor; // initial color
		cc.lpCustColors = acrCustomColors;
		cc.Flags = CC_ANYCOLOR | CC_RGBINIT;
		cc.lCustData = NULL;
		cc.lpfnHook = NULL;
		cc.lpTemplateName = NULL;

		HWND hwndFocus = ::GetFocus();
		if (ChooseColor( &cc ))
		{
			// User chose a color
			crYellowColor = cc.rgbResult;

			// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
			DWORD dwColorBase = RGB( GetBValue(crYellowColor), GetGValue(crYellowColor), GetRValue(crYellowColor) );
			int iBScale = 255 - GetBValue(crYellowColor);
			int iGScale = 255 - GetGValue(crYellowColor);
			int iRScale = 255 - GetRValue(crYellowColor);
			for( long lIndex = 0; lIndex < 256; lIndex++ )
			{
				// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
				const DWORD dwColor = dwColorBase + RGB( (iBScale * lIndex) / 255, (iGScale * lIndex) / 255, (iRScale * lIndex) / 255 );
				m_adwActiveColor[lIndex] = dwColor;
			}

			Invalidate( FALSE );
		}
		if( ::GetFocus() != hwndFocus )
		{
			::SetFocus( hwndFocus );
		}
	}
	else if( m_pTimeStrip )
	{
		switch (wParam)
		{
		case 2: // Ctrl-B
			// Snap to bar
			m_pTimeStrip->SetSnapTo( DMUSPROD_TIMELINE_SNAP_BAR );
			return 0;
			break;
		case 5: // Ctrl-E
		// Snap to none
			m_pTimeStrip->SetSnapTo( DMUSPROD_TIMELINE_SNAP_NONE );
			return 0;
			break;
		case 7: // Ctrl-G
		// Snap to grid
			m_pTimeStrip->SetSnapTo( DMUSPROD_TIMELINE_SNAP_GRID );
			return 0;
			break;
		case 20: // Ctrl-T
		// Snap to beat
			m_pTimeStrip->SetSnapTo( DMUSPROD_TIMELINE_SNAP_BEAT );
			return 0;
			break;
		}
	}

	if( m_pActiveStripList )
	{
		CallStripWMMessage( m_pActiveStripList, nMsg, wParam, lParam );
	}
	return 0;
}

POINT CTimelineCtl::GetMousePoint() const
{
	POINT point;
	::GetCursorPos( &point );
	ScreenToClient( &point );
	return point;
}

LRESULT CTimelineCtl::OnSetCursor(UINT nMsg, WPARAM wParam,
	LPARAM /*lParam*/, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	POINT point;
	point = GetMousePoint(); // to get the point in our window that the cursor is at
	SetMouseMode( point.x, point.y ); // to set m_pMouseStripList

	if( m_pMouseStripList && ((m_MouseMode==MM_UNKNOWN) || (m_MouseMode==MM_NORMAL)) )
	{
		LPARAM lparam = MAKELONG( point.x, point.y );

		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lparam );

		// ask the Strip what it wants its cursor to be
		VARIANT var;
		if( SUCCEEDED( m_pMouseStripList->m_pStrip->GetStripProperty( SP_CURSOR_HANDLE, &var )))
		{
			HCURSOR hStripCursor;
			hStripCursor = (HCURSOR) V_I4(&var);
			if ( hStripCursor ) {
				SetCursor( hStripCursor);
				m_MouseMode = MM_UNKNOWN;
			}
			else 
				m_MouseMode = MM_NORMAL; // Null pointer -> use normal cursor
		}
	}
	// if a strip is not using its own cursor, and a strip does not have
	// capture, then set our own cursor
	if ((m_MouseMode != MM_UNKNOWN) && !(m_fStripMouseCapture && m_pMouseStripList))
	{
		switch(m_MouseMode) {
		case MM_NORMAL:
		case MM_MINMAX:
			{
				static HCURSOR hCursorArrow;
				if (!hCursorArrow)
					hCursorArrow = LoadCursor( NULL, IDC_ARROW );
				if( hCursorArrow )
					SetCursor( hCursorArrow );
			}
			break;
		case MM_ACTIVEGUTTER:
		case MM_GUTTER:
			{
				static HCURSOR hCursorRightArrow;
				if (!hCursorRightArrow)
					hCursorRightArrow = LoadCursor( AfxGetInstanceHandle( ), MAKEINTRESOURCE(IDC_RIGHTARROW) );
				if( hCursorRightArrow )
					SetCursor( hCursorRightArrow );
			}
			break;
		case MM_ACTIVERESIZE:
		case MM_RESIZE:
			{
				static HCURSOR hCursorSizeNS;
				if (!hCursorSizeNS)
					hCursorSizeNS = LoadCursor( NULL, IDC_SIZENS ); // North/south resize
				if( hCursorSizeNS )
					SetCursor( hCursorSizeNS );
			}
			break;
		case MM_ACTIVERESIZE_FN:
		case MM_RESIZE_FN:
			{
				static HCURSOR hCursorSizeWE;
				if (!hCursorSizeWE)
					hCursorSizeWE = LoadCursor( NULL, IDC_SIZEWE ); // West/east resize
				if( hCursorSizeWE )
					SetCursor( hCursorSizeWE );
			}
			break;
		default:
			break;
	}
	}
	
	return 0;
}

void CTimelineCtl::SetStripGutter( StripList* pSL, BOOL fSelect )
{
	ASSERT( pSL );

	// Check if the selection state would change
	if( pSL->m_fSelected != fSelect )
	{
		// Yes - Check if this strip support gutter selection
		VARIANT var;
		if( SUCCEEDED( m_pMouseStripList->m_pStrip->GetStripProperty( SP_GUTTERSELECTABLE, &var )))
		{
			if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
			{
				// This code is duplicated in StripSetTimelineProperty, with STP_GUTTER_SELECTED
				// Yep - change it's selection
				pSL->m_fSelected = fSelect;

				// Update the gutter display
				RECT rect;
				GetStripClientRect( pSL, &rect );
				rect.left = 0;
				rect.right = rect.left + GUTTER_WIDTH;
				InvalidateRect( &rect, FALSE );

				// Notify the strip
				var.vt = VT_BOOL;
				V_BOOL(&var) = (short)m_pMouseStripList->m_fSelected;
				m_pMouseStripList->m_pStrip->SetStripProperty( SP_GUTTERSELECT, var );
			}
		}
	}
}

void CTimelineCtl::DeactivateStripList(void)
{
	RECT rect;

	if( m_pActiveStripList )
	{
		GetStripClientRect( m_pActiveStripList, &rect );
		//rect.left = 0;
		//rect.right = rect.left + GUTTER_WIDTH;
		InvalidateRect( &rect, FALSE );
		StripList* pTempSL = m_pActiveStripList;
		m_pActiveStripList = NULL;
		CallStripWMMessage( pTempSL, WM_KILLFOCUS, 0, 0 );
	}
}

void CTimelineCtl::ActivateStripList( StripList* pSL )
{
	if( pSL != m_pActiveStripList )
	{
		RECT rect;
//		long lMaxHeight;

		if( m_pActiveStripList )
		{
			DeactivateStripList();
		}
		m_pActiveStripList = pSL;
		GetStripClientRect( pSL, &rect );
		//rect.left = 0;
		//rect.right = rect.left + GUTTER_WIDTH;
		InvalidateRect( &rect, FALSE );
		CallStripWMMessage( m_pActiveStripList, WM_SETFOCUS, 0, 0 );
	}
}

// the following is mostly copied from OnLButtonDown
LRESULT CTimelineCtl::OnLButtonDblclk(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the Strip has mouse capture, send it on.

	// If there are any other buttons down, we don't care about
	// this message, so pass it along to the Strip below the cursor. Return.

	// If we are a gutter cursor:
	if( m_MouseMode == MM_GUTTER )
	{
		m_MouseMode = MM_ACTIVEGUTTER;
		SetCapture();
		if( m_pMouseStripList )
		{
			// invalidate the rect to the left of m_pMouseStripList and toggle
			// m_pMouseStripList's selection.
			if(m_pMouseStripList->m_fSelected)
			{
				m_fActiveGutterState = FALSE;
			}
			else
			{
				m_fActiveGutterState = TRUE;
			}
			SetStripGutter( m_pMouseStripList, m_fActiveGutterState );
		}
		return 0;
	}

	if( (m_MouseMode != MM_MINMAX) && (m_pMouseStripList != NULL) )
	{
		VARIANT var;
		if (SUCCEEDED (m_pMouseStripList->m_pStrip->GetStripProperty( SP_MINMAXABLE, &var)) &&
			(var.vt == VT_BOOL) && (V_BOOL(&var) == TRUE) )
		{
			if (m_pMouseStripList->m_sv == SV_MINIMIZED)
			{
				m_pMouseStripList->m_lHeight = m_pMouseStripList->m_lRestoreHeight;
				m_pMouseStripList->m_sv = SV_NORMAL;

				RECT rectWin, rect;
				GetClientRect( &rectWin );
				GetStripClientRect( m_pMouseStripList, &rect );
				rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
//				InvalidateRect( &rectWin );
				InvalidateRect( &rectWin, FALSE );

				ComputeScrollBars();
				// If, as a result of the strip resize, the total height of the strips is less than the
				// height of the window, scroll back to the top.
				if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
				{
					int iTemp = 0;
					OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
				}
				// Tell this strip that it's been resized
				CallStripWMMessage( m_pMouseStripList, WM_SIZE, SIZE_MAXIMIZED, MAKELONG(0, m_pMouseStripList->m_lHeight) );

				// Tell all the strips below this one that they've moved.
				StripList* pTempSL;
				BOOL fDeleted = TRUE;
				for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
				{
					// Make sure that this strip hasn't been removed..
					if( pTempSL == m_pMouseStripList )
					{
						for( pTempSL = m_pMouseStripList->m_pNext; pTempSL; pTempSL = pTempSL->m_pNext )
						{
							CallStripWMMessage( pTempSL, WM_MOVE, 0, 0 );
						}
						fDeleted = FALSE;
						break;
					}
				}
				if( fDeleted )
				{
					// If it was deleted, send WM_MOVE to all strips because we don't know which strips to update anymore.
					for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
					{
						CallStripWMMessage( pTempSL, WM_MOVE, 0, 0 );
					}
				}
				return 0;
			}
			else if (m_pMouseStripList->m_sv == SV_NORMAL)
			{
				// Get a rectangle defining the size of the strip
				RECT rectStrip;
				GetStripClientRect( m_pMouseStripList, &rectStrip );

				 // Get the point in our window that the cursor is at
				POINT point;
				point = GetMousePoint();

				// Check if the point is vertically where the function name would be
				if( point.y < rectStrip.top + FUNCTION_NAME_HEIGHT )
				{
					int nExcludePixels = 0;
					VARIANT var;
					if( SUCCEEDED( m_pMouseStripList->m_pStrip->GetStripProperty( SP_FUNCTIONBAR_EXCLUDE_WIDTH, &var ) ) 
					&&	(var.vt == VT_I4) )
					{
						nExcludePixels = V_I4( &var );
					}

					// Check if the point is horizontally where the function name would be
					if( (point.x >= GUTTER_WIDTH + BORDER_VERT_DRAWWIDTH) &&
						(point.x < m_lFunctionBarWidth - nExcludePixels - BORDER_VERT_WIDTH) )
					{
						// Save the current height and change the strip's state to minimized
						m_pMouseStripList->m_lRestoreHeight = m_pMouseStripList->m_lHeight;
						m_pMouseStripList->m_sv = SV_MINIMIZED;

						// Get the desired minimized height - if the strip doesn't have a preference,
						// use the default MIN_STRIP_HEIGHT
						if (SUCCEEDED (m_pMouseStripList->m_pStrip->GetStripProperty( SP_MINIMIZE_HEIGHT, &var)))
						{
							m_pMouseStripList->m_lHeight = V_INT(&var);
						}
						else
						{
							m_pMouseStripList->m_lHeight = MIN_STRIP_HEIGHT;
						}

						// Get the rectangle defining the Timeline window
						RECT rectWin;
						GetClientRect( &rectWin );

						// This gets the new rectangle, based on the strip's new height
						GetStripClientRect( m_pMouseStripList, &rectStrip );

						// Refresh the window from the top of the changed strip on down.
						rectWin.top = rectStrip.top - BORDER_HORIZ_WIDTH;
						InvalidateRect( &rectWin, FALSE );

						ComputeScrollBars();

						// If, as a result of the strip resize, the total height of the strips is less than the
						// height of the window, scroll back to the top.
						// The can happen if the strip's maximized size is smaller than its minimized size
						if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
						{
							int iTemp = 0;
							OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
						}

						// Tell this strip that it's been resized
						CallStripWMMessage( m_pMouseStripList, WM_SIZE, SIZE_MINIMIZED, MAKELONG(0, m_pMouseStripList->m_lHeight) );

						// Tell all the strips below this one that they've moved.
						StripList* pTempSL;
						BOOL fDeleted = TRUE;
						for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
						{
							// Make sure that this strip hasn't been removed..
							// Curve strips remove themselves when the minimized.  There may be some
							// strip that removes itself (is replaced by another strip) when it is
							// maximized.
							if( pTempSL == m_pMouseStripList )
							{
								for( pTempSL = m_pMouseStripList->m_pNext; pTempSL; pTempSL = pTempSL->m_pNext )
								{
									CallStripWMMessage( pTempSL, WM_MOVE, 0, 0 );
								}
								fDeleted = FALSE;
								break;
							}
						}
						if( fDeleted )
						{
							// If it was deleted, send WM_MOVE to all strips because we don't know which strips to update anymore.
							for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
							{
								CallStripWMMessage( pTempSL, WM_MOVE, 0, 0 );
							}
						}
						return 0;
					}
				}
			}
		}
	}

	// Pass the message to the Strip below the cursor.
	if( m_pMouseStripList )
	{
		// first, make this is the active strip if it's not already
		ActivateStripList( m_pMouseStripList );
		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
	}
	return 0;		
}

/* Using this breaks selection for sequence, pattern, var switch, and curve strips
static bool fSetMarkerTime_Ignore_m_pMouseStripList = false;
*/

LRESULT CTimelineCtl::OnLButtonDown(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	RECT rect;
	SetFocus();

	// If the Strip has mouse capture, send it on.

	// If there are any other buttons down, we don't care about
	// this message, so pass it along to the Strip below the cursor. Return.

	// If we are a resize cursor, start the resize operation. Return.
	if( m_MouseMode == MM_RESIZE )
	{
		m_MouseMode = MM_ACTIVERESIZE;
		// capture the mouse so we don't lose the mouse button up
		SetCapture();
		// invalidate area to draw xor line
		GetClientRect( &rect );
		rect.top = m_lResizeYPos;
		rect.bottom = m_lResizeYPos + BORDER_HORIZ_WIDTH;
//		InvalidateRect( &rect, TRUE );
		InvalidateRect( &rect, FALSE );
		return 0;
	}
	// If we are a function bar resize cursor, start the resize operation. Return.
	if( m_MouseMode == MM_RESIZE_FN )
	{
		m_MouseMode = MM_ACTIVERESIZE_FN;
		// capture the mouse so we don't lose the mouse button up
		SetCapture();
		return 0;
	}
	// If we are a gutter cursor:
	if( m_MouseMode == MM_GUTTER )
	{
		m_MouseMode = MM_ACTIVEGUTTER;
		SetCapture();
		if( m_pMouseStripList )
		{
			// invalidate the rect to the left of m_pMouseStripList and toggle
			// m_pMouseStripList's selection.
			if(m_pMouseStripList->m_fSelected)
			{
				m_fActiveGutterState = FALSE;
			}
			else
			{
				m_fActiveGutterState = TRUE;
			}
			SetStripGutter( m_pMouseStripList, m_fActiveGutterState );
		}
		return 0;
	}
		// if the shift key is pressed, add the Strip and all Strips between the
		// Strip and the last chosen Strip (inclusive) to the local active Strip list
		// Otherwise, put only the Strip beneath the cursor in the local active Strip list
		// if the control key is pressed add the local Strip list to the global one.
		// Otherwise, replace the global active Strip list with the local one.
		// Return.
	
	// If we are over the minimize/maximize button:
	if( m_MouseMode == MM_MINMAX )
	{
		m_MouseMode = MM_ACTIVEMINMAX;
		HDC hdc = GetDC();
		if (hdc && m_pMouseStripList)
		{
				RECT rect;
				GetStripClientRect( m_pMouseStripList, &rect );
				long posLength;
				ClocksToPosition( m_lLength, &posLength );
				posLength -= m_lXScrollPos;
				if( rect.right > posLength + m_lFunctionBarWidth + m_lLastEarlyPosition )
				{
					rect.right = posLength + m_lFunctionBarWidth + m_lLastEarlyPosition + MEASURE_LINE_WIDTH;
				}
				if (m_pMouseStripList->m_sv == SV_NORMAL)
				{
					//dc.DrawState(CPoint( rect.right - m_sizeMinMaxButton.cx, rect.top ), m_sizeMinMaxButton, &m_BitmapMinimized, DSS_NORMAL);
					::DrawState( hdc, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapMinimized.GetSafeHandle() ), NULL,
						rect.right - m_sizeMinMaxButton.cx, rect.top, m_sizeMinMaxButton.cx, m_sizeMinMaxButton.cy,
						DST_BITMAP| DSS_NORMAL );
				}
				else if (m_pMouseStripList->m_sv == SV_MINIMIZED)
				{
					//dc.DrawState(CPoint( rect.right - m_sizeMinMaxButton.cx, rect.top ), m_sizeMinMaxButton, &m_BitmapMaximized, DSS_NORMAL);
					::DrawState( hdc, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapMaximized.GetSafeHandle() ), NULL,
						rect.right - m_sizeMinMaxButton.cx, rect.top, m_sizeMinMaxButton.cx, m_sizeMinMaxButton.cy,
						DST_BITMAP| DSS_NORMAL );
				}
		}

		// Release the DC
		::ReleaseDC(m_hWnd, hdc);

		// capture the mouse so we don't lose the mouse button up
		SetCapture();
		return 0;
	}

	// Pass the message to the Strip below the cursor.
	if( m_pMouseStripList )
	{
		// first, make this the active strip if it's not already
		ActivateStripList( m_pMouseStripList );

		/* Using this breaks selection for sequence, pattern, var switch, and curve strips
		fSetMarkerTime_Ignore_m_pMouseStripList = true;
		SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
		SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
		fSetMarkerTime_Ignore_m_pMouseStripList = false;
		*/

		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
	}
	return 0;		
}

LRESULT CTimelineCtl::OnRButtonDown(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetFocus();

	// Pass the message to the Strip below the cursor.
	if( m_pMouseStripList )
	{
		// first, make this the active strip if it's not already
		ActivateStripList( m_pMouseStripList );
		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
	}
	return 0;		
}

// this function makes it so things are compressed more.
LRESULT CTimelineCtl::OnZoomOut(WORD /*wNotifyCode*/, WORD /*wID*/, 
		HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// See how many pixels a measure displays in
	// BUGBUG: hardcoded at 4 quarter notes
	long pos;
	ClocksToPosition( DMUS_PPQ * 4, &pos );

	if( pos > MIN_MEASURE_PIXELS ) // if we're trying to view an entire measure in under 10 pixels, forget it
	{
		// Compute the pixel position of the cursor
		long lOffset;
		ClocksToPosition( m_lCursor, &lOffset );

		// Offset it so we have the number of pixels from the left edge of the strip display
		lOffset -= m_lXScrollPos - m_lLastEarlyPosition;

		// Change the zoom level
		m_dblZoom *= .8;

		// Compute pixel position of the cursor
		long lNewCursorPos;
		ClocksToPosition( m_lCursor, &lNewCursorPos );

		// Scroll so the cursor position is constant
		ScrollToPosition( lNewCursorPos - lOffset );
		m_lXScrollPos = lNewCursorPos - lOffset;

		//ComputeXScrollPos();
		ComputeScrollBars();
		InvalidateRect(NULL, FALSE);
	}

	// Set focus back to the timeline (away from the zoom out button)
	SetFocus();
	return 0;
}

// this function makes it so things are spread out more.
LRESULT CTimelineCtl::OnZoomIn(WORD /*wNotifyCode*/, WORD /*wID*/, 
		HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check to see how many pixels a measure is displayed in
	// BUGBUG: hardcoded at four quarter notes
	long pos;
	ClocksToPosition( DMUS_PPQ * 4, &pos );
	if( pos < MAX_MEASURE_PIXELS ) // a measure maxes out at 2000 pixels
	{
		// Compute the pixel position of the cursor
		long lOffset;
		ClocksToPosition( m_lCursor, &lOffset );

		// Offset it so we have the number of pixels from the left edge of the strip display
		lOffset -= m_lXScrollPos - m_lLastEarlyPosition;

		// Change the zoom level
		m_dblZoom /= .8;

		// Compute pixel position of the cursor
		long lNewCursorPos;
		ClocksToPosition( m_lCursor, &lNewCursorPos );

		// Scroll so the cursor position is constant
		ScrollToPosition( lNewCursorPos - lOffset );
		m_lXScrollPos = lNewCursorPos - lOffset;

		//ComputeXScrollPos( lCenterPos );
		ComputeScrollBars();
		InvalidateRect(NULL, FALSE);
	}

	// Set focus back to the timeline (away from the zoom in button)
	SetFocus();
	return 0;
}

// This just tells Windows that we don't need it to erase the background for us.
// This is OK because we erase the background in OnDrawAdvanced().
LRESULT CTimelineCtl::OnEraseBkgnd(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */)
{
	return FALSE;
}

LRESULT CTimelineCtl::OnContextMenu(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	if( m_pMouseStripList )
	{
		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
	}
	return 0;
}

LRESULT CTimelineCtl::OnLButtonUp(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& lResult )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	RECT	rectStrip, rectWin;

	ReleaseCapture();
	m_fStripMouseCapture = FALSE;
	// if we have been resizing a strip, complete the resize operation.
	if( m_MouseMode == MM_ACTIVERESIZE )
	{
		m_MouseMode = MM_RESIZE;
		if( !m_pMouseStripList )
		{
			return 0;
		}
		StripList*	pSL;
		pSL = m_pMouseStripList;
		pSL->m_lHeight += (m_lResizeYPos - m_lResizeOriginalYPos);
		// send WM_SIZE to the strip, letting it know it has changed size
		// BUGBUG: Should have meaningful values for lParam.
		CallStripWMMessage( pSL, WM_SIZE, SIZE_RESTORED, MAKELONG(0, pSL->m_lHeight) );
		ComputeDrawingArea( &rectWin );
		GetStripClientRect( pSL, &rectStrip );
		rectStrip.top -= BORDER_HORIZ_WIDTH;
		rectStrip.bottom = rectWin.bottom;
		rectStrip.right = rectWin.right + BORDER_VERT_WIDTH;
		rectStrip.left = 0;
//		InvalidateRect( &rectWin );
		InvalidateRect( &rectStrip, FALSE );
		ComputeScrollBars();
		// If, as a result of the strip resize, the total height of the strips is less than the
		// height of the window, scroll back to the top.
		if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
		{
			int iTemp = 0;
			OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
		}
		// Tell all the strips below this one that they've moved.
		StripList* pTempSL;
		for( pTempSL = m_pMouseStripList->m_pNext; pTempSL; pTempSL = pTempSL->m_pNext )
		{
			CallStripWMMessage( pTempSL, WM_MOVE, 0, 0 );
		}
	}
	else if( m_MouseMode == MM_ACTIVERESIZE_FN )
	{
		//StripList*	pSL;
		m_MouseMode = MM_RESIZE_FN;
		/*pSL = m_pMouseStripList;
		pSL->m_lHeight += (m_lResizeYPos - m_lResizeOriginalYPos);
		GetClientRect( &rectWin );
		GetStripClientRect( pSL, &rectStrip );
		rectWin.top = rectStrip.top - BORDER_HORIZ_WIDTH;
//		InvalidateRect( &rectWin );
		InvalidateRect( &rectWin, FALSE );
		ComputeScrollBars();*/
	}
	else if( m_MouseMode == MM_ACTIVEGUTTER )
	{
		m_MouseMode = MM_GUTTER;
	}
	else if( m_MouseMode == MM_ACTIVEMINMAX )
	{
		m_MouseMode = MM_MINMAX;
		if( !m_pMouseStripList )
		{
			return 0;
		}

		// Get the rectangle defining the Timeline window
		GetClientRect( &rectWin );

		// toggle a strips's minimize state
		if (m_pMouseStripList->m_sv == SV_MINIMIZED)
		{
			m_pMouseStripList->m_lHeight = m_pMouseStripList->m_lRestoreHeight;
			m_pMouseStripList->m_sv = SV_NORMAL;
			GetStripClientRect( m_pMouseStripList, &rectStrip );
			rectWin.top = rectStrip.top - BORDER_HORIZ_WIDTH;
			InvalidateRect( &rectWin, FALSE );
			ComputeScrollBars();
			// If, as a result of the strip resize, the total height of the strips is less than the
			// height of the window, scroll back to the top.
			if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
			{
				int iTemp = 0;
				OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
			}
			// Tell this strip that it's been resized
			CallStripWMMessage( m_pMouseStripList, WM_SIZE, SIZE_MAXIMIZED, MAKELONG(0, m_pMouseStripList->m_lHeight) );
		}
		else if (m_pMouseStripList->m_sv == SV_NORMAL)
		{
			m_pMouseStripList->m_lRestoreHeight = m_pMouseStripList->m_lHeight;
			m_pMouseStripList->m_sv = SV_MINIMIZED;
			VARIANT var;
			if (SUCCEEDED (m_pMouseStripList->m_pStrip->GetStripProperty( SP_MINIMIZE_HEIGHT, &var)))
			{
				m_pMouseStripList->m_lHeight = V_INT(&var);
			}
			else
			{
				m_pMouseStripList->m_lHeight = MIN_STRIP_HEIGHT;
			}

			// This gets the new rectangle, based on the strip's new height
			GetStripClientRect( m_pMouseStripList, &rectStrip );

			// Refresh the window from the top of the changed strip on down.
			rectWin.top = rectStrip.top - BORDER_HORIZ_WIDTH;
			InvalidateRect( &rectWin, FALSE );

			ComputeScrollBars();

			// If, as a result of the strip resize, the total height of the strips is less than the
			// height of the window, scroll back to the top.
			// The can happen if the strip's maximized size is smaller than its minimized size
			if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
			{
				int iTemp = 0;
				OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
			}

			// Tell this strip that it's been resized
			CallStripWMMessage( m_pMouseStripList, WM_SIZE, SIZE_MINIMIZED, MAKELONG(0, m_pMouseStripList->m_lHeight) );
		}
		// Tell all the strips below this one that they've moved.
		StripList* pTempSL;
		BOOL fDeleted = TRUE;
		for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
		{
			// Make sure that this strip hasn't been removed..
			if( pTempSL == m_pMouseStripList )
			{
				for( pTempSL = m_pMouseStripList->m_pNext; pTempSL; pTempSL = pTempSL->m_pNext )
				{
					CallStripWMMessage( pTempSL, WM_MOVE, 0, 0 );
				}
				fDeleted = FALSE;
				break;
			}
		}
		if( fDeleted )
		{
			// If it was deleted, send WM_MOVE to all strips because we don't know which strips to update anymore.
			for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
			{
				CallStripWMMessage( pTempSL, WM_MOVE, 0, 0 );
			}
		}
	}
	else
	{
		// Pass the message to the Strip below the cursor.
		if( m_pMouseStripList )
		{
			CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
			OnMouseMove( WM_MOUSEMOVE, wParam, lParam, lResult);
		}
	}
	return 0;
}

LRESULT CTimelineCtl::OnRButtonUp(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// This was copied from OnLButtonUp.  Currently all it does is pass the message
	// to the strip which is currently receiving mouse messages.
	// WM_RBUTTONDOWN does not currently capture the mouse, but it doesn't hurt to 
	// try and release the mouse capture

	ReleaseCapture();
	m_fStripMouseCapture = FALSE;

	// Pass the message to the Strip below the cursor.
	if( m_pMouseStripList )
	{
		CallStripWMMessage( m_pMouseStripList, nMsg, wParam, lParam );
	}
	else if( SUCCEEDED( GetParam( GUID_Segment_DisplayContextMenu, 0xFFFFFFFF, 0, 0, NULL, &lParam ) ) )
	{
		// Display a right-click context menu.

		// Get the cursor position (To put the menu there)
		POINT pt;
		if( GetCursorPos( &pt ) )
		{
			// Display the menu
			TrackPopupMenu(NULL, pt.x, pt.y, NULL, TRUE);
		}
	}
	return 0;
}

void CTimelineCtl::ComputeDrawingArea( LPRECT pRect ) const
{
	// Get the Timeline's client rectangle
	GetClientRect( pRect );

	// Get the client rectangles for the scrollbars
	RECT rectSH, rectSV;
	m_ScrollHorizontal.GetClientRect( &rectSH );
	m_ScrollVertical.GetClientRect( &rectSV );

	// offset the left edge to mask out the functionbar
	pRect->left += m_lFunctionBarWidth;

	// check that there is some horizontal viewing space
	ASSERT( pRect->right > BORDER_VERT_WIDTH + rectSV.right );

	// Mask off the vertical scrollbar and vertical border
	pRect->right -= ( BORDER_VERT_WIDTH + rectSV.right );

	// Maxk off the horizontal scrollbar, and ensure the visible area isn't negative
	pRect->bottom = max( 0, pRect->bottom - rectSH.bottom );
}

long CTimelineCtl::PositionToXScroll( long lPos )
{
	// Compute the drawing rectangle of the Timeline (strips off scrollbars and function bar)
	RECT rect;
	ComputeDrawingArea( &rect );

	// Compute the number of pixels in length the Timeline is
	long lPosLength;
	ClocksToPosition( m_lLength, &lPosLength );

	// Add on the early and late amounts, then subtract off the number of visible pixels
	lPosLength += m_lLastEarlyPosition + m_lLastLatePosition - (rect.right - rect.left);

	// Check if there's any need to scroll
	if(lPosLength > 0)
	{
		// Convert from a pixel position to a % of MAX_SCROLL
		return ( lPos * MAX_SCROLL ) / lPosLength;
	}
	else
	{
		return 0;
	}
}

LRESULT CTimelineCtl::OnHScroll(UINT /* nMsg */, WPARAM wParam,
	LPARAM /* lParam */, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nScrollCode = (int) LOWORD(wParam);  // scroll bar value 
	long nPos = m_ScrollHorizontal.GetScrollPos();   // scroll box position
	long nScrollAmount = 0;
	RECT rect;
	long lMaxScroll;

	// Compute the strip drawing area
	ComputeDrawingArea( &rect );

	// Compute how much to scroll (offset stored in nScrollAmount or position in nPos)
	switch( nScrollCode )
	{
	case SB_LEFT:
	case SB_RIGHT:
		break;
	case SB_LINELEFT:
		// BUGBUG: hardcoded at one quarter note
		ClocksToPosition( DMUS_PPQ, &nScrollAmount);
		nScrollAmount = min( -1, -PositionToXScroll(nScrollAmount) );
		break;
	case SB_LINERIGHT:
		// BUGBUG: hardcoded at one quarter note
		ClocksToPosition( DMUS_PPQ, &nScrollAmount);
		nScrollAmount = max( 1, PositionToXScroll(nScrollAmount) );
		break;
	case SB_PAGELEFT:
		nScrollAmount = -( PositionToXScroll(rect.right - rect.left) * 3 / 4 );
		break;
	case SB_PAGERIGHT:
		nScrollAmount = PositionToXScroll(rect.right - rect.left) * 3 / 4;
		break;
	case SB_THUMBTRACK:
		m_fHScrollTracking = TRUE;
		nPos = (short int) HIWORD(wParam);
		break;
	case SB_THUMBPOSITION:
		m_fHScrollTracking = FALSE;
		nPos = (short int) HIWORD(wParam);
		break;
	case SB_ENDSCROLL:
	default:
		return 1;
	}

	// Get the maximum scroll position
	lMaxScroll = m_ScrollHorizontal.GetScrollLimit();

	// Update nPos, ensuring we don't go beyond the maximum scroll value or below zero
	nPos = max( 0, min( lMaxScroll, nPos + nScrollAmount ) );

	// Update the scrollbar position
	m_ScrollHorizontal.SetScrollPos(nPos);

	// Compute the new X scroll position
	long lNewXScrollPos = ComputeXScrollPos();

	// Check if the X scroll position actually changed
	if( m_lXScrollPos != lNewXScrollPos )
	{
		// Yes - update it
		m_lXScrollPos = lNewXScrollPos;

		// send WM_HSCROLL to all strips, letting them know they have scrolled
		StripList* pSL = m_pStripList;
		while (pSL)
		{
			// BUGBUG: Should have meaningful values for wParam and lParam.
			CallStripWMMessage( pSL, WM_HSCROLL, 0 /*wParam*/, 0 /*lParam*/ );
			pSL = pSL->m_pNext;
		}

		// Redraw the entire Timeline
		InvalidateRect(&rect, FALSE);
	}

	// This is commented out because it looks very bad when we're usin overlayed icons,
	// sunch as the min/max button or the variation choices buttons
	/*
	ScrollWindow( lOriginalPos - m_lXScrollPos, 0, &rect, &rect );

	StripList* pSL;
	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		VARIANT var;
		if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_MINMAXABLE, &var )))
		{
			if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
			{
				if ((pSL->m_sv == SV_NORMAL) || (pSL->m_sv == SV_MINIMIZED))
				{
					RECT rectStrip;
					GetStripClientRect(pSL, &rectStrip);
					long posLength;
					ClocksToPosition( m_lLength, &posLength );
					posLength += m_lFunctionBarWidth; 
					if( (posLength - m_lXScrollPos > rectStrip.right) ||
						(posLength - lOriginalPos > rectStrip.right))
					{
						// invalidate where button will go
						rectStrip.left = rectStrip.right - 16;
						rectStrip.bottom = rectStrip.top + 14;
						InvalidateRect( &rectStrip, FALSE);
					}
					if (lOriginalPos < m_lXScrollPos)
					{
						// invalidate where button used to be
						rectStrip.left += lOriginalPos - m_lXScrollPos;
						rectStrip.right = rectStrip.left + 16;
//						InvalidateRect( &rectStrip, TRUE);
						InvalidateRect( &rectStrip, FALSE);
					}
				}
			}
		}
	}
	*/
	return 0;
}

LRESULT CTimelineCtl::OnVScroll(UINT nMsg, WPARAM wParam,
	LPARAM lParam, BOOL& /* lResult */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HWND hwndScrollBar = (HWND)lParam;

	if( hwndScrollBar == m_ScrollVertical )
	{
		int nScrollCode = (int) LOWORD(wParam);  // scroll bar value 
		long nPos;
		RECT rect;
		RECT rectSH, rectSV;
		long lMaxBarScroll, lMaxStripScroll;//,lScrollAmount
		nPos = m_ScrollVertical.GetScrollPos();
		GetClientRect( &rect );
		m_ScrollHorizontal.GetClientRect( &rectSH );
		m_ScrollVertical.GetClientRect( &rectSV );
		rect.right -= rectSV.right;
		rect.bottom -= rectSH.bottom;
		if( m_pStripList )
		{
			// don't scroll top strip (usually the time strip)
			rect.top += m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH*2;
		}
		
		// Get the maximum scroll bar thumb position
		lMaxBarScroll = m_ScrollVertical.GetScrollLimit();
		
		// Get the height of all strips
		lMaxStripScroll = TotalStripHeight();
		// subtract off the top strip
		if ( m_pStripList )
		{
			lMaxStripScroll -= m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH;
		}
		// subtract the height of the viewing region
		lMaxStripScroll -= rect.bottom - rect.top;

		if (lMaxStripScroll < 0)
		{
			lMaxStripScroll = 0;
		}
		//lScrollAmount = m_lYScrollPos;

		if (lMaxStripScroll > 0)
		{
			switch( nScrollCode )
			{
			case SB_TOP:
				break;
			case SB_LINEDOWN:
				nPos = lMaxBarScroll * ( m_lYScrollPos + (long)(20)) / lMaxStripScroll;
				break;
			case SB_LINEUP:
				nPos = lMaxBarScroll * ( m_lYScrollPos - (long)(20)) / lMaxStripScroll;
				break;
			case SB_PAGEDOWN:
				nPos = lMaxBarScroll * ( m_lYScrollPos + (long)(rect.bottom - rect.top)) / lMaxStripScroll;
				break;
			case SB_PAGEUP:
				nPos = lMaxBarScroll * ( m_lYScrollPos - (long)(rect.bottom - rect.top)) / lMaxStripScroll;
				break;
			case SB_THUMBPOSITION:
			case SB_THUMBTRACK:
				nPos = (short int) HIWORD(wParam);
				break;
			case SB_BOTTOM:
				break;
			case SB_ENDSCROLL:
			default:
				return 1;
			}
		}
		if( nPos < 0 ) nPos = 0;
		if( nPos > lMaxBarScroll ) nPos = (short)lMaxBarScroll;
		m_ScrollVertical.SetScrollPos(nPos);

		long lNewYScrollPos;
		if (lMaxBarScroll > 0)
		{
			lNewYScrollPos = nPos * lMaxStripScroll / lMaxBarScroll;
		}
		else
		{
			lNewYScrollPos = 0;
		}

		if( lNewYScrollPos != m_lYScrollPos )
		{
			m_lYScrollPos = lNewYScrollPos;

			// send WM_VSCROLL to all strips, letting them know they have scrolled
			StripList* pSL = m_pStripList;
			while (pSL)
			{
				// BUGBUG: Should have meaningful values for wParam and lParam.
				CallStripWMMessage( pSL, WM_VSCROLL, 0 /*wParam*/, 0 /*lParam*/ );
				pSL = pSL->m_pNext;
			}

			// By invalidating ourself, we get rid of the flicker of the minimize buttons.
			InvalidateRect(&rect, FALSE);

			// This causes the minimize buttons to flicker
			//lScrollAmount -= m_lYScrollPos;
			//ScrollWindow( 0, lScrollAmount, &rect, &rect );
		}
	}
	else
	{
		::SendMessage( hwndScrollBar, nMsg, wParam, lParam );
	}
	return FALSE; // Handled
}

long CTimelineCtl::ComputeXScrollPos()
{
	long lPos = m_ScrollHorizontal.GetScrollPos();
	long lMaxScroll;

	lMaxScroll = m_ScrollHorizontal.GetScrollLimit();

	// Compute the drawing rectangle of the Timeline (strips off scrollbars and function bar)
	RECT rect;
	ComputeDrawingArea( &rect );

	// Compute the number of pixels in length the Timeline is
	long lPosLength;
	ClocksToPosition( m_lLength, &lPosLength );

	// Add on the early and late amounts, then subtract off the number of visible pixels
	lPosLength += m_lLastEarlyPosition + m_lLastLatePosition - (rect.right - rect.left);

	// lPos / lMaxScroll = % of way scrolled
	// lPosLength - width of drawing rectangle = range we can scroll

	// Check if there's any need to scroll
	double dbl = 0;
	if( lMaxScroll > 0 )
	{
		// Convert from a % of lMaxScroll to a pixel position
		dbl = ((double) lPos / (double) lMaxScroll) * double(lPosLength);
	}
	
	if( dbl <= 0 )
	{
		return 0; // don't allow it to scroll left past the beginning
	}

	return (long)( dbl + 0.5);
}

void CTimelineCtl::ScrollToPosition( long lPos )
{
	long lScrollPos;
	double	dbl;
	long lMaxScroll;

	lMaxScroll = m_ScrollHorizontal.GetScrollLimit();

	// Compute the drawing rectangle of the Timeline (strips off scrollbars and function bar)
	RECT rect;
	ComputeDrawingArea( &rect );

	// Compute the number of pixels in length the Timeline is
	long lPosLength;
	ClocksToPosition( m_lLength, &lPosLength );

	// Add on the early and late amounts, then subtract off the number of visible pixels
	lPosLength += m_lLastEarlyPosition + m_lLastLatePosition - (rect.right - rect.left);

	// lPosLength - width of drawing rectangle = range we can scroll
	// lPos * range we can scroll = % of way scrolled
	// Multiply this % by lMaxScroll to get the thumb position

	// Check if there's any need to scroll
	if(lPosLength > 0)
	{
		// Convert from a pixel position to a % of lMaxScroll
		dbl = (double(lPos) * double(lMaxScroll)) / double (lPosLength);

		lScrollPos = long( dbl + 0.5 );
		if (lScrollPos < 0)
		{
			lScrollPos = 0;
		}
	}
	else
	{
		lScrollPos = 0;
	}

	int iTemp = 0;
	OnHScroll( 0, MAKELONG( SB_THUMBPOSITION, lScrollPos ), 0, iTemp );
}

HRESULT CTimelineCtl::OnDrawAdvanced(ATL_DRAWINFO& di)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	long lEarlyPosition, lLatePosition;
	ComputeEarlyAndLateTime( lEarlyPosition, m_lLastLateTime );
	ClocksToPosition( lEarlyPosition, &lEarlyPosition );
	ClocksToPosition( m_lLastLateTime, &lLatePosition );

	if( lEarlyPosition != m_lLastEarlyPosition )
	{
		m_lXScrollPos = max( 0, m_lXScrollPos + lEarlyPosition - m_lLastEarlyPosition);
		m_lLastEarlyPosition = lEarlyPosition;
		if( lLatePosition != m_lLastLatePosition )
		{
			m_lXScrollPos = min( m_lLength + lLatePosition + lEarlyPosition, m_lXScrollPos );
			m_lLastLatePosition = lLatePosition;
		}
		InvalidateRect(NULL, FALSE);
		ComputeScrollBars();
		return S_OK;
	}

	if( lLatePosition != m_lLastLatePosition )
	{
		m_lXScrollPos = min( m_lLength + lLatePosition + lEarlyPosition, m_lXScrollPos );
		m_lLastLatePosition = lLatePosition;
		InvalidateRect(NULL, FALSE);
		ComputeScrollBars();
		return S_OK;
	}

	CRect rc(*(RECT*)di.prcBounds);
	CDC realDC;
	if( realDC.Attach( di.hdcDraw ) )
	{
//////////////////////////////////////////////////////////////////////////////////
		CBitmap		bmBlank;
		CRect		rcClientArea;
		
		realDC.GetClipBox(&rcClientArea);
		//GetClientRect(&rcClientArea);
		
		BOOL bStatus = bmBlank.CreateCompatibleBitmap(&realDC, rcClientArea.right, rcClientArea.bottom);
		//BOOL bStatus = bmBlank.CreateCompatibleBitmap(&realDC, rcClientArea.right - rcClientArea.left, rcClientArea.bottom - rcClientArea.top);
		if (!bStatus)
		{
			realDC.Detach();
			return E_FAIL;
		}
		
		// create a memory dc so that we can draw by doing one blt to the screen.
		CDC dc;
		bStatus = dc.CreateCompatibleDC(&realDC);
		if (!bStatus)
		{
			realDC.Detach();
			return E_FAIL;
		}
		
		//select an empty bitmap into the dc. 
		CBitmap* pOldbm = dc.SelectObject(&bmBlank);
		if (!pOldbm)
		{
			dc.DeleteDC();
			realDC.Detach();
			return E_FAIL;
		}

		CRgn* pRgn = new CRgn;
		if (!pRgn)
		{
			dc.DeleteDC();
			realDC.Detach();
			return E_FAIL;
		}
		pRgn->CreateRectRgnIndirect( rcClientArea );
		dc.SelectClipRgn( pRgn );
		
		// draw the background. 
		dc.FillSolidRect(rcClientArea, GetSysColor(COLOR_WINDOW));

		// Get the name of the font to use for the strip names
		CString strFontName;
		if( !strFontName.LoadString(IDS_DRAGBAR_FONTNAME) )
		{
			strFontName = "Times New Roman";
		}

		LOGFONT lf;
		ZeroMemory( &lf, sizeof(LOGFONT));
		lf.lfHeight = FUNCTION_NAME_HEIGHT;
		//lf.lfWidth = 0;
		//lf.lfEscapement = 0;
		//lf.lfOrientation = 0;
		lf.lfWeight = 700;
		//lf.lfItalic = FALSE;
		//lf.lfUnderline = FALSE;
		//lf.lfStrikeOut = FALSE;
		//lf.lfCharSet = ANSI_CHARSET;
		//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		//lf.lfQuality = DEFAULT_QUALITY;
		//lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
		int nLength = min( strFontName.GetLength(), 31 );
		memcpy( lf.lfFaceName, (LPCTSTR)strFontName, nLength );
		
		CFont fontStripName;
		if ( !fontStripName.CreateFontIndirect( &lf ) )
		{
			dc.DeleteDC();
			realDC.Detach();
			return E_FAIL;
		}

		lf.lfHeight = STRIP_NAME_HEIGHT;

		CFont fontStrip;
		if( !fontStrip.CreateFontIndirect( &lf ) )
		{
			fontStripName.DeleteObject();
			dc.DeleteDC();
			realDC.Detach();
			return E_FAIL;
		}

		CPen penHorizFnBar;
		if( !penHorizFnBar.CreatePen( PS_SOLID, BORDER_HORIZ_DRAWWIDTH, dc.GetNearestColor( BORDER_COLOR ) ) )
		{
			fontStrip.DeleteObject();
			fontStripName.DeleteObject();
			dc.DeleteDC();
			realDC.Detach();
			return E_FAIL;
		}

		CPen penVertFnBar;
		if( !penVertFnBar.CreatePen( PS_SOLID, BORDER_VERT_DRAWWIDTH, dc.GetNearestColor( BORDER_COLOR ) ) )
		{
			penHorizFnBar.DeleteObject();
			fontStrip.DeleteObject();
			fontStripName.DeleteObject();
			dc.DeleteDC();
			realDC.Detach();
			return E_FAIL;
		}

//////////////////////////////////////////////////////////////////////////////////
		// call each Strip's Draw routine
		StripList*	pSL;
		int			iSavedDC;
		CRect		rectClip, rectSV, rectSH;
		CRgn		rgn;
		CBrush		brushBorder;
		long		lRightBounds = di.prcBounds->right;
		COLORREF prevColor;

		long xOrgForNonPickupStrips;
		xOrgForNonPickupStrips = m_lFunctionBarWidth + max( 0, lEarlyPosition - m_lXScrollPos );

		long lXScrollOffset;
		int xOrg, yOrg, yFirst = 0, yTemp;
		int yEnd, iClipRgn;
		CRect tempRect;

		xOrg = m_lFunctionBarWidth;
		yOrg = BORDER_HORIZ_WIDTH;
		lXScrollOffset = m_lXScrollPos;
		brushBorder.CreateSolidBrush( dc.GetNearestColor( BORDER_COLOR ) );
		m_ScrollVertical.GetClientRect( &rectSV );
		m_ScrollHorizontal.GetClientRect( &rectSH );
		lRightBounds -= rectSV.right; // clip the vert scroll bar off the drawing area
		if( m_pStripList )
		{
			// color the rectangle to the right of the first strip and above the
			// vertical scrollbar grey
			tempRect.top = 0;
			tempRect.bottom = m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH*2;
			tempRect.left = lRightBounds;
			tempRect.right = di.prcBounds->right;
			if( tempRect.IntersectRect( tempRect, rcClientArea ) )
			{
				prevColor = dc.GetBkColor();
				dc.FillSolidRect( &tempRect, dc.GetNearestColor(COLOR_GUTTER_NORMAL));
				dc.SetBkColor(prevColor);
			}
		}

		CFont *pOldStripFont;
		pOldStripFont = dc.SelectObject( &fontStrip );

		// Calculate the length (in pixels) of the timeline
		long posLength;
		ClocksToPosition( m_lLength, &posLength );
		posLength += lEarlyPosition + lLatePosition;

		for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
		{
			VARIANT	varTemp;

			if( pSL == m_pStripList->m_pNext )
			{
				// the first strip (usually time strip) always plots at the top.
				// the rest are scrolled.
				yFirst = yOrg;
				yOrg -= m_lYScrollPos;
			}
			if( pSL == m_pStripList )
			{
				yTemp = yOrg;
			}
			else
			{
				yTemp = ( yOrg < yFirst ) ? yFirst : yOrg;
			}

			// Save the Device Context
			iSavedDC = dc.SaveDC();

			// prevent strips from drawing on top of vert scroll bar
			long xEnd = lRightBounds - BORDER_VERT_WIDTH;

			// clip the xEnd so it doesn't go past the length
			long lStripLatePosition = 0;
			if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_LATE_TIME, &varTemp ) ) )
			{
				// Convert from clocks to pixels
				ClocksToPosition( V_I4(&varTemp), &lStripLatePosition );

				xEnd = min( xEnd, posLength - lLatePosition - lXScrollOffset + lStripLatePosition + m_lFunctionBarWidth + BORDER_VERT_DRAWWIDTH - 1 );
			}
			else
			{
				xEnd = min( xEnd, posLength - lLatePosition - lXScrollOffset + m_lFunctionBarWidth + BORDER_VERT_DRAWWIDTH - 1 );
			}

			yEnd = yOrg + pSL->m_lHeight;
			// Clip yEnd to the bottom of the viewable area, minus the height of
			// the horizontal scroll bar
			if( yEnd > di.prcBounds->bottom - rectSH.bottom )
			{
				yEnd = di.prcBounds->bottom - rectSH.bottom;
			}

			// Draw the normal gutter
			tempRect.left = 0;
			tempRect.right = GUTTER_WIDTH;
			tempRect.top = yOrg - BORDER_HORIZ_WIDTH;
			tempRect.bottom = yEnd + BORDER_HORIZ_WIDTH;

			// Ensure we don't overwrite the top strip.
			// If we're not the top strip
			if( pSL != m_pStripList )
			{
				rgn.CreateRectRgn( rcClientArea.left, yTemp-1, rcClientArea.right, rcClientArea.bottom );
				dc.SelectClipRgn( &rgn );
				rgn.DeleteObject();
			}

			if( (dc.GetDeviceCaps( RASTERCAPS ) & RC_DIBTODEV)
			&&	(min( rcClientArea.right, xEnd ) > max( rcClientArea.left, GUTTER_WIDTH - 1 ))
			&&	(pSL->m_lHeight > 0) )
			{
				// Color the entire strip - not just the gutter
				// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
				DWORD *pdwColorArray = m_adwNormalColor;
				/*
				if( pSL->m_fSelected )
				{
					if( m_pActiveStripList == pSL )
					{
						// Orange (COLOR_GUTTER_ACTIVESELECTED)
						pdwColorArray = m_adwActiveSelectedColor;
					}
					else
					{
						// Red (COLOR_GUTTER_SELECTED)
						pdwColorArray = m_adwSelectedColor;
					}
				}
				else */	if( m_pActiveStripList == pSL )
				{
					// Yellow (COLOR_GUTTER_ACTIVE)
					pdwColorArray = m_adwActiveColor;
				}

				{
					const long lLeftEdge = max( rcClientArea.left, GUTTER_WIDTH - 1 );
					const long lRightEdge = min( rcClientArea.right, xEnd );

					BITMAPINFO bmInfo;
					ZeroMemory( &bmInfo, sizeof( BITMAPINFO ) );
					//bmInfo.bmiColors = ;
					bmInfo.bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
					bmInfo.bmiHeader.biWidth = min( SHADING_BLOCK_WIDTH, lRightEdge - lLeftEdge );
					bmInfo.bmiHeader.biHeight = -pSL->m_lHeight; // Negative, to make a top-down DIB
					bmInfo.bmiHeader.biPlanes = 1;
					bmInfo.bmiHeader.biBitCount = 32;
					bmInfo.bmiHeader.biClrImportant = 0;
					bmInfo.bmiHeader.biClrUsed = 0;
					bmInfo.bmiHeader.biCompression = BI_RGB;
					bmInfo.bmiHeader.biSizeImage = 0;
					bmInfo.bmiHeader.biXPelsPerMeter = 0;
					bmInfo.bmiHeader.biYPelsPerMeter = 0;
					const long lDIBWidth = bmInfo.bmiHeader.biWidth;
					const long lDIBHeight = pSL->m_lHeight;
					DWORD *adwDIBArray = new DWORD[lDIBWidth * lDIBHeight];
					DWORD *pdwIndex = adwDIBArray;

					for( long lDIBY = 0; lDIBY < lDIBHeight; lDIBY++ )
					{
						/*
						const BYTE bVal = SHADING_DARK_COLOR + (lDIBY << 6) / lDIBHeight;
						memset( pdwIndex, bVal, sizeof(DWORD) * lDIBWidth );
						pdwIndex += lDIBWidth;
						*/

						// Color the entire strip - not just the gutter
						const DWORD dwColor = pdwColorArray[ (lDIBY << 8)/ lDIBHeight ];
						for( long lDIBX = 0; lDIBX < lDIBWidth; lDIBX++ )
						{
							*pdwIndex = dwColor;
							pdwIndex++;
						}
					}

					::SetDIBitsToDevice( dc.m_hDC,
										 lLeftEdge, yOrg,
										 lDIBWidth, lDIBHeight,
										 0, 0,
										 0, lDIBHeight,
										 adwDIBArray, &bmInfo, DIB_RGB_COLORS );

					if( lRightEdge - lLeftEdge > SHADING_BLOCK_WIDTH )
					{
						for( long lOffset = SHADING_BLOCK_WIDTH; lOffset < lRightEdge - lLeftEdge; lOffset += SHADING_BLOCK_WIDTH )
						{
							const long lTmpWidth = min( lDIBWidth, lRightEdge - (lLeftEdge + lOffset));
							::BitBlt( dc.m_hDC,
									  lLeftEdge + lOffset, yOrg,
									  lTmpWidth, lDIBHeight,
									  dc.m_hDC,
									  lLeftEdge, yOrg,
									  SRCCOPY );
						}
					}

					//delete [] abDIBArray;
					delete [] adwDIBArray;
				}
			}

			// Create yet another temporary rect so we don't destroy the gutter rectangle
			CRect reallyTempRect;
			if( reallyTempRect.IntersectRect( tempRect, rcClientArea ) )
			{
				// Save the background color
				prevColor = dc.GetBkColor();

				// Choose the gutter's color
				COLORREF gutterColor;
				/*
				if( pSL == m_pActiveStripList )
				{
					if( pSL->m_fSelected )
					{
						gutterColor = dc.GetNearestColor(COLOR_GUTTER_ACTIVESELECTED);
					}
					else
					{
						gutterColor = dc.GetNearestColor(COLOR_GUTTER_ACTIVE);
					}
				}
				else */ if( pSL->m_fSelected )
				{
					gutterColor = dc.GetNearestColor(COLOR_GUTTER_SELECTED);
				}
				else
				{
					gutterColor = dc.GetNearestColor(COLOR_GUTTER_NORMAL);
				}

				// Draw a 3d button-like highlight around it
				dc.Draw3dRect( &tempRect, ::GetSysColor(COLOR_3DHILIGHT),
					::GetSysColor(COLOR_3DSHADOW));

				// Fill the gutter with correct color
				tempRect.top+=2;
				tempRect.bottom-=2;
				tempRect.left++;
				tempRect.right--;
				dc.FillSolidRect( &tempRect, gutterColor );

				// Restore the background color
				dc.SetBkColor( prevColor );
			}

			// draw a rectangle around the strip.
			rgn.CreateRectRgn( xOrg - BORDER_VERT_WIDTH, yOrg - BORDER_HORIZ_WIDTH,
				lRightBounds, yEnd + BORDER_HORIZ_WIDTH );
			dc.FrameRgn( &rgn, &brushBorder, BORDER_VERT_DRAWWIDTH, BORDER_HORIZ_DRAWWIDTH );
			rgn.DeleteObject();

			// also draw a rectangle around the strip's function area
			CPen *pOldStripPen = dc.SelectObject( &penVertFnBar );

			// Draw vertical lines
			dc.MoveTo( GUTTER_WIDTH, yOrg - BORDER_HORIZ_WIDTH );
			dc.LineTo( GUTTER_WIDTH, yEnd + BORDER_HORIZ_WIDTH - 1 );
			dc.MoveTo( xOrg - 1, yOrg - BORDER_HORIZ_WIDTH );
			dc.LineTo( xOrg - 1, yEnd + BORDER_HORIZ_WIDTH - 1 );

			// Draw horizontal lines
			BOOL fDrawHorizLines = TRUE;
			if( pSL->m_pNext )
			{
				if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_STRIPMGR, &varTemp )))
				{
					VARIANT varNext;
					if( SUCCEEDED( pSL->m_pNext->m_pStrip->GetStripProperty( SP_STRIPMGR, &varNext )))
					{
						if( V_UNKNOWN(&varTemp) == V_UNKNOWN(&varNext) )
						{
							fDrawHorizLines = FALSE;
						}
						V_UNKNOWN(&varNext)->Release();
					}
					V_UNKNOWN(&varTemp)->Release();
				}

				if( (pSL->m_clsidType == pSL->m_pNext->m_clsidType)
				&&	(pSL->m_clsidType == CLSID_DirectMusicSeqTrack) )
				{
					fDrawHorizLines = FALSE;
				}
			}

			if( fDrawHorizLines )
			{
				dc.SelectObject( &penHorizFnBar );
				if( pSL->m_pNext )
				{
					dc.MoveTo( GUTTER_WIDTH, yEnd + BORDER_HORIZ_WIDTH );
					dc.LineTo( xOrg - 1, yEnd + BORDER_HORIZ_WIDTH );
				}
				dc.MoveTo( GUTTER_WIDTH, yEnd + BORDER_HORIZ_WIDTH - 1 );
				dc.LineTo( xOrg - 1, yEnd + BORDER_HORIZ_WIDTH - 1 );
			}

			dc.SelectObject( pOldStripPen );

			if( yEnd > yTemp )
			{
				long lEarlyStripPosition = 0;
				long lStripXOrg = xOrgForNonPickupStrips;
				if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_EARLY_TIME, &varTemp ) ) )
				{
					// Convert from clocks to pixels
					ClocksToPosition( V_I4(&varTemp), &lEarlyStripPosition );

					lStripXOrg = m_lFunctionBarWidth + max( 0, lEarlyPosition - lEarlyStripPosition - m_lXScrollPos );
				}

				tempRect.left = lStripXOrg;
				tempRect.right = xEnd;
				tempRect.top = yTemp;
				tempRect.bottom = yEnd;
				if( tempRect.IntersectRect( tempRect, rcClientArea ) )
				{
					rgn.CreateRectRgn( tempRect.left, tempRect.top, tempRect.right, tempRect.bottom );
					iClipRgn = dc.SelectClipRgn( &rgn );

					// By using fStripWantsEarlyTime we can trick strips into not displaying anything
					// in pick-up measures

					// Only use pSL->m_lVScroll when the strip is maximized.
					long lTmpXScrollOffset = max( lXScrollOffset - lEarlyPosition, -lEarlyStripPosition );
					if (pSL->m_sv == SV_MINIMIZED)
					{
						dc.SetWindowOrg( -lStripXOrg, -yOrg );
						dc.SetBrushOrg( -lStripXOrg - lTmpXScrollOffset, -yOrg );
					}
					else
					{
						dc.SetWindowOrg( -lStripXOrg, -yOrg + pSL->m_lVScroll );
						dc.SetBrushOrg( -lStripXOrg - lTmpXScrollOffset, -yOrg + pSL->m_lVScroll );
					}

					// Color the entire strip - not just the gutter
					DWORD dwNewBkColor = RGB((SHADING_DARK_COLOR + 255) / 2, (SHADING_DARK_COLOR + 255) / 2, (SHADING_DARK_COLOR + 255) / 2);
					/*
					if( pSL->m_fSelected )
					{
						if( m_pActiveStripList == pSL )
						{
							// Orange (COLOR_GUTTER_ACTIVESELECTED)
							dwNewBkColor = RGB((255 + 255) / 2, (192 + 255) / 2, (128 + 255) / 2);
						}
						else
						{
							// Red (COLOR_GUTTER_SELECTED)
							dwNewBkColor = RGB((255 + 255) / 2, (128 + 255) / 2, (128 + 255) / 2);
						}
					}
					else */ if( m_pActiveStripList == pSL )
					{
						// Yellow (COLOR_GUTTER_ACTIVE)
						dwNewBkColor = RGB((255 + 255) / 2, (255 + 255) / 2, (192 + 255) / 2);
					}

					prevColor = dc.SetBkColor( dwNewBkColor );
					pSL->m_pStrip->Draw( dc.m_hDC, pSL->m_sv, lTmpXScrollOffset );
					dc.SetBkColor(prevColor);

					// draw minimize icon if the strip is MinMaxable and is not already minimized
					VARIANT var;
					if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_MINMAXABLE, &var )))
					{
						if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
						{
							// Compute the location to put the min/max button at
							long lXPosForMinMaxButton;
							if( lStripLatePosition
							&&	(xEnd > posLength - lLatePosition - lXScrollOffset) )
							{
								// Need to compute the position, can't use xEnd since it's beyond the end of the segment
								lXPosForMinMaxButton = min( lRightBounds - BORDER_VERT_WIDTH, posLength - lLatePosition - lXScrollOffset + m_lFunctionBarWidth + BORDER_VERT_DRAWWIDTH - 1 );
							}
							else
							{
								// Just use xEnd
								lXPosForMinMaxButton = xEnd;
							}

							// Offset it from lStripXOrg, and subtract the width of the button
							lXPosForMinMaxButton -= lStripXOrg + m_sizeMinMaxButton.cx;

							if (pSL->m_sv == SV_NORMAL)
							{
								if ( m_MouseMode == MM_ACTIVEMINMAX )
								{
									dc.DrawState(CPoint(lXPosForMinMaxButton, pSL->m_lVScroll ), m_sizeMinMaxButton, &m_BitmapMinimized, DSS_NORMAL);
								}
								else
								{
									dc.DrawState(CPoint(lXPosForMinMaxButton, pSL->m_lVScroll - 2), CSize( m_sizeMinMaxButton.cx, m_sizeMinMaxButton.cy + 2 ) , &m_BitmapMinimize, DSS_NORMAL);
								}
							}
							else if (pSL->m_sv == SV_MINIMIZED)
							{
								if ( m_MouseMode == MM_ACTIVEMINMAX )
								{
									dc.DrawState(CPoint(lXPosForMinMaxButton, 0 ), m_sizeMinMaxButton, &m_BitmapMaximized, DSS_NORMAL);
								}
								else
								{
									dc.DrawState(CPoint(lXPosForMinMaxButton, 0), m_sizeMinMaxButton, &m_BitmapMaximize, DSS_NORMAL);
								}
							}
						}
					}
					rgn.DeleteObject();
				}

				// if the name bar is showing, draw it
				if( yOrg + FUNCTION_NAME_HEIGHT >= yTemp )
				{
					CFont *pOldFont;
					pOldFont = dc.SelectObject( &fontStripName );

					int nOldBkMode;
					nOldBkMode = dc.SetBkMode( TRANSPARENT );

					long yEvenMoreTemp = max( yTemp, yOrg );

					// Make sure we don't overwrite the horizontal scroll bar
					if ( yEnd < yOrg + FUNCTION_NAME_HEIGHT )
					{
						rgn.CreateRectRgn( GUTTER_WIDTH + BORDER_VERT_DRAWWIDTH, 
							yEvenMoreTemp,
							xOrg - BORDER_VERT_WIDTH, yEnd );
					}
					else
					{
						rgn.CreateRectRgn( GUTTER_WIDTH + BORDER_VERT_DRAWWIDTH, 
							yEvenMoreTemp,
							xOrg - BORDER_VERT_WIDTH, yOrg + FUNCTION_NAME_HEIGHT );
					}
					dc.SelectClipRgn( &rgn );
					rgn.DeleteObject();
					dc.SetWindowOrg( -(GUTTER_WIDTH + BORDER_VERT_DRAWWIDTH), -yOrg );
					tempRect.top = 0;
					tempRect.left = 0;
					tempRect.right = xOrg - BORDER_VERT_WIDTH - GUTTER_WIDTH;
					tempRect.bottom = FUNCTION_NAME_HEIGHT;

					// Determine what color to use as the background for thr strip's name
					COLORREF crBackGround = dc.GetNearestColor(COLOR_FUNCTION_NAME);
					BOOL fAuditionOnly = FALSE;

					// Get the strip's strip manager
					if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_STRIPMGR, &varTemp ) ) 
					&&	V_UNKNOWN(&varTemp) )
					{
						// Get an IDMUSProdStripMgr interface
						IDMUSProdStripMgr *pStripMgr;
						if( SUCCEEDED( V_UNKNOWN(&varTemp)->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
						{
							// Get the track extras flags
							VARIANT varTrackExtras;
							varTrackExtras.vt = VT_BYREF;
							DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
							V_BYREF( &varTrackExtras ) = &ioTrackExtrasHeader;
							if( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackExtras ) == S_OK )
							{
								if( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER_MASK, &varTrackExtras ) == S_OK )
								{
									if( 0 != (V_I4(&varTrackExtras) & TRACKCONFIG_PLAY_FLAGS & (~ioTrackExtrasHeader.dwFlags)) )
									{
										// If anything is disabled, change the name background to grey
										crBackGround = dc.GetNearestColor( COLOR_GREY_FUNCTION_NAME );
									}
								}
							}

							// Get the producer-only flags
							IOProducerOnlyChunk ioProducerOnlyChunk;
							varTrackExtras.vt = VT_BYREF;
							V_BYREF( &varTrackExtras ) = &ioProducerOnlyChunk;
							if( pStripMgr->GetStripMgrProperty( SMP_PRODUCERONLY_FLAGS, &varTrackExtras ) == S_OK )
							{
								// If an audition-only strip, hatch the background of the name
								fAuditionOnly = ioProducerOnlyChunk.dwProducerOnlyFlags & SEG_PRODUCERONLY_AUDITIONONLY;
							}
							pStripMgr->Release();
						}
						V_UNKNOWN(&varTemp)->Release();
					}

					// If an audition-only strip, cross hatch the background of the name
					if( fAuditionOnly )
					{
						HBRUSH hbrushHatch = ::CreateHatchBrush( HS_DIAGCROSS, COLOR_HATCH_FUNCTION_NAME ); 
						COLORREF crOldBkColor = dc.SetBkColor( crBackGround );
						::FillRect( dc.GetSafeHdc(), &tempRect, hbrushHatch );
						dc.SetBkColor( crOldBkColor );
					}
					// Otherwise, just fill the background with a solid color
					else
					{
						dc.FillSolidRect( &tempRect, crBackGround );
					}

					CString strName;
					if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_NAME, &varTemp )))
					{
						if( varTemp.vt == VT_BSTR )
						{
							strName = V_BSTR(&varTemp);
							SysFreeString( V_BSTR(&varTemp) );
						}
					}
					COLORREF oldColor;
					oldColor = dc.SetTextColor( RGB(0, 0, 0) );
					UINT oldAlign;
					oldAlign = dc.SetTextAlign( TA_LEFT );
					dc.DrawText( strName, &tempRect,
						DT_NOCLIP | DT_TOP | DT_LEFT | DT_SINGLELINE | DT_NOPREFIX );
					dc.SetTextAlign( oldAlign );
					dc.SetTextColor( oldColor );
					dc.SetBkMode( nOldBkMode );
					dc.SelectObject(pOldFont);
				}

				// and now draw the function area if the strip supports it
				IDMUSProdStripFunctionBar* pSFB;
				if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdStripFunctionBar, (void**)&pSFB )))
				{
					// Don't exclude the area where the name was drawn when testing whether or not
					// to draw this function bar
					yTemp = max( yTemp, yOrg );
					tempRect.left = LEFT_DRAW_OFFSET;
					tempRect.right = xOrg - BORDER_VERT_WIDTH;
					tempRect.top = yTemp;
					tempRect.bottom = yEnd;
					if( tempRect.IntersectRect( tempRect, rcClientArea ) )
					{
						// Exclude the area where the name was drawn
						yTemp = max( yTemp, yOrg + FUNCTION_NAME_HEIGHT );
						tempRect.top = yTemp;

						rgn.CreateRectRgn( tempRect.left, tempRect.top, tempRect.right, tempRect.bottom );
						dc.SelectClipRgn( &rgn );
						if (pSL->m_sv == SV_MINIMIZED)
						{
							dc.SetWindowOrg( -LEFT_DRAW_OFFSET, -yOrg );
						}
						else
						{
							dc.SetWindowOrg( -LEFT_DRAW_OFFSET, -yOrg + pSL->m_lVScroll);
						}
						if (pSL->m_sv == SV_MINIMIZED)
						{
							pSFB->FBDraw( dc.m_hDC, SV_FUNCTIONBAR_MINIMIZED );
						}
						else
						{
							pSFB->FBDraw( dc.m_hDC, SV_FUNCTIONBAR_NORMAL );
						}
						rgn.DeleteObject();
					}
					pSFB->Release();
				}
			}
			dc.RestoreDC( iSavedDC );
			yOrg = yEnd + BORDER_HORIZ_DRAWWIDTH;
		}

		// if we are currently in MM_ACTIVERESIZE mode, we need to draw xor'd lines
		// across the width of the window
		if( m_MouseMode == MM_ACTIVERESIZE )
		{
			xOrg = di.prcBounds->left;
			if( xOrg < GUTTER_WIDTH )
			{
				xOrg = GUTTER_WIDTH;
			}
			rgn.CreateRectRgn( xOrg, m_lResizeYPos, lRightBounds,
				m_lResizeYPos + BORDER_HORIZ_DRAWWIDTH );
			dc.InvertRgn( &rgn );
			rgn.DeleteObject();
		}

		dc.SelectObject(pOldStripFont);

		// Always draw the time cursor
		//if( m_lCursor >= 0 )
		{
			long position;
			ClocksToPosition( m_lCursor, &position );
			position -= lXScrollOffset - m_lFunctionBarWidth - lEarlyPosition;
			if( (rcClientArea.left <= position) && (position <= rcClientArea.right) && (position >= m_lFunctionBarWidth) )
			{
				CPen penCursor;
				if( penCursor.CreatePen( PS_SOLID, 1, COLOR_TIME_CURSOR ) )
				{
					CPen *pPenOld;
					pPenOld = dc.SelectObject( &penCursor );
					int nOldROP;
					nOldROP = dc.SetROP2( R2_XORPEN );

					RECT tempScrollRect;
					m_ScrollHorizontal.GetClientRect( &tempScrollRect );
					GetClientRect( &tempRect );
					tempRect.bottom = min(tempRect.bottom - tempScrollRect.bottom, rcClientArea.bottom);
					if( rcClientArea.top < tempRect.bottom )
					{
						dc.MoveTo( position, rcClientArea.top );
						dc.LineTo( position, tempRect.bottom );
					}

					dc.SetROP2( nOldROP );
					dc.SelectObject( pPenOld );
					penCursor.DeleteObject();
				}
			}
		}
///////////////////////////////////////////////
		//Blt the memdc to the screen
		bStatus = realDC.BitBlt(rcClientArea.left, rcClientArea.top, rcClientArea.right - rcClientArea.left, rcClientArea.bottom - rcClientArea.top,
			&dc, rcClientArea.left, rcClientArea.top, SRCCOPY);
		ASSERT(bStatus);
		
		dc.SelectObject(pOldbm); //select out of dc
		bStatus = dc.DeleteDC(); //delete it.
		ASSERT(bStatus);
		delete pRgn;
///////////////////////////////////////////////
		realDC.Detach();
	}
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | DrawMusicLines | This method draws
//		vertical bar, beat, and grid lines in the specified device context.
//
//  @parm   HDC | hdc | A handle to the device context to draw in
//  @parm   <t MUSICLINE_PROPERTY> | mlp | Which type of lines to draw.  Must be one of <t MUSICLINE_PROPERTY>
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_FAIL | Unable to attach to <p hdc>.
//	@rvalue E_INVALIDARG | <p mlp> does not contain a valid value.
//
//	@xref	<i IDMUSProdTimeline>, <t MUSICLINE_PROPERTY>
HRESULT CTimelineCtl::DrawMusicLines( HDC hdc, MUSICLINE_PROPERTY mlp, DWORD dwGroupBits, DWORD dwIndex, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	ASSERT( hdc );
	ASSERT( (mlp == ML_DRAW_MEASURE_BEAT_GRID) || (mlp == ML_DRAW_MEASURE_BEAT) );
	if ( !hdc || ((mlp != ML_DRAW_MEASURE_BEAT_GRID) && (mlp != ML_DRAW_MEASURE_BEAT)) )
	{
		return E_INVALIDARG;
	}

	// Time signature behavior:  If the time signature changes during a measure, the current time
	// signature will continute to apply for that measure.  At the end of the measure, the time
	// signature will change to the most recent one available.  Repeat this process for each
	// time signature change.

	// Create the pens
	HPEN hPenMeasureLine, hPenBeatLine, hPenSubBeatLine;
	hPenMeasureLine = ::CreatePen( MEASURE_LINE_PENSTYLE, MEASURE_LINE_WIDTH, m_colorMeasureLine );
	if( hPenMeasureLine == NULL )
	{
		return E_OUTOFMEMORY;
	}

	hPenBeatLine = ::CreatePen( BEAT_LINE_PENSTYLE, BEAT_LINE_WIDTH, m_colorBeatLine );
	if( hPenBeatLine == NULL )
	{
		::DeleteObject( hPenMeasureLine );
		return E_OUTOFMEMORY;
	}

	if ( mlp == ML_DRAW_MEASURE_BEAT_GRID )
	{
		hPenSubBeatLine = ::CreatePen( SUBBEAT_LINE_PENSTYLE, SUBBEAT_LINE_WIDTH, m_colorSubBeatLine );
		if( hPenSubBeatLine == NULL )
		{
			::DeleteObject( hPenMeasureLine );
			::DeleteObject( hPenBeatLine );
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		hPenSubBeatLine = NULL;
	}

	// Set up our start time, end time
	RECT rectClip;
	MUSIC_TIME mtLeft, mtRight, mtTemp;
	::GetClipBox( hdc, &rectClip );
	PositionToClocks( rectClip.left + lXOffset, &mtLeft );
	// Since the bar lines are two pixels wide, we need to add 1 here
	PositionToClocks( rectClip.right + lXOffset + 1, &mtRight );

	long lPosition = 0; // integer position

	// Save the current pen and switch to the Measure Line pen
	HPEN hPenOld;
	hPenOld = static_cast<HPEN>( ::SelectObject( hdc, hPenMeasureLine ) );

	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext = 1;
	BYTE bBeat;

	// Handle drawing in negative times
	if( mtLeft < 0 )
	{
		if ( FAILED( GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, 0, NULL, &TimeSig ) ) )
		{
			::SelectObject( hdc, hPenOld );
			::DeleteObject( hPenMeasureLine );
			::DeleteObject( hPenBeatLine );
			if( hPenSubBeatLine )
			{
				::DeleteObject( hPenSubBeatLine );
			}
			return E_UNEXPECTED;
		}

		// Compute the number of clocks per measure
		const MUSIC_TIME mtClocksPerMeasure = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
		mtTSCur = (mtLeft - mtClocksPerMeasure + 1) / mtClocksPerMeasure;
		mtTSCur *= mtClocksPerMeasure;
	}

	while( mtTSCur < mtRight )
	{
		if ( FAILED( GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, max( 0, mtTSCur), &mtTSNext, &TimeSig ) ) )
		{
			::SelectObject( hdc, hPenOld );
			::DeleteObject( hPenMeasureLine );
			::DeleteObject( hPenBeatLine );
			if( hPenSubBeatLine )
			{
				::DeleteObject( hPenSubBeatLine );
			}
			return E_UNEXPECTED;
		}

		MUSIC_TIME mtNext;
		if( mtTSNext == 0 )
		{
			mtTSNext = m_lLength;
			mtNext = LONG_MAX;
		}
		else
		{
			mtTSNext += max( 0, mtTSCur );
			mtNext = mtTSNext;
		}

		while( (mtTSCur < mtNext) && (mtTSCur < mtRight) )
		{
			// For this measure, compute clocks per beat and clocks per grid
			const MUSIC_TIME mtClocksPerBeat = NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// Draw this measure
			if ( mtTSCur + TimeSig.bBeatsPerMeasure * mtClocksPerBeat >= mtLeft )
			{

				// Draw measure line
				if ( mtTSCur >= mtLeft )
				{
					::SelectObject( hdc, hPenMeasureLine );
					ClocksToPosition( mtTSCur, &lPosition );
					::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
					::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );
				}

				// Draw beats
				bBeat = 1;
				::SelectObject( hdc, hPenBeatLine );
				while ( bBeat < TimeSig.bBeatsPerMeasure )
				{
					mtTSCur += mtClocksPerBeat;

					// Draw beat line
					ClocksToPosition( mtTSCur, &lPosition );
					::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
					::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );

					bBeat++;
				}

				// Draw Grids
				if ( mlp == ML_DRAW_MEASURE_BEAT_GRID )
				{
					const MUSIC_TIME mtClocksPerGrid = mtClocksPerBeat / TimeSig.wGridsPerBeat;
					bBeat = 0;
					mtTSCur = mtTSCur - mtClocksPerBeat * (TimeSig.bBeatsPerMeasure - 1);
					::SelectObject( hdc, hPenSubBeatLine );
					while ( bBeat < TimeSig.bBeatsPerMeasure )
					{
						// Draw Grids

						// Save next beat position
						mtTemp = mtTSCur + mtClocksPerBeat;

						BYTE bGrid = 1;
						mtTSCur += mtClocksPerGrid;

						// Draw grid lines
						while ( bGrid < TimeSig.wGridsPerBeat )
						{
							ClocksToPosition( mtTSCur, &lPosition );
							::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
							::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );

							bGrid++;
							mtTSCur += mtClocksPerGrid;
						}
						mtTSCur = mtTemp;
						bBeat++;
					}
				}
				else
				{
					mtTSCur += mtClocksPerBeat;
				}
			}
			else
			{	// Advance time by one measure
				mtTSCur += TimeSig.bBeatsPerMeasure * mtClocksPerBeat;
			}
		}
	}

	// Restore the previous pen
	::SelectObject( hdc, hPenOld );

	::DeleteObject( hPenMeasureLine );
	::DeleteObject( hPenBeatLine );
	if( hPenSubBeatLine )
	{
		::DeleteObject( hPenSubBeatLine );
	}

	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | AddStripMgr | This method adds an <i IDMUSProdStripMgr> to the
//		list of strip managers within the Timeline.
//
//	@comm	Using the <p dwGroupBits> parameter and the Strip manager's FourCCCKIds
//		(returned by the method <om IDMUSProdStripMgr::GetFourCCCKIDs>), the Timeline determines a
//		position for the StripMgr in its internal list.<nl>
//		They are ordered first by the least track group number they belong to, then in the following order,
//		then by the order they were inserted:<nl>
//		Chord<nl>
//		Signpost<nl>
//		ChordMap Reference<nl>
//		Groove<nl>
//		Tempo<nl>
//		Style Reference<nl>
//		Sequence<nl>
//		Time Signature<nl>
//		Band<nl>
//		Mute<nl>
//		All other strips
//
//  @parm   <i IDMUSProdStripMgr>* | pIStripMgr | The strip manager to add
//  @parm	DWORD | dwGroupBits | Which track group(s) this strip manager belongs to.  A value
//		of 0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. 
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p punkStripMgr>
//	@rvalue E_INVALIDARG | The strip manager was previously added to the Timeline
//	@rvalue E_OUTOFMEMORY | Unable to allocate memory while adding the strip manager
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimeline::RemoveStripMgr>
HRESULT CTimelineCtl::AddStripMgr( IDMUSProdStripMgr* pIStripMgr, DWORD dwGroupBits)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pIStripMgr )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	StripMgrList*	pScan;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_pStripMgr == pIStripMgr )
		{
			return E_INVALIDARG;
		}
	}

	StripMgrList*	pSML = new StripMgrList( pIStripMgr, dwGroupBits );
	if( pSML )
	{
		// Empty list
		if( !m_pStripMgrList )
		{
			m_pStripMgrList = pSML;
			pSML->m_pNext = NULL;

			VARIANT varTimeline;
			varTimeline.vt = VT_UNKNOWN;
			QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
			pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
			Release();
			return S_OK;
		}

		DMUS_IO_TRACK_HEADER ioTrackHeader;
		ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
		VARIANT varTrackHeader;
		varTrackHeader.vt = VT_BYREF;
		V_BYREF(&varTrackHeader) = &ioTrackHeader;
		if( FAILED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
		{
			TRACE("Timeline: Unable to get StripMgr's FourCCCKIDs\n");
		}

		int nType1, nType2;
		nType1 = StripCLSIDToInt( ioTrackHeader.guidClassID );

		StripMgrList*	pScanOld = NULL;
		for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
		{
			ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
			varTrackHeader.vt = VT_BYREF;
			V_BYREF(&varTrackHeader) = &ioTrackHeader;
			if( FAILED( pScan->m_pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
			{
				TRACE("Timeline: Unable to get StripMgr's FourCCCKIDs\n");
			}

			// Ensure the TimeStripMgr is always the last strip
			if( pScan->m_pStripMgr->IsParamSupported( CLSID_TimeStripMgr ) == S_OK )
			{
				// if pSML should go before pScan, insert it there
				if( pScanOld )
				{
					pScanOld->m_pNext = pSML;
				}
				else
				{
					// Head of the list
					ASSERT( pScan == m_pStripMgrList );
					m_pStripMgrList = pSML;
				}
				pSML->m_pNext = pScan;

				VARIANT varTimeline;
				varTimeline.vt = VT_UNKNOWN;
				QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
				pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
				Release();
				return S_OK;
			}
			nType2 = StripCLSIDToInt( ioTrackHeader.guidClassID );

			if( CompareStrips( nType2, pScan->m_dwGroupBits, 0, NULL,
							   nType1, dwGroupBits, 0, NULL ) == 2 )
			{
				// if pSML should go before pScan, insert it there
				if( pScanOld )
				{
					pScanOld->m_pNext = pSML;
				}
				else
				{
					// Head of the list
					ASSERT( pScan == m_pStripMgrList );
					m_pStripMgrList = pSML;
				}
				pSML->m_pNext = pScan;

				VARIANT varTimeline;
				varTimeline.vt = VT_UNKNOWN;
				QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
				pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
				Release();
				return S_OK;
			}
			pScanOld = pScan;
		}
		
		// End of the list
		pScanOld->m_pNext = pSML;
		pSML->m_pNext = NULL;

		VARIANT varTimeline;
		varTimeline.vt = VT_UNKNOWN;
		QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
		pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
		Release();
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}
}

//  @method HRESULT | IDMUSProdTimeline | RemoveStripMgr | This method removes a strip manager
//		from the Timeline.
//
//  @parm   <i IDMUSProdStripMgr>* | pIStripMgr | The strip manager to remove
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p punkStripMgr>
//	@rvalue E_INVALIDARG | <p pIStripMgr> was not previously added to the Timeline via
//		<om IDMUSProdTimeline::AddStripMgr>.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimeline::AddStripMgr>
HRESULT CTimelineCtl::RemoveStripMgr(
	/* [in] */	IDMUSProdStripMgr* pIStripMgr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT			hr;

	if( NULL == pIStripMgr )
	{
		return E_POINTER;
	}
	StripMgrList	*pSML, *pSMLold;
	pSML = m_pStripMgrList;
	pSMLold = NULL;
	hr = E_INVALIDARG;
	// Remove pIStripMgr from m_pStripMgrList
	while ( pSML )
	{
		if ( pSML->m_pStripMgr == pIStripMgr )
		{
			VARIANT varTimeline;
			varTimeline.vt = VT_UNKNOWN;
			V_UNKNOWN(&varTimeline) = NULL;
			pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
			if ( pSMLold )
			{
				pSMLold->m_pNext = pSML->m_pNext;
			}
			else
			{
				m_pStripMgrList = pSML->m_pNext;
			}
			delete pSML;
			pSML = NULL;
			hr = S_OK;
		}
		else
		{
			pSMLold = pSML;
			pSML = pSML->m_pNext;
		}
	}

	// Remove the Stripmgr from the list of Notify Entries
	POSITION pos, pos2;
	NotifyEntry *pNotifyEntry;
	pos = m_lstNotifyEntry.GetHeadPosition();
	while ( pos != NULL )
	{
		pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
		// Found guidNotify, now find pIStripMgr
		NotifyListEntry* pNotifyListEntry = NULL;
		pos2 = pNotifyEntry->m_lstNotifyListEntry.GetHeadPosition( );
		while ( pos2 != NULL )
		{
			POSITION pos3 = pos2;
			pNotifyListEntry = pNotifyEntry->m_lstNotifyListEntry.GetNext( pos2 );
			if( pNotifyListEntry->pIStripMgr == pIStripMgr )
			{
				// We've found it, now remove it from the list and delete our entry
				pNotifyEntry->m_lstNotifyListEntry.RemoveAt( pos3 );
				delete pNotifyListEntry;

				// Check if the list is empty
				if ( pNotifyEntry->m_lstNotifyListEntry.IsEmpty() )
				{
					// If the list is empty, remove it from m_lstNotifyEntry
					pos2 = m_lstNotifyEntry.Find( pNotifyEntry );
					ASSERT( pos2 );
					if ( pos2 )
					{
						m_lstNotifyEntry.RemoveAt( pos2 );
						delete pNotifyEntry;
						pos2 = NULL;
					}
				}
			}
		}
	}

	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | AddStrip | This method adds a strip at the
//		bottom of the strips displayed by the Timeline.
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip to add
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p punkStrip>
//	@rvalue E_FAIL | The strip is already displayed by the Timeline
//	@rvalue E_OUTOFMEMORY | Unable to allocate memory while adding the strip
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::RemoveStrip>,
//		<om IDMUSProdTimeline::InsertStripAtDefaultPos>, <om IDMUSProdTimeline::InsertStripAtPos>.
HRESULT CTimelineCtl::AddStrip( 
    /* [in] */ IDMUSProdStrip* pIStrip)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pIStrip )
	{
		return E_POINTER;
	}

	if( m_pTimeStrip == NULL )
	{
		m_pTimeStrip = static_cast<CTimeStrip *>(pIStrip);
		ASSERT( m_pTimeStrip );
	}

	return InternalInsertStripAtPos( pIStrip, 0xffffffff, GUID_AllZeros, 1, 0 );
}

//  @method HRESULT | IDMUSProdTimeline | RemoveStrip | This method removes a strip from
//		the Timeline.
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip to remove
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStrip>
//	@rvalue E_INVALIDARG | <p pIStrip> was not previously added to the Timeline via
//		<om IDMUSProdTimeline::AddStrip>.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::AddStrip>
HRESULT CTimelineCtl::RemoveStrip(
	/* [in] */	IDMUSProdStrip* pIStrip)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT			hr = S_OK;
	RECT			rect, rectWin;

	if( NULL == pIStrip )
	{
		return E_POINTER;
	}
	// if the strip is already in the list, return E_FAIL
	StripList* pSL = FindStripList(pIStrip);
	if( !pSL )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		// If this strip is active, sent it a killfocus
		if ( m_pActiveStripList == pSL )
		{
			CallStripWMMessage( pSL, WM_KILLFOCUS, 0, 0 );
			m_pActiveStripList = NULL;
		}

		// If a strip is removed after the Timeline window is destroyed,
		// don't recompute the positions of the strips and scrollbars.
		if( ::IsWindow( m_hWnd ) )
		{
			GetClientRect( &rectWin );
			GetStripClientRect( pSL, &rect );
			rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
			InvalidateRect( &rectWin, FALSE );
			ComputeScrollBars();
		}

		// remove the strip from m_pStripList
		ASSERT(m_pStripList);
		if( m_pStripList )
		{
			StripList*	pTemp = m_pStripList;
			StripList*	pTempOld = NULL;
			while( pTemp )
			{
				if ( pTemp == pSL )
				{
					if (pTempOld)
					{
						pTempOld->m_pNext = pTemp->m_pNext;
					}
					else
					{
						m_pStripList = pTemp->m_pNext;
					}

					// Send WM_MOVE messages to all strips that were moved
					if( ::IsWindow(m_hWnd) )
					{
						pTemp = pTemp->m_pNext;
						while( pTemp )
						{
							pTemp->m_pStrip->OnWMMessage( WM_MOVE, 0, 0, 0, 0 );
							pTemp = pTemp->m_pNext;
						}
					}
					else
					{
						pTemp = NULL;
					}
				}
				else
				{
					pTempOld = pTemp;
					pTemp = pTemp->m_pNext;
				}
			}
		}

		if ( m_pMouseStripList == pSL )
		{
			m_pMouseStripList = NULL;
		}
		if ( m_pLastDragStripList == pSL )
		{
			m_pLastDragStripList = NULL;
		}
		IDMUSProdTimelineEdit* pITimelineEdit;
		if ( SUCCEEDED(pIStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**)&pITimelineEdit )))
		{
			pITimelineEdit->Release();
		}

		pIStrip->OnWMMessage( WM_DESTROY, 0, 0, 0, 0 );

		delete pSL;

		// If we need to scroll up, do so
		if( m_lYScrollPos && ::IsWindow( m_hWnd ) )
		{
			RECT rect, rectS;
			GetClientRect(&rect);
			m_ScrollHorizontal.GetClientRect(&rectS);
			rect.bottom -= rectS.bottom;

			long lMaxScroll = TotalStripHeight() - rect.bottom;
			if( lMaxScroll < m_lYScrollPos )
			{
				int nPos;
				if( lMaxScroll < 1 )
				{
					nPos = 0;
				}
				else
				{
					nPos = ( lMaxScroll * m_ScrollVertical.GetScrollLimit()) / lMaxScroll;
				}
				int iTemp = 0;
				OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, nPos ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
			}
		}
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | GetParam | This method retrieves data of the specified type
//		from a strip manager in the Timeline.
//
//  @parm   REFGUID | rguidType | Reference to the identifier of the type of data to obtain.
//		See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible data types.  Strips can also define
//		their own types for custom data.
///  @parm   DWORD | dwGroupBits | Which track group(s) to scan for the strip manager in.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To scan all strip managers
//		regardless of groups, set this parameter to 0xFFFFFFFF. 
//  @parm   DWORD | dwIndex | Index of the strip manager in the group(s) from which to obtain the data. 
//  @parm   MUSIC_TIME | mtTime | Time from which to obtain the data.
//	@parm   MUSIC_TIME* | pmtNext | Address of a variable to receive the time (relative to
//		the current time) until which the data is valid. If this returns a value of 0, it means
//		either that the data will always be valid, or that it is unknown when it will become
//		invalid. If this information is not needed, <p pmtNext> may be set to NULL. 
//  @parm   void* | pData | Address of an allocated structure in which the data is to be returned. This
//		structure must be of the appropriate kind and size for the data type identified by <p rguidType>.
//
//	@comm	This method is analagous to the DirectMusic method <om IDirectMusicPerformance::GetParam>.
//
//	@comm	Strip managers are searched in the order that they are listed in the Timeline.  See
//		<om IDMUSProdTimeline::AddStripMgr> for the order they are listed.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pData>
//	@rvalue E_INVALIDARG | No strip managers support the requested <p rguidType>.
//	@rvalue E_UNEXPECTED | An internal error occurred.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimeline::SetParam>, <om IDMUSProdStripMgr::GetParam>
HRESULT CTimelineCtl::GetParam(/* [in] */  REFGUID		guidType,
				/* [in] */  DWORD		dwGroupBits,
				/* [in] */  DWORD		dwIndex,
				/* [in] */  MUSIC_TIME	mtTime,
				/* [out] */ MUSIC_TIME*	pmtNext,
				/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	StripMgrList*	pScan;
	HRESULT hr = E_INVALIDARG;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_dwGroupBits & dwGroupBits )
		{
			ASSERT( pScan->m_pStripMgr != NULL );
			if ( pScan->m_pStripMgr == NULL )
			{
				return E_UNEXPECTED;
			}
			if ( pScan->m_pStripMgr->IsParamSupported( guidType ) == S_OK )
			{
				/*
				// Get the track extras flags
				VARIANT varTrackExtras;
				varTrackExtras.vt = VT_BYREF;
				DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
				if( pScan->m_pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackExtras ) == S_OK )
				{
					if( !(ioTrackExtrasHeader.dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED) )
					{
						continue;
					}
				}
				*/

				if ( dwIndex == 0 )
				{
					if ( pData == NULL )
					{
						return E_POINTER;
					}
					else
					{
						if( SUCCEEDED( pScan->m_pStripMgr->GetParam( guidType, mtTime, pmtNext, pData ) ) )
						{
							return S_OK;
						}
						else
						{
							hr = E_UNEXPECTED;
						}
					}
				}
				else
				{
					dwIndex--;
				}
			}
		}
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | SetParam | This method sets data on a
//		strip manager in the timeline
//
//  @parm   REFGUID | rguidType | Reference to the identifier of the type of data to set.
//		See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible data types.  Strips can also define
//		their own types for custom data.
//  @parm   DWORD | dwGroupBits | Which track group(s) to scan for the strip manager in.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To scan all strip managers
//		regardless of groups, set this parameter to 0xFFFFFFFF. 
//  @parm   DWORD | dwIndex | Index of the strip manager in the group(s) identified by <p dwGroupBits> where data is to be set. 
//  @parm   MUSIC_TIME | mtTime | Time at which to set the data.
//  @parm   void* | pData | Address of structure containing the data. This structure must be of
//		the appropriate kind and size for the data type identified by rguidType.
//
//	@comm	This method is analagous to the DirectMusic method <om IDirectMusicPerformance::SetParam>.
//
//	@comm	Strip managers are searched in the order that they are listed in the Timeline.  See
//		<om IDMUSProdTimeline::AddStripMgr> for the order they are listed.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pData>
//	@rvalue E_INVALIDARG | No strip managers support the requested <p rguidType>.
//	@rvalue E_UNEXPECTED | An internal error occurred.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimeline::GetParam>, <om IDMUSProdStripMgr::SetParam>
HRESULT CTimelineCtl::SetParam(/* [in] */ REFGUID		guidType,
				/* [in] */ DWORD		dwGroupBits,
				/* [in] */ DWORD		dwIndex,
				/* [in] */ MUSIC_TIME	mtTime,
				/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	if( ::IsEqualGUID( GUID_TimelineSetSegStartTime, guidType ) )
	{
		ASSERT( pData );
		if( pData )
		{
			// Save the current elapsed time, so we can display it
			if( (*(REFERENCE_TIME*)pData) == 0 )
			{
				REFERENCE_TIME rtRefTime;
				if( m_pIDMPerformance && (m_rtSegmentStart != 0)
				&&	SUCCEEDED( m_pIDMPerformance->GetTime( &rtRefTime, NULL ) ) )
				{
					m_rtLastElapsedTime = rtRefTime - m_rtSegmentStart;
				}
				else
				{
					m_rtLastElapsedTime = 0;
				}
			}

			m_rtSegmentStart = *(REFERENCE_TIME*)pData;
			// Don't do this - it causes bad things to happen in MFC if
			// we're not in a message handler thread.
			/*
			if( m_fShowRealTime )
			{
				// Initialize status bar panes to '0'
				CString strText;
				RefTimeToString( 0, strText );
				BSTR bstrName = strText.AllocSysString();
				m_pDMUSProdFramework->SetStatusBarPaneText( 0, bstrName, TRUE );
			}
			*/
		}
		return S_OK;
	}
	if( ::IsEqualGUID( GUID_TimelineShowRealTime, guidType ) )
	{
		ASSERT( pData );
		if( pData )
		{
			m_hKeyRealTimeStatusBar = *(HANDLE *)pData;
			if( m_hKeyRealTimeStatusBar )
			{
				// Initialize status bar panes
				REFERENCE_TIME rtRefTime = 0;
				CString strText;
				ClocksToRefTime( m_lCursor, &rtRefTime );
				RefTimeToString( rtRefTime, IDS_OFFSET_TIME, IDS_OFFSET_NEG_TIME, strText );
				m_pDMUSProdFramework->SetStatusBarPaneText( m_hKeyRealTimeStatusBar, 1, strText.AllocSysString(), TRUE );

				rtRefTime = 0;
				if( m_pIDMPerformance && (m_rtSegmentStart != 0)
				&&	SUCCEEDED( m_pIDMPerformance->GetTime( &rtRefTime, NULL ) ) )
				{
					rtRefTime -= m_rtSegmentStart;
					RefTimeToString( rtRefTime, IDS_ELAPSED_TIME, IDS_ELAPSED_NEG_TIME, strText );
				}
				else if( m_rtSegmentStart == 0 )
				{
					// Display the last value of the ElapsedTime counter
					RefTimeToString( m_rtLastElapsedTime, IDS_ELAPSED_TIME, IDS_ELAPSED_NEG_TIME, strText );
				}
				m_pDMUSProdFramework->SetStatusBarPaneText( m_hKeyRealTimeStatusBar, 0, strText.AllocSysString(), TRUE );
			}
		}
		return S_OK;
	}

	StripMgrList*	pScan;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_dwGroupBits & dwGroupBits )
		{
			ASSERT( pScan->m_pStripMgr != NULL );
			if ( pScan->m_pStripMgr == NULL )
			{
				return E_UNEXPECTED;
			}
			if ( pScan->m_pStripMgr->IsParamSupported( guidType ) == S_OK )
			{
				if ( dwIndex == 0 )
				{
					if ( pData == NULL )
					{
						return E_POINTER;
					}
					else
					{
						return pScan->m_pStripMgr->SetParam( guidType, mtTime, pData );
					}
				}
				else
				{
					dwIndex--;
				}
			}
		}
	}
	return E_INVALIDARG;
}

//  @method HRESULT | IDMUSProdTimeline | GetStripMgr | This method retrieves a pointer to the specified
//		strip manager.
//
//  @parm   REFGUID | rguidType | Reference to the identifier of the type of data to search for.
//		See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible data types.  Strips can also define
//		their own types for custom data.
//  @parm   DWORD | dwGroupBits | Which track group(s) to scan for the strip manager in.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To scan all tracks
//		regardless of groups, set this parameter to 0xFFFFFFFF. 
//  @parm   DWORD | dwIndex | Zero-based index into the list of tracks of type <p rguidType>
//		and in group <p dwGroupBits> to return. If multiple groups are selected in <p dwGroupBits>,
//		this index will indicate the nth track of type <p rguidType> encountered in the union of
//		the groups selected. 
//  @parm   <i IDMUSProdStripMgr>** | ppIStripMgr | Address of a variable to receive a pointer to
//		the strip manager.
//
//	@comm	This method is analagous to the DirectMusic method <om IDirectMusicPerformance::GetTrack>.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p ppIStripMgr>
//	@rvalue E_INVALIDARG | No matching strip manager was found
//	@rvalue E_UNEXPECTED | An internal error occurred.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdStripMgr::IsParamSupported>
HRESULT CTimelineCtl::GetStripMgr(/* [in] */ REFGUID				guidType,
					/* [in] */ DWORD				dwGroupBits,
					/* [in] */ DWORD				dwIndex,
					/* [out,retval] */ IDMUSProdStripMgr**	ppStripMgr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppStripMgr == NULL )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	StripMgrList*	pScan;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_dwGroupBits & dwGroupBits )
		{
			ASSERT( pScan->m_pStripMgr != NULL );
			if ( pScan->m_pStripMgr == NULL )
			{
				return E_UNEXPECTED;
			}
			if ( pScan->m_pStripMgr->IsParamSupported( guidType ) == S_OK )
			{
				if ( dwIndex == 0 )
				{
					*ppStripMgr = pScan->m_pStripMgr;
					pScan->m_pStripMgr->AddRef();
					return S_OK;
				}
				else
				{
					dwIndex--;
				}
			}
		}
	}

	DMUS_IO_TRACK_HEADER ioTrackHeader;
	VARIANT varTrackHeader;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_dwGroupBits & dwGroupBits )
		{
			ASSERT( pScan->m_pStripMgr != NULL );
			if ( pScan->m_pStripMgr == NULL )
			{
				return E_UNEXPECTED;
			}

			ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
			varTrackHeader.vt = VT_BYREF;
			V_BYREF(&varTrackHeader) = &ioTrackHeader;
			if ( SUCCEEDED( pScan->m_pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
			{
				if( ::IsEqualGUID( guidType, ioTrackHeader.guidClassID ) )
				{
					if ( dwIndex == 0 )
					{
						*ppStripMgr = pScan->m_pStripMgr;
						pScan->m_pStripMgr->AddRef();
						return S_OK;
					}
					else
					{
						dwIndex--;
					}
				}
			}
		}
	}

	return E_INVALIDARG;
}

//  @method HRESULT | IDMUSProdTimeline | InsertStripAtDefaultPos | This method inserts a strip into
//		timeline, ordering them by using <p rclsidType>, <p dwGroupBits> and <p dwIndex>.
//
//	@comm	Using the <p dwGroupBits> parameter and the <p rclsidType> parameter, the Timeline determines a
//		position for <p pIStrip> in its display list.<nl>
//		They are ordered first by the least track group number they belong to, then in the following order,
//		then by the value of <p dwIndex>, then by the order they were inserted:<nl>
//		Chord<nl>
//		Signpost<nl>
//		ChordMap Reference<nl>
//		Groove<nl>
//		Tempo<nl>
//		Style Reference<nl>
//		Sequence<nl>
//		Time Signature<nl>
//		Band<nl>
//		Mute<nl>
//		All other strips
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip to add.
//  @parm	REFCLSID | rclsidType | The CLSID of the strip to add.
//  @parm   DWORD | dwGroupBits | Which track group(s) to add the strip in.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group.
//  @parm   DWORD | dwIndex | Where in the list of matching strips to add the strip..
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStrip>
//	@rvalue E_FAIL | <p pIStrip> was previously added.
//	@rvalue E_INVALIDARG | 0 was passed as <p dwGroupBits>.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::RemoveStrip>,
//		<om IDMUSProdTimeline::InsertStripAtPos>, <om IDMUSProdTimeline::AddStrip>
HRESULT CTimelineCtl::InsertStripAtDefaultPos(
		/* [in] */ IDMUSProdStrip* pStrip,
		/* [in] */ REFCLSID		clsidType,
		/* [in] */ DWORD		dwGroupBits,
		/* [in] */ DWORD		dwIndex)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	DWORD		dwPosition = 0;

	if( NULL == pStrip )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// if the strip is already in the list, return E_FAIL
	StripList*	pScan;
	for( pScan = m_pStripList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_pStrip == pStrip )
		{
			pStrip->Release();
			return E_FAIL;
		}
	}

	// determine the default position
	dwPosition = 1;
	if( m_pStripList )
	{
		if( m_pStripList->m_pNext != NULL )
		{
			// Remember to skip over the first strip.
			StripList*	pTemp = m_pStripList->m_pNext;
			int nMyId = StripCLSIDToInt( clsidType );
			BSTR bstrMyName = NULL;
			VARIANT var;
			if( SUCCEEDED( pStrip->GetStripProperty( SP_NAME, &var ) ) && (var.vt == VT_BSTR) )
			{
				bstrMyName = V_BSTR(&var);
			}
			IUnknown *punkMyStripMgr = NULL;
			if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &var ) ) && (var.vt == VT_UNKNOWN) )
			{
				punkMyStripMgr = V_UNKNOWN(&var);
			}

			IUnknown *punkLastStripMgr = NULL;
			IUnknown *punkTempStripMgr = NULL;
			while( pTemp )
			{
				BSTR bstrTempName = NULL;
				if( SUCCEEDED( pTemp->m_pStrip->GetStripProperty( SP_NAME, &var ) ) && (var.vt == VT_BSTR) )
				{
					bstrTempName = V_BSTR(&var);
				}
				if( SUCCEEDED( pTemp->m_pStrip->GetStripProperty( SP_STRIPMGR, &var ) ) && (var.vt == VT_UNKNOWN) )
				{
					punkTempStripMgr = V_UNKNOWN(&var);
				}
				// (If the last StripMgr and the temp StripMgr are different and the last StripMgr and my
				// StripMgr are the same)
				// OR
				// (If the last StripMgr and the temp StripMgr are different, or if the last, temp, and my
				// StripMgr are all the same, check if the strip being inserted should go BEFORE pTemp.)
				// If so, break.
				if( ((punkLastStripMgr != punkTempStripMgr) && (punkLastStripMgr == punkMyStripMgr))
				||	(((punkLastStripMgr != punkTempStripMgr) || (punkMyStripMgr == punkTempStripMgr))
					 && CompareStrips( StripCLSIDToInt(pTemp->m_clsidType), pTemp->m_dwGroupBits, pTemp->m_dwIndex, bstrTempName,
								   nMyId, dwGroupBits, dwIndex, bstrMyName ) == 2) )
				{
					if( bstrTempName )
					{
						::SysFreeString( bstrTempName );
					}
					if( punkLastStripMgr )
					{
						punkLastStripMgr->Release();
					}
					break;
				}
				if( bstrTempName )
				{
					::SysFreeString( bstrTempName );
				}
				if( punkLastStripMgr )
				{
					punkLastStripMgr->Release();
				}
				punkLastStripMgr = punkTempStripMgr;
				dwPosition++;
				pTemp = pTemp->m_pNext;
			}

			if( punkTempStripMgr )
			{
				punkTempStripMgr->Release();
			}
			if( punkMyStripMgr )
			{
				punkMyStripMgr->Release();
			}

			if( bstrMyName )
			{
				::SysFreeString( bstrMyName );
			}
		}
	}

	return InternalInsertStripAtPos( pStrip, dwPosition, clsidType, dwGroupBits, dwIndex );
}

int StripCLSIDToInt( REFCLSID clsidType )
{
	if( memcmp( &clsidType, &CLSID_DirectMusicTempoTrack, sizeof(GUID) ) == 0 )
	{
		return 0;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicTimeSigTrack, sizeof(GUID) ) == 0 )
	{
		return 10;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicChordMapTrack, sizeof(GUID) ) == 0 )
	{
		return 20;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicSignPostTrack, sizeof(GUID) ) == 0 )
	{
		return 30;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicChordTrack, sizeof(GUID) ) == 0 )
	{
		return 40;
	}
	else if( (memcmp( &clsidType, &CLSID_DirectMusicMotifTrack, sizeof(GUID) ) == 0)
		 ||	 (memcmp( &clsidType, &CLSID_DirectMusicSegmentTriggerTrack, sizeof(GUID) ) == 0) )
	{
		return 50;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicCommandTrack, sizeof(GUID) ) == 0 )
	{
		return 60;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicStyleTrack, sizeof(GUID) ) == 0 )
	{
		return 70;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicMelodyFormulationTrack, sizeof(GUID) ) == 0 )
	{
		return 80;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicPatternTrack, sizeof(GUID) ) == 0 )
	{
		return 90;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicSeqTrack, sizeof(GUID) ) == 0 )
	{
		return 100;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicWaveTrack, sizeof(GUID) ) == 0 )
	{
		return 110;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicBandTrack, sizeof(GUID) ) == 0 )
	{
		return 120;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicParamControlTrack, sizeof(GUID) ) == 0 )
	{
		return 130;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicMuteTrack, sizeof(GUID) ) == 0 )
	{
		return 140;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicScriptTrack, sizeof(GUID) ) == 0 )
	{
		return 150;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicLyricsTrack, sizeof(GUID) ) == 0 )
	{
		return 160;
	}
	else
	{
		return 170;
	}
}

int CompareStrips( int nType1, DWORD dwGroups1, DWORD dwIndex1, BSTR bstrName1, int nType2, DWORD dwGroups2, DWORD dwIndex2, BSTR bstrName2 )
{
	// If the group bits are equal, check the types
	if( dwGroups1 == dwGroups2 )
	{
		if( nType1 == nType2 )
		{
			if( dwIndex1 == dwIndex2 )
			{
				if( bstrName1 && bstrName2 )
				{
					CString strName1 = bstrName1;
					CString strName2 = bstrName2;
					return strName1.CompareNoCase( strName2 ) < 0 ? 1 : 2;
				}
			}
			return long(dwIndex1) <= long(dwIndex2) ? 1 : 2;
		}
		return nType1 < nType2 ? 1 : 2;
	}

	// Continue while both group bits have at least one bit still set
	while( dwGroups1 && dwGroups2 )
	{
		if( (dwGroups1 & dwGroups2 & 1) == 0 )
		{
			// One of the first bits of dwGroups1 or dwGroups2 is zero
			if( dwGroups1 & 1 )
			{
				// The first bit of dwGroups1 is one and at least one bit in dwGroups2 is set -
				// #1 should go first
				return 1;
			}
			else if( dwGroups2 & 1 )
			{
				// The first bit of dwGroups2 is one and at least one bit in dwGroups1 is set -
				// #2 should go first
				return 2;
			}
			// else both of the first bits are zero - try the next bit
		}
		else
		{
			// Both of the first bits of dwGroups1 and dwGroups2 are one
			if( nType1 < nType2 )
			{
				return 1; // #1 should go first
			}
			else if ( nType1 > nType2 )
			{
				return 2; // #2 should go first
			}
			// else both are the same type - check the next bit
		}
		dwGroups1 = dwGroups1 >> 1;
		dwGroups2 = dwGroups2 >> 1;
	}

	if( dwGroups1 )
	{
		// Some of the bits in dwGroups1 are set - #2 should go first
		return 2;
	}
	else if( dwGroups2 )
	{
		// Some of the bits in dwGroups2 are set - #1 should go first
		return 1;
	}
	// dwGroups1 == dwGroups2 == 0 (Shouldn't happen!)
	ASSERT( FALSE );
	return 1;
}

HRESULT CTimelineCtl::InternalInsertStripAtPos( IDMUSProdStrip* pStrip, DWORD dwPosition, REFCLSID clsidType, DWORD dwGroupBits, DWORD dwIndex )
{
	HRESULT			hr = S_OK;
	StripList*		pSL;

	if( pStrip == NULL )
	{
		return E_POINTER;
	}

	if( dwPosition == 0 )
	{
		return E_INVALIDARG;
	}
	dwPosition--;

	// if the strip is already in the list, return E_FAIL
	StripList*	pScan;
	for( pScan = m_pStripList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_pStrip == pStrip )
		{
			pStrip->Release();
			return E_FAIL;
		}
	}
	// add the strip to the list of strips
	pSL = new StripList( pStrip, clsidType );
	if( pSL == NULL )
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pSL->m_dwGroupBits = dwGroupBits;
		pSL->m_dwIndex = dwIndex;

		// ask the Strip how tall it wants to be
		VARIANT var;
		if( SUCCEEDED( pStrip->GetStripProperty( SP_DEFAULTHEIGHT, &var )))
		{
			pSL->m_lHeight = V_INT(&var);
		}
		else if( SUCCEEDED( pStrip->GetStripProperty( SP_MAXHEIGHT, &var )))
		{
			pSL->m_lHeight = V_INT(&var);
		}
		else if( SUCCEEDED( pStrip->GetStripProperty( SP_MINHEIGHT, &var )))
		{
			pSL->m_lHeight = V_INT(&var);
		}

		// add the strip to the specified position
		if( m_pStripList )
		{
			StripList* pTemp = m_pStripList;
			while( pTemp->m_pNext && dwPosition > 0 )
			{
				pTemp = pTemp->m_pNext;
				dwPosition--;
			}
			pSL->m_pNext = pTemp->m_pNext;
			pTemp->m_pNext = pSL;

			// call the strip's callback that it has been added
			pStrip->OnWMMessage( WM_CREATE, 0, 0, 0, 0 );

			// Send WM_MOVE messages to all strips that were moved
			if( ::IsWindow(m_hWnd) )
			{
				pTemp = pSL->m_pNext;
				while( pTemp )
				{
					pTemp->m_pStrip->OnWMMessage( WM_MOVE, 0, 0, 0, 0 );
					pTemp = pTemp->m_pNext;
				}
			}
		}
		else
		{
			m_pStripList = pSL;

			// call the strip's callback that it has been added
			pStrip->OnWMMessage( WM_CREATE, 0, 0, 0, 0 );
		}
		// Compute what the scroll bars look like
		ComputeScrollBars();

		RECT rectWin, rect;
		GetClientRect( &rectWin );
		GetStripClientRect( pSL, &rect );
		rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
		InvalidateRect( &rectWin, FALSE );
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | EnumStrip | This method enumerates through all strips
//		displayed within the Timeline.
//
//  @parm   DWORD | dwEnum | Zero-based index into the Timeline's strip list. 
//  @parm   <i IDMUSProdStrip>** | ppIStrip | Address of a variable to receive a pointer to the strip.
//		The caller is responsible for Release()ing the pointer when it is done with it.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p ppIStrip>
//	@rvalue E_FAIL | There is no strip at the given index.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>
HRESULT CTimelineCtl::EnumStrip(
		/* [in] */  DWORD			 dwEnum,
		/* [in] */  IDMUSProdStrip** ppStrip)
{
	if( ppStrip == NULL )
	{
		return E_POINTER;
	}
	StripList	*pSL;

	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( dwEnum == 0 )
		{
			*ppStrip = pSL->m_pStrip;
			if( pSL->m_pStrip )
			{
				pSL->m_pStrip->AddRef();
			}
			return S_OK;
		}
		dwEnum--;
	}
	*ppStrip = NULL;
	return E_FAIL;
}


//  @method HRESULT | IDMUSProdTimeline | InsertStripAtPos | This method inserts a strip at the
//		specified position.
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip to add to the Timeline.  The strip must not
//		have been previously added to the Timeline.
//  @parm   DWORD | dwPosition | The 0-based position to add the strip at.
//
//	@comm	No strip may be inserted before the Time Strip, the first strip in the Timeline.
//		Consequently, 0 is an invalid value for <p dwPosition>.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStrip>
//	@rvalue E_FAIL | The operation failed.
//	@rvalue E_OUTOFMEMORY | There was not enough available memory to complete the operation.
//	@rvalue E_INVALIDARG | dwPosition is 0.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::RemoveStrip>,
//		<om IDMUSProdTimeline::InsertStripAtDefaultPos>, <om IDMUSProdTimeline::AddStrip>
HRESULT CTimelineCtl::InsertStripAtPos(
		/* [in] */  IDMUSProdStrip*	pStrip,
		/* [in] */  DWORD		    dwPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pStrip != NULL );
	if( pStrip == NULL )
	{
		return E_POINTER;
	}

	DMUS_IO_TRACK_HEADER ioTrackHeader;
	ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );

	VARIANT varStripMgr;
	if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
	&&	(varStripMgr.vt == VT_UNKNOWN) && (V_UNKNOWN(&varStripMgr) != NULL) )
	{
		IDMUSProdStripMgr* pIStripMgr;
		if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pIStripMgr ) ) )
		{
			VARIANT varTrackHeader;
			varTrackHeader.vt = VT_BYREF;
			V_BYREF(&varTrackHeader) = &ioTrackHeader;
			if( FAILED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
			{
				TRACE("Timeline: Unable to get StripMgr's TrackHeader\n");
			}

			pIStripMgr->Release();
		}
		V_UNKNOWN(&varStripMgr)->Release();
	}

	return InternalInsertStripAtPos( pStrip, dwPosition, ioTrackHeader.guidClassID, ioTrackHeader.dwGroup, ioTrackHeader.dwPosition );
}


//  @method HRESULT | IDMUSProdTimeline | StripToWindowPos | This method converts a point from strip
//		coordinates to Timeline Window coordinates
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip from whose coordinates to convert from.
//  @parm   POINT* | pPoint | Address of the point to convert.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pPoint> or <p pIStrip>
//	@rvalue E_INVALIDARG | <p pIStrip> was not previously added to the Timeline
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>
HRESULT CTimelineCtl::StripToWindowPos(
		/* [in] */		IDMUSProdStrip*	pIStrip,
		/* [in,out] */	POINT*			pPoint)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if( NULL == pIStrip || NULL == pPoint )
	{
		return E_POINTER;
	}

	if (m_pStripList == NULL)
	{
		return E_INVALIDARG;
	}

	StripList* pTempSL;
	// subtract the heights of any strips above this one
	for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
	{
		if( pIStrip == pTempSL->m_pStrip )
		{
			return StripPointToClient( pTempSL, pPoint );
		}
	}
	return E_INVALIDARG;
}


//  @method HRESULT | IDMUSProdTimeline | AddToNotifyList | This method enables a StripMgr to receive
//		notifications of type <p rguidType> send to at least one group of <p dwGroupBits>
//
//  @parm   <i IDMUSProdStripMgr>* | pIStripMgr | The strip manager to add.
//  @parm   REFGUID | rguidType | Reference to the identifier of the notification type to start
//		receiving notifications for.  See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible notifications.  Strips can also define
//		their own types for custom notifications.
//  @parm   DWORD | dwGroupBits | Which track group(s) to receive notifications for.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To receive all notifications
//		of the type specified by <p rguidType> regardless of groups, set this parameter to 0xFFFFFFFF. 
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStripMgr>
//	@rvalue E_OUTOFMEMORY | Not enough memory available
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdStripMgr::OnUpdate>, <om IDMUSProdTimeline::RemoveFromNotifyList>,
//		<om IDMUSProdTimeline::NotifyStripMgrs>
HRESULT CTimelineCtl::AddToNotifyList(
		/* [in] */	IDMUSProdStripMgr*	pIStripMgr,
		/* [in] */	REFGUID				rguidType,
		/* [in] */	DWORD				dwGroupBits)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( pIStripMgr == NULL )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	NotifyEntry* pNotifyEntry = NULL;
	BOOL fFound = FALSE;
	NotifyListEntry* pNotifyListEntry = NULL;

	try
	{
		// Look through m_lstNotifyEntry for guidNotify
		POSITION pos;
		pos = m_lstNotifyEntry.GetHeadPosition();
		while ( pos != NULL && !fFound )
		{
			pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
			if ( InlineIsEqualGUID( pNotifyEntry->m_guid, rguidType ) )
			{
				// Found guidNotify, add pNotifyListEntry to the end of the list
				fFound = TRUE;

				pNotifyListEntry = new NotifyListEntry;
				pNotifyListEntry->pIStripMgr = pIStripMgr;
				//pIStripMgr->AddRef();
				pNotifyListEntry->dwGroupBits = dwGroupBits;

				pNotifyEntry->m_lstNotifyListEntry.AddTail( pNotifyListEntry );
			}
		}

		// Didn't find guidNotify, add a new NotifyEntry to the end of m_lstNotifyEntry
		if ( !fFound )
		{
			pNotifyEntry = new NotifyEntry( pIStripMgr, rguidType, dwGroupBits );
			m_lstNotifyEntry.AddTail( pNotifyEntry );
		}
	}
	catch( CMemoryException *pMemoryException )
	{
		if( pNotifyListEntry )
		{
			delete pNotifyListEntry;
		}
		if( pNotifyEntry )
		{
			delete pNotifyEntry;
		}
		pMemoryException->Delete();
		return E_OUTOFMEMORY;
	}
		
	return S_OK;
}


//  @method HRESULT | IDMUSProdTimeline | RemoveFromNotifyList | This method stops a StripMgr from
//		receiving notifications of type <p rguidType> for groups in <p dwGroupBits>
//
//  @parm   <i IDMUSProdStripMgr>* | pIStripMgr | The strip manager to remove.
//  @parm   REFGUID | rguidType |  Reference to the identifier of the notification type to stop
//		receiving notifications for.  See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible notifications.  Strips can also define
//		their own types for custom notifications.
//  @parm   DWORD | dwGroupBits | Which track group(s) to stop receiving notifications for.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To stop receiving all notifications
//		of the type specified by <p rguidType> regardless of groups, set this parameter to 0xFFFFFFFF. 
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStripMgr>
//	@rvalue E_INVALIDARG | The specified <p pIStripMgr> can not be found
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdStripMgr::OnUpdate>, <om IDMUSProdTimeline::AddToNotifyList>,
//		<om IDMUSProdTimeline::NotifyStripMgrs>
HRESULT CTimelineCtl::RemoveFromNotifyList(
		/* [in] */	IDMUSProdStripMgr*	pIStripMgr,
		/* [in] */	REFGUID				rguidType,
		/* [in] */	DWORD				dwGroupBits)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( pIStripMgr == NULL )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	NotifyEntry* pNotifyEntry = NULL;
	BOOL fFound = FALSE;

	// Look through m_lstNotifyEntry for guidNotify
	POSITION pos;
	pos = m_lstNotifyEntry.GetHeadPosition();
	while ( pos != NULL && !fFound )
	{
		pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
		if ( InlineIsEqualGUID( pNotifyEntry->m_guid, rguidType ) )
		{
			// Found guidNotify, now find pIStripMgr
			NotifyListEntry* pNotifyListEntry = NULL;
			POSITION pos2;
			pos2 = pNotifyEntry->m_lstNotifyListEntry.GetHeadPosition( );
			while ( pos2 != NULL && !fFound )
			{
				POSITION pos3 = pos2;
				pNotifyListEntry = pNotifyEntry->m_lstNotifyListEntry.GetNext( pos2 );
				if( pNotifyListEntry->pIStripMgr == pIStripMgr &&
					pNotifyListEntry->dwGroupBits == dwGroupBits )
				{
					// We've found it, now remove it from the list and delete our entry
					fFound = TRUE;
					pNotifyEntry->m_lstNotifyListEntry.RemoveAt( pos3 );
					delete pNotifyListEntry;

					// Check if the list is empty
					if ( pNotifyEntry->m_lstNotifyListEntry.IsEmpty() )
					{
						// If the list is empty, remove it from m_lstNotifyEntry
						pos2 = m_lstNotifyEntry.Find( pNotifyEntry );
						ASSERT( pos2 );
						if ( pos2 )
						{
							m_lstNotifyEntry.RemoveAt( pos2 );
							delete pNotifyEntry;
						}
					}
				}
			}
		}
	}

	// Didn't find guidNotify, add a new NotifyEntry to the end of m_lstNotifyEntry
	if ( !fFound )
	{
		return E_INVALIDARG;
	}
	return S_OK;
}


//  @method HRESULT | IDMUSProdTimeline | NotifyStripMgrs | This method broadcasts the specified
//		notification to all registered strip managers that belong to at least one of <p dwGroupBits>
//
//  @parm   REFGUID | rguidType |  Reference to the identifier of the notification type to send.
//		See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible notifications.  Strips can also define
//		their own types for custom notifications.
///  @parm   DWORD | dwGroupBits | Which track group(s) to notify.  A value of 0 is invalid. Each bit in
//		<p dwGroupBits> corresponds to a track group.  To notify all strip managers that asked to hear
//		notifications of the type specified by <p rguidType> regardless of groups, set this parameter to 0xFFFFFFFF. 
//
//  @rvalue S_OK | The operation was successful
//	@rvalue E_FAIL | No matching strip managers were found, so no notifications were sent
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdStripMgr::OnUpdate>, <om IDMUSProdTimeline::AddToNotifyList>,
//		<om IDMUSProdTimeline::RemoveFromNotifyList>
HRESULT CTimelineCtl::NotifyStripMgrs(
		/* [in] */	REFGUID		rguidType,
		/* [in] */	DWORD		dwGroupBits,
		/* [in] */  void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// If displaying realtime in status bar, update it when tempo changes
	if( m_pDMUSProdFramework && m_hKeyRealTimeStatusBar
	&&	((rguidType == GUID_TempoParam) || (rguidType == GUID_Segment_AllTracksAdded)) )
	{
		// Initialize status bar panes
		REFERENCE_TIME rtRefTime = 0;
		CString strText;
		ClocksToRefTime( m_lCursor, &rtRefTime );
		RefTimeToString( rtRefTime, IDS_OFFSET_TIME, IDS_OFFSET_NEG_TIME, strText );
		m_pDMUSProdFramework->SetStatusBarPaneText( m_hKeyRealTimeStatusBar, 1, strText.AllocSysString(), TRUE );

		rtRefTime = 0;
		if( m_pIDMPerformance && (m_rtSegmentStart != 0)
		&&	SUCCEEDED( m_pIDMPerformance->GetTime( &rtRefTime, NULL ) ) )
		{
			rtRefTime -= m_rtSegmentStart;
			RefTimeToString( rtRefTime, IDS_ELAPSED_TIME, IDS_ELAPSED_NEG_TIME, strText );
		}
		else if( m_rtSegmentStart == 0 )
		{
			// Display the last value of the ElapsedTime counter
			RefTimeToString( m_rtLastElapsedTime, IDS_ELAPSED_TIME, IDS_ELAPSED_NEG_TIME, strText );
		}
		m_pDMUSProdFramework->SetStatusBarPaneText( m_hKeyRealTimeStatusBar, 0, strText.AllocSysString(), TRUE );
	}

	// Find the NotifyEntry corresponding to rguidType
	NotifyEntry* pNotifyEntry = NULL;
	BOOL fFound = FALSE;
	POSITION pos;
	pos = m_lstNotifyEntry.GetHeadPosition();
	while ( pos != NULL && !fFound )
	{
		pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
		if ( InlineIsEqualGUID( pNotifyEntry->m_guid, rguidType ) )
		{
			VARIANT var;

			BOOL fOrigFreezeUndo = FALSE;
			if( SUCCEEDED( GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
			{
				fOrigFreezeUndo = V_BOOL(&var);
			}

			// Freeze undo queue
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			SetTimelineProperty( TP_FREEZE_UNDO, var );

			// Found the NotifyEntry corresponding to rguidType
			// Now, call OnUpdate for all matching StripMgrs
			HRESULT hr = E_FAIL;
			POSITION pos2;
			NotifyListEntry *pNotifyListEntry;
			pos2 = pNotifyEntry->m_lstNotifyListEntry.GetHeadPosition();
			while ( pos2 != NULL )
			{
				pNotifyListEntry = pNotifyEntry->m_lstNotifyListEntry.GetNext( pos2 );
				ASSERT( pNotifyListEntry );
				if ( pNotifyListEntry && (pNotifyListEntry->dwGroupBits & dwGroupBits) )
				{
					ASSERT( pNotifyListEntry->pIStripMgr );
					if( pNotifyListEntry->pIStripMgr )
					{
						fFound = TRUE;
						HRESULT hr2;
						hr2 = pNotifyListEntry->pIStripMgr->OnUpdate( rguidType, pNotifyListEntry->dwGroupBits & dwGroupBits, pData );
						if( (hr != S_OK) && (FAILED( hr ) || SUCCEEDED( hr2 )) )
						{
							hr = hr2;
						}
					}
				}
			}

			// Restore undo queue
			var.vt = VT_BOOL;
			V_BOOL(&var) = (short)fOrigFreezeUndo;
			SetTimelineProperty( TP_FREEZE_UNDO, var );

			return hr;
		}
	}
	return E_FAIL;
}


//  @method HRESULT | IDMUSProdTimeline | AllocTimelineDataObject | This method allocates an object that
//		implements the <i IDMUSProdTimelineDataObject> interface.
//
//  @parm	<i IDMUSProdTimelineDataObject> | ppITimelineDataObject | Address of a variable to receive a pointer
//		to the TimelineDataObject.
//
//	@comm	A Timeline DataObject simplifies dealing with the clipboard, and allows the Timeline to manage
//		multiple-strip copy and paste operations.
//
//  @rvalue S_OK | The operation was successful
//	@rvalue E_OUTOFMEMORY | Not enough memory available to allocate a TimelineDataObject
//	@rvalue E_POINTER | <p ppITimelineDataObject> is NULL
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdTimelineDataObject>
HRESULT CTimelineCtl::AllocTimelineDataObject(
		/* [out,retval] */ IDMUSProdTimelineDataObject**	ppITimelineDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate ppITimelineDataObject
	if( ppITimelineDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize variables
	HRESULT hr = S_OK;
	CTimelineDataObject *pTimelineDataObject = NULL;

	// Try and allocate a CTimelineDataObject object
	try
	{
		pTimelineDataObject = new CTimelineDataObject;
	}
	// Catch out of memory exception
	catch( CMemoryException *pMemException )
	{
		hr = E_OUTOFMEMORY;
		pMemException->Delete();
	}

	// If successful, QI for an IDMUSProdTimelineDataObject to store in ppITimelineDataObject
	if( SUCCEEDED(hr) && pTimelineDataObject )
	{
		hr = pTimelineDataObject->QueryInterface( IID_IDMUSProdTimelineDataObject, (void**)ppITimelineDataObject );
		pTimelineDataObject->Release();
	}
	
	return hr;
}


//  @method HRESULT | IDMUSProdTimeline | GetPasteType | This method returns the type of Paste operation
//		to perform.
//
//  @parm   <t TIMELINE_PASTE_TYPE>* | ptlptPasteType | Address of a variable to store the
//		<t TIMELINE_PASTE_TYPE> in.
//
//  @rvalue S_OK | The operation was successful
//	@rvalue E_POINTER | <p ptlptPasteType> is NULL
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::SetPasteType>
HRESULT CTimelineCtl::GetPasteType(
		/* [out,retval] */ TIMELINE_PASTE_TYPE*	ptlptPasteType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate ptlptPasteType
	if( ptlptPasteType == NULL )
	{
		return E_POINTER;
	}

	*ptlptPasteType = m_ptPasteType;

	return S_OK;
}


//  @method HRESULT | IDMUSProdTimeline | SetPasteType | This method sets the type of Paste operation
//		to perform.
//
//  @parm   <t TIMELINE_PASTE_TYPE> | tlptPasteType | The type of <t TIMELINE_PASTE_TYPE> to set
//
//  @rvalue S_OK | The operation was successful
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::GetPasteType>
HRESULT CTimelineCtl::SetPasteType(
		/* [in] */ TIMELINE_PASTE_TYPE tlptPasteType )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_ptPasteType = tlptPasteType;

	return S_OK;
}


void CTimelineCtl::ScrollToTimeCursor( long lTime, long lLeftSide, long lRightSide )
{
	// Convert from a time to a pixel position
	long lPosition;
	ClocksToPosition( lTime, &lPosition );
	lPosition += m_lLastEarlyPosition;

	// Scroll backward in time (if the cursor is off the left edge of the display)
	if( lPosition < m_lXScrollPos )
	{
		ScrollToPosition( lPosition );
	}

	// Check to see if there is new music that we can scroll to.

	// Compute the length of the segment, in pixels
	long lMaxPos;
	ClocksToPosition( m_lLength, &lMaxPos );

	// Add the early and late amounts
	lMaxPos += m_lLastEarlyPosition + m_lLastLatePosition;

	// Check if the right edge of the display is earlier than the last visible pixel
	if( lRightSide + m_lXScrollPos < lMaxPos + m_lFunctionBarWidth )
	{
		// yes - at least one pixel exists beyond the right edge of the display

		// scroll after we've covered 9/10 of the window
		if( lPosition + CURSOR_WIDTH - m_lXScrollPos > (long)(( lRightSide - lLeftSide ) * .9) )
		{
			// Scroll so that lPosition displays 2/10 of the way from the left border
			long lScrollTo = lPosition - (long)(( lRightSide - lLeftSide ) * .2 );

			// Ensure lScrollTo is less than the maximum scroll position
			lScrollTo = min( lScrollTo, lMaxPos - (lRightSide - lLeftSide) );

			// Finally, scroll to it
			ScrollToPosition( lScrollTo );
		}
	}
}

void CTimelineCtl::SetTimeCursor( long lTime, BOOL fScroll, bool fUserSetCursor )
{
	// Check if the length is greater than 0
	if( m_lLength > 0 )
	{
		// if time is past the length, wrap around
		if( lTime > m_lLength + m_lLastLateTime )
		{
			lTime %= m_lLength + m_lLastLateTime;
		}
	}
	else
	{
		// Length is 0, so lTime must also be 0
		lTime = 0;
	}

	// If the cursor time actually changed
	if( lTime != m_lCursor )
	{
		// Compute the drawing area for the strips
		RECT rect;
		ComputeDrawingArea( &rect );

		// If the user isn't scrolling with the horizontal scroll bar, if fScroll is set,
		// and if the mouse isn't captured
		if( !m_fHScrollTracking
		&&	fScroll
		&&	!m_fStripMouseCapture )
		{
			// Scroll the display so the time cursor is visible
			ScrollToTimeCursor( lTime, rect.left, rect.right );
		}

		// Compute the old position of the cursor
		long lOldPosition;
		ClocksToPosition( m_lCursor, &lOldPosition );
		lOldPosition = lOldPosition + m_lFunctionBarWidth + m_lLastEarlyPosition - m_lXScrollPos;

		// Compute the new position of the cursor
		long lNewPosition;
		ClocksToPosition( lTime, &lNewPosition );
		lNewPosition = lNewPosition + m_lFunctionBarWidth + m_lLastEarlyPosition - m_lXScrollPos;

		// If either the new cursor position or the old cursor position is visible, redraw the cursor
		if( (lNewPosition >= m_lFunctionBarWidth)
		||	(lOldPosition >= m_lFunctionBarWidth) )
		{
			// Get our device context
			HDC hdc = GetDC();
			if( hdc )
			{
				// Create the pen to draw the time cursor with
				HPEN hpen;
				hpen = ::CreatePen( PS_SOLID, 1, COLOR_TIME_CURSOR );
				if( hpen )
				{
					// Save the currently used pen and select the time cursor pen
					HPEN hpenOld;
					hpenOld = static_cast<HPEN>(::SelectObject( hdc, hpen ));

					// Save the currently used ROP and select the time cursor ROP
					int nOldROP;
					nOldROP = ::SetROP2( hdc, R2_XORPEN );

					// If the old cursor is visible
					if ( (lOldPosition >= m_lFunctionBarWidth) && (lOldPosition <= rect.right) )
					{
						// Draw over it (this should erase it)
						::MoveToEx( hdc, lOldPosition, rect.top, NULL );
						::LineTo( hdc, lOldPosition, rect.bottom );
					}

					// If the new cursor is visible
					if ( (lNewPosition >= m_lFunctionBarWidth) && (lNewPosition <= rect.right) )
					{
						// Draw it
						::MoveToEx( hdc, lNewPosition, rect.top, NULL );
						::LineTo( hdc, lNewPosition, rect.bottom );
					}

					// Restore the old ROP and pen
					::SetROP2( hdc, nOldROP );
					::SelectObject( hdc, hpenOld );

					// Delete the time cursor pen
					::DeleteObject( hpen );
				}

				// Release the DC
				ReleaseDC( hdc );
			}
		}

		// Update the time of the cursor
		m_lCursor = lTime;

		// Check if we're displaying the real-time in the status bar
		if( m_pDMUSProdFramework && m_hKeyRealTimeStatusBar )
		{
			// Yes - update the text in the status bar panes

			// Get the REFERENCE_TIME of the cursor
			REFERENCE_TIME rtRefTime = 0;
			ClocksToRefTime( m_lCursor, &rtRefTime );

			// Convert from a number to a string
			CString strText;
			RefTimeToString( rtRefTime, IDS_OFFSET_TIME, IDS_OFFSET_NEG_TIME, strText );

			// Update the status bar text
			m_pDMUSProdFramework->SetStatusBarPaneText( m_hKeyRealTimeStatusBar, 1, strText.AllocSysString(), TRUE );

			// Now, try and get the offset from the start of the segment
			rtRefTime = 0;

			// Check if the segment is playing
			if( m_pIDMPerformance && (m_rtSegmentStart != 0)
			&&	SUCCEEDED( m_pIDMPerformance->GetTime( &rtRefTime, NULL ) ) )
			{
				// Yes - set rtRefTime to the current offset in the segment
				rtRefTime -= m_rtSegmentStart;
			}
			else if( m_rtSegmentStart == 0 )
			{
				// Display the last value of the ElapsedTime counter
				rtRefTime = m_rtLastElapsedTime;
			}

			// Convert from a number to a string
			RefTimeToString( rtRefTime, IDS_ELAPSED_TIME, IDS_ELAPSED_NEG_TIME, strText );

			// Update the status bar text
			m_pDMUSProdFramework->SetStatusBarPaneText( m_hKeyRealTimeStatusBar, 0, strText.AllocSysString(), TRUE );
		}

		// Notify the strips that the time cursor changed
		NotifyStripMgrs( fUserSetCursor ? GUID_TimelineUserSetCursor : GUID_TimelineSetCursor, 0xFFFFFFFF, &lTime );
	}
}

void CTimelineCtl::InvalidateSelectedStrips(BOOL fErase)
{
	UNREFERENCED_PARAMETER( fErase );
	StripList* pSL;
	RECT rect;
	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( pSL->m_fSelected )
		{
			GetStripClientRect( pSL, &rect );
//			InvalidateRect( &rect, fErase );
			InvalidateRect( &rect, FALSE );
		}
	}
}

//  @method HRESULT | IDMUSProdTimeline | SetMarkerTime | This method sets the location of
//		one of the markers in the time strip.
//
//  @parm   <t MARKERID> | idMarkerType | Which marker to get the location of.  Must be
//		one of <t MARKERID>.  MARKER_LEFTDISPLAY and MARKER_RIGHTDISPLAY are not supported.
//  @parm   <t TIMETYPE> | ttType | Which units to use when computing <p plTime>.  Must be
//		one of <t TIMETYPE>.
//  @parm   long | lTime | The time the marker should be set to.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_INVALIDARG | <p ttType> or <p idMarkerType> do not contain valid values, or
//		lTime is less than zero.
//
//	@xref	<i IDMUSProdTimeline>, <t TIMETYPE>, <t MARKERID>, <om IDMUSProdTimeline::GetMarkerTime>
HRESULT CTimelineCtl::SetMarkerTime( 
    /* [in] */ MARKERID idMarkerType,
	/* [in] */ TIMETYPE	ttType,
    /* [in] */ long lTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	StripList*	pSL;
	VARIANT		var;

	// If in milliseconds, convert to clocks
	if( ttType == TIMETYPE_MS )
	{
		RefTimeToClocks( lTime * 10000, &lTime );
	}

	switch( idMarkerType )
	{
	case MARKER_CURRENTTIME:		// signifies the time cursor
		if( m_pTimeStrip )
		{
			SetTimeCursor( lTime, m_pTimeStrip->m_fScrollWhenSettingTimeCursor, false );
		}
		break;

	case MARKER_BEGINSELECT:		// begin of edit selection
		if( lTime < 0 )
			return E_INVALIDARG;

		if( m_bPasting )
		{
			break;
		}
		m_lBeginSelect = lTime;
		var.vt = VT_I4;
		V_I4( &var ) = lTime;
		for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
		{
			if( pSL->m_pStrip != NULL )
			{
				/*
				if( !fSetMarkerTime_Ignore_m_pMouseStripList
				||	pSL != m_pMouseStripList )
				{
				*/
				pSL->m_pStrip->SetStripProperty( SP_BEGINSELECT, var);
				/*
				}
				*/
			}
		}
		break;

	case MARKER_ENDSELECT:		// end of edit selection
		if( lTime < 0 )
			return E_INVALIDARG;

		if( m_bPasting )
		{
			break;
		}
		m_lEndSelect = lTime; // note that end select isn't guaranteed to be > begin select
		var.vt = VT_I4;
		V_I4( &var ) = lTime;
		for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
		{
			if( pSL->m_pStrip != NULL )
			{
				/*
				if( !fSetMarkerTime_Ignore_m_pMouseStripList
				||	pSL != m_pMouseStripList )
				{
				*/
				pSL->m_pStrip->SetStripProperty( SP_ENDSELECT, var);
				/*
				}
				*/
			}
		}
		break;

	case MARKER_LEFTDISPLAY:		// scroll the display area to this time
	case MARKER_RIGHTDISPLAY:
		return E_NOTIMPL;
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | GetMarkerTime | This method gets the location of
//		one of the markers in the time strip.
//
//  @parm   <t MARKERID> | idMarkerType | Which marker to get the location of.  Must be
//		one of <t MARKERID>
//  @parm   <t TIMETYPE> | ttType | Which units to use when computing <p plTime>.  Must be
//		one of <t TIMETYPE>.
//  @parm   long* | plTime | Address of a variable to receive the location of <p idMarkerType>.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | <p plTime> is NULL.
//	@rvalue E_INVALIDARG | <p ttType> or <p idMarkerType> do not contain valid values.
//
//	@xref	<i IDMUSProdTimeline>, <t TIMETYPE>, <t MARKERID>, <om IDMUSProdTimeline::SetMarkerTime>
HRESULT CTimelineCtl::GetMarkerTime( 
    /* [in] */ MARKERID idMarkerType,
	/* [in] */ TIMETYPE	ttType,
    /* [out] */ long *plTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( plTime == NULL )
	{
		return E_POINTER;
	}

	if( ttType == TIMETYPE_MS )
	{
		// Use reference time
		REFERENCE_TIME rtTime;
		switch( idMarkerType )
		{
		case MARKER_CURRENTTIME:		// signifies the time cursor
			ClocksToRefTime( m_lCursor, &rtTime );
			*plTime = long(rtTime / 10000);
			break;

		case MARKER_BEGINSELECT:		// begin of edit selection
			ClocksToRefTime( m_lBeginSelect, &rtTime );
			*plTime = long(rtTime / 10000);
			break;

		case MARKER_ENDSELECT:			// end of edit selection
			ClocksToRefTime( m_lEndSelect, &rtTime );
			*plTime = long(rtTime / 10000);
			break;

		case MARKER_LEFTDISPLAY:		// left edge of display window
			PositionToRefTime( m_lXScrollPos - m_lLastEarlyPosition, &rtTime );
			*plTime = long(rtTime / 10000);
			break;

		case MARKER_RIGHTDISPLAY:		// right edge of display window
			{
				RECT rectDrawingArea;
				ComputeDrawingArea( &rectDrawingArea );
				PositionToRefTime( m_lXScrollPos - m_lLastEarlyPosition + rectDrawingArea.right - rectDrawingArea.left, &rtTime );
				*plTime = long(rtTime / 10000);
			}
			break;

		default:
			return E_INVALIDARG;
		}
	}
	else
	{
		// Use clocks
		switch( idMarkerType )
		{
		case MARKER_CURRENTTIME:
			*plTime = m_lCursor;		// signifies the time cursor
			break;

		case MARKER_BEGINSELECT:		// begin of edit selection
			*plTime = m_lBeginSelect;
			break;

		case MARKER_ENDSELECT:			// end of edit selection
			*plTime = m_lEndSelect;
			break;

		case MARKER_LEFTDISPLAY:		// left edge of display window
			PositionToClocks( m_lXScrollPos - m_lLastEarlyPosition, plTime );
			break;

		case MARKER_RIGHTDISPLAY:		// right edge of display window
			{
				RECT rectDrawingArea;
				ComputeDrawingArea( &rectDrawingArea );
				PositionToClocks( m_lXScrollPos - m_lLastEarlyPosition + rectDrawingArea.right - rectDrawingArea.left, plTime );
			}
			break;

		default:
			return E_INVALIDARG;
		}
	}
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | ClocksToPosition | This method converts
//		from a time in clocks to a horizontal pixel position
//
//	@comm	Negative values for <p lTime> are valid.
//
//	@comm	Due to rounding errors, converting from a time to a pixel position and back
//		will usually return a value different from the original one.
//
//  @parm   long | lTime | The time in clocks
//  @parm   long* | plPosition | Address of a variable to receive the pixel position this
//		time resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p plPosition>
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::PositionToClocks>
HRESULT CTimelineCtl::ClocksToPosition( 
    /* [in] */ long   lTime,
    /* [out] */ long *plPosition)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == plPosition )
	{
		return E_POINTER;
	}
	if (m_fMusicTime == TRUE) 
	{
		*plPosition = (long)floor( double(lTime) * m_dblZoom + 0.5 );
		return S_OK;
	}
	else
	{
		REFERENCE_TIME rTime;
		HRESULT hr = ClocksToRefTime( lTime, &rTime);
		if (SUCCEEDED(hr))
		{
			return RefTimeToPosition( rTime, plPosition);
		}
		return hr;
	}
}

//  @method HRESULT | IDMUSProdTimeline | PositionToClocks | This method converts
//		from a horizontal pixel position to a time in clocks.
//
//	@comm	Negative values for <p lPosition> are valid.
//
//	@comm	Due to rounding errors, converting from a pixel position to a time and back
//		may return a value different from the original one.
//
//  @parm   long | lPosition | The horizontal position, in pixels.
//  @parm   long* | plTime | Address of a variable to receive the time in clocks this
//		position resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p plTime>
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::ClocksToPosition>
HRESULT CTimelineCtl::PositionToClocks( 
    /* [in] */ long position,
    /* [out] */ long *plTime)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == plTime )
	{
		return E_POINTER;
	}
	if (m_fMusicTime == TRUE)
	{
		double dblPosition;
		double dblTime;
		dblPosition = position;
		dblTime = dblPosition / m_dblZoom;
		*plTime = (long)floor(dblTime + 0.5);
		return S_OK;
	}
	else
	{
		REFERENCE_TIME rTime;
		HRESULT hr = PositionToRefTime( position, &rTime);
		if (SUCCEEDED(hr))
		{
			return RefTimeToClocks( rTime, plTime);
		}
		return hr;
	}
}

void CTimelineCtl::OptimizeZoomFactor(void)
{
	// examine the clocklength of the piece. If the final position is a fraction
	// of the overall window real estate, zoom in until it fills the window

	// Compute the pixel length of the timeline
	long position;
	ClocksToPosition( m_lLength, &position );
	position += m_lLastEarlyPosition + m_lLastLatePosition;

	// Get the client timeline window (without the scrollbars)
	RECT rectClient;
	GetWindowRect(&rectClient);

	long desired = (rectClient.right - rectClient.left ) * 3 / 8;
	if( position < desired )
	{
		// Convert from a pixel length to a clock length
		PositionToClocks( position, &position );

		// Set the zoom factor
		m_dblZoom = (double)desired / double(position);
	}
}

static HRESULT GetVT_I4( VARIANT var, long* plVal )
{
	if( var.vt != VT_I4 )
		return E_FAIL;
	*plVal = V_I4(&var);
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | SetTimelineProperty | This method sets a property of
//		the Timeline.
//
//	@comm	The TP_SNAPAMOUNT property is not supported.
//
//  @parm   <t TIMELINE_PROPERTY> | tp | Which property to get.  Must be one of <t TIMELINE_PROPERTY>.
//  @parm   VARIANT | var | The data to set the property with.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_INVALIDARG | <p tp> does not contain a valid property type.
//	@rvalue E_FAIL | <p var> contained an invalid value for the specified property type.
//
//	@xref	<i IDMUSProdTimeline>, <t TIMELINE_PROPERTY>, <om IDMUSProdTimeline::GetTimelineProperty>
HRESULT CTimelineCtl::SetTimelineProperty(
		/* [in] */ TIMELINE_PROPERTY	tp,
		/* [in] */ VARIANT				var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_FAIL;
	long	lVal;

	switch(tp)
	{
	case TP_CLOCKLENGTH:
		if( SUCCEEDED( hr = GetVT_I4( var, &lVal )))
		{
			if( (lVal >= 0) && (m_lLength != lVal) )
			{
				m_lLength = lVal;
				OptimizeZoomFactor();
				ComputeScrollBars();

				// send WM_SIZE to all strips, letting them know they have changed size
				StripList* pSL = m_pStripList;
				while (pSL)
				{
					// BUGBUG: Should have meaningful values for lParam.
					CallStripWMMessage( pSL, WM_SIZE, SIZE_RESTORED, MAKELONG(0, pSL->m_lHeight) );
					pSL = pSL->m_pNext;
				}

				hr = S_OK;
			}
		}
		break;

	case TP_STRIPMOUSECAPTURE:
		if( V_BOOL(&var) == TRUE )
		{
			m_fStripMouseCapture = TRUE;
			SetCapture();
			// Make sure the active strip is getting the mouse messages
			if( m_pActiveStripList )
			{
				m_pMouseStripList = m_pActiveStripList;
				m_MouseMode = MM_UNKNOWN;
			}
			hr = S_OK;
		}
		else
		{
			m_fStripMouseCapture = FALSE;
			ReleaseCapture();
			// Change the active strip to whatever strip the mouse cursor is currently over
			BOOL fBool = FALSE;
			OnSetCursor( WM_SETCURSOR, 0, NULL, fBool );
			if ( m_pMouseStripList && (m_pMouseStripList != m_pActiveStripList) )
			{
				ActivateStripList( m_pMouseStripList );
			}
			hr = S_OK;
		}
		break;

	case TP_ACTIVESTRIP:
		{
			hr = E_INVALIDARG;
			IUnknown* punk;
			if( var.vt == VT_UNKNOWN )
			{
				punk = V_UNKNOWN(&var);
				if( punk )
				{
					IDMUSProdStrip* pIStrip;
					if( SUCCEEDED( punk->QueryInterface( IID_IDMUSProdStrip, (void**)&pIStrip ) ) )
					{
						StripList* pSL = FindStripList( pIStrip );
						if( pSL )
						{
							ActivateStripList( pSL );
							hr = S_OK;
						}
						pIStrip->Release();
					}
					punk->Release();
				}
				else
				{
					DeactivateStripList();
					hr = S_OK;
				}
			}
		}
		break;

	case TP_DMUSPRODFRAMEWORK:
		{
			IUnknown* punk;
			if( var.vt == VT_UNKNOWN )
			{
				if( m_pDMUSProdFramework )
				{
					m_pDMUSProdFramework->Release();
					m_pDMUSProdFramework = NULL;
				}
				punk = V_UNKNOWN(&var);
				if( punk )
				{
					if( SUCCEEDED( punk->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMUSProdFramework ) ) )
					{
						IDMUSProdComponent* pIComponent = NULL;
						if( SUCCEEDED ( m_pDMUSProdFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
						{
							IDMUSProdConductor *pIConductor;
							if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIConductor ) ) )
							{
								if( m_pIDMPerformance )
								{
									m_pIDMPerformance->Release();
									m_pIDMPerformance = NULL;
								}
								IUnknown* punkPerformance;
								if( SUCCEEDED( pIConductor->GetPerformanceEngine( &punkPerformance ) ) )
								{
									punkPerformance->QueryInterface( IID_IDirectMusicPerformance, (void **)&m_pIDMPerformance ) ;
									punkPerformance->Release();
								}
								pIConductor->Release();
							}
							pIComponent->Release();
						}
					}
				}
				hr = S_OK;
			}
		}
		break;

	case TP_TIMELINECALLBACK:
		{
			IUnknown* punk;
			if( var.vt == VT_UNKNOWN )
			{
				if( m_pTimelineCallback )
				{
					m_pTimelineCallback->Release();
					m_pTimelineCallback = NULL;
				}
				punk = V_UNKNOWN(&var);
				if( punk )
				{
					punk->QueryInterface( IID_IDMUSProdTimelineCallback, (void**)&m_pTimelineCallback );
				}
				hr = S_OK;
			}
		}
		break;

	case TP_ZOOM:
		if( var.vt == VT_R8 )
		{
			if ( V_R8(&var) > 0 )
			{
				m_dblZoom = V_R8(&var);
				hr = S_OK;
			}
		}
		break;

	case TP_HORIZONTAL_SCROLL:
		if( var.vt == VT_I4 )
		{
			ScrollToPosition( V_I4(&var) + m_lLastEarlyPosition );
			hr = S_OK;
		}
		break;

	case TP_VERTICAL_SCROLL:
		if( var.vt == VT_I4 )
		{
			hr = S_OK;
			if( m_lYScrollPos != V_I4(&var) )
			{
				// Get the height of all strips
				long lMaxStripScroll = TotalStripHeight();

				RECT rect;
				GetClientRect( &rect );

				RECT rectTmp;
				m_ScrollHorizontal.GetClientRect( &rectTmp );
				rect.bottom -= rectTmp.bottom;

				if( m_pStripList )
				{
					// don't scroll top strip (usually the time strip)
					rect.top += m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH*2;

					// subtract off the top strip
					lMaxStripScroll -= m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH;
				}

				// subtract the height of the viewing region
				lMaxStripScroll -= rect.bottom - rect.top;

				int nPos;
				if (lMaxStripScroll < 1)
				{
					nPos = 0;
				}
				else
				{
					nPos = (V_I4(&var) * m_ScrollVertical.GetScrollLimit()) / lMaxStripScroll;
				}

				int iTemp = 0;
				OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, nPos ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
			}
		}
		break;

	case TP_FREEZE_UNDO:
		if( var.vt == VT_BOOL )
		{
			m_fFreezeUndo = V_BOOL(&var);
			hr = S_OK;
		}
		break;

	case TP_SNAP_TO:
		if( var.vt == VT_I4 )
		{
			m_pTimeStrip->SetSnapTo( (DMUSPROD_TIMELINE_SNAP_TO) V_I4(&var) );
			hr = S_OK;
		}
		break;
	
	case TP_FUNCTIONBAR_WIDTH:
		if( var.vt == VT_I4 )
		{
			if(( V_I4(&var) >= MIN_FNBAR_WIDTH ) && ( V_I4(&var) <= MAX_FNBAR_WIDTH))
			{
				m_lFunctionBarWidth = V_I4(&var);
				hr = S_OK;

				// Probably should calculate the area that will be affected
				// and only invalidate it.
				// Perhaps we could just 'scroll' the affected area to the
				// right and invalidate the small new area to be displayed

				// send WM_SIZE to all strips, letting them know something has changed size
				StripList* pSL = m_pStripList;
				while (pSL)
				{
					// BUGBUG: Should have meaningful values for lParam.
					CallStripWMMessage( pSL, WM_SIZE, SIZE_RESTORED, MAKELONG(0, pSL->m_lHeight) );
					pSL = pSL->m_pNext;
				}

				ComputeScrollBars();
				RECT rect;
				GetClientRect( &rect );
//				InvalidateRect( &rect, TRUE );
				InvalidateRect( &rect, FALSE );
			}
		}
		break;

	case TP_TOP_STRIP:
		{
			hr = E_INVALIDARG;
			IUnknown* punk;
			if( var.vt == VT_UNKNOWN )
			{
				punk = V_UNKNOWN(&var);
				if( punk )
				{
					IDMUSProdStrip* pIStrip;
					if( SUCCEEDED( punk->QueryInterface( IID_IDMUSProdStrip, (void**)&pIStrip ) ) )
					{
						StripList* pSL = FindStripList( pIStrip );
						if( pSL )
						{
							SetTopStripList( pSL );
							hr = S_OK;
						}
						pIStrip->Release();
					}
					punk->Release();
				}
				else
				{
					DeactivateStripList();
					hr = S_OK;
				}
			}
		}
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | GetTimelineProperty | This method gets a property of
//		the Timeline.
//
//  @parm   <t TIMELINE_PROPERTY> | tp | Which property to get.  Must be one of <t TIMELINE_PROPERTY>.
//  @parm   VARIANT* | pVar | Address of the variant to return the property's data in.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | <p pVar> is NULL.
//	@rvalue E_INVALIDARG | <p tp> does not contain a valid property type.
//
//	@xref	<i DMUSProdTimeline>, <t TIMELINE_PROPERTY>, <om IDMUSProdTimeline::SetTimelineProperty>
HRESULT CTimelineCtl::GetTimelineProperty(
		/* [in] */ TIMELINE_PROPERTY	tp,
		/* [out] */ VARIANT*			pVar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	if( pVar == NULL )
	{
		return E_POINTER;
	}

	switch(tp)
	{
	case TP_CLOCKLENGTH:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_lLength;
		break;

	case TP_TIMELINECALLBACK:
		pVar->vt = VT_UNKNOWN;
		V_UNKNOWN(pVar) = m_pTimelineCallback;
		if( m_pTimelineCallback )
		{
			m_pTimelineCallback->AddRef();
		}
		else
		{
			return E_FAIL;
		}
		break;

	case TP_DMUSPRODFRAMEWORK:
		pVar->vt = VT_UNKNOWN;
		V_UNKNOWN(pVar) = m_pDMUSProdFramework;
		if( m_pDMUSProdFramework )
		{
			m_pDMUSProdFramework->AddRef();
		}
		else
		{
			return E_FAIL;
		}
		break;

	case TP_ACTIVESTRIP:
		pVar->vt = VT_UNKNOWN;
		if( m_pActiveStripList && m_pActiveStripList->m_pStrip )
		{
			V_UNKNOWN(pVar) = m_pActiveStripList->m_pStrip;
			m_pActiveStripList->m_pStrip->AddRef();
		}
		else
		{
			V_UNKNOWN(pVar) = NULL;
			return E_FAIL;
		}
		break;
	
	case TP_FUNCTIONBAR_WIDTH:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_lFunctionBarWidth;
		break;

	case TP_MAXIMUM_HEIGHT:
		{
			RECT rectWin, rectSH;
			GetClientRect( &rectWin );
			m_ScrollHorizontal.GetClientRect( &rectSH );
			pVar->vt = VT_I4;
			V_I4(pVar) = rectWin.bottom - m_pStripList->m_lHeight - rectSH.bottom - BORDER_HORIZ_WIDTH*3;
		}
		break;

	case TP_HORIZONTAL_SCROLL:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_lXScrollPos - m_lLastEarlyPosition;
		break;

	case TP_VERTICAL_SCROLL:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_lYScrollPos;
		break;

	case TP_ZOOM:
		pVar->vt = VT_R8;
		V_R8(pVar) = m_dblZoom;
		break;

	case TP_SNAPAMOUNT:
		if( m_pTimeStrip )
		{
			V_I4(pVar) = m_pTimeStrip->SnapAmount( V_I4(pVar) );
			pVar->vt = VT_I4;
		}
		else
		{
			return E_FAIL;
		}
		break;

	case TP_FREEZE_UNDO:
		pVar->vt = VT_BOOL;
		V_BOOL(pVar) = (short)m_fFreezeUndo;
		break;

	case TP_SNAP_TO:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_pTimeStrip->m_stSetting;
		break;

	case TP_FUNCTIONNAME_HEIGHT:
		pVar->vt = VT_I4;
		V_I4(pVar) = FUNCTION_NAME_HEIGHT;
		break;

		/* TODO: Implement
	case TP_TOP_STRIP:
		pVar->vt = VT_UNKNOWN;
		{
			StripList* pSL = GetTopStripList();
			if( pSL && pSL->m_pStrip )
			{
				V_UNKNOWN(pVar) = pSL->m_pStrip;
				pSL->m_pStrip->AddRef();
			}
			else
			{
				V_UNKNOWN(pVar) = NULL;
				return E_FAIL;
			}
		}
		break;
		*/

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | Refresh | This method causes a redraw of the
//		entire Timeline.
//
//	@comm	This method should be used sparingly.  If at all possible,
//		<om IDMUSProdTimeline::StripInvalidateRect> and <om IDMUSProdTimeline::NotifyStripMgrs>
//		should be used instead.
//
//  @rvalue S_OK | The operation was successful
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::StripInvalidateRect>, <om IDMUSProdTimeline::NotifyStripMgrs>
HRESULT CTimelineCtl::Refresh(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ComputeScrollBars();
//	InvalidateRect(NULL);
	InvalidateRect(NULL, FALSE);
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | ClocksToMeasureBeat | This method converts
//		from a time in clocks to a time in measures and beats
//
//	@comm	If <p lTime> is less than 0, the Time Signature at time 0 will
//			be used to compute <p plMeasure> and <p plBeat>.  <p plMeasure> will
//			contain the negative measure number, and <p plBeat> will contain
//			the beat in the measure that <p lTime> falls in.
//
//	@comm	Either <p plMeasure> or <p lBeat> may be NULL, but not both.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm   long | lTime | The time in clocks
//  @parm   long* | plMeasure | Address of a variable to recieve the measure number, with
//		measure 0 as the first measure.
//  @parm   long* | plBeat | Address of a variable to receive the beat number, with beat
//		0 as the first beat in each measure.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p plMeasure> and <p plBeat>
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::MeasureBeatToClocks>
HRESULT CTimelineCtl::ClocksToMeasureBeat( 
	/* [in] */ DWORD  dwGroupBits,
	/* [in] */ DWORD  dwIndex,
    /* [in] */ long	  lTime,
    /* [out] */ long *plMeasure,
    /* [out] */ long *plBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (NULL == plMeasure) && (NULL == plBeat) )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext;
	long lBeat = 0, lMeasure = 0;

	do
	{
		// Try and get the current time signature
		if ( FAILED( GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig ) ) )
		{
			return E_UNEXPECTED;
		}

		// If lTime is less than 0, only use the first TimeSig
		if( lTime < 0 )
		{
			lMeasure += lTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));
			lTime = -(abs(lTime) % (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ )));
			break;
		}
		// If there is no next time signature, do the math to find how many more measures to add
		else if( mtTSNext == 0 )
		{
			lMeasure += lTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));
			lTime %= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
			break;
		}
		// Otherwise it's more complicated
		else
		{
			// If the next time signature is after the time we're looking for
			if( lTime < mtTSNext )
			{
				// Add the number of complete measures between here and there
				lMeasure += lTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));

				// lTime now stores an offset from the beginning of the measure
				lTime %= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
				break;
			}
			// The next time signature is before the time we're looking for
			else
			{
				// Compute how many complete measures there are between now and the next Time signature
				long lMeasureDiff= mtTSNext / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));

				// Add them to lMeasure
				lMeasure += lMeasureDiff;

				// Change lMeasureDiff from measures to clocks
				lMeasureDiff *= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

				// Subtract from the time left (lTime) and add to the current time (mtTSCur)
				lTime -= lMeasureDiff;
				mtTSCur += lMeasureDiff;
			}
		}
	}
	// While the time left is greater than 0
	while ( lTime > 0 );

	if ( lTime < 0 )
	{
		lTime += TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
		lMeasure--;
	}

	if ( lTime != 0 && plBeat != NULL )
	{
		lBeat = lTime / NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
	}
	else
	{
		lBeat = 0;
	}

	if( plMeasure != NULL )
	{
		*plMeasure = lMeasure;
	}
	if( plBeat != NULL )
	{
		*plBeat = lBeat;
	}

	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | PositionToMeasureBeat | This method converts
//		from a horizontal pixel position to a measure and beat value.
//
//	@comm	If <p lPosition> is less than 0, the Time Signature at time 0 will
//			be used to compute <p plMeasure> and <p plBeat>.  <p plMeasure> will
//			contain the negative measure number, and <p plBeat> will contain
//			the beat in the measure that <p lTime> falls in.
//
//	@comm	Either <p plMeasure> or <p lBeat> may be NULL, but not both.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm   long | lPosition | The horizontal pixel position.
//  @parm   long* | plMeasure | Address of a variable to receive the measure number, with
//		measure 0 as the first measure.
//  @parm   long* | plBeat | Address of a variable to receive the beat number, with beat
//		0 as the first beat in each measure.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p plMeasure> and <p plBeat>
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::MeasureBeatToPosition>
HRESULT CTimelineCtl::PositionToMeasureBeat( 
	/* [in] */ DWORD  dwGroupBits,
	/* [in] */ DWORD  dwIndex,
    /* [in] */ long   position,
    /* [out] */ long *plMeasure,
    /* [out] */ long *plBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	long lTime;
	HRESULT hr;

	// Since this uses PositionToClocks, we don't care if we're in music time
	// or real time.  PositionToClocks will deal with it appropriately.
	if( SUCCEEDED( hr = PositionToClocks( position, &lTime ) ))
	{
		hr = ClocksToMeasureBeat( dwGroupBits, dwIndex, lTime, plMeasure, plBeat );
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | MeasureBeatToClocks | This method converts
//		from a measure and beat to a time in clocks.
//
//	@comm	If <p lMeasure> is less than 0, the Time Signature at time 0 will
//			be used to compute <p plTime>.  If <p lBeat> is less than 0, the
//			Time Signature in measure <p lMeasure> will be used to compute the offset
//			from the start of measure <p lMeasure>.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm	long | lMeasure | The measure number, with measure 0 as the first measure.
//  @parm	long | lBeat | The beat number, with beat 0 as the first beat in each measure.
//  @parm	long* | plTime | Address of a variable to receive the converted time in clocks.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | NULL was passed as <p plTime>.
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::ClocksToMeasureBeat>
HRESULT CTimelineCtl::MeasureBeatToClocks( 
	/* [in] */ DWORD  dwGroupBits,
	/* [in] */ DWORD  dwIndex,
    /* [in] */ long lMeasure,
    /* [in] */ long lBeat,
    /* [out] */ long *plTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == plTime )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	HRESULT hr;
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext = 1;
	do
	{
		hr = GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig );
		if ( FAILED( hr ) )
		{
			return E_UNEXPECTED;
		}

		long lMeasureClocks = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
		if( mtTSNext == 0 )
		{
			mtTSCur += lMeasureClocks * lMeasure;
			break;
		}
		else
		{
			long lTmpMeasures = mtTSNext / lMeasureClocks;
			if( lMeasure <= lTmpMeasures )
			{
				mtTSCur += lMeasureClocks * lMeasure;
				break;
			}
			else
			{
				mtTSCur += lMeasureClocks * lTmpMeasures;
				lMeasure -= lTmpMeasures;
			}
		}
	}
	while( lMeasure > 0 );

	if( lBeat >= 0 )
	{
		hr = GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, max(mtTSCur, 0), NULL, &TimeSig );
	}
	else
	{
		hr = GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, max(mtTSCur - TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ), 0), NULL, &TimeSig );
	}
	if ( FAILED( hr ) )
	{
		return E_UNEXPECTED;
	}

	mtTSCur += NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ) * lBeat;
	*plTime = mtTSCur;
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | MeasureBeatToPosition | This method converts
//		from a measure and beat to a pixel position.
//
//	@comm	If <p lMeasure> is less than 0, the Time Signature at time 0 will
//			be used to compute <p plPosition>.  If <p lBeat> is less than 0, the
//			Time Signature in measure <p lMeasure> will be used to compute the offset
//			from the start of measure <p lMeasure>.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm	long | lMeasure | The measure number, with measure 0 as the first measure.
//  @parm	long | lBeat | The beat number, with beat 0 as the first beat in each measure.
//  @parm	long* | plPosition | Address of a variable to receive the pixel position.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | NULL was passed as <p plPosition>.
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::PositionToMeasureBeat>
HRESULT CTimelineCtl::MeasureBeatToPosition( 
	/* [in] */ DWORD  dwGroupBits,
	/* [in] */ DWORD  dwIndex,
    /* [in] */ long   lMeasure,
    /* [in] */ long   lBeat,
    /* [out] */ long *pPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	long lTime;
	HRESULT hr;
	// Since this uses ClocksToPosition, we don't care if we're in music time
	// or real time.  ClocksToPosition will deal with it appropriately.
	if( SUCCEEDED( hr = MeasureBeatToClocks( dwGroupBits, dwIndex, lMeasure, lBeat, &lTime ) ))
	{
		hr = ClocksToPosition( lTime, pPosition );
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | StripInvalidateRect | This method invalidates the
//		specified rectangle in a strip, causing the area to be redrawn.
//
//	@parm	<i IDMUSProdStrip>* | pStrip | Which strip to invalidate the rectangle in.
//  @parm   RECT* | pRect | The rectangle to invalidate.  If NULL, invalidate the entire strip.
//  @parm   BOOL | fErase | If TRUE, erase the background of the rectangle first.
//
//	@comm	The parameter <p fErase> is ignore, as the background of the strip is always filled
//		before <om IDMUSProdStrip::Draw> is called.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_INVALIDARG | <p pStrip> was not added to the timeline by calling one of
//		<om IDMUSProdTimeline::AddStrip>, <om IDMUSProdTimeline::InsertStripAtDefaultPos>, or
//		<om IDMUSProdTimeline::InsertStripAtPos>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::Refresh>, <i IDMUSProdStrip>
HRESULT CTimelineCtl::StripInvalidateRect(
	/* [in] */ IDMUSProdStrip*	pStrip,
	/* [in] */ RECT*			pRect,
	/* [in] */ BOOL				fErase)
{
	UNREFERENCED_PARAMETER( fErase );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !::IsWindow(m_hWnd) )
	{
		// Our window has been destroyed - fail.
		return E_FAIL;
	}

	StripList* pSL;
	RECT	rect;

	pSL = FindStripList( pStrip );
	if( pSL )
	{
		RECT rectStripClientRect;
		GetStripClientRect( pSL, &rectStripClientRect );

		int nResult = 1;

		// if pRect is NULL, we should invalidate the entire strip.
		if( pRect == NULL )
		{
			rect = rectStripClientRect;
		}
		// otherwise, we need to convert from strip coordinates to
		// window coordinates
		else
		{
			HRESULT hr;
			rect = *pRect;
			if( FAILED(hr = StripRectToClient( pSL, &rect )) )
			{
				return hr;
			}
			nResult = ::IntersectRect( &rect, &rect, &rectStripClientRect );
		}

		// Only invalidate if the rect isn't empty
		if( (rect.left != rect.right)
		&&	(rect.top != rect.bottom) )
		{
			InvalidateRect( &rect, FALSE );
		}
	}
	else
	{
		return E_INVALIDARG;
	}
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | RemovePropertyPageObject | This method removes
//		a property page object previously set by <om IDMUSProdTimeline::SetPropertyPage>
//
//	@comm <t TP_DMUSPRODFRAMEWORK> must be set to the DirectMusic Producer framework
//		object (via a call to <om IDMUSProdTimeline::SetTimelineProperty> prior to calling
//		this method.
//
//  @parm   IUnknown* | punkPropPageObj | Reference to the <i IDMUSProdPropPageObject>
//		to remove from the current property sheet.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p punkPropPageObj>
//	@rvalue E_FAIL | <t TP_DMUSPRODFRAMEWORK> was not set previous to calling this method.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdPropPageObject>,	<om IDMUSProdTimeline::SetPropertyPage>
HRESULT CTimelineCtl::RemovePropertyPageObject(	/* [in] */ IUnknown* punkPropPageObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( punkPropPageObj == NULL )
	{
		return E_POINTER;
	}

	if ( m_pDMUSProdFramework == NULL )
	{
		return E_FAIL;
	}

	IDMUSProdPropPageObject* pPPO;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED(hr = punkPropPageObj->QueryInterface( IID_IDMUSProdPropPageObject,
		(void**)&pPPO )))
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED(hr = m_pDMUSProdFramework->QueryInterface( IID_IDMUSProdPropSheet,
			(void**)&pJPS )))
		{
			pJPS->RemovePageManagerByObject( pPPO );
			pJPS->Release();
		}
		pPPO->Release();
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | SetPropertyPage | This method changes the
//		currently displayed <i IDMUSProdPropSheet> to refer to <p punkPropPageMgr>
//		and <p punkPropPageObj>.
//
//	@comm <t TP_DMUSPRODFRAMEWORK> must be set to the DirectMusic Producer framework
//		object (via a call to <om IDMUSProdTimeline::SetTimelineProperty> prior to calling
//		this method.
//
//  @parm   IUnknown* | punkPropPageMgr | Reference to the <i IDMUSProdPropPageManager>
//		to set for the currently displayed property sheet.
//  @parm   IUnknown* | punkPropPageObj | Reference to the <i IDMUSProdPropPageObject>
//		to set for the currently displayed property sheet.
//
//	@rdesc	If the property sheet is hidden, this method returns S_FALSE and does not
//		set either <p punkPropPageMgr> or <p punkPropPageObj>.
//
//  @rvalue S_OK | The operation was successful
//	@rvalue S_FALSE | The current property sheet is hidden.
//  @rvalue E_POINTER | NULL was passed as  <p punkPropPageObj> or <p punkPropPageMgr>
//	@rvalue E_FAIL | <t TP_DMUSPRODFRAMEWORK> was not set previous to calling this method.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>,
//		<i IDMUSProdPropSheet>, <om IDMUSProdTimeline::RemovePropertyPageObject>
HRESULT CTimelineCtl::SetPropertyPage(
		/* [in] */ IUnknown* punkPropPageMgr,
		/* [in] */ IUnknown* punkPropPageObj)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !punkPropPageMgr || !punkPropPageObj )
	{
		return E_POINTER;
	}

	IDMUSProdPropPageManager* pPPM;
	IDMUSProdPropPageObject* pPPO;
	HRESULT hr = E_FAIL;

	if( m_pDMUSProdFramework )
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED(hr = m_pDMUSProdFramework->QueryInterface( IID_IDMUSProdPropSheet,
			(void**)&pJPS )))
		{
			//  If the property sheet is hidden, exit
			if( pJPS->IsShowing() != S_OK )
			{
				pJPS->Release();
				return S_FALSE;
			}
			if( SUCCEEDED(hr = punkPropPageMgr->QueryInterface( IID_IDMUSProdPropPageManager, 
				(void**)&pPPM )))
			{
				if( SUCCEEDED(hr = punkPropPageObj->QueryInterface( IID_IDMUSProdPropPageObject,
					(void**)&pPPO )))
				{
					HWND hwnd = ::GetFocus();	// save window to setfocus to afterwards if necessary
					if( SUCCEEDED(pJPS->SetPageManager( pPPM )))
					{
						pPPM->SetObject(pPPO);
// don't open property page automatically	pJPS->Show(TRUE);
					}
					HWND hwnd2 = ::GetFocus();
					if(hwnd != hwnd2)
					{
						::SetFocus(hwnd);
					}
					pPPO->Release();
				}
				pPPM->Release();
			}
			pJPS->Release();
		}
	}
	return hr;
}

StripList* CTimelineCtl::FindStripList(IDMUSProdStrip* pStrip) const
{
	StripList* pSL;

	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( pSL->m_pStrip == pStrip )
		{
			return pSL;
		}
	}
	return NULL;
}

//  @method HRESULT | IDMUSProdTimeline | StripSetTimelineProperty | This method sets a strip property
//		that is controlled by the Timeline.
//
//	@parm	<i IDMUSProdStrip>* | pIStrip | Which strip to set the property for.
//  @parm   <t STRIP_TIMELINE_PROPERTY> | stp | Which property to set.  Must be one of <t STRIP_TIMELINE_PROPERTY>.
//  @parm   VARIANT | variant | The data to set the property with.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | <p pIStrip> is NULL.
//	@rvalue E_INVALIDARG | <p stp> does not contain a valid property type, <p variant>
//		contains invalid data for the specified property type, or <p pIStrip> was not previously
//		added to the Timeline.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <t STRIP_TIMELINE_PROPERTY>,
//		<om IDMUSProdTimeline::StripGetTimelineProperty>
HRESULT CTimelineCtl::StripSetTimelineProperty( 
    /* [in] */ IDMUSProdStrip* pIStrip,
    /* [in] */ STRIP_TIMELINE_PROPERTY stp,
    /* [in] */ VARIANT variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_INVALIDARG;

	if( NULL == pIStrip )
	{
		return E_POINTER;
	}

	StripList* pSL = FindStripList(pIStrip);
	if( NULL == pSL )
	{
		return E_INVALIDARG;
	}

	switch( stp )
	{
	case STP_VERTICAL_SCROLL:
		{
				long lScrollAmount = pSL->m_lVScroll - V_I4(&variant);
				RECT rect;

				GetStripClientRect(pSL, &rect);
				if (( lScrollAmount >= rect.bottom - rect.top ) || ( -lScrollAmount >= rect.bottom - rect.top ))
				{
					pSL->m_lVScroll = V_I4(&variant);
					StripInvalidateRect( pIStrip, NULL, TRUE );
				}
				else
				{
					// Scroll strip
					pSL->m_lVScroll = V_I4(&variant);
					ScrollWindow( 0, lScrollAmount, &rect, &rect );
					if (lScrollAmount < 0) // scroll up
					{
						// bottom is invalidated automatically by ScrollWindow()
						RECT oldRect = rect;

						// invalidate region displaying the track's title
						rect.bottom = rect.top + FUNCTION_NAME_HEIGHT;
						rect.right = rect.left + m_lFunctionBarWidth;
						// Don't need to erase, since the title will overwrite it anyways
						InvalidateRect( &rect, FALSE);

						// invalidate region displaying the track's minize icon
						VARIANT var;
						if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_MINMAXABLE, &var )))
						{
							if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
							{
								if ((pSL->m_sv == SV_NORMAL) || (pSL->m_sv == SV_MINIMIZED))
								{
									rect.bottom += m_sizeMinMaxButton.cy - FUNCTION_NAME_HEIGHT;
									rect.right = oldRect.right;
									long posLength;
									ClocksToPosition( m_lLength, &posLength );
									posLength++;
									if( posLength < rect.right - m_lFunctionBarWidth)
									{
										rect.right = posLength + m_lFunctionBarWidth;
									}
									rect.left = rect.right - m_sizeMinMaxButton.cx;
									// Don't need to erase, since the button will overwrite it anyways
									InvalidateRect( &rect, FALSE);
								}
							}
						}
					}
					else // scroll down
					{
						RECT oldRect = rect;
						// top is invalidated automatically by ScrollWindow()

						// invalidate region displaying the track's title
						rect.top += lScrollAmount;
						rect.bottom = rect.top + FUNCTION_NAME_HEIGHT;
						rect.right = rect.left + m_lFunctionBarWidth;
						InvalidateRect( &rect, FALSE);

						// invalidate region displaying the track's minize icon
						VARIANT var;
						if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_MINMAXABLE, &var )))
						{
							if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
							{
								if ((pSL->m_sv == SV_NORMAL) || (pSL->m_sv == SV_MINIMIZED))
								{
									rect.bottom += m_sizeMinMaxButton.cy - FUNCTION_NAME_HEIGHT;
									rect.right = oldRect.right;
									long posLength;
									ClocksToPosition( m_lLength, &posLength );
									posLength++;
									if( posLength < rect.right - m_lFunctionBarWidth)
									{
										rect.right = posLength + m_lFunctionBarWidth;
									}
									rect.left = rect.right - m_sizeMinMaxButton.cx;
									InvalidateRect( &rect, FALSE);
								}
							}
						}
					}
				}
		}
		break;

	case STP_HEIGHT:
		if (variant.vt != VT_I4)
		{
			hr = E_INVALIDARG;
		}
		else
		{
				hr = S_OK;
				if ( pSL->m_sv == SV_NORMAL )
				{
					if( pSL->m_lHeight != V_I4(&variant) )
					{
						pSL->m_lHeight = V_I4(&variant);

						// Send WM_MOVE messages to all strips (below this one) that were moved
						if( ::IsWindow(m_hWnd) )
						{
							StripList* pTemp = pSL->m_pNext;
							while( pTemp )
							{
								pTemp->m_pStrip->OnWMMessage( WM_MOVE, 0, 0, 0, 0 );
								pTemp = pTemp->m_pNext;
							}
						}

						RECT rectWin, rect;
						GetClientRect( &rectWin );
						GetStripClientRect( pSL, &rect );
						rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
	//						InvalidateRect( &rectWin );
						InvalidateRect( &rectWin, FALSE );
						ComputeScrollBars();
						// If, as a result of the strip resize, the total height of the strips is less than the
						// height of the window, scroll back to the top.
						if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
						{
							int iTemp = 0;
							OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
						}
					}
				}
				else if ( pSL->m_sv == SV_MINIMIZED )
				{
					pSL->m_lRestoreHeight = V_I4(&variant);
				}
				else
				{
					hr = E_UNEXPECTED;
				}
		}
		break;

	case STP_STRIPVIEW:
		if (variant.vt != VT_I4)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			if( (V_I4(&variant) <= (int) SV_FUNCTIONBAR_MINIMIZED))
			{
				if ( pSL->m_sv != (STRIPVIEW) V_I4(&variant) )
				{
					if ( (STRIPVIEW) V_I4(&variant) == SV_MINIMIZED)
					{
						pSL->m_lRestoreHeight = pSL->m_lHeight;
						pSL->m_sv = SV_MINIMIZED;
						VARIANT var;
						if (SUCCEEDED (pIStrip->GetStripProperty( SP_MINIMIZE_HEIGHT, &var)))
						{
							pSL->m_lHeight = V_INT(&var);
						}
						else
						{
							pSL->m_lHeight = MIN_STRIP_HEIGHT;
						}
					}
					else if ( (STRIPVIEW) V_I4(&variant) == SV_NORMAL)
					{
						pSL->m_lHeight = pSL->m_lRestoreHeight;
						pSL->m_sv = SV_NORMAL;
					}

					// Send WM_MOVE messages to all strips (below this one) that were moved
					if( ::IsWindow(m_hWnd) )
					{
						StripList* pTemp = pSL->m_pNext;
						while( pTemp )
						{
							pTemp->m_pStrip->OnWMMessage( WM_MOVE, 0, 0, 0, 0 );
							pTemp = pTemp->m_pNext;
						}
					}
	
					RECT rectWin, rect;
					GetClientRect( &rectWin );
					GetStripClientRect( pSL, &rect );
					rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
					InvalidateRect( &rectWin, FALSE );
					ComputeScrollBars();
					// If, as a result of the strip resize, the total height of the strips is less than the
					// height of the window, scroll back to the top.
					if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
					{
						int iTemp = 0;
						OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_ScrollVertical), iTemp );
					}
				}
			}
			else
			{
				hr = E_INVALIDARG;
			}
		}
		break;

	case STP_GUTTER_SELECTED:
		if (variant.vt != VT_BOOL)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			if( (V_BOOL(&variant) != pSL->m_fSelected) )
			{
				// This code is duplicated in SetStripGutter
				// Change its selection
				pSL->m_fSelected = V_BOOL(&variant);

				// Update the gutter display
				RECT rect;
				GetStripClientRect( pSL, &rect );
				rect.left = 0;
				rect.right = rect.left + GUTTER_WIDTH;
				InvalidateRect( &rect, FALSE );

				// Notify the strip
				/*
				var.vt = VT_BOOL;
				V_BOOL(&var) = (short)m_pMouseStripList->m_fSelected;
				m_pMouseStripList->m_pStrip->SetStripProperty( SP_GUTTERSELECT, var );
				*/
				hr = S_OK;
			}
		}
		break;

	case STP_STRIP_INFO:
		if (variant.vt != VT_BYREF)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			DMUSPROD_TIMELINE_STRIP_INFO *pDMUSPROD_TIMELINE_STRIP_INFO = (DMUSPROD_TIMELINE_STRIP_INFO *)V_BYREF( &variant );
			if( NULL == pDMUSPROD_TIMELINE_STRIP_INFO )
			{
				hr = E_POINTER;
			}
			else
			{
				pSL->m_clsidType = pDMUSPROD_TIMELINE_STRIP_INFO->clsidType;
				pSL->m_dwGroupBits = pDMUSPROD_TIMELINE_STRIP_INFO->dwGroupBits;
				pSL->m_dwIndex = pDMUSPROD_TIMELINE_STRIP_INFO->dwIndex;
			}
		}
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | OnDataChanged | This method calls the registered
//		<om IDMUSProdTimelineCallback::OnDataChanged> method with <p punk> as a
//		parameter.
//
//	@comm	When used in the Segment Designer, an <i IDMUSProdStripMgr> interface must be passed
//		in <p punk>.  The Segment Designer will then call the strip manager's <om IStream::Save>
//		method to retrieve the new data.
//
//  @parm   IUnknown* | punk | The interface to pass.
//
//	@rdesc	If there is an <om IDMUSProdTimelineCallback::OnDataChanged> method registered, 
//		the return value is the value returned by <om IDMUSProdTimelineCallback::OnDataChanged>.
//		Otherwise, the return value is E_FAIL.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimelineCallback::OnDataChanged>
HRESULT CTimelineCtl::OnDataChanged( IUnknown* punk )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_FAIL;

	if( m_pTimelineCallback )
	{
		EnterCriticalSection( &m_csOnDataChanged );
		hr = m_pTimelineCallback->OnDataChanged( punk );
		LeaveCriticalSection( &m_csOnDataChanged );
	}
	else
	{
		return E_FAIL;
	}
	return hr;
}

// This method is used by the drag'n'drop code
void CTimelineCtl::GetStripAndCoordinates( POINTL ptTimeline, POINTL *ptStrip, StripList **ppSL )
{
	long xPos = ptTimeline.x;
	long yPos = ptTimeline.y;

	ASSERT(ppSL != NULL);

	// No strip should have the mouse captured
	ASSERT(m_fStripMouseCapture == FALSE);

	// We should not be in any "active" mouse mode
	ASSERT(m_MouseMode != MM_ACTIVERESIZE && m_MouseMode != MM_ACTIVEGUTTER);

	// Convert X coordinate to be an offset from the strip origin
	// add horizontal scroll and subtract the function bar and early amount
	xPos += m_lXScrollPos - m_lLastEarlyPosition - m_lFunctionBarWidth;

	// Convert the X coordinate to a clock position
	long lClockPos;
	PositionToClocks( xPos, &lClockPos );

	// If beyond the end of time, set ppSL to NULL
	if( lClockPos >= m_lLength + m_lLastLateTime )
	{
		*ppSL = NULL;
		return;
	}

	// Compute which Strip is below the cursor.
	StripList	*pSLSelected;
	StripList	*pTempSL;
	StripList	*pSL;
	long		yOrg = -m_lYScrollPos;

	// Initialize the found strip to NULL
	pSLSelected = NULL;

	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( pSL == m_pStripList )
		{
			// the top strip doesn't scroll
			yOrg += m_lYScrollPos;
		}
		else if( pSL == m_pStripList->m_pNext )
		{
			yOrg -= m_lYScrollPos;
		}
		yOrg += pSL->m_lHeight + BORDER_HORIZ_WIDTH;
		if( ( xPos < BORDER_VERT_WIDTH ) && 
			( yPos > yOrg - pSL->m_lHeight - BORDER_HORIZ_WIDTH ) && 
			( yPos < yOrg + BORDER_HORIZ_WIDTH ) )
		{
			// The mouse is in the left gutter
			// Set selected strip to NULL to indicate failure
			pSLSelected = NULL;
		}
		else if( (yPos < yOrg + BORDER_HORIZ_WIDTH) && (yPos > yOrg) )
		{
			// We are on the border between strips, choose the one we are closer to and send
			// the message there.
			if(yPos - yOrg > BORDER_HORIZ_WIDTH / 2)
			{
				// Choose the lower strip
				if(pSL->m_pNext != NULL)
				{
					pSLSelected = pSL->m_pNext;
				}
				else
				{
					pSLSelected = pSL;
				}
			}
			else
			{
				// Choose the upper strip
				pSLSelected = pSL;
			}
		}
		else if ( ( yPos > yOrg - pSL->m_lHeight - BORDER_HORIZ_WIDTH ) && 
			( yPos < yOrg + BORDER_HORIZ_WIDTH ) )
		{
			pSLSelected = pSL;
			break; // this break must be here or else the top strip might not get selected
		}
	}

	// If we didn't find a strip, set ppSL to NULL and return
	if(pSLSelected == NULL)
	{
		*ppSL = NULL;
		return;
	}

	// Convert Y coordinate to be relative to strip's origin
	// add any strip vertical scrolling, along with any borders
	yPos += pSLSelected->m_lVScroll - BORDER_HORIZ_WIDTH;

	// add vertical timeline scroll for all except top strip, which doesn't scroll
	if( pSLSelected != m_pStripList )
	{
		yPos += m_lYScrollPos;
	}

	// subtract the heights of any strips above this one
	for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
	{
		if( pTempSL == pSLSelected )
		{
			break;
		}
		yPos -= ( pTempSL->m_lHeight + BORDER_HORIZ_DRAWWIDTH );
	}

	// Set the strip position (ptStrip), in strip coordinates
	ASSERT( ptStrip != NULL );
	(*ptStrip).x = xPos;
	(*ptStrip).y = yPos;
	*ppSL = pSLSelected;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl IDropTarget implementation

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::DragEnter

HRESULT CTimelineCtl::DragEnter(
	/* [in] */ IDataObject __RPC_FAR *pDataObj,
	/* [in] */ DWORD grfKeyState,
	/* [in] */ POINTL pt,
	/* [out][in] */ DWORD __RPC_FAR *pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Save a pointer to the data object to pass to strips as the object is dragged over them
	ASSERT(m_pCurrentDataObject == NULL);
	if(pDataObj == NULL || pdwEffect == NULL)
	{
		return E_INVALIDARG;
	}
	m_pCurrentDataObject = pDataObj;
	m_pCurrentDataObject->AddRef();

	// Reset timer used to scroll timeline
	m_dwDragScrollTick = 0;

	HRESULT		hr;
	StripList	*pSLSelected;
	IDropTarget	*pIDropTarget;
	POINTL		ptStrip;
	
	{
		// BUGBUG: May cut off point coordinates here.
		ASSERT( (pt.x < SHRT_MAX) && (pt.y < SHRT_MAX) && (pt.x > SHRT_MIN) && (pt.y > SHRT_MIN));
		POINT	ptTmp;
		ptTmp.x = pt.x;
		ptTmp.y = pt.y;
		ScreenToClient( &ptTmp );
		pt.x = ptTmp.x;
		pt.y = ptTmp.y;
	}

	GetStripAndCoordinates(pt, &ptStrip, &pSLSelected);
	if(pSLSelected == NULL)
	{
		// We succeeded, but we cannot accept the object
		*pdwEffect = DROPEFFECT_NONE;
		return S_OK;
	}

	ASSERT(pSLSelected->m_pStrip != NULL);

	hr = pSLSelected->m_pStrip->QueryInterface(IID_IDropTarget, (void **) &pIDropTarget);
	if(FAILED(hr))
	{
		// We succeeded, but we cannot accept the object
		*pdwEffect = DROPEFFECT_NONE;
		return S_OK;
	}

	m_pLastDragStripList = pSLSelected;
	m_pLastDragStripList->m_pStrip->AddRef();

	// Call the strip's IDropTarget::DragEnter method
	hr = pIDropTarget->DragEnter(pDataObj, grfKeyState, ptStrip, pdwEffect);
	if(FAILED(hr))
	{
		m_pCurrentDataObject->Release();
		m_pCurrentDataObject = NULL;
		m_pLastDragStripList->m_pStrip->Release();
		m_pLastDragStripList = NULL;
	}
	pIDropTarget->Release();
	return hr;
}

 
#define DO_HSCROLL		1
#define DO_VSCROLL		2
   
////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::ScrollTimeline

void CTimelineCtl::ScrollTimeline( POINTL point )
{
	// Check to see if we need to scroll the timeline
	DWORD dwScrollTick = m_dwDragScrollTick;
	m_dwDragScrollTick = 0;

	// Determine width of scrollbars
	int nHScrollBarHeight = GetSystemMetrics( SM_CYHSCROLL );
	int nVScrollBarWidth = GetSystemMetrics( SM_CXVSCROLL );
	
	LPARAM lParam;
	int nGutterWidth = GUTTER_WIDTH;
	if( SUCCEEDED( GetParam( GUID_Segment_DisplayContextMenu, 0xFFFFFFFF, 0, 0, NULL, &lParam ) ) )
	{
		// Segments should include FBar width
		nGutterWidth += m_lFunctionBarWidth;
	}

	CRect rect;
	UINT nAction = (UINT)-1;
	short nDirection = -1;

	GetClientRect( &rect );

	int nScrollMin;
	int nScrollMax;
	int nScrollPos;

	if( point.x <= (rect.left + nGutterWidth) )
	{
		m_ScrollHorizontal.GetScrollRange( &nScrollMin, &nScrollMax );
		nScrollPos = m_ScrollHorizontal.GetScrollPos();

		if( nScrollPos > nScrollMin )
		{
			nDirection = DO_HSCROLL;
			nAction = SB_LINELEFT;
		}
	}
	else if( point.x >= (rect.right - nVScrollBarWidth) )	
	{
		m_ScrollHorizontal.GetScrollRange( &nScrollMin, &nScrollMax );
		nScrollPos = m_ScrollHorizontal.GetScrollPos();

		if( nScrollPos < nScrollMax )
		{
			nDirection = DO_HSCROLL;
			nAction = SB_LINERIGHT;
		}
	}
	else if( point.y <= (rect.top + STRIP_HEIGHT) )
	{
		m_ScrollVertical.GetScrollRange( &nScrollMin, &nScrollMax );
		nScrollPos = m_ScrollVertical.GetScrollPos();

		if( nScrollPos > nScrollMin )
		{
			nDirection = DO_VSCROLL;
			nAction = SB_LINEUP;
		}
	}
	else if( point.y >= (rect.bottom - nHScrollBarHeight) )	
	{
		m_ScrollVertical.GetScrollRange( &nScrollMin, &nScrollMax );
		nScrollPos = m_ScrollVertical.GetScrollPos();

		if( nScrollPos < nScrollMax )
		{
			nDirection = DO_VSCROLL;
			nAction = SB_LINEDOWN;
		}
	}

	if( nAction != -1 )
	{
		DWORD dwTick = GetTickCount();

		if( dwScrollTick )
		{
			if( dwTick >= dwScrollTick )
			{
				// Time to scroll
				if( nDirection == DO_VSCROLL )
				{
					SendMessage( WM_VSCROLL, nAction, (LPARAM)m_ScrollVertical.GetSafeHwnd() );
				}
				else
				{
					SendMessage( WM_HSCROLL, nAction, 0L );
				}

				if( nDirection == DO_HSCROLL )
				{
					m_dwDragScrollTick = dwTick + 90;	// wait 90 ms
				}
				else
				{
					m_dwDragScrollTick = dwTick + 90;	// wait 90 ms
				}
			}
			else
			{
				m_dwDragScrollTick = dwScrollTick;	// still waiting...
			}
		}
		else
		{
			m_dwDragScrollTick = dwTick + 350;		// wait 300 ms
		}
	}
}

   
////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::DragOver

HRESULT CTimelineCtl::DragOver(
	/* [in] */ DWORD grfKeyState,
	/* [in] */ POINTL pt,
	/* [out][in] */ DWORD __RPC_FAR *pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if(pdwEffect == NULL)
	{
		return E_INVALIDARG;
	}

	ASSERT(m_pCurrentDataObject != NULL);

	HRESULT		hr;
	StripList	*pSLSelected;
	IDropTarget	*pIDropTarget;
	POINTL		ptStrip;

	ScreenToClient( (PPOINT) &pt );

	// Scroll timeline when necessary
	ScrollTimeline( pt );

	GetStripAndCoordinates(pt, &ptStrip, &pSLSelected);

	if(m_pLastDragStripList != NULL && m_pLastDragStripList != pSLSelected)
	{
		hr = m_pLastDragStripList->m_pStrip->QueryInterface(IID_IDropTarget, (void **) &pIDropTarget);
		// m_pLastDragStripList should only be non-NULL if it is a drop target
		ASSERT(SUCCEEDED(hr));
		pIDropTarget->DragLeave();
		pIDropTarget->Release();
		m_pLastDragStripList->m_pStrip->Release();
		m_pLastDragStripList = NULL;
		if(pSLSelected != NULL)
		{
			ASSERT(pSLSelected->m_pStrip != NULL);

			hr = pSLSelected->m_pStrip->QueryInterface(IID_IDropTarget, (void **) &pIDropTarget);
			if(FAILED(hr))
			{
				goto Leave;
			}

			m_pLastDragStripList = pSLSelected;
			m_pLastDragStripList->m_pStrip->AddRef();

			// Call the strip's IDropTarget::DragEnter method
			hr = pIDropTarget->DragEnter(m_pCurrentDataObject, grfKeyState, ptStrip, pdwEffect);
			pIDropTarget->Release();
		}
		else
		{
			goto Leave;
		}
	}
	else if(pSLSelected == NULL)
	{
		goto Leave;
	}
	else if(m_pLastDragStripList == pSLSelected)
	{
		ASSERT(pSLSelected->m_pStrip != NULL);

		hr = pSLSelected->m_pStrip->QueryInterface(IID_IDropTarget, (void **) &pIDropTarget);
		if(FAILED(hr))
		{
			goto Leave;
		}

		// Call the strip's IDropTarget::DragOver method
		hr = pIDropTarget->DragOver(grfKeyState, ptStrip, pdwEffect);
		pIDropTarget->Release();
	}
	else // m_pLastDragStrip == NULL, pSLSelected != NULL
	{
		ASSERT(pSLSelected->m_pStrip != NULL);

		hr = pSLSelected->m_pStrip->QueryInterface(IID_IDropTarget, (void **) &pIDropTarget);
		if(FAILED(hr))
		{
			goto Leave;
		}

		ASSERT( m_pLastDragStripList == NULL );
		m_pLastDragStripList = pSLSelected;
		m_pLastDragStripList->m_pStrip->AddRef();

		// Call the strip's IDropTarget::DragEnter method
		hr = pIDropTarget->DragEnter(m_pCurrentDataObject, grfKeyState, ptStrip, pdwEffect);
		pIDropTarget->Release();
	}

	return hr;

Leave:
	// We succeeded, but we cannot accept the object
	*pdwEffect = DROPEFFECT_NONE;
	return S_OK;
}
    
////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::DragLeave

HRESULT CTimelineCtl::DragLeave(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_pCurrentDataObject != NULL);
	m_pCurrentDataObject->Release();
	m_pCurrentDataObject = NULL;

	if(m_pLastDragStripList != NULL)
	{
		ASSERT(m_pLastDragStripList->m_pStrip != NULL);

		HRESULT		hr;
		IDropTarget	*pIDropTarget;

		hr = m_pLastDragStripList->m_pStrip->QueryInterface(IID_IDropTarget, (void **) &pIDropTarget);
		// This strip should always have this implementation
		ASSERT(SUCCEEDED(hr));
		if(SUCCEEDED(hr))
		{
			pIDropTarget->DragLeave();
			pIDropTarget->Release();
		}
		m_pLastDragStripList->m_pStrip->Release();
		m_pLastDragStripList = NULL;
	}

	return S_OK;
}
    
////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::Drop

HRESULT CTimelineCtl::Drop(
	/* [in] */ IDataObject __RPC_FAR *pDataObj,
	/* [in] */ DWORD grfKeyState,
	/* [in] */ POINTL pt,
	/* [out][in] */ DWORD __RPC_FAR *pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if(pDataObj == NULL || pdwEffect == NULL)
	{
		return E_POINTER;
	}

	// Assert that we are dropping the object we got the DragEnter on
	ASSERT(pDataObj == m_pCurrentDataObject);

	HRESULT		hr;
	StripList	*pSLSelected;
	IDropTarget	*pIDropTarget;
	POINTL		ptStrip;

	{
		// BUGBUG: May cut off point coordinates here.
		ASSERT( (pt.x < SHRT_MAX) && (pt.y < SHRT_MAX) && (pt.x > SHRT_MIN) && (pt.y > SHRT_MIN));
		POINT	ptTmp;
		ptTmp.x = pt.x;
		ptTmp.y = pt.y;
		ScreenToClient( &ptTmp );
		pt.x = ptTmp.x;
		pt.y = ptTmp.y;
	}

	GetStripAndCoordinates(pt, &ptStrip, &pSLSelected);
	ASSERT(pSLSelected == m_pLastDragStripList);

	if(pSLSelected == NULL)
	{
		goto Leave;
	}

	ASSERT(pSLSelected->m_pStrip != NULL);

	hr = pSLSelected->m_pStrip->QueryInterface(IID_IDropTarget, (void **) &pIDropTarget);
	if(FAILED(hr))
	{
		goto Leave;
	}
	// Call the strip's IDropTarget::Drop method
	hr = pIDropTarget->Drop(pDataObj, grfKeyState, ptStrip, pdwEffect);

	m_pCurrentDataObject->Release();
	m_pCurrentDataObject = NULL;
	m_pLastDragStripList->m_pStrip->Release();
	m_pLastDragStripList = NULL;

	pIDropTarget->Release();

	if( SUCCEEDED( hr )
	&&	(*pdwEffect != DROPEFFECT_NONE) )
	{
		// If we did a drop, set the dropped on node as active
		if( m_pDMUSProdFramework
		&&	m_pTimelineCallback )
		{
			IDMUSProdNode *pIDMUSProdNode;
			if( SUCCEEDED( m_pTimelineCallback->QueryInterface( IID_IDMUSProdNode, (void**)&pIDMUSProdNode ) ) )
			{
				m_pDMUSProdFramework->SetSelectedNode( pIDMUSProdNode );
				pIDMUSProdNode->Release();
			}
		}
	}

	return hr;

Leave:
	// We succeeded, but we cannot accept the object
	*pdwEffect = DROPEFFECT_NONE;

	m_pCurrentDataObject->Release();
	m_pCurrentDataObject = NULL;

	if(m_pLastDragStripList != NULL)
	{
		m_pLastDragStripList->m_pStrip->Release();
		m_pLastDragStripList = NULL;
	}

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl IDMUSProdTimelineEdit implementation

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::Cut
HRESULT CTimelineCtl::Cut( /* out */ IDMUSProdTimelineDataObject* pIDataObject )
{
	return CutCopy( TRUE, pIDataObject );
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::Copy
HRESULT CTimelineCtl::Copy( /* out */ IDMUSProdTimelineDataObject* pIDataObject )
{
	return CutCopy( FALSE, pIDataObject );
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::Paste
HRESULT CTimelineCtl::Paste( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT					hr;
	StripList*				pSL;
	IDMUSProdTimelineEdit*	pITimelineEdit = NULL;
	long					lBeginTime = -1;
	long					lEndTime = -1;

	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		pIDataObject->Release();
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Make sure we can paste
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	m_bPasting = TRUE;	// So the strips won't change the select times thinking
						// they are the only ones pasting.

	// If no strips are gutter selected, only call the Active strip
	if( !AnyGutterSelectedStrips() )
	{
		if( m_pActiveStripList && m_pActiveStripList->m_pStrip &&
			SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit ) ) )
		{
			hr = pITimelineEdit->Paste(pITimelineDataObject);

			pITimelineEdit->Release();
		}
		else
		{
			hr = E_UNEXPECTED;
		}
	}
	else
	{
		int iNumCanPaste = 0;
		// Find the strip which will accept this.
		for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
		{
			if( pSL->m_fSelected && pSL->m_pStrip != NULL )
			{
				if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit )))
				{
					if ( pITimelineEdit->CanPaste( pITimelineDataObject ) == S_OK )
					{
						iNumCanPaste++;
					}
					pITimelineEdit->Release();
				}
			}
		}

		BOOL fOrigFreezeUndo = FALSE;
		if( iNumCanPaste > 1 )
		{
			// Freeze updates so only one Undo item is created
			VARIANT var;
			if( SUCCEEDED( GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
			{
				fOrigFreezeUndo = V_BOOL(&var);
			}

			// Freeze undo queue
			if( !fOrigFreezeUndo )
			{
				// Tell Segment to get undo text from TimeStripMgr
				m_pTimeStrip->m_nLastEdit = IDS_UNDO_PASTE_DATA;
				OnDataChanged( m_pTimeStrip->m_pTimeStripMgr );
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				SetTimelineProperty( TP_FREEZE_UNDO, var );
			}
		}

		BOOL fOneSucceeded = FALSE;

		// Find the strip which will accept this.
		// Paste TimeSigs first
		for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
		{
			if( pSL->m_fSelected && pSL->m_pStrip != NULL )
			{
				// Get the selected time so it can be restored at the end of paste.
				if( lBeginTime == -1 && lEndTime == -1 )
				{
					lBeginTime = m_lBeginSelect;
					lEndTime= m_lEndSelect;
				}
				if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit )))
				{
					if ( pITimelineEdit->CanPaste( pITimelineDataObject ) == S_OK )
					{
						if( StripSupportTimeSigs( pSL->m_pStrip ) )
						{
							if( pITimelineEdit->Paste( pITimelineDataObject ) == S_OK )
							{
								fOneSucceeded = TRUE;
							}
						}
					}
					pITimelineEdit->Release();
				}
			}
		}

		// Paste non-TimeSigs second
		for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
		{
			if( pSL->m_fSelected && pSL->m_pStrip != NULL )
			{
				// Get the selected time so it can be restored at the end of paste.
				if( lBeginTime == -1 && lEndTime == -1 )
				{
					lBeginTime = m_lBeginSelect;
					lEndTime= m_lEndSelect;
				}
				if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit )))
				{
					if ( pITimelineEdit->CanPaste( pITimelineDataObject ) == S_OK )
					{
						if( !StripSupportTimeSigs( pSL->m_pStrip ) )
						{
							if( pITimelineEdit->Paste( pITimelineDataObject ) == S_OK )
							{
								fOneSucceeded = TRUE;
							}
						}
					}
					pITimelineEdit->Release();
				}
			}
		}

		// UnLock updates
		if( (iNumCanPaste > 1) && !fOrigFreezeUndo )
		{
			// Restore undo queue
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			SetTimelineProperty( TP_FREEZE_UNDO, var );
		}

		if( fOneSucceeded ) 
		{
			hr = S_OK;
		}
		else
		{
			hr = E_UNEXPECTED;
		}
	}

	m_bPasting = FALSE;

	// Now set the correct selection time.
	if( ((lBeginTime != m_lBeginSelect) || (lEndTime != m_lEndSelect))
	&&	lBeginTime > -1 && lEndTime > -1 )
	{
		SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, lBeginTime );
		SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, lEndTime );
	}

	pITimelineDataObject->Release();

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::Insert
// Can insert iff one strip is selected. (CanInsert() checks this)
HRESULT CTimelineCtl::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	hr = CanInsert();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Now, call Insert() on the active strip
	IDMUSProdTimelineEdit *pITimelineEdit;
	if( m_pActiveStripList && m_pActiveStripList->m_pStrip &&
		SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit ) ) )
	{
		hr = pITimelineEdit->Insert();

		pITimelineEdit->Release();
		return hr;
	}

	// No active strip, or strip doesn't support IDMUSProdTimelineEdit
	return E_FAIL;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::Delete
HRESULT CTimelineCtl::Delete()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT					hr;
	IDMUSProdTimelineEdit*	pITimelineEdit = NULL;

	hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// If no strips are gutter selected, or the selection range is empty - call Delete
	// for the active strip only
	if( (m_lBeginSelect == m_lEndSelect) || !AnyGutterSelectedStrips() )
	{
		hr = E_UNEXPECTED;
		if( m_pActiveStripList && m_pActiveStripList->m_pStrip &&
			SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit ) ) )
		{
			hr = pITimelineEdit->Delete();

			pITimelineEdit->Release();
		}
		return hr;
	}

	// At least one strip is gutter selected and the selection range is non-empty
	int iNumCanDelete = 0;
	StripList* pSL;
	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( pSL->m_fSelected && (pSL->m_pStrip != NULL) )
		{
			if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
														  (void**) &pITimelineEdit )))
			{
				if( pITimelineEdit->CanDelete() == S_OK )
				{
					iNumCanDelete++;
				}
				pITimelineEdit->Release();
			}
		}
	}

	BOOL fOrigFreezeUndo = FALSE;
	if( iNumCanDelete > 1 )
	{
		// Freeze updates so only one Undo item is created
		VARIANT var;
		if( SUCCEEDED( GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
		{
			fOrigFreezeUndo = V_BOOL(&var);
		}

		// Freeze undo queue
		if( !fOrigFreezeUndo )
		{
			// Tell Segment to get undo text from TimeStripMgr
			m_pTimeStrip->m_nLastEdit = IDS_UNDO_DELETE_DATA;
			OnDataChanged( m_pTimeStrip->m_pTimeStripMgr );
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			SetTimelineProperty( TP_FREEZE_UNDO, var );
		}
	}

	// Delete all non-TimeSig supporting strips
	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( pSL->m_fSelected && (pSL->m_pStrip != NULL) )
		{
			if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
														  (void**) &pITimelineEdit )))
			{
				if( pITimelineEdit->CanDelete() == S_OK )
				{
					if( !StripSupportTimeSigs( pSL->m_pStrip ) )
					{
						hr = pITimelineEdit->Delete();
						// Assert that a strip successfully deleted after it told us it could
						ASSERT( SUCCEEDED(hr) );
					}
				}
				pITimelineEdit->Release();
			}
		}
	}

	// Delete all Time-Sig supporting strips
	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( pSL->m_fSelected && (pSL->m_pStrip != NULL) )
		{
			if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
														  (void**) &pITimelineEdit )))
			{
				if( pITimelineEdit->CanDelete() == S_OK )
				{
					if( StripSupportTimeSigs( pSL->m_pStrip ) )
					{
						hr = pITimelineEdit->Delete();
						// Assert that a strip successfully deleted after it told us it could
						ASSERT( SUCCEEDED(hr) );
					}
				}
				pITimelineEdit->Release();
			}
		}
	}

	// UnLock updates
	if( (iNumCanDelete > 1) && !fOrigFreezeUndo )
	{
		// Restore undo queue
		VARIANT var;
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		SetTimelineProperty( TP_FREEZE_UNDO, var );
	}

	// TODO: Add code to return E_UNEXPECTED if no strip succeeds on the Delete() call.
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::SelectAll
HRESULT CTimelineCtl::SelectAll()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( AnyGutterSelectedStrips() )
	{
		SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
		SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, m_lLength );

		return S_OK;
	}
	else if( m_pActiveStripList && m_pActiveStripList->m_pStrip )
	{
		// None selected, call SelectAll for the active strip
		IDMUSProdTimelineEdit* pITimelineEdit;
		if( SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void **)&pITimelineEdit ) ) )
		{
			HRESULT hr = pITimelineEdit->CanSelectAll();
			ASSERT( hr == S_OK );
			if( hr == S_OK )
			{
				hr = pITimelineEdit->SelectAll();
			}
			pITimelineEdit->Release();

			return hr;
		}
	}

	return E_UNEXPECTED;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::CanCut
HRESULT CTimelineCtl::CanCut( void )
{
	return CanEdit( IDC_TIMELINE_CUT );
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::CanCopy
HRESULT CTimelineCtl::CanCopy( void )
{
	return CanEdit( IDC_TIMELINE_COPY );
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::CanPaste
HRESULT CTimelineCtl::CanPaste( /* in */ IDMUSProdTimelineDataObject* pIDataObject )
{
	UNREFERENCED_PARAMETER( pIDataObject );
	return CanEdit( IDC_TIMELINE_PASTE );;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::CanSelectAll
HRESULT CTimelineCtl::CanSelectAll()
{
	return CanEdit( IDC_TIMELINE_SELECTALL );;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::CanInsert
HRESULT CTimelineCtl::CanInsert()
{
	HRESULT			hr;

	hr = CanEdit( IDC_TIMELINE_INSERT );
	if( hr == S_OK )
	{
		return S_OK;
	}
	return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CTimelineCtl::CanDelete
HRESULT CTimelineCtl::CanDelete()
{
	return CanEdit( IDC_TIMELINE_DELETE );
}

HRESULT CTimelineCtl::CutCopy( BOOL bCut , IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT					hr;
	IDMUSProdTimelineEdit*	pITimelineEdit;
	BOOL					fSetClipboard = FALSE;

	// Ensure we can Cut or Copy
	hr = CanEdit( bCut ? IDC_TIMELINE_CUT : IDC_TIMELINE_COPY );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// If no strips are gutter selected, or if the selection is NULL, only Cut/Copy in the active strip
	if( !AnyGutterSelectedStrips() || (m_lBeginSelect == m_lEndSelect) )
	{
		if( m_pActiveStripList && m_pActiveStripList->m_pStrip &&
			SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit ) ) )
		{
			if( bCut )
			{
				hr = pITimelineEdit->Cut( pITimelineDataObject );
			}
			else
			{
				hr = pITimelineEdit->Copy( pITimelineDataObject );
			}
			pITimelineEdit->Release();
		}
	}
	// Otherwise, pass the ITimelineDataObject to all selected strips.
	else
	{
		// If pITimelineDataObject is NULL, set the clipboard before returning
		fSetClipboard = (pITimelineDataObject == NULL) ? TRUE : FALSE;

		if( pITimelineDataObject )
		{
			pITimelineDataObject->AddRef();
		}
		else
		{
			hr = AllocTimelineDataObject( &pITimelineDataObject );
			ASSERT( SUCCEEDED( hr ) );
			if( FAILED( hr ) )
			{
				return E_UNEXPECTED;
			}
		}

		BOOL fOneSucceeded = FALSE;

		// Set the selection boundaries
		pITimelineDataObject->SetBoundaries( m_lBeginSelect, m_lEndSelect );

		int iNumCanCut = 0;
		StripList* pSL;
		if( bCut )
		{
			// Iterate through all selected strips
			for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
			{
				if( (pSL->m_pStrip != NULL) && pSL->m_fSelected )
				{
					if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
																  (void**) &pITimelineEdit)))
					{
						if( pITimelineEdit->CanCut() == S_OK )
						{
							iNumCanCut++;
						}
						pITimelineEdit->Release();
					}
				}
			}
		}

		BOOL fOrigFreezeUndo = FALSE;
		if( iNumCanCut > 1 )
		{
			// Freeze updates so only one Undo item is created
			VARIANT var;
			if( SUCCEEDED( GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
			{
				fOrigFreezeUndo = V_BOOL(&var);
			}

			// Freeze undo queue
			if( !fOrigFreezeUndo )
			{
				// Tell Segment to get undo text from TimeStripMgr
				m_pTimeStrip->m_nLastEdit = IDS_UNDO_CUT_DATA;
				OnDataChanged( m_pTimeStrip->m_pTimeStripMgr );
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				SetTimelineProperty( TP_FREEZE_UNDO, var );
			}
		}

		if( bCut )
		{
			// Cut
			// Iterate through all selected strips
			// Cut Non-TimeSigs first
			for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
			{
				if( (pSL->m_pStrip != NULL) && pSL->m_fSelected )
				{
					if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
																  (void**) &pITimelineEdit)))
					{
						if( pITimelineEdit->CanCut() == S_OK )
						{
							if( !StripSupportTimeSigs( pSL->m_pStrip ) )
							{
								if( pITimelineEdit->Cut( pITimelineDataObject ) == S_OK )
								{
									fOneSucceeded = TRUE;
								}
							}
						}
						pITimelineEdit->Release();
					}
				}
			}

			// Cut TimeSigs last
			for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
			{
				if( (pSL->m_pStrip != NULL) && pSL->m_fSelected )
				{
					if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
																  (void**) &pITimelineEdit)))
					{
						if( pITimelineEdit->CanCut() == S_OK )
						{
							if( StripSupportTimeSigs( pSL->m_pStrip ) )
							{
								if( pITimelineEdit->Cut( pITimelineDataObject ) == S_OK )
								{
									fOneSucceeded = TRUE;
								}
							}
						}
						pITimelineEdit->Release();
					}
				}
			}
		}
		else
		{
			// Copy
			// Iterate through all selected strips
			for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
			{
				if( (pSL->m_pStrip != NULL) && pSL->m_fSelected )
				{
					if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
																  (void**) &pITimelineEdit)))
					{
						if( pITimelineEdit->CanCopy() == S_OK )
						{
							if( pITimelineEdit->Copy( pITimelineDataObject ) == S_OK )
							{
								fOneSucceeded = TRUE;
							}
						}
						pITimelineEdit->Release();
					}
				}
			}
		}

		// UnLock updates
		if( (iNumCanCut > 1) && !fOrigFreezeUndo )
		{
			// Restore undo queue
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			SetTimelineProperty( TP_FREEZE_UNDO, var );
		}

		// If at least one returned S_OK, then we suceeded.. Otherwise we failed.
		if( fOneSucceeded )
		{
			hr = S_OK;
		}
		else
		{
			hr = E_FAIL;
		}
	}

	if( SUCCEEDED( hr ) && fSetClipboard )
	{
		// Get the IDataObject
		IDataObject* pIDataObject = NULL;
		pITimelineDataObject->Export( &pIDataObject );

		// Send the IDataObject to the Clipboard
		ASSERT( pIDataObject != NULL );
		if( pIDataObject != NULL )
		{
			// Set m_pCopyDataObject so we can flush the clipboard if we're left on it
			// when the timeline goes away.
			if( m_pCopyDataObject )
			{
				m_pCopyDataObject->Release();
			}
			m_pCopyDataObject = pIDataObject;
			m_pCopyDataObject->AddRef();

			// Put the IDataObject on the clipboard.
			hr = OleSetClipboard( pIDataObject );
			pIDataObject->Release();
		}
	}

	if( pITimelineDataObject )
	{
		pITimelineDataObject->Release();
	}

	return hr;
}

HRESULT CTimelineCtl::CanEdit( long lCommand )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT					hr;
	IDMUSProdTimelineEdit*	pITimelineEdit;

	// Take care of Insert - can only insert into the active strip
	if( lCommand == IDC_TIMELINE_INSERT )
	{
		if( m_pActiveStripList && m_pActiveStripList->m_pStrip &&
			SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit ) ) )
		{
			hr = pITimelineEdit->CanInsert();

			pITimelineEdit->Release();
			return hr;
		}
		return S_FALSE;
	}

	// Take care of case of no gutter selection - only check active strip
	if( !AnyGutterSelectedStrips() )
	{
		if( m_pActiveStripList && m_pActiveStripList->m_pStrip &&
			SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit ) ) )
		{
			hr = CanStripEdit( pITimelineEdit, lCommand );

			pITimelineEdit->Release();
			return hr;
		}
		return S_FALSE;
	}

	// For Cut/Copy/Delete, if the selection size is 0 - only check active strip
	if( (lCommand == IDC_TIMELINE_CUT) || (lCommand == IDC_TIMELINE_COPY) ||
		(lCommand == IDC_TIMELINE_DELETE) )
	{
		if( m_lBeginSelect == m_lEndSelect )
		{
			if( m_pActiveStripList && m_pActiveStripList->m_pStrip &&
				SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**) &pITimelineEdit ) ) )
			{
				hr = CanStripEdit( pITimelineEdit, lCommand );

				pITimelineEdit->Release();
				return hr;
			}
			return S_FALSE;
		}
	}

	// Go through the strip list and find out if at least one can do the specified edit operation.
	// End when pSL is null or when a CanStripEdit returns S_OK
	StripList* pSL;
	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		// Only look at the selected strips.
		if( (pSL->m_pStrip != NULL) && pSL->m_fSelected )
		{
			if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
														  (void**) &pITimelineEdit)))
			{
				hr = CanStripEdit( pITimelineEdit, lCommand );
				pITimelineEdit->Release();

				if( hr == S_OK )
				{
					return S_OK;
				}
			}
		}
	}

	// None return S_OK - return S_FALSE
	return S_FALSE;
}

// insert pMenu2 before nPos in pMenu1
void InsertMenuInMenu( CMenu* pMenu1, UINT nPos, CMenu* pMenu2)
{
	if (!pMenu2) return;
	if (!pMenu1) {
		pMenu1 = new CMenu();
		pMenu1->Attach(pMenu2->GetSafeHmenu());
	}
	else {
		if (nPos > pMenu1->GetMenuItemCount())
			nPos = pMenu1->GetMenuItemCount();
		for (int i=pMenu2->GetMenuItemCount()-1; i>=0; i--) {
			int state, ID;
			state=pMenu2->GetMenuState(i, MF_BYPOSITION);
			ID=pMenu2->GetMenuItemID(i);
			if (state && MF_SEPARATOR) {
				// separator
				pMenu1->InsertMenu(nPos, MF_BYPOSITION|MF_SEPARATOR);
			}
			else if (ID==-1) {
				// pop-up menu
				HMENU hSubMenu = pMenu2->GetSubMenu(i)->GetSafeHmenu();
				pMenu1->InsertMenu(nPos, MF_BYPOSITION|MF_POPUP, (UINT) hSubMenu);
			}
			else {
				// just a regular menu item;
				CString Name;
				pMenu2->GetMenuString( i, Name, MF_BYPOSITION );
				pMenu1->InsertMenu(nPos, MF_BYPOSITION|state|MF_STRING, ID, Name);
			}
		}
	}
}

//  @method HRESULT | IDMUSProdTimeline | TrackPopupMenu | This method displays a
//		context menu at the specified position.
//
//  @parm   HMENU | hMenu | The handle of the menu to add to the default menu.  If NULL, don't add
//		any custom items.
//  @parm   long | lXPos | The horizontal coordinate to display the menu at, in screen coordinates.
//  @parm   long | lYPos | The vertical coordinate to display the menu at, in screen coordinates.
//	@parm	<i DMUSProdStrip>* | pIStrip | Which strip to display the popup menu for.  If NULL, display the default
//		edit menu and send the results to the Timeline.
//  @parm   BOOL | fEditMenu | If TRUE, display the default edit menu.
//
//	@comm	If a custom menu is specified in <p hMenu> and <p fEditMenu> is TRUE, the items in <p hMenu>
//		will be added immediately before the "Properties" item in the edit menu.
//
//	@comm	If a valid <p pIStrip> is given, a WM_COMMAND message will be sent to <om IDMUSProdStrip::OnWMMessage>
//		if the user chooses a menu item.  No message is sent if the user cancels the context menu.
//
//	@comm	If <p hMenu> is non-NULL, <p pIStrip> should also be non-NULL to ensure the custom menu items
//		are properly handled.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_INVALIDARG | <p hMenu> is NULL and fEditMenu is FALSE.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>
HRESULT CTimelineCtl::TrackPopupMenu(HMENU hMenu, long x, long y, IDMUSProdStrip *pIStrip, BOOL fEditMenu)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HMENU hMenuPopup;
	CMenu MenuStrip, MenuEdit;
	IDMUSProdTimelineEdit * pITimelineEdit;
	HRESULT hr = S_OK;
	BOOL fNeedToDestroy = FALSE;

	if (fEditMenu == TRUE)
	{
		// Get default Edit menu items
		hr = MenuEdit.LoadMenu(IDR_EDIT_RMENU);
		ASSERT(SUCCEEDED( hr ));
		fNeedToDestroy = TRUE;
		hMenuPopup = ::GetSubMenu( MenuEdit.Detach(), 0 );
		hr = MenuEdit.Attach(hMenuPopup);
		ASSERT(SUCCEEDED( hr ));

		// default state of Edit items is greyed out.
		// Query to see if the strip supports any of them
		if( pIStrip && SUCCEEDED( pIStrip->QueryInterface( 
			IID_IDMUSProdTimelineEdit, (void**)&pITimelineEdit )))
		{
			EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( pITimelineEdit->CanCut() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( pITimelineEdit->CanCopy() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			EnableMenuItem( hMenuPopup, 2, ( pITimelineEdit->CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
					MF_GRAYED | MF_BYPOSITION );
			EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( pITimelineEdit->CanInsert() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( pITimelineEdit->CanDelete() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( pITimelineEdit->CanSelectAll() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			pITimelineEdit->Release();
		}
		else
		{
			EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED : MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED : MF_GRAYED );
			EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION : MF_GRAYED | MF_BYPOSITION );
			EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED : MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED : MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ? MF_ENABLED : MF_GRAYED );
		}
		
		EnableMenuItem( hMenuPopup, ID_EDIT_DELETE_TRACK, ShouldEnableDeleteTrack() ? MF_ENABLED : MF_GRAYED );

		long lFourQuarterNoteLength;
		ClocksToPosition( DMUS_PPQ * 4, &lFourQuarterNoteLength );

		EnableMenuItem( hMenuPopup, ID_EDIT_HORIZZOOMIN, ( lFourQuarterNoteLength < MAX_MEASURE_PIXELS ) ? MF_ENABLED : MF_GRAYED );
		EnableMenuItem( hMenuPopup, ID_EDIT_HORIZZOOMOUT, ( lFourQuarterNoteLength > MIN_MEASURE_PIXELS ) ? MF_ENABLED : MF_GRAYED );

		// If there is one, insert the strip's own menu immediately
		// before Properties in the Edit menu.
		if (hMenu) {
			hr = MenuStrip.Attach(hMenu);
			ASSERT( SUCCEEDED( hr ));
			InsertMenuInMenu( &MenuEdit, 8, &MenuStrip);
			MenuStrip.Detach();
		}
	}
	else // bEditMenu == FALSE
	{
		if ( hMenu )
		{
			// Only use the given menu items
			hr=MenuEdit.Attach(hMenu);
			ASSERT(SUCCEEDED( hr ));
			m_MenuHandler.m_fCustomMenu = TRUE;
		}
		else
		{
			return E_INVALIDARG;
		}
	}

	m_MenuHandler.m_pStrip = pIStrip;

	hr = MenuEdit.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, x, y, &m_MenuHandler);
	ASSERT( SUCCEEDED( hr ));

	if( fNeedToDestroy )
	{
		MenuEdit.DestroyMenu();
	}
	MenuEdit.Detach();

	m_MenuHandler.m_fCustomMenu = FALSE;

	return S_OK;
}

CWndClassInfo& CTimelineCtl::GetWndClassInfo()
{
	static CWndClassInfo wc =
	{
		{ sizeof(WNDCLASSEX), CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, StartWindowProc,
		  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, NULL, 0 },
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
	};
	return wc;
}

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CTimelineCtl::GetData( /* [retval][out] */ void **ppData)
{
	UNREFERENCED_PARAMETER( ppData );
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTimelineCtl::SetData( /* [in] */ void *pData)
{
	UNREFERENCED_PARAMETER( pData );
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTimelineCtl::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;
	if (m_pActiveStripList)
	{
		if (m_pActiveStripList->m_pStrip)
		{
			IDMUSProdPropPageObject* pPropPageObject;
			if ( SUCCEEDED( m_pActiveStripList->m_pStrip->QueryInterface( IID_IDMUSProdPropPageObject, (void**)&pPropPageObject ) ) )
			{
				hr = pPropPageObject->OnShowProperties();
				pPropPageObject->Release();
			}
		}
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CTimelineCtl::OnRemoveFromPageManager( void)
{
	return E_NOTIMPL;
}

// Get a list of tempos before the given time
void CTimelineCtl::GetTempoList( CList<DMUS_TEMPO_PARAM,DMUS_TEMPO_PARAM&> &lstTempos, long lTime )
{
	DWORD dwIndex = 0;
	while( TRUE )
	{
		IDMUSProdStripMgr *pTempoStripMgr = NULL;
		if( SUCCEEDED( GetStripMgr( GUID_TempoParam, 0xFFFFFFFF, dwIndex, &pTempoStripMgr ) ) )
		{
			if( S_OK != pTempoStripMgr->IsParamSupported( GUID_TimeSignature ) )
			{
				POSITION posToInsert = lstTempos.GetHeadPosition();
				MUSIC_TIME mtCur = 0, mtNextTempo = LONG_MIN;
				DMUS_TEMPO_PARAM tempo;
				while( SUCCEEDED( pTempoStripMgr->GetParam( GUID_TempoParam, mtCur, &mtNextTempo, &tempo ) ) )
				{
					// Look for an element to insert before
					if( posToInsert )
					{
						DMUS_TEMPO_PARAM tmpTempo;
						while( posToInsert )
						{
							POSITION posLast = posToInsert;
							tmpTempo = lstTempos.GetNext(posToInsert);

							if( tmpTempo.mtTime > tempo.mtTime )
							{
								posToInsert = posLast;
								lstTempos.InsertBefore( posToInsert, tempo );
								break;
							}
						}

					}

					// If we didn't find an element to insert before, insert at the end of the list
					if( posToInsert == NULL )
					{
						lstTempos.AddTail( tempo );
					}

					if( mtNextTempo == 0 )
					{
						break;
					}

					mtCur += mtNextTempo;

					if( mtCur > lTime )
					{
						break;
					}
				}
			}

			pTempoStripMgr->Release();
		}
		else
		{
			// No more strips to check - exit
			break;
		}
		dwIndex++;
	}

}

inline REFERENCE_TIME ClockToRef( REFERENCE_TIME mtTime, long double dblTempo )
{
	long double ldDivisor = dblTempo * long double(DMUS_PPQ);
	long double ldDivisorDiv2;
	if( mtTime < 0 )
	{
		ldDivisorDiv2 = -ldDivisor / 2.0;
	}
	else
	{
		ldDivisorDiv2 = ldDivisor / 2.0;
	}
	return REFERENCE_TIME((long double(mtTime * REFCLOCKS_PER_MINUTE) + ldDivisorDiv2) / ldDivisor);
}

//  @method HRESULT | IDMUSProdTimeline | ClocksToRefTime | This method converts
//		from a time in clocks to a time in REFERENCE_TIME units
//
//	@comm	Negative values for <p lTime> are valid.  The tempo at time 0 will be used
//		to compute the value to return in <p pRefTime>.
//
//  @parm   long | lTime | The time in clocks
//  @parm   REFERENCE_TIME* | pRefTime | Address of a variable to receive the time in
//		REFERENCE_TIME units this time resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p pRefTime>
//	@rvalue E_UNEXPECTED | The tempo is zero at some point.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::RefTimeToClocks>
HRESULT CTimelineCtl::ClocksToRefTime(
		/* [in] */  long		lTime,
		/* [out] */ REFERENCE_TIME		*pRefTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	if (NULL == pRefTime)
	{
		return E_POINTER;
	}

	if (NULL != m_pTempoMapMgr)
	{
		return m_pTempoMapMgr->ClocksToRefTime( lTime, pRefTime);
	}

	CList<DMUS_TEMPO_PARAM,DMUS_TEMPO_PARAM&> lstTempos;
	GetTempoList( lstTempos, lTime );

	REFERENCE_TIME rtTime = 0;
	DMUS_TEMPO_PARAM tempo;
	POSITION pos = lstTempos.GetHeadPosition();
	while( pos )
	{
		tempo = lstTempos.GetNext( pos );

		ASSERT(tempo.dblTempo > 0.0);
		if( tempo.dblTempo <= 0.0 )
		{
			return E_UNEXPECTED;
		}

		MUSIC_TIME mtNext = 0;
		if( pos )
		{
			mtNext = lstTempos.GetAt( pos ).mtTime - tempo.mtTime;
		}

		REFERENCE_TIME rtRes;
		if( !mtNext || mtNext + tempo.mtTime > lTime )
		{
			rtRes = ClockToRef( lTime - tempo.mtTime, tempo.dblTempo );
		}
		else
		{
			rtRes = ClockToRef( mtNext, tempo.dblTempo );
		}
		rtTime += rtRes;
	}

	// If there are no tempos
	if( lstTempos.GetCount() == 0 )
	{
		// Get the tempo from the time strip
		if( SUCCEEDED( m_pTimeStrip->m_pTimeStripMgr->GetParam( GUID_TempoParam, 0, NULL, &tempo ) ) )
		{
			rtTime = ClockToRef( lTime, tempo.dblTempo );
		}
	}

	*pRefTime = rtTime;
	return S_OK;
}

inline MUSIC_TIME RefToClock( REFERENCE_TIME rtTime, long double dblTempo )
{
	REFERENCE_TIME rtRoundingFactor;
	if( rtTime < 0 )
	{
		rtRoundingFactor = -REFCLOCKS_PER_MINUTE / 2;
	}
	else
	{
		rtRoundingFactor = REFCLOCKS_PER_MINUTE / 2;
	}
	REFERENCE_TIME rtResult = (REFERENCE_TIME(long double(rtTime) * dblTempo * long double(DMUS_PPQ)) + rtRoundingFactor) / REFCLOCKS_PER_MINUTE;
	return MUSIC_TIME( max( min( rtResult, LONG_MAX ), LONG_MIN ) );
}

//  @method HRESULT | IDMUSProdTimeline | RefTimeToClocks | This method converts
//		from a time in REFERENCE_TIME units to a time in clocks.
//
//	@comm	Negative values for <p RefTime> are valid, in which case the tempo at time 0 will
//		be used to compute the value of <p plTime>.
//
//  @parm   REFERENCE_TIME | RefTime | The time in REFERENCE_TIME units.
//  @parm   long* | plTime | Address of a variable to receive the time in clocks.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p plTime>
//	@rvalue E_UNEXPECTED | The tempo is zero at some point.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::ClocksToRefTime>
HRESULT CTimelineCtl::RefTimeToClocks(
		/* [in] */  REFERENCE_TIME		RefTime,
		/* [out] */ long		*plTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (NULL == plTime)
	{
		return E_POINTER;
	}

	if (NULL != m_pTempoMapMgr)
	{
		return m_pTempoMapMgr->RefTimeToClocks( RefTime, plTime );
	}

	MUSIC_TIME mtNext, mtCur = 0;
	do
	{
		mtNext = 0;

		BOOL fHaveTempoTrack = FALSE;
		double dblTempo = 120.0;
		MUSIC_TIME mtLatestTempoTime = LONG_MIN;
		DWORD dwIndex = 0;
		while( TRUE )
		{
			IDMUSProdStripMgr *pTempoStripMgr = NULL;
			if( SUCCEEDED( GetStripMgr( GUID_TempoParam, 0xFFFFFFFF, dwIndex, &pTempoStripMgr ) ) )
			{
				if( S_OK != pTempoStripMgr->IsParamSupported( GUID_TimeSignature ) )
				{
					DMUS_TEMPO_PARAM tempo;
					MUSIC_TIME mtNextTemp;
					HRESULT hr = pTempoStripMgr->GetParam( GUID_TempoParam, mtCur, &mtNextTemp, &tempo );

					if( SUCCEEDED( hr ) )
					{
						fHaveTempoTrack = TRUE;
						// If we found a real tempo and it's later than all other tempos,
						// save it to use for this time span
						if( (hr == S_OK) && (tempo.mtTime > mtLatestTempoTime) )
						{
							dblTempo = tempo.dblTempo;
							mtLatestTempoTime = tempo.mtTime;
						}
						else if( mtLatestTempoTime == LONG_MIN )
						{
							dblTempo = tempo.dblTempo;
						}

						// Look for the earliest next tempo (mtNextTempo==0 means no more tempo changes)
						if( mtNextTemp && (!mtNext || (mtNextTemp < mtNext)) )
						{
							mtNext = mtNextTemp;
						}
					}
				}

				pTempoStripMgr->Release();
			}
			else
			{
				// No more strips to check - exit
				break;
			}
			dwIndex++;
		}

		if( !fHaveTempoTrack )
		{
			DMUS_TEMPO_PARAM tempo;
			if( SUCCEEDED( m_pTimeStrip->m_pTimeStripMgr->GetParam( GUID_TempoParam, mtCur, &mtNext, &tempo ) ) )
			{
				dblTempo = tempo.dblTempo;
			}
		}

		ASSERT(dblTempo > 0.0);
		if( dblTempo <= 0.0 )
		{
			return E_UNEXPECTED;
		}

		// Convert mtNext to rtRes
		REFERENCE_TIME rtRes = ClockToRef( mtNext, dblTempo );
		if( !mtNext || RefTime <= rtRes )
		{
			// Convert RefTime to a musictime value and stuff it in plTime
			*plTime = mtCur + RefToClock( RefTime, dblTempo );
		}
		else
		{
			mtCur += mtNext;
		}
		RefTime -= rtRes;
	}
	while( mtNext && RefTime > 0 );
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | PositionToRefTime | This method converts
//		from a horizontal pixel position to a time in REFERENCE_TIME units.
//
//	@comm	Negative values for <p lPosition> are valid, in which case the tempo at time 0 will be used
//		to compute the value to return in <p pRefTime>.
//
//  @parm   long | lPosition | The horizontal pixel position.
//  @parm   REFERENCE_TIME* | pRefTime | Address of a variable to receive the time
//		in REFERENCE_TIME units this position resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p pRefTime>
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::RefTimeToClocks>
HRESULT CTimelineCtl::PositionToRefTime(
		/* [in] */  long		position,
		/* [out] */ REFERENCE_TIME		*pRefTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (NULL == pRefTime)
	{
		return E_POINTER;
	}

	if (m_fMusicTime == TRUE)
	{
		long lClocks;
		HRESULT hr;
		if (SUCCEEDED(hr = PositionToClocks( position, &lClocks)))
		{
			if (NULL != m_pTempoMapMgr)
			{
				hr = m_pTempoMapMgr->ClocksToRefTime( lClocks, pRefTime);
			}
			else
			{
				hr = ClocksToRefTime( lClocks, pRefTime);
			}
		}
		return hr;
	}
	else
	{
		DMUS_TEMPO_PARAM dmTempo;
		if( FAILED( GetParam( GUID_TempoParam, 0xffffffff, 0, 0, NULL, &dmTempo ) ) )
		{
			return E_FAIL;
		}
		double dblTmp = position;
		dblTmp /= m_dblZoom * (double)DMUS_PPQ * dmTempo.dblTempo / (double)REFCLOCKS_PER_MINUTE;
		*pRefTime = (REFERENCE_TIME) dblTmp;
		return S_OK;
	}
}

//  @method HRESULT | IDMUSProdTimeline | RefTimeToPosition | This method converts
//		from a time in REFERENCE_TIME units to a horizontal pixel position
//
//	@comm	Negative values for <p RefTime> are valid, in which case the tempo at time 0 will
//		be used to compute the value of <p plPosition>.
//
//  @parm   REFERENCE_TIME | RefTime | The time in REFERENCE_TIME units.
//  @parm   long* | plPosition | Address of a variable to receive the pixel position this
//		time resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p plPosition>
//	@rvalue E_UNEXPECTED | The tempo is zero at some point.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::PositionToRefTime>
HRESULT CTimelineCtl::RefTimeToPosition(
		/* [in] */  REFERENCE_TIME		RefTime,
		/* [out] */ long		*pPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (NULL == pPosition)
	{
		return E_POINTER;
	}

	if (m_fMusicTime == TRUE)
	{
		long lClocks;
		// RefTimeToClocks will map this fn to m_pTempoMapMgr if necessary
		HRESULT hr;
		if (SUCCEEDED(hr = RefTimeToClocks( RefTime, &lClocks)))
		{
			hr = ClocksToPosition( lClocks, pPosition);
		}
		return hr;
	}
	else
	{
		DMUS_TEMPO_PARAM dmTempo;
		if( FAILED( GetParam( GUID_TempoParam, 0xffffffff, 0, 0, NULL, &dmTempo ) ) )
		{
			return E_FAIL;
		}
		double dblTmp = (double)RefTime * m_dblZoom * (double)DMUS_PPQ * dmTempo.dblTempo /
						(double)REFCLOCKS_PER_MINUTE;;
		*pPosition = (long) dblTmp;
		return S_OK;
	}
}

//  @method HRESULT | IDMUSProdTimeline | MeasureBeatToRefTime | This method converts
//		from a measure and beat to a time in REFERENCE_TIME units.
//
//	@comm	If <p lMeasure> is less than 0, the Time Signature at time 0 will
//			be used to compute <p pRefTime>.  If <p lBeat> is less than 0, the
//			Time Signature in measure <p lMeasure> will be used to compute the offset
//			from the start of measure <p lMeasure>.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm   long | lMeasure | The measure.
//  @parm   long | lBeat | The beat.
//  @parm   REFERENCE_TIME* | pRefTime | Address of a variable to receive the
//		reference time.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | NULL was passed as <p pRefTime>.
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::RefTimeToMeasureBeat>
HRESULT CTimelineCtl::MeasureBeatToRefTime(
		/* [in] */ DWORD		dwGroupBits,
		/* [in] */ DWORD		dwIndex,
		/* [in] */  long		lMeasure,
		/* [in] */  long		lBeat,
		/* [out] */ REFERENCE_TIME		*pRefTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (NULL == pRefTime)
	{
		return E_POINTER;
	}

	long lClocks;
	HRESULT hr;
	if (SUCCEEDED( hr = MeasureBeatToClocks( dwGroupBits, dwIndex, lMeasure, lBeat, &lClocks)))
	{
		if (NULL != m_pTempoMapMgr)
		{
			return m_pTempoMapMgr->ClocksToRefTime( lClocks, pRefTime);
		}
		hr = ClocksToRefTime( lClocks, pRefTime);
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | RefTimeToMeasureBeat | This method converts
//		from a time in REFERENCE_CLOCK units to a time in measures and beats
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm   REFERENCE_TIME | RefTime | The time in REFERENCE_CLOCK units
//  @parm   long* | plMeasure | Address of a variable to receive the measure this
//							   time resolves to.
//  @parm   long* | plBeat | Address of a variable to receive the beat this
//							time resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p plMeasure> or <p plBeat>
//	@rvalue E_INVALIDARG | <p RefTime> is less than 0.  <p plMeasure> and <p plBeat> are
//						   set to -1.
//	@rvalue E_UNEXPECTED | The tempo is zero at some point or the Time Signature was unable
//		to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::MeasureBeatToRefTime>
HRESULT CTimelineCtl::RefTimeToMeasureBeat(
		/* [in] */  DWORD		 dwGroupBits,
		/* [in] */  DWORD		 dwIndex,
		/* [in] */  REFERENCE_TIME		RefTime,
		/* [out] */ long		*plMeasure,
		/* [out] */ long		*plBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	long lClocks;
	HRESULT hr;
	if (NULL != m_pTempoMapMgr)
	{
		hr = m_pTempoMapMgr->RefTimeToClocks( RefTime, &lClocks );
	}
	else
	{
		hr = RefTimeToClocks( RefTime, &lClocks);
	}
	if ( SUCCEEDED(hr) )
	{
		hr = ClocksToMeasureBeat( dwGroupBits, dwIndex, lClocks, plMeasure, plBeat);
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | ScreenToStripPosition | This method converts from a
//		<t POINT> in screen coordinates to a <t POINT> in strip coordinates.
//
//	@parm	<i IDMUSProdStrip>* | pIStrip | Which strip to get the new coordinates from.
//  @parm   <t POINT>* | pPoint | The screen point to convert.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_POINTER | <p pIStrip> or <p pPoint> are NULL.
//	@rvalue E_INVALIDARG | <p pIStrip> was not previously added to the Timeline.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>
HRESULT CTimelineCtl::ScreenToStripPosition(
		/* [in] */		 IDMUSProdStrip		*pIStrip,
		/* [in] [out] */ POINT				*pPoint)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( NULL == pIStrip || NULL == pPoint )
	{
		return E_POINTER;
	}

	// Ensure the strip is in the timeline
	StripList* pSLToUse = FindStripList( pIStrip );
	if (pSLToUse == NULL)
	{
		return E_INVALIDARG;
	}

	// Convert the point from screen coordinates to timeline window coordinates
	ScreenToClient( pPoint );

	// Store the point's y coordinate in a working variable
	long yPos;
	yPos = pPoint->y;

	// add horizontal scroll and subtract the function bar and early time
	pPoint->x += m_lXScrollPos - m_lFunctionBarWidth - m_lLastEarlyPosition;

	// subtract any borders
	yPos -= BORDER_HORIZ_WIDTH;

	// Check if we're looking in the first strip
	if (pSLToUse == m_pStripList)
	{
		if (pSLToUse->m_sv != SV_MINIMIZED)
		{
			// add any strip vertical scrolling, if not minized
			yPos += pSLToUse->m_lVScroll;
		}
		pPoint->y = yPos;
		return S_OK;
	}

	// add timeline scroll for all except top strip, which doesn't scroll
	yPos += m_lYScrollPos;

	// subtract the heights of any strips above this one
	for( StripList* pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
	{
		if( pTempSL == pSLToUse )
		{
			break;
		}
		yPos -= ( pTempSL->m_lHeight + BORDER_HORIZ_DRAWWIDTH );
	}

	// add any strip vertical scrolling
	if (pSLToUse->m_sv != SV_MINIMIZED)
	{
		// add any strip vertical scrolling, if not minized
		yPos += pSLToUse->m_lVScroll;
	}

	pPoint->y = yPos;
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | StripGetTimelineProperty | This method gets a strip property
//		that is controlled by the Timeline.
//
//	@parm	<i IDMUSProdStrip>* | pIStrip | Which strip to get the property of.
//  @parm   <t STRIP_TIMELINE_PROPERTY> | stp | Which property to get.  Must be one of <t STRIP_TIMELINE_PROPERTY>.
//  @parm   VARIANT* | pVariant | The address to return to property's data in.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | <p pVariant> or <p pIStrip> are NULL.
//	@rvalue E_INVALIDARG | <p stp> does not contain a valid property type, <p pIStrip> was not previously
//		added to the Timeline,	or <p pVariant> contained an invalid value for the specified property type.
//
//	@xref	<i IDMUSProdTimeline>, <t STRIP_TIMELINE_PROPERTY>,
//		<om IDMUSProdTimeline::StripSetTimelineProperty>, <i IDMUSProdStrip>
HRESULT CTimelineCtl::StripGetTimelineProperty(
		/* [in] */	IDMUSProdStrip*	pIStrip,
		/* [in] */	STRIP_TIMELINE_PROPERTY stp,
		/* [out] */	VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_INVALIDARG;

	if( NULL == pIStrip || NULL == pVariant )
	{
		return E_POINTER;
	}

	if (m_pStripList == NULL)
	{
		return E_INVALIDARG;
	}

	StripList* pSL = FindStripList( pIStrip );
	if( pSL == NULL )
	{
		return E_INVALIDARG;
	}

	switch( stp )
	{
	case STP_VERTICAL_SCROLL:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = pSL->m_lVScroll;
		hr = S_OK;
		break;

	case STP_ENTIRE_STRIP_RECT:
		if( (pVariant->vt == VT_BYREF) && (V_BYREF(pVariant) != NULL) )
		{
			RECT *pRect = (RECT *)V_BYREF(pVariant);
			GetEntireStripClientRect( pSL, pRect );
			hr = S_OK;
		}
		break;
	case STP_STRIP_RECT:
	case STP_FBAR_RECT:
	case STP_FBAR_CLIENT_RECT:
		if( (pVariant->vt == VT_BYREF) && (V_BYREF(pVariant) != NULL) )
		{
			RECT *pRect = (RECT *)V_BYREF(pVariant);
			GetStripClientRect( pSL, pRect );
			if( stp == STP_STRIP_RECT )
			{
				pRect->left += m_lFunctionBarWidth;
			}
			else if( stp == STP_FBAR_RECT )
			{
				pRect->right = m_lFunctionBarWidth;
			}
			else // STP_FBAR_CLIENT_RECT
			{
				pRect->bottom = pRect->bottom - pRect->top;
				pRect->top = 0;
				pRect->right = m_lFunctionBarWidth - GUTTER_WIDTH - BORDER_VERT_WIDTH;
			}
			if( pRect->left > pRect->right )
			{
				// there is no client area to draw in, so fail
				pRect->left = 0;
				pRect->right = 0;
				pRect->bottom = 0;
				pRect->top = 0;
				hr = E_FAIL;
			}
			else
			{
				hr = S_OK;
			}
		}
		break;

	case STP_GET_HDC:
		// Only succeed if m_hWnd is actually a real window
		if( ::IsWindow( m_hWnd ) )
		{
			HDC hdc;
			hdc = GetDC();

			if( hdc )
			{
				CDC dc;
				if( dc.Attach( hdc ) )
				{
					RECT rect;

					GetStripClientRect( pSL, &rect );
					rect.top += BORDER_HORIZ_WIDTH;
					rect.left += m_lFunctionBarWidth;
					hr = S_OK;
					if( rect.left > rect.right )
					{
						// there is no client area to draw in, so return
						// a null hdc
						ReleaseDC(hdc);
						hdc = NULL;
						hr = E_FAIL;
					}
					else
					{
						CRgn rgn;
						// set window org so m_lXScrollPos,0 is top left of strip
						dc.SetWindowOrg( -rect.left, -rect.top );
						// set clip region so we can't plot outside of strip
						rgn.CreateRectRgn( rect.left, rect.top, rect.right, rect.bottom );
						dc.SelectClipRgn( &rgn );
						rgn.DeleteObject();
					}
					dc.Detach();
				}
				else
				{
					ReleaseDC(hdc);
					hdc = NULL;
					hr = E_FAIL;
				}
			}
			else
			{
				hr = E_FAIL;
			}
			pVariant->vt = VT_I4;
			V_I4(pVariant) = (long)hdc;
		}
		else
		{
			hr = E_FAIL;
		}
		break;

	case STP_HEIGHT:
		pVariant->vt = VT_I4;
		hr = S_OK;
		if ( pSL->m_sv == SV_NORMAL )
		{
			V_I4(pVariant) = pSL->m_lHeight;
		}
		else if ( pSL->m_sv == SV_MINIMIZED )
		{
			V_I4(pVariant) = pSL->m_lRestoreHeight;
		}
		else
		{
			V_I4(pVariant) = -1;
			hr = E_UNEXPECTED;
		}
		break;

	case STP_STRIPVIEW:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = (int) pSL->m_sv;
		hr = S_OK;
		break;

	case STP_POSITION:
		{
			pVariant->vt = VT_I4;
			StripList*	pScan;
			long lResult = -1, lPosition = 0;
			for( pScan = m_pStripList; pScan; pScan = pScan->m_pNext )
			{
				if( pScan->m_pStrip == pIStrip )
				{
					lResult = lPosition;
					break;
				}
				lPosition++;
			}
			if( lResult == -1 )
			{
				hr = E_INVALIDARG;
				V_I4(pVariant) = lResult;
			}
			else
			{
				hr = S_OK;
				V_I4(pVariant) = lResult;
			}
		}
		break;

	case STP_GUTTER_SELECTED:
		pVariant->vt = VT_BOOL;
		V_BOOL(pVariant) = (short)pSL->m_fSelected;
		hr = S_OK;
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

HRESULT CTimelineCtl::StripPointToClient( StripList* pSL, POINT *pPoint) const
{
	// Validate parameters
	ASSERT( pSL && pPoint );
	if ((NULL == pSL)||(NULL == pPoint))
	{
		return E_INVALIDARG;
	}

	// Store the point's y coordinate in a working variable
	long yPos;
	yPos = pPoint->y;

	// subtract horizontal scroll and add the function bar and early time
	pPoint->x -= m_lXScrollPos - m_lFunctionBarWidth - m_lLastEarlyPosition;

	// add any borders
	yPos += BORDER_HORIZ_WIDTH;

	// Check if we're looking in the first strip
	if (pSL == m_pStripList)
	{
		if (pSL->m_sv != SV_MINIMIZED)
		{
			// subtract any strip vertical scrolling, if not minized
			yPos -= pSL->m_lVScroll;
		}
		pPoint->y = yPos;
		return S_OK;
	}

	// subtract timeline scroll for all except top strip, which doesn't scroll
	yPos -= m_lYScrollPos;

	// add the heights of any strips above this one
	for( StripList* pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
	{
		if( pSL == pTempSL )
		{
			break;
		}
		yPos += ( pTempSL->m_lHeight + BORDER_HORIZ_DRAWWIDTH );
	}

	if ( pTempSL == NULL )
	{
		// Strip not in our list.
		return E_INVALIDARG;
	}

	if (pSL->m_sv != SV_MINIMIZED)
	{
		// subtract any strip vertical scrolling, if not minized
		yPos -= pSL->m_lVScroll;
	}

	pPoint->y = yPos;
	return S_OK;
}

HRESULT CTimelineCtl::StripRectToClient( StripList* pSL, LPRECT pRect) const
{
	POINT point;
	point.x = 0;
	point.y = 0;

	HRESULT hr;
	hr = StripPointToClient( pSL, &point );
	if ( SUCCEEDED(hr) )
	{
		pRect->top += point.y;
		pRect->bottom += point.y;
		pRect->left += point.x;
		pRect->right += point.x;
	}
	return hr;
}

bool CTimelineCtl::AnyGutterSelectedStrips( void ) const
{
	StripList* pSL;
	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( (pSL->m_pStrip != NULL) && pSL->m_fSelected )
		{
			return true;
		}
	}

	return false;
}

HRESULT CTimelineCtl::CanStripEdit( IDMUSProdTimelineEdit* pITimelineEdit, long lCommand )
{
	HRESULT hr = S_FALSE;

	switch( lCommand )
	{
	case IDC_TIMELINE_CUT:
		hr = pITimelineEdit->CanCut();
		break;
	case IDC_TIMELINE_COPY:
		hr = pITimelineEdit->CanCopy();
		break;
	case IDC_TIMELINE_PASTE:
		{
			// Get the IDataObject from the clipboard
			IDataObject *pIDataObject;
			if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
			{
				// Create a new TimelineDataObject
				IDMUSProdTimelineDataObject *pITimelineDataObject;
				if( SUCCEEDED( AllocTimelineDataObject( &pITimelineDataObject ) ) )
				{
					// Insert the IDataObject into the TimelineDataObject
					if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
					{
						hr = pITimelineEdit->CanPaste( pITimelineDataObject );
					}
					pITimelineDataObject->Release();
				}
				pIDataObject->Release();
			}
		}
		break;
	case IDC_TIMELINE_INSERT:
		ASSERT(FALSE);
		// Should never get here
		//hr = pITimelineEdit->CanInsert();
		break;
	case IDC_TIMELINE_DELETE:
		hr = pITimelineEdit->CanDelete();
		break;
	case IDC_TIMELINE_SELECTALL:
		hr = pITimelineEdit->CanSelectAll();
		break;
	}

	return hr == S_OK ? S_OK : S_FALSE;
}

void CTimelineCtl::DisplayPropertySheet( void )
{
	// Get a pointer to the property sheet and show it
	IDMUSProdPropSheet*	pIPropSheet;
	if( m_pDMUSProdFramework )
	{
		if( SUCCEEDED( m_pDMUSProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->Show( TRUE );
			pIPropSheet->Release();
		}
	}
}

LRESULT CTimelineCtl::OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& /*lResult*/)
{
	if( m_pActiveStripList )
	{
		CallStripWMMessage( m_pActiveStripList, nMsg, wParam, lParam );
	}
	return 0;
}

void CTimelineCtl::GetEntireStripClientRect( StripList* pSL, LPRECT pRect )
{
	// Display format:
	// BORDER_HORIZ_DRAWWIDTH
	// Strip
	// BORDER_HORIZ_DRAWWIDTH
	// Strip
	// BORDER_HORIZ_DRAWWIDTH
	// Strip
	// BORDER_HORIZ_DRAWWIDTH

	// BORDER_HORIZ_WIDTH == BORDER_HORIZ_DRAWWIDTH

	// Ensure pRect is valid
	ASSERT( pRect );

	// Set the left and right boundaries
	ClocksToPosition( m_lLength, &pRect->right );
	pRect->right += m_lLastEarlyPosition + m_lLastLatePosition;
	pRect->right -= m_lXScrollPos;
	pRect->left = -m_lXScrollPos;

	// If we're getting the rect for the top strip
	if( pSL == m_pStripList )
	{
		pRect->top = BORDER_HORIZ_WIDTH;
		pRect->bottom = pRect->top + pSL->m_lHeight;
	}
	else
	{
		// Offset everything by the timeline's vertical scroll position
		pRect->top = -m_lYScrollPos;
		// Add up the heights of all strips above ours to set pRect->top and pRect->bottom
		for( StripList* pList = m_pStripList; pList; pList = pList->m_pNext )
		{
			pRect->bottom = pRect->top + pList->m_lHeight + BORDER_HORIZ_WIDTH;
			if( pList == pSL )
			{
				break;
			}
			// The previous's strip bottom is our top, except if the previous strip is the first
			// strip and there is a vertical scroll
			pRect->top = pRect->bottom;
		}
		pRect->top += BORDER_HORIZ_WIDTH;
	}
}

bool CTimelineCtl::ComputeEarlyAndLateTime( long &lEarlyTime, long &lLateTime )
{
	// Initialize the times to 0.
	lEarlyTime = 0;
	lLateTime = 0;

	VARIANT varTime;
	for( StripList* pList = m_pStripList; pList; pList = pList->m_pNext )
	{
		if( SUCCEEDED( pList->m_pStrip->GetStripProperty( SP_EARLY_TIME, &varTime ) ) )
		{
			lEarlyTime = max( lEarlyTime, V_I4(&varTime) );
		}

		if( SUCCEEDED( pList->m_pStrip->GetStripProperty( SP_LATE_TIME, &varTime ) ) )
		{
			lLateTime = max( lLateTime, V_I4(&varTime) );
		}
	}

	return (lEarlyTime != 0) || (lLateTime != 0);
}

bool CTimelineCtl::BumpTimeCursor( bool fMoveRight, DMUSPROD_TIMELINE_SNAP_TO stAmount )
{
	// TODO: Use the dwIndex value also?
	DWORD dwGroupBits = m_pActiveStripList ? m_pActiveStripList->m_dwGroupBits : 0xFFFFFFFF;

	long lNewCursorPos = m_lCursor;

	switch( stAmount )
	{
	case DMUSPROD_TIMELINE_SNAP_BAR:
		{
			long lMeasure;
			if( SUCCEEDED( ClocksToMeasureBeat( dwGroupBits, 0, m_lCursor, &lMeasure, NULL ) ) )
			{
				long lMeasureStart, lNextMeasureStart;
				if( SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure, 0, &lMeasureStart ) )
				&&	SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure + 1, 0, &lNextMeasureStart ) ) )
				{
					if( fMoveRight )
					{
						// If we're not in the last measure
						if( lNextMeasureStart < m_lLength )
						{
							long lNewMeasureEnd;
							if( SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure + 2, 0, &lNewMeasureEnd ) ) )
							{
								// Keep the cursor the same % of the way through the bar
								lNewCursorPos = lNextMeasureStart + ((m_lCursor - lMeasureStart) * (lNewMeasureEnd - lNextMeasureStart)) / (lNextMeasureStart - lMeasureStart);
							}
						}
					}
					else
					{
						// If we're not in the first measure
						if( lMeasure != 0 )
						{
							long lNewMeasureStart;
							if( SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure - 1, 0, &lNewMeasureStart ) ) )
							{
								// Keep the cursor the same % of the way through the bar
								lNewCursorPos = lNewMeasureStart + ((m_lCursor - lMeasureStart) * (lMeasureStart - lNewMeasureStart)) / (lNextMeasureStart - lMeasureStart);
							}
						}
					}
				}
			}
		}
		break;
	case DMUSPROD_TIMELINE_SNAP_NONE:
		lNewCursorPos += fMoveRight ? 1 : -1;
		// Boundary conditions are handled at the bottom of this function
		break;
	case DMUSPROD_TIMELINE_SNAP_GRID:
		{
			long lMeasure, lBeat;
			if( SUCCEEDED( ClocksToMeasureBeat( dwGroupBits, 0, m_lCursor, &lMeasure, &lBeat ) ) )
			{
				DMUS_TIMESIGNATURE currentTimeSig;
				long lBeatStart;
				if( SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure, lBeat, &lBeatStart ) )
				&&	SUCCEEDED( GetParam( GUID_TimeSignature, dwGroupBits, 0, lBeatStart, NULL, &currentTimeSig ) ) )
				{
					const long lCurrentBeatLength = (DMUS_PPQ * 4) / currentTimeSig.bBeat;
					const long lCurrentGridLength = lCurrentBeatLength / currentTimeSig.wGridsPerBeat;
					long lGridStart = (m_lCursor - lBeatStart) / lCurrentGridLength;
					lGridStart *= lCurrentGridLength;
					lGridStart += lBeatStart;

					if( fMoveRight )
					{
						long lNewGridEnd = lGridStart + lCurrentGridLength * 2;
						if( lNewGridEnd > lBeatStart + lCurrentBeatLength )
						{
							// Check if we did not move past the end of the segment
							if( lBeatStart + lCurrentBeatLength < m_lLength )
							{
								// Moved into new beat, so get new time sig
								DMUS_TIMESIGNATURE newTimeSig;
								if( SUCCEEDED( GetParam( GUID_TimeSignature, dwGroupBits, 0, lBeatStart + lCurrentBeatLength + 1, NULL, &newTimeSig ) ) )
								{
									// Check if the TimeSigs are the same (don't care about # of beats per measure)
									if( (newTimeSig.bBeat == currentTimeSig.bBeat)
									&&	(newTimeSig.wGridsPerBeat == currentTimeSig.wGridsPerBeat) )
									{
										// Keep the cursor the same % of the way through the grid
										// Can't just add grid length because there may be a non-even number of grids per beat
										lNewCursorPos = m_lCursor - lGridStart + lBeatStart + lCurrentBeatLength;
									}
									else
									{
										const long lNewGridLength = ((DMUS_PPQ * 4) / newTimeSig.bBeat) / newTimeSig.wGridsPerBeat;

										// Keep the cursor the same % of the way through the grid
										lNewCursorPos = lBeatStart + lCurrentBeatLength + ((m_lCursor - lGridStart) * lNewGridLength) / lCurrentGridLength;
									}
								}
							}
						}
						else
						{
							// Check if we did not move past the end of the segment
							if( lGridStart + lCurrentGridLength < m_lLength )
							{
								// Keep the cursor the same % of the way through the grid
								lNewCursorPos = m_lCursor + lCurrentGridLength;
							}
						}
					}
					else
					{
						// Check if not moving before start of the segment
						if( lGridStart != 0 )
						{
							long lNewGridStart = lGridStart - lCurrentGridLength;
							if( lNewGridStart < lBeatStart )
							{
								// Moved into new beat, so get new time sig
								DMUS_TIMESIGNATURE newTimeSig;
								if( SUCCEEDED( GetParam( GUID_TimeSignature, dwGroupBits, 0, lBeatStart - 1, NULL, &newTimeSig ) ) )
								{
									// Check if the TimeSigs are the same (don't care about # of beats per measure)
									if( (newTimeSig.bBeat == currentTimeSig.bBeat)
									&&	(newTimeSig.wGridsPerBeat == currentTimeSig.wGridsPerBeat) )
									{
										// Keep the cursor the same % of the way through the grid
										// Can't just subtract grid length because there may be a non-even number of grids per beat
										lNewCursorPos = m_lCursor - lCurrentBeatLength + (currentTimeSig.wGridsPerBeat - 1) * lCurrentGridLength;
									}
									else
									{
										const long lNewBeatLength = (DMUS_PPQ * 4) / newTimeSig.bBeat;
										const long lNewGridLength = lNewBeatLength / newTimeSig.wGridsPerBeat;

										// Keep the cursor the same % of the way through the grid
										// Can't just subtract grid length because there may be a non-even number of grids per beat
										lNewCursorPos = lBeatStart - lNewBeatLength + (newTimeSig.wGridsPerBeat - 1) * lNewGridLength + ((m_lCursor - lGridStart) * lNewGridLength) / lCurrentGridLength;
									}
								}
							}
							else
							{
								// Keep the cursor the same % of the way through the grid
								lNewCursorPos = m_lCursor - lCurrentGridLength;
							}
						}
					}
				}
			}
		}
		break;
	case DMUSPROD_TIMELINE_SNAP_BEAT:
		{
			long lMeasure, lBeat;
			if( SUCCEEDED( ClocksToMeasureBeat( dwGroupBits, 0, m_lCursor, &lMeasure, &lBeat ) ) )
			{
				long lBeatStart, lNextBeatStart;
				if( SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure, lBeat, &lBeatStart ) )
				&&	SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure, lBeat + 1, &lNextBeatStart ) ) )
				{
					if( fMoveRight )
					{
						// If the next beat starts before the segment
						if( lNextBeatStart < m_lLength )
						{
							long lNewBeatEnd, lNextMeasureStart;
							if( SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure, lBeat + 2, &lNewBeatEnd ) )
							&&	SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure + 1, 0, &lNextMeasureStart ) ) )
							{
								// Check if we're moving into a new measure
								if( lNewBeatEnd > lNextMeasureStart )
								{
									// Yes - find the end of the first beat in the new measure
									if( SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure + 1, 1, &lNewBeatEnd ) ) )
									{
										// Keep the cursor the same % of the way through the beat
										lNewCursorPos = lNextBeatStart + ((m_lCursor - lBeatStart) * (lNewBeatEnd - lNextBeatStart)) / (lNextBeatStart - lBeatStart);
									}
								}
								else
								{
									// Keep the cursor the same % of the way through the beat
									lNewCursorPos = lNextBeatStart + ((m_lCursor - lBeatStart) * (lNewBeatEnd - lNextBeatStart)) / (lNextBeatStart - lBeatStart);
								}
							}
						}
					}
					else // Move left
					{
						// If we're not in the first beat
						if( lBeatStart != 0 )
						{
							long lNewBeatStart, lThisMeasureStart;
							if( SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure, lBeat - 1, &lNewBeatStart ) )
							&&	SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure, 0, &lThisMeasureStart ) ) )
							{
								// Check if we're moving into a new measure
								if( lNewBeatStart < lThisMeasureStart )
								{
									// Yes - find the start of the last beat in the new measure
									DMUS_TIMESIGNATURE TimeSig;
									if( SUCCEEDED( GetParam( GUID_TimeSignature, dwGroupBits, 0, lThisMeasureStart - 1, NULL, &TimeSig ) )
									&&	SUCCEEDED( MeasureBeatToClocks( dwGroupBits, 0, lMeasure - 1, TimeSig.bBeatsPerMeasure - 1, &lNewBeatStart ) ) )
									{
										// Keep the cursor the same % of the way through the beat
										lNewCursorPos = lNewBeatStart + ((m_lCursor - lBeatStart) * (lBeatStart - lNewBeatStart)) / (lNextBeatStart - lBeatStart);
									}
								}
								else
								{
									// Keep the cursor the same % of the way through the beat
									lNewCursorPos = lNewBeatStart + ((m_lCursor - lBeatStart) * (lBeatStart - lNewBeatStart)) / (lNextBeatStart - lBeatStart);
								}
							}
						}
					}
				}
			}
		}
		break;
	}

	lNewCursorPos = max( 0, min( lNewCursorPos, m_lLength - 1 ) );

	if( lNewCursorPos != m_lCursor )
	{
		SetTimeCursor( lNewCursorPos, m_pTimeStrip->m_fScrollWhenSettingTimeCursor, true );
		return true;
	}

	return false;
}

bool CTimelineCtl::ShouldEnableDeleteTrack( void )
{
	// Only enable Delete Track if any strips are gutter selected, or if the 
	// there is an active strip and it is not the first strip.
	return AnyGutterSelectedStrips()
		   || (m_pActiveStripList && (m_pActiveStripList != m_pStripList));
}

void CTimelineCtl::SetTopStripList( StripList* pSL )
{
	RECT rectStrip;
	GetEntireStripClientRect( pSL, &rectStrip );

	VARIANT var;
	var.vt = VT_I4;
	V_I4( &var ) = rectStrip.top + m_lYScrollPos - m_pStripList->m_lHeight - BORDER_HORIZ_WIDTH*2;
	SetTimelineProperty( TP_VERTICAL_SCROLL, var );
}

/* TODO: Implement
StripList *CTimelineCtl::GetTopStripList( void )
{
	return m_pStripList;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TimelineDraw.h ===
#ifndef __TIMELINEDRAW_H__
#define __TIMELINEDRAW_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// TimelineDraw.h
// Macros and contants for drawing routines inside the Timeline

#define BORDER_VERT_DRAWWIDTH	2
#define BORDER_HORIZ_DRAWWIDTH	2
#define BORDER_VERT_SPACEWIDTH	1
//#define BORDER_HORIZ_SPACEWIDTH	1
#define BORDER_VERT_WIDTH		(BORDER_VERT_DRAWWIDTH + BORDER_VERT_SPACEWIDTH)
//#define BORDER_HORIZ_WIDTH		(BORDER_HORIZ_DRAWWIDTH + BORDER_HORIZ_SPACEWIDTH)
#define BORDER_HORIZ_WIDTH		BORDER_HORIZ_DRAWWIDTH
#define BORDER_COLOR			RGB(0,0,0)
#define GUTTER_WIDTH			8
#define MIN_STRIP_HEIGHT		20
#define MIN_FNBAR_WIDTH			(LEFT_DRAW_OFFSET + 1)
#define MAX_FNBAR_WIDTH			1000
#define MAX_SCROLL				31000
#define SCROLL_NPAGE			1000
#define LEFT_DRAW_OFFSET		(BORDER_VERT_WIDTH + GUTTER_WIDTH)
#define MAX_MEASURE_PIXELS		2000
#define MIN_MEASURE_PIXELS		10

#define	COLOR_GUTTER_ACTIVE			RGB( 255, 255, 0 )
#define COLOR_GUTTER_ACTIVESELECTED	RGB( 255, 128, 0 )
#define COLOR_GUTTER_SELECTED		RGB( 255, 0, 0 )
#define COLOR_GUTTER_NORMAL			RGB( 190, 190, 190 )
#define COLOR_LINE_GREY				RGB( 190, 190, 190 )
#define COLOR_TIME_CURSOR			RGB(0, 255, 255)

#define	FUNCTION_NAME_HEIGHT		15
#define COLOR_FUNCTION_NAME			RGB( 225, 225, 255 )
#define COLOR_GREY_FUNCTION_NAME	RGB( 192, 192, 192 )
#define COLOR_HATCH_FUNCTION_NAME	RGB( 128, 128, 128 )

#define SHADING_DARK_COLOR			192

#define STRIP_NAME_HEIGHT			15

// stuff for music line drawing
#define MEASURE_LINE_PENSTYLE	PS_SOLID
#define MEASURE_LINE_WIDTH		2
#define MEASURE_LINE_COLOR		RGB(0,0,0)
#define BEAT_LINE_PENSTYLE		PS_SOLID
#define BEAT_LINE_WIDTH			1
#define BEAT_LINE_COLOR			RGB(51,51,153)
#define SUBBEAT_LINE_PENSTYLE	PS_SOLID
#define SUBBEAT_LINE_WIDTH		1
#define SUBBEAT_LINE_COLOR		RGB(204,204,255)

#define CURSOR_WIDTH			1

#ifndef NOTE_TO_CLOCKS
#define NOTE_TO_CLOCKS(note, ppq)	( (ppq) * 4 / (note) )
#endif

// stuff to identify the current mouse mode
typedef enum tagMOUSEMODE
{
	MM_NORMAL,
	MM_RESIZE,			// cursor is over a resize area
	MM_ACTIVERESIZE,	// mouse button is clicked and we are actively resizing
	MM_GUTTER,			// cursor is over a gutter
	MM_ACTIVEGUTTER,	// the gutter was clicked
	MM_RESIZE_FN,		// cursor is over a function bar resize area
	MM_ACTIVERESIZE_FN, // mouse button is clicked and we are resizing the function bar
	MM_MINMAX,			// cursor is over minimize/maximize button
	MM_ACTIVEMINMAX,	// mouse button is clicked and we will minimize/maximize on button up
	MM_UNKNOWN,			// cursor is most likely over a strip, and in an unkown shape
} MOUSEMODE;

#endif // __TIMELINEDRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TimeStripMgr.cpp ===
// TimeStripMgr.cpp : Implementation of CTimeStripMgr
#include "stdafx.h"
#include "DMusProd.h"
#include "DMPPrivate.h"
#include "TimeStripMgr.h"
#include <dmusicf.h>
#include <initguid.h>
#include <math.h>
#include "TimelineCtl.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MUSICTIME_VERT_POS 15
#define REALTIME_VERT_POS 0

#define FIRST_SCROLL_ID		1
#define SECOND_SCROLL_ID	2
#define SCROLL_HORIZ_AMOUNT 25 

/////////////////////////////////////////////////////////////////////////////
// CTimeStripMgr

/////////////////////////////////////////////////////////////////////////////
// CTimeStripMgr IDMUSProdStripMgr

HRESULT STDMETHODCALLTYPE CTimeStripMgr::GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData)
{
	if ( pData == NULL )
	{
		return E_POINTER;
	}
	if ( InlineIsEqualGUID( guidType, GUID_TimeSignature ) )
	{
		memcpy(	pData, &m_TimeSig, sizeof( DMUS_TIMESIGNATURE ) );
		((DMUS_TIMESIGNATURE*)pData)->mtTime = mtTime;
		if ( pmtNext != NULL )
		{
			*pmtNext = 0;
		}
		return S_OK;
	}
	else if ( InlineIsEqualGUID( guidType, GUID_TempoParam ) )
	{
		DMUS_TEMPO_PARAM *pTempoParam = (DMUS_TEMPO_PARAM *)pData;
		pTempoParam->mtTime = 0;
		pTempoParam->dblTempo = m_dblTempo;
		if ( pmtNext != NULL )
		{
			*pmtNext = 0;
		}
		return S_OK;
	}
	else if ( InlineIsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		CComBSTR bstrTmp;
		bstrTmp.LoadString( this->m_pTimeStrip->m_nLastEdit );
		*(BSTR*)pData = bstrTmp.Detach();
		return S_OK;
	}
	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CTimeStripMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	if ( pData == NULL )
	{
		return E_POINTER;
	}
	if ( mtTime != 0 )
	{
		return E_FAIL;
	}
	if ( InlineIsEqualGUID( guidType, GUID_TimeSignature ) )
	{
		DMUS_TIMESIGNATURE *pTimeSig = (DMUS_TIMESIGNATURE *)pData;
		BOOL fChange = FALSE;
		if ( m_TimeSig.bBeatsPerMeasure != pTimeSig->bBeatsPerMeasure )
		{
			fChange = TRUE;
		}
		else if ( m_TimeSig.bBeat != pTimeSig->bBeat )
		{
			fChange = TRUE;
		}
		else if ( m_TimeSig.wGridsPerBeat != pTimeSig->wGridsPerBeat )
		{
			fChange = TRUE;
		}
		if ( fChange )
		{
			memcpy(	&m_TimeSig, pData, sizeof( DMUS_TIMESIGNATURE ) );
			m_TimeSig.mtTime = 0;
			m_pTimeline->StripInvalidateRect( m_pTimeStrip, NULL, TRUE );
			// BUGBUG: Should we also invalidate all other strips that belong to our group?
			// Probably not, since we belong to all groups.. But then how will the strips
			// that depend on us for their TimeSig be refreshed?
		}
		return S_OK;
	}
	else if ( InlineIsEqualGUID( guidType, GUID_TempoParam ) )
	{
		DMUS_TEMPO_PARAM *pTempoParam = (DMUS_TEMPO_PARAM *)pData;
		if ( m_dblTempo != pTempoParam->dblTempo )
		{
			m_dblTempo = pTempoParam->dblTempo;
			m_pTimeline->StripInvalidateRect( m_pTimeStrip, NULL, TRUE );
			// BUGBUG: Should we also invalidate all other strips that belong to our group?
			// Probably not, since we belong to all groups.. But then how will the strips
			// that depend on us for their TimeSig be refreshed?
		}
		return S_OK;
	}
	else if( InlineIsEqualGUID( guidType, GUID_TimelineShowTimeSig ) )
	{
		BOOL *pfShowTimeSig = (BOOL *)pData;
		if( m_fShowTimeSig != *pfShowTimeSig )
		{
			m_fShowTimeSig = *pfShowTimeSig;
			m_pTimeline->StripInvalidateRect( m_pTimeStrip, NULL, TRUE );
		}
		return S_OK;
	}
	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CTimeStripMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if ( InlineIsEqualGUID( guidType, GUID_TimeSignature ) )
	{
		return S_OK;
	}
	else if ( InlineIsEqualGUID( guidType, GUID_TempoParam ) )
	{
		return S_OK;
	}
	else if ( InlineIsEqualGUID( guidType, GUID_TimelineShowTimeSig ) )
	{
		return S_OK;
	}
	else if ( InlineIsEqualGUID( guidType, CLSID_TimeStripMgr ) )
	{
		return S_OK;
	}
	else if ( InlineIsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		return S_OK;
	}
	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CTimeStripMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwGroupBits);
	UNREFERENCED_PARAMETER(pData);

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Redraw our strip
		if( m_pTimeline )
		{
			m_pTimeline->StripInvalidateRect( m_pTimeStrip, NULL, TRUE );
		}
		return S_OK;
	}
	else if( ::IsEqualGUID( rguidType, GUID_TempoParam ) )
	{
		// Redraw our strip
		if( m_pTimeline && m_pTimeStrip->m_bDisplayRealTime )
		{
			m_pTimeline->StripInvalidateRect( m_pTimeStrip, NULL, TRUE );
		}
		return S_OK;
	}

	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTimeStripMgr::GetStripMgrProperty(
		/* [in] */  STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */	VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;
		/* Unsupported
	case SMP_IDIRECTMUSICTRACK:
		break;
	case SMP_IDMUSPRODFRAMEWORK:
		break;
	case SMP_DMUSIOTRACKHEADER:
		break;
		*/
	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CTimeStripMgr::SetStripMgrProperty(
		/* [in] */  STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */	VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( m_pTimeline )
		{
			m_pTimeline->RemoveStrip( m_pTimeStrip );
			delete m_pTimeStrip;
			m_pTimeStrip = NULL;

			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, 0xFFFFFFFF );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, 0xFFFFFFFF );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}
		if( V_UNKNOWN( &variant ) && FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
		{
			m_pTimeline = NULL;
			return E_FAIL;
		}
		if( m_pTimeline )
		{
			m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, 0xFFFFFFFF );
			m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, 0xFFFFFFFF );

			CTimeStrip*	pTimeStrip = new CTimeStrip(this);
			if( !pTimeStrip )
			{
				return E_OUTOFMEMORY;
			}

			m_pTimeStrip = pTimeStrip;

			m_pTimeline->AddStrip( pTimeStrip );
		}
		break;
		/* Unsupported
	case SMP_IDIRECTMUSICTRACK:
		break;
	case SMP_IDMUSPRODFRAMEWORK:
		break;
	case SMP_DMUSIOTRACKHEADER:
		break;
		*/
	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeStrip

/////////////////////////////////////////////////////////////////////////////
// CTimeStrip IUnknown
STDMETHODIMP CTimeStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CTimeStrip::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CTimeStrip::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTimeStrip IDMUSProdStrip
HRESULT	STDMETHODCALLTYPE CTimeStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	UNREFERENCED_PARAMETER( sv );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTimeStripMgr->m_pTimeline )
	{
		m_pTimeStripMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, 0xFFFFFFFF, 0, lXOffset );
		{
			RECT	rectClip;
			::GetClipBox( hDC, &rectClip );

			if ( m_bDisplayMusicTime == TRUE )
			{
				DrawMusicTime( hDC, lXOffset );
			}

			if ( m_bDisplayRealTime == TRUE )
			{
				switch (m_tsdDisplayRealTime)
				{
				case TS_RT_SECOND:
					DrawRealOnSecond( hDC, lXOffset );
					break;
				case TS_RT_MEASURE:
					DrawRealOnMeasure( hDC, lXOffset );
					break;
				case TS_RT_BEAT:
					DrawRealOnBeat( hDC, lXOffset );
					break;
				default:
					break;
				}
			}
			// invertrect selected time
			if( m_lBeginSelect != m_lEndSelect )
			{
				long beginPos, endPos, cursorPos;

				m_pTimeStripMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &cursorPos );
				if( cursorPos > 0 )
				{
					m_pTimeStripMgr->m_pTimeline->ClocksToPosition( cursorPos, &cursorPos );
				}
				else
				{
					cursorPos = 0;
				}
				
				if (m_lBeginSelect > 0)
				{
					m_pTimeStripMgr->m_pTimeline->ClocksToPosition( m_lBeginSelect, &beginPos );
				}
				else
				{
					beginPos = 0;
				}
				if (m_lEndSelect > 0)
				{
					m_pTimeStripMgr->m_pTimeline->ClocksToPosition( m_lEndSelect, &endPos );
				}
				else
				{
					endPos = 0;
				}

				if( endPos && ( beginPos == endPos ) )
				{
					endPos += 1;
				}

				if ( cursorPos )
				{
					if ( beginPos == cursorPos )
					{
						beginPos++;
					}
					else if ( endPos == cursorPos )
					{
						endPos--;
					}
				}
				rectClip.left = beginPos - lXOffset;
				rectClip.right = endPos - lXOffset;

				GrayOutRect( hDC, &rectClip );
			}
		}
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CTimeStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_MINHEIGHT:
	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;

	case SP_NAME:
		{
			if ( !m_pTimeStripMgr )
			{
				return E_FAIL;
			}

			HRESULT hr = E_FAIL;

			// Only display the time sig if m_pTimeStripMgr->m_fShowTimeSig is set
			if( m_pTimeStripMgr->m_fShowTimeSig )
			{
				BSTR bstr;
				CString str;

				long lTimeSigBottom = m_pTimeStripMgr->m_TimeSig.bBeat;
				// Zero is really 256
				if ( lTimeSigBottom == 0 )
				{
					lTimeSigBottom = 256;
				}
				str.Format("%d / %d", m_pTimeStripMgr->m_TimeSig.bBeatsPerMeasure, lTimeSigBottom );

				// Set pvar
				pvar->vt = VT_BSTR;
				try
				{
					bstr = str.AllocSysString();
				}
				catch(CMemoryException*)
				{
					return E_OUTOFMEMORY;
				}
				V_BSTR(pvar) = bstr;

				// We've succeeded
				hr = S_OK;
			}

			if( FAILED( hr ) )
			{
				return hr;
			}
		}
		break;

	case SP_CURSOR_HANDLE:
		if (m_hCursor)
		{
			pvar->vt = VT_I4;
			V_I4(pvar) = (long) m_hCursor;
		}
		else return E_FAIL;
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pTimeStripMgr )
		{
			m_pTimeStripMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}

void CTimeStrip::OnGutterSelect( BOOL fSelect )
{
	// Set selection start to 0
	m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );

	// now see if it was originally zero
	if( !fSelect )
	{
		// Set selection end to 0 (should clear selection)
		m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	}
	else
	{
		// Set selection end to entire timeline
		VARIANT varLength;
		m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength );

		m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, V_I4(&varLength) );
	}
}

/*
	VARIANT varLength;
	long lTemp;
	IDMUSProdTimeline* pTimeline = m_pTimeStripMgr->m_pTimeline;
	// if we've currently selected all time, deselect all time. Otherwise,
	// select all time
	pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength );
	pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTemp );
	// this gets set to 0 regardless
	pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	// now see if it was originally zero
	if( lTemp == 0 )
	{
		// and see if the endtime was the length
		pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTemp );
		if( lTemp == V_I4(&varLength) )
		{
			pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
			pTimeline->StripInvalidateRect( this, NULL, FALSE );
			return;
		}
	}
	pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, V_I4(&varLength) );
	pTimeline->StripInvalidateRect( this, NULL, FALSE );
*/

HRESULT STDMETHODCALLTYPE CTimeStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
	{
		if( var.vt != VT_I4 )
		{
			return E_INVALIDARG;
		}

		BOOL fRefresh = FALSE;
		if( sp == SP_BEGINSELECT )
		{
			if( m_lBeginSelect != V_I4( &var ) )
			{
				fRefresh = TRUE;
				m_lBeginSelect = V_I4( &var );
				if( m_lBeginSelect != 0 )
				{
					// If begin selection is not 0, clear our gutter selection
					var.vt = VT_BOOL;
					V_BOOL( &var ) = FALSE;
					m_pTimeStripMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_GUTTER_SELECTED, var );
				}
			}
		}
		else
		{
			if( m_lEndSelect != V_I4( &var ) )
			{
				fRefresh = TRUE;
				m_lEndSelect = V_I4( &var );

				// Get length of timeline
				m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
				if( m_lEndSelect != V_I4( &var ) )
				{
					// If end selection is not the end of the timeline, clear our gutter selection
					var.vt = VT_BOOL;
					V_BOOL( &var ) = FALSE;
					m_pTimeStripMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_GUTTER_SELECTED, var );
				}
			}
		}

		if( fRefresh )
		{
			m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		}
	}
		break;

	case SP_GUTTERSELECT:
		if( var.vt != VT_BOOL )
		{
			return E_INVALIDARG;
		}
		OnGutterSelect(V_BOOL( &var ));
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}

void CTimeStrip::OnLButtonDown( WPARAM wParam, LONG lXPos )
{
	int fwKeys = wParam;        // key flags 
	long time;
	VARIANT var;

	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTimeStripMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	m_pTimeStripMgr->m_pTimeline->PositionToClocks( lXPos, &time );
	SnapTime( &time );

	if (m_tsrResizing == TS_NOTRESIZING)
	{
		if( !( fwKeys & MK_SHIFT ))
		{
			m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, time );
			m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, time );
			m_fScrollWhenSettingTimeCursor = FALSE;
			m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, m_lBeginSelect );
			m_fScrollWhenSettingTimeCursor = TRUE;
			m_lBeginSelect = time;
			m_lEndSelect = time;

			m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
		}
		else if ( fwKeys & MK_SHIFT )
		{
			if( time != m_lBeginSelect )
			{
				if( time < m_lBeginSelect )
				{
					// End time is before begin time - swap them
					UpdateStartEnd( time, m_lBeginSelect );
				}
				else if( time > m_lBeginSelect )
				{
					// End time is after begin time - leave it
					UpdateStartEnd( m_lBeginSelect, time );
				}
			}
		}
	}
	else if (m_tsrResizing == TS_START)
	{
		if( m_lBeginSelect != time )
		{
			if( time < m_lEndSelect )
			{
				UpdateStartEnd( time, m_lEndSelect );
			}
			else
			{
				// Move start past end - switch to resizing end time
				m_tsrResizing = TS_END;
				UpdateStartEnd( m_lEndSelect, time );
			}
		}
	}
	else if (m_tsrResizing == TS_END)
	{
		if( m_lEndSelect != time )
		{
			if( time > m_lBeginSelect )
			{
				UpdateStartEnd( m_lBeginSelect, time );
			}
			else
			{
				// Move end before start - switch to resizing start time
				m_tsrResizing = TS_START;
				UpdateStartEnd( time, m_lBeginSelect );
			}
		}
	}

	m_fSelecting = TRUE;
}

void CTimeStrip::OnMouseMove( LONG lXPos )
{
	long time;

	if( m_fLButtonDown )
	{
		// Deal with timer used for scrolling
		VARIANT var;

		// Get rectangle defining strip position
		var.vt = VT_BYREF;
		RECT rectStrip;
		V_BYREF(&var) = &rectStrip;
		if( SUCCEEDED ( m_pTimeStripMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var) ) )
		{
			// Get cursor position
			POINT pt;
			::GetCursorPos( &pt );

			// Convert cursor position to strip coordinates
			if( SUCCEEDED ( m_pTimeStripMgr->m_pTimeline->ScreenToStripPosition( (IDMUSProdStrip *)this, &pt ) ) 
			&&  SUCCEEDED ( m_pTimeStripMgr->m_pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &pt ) ) )
			{
				if( pt.x < rectStrip.left 
				||  pt.x > rectStrip.right )
				{
					// May need to scroll, cursor is NOT in the visible portion of the strip
					if( m_nScrollTimerID == 0 )
					{
						StartScrollTimer( FIRST_SCROLL_ID );
					}
				}
				else
				{
					// No need to scroll, cursor IS in the visible portion of the strip
					if( m_nScrollTimerID )
					{
						StopScrollTimer();
					}
				}
			}
		}
	}

	m_pTimeStripMgr->m_pTimeline->PositionToClocks( lXPos, &time );
	SnapTime( &time );

	if ((m_tsrResizing == TS_NOTRESIZING) || (m_tsrResizing == TS_END))
	{
		if( m_lEndSelect != time )
		{
			if( time > m_lBeginSelect )
			{
				UpdateStartEnd( m_lBeginSelect, time );
			}
			else
			{
				// Move end before start - switch to resizing start time
				m_tsrResizing = TS_START;
				UpdateStartEnd( time, m_lBeginSelect );
			}
		}
	}
	else if (m_tsrResizing == TS_START)
	{
		if( m_lBeginSelect != time )
		{
			if( time < m_lEndSelect )
			{
				UpdateStartEnd( time, m_lEndSelect );
			}
			else
			{
				// Move start past end - switch to resizing end time
				m_tsrResizing = TS_END;
				UpdateStartEnd( m_lEndSelect, time );
			}
		}
	}
}

void CTimeStrip::OnButtonClicked( WPARAM wParam )
{
	if (wParam == BTN_REALTIME)
	{
		if (m_bDisplayRealTime == FALSE)
		{
			ASSERT(m_bDisplayMusicTime == TRUE);
			m_bDisplayRealTime = TRUE;
			m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
		}
		else // m_bDisplayRealTime == TRUE
		{
			if ( m_bDisplayMusicTime == TRUE )
			{
				m_bDisplayRealTime = FALSE;
				m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
			}
		}
	}
	if (wParam == BTN_MUSICTIME)
	{
		if (m_bDisplayMusicTime == FALSE)
		{
			ASSERT(m_bDisplayRealTime == TRUE);
			m_bDisplayMusicTime = TRUE;
			m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
		}
		else // m_bDisplayMusicTime == TRUE
		{
			if ( m_bDisplayRealTime == TRUE )
			{
				m_bDisplayMusicTime = FALSE;
				m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
			}
		}
	}
}

HRESULT STDMETHODCALLTYPE CTimeStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER( lYPos );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_CREATE:
		{
			CWnd *pWnd = GetTimelineCWnd();
			if (pWnd)
			{
				RECT rect;
				rect.top = 0;
				rect.bottom = 15;
				rect.left = 0;
				rect.right = 15;

				m_BtnRealTime.Create( "R", BS_OWNERDRAW | BS_PUSHBUTTON | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, rect, pWnd, BTN_REALTIME );
				m_BtnRealTime.LoadBitmaps( IDB_REALTIME, IDB_REALTIMEDOWN );
				m_BtnRealTime.EnableToolTips(TRUE);

				m_BtnMusicTime.Create( "M", BS_OWNERDRAW | BS_PUSHBUTTON | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, rect, pWnd, BTN_MUSICTIME );
				m_BtnMusicTime.LoadBitmaps( IDB_MUSICTIME, IDB_MUSICTIMEDOWN );
				m_BtnMusicTime.EnableToolTips(TRUE);
			}
		}
		break;

	case WM_TIMER:
		OnTimer();
		break;
	case WM_LBUTTONDOWN:
		m_fLButtonDown = TRUE;
		OnLButtonDown( wParam, lXPos );
		break;
	case WM_LBUTTONUP:
		StopScrollTimer();
		m_fLButtonDown = FALSE;
		m_fSelecting = FALSE;
		break;
	case WM_DRAWITEM:
		OnDrawItem( wParam, lParam );
		break;
	case BN_CLICKED:
		OnButtonClicked( wParam );
		break;
	case WM_RBUTTONUP:
		{
			HMENU hMenu;
			HMENU hMenuPopup;

			hMenu = ::LoadMenu( AfxGetStaticModuleState()->m_pCurrentWinApp->m_hInstance, MAKEINTRESOURCE( IDR_REALTIME_MENU ));			//		hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE( IDR_EDIT_RMENU ));
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			::CheckMenuItem( hMenuPopup, ID_RT_SECONDS, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_RT_MEASURES, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_RT_BEATS, MF_UNCHECKED );

			switch( m_tsdDisplayRealTime )
			{
			case TS_RT_SECOND:
				::CheckMenuItem( hMenuPopup, ID_RT_SECONDS, MF_CHECKED );
				break;
			case TS_RT_MEASURE:
				::CheckMenuItem( hMenuPopup, ID_RT_MEASURES, MF_CHECKED );
				break;
			case TS_RT_BEAT:
				::CheckMenuItem( hMenuPopup, ID_RT_BEATS, MF_CHECKED );
				break;
			}

			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_UNCHECKED );

			switch( m_stSetting )
			{
			case DMUSPROD_TIMELINE_SNAP_NONE:
				::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_CHECKED );
				break;
			case DMUSPROD_TIMELINE_SNAP_GRID:
				::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_CHECKED );
				break;
			case DMUSPROD_TIMELINE_SNAP_BEAT:
				::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_CHECKED );
				break;
			case DMUSPROD_TIMELINE_SNAP_BAR:
				::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_CHECKED );
				break;
			}

			if( SUCCEEDED( m_pTimeStripMgr->m_pTimeline->GetParam( GUID_Segment_DisplayContextMenu, 0xFFFFFFFF, 0, 0, NULL, &lParam ) ) )
			{
				EnableMenuItem( hMenuPopup, ID_EDIT_DELETE_TRACK, ((CTimelineCtl*)m_pTimeStripMgr->m_pTimeline)->ShouldEnableDeleteTrack() ? MF_ENABLED : MF_GRAYED );
			}
			else
			{
				::DeleteMenu( hMenuPopup, ID_EDIT_DELETE_TRACK, MF_BYCOMMAND );
				::DeleteMenu( hMenuPopup, ID_EDIT_ADD_TRACK, MF_BYCOMMAND );
				::DeleteMenu( hMenuPopup, 2, MF_BYPOSITION );
			}

			// Get the cursor position (To put the menu there)
			POINT pt;
			BOOL bResult = GetCursorPos( &pt );
			ASSERT( bResult );
			if( !bResult )
			{
				break;
			}
			
			ASSERT(m_pTimeStripMgr->m_pTimeline);
			m_pTimeStripMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);

			::DestroyMenu( hMenu );
		}
		break;

	case WM_SETFOCUS:
		OnShowProperties();
		break;

	case WM_SETCURSOR:
		if( !m_fSelecting )
		{
			if( m_lBeginSelect == m_lEndSelect )
			{
				HCURSOR hCursorArrow = GetArrowCursor();
				if( hCursorArrow )
					m_hCursor = hCursorArrow;
				m_tsrResizing = TS_NOTRESIZING;
			}
			else
			{
				long nPos;
				BOOL fResizing = FALSE;
				if (m_lEndSelect >= 0)
				{
					m_pTimeStripMgr->m_pTimeline->ClocksToPosition(m_lEndSelect,&nPos);
					if (abs(lXPos-nPos)<3)
					{
						fResizing = TRUE;
						m_tsrResizing = TS_END;
					}
				}
				if (m_lBeginSelect >= 0)
				{
					m_pTimeStripMgr->m_pTimeline->ClocksToPosition(m_lBeginSelect,&nPos);
					if (abs(lXPos-nPos)<3)
					{
						fResizing = TRUE;
						m_tsrResizing = TS_START;
					}
				}
				if (fResizing)
				{
					HCURSOR hCursorSizeWE = GetWECursor();
					if( hCursorSizeWE )
						m_hCursor = hCursorSizeWE;
				}
				else
				{
					HCURSOR hCursorArrow = GetArrowCursor();
					if( hCursorArrow )
						m_hCursor = hCursorArrow;
					m_tsrResizing = TS_NOTRESIZING;
				}
			}
		}
		break;
	case WM_MOUSEMOVE:
		if( m_fSelecting )
		{
			OnMouseMove( lXPos );
		}
		break;
	case WM_SIZE:
		hr = OnSize( wParam, lParam );
		break;
	case WM_COMMAND:
		{
			;
			ASSERT(m_pTimeStripMgr);
			if ( m_pTimeStripMgr == NULL )
			{
				break;
			}
			ASSERT(m_pTimeStripMgr->m_pTimeline);
			if ( m_pTimeStripMgr->m_pTimeline == NULL )
			{
				break;
			}
			
			BOOL bResult;
			WORD wID = LOWORD(wParam);	// item, control, or accelerator identifier 
			switch(wID)
			{
			case ID_RT_SECONDS:
				if ( m_tsdDisplayRealTime != TS_RT_SECOND )
				{
					m_tsdDisplayRealTime = TS_RT_SECOND;
					m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
				}
				break;
			case ID_RT_MEASURES:
				if ( m_tsdDisplayRealTime != TS_RT_MEASURE )
				{
					m_tsdDisplayRealTime = TS_RT_MEASURE;
					m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
				}
				break;
			case ID_RT_BEATS:
				if ( m_tsdDisplayRealTime != TS_RT_BEAT )
				{
					m_tsdDisplayRealTime = TS_RT_BEAT;
					m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
				}
				break;
			case ID_SNAP_NONE:
				SetSnapTo( DMUSPROD_TIMELINE_SNAP_NONE );
				break;
			case ID_SNAP_GRID:
				SetSnapTo( DMUSPROD_TIMELINE_SNAP_GRID );
				break;
			case ID_SNAP_BEAT:
				SetSnapTo( DMUSPROD_TIMELINE_SNAP_BEAT );
				break;
			case ID_SNAP_BAR:
				SetSnapTo( DMUSPROD_TIMELINE_SNAP_BAR );
				break;
			case ID_EDIT_HORIZZOOMIN:
				((CTimelineCtl *)m_pTimeStripMgr->m_pTimeline)->OnZoomIn( 0, 0, 0, bResult );
				break;
			case ID_EDIT_HORIZZOOMOUT:
				((CTimelineCtl *)m_pTimeStripMgr->m_pTimeline)->OnZoomOut( 0, 0, 0, bResult );
				break;
			case ID_EDIT_DELETE_TRACK:
			case ID_EDIT_ADD_TRACK:
				::SendMessage( ((CTimelineCtl *)m_pTimeStripMgr->m_pTimeline)->GetParent(), WM_COMMAND, wParam, lParam );
				break;
			case ID_VIEW_PROPERTIES :
				return E_NOTIMPL;
			default:
				break;
			}
		}
		break;
	default:
		break;
	}
	return S_OK;
}

HCURSOR CTimeStrip::GetWECursor(void)
{
	static HCURSOR hCursorSizeWE;
	if (!hCursorSizeWE)
		hCursorSizeWE = LoadCursor( NULL, IDC_SIZEWE ); // West/east resize
	return hCursorSizeWE;
}

HCURSOR CTimeStrip::GetArrowCursor(void)
{
	static HCURSOR hCursorArrow;
	if (!hCursorArrow)
		hCursorArrow = LoadCursor( NULL, IDC_ARROW );
	return hCursorArrow;
}

void CTimeStrip::DrawMusicTime( HDC hDC, LONG lXOffset )
{
	{
		// get first number we need to draw
		RECT	rectClip;
		long	measure, position, endPosition;
		char	cstrMeasure[20];
		VARIANT var;

		::GetClipBox( hDC, &rectClip );
		m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		m_pTimeStripMgr->m_pTimeline->ClocksToPosition( V_I4(&var), &endPosition );

		if ( SUCCEEDED(m_pTimeStripMgr->m_pTimeline->PositionToMeasureBeat( 0xFFFFFFFF, 0, rectClip.left + lXOffset, &measure, NULL )) )
		{
			do	{
				m_pTimeStripMgr->m_pTimeline->MeasureBeatToPosition( 0xFFFFFFFF, 0, measure, 0, &position );
				_itoa( (int)(++measure), cstrMeasure, 10 );
				position++;
				if( position < endPosition )
				{
					::TextOut( hDC, position - lXOffset, MUSICTIME_VERT_POS, cstrMeasure, strlen(cstrMeasure) );
				}
			} while( (position < rectClip.right + lXOffset) && (position < endPosition) );
		}
	}
}

void CTimeStrip::DrawRealOnSecond( HDC hDC, LONG lXOffset )
{
	{
		RECT	rectClip;
		long	position, endPosition;
		char	strTime[20];
		VARIANT var;

		::GetClipBox( hDC, &rectClip );
		m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		m_pTimeStripMgr->m_pTimeline->ClocksToPosition( V_I4(&var), &endPosition );

		REFERENCE_TIME refTime,refSecond;
		m_pTimeStripMgr->m_pTimeline->PositionToRefTime( rectClip.left + lXOffset, &refTime);
		refSecond = refTime / REFCLOCKS_PER_SECOND;

		HPEN hPenTimeTick;
		hPenTimeTick = ::CreatePen( PS_SOLID, 1, m_colorTimeTick );
		if( hPenTimeTick )
		{
			do
			{
				m_pTimeStripMgr->m_pTimeline->RefTimeToPosition( refSecond * REFCLOCKS_PER_SECOND, &position );
				if( position < endPosition )
				{
					if( refSecond < 60 )
					{
						_snprintf( strTime, 19, "%02d", (int)refSecond );
					}
					else
					{
						_snprintf( strTime, 19, "%d:%02d", (int)refSecond/60, (int)refSecond%60 );
					}
					::TextOut( hDC, position - lXOffset, REALTIME_VERT_POS, strTime, strlen(strTime) );

					HPEN hPenOld;
					hPenOld = static_cast<HPEN> ( ::SelectObject( hDC, hPenTimeTick ) );
					::MoveToEx( hDC, position - lXOffset, 0, NULL );
					::LineTo( hDC, position - lXOffset, STRIP_HEIGHT / 4 );
					::SelectObject( hDC, hPenOld );
				}
				refSecond++;
			} while( position < rectClip.right + lXOffset );
			
			::DeleteObject( hPenTimeTick );
		}
	}
}

void CTimeStrip::DrawRealOnMeasure( HDC hDC, LONG lXOffset )
{
	{
		RECT	rectClip;
		long	measure, position, endPosition, endMeasure;
		char	strTime[20];
		VARIANT var;
		
		::GetClipBox( hDC, &rectClip );
		m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		m_pTimeStripMgr->m_pTimeline->ClocksToPosition( V_I4(&var), &endPosition );
		m_pTimeStripMgr->m_pTimeline->PositionToMeasureBeat( 0xFFFFFFFF, 0, rectClip.right + lXOffset, &endMeasure, NULL );
		m_pTimeStripMgr->m_pTimeline->PositionToMeasureBeat( 0xFFFFFFFF, 0, rectClip.left + lXOffset, &measure, NULL );

		while( measure <= endMeasure )
		{
			m_pTimeStripMgr->m_pTimeline->MeasureBeatToPosition( 0xFFFFFFFF, 0, measure, 0, &position );
			position++;
			if( position < endPosition )
			{
				REFERENCE_TIME refTimeTmp;
				m_pTimeStripMgr->m_pTimeline->MeasureBeatToRefTime( 0xFFFFFFFF, 0, measure, 0, &refTimeTmp);
				float fTime = (float) refTimeTmp;
				fTime /= REFCLOCKS_PER_SECOND;
				if( fTime >= 60.0 )
				{
					_snprintf( strTime, 19, "%d:%#05.2f", int(fTime / 60.0), fmod(fTime, 60.0));
				}
				else
				{
					_snprintf( strTime, 19, "%#05.2f", fTime);
				}
				::TextOut( hDC, position - lXOffset, REALTIME_VERT_POS, strTime, strlen(strTime) );
			}
			measure++;
		};
	}
}

void CTimeStrip::DrawRealOnBeat( HDC hDC, LONG lXOffset )
{
	{
		RECT	rectClip;
		long	measure, beat, position, endPosition, endMeasure;
		char	strTime[20];
		VARIANT var;
		
		::GetClipBox( hDC, &rectClip );
		m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		m_pTimeStripMgr->m_pTimeline->ClocksToPosition( V_I4(&var), &endPosition );
		m_pTimeStripMgr->m_pTimeline->PositionToMeasureBeat( 0xFFFFFFFF, 0, rectClip.right + lXOffset, &endMeasure, NULL );
		m_pTimeStripMgr->m_pTimeline->PositionToMeasureBeat( 0xFFFFFFFF, 0, rectClip.left + lXOffset, &measure, NULL );

		DMUS_TIMESIGNATURE TimeSig;
		MUSIC_TIME mtTSCur;
		m_pTimeStripMgr->m_pTimeline->MeasureBeatToClocks( 0xFFFFFFFF, 0, measure, 0, &mtTSCur );

		HRESULT hr;
		while( measure <= endMeasure )
		{
			hr = m_pTimeStripMgr->m_pTimeline->GetParam( GUID_TimeSignature, 0xFFFFFFFF, 0, mtTSCur, NULL, &TimeSig );
			if ( FAILED( hr ) )
			{
				return;
			}

			for (beat = 0; beat < TimeSig.bBeatsPerMeasure; beat ++)
			{
				m_pTimeStripMgr->m_pTimeline->MeasureBeatToPosition( 0xFFFFFFFF, 0, measure, beat, &position );
				position++;
				if( position < endPosition )
				{
					REFERENCE_TIME refTimeTmp;
					m_pTimeStripMgr->m_pTimeline->MeasureBeatToRefTime( 0xFFFFFFFF, 0, measure, beat, &refTimeTmp);
					float fTime = (float) refTimeTmp;
					fTime /= REFCLOCKS_PER_SECOND;
					if( fTime >= 60.0 )
					{
						_snprintf( strTime, 19, "%d:%#05.2f", int(fTime / 60.0), fmod(fTime, 60.0));
					}
					else
					{
						_snprintf( strTime, 19, "%#05.2f", fTime);
					}
					::TextOut( hDC, position - lXOffset, REALTIME_VERT_POS, strTime, strlen(strTime) );
				}
			}
			measure++;
			mtTSCur += NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ) * TimeSig.bBeatsPerMeasure;
		};
	}
}

HRESULT CTimeStrip::FBDraw( HDC hDC, STRIPVIEW sv)
{
	UNREFERENCED_PARAMETER( hDC );
	UNREFERENCED_PARAMETER( sv );
	return E_NOTIMPL;
}

HRESULT CTimeStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( lXPos );
	UNREFERENCED_PARAMETER( lYPos );

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_fLButtonDown = TRUE;
		break;

	case WM_LBUTTONUP:
		StopScrollTimer();
		m_fLButtonDown = FALSE;
		m_fSelecting = FALSE;
		break;

	case WM_MOUSEMOVE:
		if( m_fSelecting )
		{
			// May need to scroll, cursor is NOT in the visible portion of the strip
			if( m_nScrollTimerID == 0 )
			{
				StartScrollTimer( FIRST_SCROLL_ID );
			}
		}
		break;

	case WM_SETCURSOR:
		if( !m_fSelecting )
		{
			HCURSOR hCursorArrow = GetArrowCursor();
			if( hCursorArrow )
				m_hCursor = hCursorArrow;
			m_tsrResizing = TS_NOTRESIZING;
		}
		break;

	default:
		break;
	};

	return S_OK;
}

void CTimeStrip::OnDrawItem( WPARAM wParam, LPARAM lParam )
{
	UINT	idCtl;
	idCtl = (UINT) wParam;             // control identifier 

	if( idCtl == BTN_REALTIME )
	{
		m_BtnRealTime.SendMessage( WM_DRAWITEM, wParam, lParam );
	}
	else if( idCtl == BTN_MUSICTIME )
	{
		m_BtnMusicTime.SendMessage( WM_DRAWITEM, wParam, lParam );
	}
}

HRESULT CTimeStrip::OnSize( WPARAM wParam, LPARAM lParam )
{
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( wParam );
	int nWidth;
	VARIANT var;

	if( FAILED(m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var )))
	{
		return E_UNEXPECTED;
	}
	nWidth = V_I4(&var) - BORDER_VERT_WIDTH;
	// move the RealTime and MusicTime buttons to where they need to go
	RECT rectMusicTime, rectRealTime;
	m_BtnMusicTime.GetClientRect(&rectMusicTime);
	m_BtnRealTime.GetClientRect(&rectRealTime);
	rectMusicTime.left = nWidth - rectMusicTime.right;
	rectMusicTime.right = nWidth;
	rectMusicTime.top = BORDER_VERT_WIDTH + MUSICTIME_VERT_POS;
	rectMusicTime.bottom = rectMusicTime.top + 15;

	rectRealTime.left = nWidth - rectRealTime.right;
	rectRealTime.right = nWidth;
	rectRealTime.top = BORDER_VERT_WIDTH + REALTIME_VERT_POS;
	rectRealTime.bottom = rectRealTime.top + 15;

	m_BtnRealTime.MoveWindow( &rectRealTime, TRUE );
	m_BtnMusicTime.MoveWindow( &rectMusicTime, TRUE );
	return S_OK;
}

void CTimeStrip::SnapTime( long *plTime )
{
	ASSERT( plTime );

	// ensure plTime is not negative
	*plTime = max( *plTime, 0 );

	if( m_stSetting == DMUSPROD_TIMELINE_SNAP_NONE )
	{
		return;
	}

	long lMeasure, lBeat;
	DMUS_TIMESIGNATURE TimeSig;
	if( SUCCEEDED( m_pTimeStripMgr->m_pTimeline->ClocksToMeasureBeat( 0xFFFFFFFF, 0, *plTime, &lMeasure, &lBeat ) )
	 && SUCCEEDED( m_pTimeStripMgr->m_pTimeline->GetParam( GUID_TimeSignature, 0xFFFFFFFF, 0, *plTime, NULL, &TimeSig ) ) )
	{
		switch( m_stSetting )
		{
		case DMUSPROD_TIMELINE_SNAP_BAR:
		{
			long lMeasureTime;
			m_pTimeStripMgr->m_pTimeline->MeasureBeatToClocks( 0xFFFFFFFF, 0, lMeasure, 0, &lMeasureTime );

			// If difference is greater than half the measure length, set plTime to the time of the next bar
			if( *plTime - lMeasureTime > (DMUS_PPQ * 2 / TimeSig.bBeat) * TimeSig.bBeatsPerMeasure )
			{
				*plTime = lMeasureTime + (DMUS_PPQ * 4 / TimeSig.bBeat) * TimeSig.bBeatsPerMeasure;
			}
			// Otherwise, set plTime to the time of the first bar
			else
			{
				*plTime = lMeasureTime;
			}
			break;
		}

		case DMUSPROD_TIMELINE_SNAP_BEAT:
		{
			long lBeatTime;
			m_pTimeStripMgr->m_pTimeline->MeasureBeatToClocks( 0xFFFFFFFF, 0, lMeasure, lBeat, &lBeatTime );

			// If difference is greater than half the beat length, set plTime to the time of the next beat
			if( *plTime - lBeatTime > (DMUS_PPQ * 2 / TimeSig.bBeat) )
			{
				*plTime = lBeatTime + (DMUS_PPQ * 4 / TimeSig.bBeat);
			}
			// Otherwise, set plTime to the time of the first beat
			else
			{
				*plTime = lBeatTime;
			}
			break;
		}

		case DMUSPROD_TIMELINE_SNAP_GRID:
		{
			long lGridTime;
			m_pTimeStripMgr->m_pTimeline->MeasureBeatToClocks( 0xFFFFFFFF, 0, lMeasure, lBeat, &lGridTime );

			// Calculate whicih grid we're in
			long lGridDiff;
			lGridDiff = *plTime - lGridTime;
			lGridDiff /= (DMUS_PPQ * 4 / TimeSig.bBeat) / TimeSig.wGridsPerBeat;
			lGridDiff *= (DMUS_PPQ * 4 / TimeSig.bBeat) / TimeSig.wGridsPerBeat;
			lGridTime += lGridDiff;

			// If difference is greater than half the grid length, set plTime to the time of the next grid
			if( *plTime - lGridTime > ((DMUS_PPQ * 2 / TimeSig.bBeat) / TimeSig.wGridsPerBeat) )
			{
				*plTime = lGridTime + ((DMUS_PPQ * 4 / TimeSig.bBeat) / TimeSig.wGridsPerBeat);
			}
			// Otherwise, set plTime to the time of the first grid
			else
			{
				*plTime = lGridTime;
			}
			break;
		}

		default:
			break;
		}
	}
}

void CTimeStrip::UpdateStartEnd( long lNewBegin, long lNewEnd )
{
	SnapTime( &lNewBegin );
	SnapTime( &lNewEnd );

	if( (lNewBegin != m_lBeginSelect) || (lNewEnd != m_lEndSelect) )
	{
		if( lNewBegin > lNewEnd )
		{
			m_lEndSelect = lNewBegin;
			if( m_stSetting != DMUSPROD_TIMELINE_SNAP_NONE )
			{
				m_lEndSelect--;
			}
			lNewBegin = lNewEnd;
			lNewEnd = m_lEndSelect;
		}
		else if( lNewEnd > lNewBegin )
		{
			m_lEndSelect = lNewEnd;
			if( m_stSetting != DMUSPROD_TIMELINE_SNAP_NONE )
			{
				m_lEndSelect--;
			}
		}
		else
		{
			m_lEndSelect = lNewEnd;
		}

		m_lBeginSelect = lNewBegin;

		long lTmpTime;
		m_pTimeStripMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTmpTime );
		if( lTmpTime != m_lBeginSelect )
		{
			m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, m_lBeginSelect );
		}
		m_pTimeStripMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTmpTime );
		if( lTmpTime != m_lEndSelect )
		{
			m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, m_lEndSelect );
		}

		ASSERT( m_lBeginSelect <= m_lEndSelect );

		m_pTimeStripMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTmpTime );
		if( lTmpTime != m_lBeginSelect )
		{
			m_fScrollWhenSettingTimeCursor = FALSE;
			m_pTimeStripMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, m_lBeginSelect );
			m_fScrollWhenSettingTimeCursor = TRUE;
		}

		m_pTimeStripMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
	}
}

long CTimeStrip::SnapAmount( long lTime )
{
	if( m_stSetting == DMUSPROD_TIMELINE_SNAP_NONE )
	{
		return 1;
	}

	DMUS_TIMESIGNATURE TimeSig;
	if( SUCCEEDED( m_pTimeStripMgr->m_pTimeline->GetParam( GUID_TimeSignature, 0xFFFFFFFF, 0, lTime, NULL, &TimeSig ) ) )
	{
		switch( m_stSetting )
		{
		case DMUSPROD_TIMELINE_SNAP_BAR:
			return ((DMUS_PPQ * 4) / TimeSig.bBeat) * TimeSig.bBeatsPerMeasure;

		case DMUSPROD_TIMELINE_SNAP_BEAT:
			return (DMUS_PPQ * 4) / TimeSig.bBeat;

		case DMUSPROD_TIMELINE_SNAP_GRID:
			return (DMUS_PPQ * 4) / (TimeSig.bBeat * TimeSig.wGridsPerBeat);
		}
	}
	return 1;
}

void CTimeStrip::StartScrollTimer( UINT nScrollTimerID )
{
	if( m_nScrollTimerID )
	{
		StopScrollTimer();
	}

	CWnd *pWnd = GetTimelineCWnd();
	if( pWnd )
	{
		UINT nInterval;

		switch( nScrollTimerID )
		{
			case FIRST_SCROLL_ID:
				nInterval = 350;
				break;
			case SECOND_SCROLL_ID:
				nInterval = 90;
				break;
			default:
				nInterval = 90;
				break;
		}

		if( ::SetTimer( pWnd->GetSafeHwnd(), nScrollTimerID, nInterval, NULL ) )
		{
			m_nScrollTimerID = nScrollTimerID;
		}
	}
}

void CTimeStrip::StopScrollTimer( void )
{
	if( m_nScrollTimerID )
	{
		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			::KillTimer( pWnd->GetSafeHwnd(), m_nScrollTimerID );
		}

		m_nScrollTimerID = 0;
	}
}


CWnd* CTimeStrip::GetTimelineCWnd( void )
{
	CWnd* pWnd = NULL;

	// Get the DC of our Strip
	if( m_pTimeStripMgr->m_pTimeline )
	{
		IOleWindow *pIOleWindow;
		if( SUCCEEDED ( m_pTimeStripMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow ) ) )
		{
			HWND hwnd;
			if( SUCCEEDED( pIOleWindow->GetWindow( &hwnd ) ) )
			{
				pWnd = CWnd::FromHandlePermanent( hwnd );
			}
			pIOleWindow->Release();
		}
	}

	return pWnd;
}

void CTimeStrip::OnTimer( void )
{
	if( m_nScrollTimerID == FIRST_SCROLL_ID )
	{
		StartScrollTimer( SECOND_SCROLL_ID );
	}

	// Get cursor position
	POINT pt;
	::GetCursorPos( &pt );

	// Convert to strip coordinates
	if( FAILED ( m_pTimeStripMgr->m_pTimeline->ScreenToStripPosition( (IDMUSProdStrip *)this, &pt ) ) )
	{
		return;
	}

	// Get current scroll position
	VARIANT var;
	long lHScroll = 0;
	if( SUCCEEDED( m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
	{
		lHScroll = V_I4(&var);
	}

	// Scroll left?
	if( pt.x < lHScroll 
	&&  lHScroll > 0 )
	{
		// Scroll left
		var.vt = VT_I4;
		V_I4(&var) = max( lHScroll - SCROLL_HORIZ_AMOUNT, 0 );
		m_pTimeStripMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

		OnMouseMove( max(lHScroll - SCROLL_HORIZ_AMOUNT, 0) );
		return;
	}

	// Get rectangle defining strip position
	var.vt = VT_BYREF;
	RECT rectStrip;
	V_BYREF(&var) = &rectStrip;
	if( SUCCEEDED ( m_pTimeStripMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var) ) )
	{
		// Compute the right side of the display
		long lMaxScreenPos = lHScroll + rectStrip.right - rectStrip.left;

		// Compute the maximum scroll position
		m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		long lTimelineClockLength = V_I4(&var);
		long lMaxXPos;
		if( SUCCEEDED ( m_pTimeStripMgr->m_pTimeline->ClocksToPosition( lTimelineClockLength, &lMaxXPos ) ) )
		{
			long lMaxHScroll = lMaxXPos - (rectStrip.right - rectStrip.left);

			// Scroll right?
			if( pt.x > lMaxScreenPos 
			&&  lHScroll < lMaxHScroll )
			{
				// Scroll right
				var.vt = VT_I4;
				V_I4(&var) = min( lHScroll + SCROLL_HORIZ_AMOUNT, lMaxHScroll);
				m_pTimeStripMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

				OnMouseMove( min(lMaxScreenPos + SCROLL_HORIZ_AMOUNT, lMaxXPos) );
				return;
			}
		}
	}
}

void CTimeStrip::SetSnapTo( DMUSPROD_TIMELINE_SNAP_TO stNew )
{
	if( m_stSetting == stNew )
	{
		return;
	}

	m_stSetting = stNew;

	switch( stNew )
	{
	case DMUSPROD_TIMELINE_SNAP_NONE:
	case DMUSPROD_TIMELINE_SNAP_GRID:
	case DMUSPROD_TIMELINE_SNAP_BEAT:
	case DMUSPROD_TIMELINE_SNAP_BAR:
		// Do nothing
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	UpdateStartEnd( m_lBeginSelect, m_lEndSelect );

	// Notify the strips that the snap-to setting changed
	m_pTimeStripMgr->m_pTimeline->NotifyStripMgrs( GUID_TimelineSetSnapTo, 0xFFFFFFFF, &stNew );
}

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CTimeStrip::GetData( /* [retval][out] */ void **ppData)
{
	UNREFERENCED_PARAMETER( ppData );
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTimeStrip::SetData( /* [in] */ void *pData)
{
	UNREFERENCED_PARAMETER( pData );
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTimeStrip::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	VARIANT varFramework;
	if( SUCCEEDED( m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &varFramework ) )
	&&	(V_UNKNOWN(&varFramework) != NULL) )
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED( V_UNKNOWN(&varFramework)->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pJPS )))
		{
			if( pJPS->IsShowing() == S_OK )
			{
				VARIANT varNode;
				if( SUCCEEDED( m_pTimeStripMgr->m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &varNode ) )
				&&	(V_UNKNOWN(&varNode) != NULL) )
				{
					IDMUSProdPropPageObject *pIDMUSProdPropPageObject;
					if( SUCCEEDED( V_UNKNOWN(&varNode)->QueryInterface( IID_IDMUSProdPropPageObject, (void**)&pIDMUSProdPropPageObject ) ) )
					{
						HWND hwnd = ::GetFocus();	// save window to setfocus to afterwards if necessary

						pIDMUSProdPropPageObject->OnShowProperties();

						if(hwnd != ::GetFocus())
						{
							::SetFocus(hwnd);
						}

						pIDMUSProdPropPageObject->Release();
					}
					V_UNKNOWN(&varNode)->Release();
				}
			}
			pJPS->Release();
		}
		V_UNKNOWN(&varFramework)->Release();
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CTimeStrip::OnRemoveFromPageManager( void)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TimeStripMgr.h ===
// TimeStripMgr.h : Declaration of the CTimeStripMgr

#ifndef __TIMESTRIPMGR_H_
#define __TIMESTRIPMGR_H_

#include "resource.h"       // main symbols
#include <afxext.h>
#include "TimelineDraw.h"
#include <dmusici.h>

#ifndef REFCLOCKS_PER_SECOND
#define REFCLOCKS_PER_SECOND 10000000
#endif

#define STRIP_HEIGHT 30

class CTimeStrip;
/////////////////////////////////////////////////////////////////////////////
// CTimeStripMgr
class ATL_NO_VTABLE CTimeStripMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTimeStripMgr, &CLSID_TimeStripMgr>,
	public IDMUSProdStripMgr
{
friend class CTimeStrip;
protected:
	IDMUSProdTimeline*	m_pTimeline;
	CTimeStrip*			m_pTimeStrip;
public:
	CTimeStripMgr()
	{
		m_pTimeline = NULL;
		m_pTimeStrip = NULL;
		m_TimeSig.bBeatsPerMeasure = 4;
		m_TimeSig.bBeat = 4;
		m_TimeSig.wGridsPerBeat = 4;
		m_TimeSig.mtTime = 0;
		m_dblTempo = 120;
		m_fShowTimeSig = TRUE;
	}
	~CTimeStripMgr()
	{
		if( m_pTimeline )
		{
			m_pTimeline->Release();
		}
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TIMESTRIPMGR)

BEGIN_COM_MAP(CTimeStripMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
END_COM_MAP()

// ITimeStripMgr
public:
	STDMETHODIMP GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData);
	STDMETHODIMP SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData);
	STDMETHODIMP IsParamSupported(
		/* [in] */ REFGUID		guidType);
	STDMETHODIMP OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData);
	STDMETHODIMP GetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant);
	STDMETHODIMP SetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY smp,
		/* [in] */ VARIANT		variant);

private:
	DMUS_TIMESIGNATURE	m_TimeSig;
	double				m_dblTempo;
	BOOL				m_fShowTimeSig;
};



typedef enum tagTSRESIZE
{
	TS_NOTRESIZING	= 0,
	TS_START		= TS_NOTRESIZING + 1,
	TS_END			= TS_START + 1
} TSRESIZE;

typedef enum tagTSRTDISPLAY
{
	TS_RT_SECOND	= 0,
	TS_RT_MEASURE	= TS_RT_SECOND + 1,
	TS_RT_BEAT		= TS_RT_MEASURE + 1
} TSRTDISPLAY;

class CTimeStrip : 
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdPropPageObject
{
	friend class CTimelineCtl;
public:
	BOOL			m_fScrollWhenSettingTimeCursor;
	BOOL			m_bDisplayRealTime; // flag to enable display of real time
	int				m_nLastEdit; // ID of string to return when asked for undo text
protected:
	long			m_cRef;
	long			m_lBeginSelect;
	long			m_lEndSelect;
	TSRESIZE		m_tsrResizing;
	HCURSOR			m_hCursor;
	CTimeStripMgr*	m_pTimeStripMgr;
	BOOL			m_fSelecting;
	COLORREF		m_colorTimeTick;
	CBitmapButton	m_BtnRealTime;	// Real Time button
	CBitmapButton	m_BtnMusicTime;	// Music Time button
	BOOL			m_bDisplayMusicTime; // flag to enable display of music time
	TSRTDISPLAY		m_tsdDisplayRealTime; // setting for display of real time
	DMUSPROD_TIMELINE_SNAP_TO m_stSetting;	// Snap to setting
	UINT			m_nScrollTimerID;
	BOOL			m_fLButtonDown;
public:
	CTimeStrip( CTimeStripMgr* pTimeStripMgr )
	{
		ASSERT( pTimeStripMgr );
		m_cRef = 0;
		AddRef();
		m_pTimeStripMgr = pTimeStripMgr;
		m_fSelecting = FALSE;
		m_hCursor = LoadCursor( NULL, IDC_ARROW );
		m_lBeginSelect = -1;
		m_lEndSelect = -1;
		m_tsrResizing = TS_NOTRESIZING;
		m_bDisplayMusicTime = TRUE;
		m_bDisplayRealTime = FALSE;
		m_tsdDisplayRealTime = TS_RT_SECOND;
		m_stSetting = DMUSPROD_TIMELINE_SNAP_GRID;
		m_colorTimeTick = RGB( 0, 0, 0 );
		m_nScrollTimerID = 0;
		m_fLButtonDown = FALSE;
		m_nLastEdit = 0;
		m_fScrollWhenSettingTimeCursor = TRUE;
	};

	~CTimeStrip()
	{
		if( m_nScrollTimerID )
		{
			StopScrollTimer();
		}
	}

// IUnknown
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDMUSProdStrip
public:
	HRESULT	STDMETHODCALLTYPE	Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
    HRESULT STDMETHODCALLTYPE	GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
    HRESULT STDMETHODCALLTYPE	SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE	OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
// IDMUSProdStripFunctionBar
public:
    HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv);
    HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdPropPageObject functions
public:
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

public:
	long SnapAmount( long lTime );
	void SetSnapTo( DMUSPROD_TIMELINE_SNAP_TO stNew );

protected:
	void OnGutterSelect( BOOL fSelect );
	void OnLButtonDown( WPARAM wParam, LONG lXPos );
	void OnMouseMove( LONG lXPos );
	void OnButtonClicked( WPARAM wParam );
	HRESULT OnSize( WPARAM wParam, LPARAM lParam );
	HCURSOR GetWECursor(void);
	HCURSOR GetArrowCursor(void);
	void OnDrawItem( WPARAM wParam, LPARAM lParam );
	void DrawMusicTime( HDC hDC, LONG lXOffset );
	void DrawRealOnSecond( HDC hDC, LONG lXOffset );
	void DrawRealOnBeat( HDC hDC, LONG lXOffset );
	void DrawRealOnMeasure( HDC hDC, LONG lXOffset );
	void SnapTime( long *plTime );
	void UpdateStartEnd( long lNewBegin, long lNewEnd );
	void StartScrollTimer( UINT nScrollTimerID );
	void StopScrollTimer();
	CWnd* GetTimelineCWnd();
	void OnTimer();
};

#endif //__TIMESTRIPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include <StaticPropPageManager.h>

class PropPageTimeSig;

class CTimeSigPropPageMgr : CStaticPropPageManager
{
	friend PropPageTimeSig;
public:
	CTimeSigPropPageMgr(IDMUSProdFramework* pIFramework);
	~CTimeSigPropPageMgr();

	// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
 
	// IDMUSProdPropPageManager methods
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Additional methods
	void UpdateObjectWithTimeSigData();

private:
	IDMUSProdFramework*		m_pIFramework;
	PropPageTimeSig*			m_pPropPageTimeSig;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\GroupBitsPPG.cpp ===
// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "TimeSigStripMgr.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr property page

short CGroupBitsPropPageMgr::sm_nActiveTab = 0;
short* CGroupBitsPPG::sm_pnActiveTab = NULL;

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pGroupBitsPPG = NULL;
	m_pTrackFlagsPPG = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CGroupBitsPropPageMgr::~CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
		m_pGroupBitsPPG = NULL;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT CGroupBitsPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add group bits tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	if( NULL == m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG = new CGroupBitsPPG();
	}
	if( m_pGroupBitsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

IMPLEMENT_DYNCREATE(CGroupBitsPPG, CPropertyPage)

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_PPGTrackParams.dwPageIndex = 0;
	m_PPGTrackParams.dwGroupBits = 0;
	m_fNeedToDetach = FALSE;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	DDX_Control(pDX, IDC_COMBO_GROUP_LIST, m_GroupDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_GROUP_LIST, OnSelchangeComboGroupList)
	ON_MESSAGE( WM_APP, OnApp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if(::IsWindow(m_GroupDropDownList.m_hWnd))
	{
		m_GroupDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CGroupBitsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioGroupBitsPPGData *pioGroupBitsPPGData = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioGroupBitsPPGData ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Group Bits combo box
	if (!m_PPGTrackParams.dwGroupBits)
	{
		m_PPGTrackParams.dwGroupBits = 1;
	}
	for (int iIndex = 0; iIndex < 32; iIndex++)
	{
		if (m_PPGTrackParams.dwGroupBits & (1 << iIndex) )
			break;
	}
	m_GroupDropDownList.SetCurSel(iIndex);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CGroupBitsPPG::OnSelchangeComboGroupList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PostMessage( WM_APP, 0, 0 );
}

LRESULT CGroupBitsPPG::OnApp(WPARAM, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Custom handler for OnSelChanged to work-around bug in user32.dll
	int iIndex = m_GroupDropDownList.GetCurSel();

	if (iIndex >= 0 && iIndex < 32)
	{
		m_PPGTrackParams.dwGroupBits = (1 << iIndex);
	}
	else
	{
		ASSERT(FALSE);
		return 0;
	}

	UpdatePPO();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\PropPageTimeSig.h ===
#if !defined(AFX_PROPPAGETIMESIG_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGETIMESIG_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CTimeSigPropPageMgr;

// PropPageTimeSig.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig dialog
class CTimeSigPropPageMgr;

class PropPageTimeSig : public CPropertyPage
{
	friend CTimeSigPropPageMgr;
	DECLARE_DYNCREATE(PropPageTimeSig)

// Construction
public:
	PropPageTimeSig();
	~PropPageTimeSig();

// Dialog Data
	//{{AFX_DATA(PropPageTimeSig)
	enum { IDD = IDD_TIMESIG_PROPPAGE };
	CStatic	m_InfoStatic;
	CButton	m_btnTimeSignature;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinMeasure;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageTimeSig)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPageTimeSig)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditMeasure();
	afx_msg void OnTimeSignature();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void CopyDataToTimeSig( CPropTimeSig* pTimeSig );
	void GetDataFromTimeSig( CPropTimeSig* pTimeSig );

protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void SetTimeSignatureBitmap( void );
	int  AdjustTime( int nNewValue, int nDelta );
	BOOL HasStyleTrack();

private:
	CPropTimeSig*			m_pTimeSig;
	CTimeSigPropPageMgr*	m_pPropPageMgr;
	IDMUSProdFramework*		m_pIFramework;
	BOOL					m_fHaveData;
	BOOL					m_fMultipleTimeSigsSelected;
	BOOL					m_fNeedToDetach;
	BOOL					m_bHasStyleTrack;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGETIMESIG_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\PropPageTimeSig.cpp ===
// PropPageTimeSig.cpp : implementation file
//

#include "stdafx.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "PropTimeSig.h"
#include "PropPageMgr.h"
#include "PropPageTimeSig.h"
#include "TimeSignatureDlg.h"
#include "TimeSigStripMgr.h"
#include "Timeline.h"
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

UINT g_nGridsPerBeatBitmaps[MAX_GRIDS_PER_BEAT_ENTRIES] =
	{ 
	  IDB_GPB1,     IDB_GPB2,     IDB_GPB3,     IDB_GPB4,     IDB_GPB5,		// Beat = quarter note
	  IDB_GPB6,     IDB_GPB7,     IDB_GPB8,     IDB_GPB9,     IDB_GPBa10,
	  IDB_GPBa11,   IDB_GPBa12,   IDB_GPBa13,   IDB_GPBa14,   IDB_GPBa15,
	  IDB_GPBa16,   IDB_GPBa17,   IDB_GPBa18,   IDB_GPBa19,   IDB_GPBb20,
	  IDB_GPBb21,   IDB_GPBb22,   IDB_GPBb23,   IDB_GPBb24,
	  IDB_GPB1_ALT, IDB_GPB2_ALT, IDB_GPB3_ALT, IDB_GPB4_ALT, IDB_GPB5,		// Beat != quarter note
	  IDB_GPB6_ALT, IDB_GPB7,     IDB_GPB8_ALT, IDB_GPB9,     IDB_GPBa10,
	  IDB_GPBa11,   IDB_GPBa12,   IDB_GPBa13,   IDB_GPBa14,   IDB_GPBa15,
	  IDB_GPBa16,   IDB_GPBa17,   IDB_GPBa18,   IDB_GPBa19,   IDB_GPBb20,
	  IDB_GPBb21,   IDB_GPBb22,   IDB_GPBb23,   IDB_GPBb24
	};

/////////////////////////////////////////////////////////////////////////////
// CTimeSigPropPageMgr constructor/destructor

CTimeSigPropPageMgr::CTimeSigPropPageMgr(IDMUSProdFramework* pIFramework) : CStaticPropPageManager()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();
	m_pPropPageTimeSig = NULL;
//	CStaticPropPageManager::CStaticPropPageManager();
}

CTimeSigPropPageMgr::~CTimeSigPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageTimeSig )
	{
		delete m_pPropPageTimeSig;
		m_pPropPageTimeSig = NULL;
	}
	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigPropPageMgr IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigPropPageMgr::QueryInterface

HRESULT STDMETHODCALLTYPE CTimeSigPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Just call the base class implementation
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


/////////////////////////////////////////////////////////////////////////////
// CTimeSigPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CTimeSigPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	// Get and store the title.
	strTitle.LoadString( IDS_PROPPAGE_TIMESIG );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CTimeSigPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CTimeSigPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add TimeSig tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPageTimeSig)
	{
		m_pPropPageTimeSig = new PropPageTimeSig;
		if( m_pPropPageTimeSig )
		{
			m_pPropPageTimeSig->m_pIFramework = m_pIFramework;
			m_pPropPageTimeSig->m_pIFramework->AddRef();

			m_pPropPageTimeSig->m_pPropPageMgr = this;
		}
	}

	if( m_pPropPageTimeSig )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageTimeSig->m_psp, sizeof(PROPSHEETPAGE) );

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageTimeSig->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CTimeSigPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CTimeSigPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropTimeSig* pTimeSig = NULL;
	HRESULT hr = S_OK;

	if( m_pIPropPageObject == NULL )
	{
		pTimeSig = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pTimeSig ) ) )
	{
		pTimeSig = NULL;
		hr = E_FAIL;
	}

	if( m_pPropPageTimeSig )
	{
		m_pPropPageTimeSig->m_fMultipleTimeSigsSelected = FALSE;
		m_pPropPageTimeSig->m_fHaveData = FALSE;

		if( pTimeSig )
		{
			if( pTimeSig->m_dwMeasure == 0xFFFFFFFF )
			{
				m_pPropPageTimeSig->m_fMultipleTimeSigsSelected = TRUE;
			}
			else
			{
				m_pPropPageTimeSig->m_fHaveData = TRUE;
			}
			m_pPropPageTimeSig->CopyDataToTimeSig( pTimeSig );
		}
		else
		{
			CPropTimeSig TimeSig;
			m_pPropPageTimeSig->CopyDataToTimeSig( &TimeSig );
		}

		m_pPropPageTimeSig->UpdateControls();
	}

	if( pTimeSig )
	{
		delete pTimeSig;
	}

	return hr;
};

void CTimeSigPropPageMgr::UpdateObjectWithTimeSigData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropPageObject != NULL );

	CPropTimeSig TimeSig;

	// Populate the TimeSig structure
	m_pPropPageTimeSig->GetDataFromTimeSig( &TimeSig );
	
	// Send the new data to the PropPageObject
	m_pIPropPageObject->SetData( (void *)&TimeSig );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig property page

IMPLEMENT_DYNCREATE(PropPageTimeSig, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig constructor/destructor

PropPageTimeSig::PropPageTimeSig() : CPropertyPage(PropPageTimeSig::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_TIMESIG_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageTimeSig)
	//}}AFX_DATA_INIT
	m_pIFramework = NULL;

	m_fHaveData = FALSE;
	m_fMultipleTimeSigsSelected = FALSE;
	m_pTimeSig = new CPropTimeSig;
	m_fNeedToDetach = FALSE;
}

PropPageTimeSig::~PropPageTimeSig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
	
	if( m_pTimeSig )
	{
		delete m_pTimeSig;
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig::DoDataExchange

void PropPageTimeSig::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageTimeSig)
	DDX_Control(pDX, IDC_INFO_STATIC, m_InfoStatic);
	DDX_Control(pDX, IDC_TIME_SIGNATURE, m_btnTimeSignature);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageTimeSig, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageTimeSig)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_BN_CLICKED(IDC_TIME_SIGNATURE, OnTimeSignature)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig::UpdateControls

void PropPageTimeSig::UpdateControls()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Controls not created yet
	if( IsWindow( m_hWnd ) == 0 )
	{
		return;
	}

	ASSERT( m_pTimeSig );
	if( m_pTimeSig == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	m_bHasStyleTrack = HasStyleTrack(); 
	CString sInfoString("");
	if(m_bHasStyleTrack == TRUE)
		sInfoString.LoadString(IDS_EDITING_INFO);
	m_InfoStatic.SetWindowText(sInfoString);
	
	
	// Set enable state of controls
	EnableControls( m_fHaveData && !(m_pTimeSig->m_dwBits & UD_STYLEUPDATE) );

	// Measure
	if( (signed)m_pTimeSig->m_dwMeasure != (m_spinMeasure.GetPos() - 1) )
	{
		m_spinMeasure.SetPos( m_pTimeSig->m_dwMeasure + 1 );
	}

	// TimeSig button
	SetTimeSignatureBitmap();
}

BOOL PropPageTimeSig::HasStyleTrack()
{
	BOOL bHasStyleTrack = FALSE;
	IDMUSProdStripMgr *pIStripMgr;
	if( m_pPropPageMgr->m_pIPropPageObject && SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void **)&pIStripMgr ) ) )
	{
		DMUS_IO_TRACK_HEADER ioTrackHeader;
		ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
		VARIANT varTrackHeader;
		varTrackHeader.vt = VT_BYREF;
		V_BYREF(&varTrackHeader) = &ioTrackHeader;
		pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader );

		VARIANT varTimeline;
		if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &varTimeline ) ) )
		{
			IDMUSProdTimeline* pITimelineCtl;
			if( SUCCEEDED( V_UNKNOWN( &varTimeline )->QueryInterface( IID_IDMUSProdTimeline, (void **)&pITimelineCtl ) ) )
			{
				IDMUSProdStripMgr* pIStripMgr = NULL;
				if( SUCCEEDED( pITimelineCtl->GetStripMgr( GUID_IDirectMusicStyle, ioTrackHeader.dwGroup, 0, &pIStripMgr ) ) )
				{
					bHasStyleTrack = TRUE;
					pIStripMgr->Release();
				}
				pITimelineCtl->Release();
			}
			V_UNKNOWN( &varTimeline )->Release();
		}
		pIStripMgr->Release();
	}

	return bHasStyleTrack;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig::OnCreate

int PropPageTimeSig::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig::OnDestroy

void PropPageTimeSig::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Delete the time signature button's bitmap
	HBITMAP hBitmap = m_btnTimeSignature.GetBitmap();
	if( hBitmap )
	{
		::DeleteObject( hBitmap );
	}

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig::OnInitDialog

BOOL PropPageTimeSig::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Update the dialog
	UpdateControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPageTimeSig, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageTimeSig)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPageTimeSig::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fHaveData )
	{
		CString strNewMeasure;

		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillfocusEditMeasure();

		m_editMeasure.GetWindowText( strNewMeasure );

		// Strip leading and trailing spaces
		strNewMeasure.TrimRight();
		strNewMeasure.TrimLeft();

		if( !strNewMeasure.IsEmpty() )
		{
			m_pTimeSig->m_dwMeasure = max( _ttoi( strNewMeasure ) - 1, 0 );
		}

		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nNewValue = m_pTimeSig->m_dwMeasure + pNMUpDown->iDelta;
		int nDelta = pNMUpDown->iDelta;
		if( nNewValue < 0 )
		{
			nNewValue = 0;
			nDelta = -(signed(m_pTimeSig->m_dwMeasure));
		}
		else if( nNewValue > 32766 )
		{
			nNewValue = 32766;
			nDelta = 32766 - m_pTimeSig->m_dwMeasure;
		}

		if( (DWORD)nNewValue != m_pTimeSig->m_dwMeasure )
		{
			nNewValue = AdjustTime( nNewValue, nDelta );

			if( (DWORD)nNewValue != m_pTimeSig->m_dwMeasure )
			{
				m_pTimeSig->m_dwMeasure = nNewValue;
				m_spinMeasure.SetPos( nNewValue + 1 );
				m_pPropPageMgr->UpdateObjectWithTimeSigData();
			}
		}
	}

	// We handled this message - don't change the numbers further
	*pResult = 1;
}


void PropPageTimeSig::OnKillfocusEditMeasure() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewMeasure;

	m_editMeasure.GetWindowText( strNewMeasure );

	// Strip leading and trailing spaces
	strNewMeasure.TrimRight();
	strNewMeasure.TrimLeft();

	if( strNewMeasure.IsEmpty() )
	{
		m_spinMeasure.SetPos( m_pTimeSig->m_dwMeasure + 1 );
	}
	else
	{
		// Get maximum number of measures
		long lMaxMeasure = 32767;
		VARIANT var;
		IDMUSProdStripMgr *pIStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void **)&pIStripMgr ) ) )
		{
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
			VARIANT varTrackHeader;
			varTrackHeader.vt = VT_BYREF;
			V_BYREF(&varTrackHeader) = &ioTrackHeader;
			pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader );

			VARIANT varTimeline;
			if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &varTimeline ) ) )
			{
				IDMUSProdTimeline *pITimelineCtl;
				if( SUCCEEDED( V_UNKNOWN( &varTimeline )->QueryInterface( IID_IDMUSProdTimeline, (void **)&pITimelineCtl ) ) )
				{
					pITimelineCtl->GetTimelineProperty( TP_CLOCKLENGTH, &var );
					pITimelineCtl->ClocksToMeasureBeat( ioTrackHeader.dwGroup,
														0,
														V_I4( &var ),
														&lMaxMeasure,
														NULL );
					pITimelineCtl->Release();
				}
				V_UNKNOWN( &varTimeline )->Release();
			}
			pIStripMgr->Release();
		}

		// Ensure lMaxMeasure is at least 1
		lMaxMeasure = max( 1, lMaxMeasure );

		int iNewMeasure = _ttoi( strNewMeasure );
		if( iNewMeasure > lMaxMeasure )
		{
			iNewMeasure = lMaxMeasure;
		}
		else if( iNewMeasure < 1 )
		{
			iNewMeasure = 1;
		}

		m_spinMeasure.SetPos( iNewMeasure );
		
		iNewMeasure--;
		if( (DWORD)iNewMeasure != m_pTimeSig->m_dwMeasure )
		{
			m_pTimeSig->m_dwMeasure = iNewMeasure;
			m_pPropPageMgr->UpdateObjectWithTimeSigData();
		}
	}
}

BOOL PropPageTimeSig::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return CPropertyPage::OnSetActive();
}

void PropPageTimeSig::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_editMeasure.GetSafeHwnd() == NULL )
	{
		return;
	}

	m_spinMeasure.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_btnTimeSignature.EnableWindow( fEnable );
}

void PropPageTimeSig::CopyDataToTimeSig( CPropTimeSig* pTimeSig )
{
	ASSERT( pTimeSig != NULL );

	m_pTimeSig->m_dwMeasure		= pTimeSig->m_dwMeasure;
	m_pTimeSig->m_dwBits		= pTimeSig->m_dwBits;
	m_pTimeSig->m_TimeSignature = pTimeSig->m_TimeSignature;
}


void PropPageTimeSig::GetDataFromTimeSig( CPropTimeSig* pTimeSig )
{
	ASSERT( pTimeSig != NULL );

	pTimeSig->m_dwMeasure		= m_pTimeSig->m_dwMeasure;
	pTimeSig->m_dwBits			= m_pTimeSig->m_dwBits;
	pTimeSig->m_TimeSignature	= m_pTimeSig->m_TimeSignature;

}

BOOL PropPageTimeSig::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fHaveData )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_MEASURE: 
								m_spinMeasure.SetPos( m_pTimeSig->m_dwMeasure + 1 );
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig::OnTimeSignature

void PropPageTimeSig::OnTimeSignature() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTimeSig )
	{
		CTimeSignatureDlg tsDlg;

		tsDlg.m_TimeSignature = m_pTimeSig->m_TimeSignature;

		if( tsDlg.DoModal() == IDOK )
		{
			// Update time signature
			m_pTimeSig->m_TimeSignature = tsDlg.m_TimeSignature;
			m_pPropPageMgr->UpdateObjectWithTimeSigData();

			// Update bitmap on time signature button
			SetTimeSignatureBitmap();
		}

		m_btnTimeSignature.SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig::SetTimeSignatureBitmap

void PropPageTimeSig::SetTimeSignatureBitmap( void )
{
	HBITMAP hNewBits = NULL;

	ASSERT( m_pTimeSig != NULL );

	RECT rect;
	m_btnTimeSignature.GetClientRect( &rect );

	// Create a DC for the new bitmap
	// a DC for the 'Grids Per Beat' bitmap
	// a Bitmap for the new bits
	CDC cdcDest;
	CDC cdcGridsPerBeat;
	CBitmap bmpNewBits;
	CBitmap bmpGridsPerBeat;

	CDC* pDC = m_btnTimeSignature.GetDC();
	if( pDC )
	{

		if( cdcDest.CreateCompatibleDC( pDC ) == FALSE
		||  cdcGridsPerBeat.CreateCompatibleDC( pDC ) == FALSE
		||  bmpNewBits.CreateCompatibleBitmap( pDC, rect.right, rect.bottom ) == FALSE )
		{
			m_btnTimeSignature.ReleaseDC( pDC );
			return;
		}

		m_btnTimeSignature.ReleaseDC( pDC );
	}

	// Create the new bitmap
	CBitmap* pbmpOldMem = cdcDest.SelectObject( &bmpNewBits );

	// Fill Rect with button color
	if(m_btnTimeSignature.IsWindowEnabled())
		cdcDest.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );

	cdcDest.ExtTextOut( 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);

	if(m_btnTimeSignature.IsWindowEnabled() )
	{
		// Write text
		CString strTimeSignature;

		CFont font;
		CFont* pfontOld = NULL;
		
		if( font.CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 							DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
							DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
		{
			pfontOld = cdcDest.SelectObject( &font );
		}

		strTimeSignature.Format( "%d/%d",
								 m_pTimeSig->m_TimeSignature.bBeatsPerMeasure,
								 m_pTimeSig->m_TimeSignature.bBeat );
		rect.left += 6;
		cdcDest.SetTextColor( COLOR_BTNTEXT );
		cdcDest.DrawText( strTimeSignature, -1, &rect, (DT_SINGLELINE | DT_LEFT | DT_VCENTER) );
		rect.left -= 6;

		if( pfontOld )
		{
			cdcDest.SelectObject( pfontOld );
			font.DeleteObject();
		}

		// Set x coord for 'Grids Per Beat' image
		CSize sizeText = cdcDest.GetTextExtent( strTimeSignature );
		int nX = max( 48, (sizeText.cx + 8) );

		// Draw "splitter"
		{
			CPen pen1;
			CPen pen2;
			CPen* ppenOld;

			int nPlace = nX - 6;
			int nModeOld = cdcDest.SetROP2( R2_COPYPEN );

			// Highlight
			if( pen1.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) ) )
			{
				ppenOld = cdcDest.SelectObject( &pen1 );
				cdcDest.MoveTo( nPlace, (rect.top + 3) );
				cdcDest.LineTo( nPlace, (rect.bottom - 3) );
				cdcDest.SelectObject( ppenOld );
			}

			// Shadow
			if( pen2.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT) ) )
			{
				ppenOld = cdcDest.SelectObject( &pen2 );
				cdcDest.MoveTo( ++nPlace, (rect.top + 3) );
				cdcDest.LineTo( nPlace, (rect.bottom - 3) );
				cdcDest.SelectObject( ppenOld );
			}

			if( nModeOld )
			{
				cdcDest.SetROP2( nModeOld );
			}
		}

		// Add 'Grids Per Beat' bitmap
		{
			int nResourceID = m_pTimeSig->m_TimeSignature.wGridsPerBeat - 1;
			if( m_pTimeSig->m_TimeSignature.bBeat != 4 )		// 4 = quarter note gets the beat
			{
				nResourceID += MAX_GRIDS_PER_BEAT;
			}
			ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) );

			if( bmpGridsPerBeat.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
			{
				BITMAP bm;

				bmpGridsPerBeat.GetBitmap( &bm );

				int nY = ((rect.bottom - rect.top) - bm.bmHeight) >> 1;

				CBitmap* pbmpOld = cdcGridsPerBeat.SelectObject( &bmpGridsPerBeat );

				{
					CDC cdcMono;
					CBitmap bmpMono;

					if(cdcMono.CreateCompatibleDC( &cdcDest )
					&&  bmpMono.CreateBitmap( bm.bmWidth, bm.bmHeight, 1, 1, NULL ) )
					{
						CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpMono );
						
						cdcGridsPerBeat.SetBkColor( RGB(255,255,255) );
						cdcDest.SetBkColor( RGB(255,255,255) );

						cdcMono.BitBlt( 0, 0, bm.bmWidth, bm.bmHeight,
										&cdcGridsPerBeat, 0, 0, SRCCOPY);
						cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
										&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;
						cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
										&cdcMono, 0, 0, SRCAND ) ;
						cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
										&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;

						cdcMono.SelectObject( pbmpOldMono ) ;
					}
				}

				cdcGridsPerBeat.SelectObject( pbmpOld );
			}
		}
	}

	cdcDest.SelectObject( pbmpOldMem );

	// Set the new bitmap
	hNewBits = (HBITMAP)bmpNewBits.Detach();
	if( hNewBits )
	{
		HBITMAP hBitmapOld = m_btnTimeSignature.SetBitmap( hNewBits );
		if( hBitmapOld )
		{
			::DeleteObject( hBitmapOld );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTimeSig::AdjustTime

int PropPageTimeSig::AdjustTime( int nNewValue, int nDelta )
{
	ITimeSigMgr *pITimeSigMgr;

	if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_ITimeSigMgr, (void**) &pITimeSigMgr ) ) )
	{
		// Save the original value
		const int nOrigValue = nNewValue - nDelta;

		while( TRUE )
		{
			HRESULT hr = pITimeSigMgr->IsMeasureOpen( nNewValue );
			if( FAILED(hr) )
			{
				// The measure is off the end of the segment - there are no open measures
				// after nNewValue.  Check between nOrigvalue and nNewValue
				ASSERT( nDelta > 0 );
				for( int i = nOrigValue + nDelta - 1; i > nOrigValue; i-- )
				{
					if( pITimeSigMgr->IsMeasureOpen( i ) == S_OK )
					{
						break;
					}
				}

				// If we found an open measure, i will point to it.
				// If we didn't find an open measure, i will be nOrigValue
				nNewValue = i;
				break;
			}
			else
			{
				if( hr == S_OK )
				{
					break;
				}
				else
				{
					nNewValue += nDelta > 0 ? 1 : -1;
					if( nNewValue < 0 )
					{
						// The measure is before the start of the segment - there are no open measures
						// before nNewValue.  Check between nOrigvalue and nNewValue
						ASSERT( nDelta < 0 );
						for( int i = nOrigValue - 1; i > nOrigValue + nDelta; i-- )
						{
							if( pITimeSigMgr->IsMeasureOpen( i ) == S_OK )
							{
								nNewValue = i;
								break;
							}
						}
						nNewValue = nOrigValue;
						break;
					}
				}
			}
		}
		pITimeSigMgr->Release();

		return nNewValue;
	}
	else
	{
		return nNewValue;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\GroupBitsPPG.h ===
#if !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "resource.h"

typedef struct 
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
} ioGroupBitsPPGData;

// GroupBitsPPG.h : header file
//

#define ALLEXTRAS_FLAGS (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | \
	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_COMPOSE | \
	DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | \
	DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr

class CGroupBitsPropPageMgr : CStaticPropPageManager
{
public:
	CGroupBitsPropPageMgr();
	~CGroupBitsPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	class CGroupBitsPPG*	m_pGroupBitsPPG;
	class CTrackFlagsPPG*	m_pTrackFlagsPPG;

public:
	static short			sm_nActiveTab;
};

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG dialog

class CGroupBitsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CGroupBitsPPG)

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_TIMESIG_GROUP };
	CComboBox	m_GroupDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboGroupList();
	afx_msg LRESULT OnApp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioGroupBitsPPGData			m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\PropTimeSig.h ===
#ifndef __PROPTIMESIG_H_
#define __PROPTIMESIG_H_

#include <DMUSProd.h>
#include <dmusici.h>

class CTimeSigItem;

class CPropTimeSig 
{
public:
	CPropTimeSig();
	CPropTimeSig( const CTimeSigItem *pTimeSigItem );
	~CPropTimeSig();
	const TCHAR *GetString();

    DWORD				m_dwMeasure;		// What measure this Time Signature falls on
	DWORD				m_dwBits;			// Various bits
	DMUS_TIMESIGNATURE	m_TimeSignature;	// Time Signature
	TCHAR				m_tcsText[20];		// Textual representation of the Time Signature
};

#define UD_DRAGSELECT		0x0001
#define UD_FAKE				0x0004
#define UD_STYLEUPDATE		0x0008

#endif // __PROPTIMESIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\PropTimeSig.cpp ===
#include "stdafx.h"
#include "PropTimeSig.h"
#include "TimeSigIO.h"

CPropTimeSig::CPropTimeSig()
{
	m_dwMeasure = 0;
	m_dwBits = 0;

	m_TimeSignature.mtTime = 0;
	m_TimeSignature.bBeatsPerMeasure = 4;
	m_TimeSignature.bBeat = 4;
	m_TimeSignature.wGridsPerBeat = 4;
}

CPropTimeSig::CPropTimeSig(const CTimeSigItem *pTimeSigItem)
{
	ASSERT( pTimeSigItem != NULL );

	m_dwMeasure = pTimeSigItem->m_dwMeasure;
	m_dwBits = pTimeSigItem->m_dwBits;

	m_TimeSignature.bBeatsPerMeasure = pTimeSigItem->m_TimeSignature.bBeatsPerMeasure;
	m_TimeSignature.bBeat = pTimeSigItem->m_TimeSignature.bBeat;
	m_TimeSignature.wGridsPerBeat = pTimeSigItem->m_TimeSignature.wGridsPerBeat;
}

CPropTimeSig::~CPropTimeSig( ) 
{ 
}

const TCHAR *CPropTimeSig::GetString()
{
	if( m_dwBits & UD_FAKE )
	{
		return _T("");
	}

	TCHAR tcsTmp2[10];

	_itot( m_TimeSignature.bBeatsPerMeasure, m_tcsText, 10 );

	_tcscpy( tcsTmp2, _T(" / ") );
	_tcscat( m_tcsText, tcsTmp2 );

	_itot( m_TimeSignature.bBeat, tcsTmp2, 10 );
	_tcscat( m_tcsText, tcsTmp2 );

	return m_tcsText;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TimeSigStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_TIMESIG            101
#define IDR_TIMESIGMGR                  102
#define IDS_DELETE                      102
#define IDS_PASTE                       103
#define IDS_INSERT                      104
#define IDD_TIMESIG_PROPPAGE            105
#define IDS_TRACK_NAME                  105
#define IDS_EDITOR_NAME                 106
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDS_MULTIPLE_SELECT             110
#define IDS_CHANGE                      111
#define IDS_TRACK_GROUP                 112
#define IDS_UNDO_MOVE                   113
#define IDS_FUNCTIONBAR_NAME            114
#define IDS_EDITING_INFO                115
#define IDI_TIMESIGTRUCK                210
#define IDD_PROPPAGE_TIMESIG_GROUP      216
#define IDC_CHECK_GROUP1                223
#define IDC_EDIT_MEASURE                224
#define IDC_CHECK_GROUP2                224
#define IDC_CHECK_GROUP3                225
#define IDC_CHECK_GROUP4                226
#define IDC_CHECK_GROUP5                227
#define IDC_CHECK_GROUP6                228
#define IDC_SPIN_MEASURE                229
#define IDC_CHECK_GROUP7                229
#define IDC_CHECK_GROUP8                230
#define IDC_CHECK_GROUP9                231
#define IDC_COMBO_GROUP_LIST            231
#define IDC_CHECK_GROUP10               232
#define IDC_COMBO_STYLES                232
#define IDC_CHECK_GROUP11               233
#define IDC_INFO_STATIC                 233
#define IDC_CHECK_GROUP12               234
#define IDD_TIME_SIGNATURE              234
#define IDC_CHECK_GROUP13               235
#define IDC_CHECK_GROUP14               236
#define IDC_CHECK_GROUP15               237
#define IDC_BEAT                        237
#define IDC_CHECK_GROUP16               238
#define IDC_GRID                        238
#define IDC_TIME_SIGNATURE              238
#define IDC_CHECK_GROUP17               239
#define IDC_BPM                         239
#define IDC_CHECK_GROUP18               240
#define IDC_BPM_SPIN                    240
#define IDC_CHECK_GROUP19               241
#define IDC_CHECK_GROUP20               242
#define IDM_DRAG_RMENU                  243
#define IDC_CHECK_GROUP21               243
#define IDC_CHECK_GROUP22               244
#define IDC_CHECK_GROUP23               245
#define IDC_CHECK_GROUP24               246
#define IDC_CHECK_GROUP25               247
#define IDC_CHECK_GROUP26               248
#define IDC_CHECK_GROUP27               249
#define IDC_CHECK_GROUP28               250
#define IDC_CHECK_GROUP29               251
#define IDC_CHECK_GROUP30               252
#define IDC_CHECK_GROUP31               253
#define IDC_CHECK_GROUP32               254
#define IDB_GPB1                        501
#define IDB_GPB2                        502
#define IDB_GPB3                        503
#define IDB_GPB4                        504
#define IDB_GPB5                        505
#define IDB_GPB6                        506
#define IDB_GPB7                        507
#define IDB_GPB8                        508
#define IDB_GPB9                        509
#define IDB_GPBa10                      510
#define IDB_GPBa11                      511
#define IDB_GPBa12                      512
#define IDB_GPBa13                      513
#define IDB_GPBa14                      514
#define IDB_GPBa15                      515
#define IDB_GPBa16                      516
#define IDB_GPBa17                      517
#define IDB_GPBa18                      518
#define IDB_GPBa19                      519
#define IDB_GPBb20                      520
#define IDB_GPBb21                      521
#define IDB_GPBb22                      522
#define IDB_GPBb23                      523
#define IDB_GPBb24                      524
#define IDB_GPB1_ALT                    527
#define IDB_GPB2_ALT                    528
#define IDB_GPB3_ALT                    529
#define IDB_GPB4_ALT                    530
#define IDB_GPB6_ALT                    531
#define IDB_GPB8_ALT                    532
#define IDS_BEAT1                       4050
#define IDS_BEAT2                       4051
#define IDS_BEAT3                       4052
#define IDS_BEAT4                       4053
#define IDS_BEAT5                       4054
#define IDS_BEAT6                       4055
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define IDS_ERR_MIN_MAX                 57662
#define IDS_ERR_BEAT                    57664
#define IDS_ERR_GRIDS_PER_BEAT          57665
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        214
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         234
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\TimeSigIO.cpp ===
#include "stdafx.h"
#include "TimeSigIO.h"
#include "TimeSigStripMgr.h"
#include "TimeSigMgr.h"


CTimeSigItem::CTimeSigItem( CTimeSigMgr* pTimeSigMgr )
{
	ASSERT( pTimeSigMgr != NULL );
	m_pTimeSigMgr = pTimeSigMgr;

	m_fSelected = FALSE;
	m_fRemoveNotify = FALSE;
}

CTimeSigItem::~CTimeSigItem()
{
}

BOOL CTimeSigItem::After(const CTimeSigItem& TimeSig)
{
	if( m_dwMeasure > TimeSig.m_dwMeasure )
	{
		return TRUE;
	}
	/*
	else if( m_dwMeasure == TimeSig.m_dwMeasure )
	{
	}
	*/
	return FALSE;
}

BOOL CTimeSigItem::Before(const CTimeSigItem& TimeSig)
{
	if( m_dwMeasure < TimeSig.m_dwMeasure )
	{
		return TRUE;
	}
	/*
	else if( m_dwMeasure == TimeSig.m_dwMeasure )
	{
	}
	*/
	return FALSE;
}
	
void CTimeSigItem::SetSelectFlag( BOOL fSelected )
{
	m_fSelected = fSelected;
	m_dwBits &= ~(UD_DRAGSELECT);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\TimeSigIO.h ===
#ifndef __TIMESIGIO_H_
#define __TIMESIGIO_H_

#include "PropTimeSig.h"
#include <dmusici.h>

class CTimeSigMgr;

class CTimeSigItem : public CPropTimeSig
{
public:
	CTimeSigItem( CTimeSigMgr* pTimeSigMgr );
	~CTimeSigItem();

	BOOL After(const CTimeSigItem& TimeSig);
	BOOL Before(const CTimeSigItem& TimeSig);
	void SetSelectFlag( BOOL fSelected );

	CTimeSigMgr*	m_pTimeSigMgr;

//	Used to track the selection of the style reference in display.
	BOOL		 m_fSelected;		// This style reference is currently selected.
	BOOL		 m_fRemoveNotify;
};

#endif // __TIMESIGIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\TimeSigMgr.cpp ===
// TimeSigMgr.cpp : implementation file
//

/*--------------
@doc TIMESIGSAMPLE
--------------*/

#include "stdafx.h"
#include "TimeSigIO.h"
#include "TimeSigStripMgr.h"
#include "TimeSigMgr.h"
#include "DLLJazzDataObject.h"
#include "PropPageMgr.h"
#include <dmusici.h>
#include <dmusicf.h>
#include <mmreg.h>
#include <RiffStrm.h>
#include <initguid.h>
#include <SegmentGuids.h>
#include "SegmentIO.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define INVALID_MEASURE 0xFFFFFFFF

inline MUSIC_TIME ClocksPerBeat(DMUS_TIMESIGNATURE& TimeSig)
{ return DMUS_PPQ * 4 / TimeSig.bBeat; }

inline MUSIC_TIME ClocksPerMeasure(DMUS_TIMESIGNATURE& TimeSig)
{ return ClocksPerBeat(TimeSig) * TimeSig.bBeatsPerMeasure; }

inline DWORD ClocksToMeasure(DWORD dwTotalClocks, DMUS_TIMESIGNATURE& TimeSig)
{ return (dwTotalClocks / ClocksPerMeasure(TimeSig)); }

POSITION GetFirstValidTimeSig(POSITION pos, const CTypedPtrList<CPtrList, CTimeSigItem*> &lstTimeSigs )
{
	while( pos )
	{
		POSITION posToReturn = pos;
		if( !(lstTimeSigs.GetNext( pos )->m_dwBits & UD_FAKE) )
		{
			return posToReturn;
		}
	}
	return NULL;
}

void CTimeSigMgr::ClocksToMeasure(MUSIC_TIME mtTime, DWORD& rdwMeasure)
{
	//ASSERT( mtTime >= 0 );
	if( mtTime <= 0 )
	{
		rdwMeasure = 0;
		return;
	}

	DMUS_TIMESIGNATURE TimeSignature;

	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	pos = GetFirstValidTimeSig( pos, m_lstTimeSigs );
	if( !pos )
	{
		// Default to 4/4, since this is what the Timeline defaults to
		TimeSignature.bBeatsPerMeasure = 4;
		TimeSignature.bBeat = 4;
		rdwMeasure = ::ClocksToMeasure(mtTime, TimeSignature);
		return;
	}

	CTimeSigItem* pTimeSigItem = NULL;
	MUSIC_TIME mtSRTime = 0;
	DWORD dwCurrentMeasure = 0;

	// Initialize TimeSignature with the TimeSig of the first valid item
	pTimeSigItem = m_lstTimeSigs.GetAt( pos );
	TimeSignature = pTimeSigItem->m_TimeSignature;

	while( pos )
	{
		pTimeSigItem = m_lstTimeSigs.GetNext( pos );

		// This should be a real TimeSig
		ASSERT( !(pTimeSigItem->m_dwBits & UD_FAKE) );

		MUSIC_TIME mtMeasureClocks = ClocksPerMeasure(TimeSignature);
		long lNumMeasures = pTimeSigItem->m_dwMeasure - dwCurrentMeasure;
		if (mtSRTime + mtMeasureClocks * lNumMeasures > mtTime)
		{
			break;
		}

		mtSRTime += mtMeasureClocks * lNumMeasures;
		dwCurrentMeasure = pTimeSigItem->m_dwMeasure;
		TimeSignature = pTimeSigItem->m_TimeSignature;

		// Get the next valid TimeSig
		pos = GetFirstValidTimeSig( pos, m_lstTimeSigs );
	}

	mtTime -= mtSRTime;
	rdwMeasure = dwCurrentMeasure + ::ClocksToMeasure(mtTime, TimeSignature);
}

MUSIC_TIME CTimeSigMgr::MeasureToClocks(DWORD dwMeasure)
{ 
	DMUS_TIMESIGNATURE TimeSignature;

	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	pos = GetFirstValidTimeSig( pos, m_lstTimeSigs );
	if( !pos )
	{
		// Default to 4/4, since this is what the Timeline defaults to
		TimeSignature.bBeatsPerMeasure = 4;
		TimeSignature.bBeat = 4;
		return ClocksPerMeasure(TimeSignature) * (MUSIC_TIME) dwMeasure; 
	}

	CTimeSigItem* pTimeSigItem = NULL;
	MUSIC_TIME mtSRTime = 0;
	DWORD dwCurrentMeasure = 0;

	// Initialize TimeSignature with the TimeSig of the first valid item
	TimeSignature = m_lstTimeSigs.GetAt( pos )->m_TimeSignature;

	while( pos )
	{
		pTimeSigItem = m_lstTimeSigs.GetNext( pos );

		// This should be a real TimeSig
		ASSERT( !(pTimeSigItem->m_dwBits & UD_FAKE) );

		// JHD: This is >= (not >) because dwMeasure is 1-based, while
		// m_dwMeasure is 0-based
		if( pTimeSigItem->m_dwMeasure >= dwMeasure)
		{
			break;
		}

		mtSRTime += ClocksPerMeasure(TimeSignature) * 
			(MUSIC_TIME) (pTimeSigItem->m_dwMeasure - dwCurrentMeasure);
		dwCurrentMeasure = pTimeSigItem->m_dwMeasure;
		TimeSignature = pTimeSigItem->m_TimeSignature;

		// Get the next valid TimeSig
		pos = GetFirstValidTimeSig( pos, m_lstTimeSigs );
	}
	return 
		mtSRTime + 
		ClocksPerMeasure(TimeSignature) * (MUSIC_TIME) (dwMeasure - dwCurrentMeasure);
}

////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr constructor/destructor 

CTimeSigMgr::CTimeSigMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pPropertyPage = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pTimeSigStrip = NULL;
	m_pIDMTrack = NULL;
	m_pISegmentNode = NULL;
	m_fHaveStyleRefStrip = FALSE;

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// By default, belong to Group 1
	m_dwGroupBits = 1;

	// Initialize the track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;

	// Create a strip
	m_pTimeSigStrip = new CTimeSigStrip(this);
	ASSERT( m_pTimeSigStrip );
}

CTimeSigMgr::~CTimeSigMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Delete all the TimeSigs in m_lstTimeSigs
	EmptyTimeSigList();

	// Clean up our references
	if( m_pTimeSigStrip )
	{
		m_pTimeSigStrip->Release();
		m_pTimeSigStrip = NULL;
	}

	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	ASSERT( m_pTimeline == NULL );
	ASSERT( m_pPropertyPage == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
	}
	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr ITimeSigMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::IsMeasureOpen

// Return: S_OK - Yes.  S_FALSE - No

HRESULT STDMETHODCALLTYPE CTimeSigMgr::IsMeasureOpen( DWORD dwMeasure )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get maximum number of measures
	long lMaxMeasure;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits,
									  0,
									   V_I4( &var ),
									  &lMaxMeasure,
									  NULL );
	// Ensure lMaxMeasure is at least 1
	lMaxMeasure = max( 1, lMaxMeasure );

	if( dwMeasure >= (unsigned)lMaxMeasure )
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );
		if( pTimeSigItem->m_dwMeasure > dwMeasure )
		{
			pos = NULL;
		}
		else if( (pTimeSigItem->m_dwMeasure == dwMeasure) && !(pTimeSigItem->m_dwBits & UD_FAKE) )
		{
			hr = S_FALSE;
			pos = NULL;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::GetParam

HRESULT STDMETHODCALLTYPE CTimeSigMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( !m_fHaveStyleRefStrip && (guidType == GUID_TimeSignature) )
	{
		// Initialize pmtNext
		if( pmtNext )
		{
			*pmtNext = 0;
		}

		// Search through TimeSig list for first valid time signature
		POSITION pos = m_lstTimeSigs.GetHeadPosition();
		pos = GetFirstValidTimeSig( pos, m_lstTimeSigs );

		if( !pos )
		{
			// No valid TimeSigs in this track.
			return DMUS_E_NOT_FOUND;
		}

		// Initialize Previous time signature
		CTimeSigItem* pPrevious = m_lstTimeSigs.GetAt( pos );

		MUSIC_TIME mtSRTime = 0;
		DWORD dwCurrentMeasure = 0;

		while( pos )
		{
			CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );

			// This should be a real TimeSig
			ASSERT( !(pTimeSigItem->m_dwBits & UD_FAKE) );

			// Get the length of time between the previous time sig and this one
			long lSpan = ClocksPerMeasure(pPrevious->m_TimeSignature) * 
					(MUSIC_TIME) (pTimeSigItem->m_dwMeasure - dwCurrentMeasure);

			// If this time sig is beyond the requested time, break out of the loop
			if( mtSRTime + lSpan > mtTime )
			{
				// Set next
				if( pmtNext )
				{
					*pmtNext = mtSRTime + lSpan - mtTime;
				}
				break;
			}

			mtSRTime += lSpan;
			dwCurrentMeasure = pTimeSigItem->m_dwMeasure;
			pPrevious = pTimeSigItem;

			// Get the next valid Time Signature
			pos = GetFirstValidTimeSig( pos, m_lstTimeSigs );
		}

		// We should have found a valid TimeSig
		ASSERT( pPrevious );

		// Return the TimeSig we found
		DMUS_TIMESIGNATURE* pTS = (DMUS_TIMESIGNATURE*) pData;
		*pTS = pPrevious->m_TimeSignature;
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode** ppIDocRootNode = (IDMUSProdNode **)pData;

		*ppIDocRootNode = m_pISegmentNode;
		if( m_pISegmentNode )
		{
			m_pISegmentNode->AddRef();
		}
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pTimeSigStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::SetParam

HRESULT STDMETHODCALLTYPE CTimeSigMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);

	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode* pIDocRootNode = (IDMUSProdNode *)pData;

		m_pISegmentNode = pIDocRootNode;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::IsParamSupported

// support GUID_TimeSignature for maintaining the time signature
// support GUID_DocRootNode for maintaining pointer to DocRoot node
HRESULT STDMETHODCALLTYPE CTimeSigMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (!m_fHaveStyleRefStrip && ::IsEqualGUID( guidType, GUID_TimeSignature ))
	||  ::IsEqualGUID( guidType, GUID_DocRootNode )
	||  ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CTimeSigMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsEqualGUID( GUID_IDirectMusicStyle, rguidType) ||
		::IsEqualGUID( GUID_TimeSignature, rguidType) ||
		::IsEqualGUID( GUID_Segment_AllTracksAdded, rguidType) )
	{
		UpdateHaveStyleFlag();
		return S_OK;
	}

	// Track deleted
	if( ::IsEqualGUID( rguidType, GUID_Segment_DeletedTrack ) )
	{
		// Notify other StripMgrs that the time signature may have changed
		IDMUSProdTimeline *pTimeline = (IDMUSProdTimeline *)pData;
		if( pTimeline )
		{
			pTimeline->NotifyStripMgrs( GUID_TimeSignature, dwGroupBits, NULL );
		}
		return S_OK;
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTimeSigMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicTimeSigTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = NULL;
			pioTrackHeader->fccType = DMUS_FOURCC_TIMESIGTRACK_LIST;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTimeSigMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			m_pTimeline->RemoveFromNotifyList( this, GUID_TimeSignature, m_dwGroupBits );
			m_pTimeline->RemoveFromNotifyList( this, GUID_IDirectMusicStyle, m_dwGroupBits );
			m_pTimeline->RemoveFromNotifyList( this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
			if ( m_pTimeSigStrip )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pTimeSigStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pTimeSigStrip );
			}
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pTimeSigStrip, CLSID_DirectMusicTimeSigTrack, m_dwGroupBits, 0 );
				m_pTimeline->AddToNotifyList( this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( this, GUID_IDirectMusicStyle, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( this, GUID_TimeSignature, m_dwGroupBits );
				UpdateHaveStyleFlag();
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::GetClassID

HRESULT CTimeSigMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &CLSID_TimeSigMgr, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::IsDirty

HRESULT CTimeSigMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::Load

HRESULT CTimeSigMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing time signatures
	EmptyTimeSigList();

	// Load the Track
	MMCKINFO ck;
	MMCKINFO ckList;
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_TIMESIGNATURE_TRACK: // TimeSig Chunk
				LoadTimeSigChunk( pIStream, ck.cksize, FALSE, 0 );
				hr = S_OK;
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_TIMESIGTRACK_LIST:
				        ckList.ckid = 0;
						ckList.fccType = 0;
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{				
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_TIMESIG_CHUNK :
									LoadTimeSigChunk( pIStream, ckList.cksize, FALSE, 0 );
									hr = S_OK;
									break;
							}    

							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

	pIRiffStream->Release();

	SyncWithDirectMusic();

	return hr;
}


HRESULT CTimeSigMgr::LoadTimeSigChunk( IStream* pIStream,
										long lSize,
										BOOL fPaste,
										MUSIC_TIME mtPasteTime )
{
	BOOL fChanged = FALSE;

	// Validate pIStream
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// Read in the size of the TimeSig structure
	DWORD cb, dwTimeSigSize;
	HRESULT hr = pIStream->Read( &dwTimeSigSize, sizeof( DWORD ), &cb );
	if( FAILED(hr) || cb != sizeof( DWORD ) )
	{
		if (SUCCEEDED(hr)) hr = E_FAIL;
		goto ON_END;
	}

	// Subtract off the four bytes we just read
	lSize -= sizeof(DWORD);

	// Compute how many bytes (if any) we'll need to skip
	ASSERT( dwTimeSigSize >= sizeof(DMUS_IO_TIMESIGNATURE_ITEM) );
	DWORD dwSkipBytes;
	dwSkipBytes = 0;
	if( dwTimeSigSize > sizeof(DMUS_IO_TIMESIGNATURE_ITEM) )
	{
		dwSkipBytes = dwTimeSigSize - sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
	}

	// Ensure that the chunk size is an even number of TimeSig items
	ASSERT( (lSize % dwTimeSigSize) == 0 );

	if( fPaste )
	{
		DWORD dwCurrentFilePos = StreamTell( pIStream );
		long lTmpSize = lSize;

		MUSIC_TIME mtAdjustment = 0;;

		ASSERT( m_pTimeline != NULL );
		if( m_pTimeline )
		{
			// Get Timeline length
			VARIANT var;
			m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
			MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

			// Determine new paste time to enforce boundaries
			while ( lTmpSize >= (signed)dwTimeSigSize )
			{
				// Read in a TimeSignature item
				DMUS_IO_TIMESIGNATURE_ITEM iTimeSigItem;
				DWORD cb;
				hr = pIStream->Read( &iTimeSigItem, sizeof( DMUS_IO_TIMESIGNATURE_ITEM ), &cb );
				if (FAILED(hr) || cb != sizeof( DMUS_IO_TIMESIGNATURE_ITEM ) ) 
				{
					if (SUCCEEDED(hr)) hr = E_FAIL;
					goto ON_END;
				}

				// If we need to, skip some bytes
				if( dwSkipBytes )
				{
					hr = StreamSeek( pIStream, dwSkipBytes, STREAM_SEEK_CUR );
					if( FAILED(hr) )
					{
						goto ON_END;
					}
				}

				// Subtract off the amount we read in
				lTmpSize -= dwTimeSigSize;

				// Now, figure out if we need to adjust the start time of the paste
				MUSIC_TIME mtTime = iTimeSigItem.lTime;
				mtTime += mtPasteTime;
				if( mtTime < 0 )
				{
					mtTime = 0 - mtTime;
					if( mtTime > mtAdjustment )
					{
						mtAdjustment = mtTime;
					}
				}
				else if( mtTime >= mtMaxTimelineLength )
				{
					mtTime = mtMaxTimelineLength - mtTime;
					if( mtTime < mtAdjustment )
					{
						mtAdjustment = mtTime - 1;
					}
				}
			}
		}

		// New paste time which will enforce strip boundaries
		mtPasteTime += mtAdjustment;

		// Restore our position back to the start of the TimeSigs
		StreamSeek( pIStream, dwCurrentFilePos, STREAM_SEEK_SET );
	}

	while ( lSize )
	{
		DMUS_IO_TIMESIGNATURE_ITEM iTimeSigItem;
		DWORD cb;
		hr = pIStream->Read( &iTimeSigItem, sizeof( DMUS_IO_TIMESIGNATURE_ITEM ), &cb );
		if (FAILED(hr) || cb != sizeof( DMUS_IO_TIMESIGNATURE_ITEM ) ) 
		{
			if (SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_END;
		}

		// If we need to, skip some bytes
		if( dwSkipBytes )
		{
			hr = StreamSeek( pIStream, dwSkipBytes, STREAM_SEEK_CUR );
			if( FAILED(hr) )
			{
				goto ON_END;
			}
		}

		// Subtract off the amount we read in
		lSize -= dwTimeSigSize;

		CTimeSigItem* pItem = new CTimeSigItem( this );
		if( pItem == NULL )
		{
			hr = E_OUTOFMEMORY;
			goto ON_END;
		}

		MUSIC_TIME mtTime = iTimeSigItem.lTime;
		if( fPaste )
		{
			mtTime += mtPasteTime;
		}

		// Copy TimeSignature to the pItem
		pItem->m_TimeSignature.bBeat = iTimeSigItem.bBeat;
		pItem->m_TimeSignature.bBeatsPerMeasure = iTimeSigItem.bBeatsPerMeasure;
		pItem->m_TimeSignature.wGridsPerBeat = iTimeSigItem.wGridsPerBeat;
		if( pItem->m_TimeSignature.wGridsPerBeat == 0 )
		{
			pItem->m_TimeSignature.wGridsPerBeat = 2;
		}
		if( pItem->m_TimeSignature.bBeat == 0 )
		{
			pItem->m_TimeSignature.bBeat = 2;
		}
		if( pItem->m_TimeSignature.bBeatsPerMeasure == 0 )
		{
			pItem->m_TimeSignature.bBeatsPerMeasure = 4;
		}

		// Set the measure this TimeSig belongs to
		if( !GetFirstValidTimeSig( m_lstTimeSigs.GetHeadPosition(), m_lstTimeSigs ) )
		{
			// If no valid TimeSigs, we need to use the TimeSig of this item to compute the measure #
			pItem->m_dwMeasure = mtTime / ClocksPerMeasure( pItem->m_TimeSignature );
		}
		else
		{
			// Have valid TimeSigs, can use ClocksToMeasure
			ClocksToMeasure( mtTime, (DWORD&)pItem->m_dwMeasure );
		}
		ASSERT( pItem->m_dwMeasure >= 0 );

		// Insert it into the list
		InsertByAscendingTime( pItem );
		fChanged = TRUE;

		// If pasting, select the item
		if( fPaste )
		{
			pItem->SetSelectFlag( TRUE );
		}
	}

ON_END:
	if( SUCCEEDED( hr )
	&&  fChanged == FALSE )
	{
		hr = S_FALSE;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::Save

HRESULT CTimeSigMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(fClearDirty);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_DESIGN;	// Default to FT_DESIGN so clipboard
										// gets proper file ref chunk
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}
	if( !(::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ))
	&&  !(::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

    MMCKINFO ckMain;
    MMCKINFO ck;

	// Create the track list chunk
	ckMain.fccType = DMUS_FOURCC_TIMESIGTRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// If the TimeSig list isn't empty, save it
	if ( !m_lstTimeSigs.IsEmpty() )
	{
		// Create a chunk to store the TimeSig data
		ck.ckid = DMUS_FOURCC_TIMESIG_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		DWORD cb, dwTimeSigSize = sizeof( DMUS_IO_TIMESIGNATURE_ITEM );
		hr = pIStream->Write( &dwTimeSigSize, sizeof( DWORD ), &cb );
		if( FAILED(hr) || cb != sizeof(DWORD) )
		{
			if(SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_ERROR;
		}

		POSITION pos = m_lstTimeSigs.GetHeadPosition();
		while( pos )
		{
			CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );
			if( !(pTimeSigItem->m_dwBits & UD_FAKE) )
			{
				DMUS_IO_TIMESIGNATURE_ITEM oTimeSigItem;

				oTimeSigItem.lTime = MeasureToClocks( pTimeSigItem->m_dwMeasure );
				oTimeSigItem.bBeatsPerMeasure = pTimeSigItem->m_TimeSignature.bBeatsPerMeasure;
				oTimeSigItem.bBeat = pTimeSigItem->m_TimeSignature.bBeat;
				oTimeSigItem.wGridsPerBeat = pTimeSigItem->m_TimeSignature.wGridsPerBeat;

				hr = pIStream->Write( &oTimeSigItem, sizeof( DMUS_IO_TIMESIGNATURE_ITEM ), &cb );
				if( FAILED(hr) || cb != sizeof(DMUS_IO_TIMESIGNATURE_ITEM) )
				{
					if(SUCCEEDED(hr)) hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
		
		// Ascend out of the TimeSig chunk.
		pIRiffStream->Ascend( &ck, 0 );
	}
		
	// Ascend out of the track list chunk.
	pIRiffStream->Ascend( &ckMain, 0 );

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::SyncWithDirectMusic

HRESULT CTimeSigMgr::SyncWithDirectMusic( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIDMTrack == NULL )
	{
		return E_FAIL;
	}

	IStream* pIMemStream;

	// Persist the strip into a stream
	HRESULT hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		hr = Save( pIMemStream, FALSE );
		if( SUCCEEDED ( hr ) )
		{
			IPersistStream* pIPersistStream;
			hr = m_pIDMTrack->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
			if( SUCCEEDED ( hr ) )
			{
				// Load into DirectMusic track
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				hr = pIPersistStream->Load( pIMemStream );

				pIPersistStream->Release();
			}
		}

		pIMemStream->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::GetSizeMax

HRESULT CTimeSigMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	UNREFERENCED_PARAMETER(pcbSize);
	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::GetData

// This method is called by CTimeSigPropPageMgr to get data to send to the
// TimeSig property page.
// The CTimeSigStrip::GetData() method is called by CTimeSigStripPropPageMgr
// to get the strip's properties (Group Bits, etc.)
HRESULT STDMETHODCALLTYPE CTimeSigMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected TimeSig
	BOOL fMultipleSelect = FALSE;
	CTimeSigItem* pFirstTimeSigItem = NULL;

	CTimeSigItem* pTimeSigItem;
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		pTimeSigItem = m_lstTimeSigs.GetNext( pos );
		if( pTimeSigItem->m_fSelected
		&&  !(pTimeSigItem->m_dwBits & UD_FAKE) )
		{
			pFirstTimeSigItem = pTimeSigItem;
			while( pos )
			{
				pTimeSigItem = m_lstTimeSigs.GetNext( pos );
				if( pTimeSigItem->m_fSelected
				&&  !(pTimeSigItem->m_dwBits & UD_FAKE) )
				{
					fMultipleSelect = TRUE;
					pos = NULL;
					break;
				}
			}
			break;
		}
	}

	*ppData = NULL;
	HRESULT hr = E_FAIL;

	// Multiple TimeSigs selected
	if( fMultipleSelect )
	{
		CPropTimeSig* pPropTimeSig = new CPropTimeSig;
		if( pPropTimeSig )
		{
			pPropTimeSig->m_dwMeasure = 0xFFFFFFFF;		// Signifies multiple TimeSigs selected
			*ppData = pPropTimeSig;
			hr = S_OK;
		}
	}

	// One TimeSig selected
	else if( pFirstTimeSigItem )
	{
		CPropTimeSig* pPropTimeSig = new CPropTimeSig( pFirstTimeSigItem );
		if( pPropTimeSig )
		{
			if( m_fHaveStyleRefStrip )
			{
				pPropTimeSig->m_dwBits |= UD_STYLEUPDATE;
			}
			*ppData = pPropTimeSig;
			hr = S_OK;
		}
	}

	// Nothing selected
	else
	{
		*ppData = NULL;
		hr = S_OK;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::SetData

// This method is called by CTimeSigPropPageMgr in response to user actions
// in the TimeSig Property page.  It changes the currenly selected TimeSig. 
HRESULT STDMETHODCALLTYPE CTimeSigMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected timesig
	CTimeSigItem* pTimeSigItem = FirstSelectedRealTimeSig();

	if( pTimeSigItem )
	{
		CPropTimeSig* pTimeSig = (CPropTimeSig*)pData;
		BOOL fChanged = FALSE;

		// Check if measure # changed
		if( pTimeSigItem->m_dwMeasure != pTimeSig->m_dwMeasure )
		{
			pTimeSigItem->m_dwMeasure = pTimeSig->m_dwMeasure;
			fChanged = TRUE;
			m_pTimeSigStrip->m_nLastEdit = IDS_UNDO_MOVE;

			// Re-insert the Time Sig into the list, since its measure info 
			// changed and it may now be out of order w.r.t. the other elements.
			if( RemoveItem( pTimeSigItem ) )
			{
				InsertByAscendingTime( pTimeSigItem );
			}
		}

		// Check if TimeSig changed
		if( (pTimeSigItem->m_TimeSignature.bBeat != pTimeSig->m_TimeSignature.bBeat) ||
			(pTimeSigItem->m_TimeSignature.bBeatsPerMeasure != pTimeSig->m_TimeSignature.bBeatsPerMeasure) ||
			(pTimeSigItem->m_TimeSignature.wGridsPerBeat != pTimeSig->m_TimeSignature.wGridsPerBeat) )
		{
			pTimeSigItem->m_TimeSignature = pTimeSig->m_TimeSignature;
			fChanged = TRUE;
			m_pTimeSigStrip->m_nLastEdit = IDS_CHANGE;
		}

		if( fChanged )
		{
			// Since it changed, make it into a 'real' Time signatures
			pTimeSigItem->m_dwBits &= ~UD_FAKE;

			// Redraw the timesig strip
			// BUGBUG: Should be smarter and only redraw the time sig that changed
			m_pTimeline->StripInvalidateRect( m_pTimeSigStrip, NULL, TRUE );

			// Let our hosting editor know about the changes
			OnDataChanged();

			SyncWithDirectMusic();

			// Notify the other strips of possible TimeSig change
			m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_dwGroupBits, NULL );
			return S_OK;
		}
	}

	// Nothing changed, or no items are selected
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CTimeSigMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		CTimeSigPropPageMgr* pPPM = new CTimeSigPropPageMgr(m_pDMProdFramework);
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		m_pPropPageMgr->SetObject( this );

		// Remove the reference created by the contrustor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CTimeSigMgr::OnRemoveFromPageManager( void)
{
	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::OnDataChanged

HRESULT STDMETHODCALLTYPE CTimeSigMgr::OnDataChanged( void)
{
	ASSERT( m_pTimeline );
	if ( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged( (ITimeSigMgr*)this );

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::DeleteSelectedTimeSigs

HRESULT CTimeSigMgr::DeleteSelectedTimeSigs()
{
	CTimeSigItem* pTimeSigItem;
	POSITION pos2, pos1 = m_lstTimeSigs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pTimeSigItem = m_lstTimeSigs.GetNext( pos1 );
		if( pTimeSigItem->m_fSelected
		|| (pTimeSigItem->m_dwBits & UD_FAKE) )
		{
			m_lstTimeSigs.RemoveAt( pos2 );
			delete pTimeSigItem;
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::SaveSelectedTimeSigs

HRESULT CTimeSigMgr::SaveSelectedTimeSigs(LPSTREAM pIStream, MUSIC_TIME mtOffset)
{
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the TimeSig list has anything in it, look for selected TimeSigs
	if ( !m_lstTimeSigs.IsEmpty() )
	{
		DWORD cb, dwTimeSigSize = sizeof( DMUS_IO_TIMESIGNATURE_ITEM );
		hr = pIStream->Write( &dwTimeSigSize, sizeof( DWORD ), &cb );
		if( FAILED(hr) || cb != sizeof(DWORD) )
		{
			if(SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_ERROR;
		}

		POSITION pos = m_lstTimeSigs.GetHeadPosition();
		while( pos )
		{
			CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );
			if(  pTimeSigItem->m_fSelected
			&& !(pTimeSigItem->m_dwBits & UD_FAKE) )
			{
				DMUS_IO_TIMESIGNATURE_ITEM oTimeSigItem;

				oTimeSigItem.lTime = MeasureToClocks( pTimeSigItem->m_dwMeasure ) - mtOffset;
				oTimeSigItem.bBeatsPerMeasure = pTimeSigItem->m_TimeSignature.bBeatsPerMeasure;
				oTimeSigItem.bBeat = pTimeSigItem->m_TimeSignature.bBeat;
				oTimeSigItem.wGridsPerBeat = pTimeSigItem->m_TimeSignature.wGridsPerBeat;

				hr = pIStream->Write( &oTimeSigItem, sizeof( DMUS_IO_TIMESIGNATURE_ITEM ), &cb );
				if( FAILED(hr) || cb != sizeof(DMUS_IO_TIMESIGNATURE_ITEM) )
				{
					if(SUCCEEDED(hr)) hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
	}
	else
	{
		hr = S_FALSE; // Nothing in the list
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::CreateTimeSig

HRESULT CTimeSigMgr::CreateTimeSig( MUSIC_TIME mtTime, CTimeSigItem*& rpTimeSig )
{
	rpTimeSig = NULL;

	if( m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	rpTimeSig = new CTimeSigItem( this );
	if( rpTimeSig == NULL )
	{
		return E_OUTOFMEMORY;
	}

	long lMeasure = 0;

	HRESULT hr;
	hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, NULL );
	ASSERT( SUCCEEDED ( hr ) );

	rpTimeSig->m_TimeSignature.bBeat = 4;
	rpTimeSig->m_TimeSignature.bBeatsPerMeasure = 4;
	rpTimeSig->m_TimeSignature.wGridsPerBeat = 4;

	rpTimeSig->m_dwMeasure = lMeasure;

	//rpTimeSig->SetSelectFlag( TRUE );
	InsertByAscendingTime( rpTimeSig );

	// Mark this time sig as 'fake'
	rpTimeSig->m_dwBits |= UD_FAKE;

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::MarkSelectedTimeSigs

// marks m_dwUndermined field CTimeSigItems in list
void CTimeSigMgr::MarkSelectedTimeSigs( DWORD dwFlags )
{
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );
		if ( pTimeSigItem->m_fSelected )
		{
			pTimeSigItem->m_dwBits |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::DeleteMarked

// deletes TimeSigs marked by given flag
void CTimeSigMgr::DeleteMarked( DWORD dwFlags )
{
	POSITION pos2, pos1 = m_lstTimeSigs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos1 );
		if( (pTimeSigItem->m_dwBits & dwFlags)
		||  (pTimeSigItem->m_dwBits & UD_FAKE) )
		{
			m_lstTimeSigs.RemoveAt( pos2 );
			delete pTimeSigItem;
		}
	}

	// Update the property page
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::UnMarkTimeSigs

// unmarks flag m_dwUndermined field CTimeSigItems in list
void CTimeSigMgr::UnMarkTimeSigs( DWORD dwFlags )
{
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		m_lstTimeSigs.GetNext( pos )->m_dwBits &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::UnselectAllKeepBits

void CTimeSigMgr::UnselectAllKeepBits()
{
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		m_lstTimeSigs.GetNext( pos )->m_fSelected = FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::UnselectAll

BOOL CTimeSigMgr::UnselectAll()
{
	BOOL fChange = FALSE; // Flag notifying the caller on whether they need to redraw

	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem *pItem = m_lstTimeSigs.GetNext( pos );
		if( pItem->m_fSelected || (pItem->m_dwBits & UD_DRAGSELECT) )
		{
			pItem->SetSelectFlag( FALSE );
			fChange = TRUE;
		}
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::SelectAll

void CTimeSigMgr::SelectAll()
{
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );
		// Only select "real" TimeSigs
		pTimeSigItem->SetSelectFlag( !(pTimeSigItem->m_dwBits & UD_FAKE) );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::IsSelected

BOOL CTimeSigMgr::IsSelected()
{
	// If anything "real" is selected, return TRUE.
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );
		if( pTimeSigItem->m_fSelected
		&&  !(pTimeSigItem->m_dwBits & UD_FAKE) )
		{
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::FirstSelectedTimeSig

CTimeSigItem* CTimeSigMgr::FirstSelectedTimeSig()
{
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );
		if ( pTimeSigItem->m_fSelected )
		{
			return pTimeSigItem;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::FirstSelectedReaTimeSig

CTimeSigItem* CTimeSigMgr::FirstSelectedRealTimeSig()
{
	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );

		if(  pTimeSigItem->m_fSelected
		&& !(pTimeSigItem->m_dwBits & UD_FAKE) )
		{
			return pTimeSigItem;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::SelectSegment

BOOL CTimeSigMgr::SelectSegment(long lBeginTime, long lEndTime)
{
	ASSERT(m_pTimeline);
	if( !m_pTimeline )
	{
		return FALSE;
	}

	BOOL result = FALSE;
	if( lBeginTime == -1)
	{
		// till we implement m_lShiftFromMeasure (see CommandMgr::SelectSegment),
		// just set it to beginning
		lBeginTime = 0;
	}

	long lBeginMeas, lEndMeas;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lBeginTime, &lBeginMeas, NULL );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEndTime, &lEndMeas, NULL );

	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos );
		pTimeSigItem->SetSelectFlag( FALSE );
		if( (DWORD)lBeginMeas < pTimeSigItem->m_dwMeasure && pTimeSigItem->m_dwMeasure < (DWORD)lEndMeas )
		{
			pTimeSigItem->SetSelectFlag( TRUE );
			result = TRUE;
		}
		else if( (DWORD)lBeginMeas == pTimeSigItem->m_dwMeasure )
		{
			if( (DWORD)lEndMeas == pTimeSigItem->m_dwMeasure )
			{
				pTimeSigItem->SetSelectFlag( TRUE );
				result = TRUE;
			}
			else
			{
				pTimeSigItem->SetSelectFlag( TRUE );
				result = TRUE;
			}
		}
		else if( (DWORD)lEndMeas == pTimeSigItem->m_dwMeasure )
		{
			pTimeSigItem->SetSelectFlag( TRUE );
			result = TRUE;
		}
	}
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::EmptyTimeSigList

void CTimeSigMgr::EmptyTimeSigList(void)
{
	if( !m_lstTimeSigs.IsEmpty() )
	{
		while ( !m_lstTimeSigs.IsEmpty() )
		{
			delete m_lstTimeSigs.RemoveHead();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::InsertByAscendingTime

void CTimeSigMgr::InsertByAscendingTime( CTimeSigItem *pTimeSig )
{
	ASSERT( pTimeSig );
	if ( pTimeSig == NULL )
	{
		return;
	}

	POSITION pos2, pos1 = m_lstTimeSigs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetNext( pos1 );
		if( pTimeSigItem->m_dwMeasure == pTimeSig->m_dwMeasure )
		{
			// Always replace item
			m_lstTimeSigs.InsertBefore( pos2, pTimeSig );
			m_lstTimeSigs.RemoveAt( pos2 );
			delete pTimeSigItem;
			return;
		}
		if( pTimeSigItem->m_dwMeasure > pTimeSig->m_dwMeasure )
		{
			// insert before pos2 (current position of pTimeSigItem)
			m_lstTimeSigs.InsertBefore( pos2, pTimeSig );
			return;
		}
	}
	// insert at end of list
	m_lstTimeSigs.AddTail( pTimeSig );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::RemoveItem

BOOL CTimeSigMgr::RemoveItem( CTimeSigItem* pItem )
{
	POSITION pos2;
	POSITION pos1 = m_lstTimeSigs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstTimeSigs.GetNext( pos1 ) == pItem )
		{
			m_lstTimeSigs.RemoveAt( pos2 );
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::GetBoundariesOfSelectedTimeSigs

void CTimeSigMgr::GetBoundariesOfSelectedTimeSigs( long *plStart, long *plEnd )
{
	ASSERT( plStart );
	ASSERT( plEnd );

	HRESULT hr;
	long lClocks;
	long lEnd = -1;
	BOOL fSetStart = FALSE;

	POSITION pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		CTimeSigItem* pItem = m_lstTimeSigs.GetNext( pos );

		if( pItem->m_fSelected ) 
//		&&	!(pTimeSigItem->m_dwBits & UD_FAKE) )
		{
			hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits,
												   0,
												   pItem->m_dwMeasure,
												   0,
												   &lClocks );
			ASSERT( SUCCEEDED ( hr ) );
			if( SUCCEEDED ( hr ) )
			{
				if( lEnd < lClocks )
				{
					lEnd = lClocks;
				}
				if( !fSetStart )
				{
					fSetStart = TRUE;
					*plStart = lClocks;
				}
			}
		}
	}

	if( lEnd >= 0 )
	{
		if( lEnd <= *plStart )
		{
			lEnd = *plStart + 1;
		}
		*plEnd = lEnd;
	}
	else
	{
		*plStart = -1;
		*plEnd = -1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::DeleteBetweenTimes

BOOL CTimeSigMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	HRESULT hr;
	long lClocks;

	BOOL fChanged = FALSE;

	// Iterate through the list
	CTimeSigItem* pItem;
	POSITION pos2, pos = m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		// Save the current position
		pos2 = pos;
		pItem = m_lstTimeSigs.GetNext( pos );

		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits,
											   0,
											   pItem->m_dwMeasure,
											   0,
											   &lClocks );
		ASSERT( SUCCEEDED ( hr ) );
		if( SUCCEEDED ( hr ) )
		{
			// If the TimeSig occurs between lStart and lEnd, delete it
			if( (lClocks >= lStart) && (lClocks <= lEnd) ) 
			{
				m_lstTimeSigs.RemoveAt( pos2 );
				if( !(pItem->m_dwBits & UD_FAKE) )
				{
					fChanged = TRUE;
				}
				delete pItem;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr::UpdateHaveStyleFlag

void CTimeSigMgr::UpdateHaveStyleFlag( void )
{
	BOOL fOrigHaveStyleRefStrip = m_fHaveStyleRefStrip;

	IDMUSProdStripMgr *pIStripMgr = NULL;
	if( m_pTimeline &&
		SUCCEEDED( m_pTimeline->GetStripMgr( GUID_IDirectMusicStyle, m_dwGroupBits, 0, &pIStripMgr ) ) )
	{
		m_fHaveStyleRefStrip = TRUE;
		
		// Remove all unselected items
		POSITION pos2, pos = m_lstTimeSigs.GetHeadPosition();
		while ( pos )
		{
			pos2 = pos;
			if( !m_lstTimeSigs.GetNext( pos )->m_fSelected )
			{
				delete m_lstTimeSigs.GetAt( pos2 );
				m_lstTimeSigs.RemoveAt( pos2 );
			}
			else
			{
				m_lstTimeSigs.GetAt(pos2)->m_dwBits |= UD_STYLEUPDATE;
			}
		}

		// Add new TimeSigs from this Style track
		MUSIC_TIME mtCurrent = 0, mtNext = 1;
		pos = m_lstTimeSigs.GetHeadPosition();
		while( mtNext > 0 )
		{
			IDirectMusicStyle *pIDMStyle;
			// If first style isn't at time zero, we treat if as if it were at 0.
			if( SUCCEEDED( pIStripMgr->GetParam( GUID_IDirectMusicStyle, mtCurrent, &mtNext, &pIDMStyle ) ) )
			{
				// pIDMStyle will be NULL if mtCurrent is 0 and
				// there is NOT a style in Measure 1
				if( pIDMStyle )
				{
					long lMeasure;
					m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtCurrent, &lMeasure, NULL );

					CTimeSigItem *pItem = new CTimeSigItem(this);
					pItem->m_dwMeasure = lMeasure;

					DMUS_TIMESIGNATURE timeSig;
					pIDMStyle->GetTimeSignature( &timeSig );
					memcpy( &pItem->m_TimeSignature, &timeSig, sizeof(DMUS_TIMESIGNATURE) );

					// Insert the new item into the list
					while( pos )
					{
						CTimeSigItem* pTimeSigItem = m_lstTimeSigs.GetAt( pos );
						if( pTimeSigItem->m_dwMeasure == pItem->m_dwMeasure )
						{
							// replace item
							pItem->m_fSelected = pTimeSigItem->m_fSelected;
							m_lstTimeSigs.InsertBefore( pos, pItem );
							m_lstTimeSigs.RemoveAt( pos );
							delete pTimeSigItem;
							pos = m_lstTimeSigs.GetHeadPosition();
							break;
						}
						if( pTimeSigItem->m_dwMeasure > pItem->m_dwMeasure )
						{
							// insert before pos (current position of pTimeSigItem)
							m_lstTimeSigs.InsertBefore( pos, pItem );
							break;
						}
						// Get next item to check
						m_lstTimeSigs.GetNext( pos );
					}

					// insert at end of list
					if( pos == NULL )
					{
						m_lstTimeSigs.AddTail( pItem );
					}

					pIDMStyle->Release();
				}
				mtCurrent += mtNext;
			}
			else
			{
				mtNext = 0;
			}
		}

		// Mark all marked, valid TimeSig items as 'fake'
		pos = m_lstTimeSigs.GetHeadPosition();
		while ( pos )
		{
			pos2 = pos;
			if( m_lstTimeSigs.GetNext( pos )->m_dwBits & UD_STYLEUPDATE )
			{
				m_lstTimeSigs.GetAt( pos2 )->m_dwBits &= UD_STYLEUPDATE;
				m_lstTimeSigs.GetAt( pos2 )->m_dwBits |= UD_FAKE;
			}
		}

		pIStripMgr->Release();
	}
	else
	{
		m_fHaveStyleRefStrip = FALSE;
	}

	if( (fOrigHaveStyleRefStrip || m_fHaveStyleRefStrip) && m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\TimeSigMgr.h ===
// TimeSigMgr.h : Declaration of the CTimeSigMgr

#ifndef __TIMESIGMGR_H_
#define __TIMESIGMGR_H_

#include "resource.h"		// main symbols
#include "TimeSigStripMgr.h"
#include "timeline.h"
#include <DMUSProd.h>
#include <afxtempl.h>
#include "proppagemgr.h"
#include <mmsystem.h>
#include <dmusici.h>
#include <dmusicf.h>

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION )

class CTimeSigStrip;
class CTimeSigItem;
interface IDirectMusicTrack;
interface IDMUSProdRIFFStream;

/////////////////////////////////////////////////////////////////////////////
// CTimeSigMgr
class ATL_NO_VTABLE CTimeSigMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTimeSigMgr, &CLSID_TimeSigMgr>,
	public ITimeSigMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CTimeSigStrip;
friend CTimeSigItem;

public:
	CTimeSigMgr();
	~CTimeSigMgr();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_TIMESIGMGR)

BEGIN_COM_MAP(CTimeSigMgr)
	COM_INTERFACE_ENTRY_IID(IID_ITimeSigMgr,ITimeSigMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// ITimeSigMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureOpen( DWORD dwMeasure );

// IPersist methods
	STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream methods
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

protected:
	HRESULT SyncWithDirectMusic();
	void ClocksToMeasure(MUSIC_TIME mtTime, DWORD& rdwMeasure);
	MUSIC_TIME MeasureToClocks(DWORD dwMeasure);
	HRESULT LoadTimeSigChunk( IStream* pIStream, 
								long lSize,
										BOOL fPaste,
								MUSIC_TIME mtPasteTime );
	HRESULT STDMETHODCALLTYPE OnDataChanged();
	void	EmptyTimeSigList();
	void	InsertByAscendingTime( CTimeSigItem *pTimeSig );
	void	GetBoundariesOfSelectedTimeSigs( long *plStart, long *plEnd );
	BOOL	DeleteBetweenTimes( long lStart, long lEnd );

	BOOL	SelectSegment(long begintime, long endtime);

protected:
	IDMUSProdTimeline*			m_pTimeline;

	CTypedPtrList<CPtrList, CTimeSigItem*> m_lstTimeSigs;
	IDMUSProdFramework* 		m_pDMProdFramework;
	CPropertyPage*				m_pPropertyPage;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDataObject*				m_pCopyDataObject;
	DWORD						m_dwGroupBits;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	IDMUSProdNode*				m_pISegmentNode; // DocRoot node of Segment
	BOOL						m_fDirty;
	BOOL						m_fHaveStyleRefStrip;

	CTimeSigStrip*				m_pTimeSigStrip;

protected:
	HRESULT DeleteSelectedTimeSigs();
	HRESULT SaveSelectedTimeSigs(LPSTREAM pIStream, MUSIC_TIME mtOffset);
	HRESULT CreateTimeSig( MUSIC_TIME mtTime, CTimeSigItem*& rpTimeSig );
	void UpdateHaveStyleFlag();

// general helpers
	void MarkSelectedTimeSigs(DWORD flags);
	void UnMarkTimeSigs(DWORD flags);
	void DeleteMarked(DWORD flags);
	void UnselectAllKeepBits();
	BOOL UnselectAll();
	void SelectAll();
	BOOL RemoveItem( CTimeSigItem* pItem );

// Misc
	BOOL		IsSelected();	// returns if one or more timesigs are selected.
	CTimeSigItem* FirstSelectedTimeSig();
	CTimeSigItem* FirstSelectedRealTimeSig();
};


class CTimeSigStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDropSource,
	public IDropTarget,
	public IDMUSProdPropPageObject
{
friend CTimeSigMgr;

public:
	CTimeSigStrip( CTimeSigMgr* pTimeSigMgr );
	~CTimeSigStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropSource helpers
	HRESULT 	CreateDataObject(IDataObject**, long position);

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
	CWnd*	GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtTime, BOOL bDropNotEditPaste, BOOL &fChanged);

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

private:
	HRESULT	DisplayPropertySheet( IDMUSProdTimeline* );
	void UnselectGutterRange( void );

protected:
// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LONG lXPos );
	HRESULT OnRButtonDown( WPARAM wParam, LONG lXPos );
	BOOL DoDragDrop();

	long				m_cRef;
	CTimeSigMgr*		m_pTimeSigMgr;
	IDMUSProdStripMgr*	m_pStripMgr;

	LONG			m_lGutterBeginSelect;
	LONG			m_lGutterEndSelect;
	BOOL			m_bGutterSelected;	// whether the gutter select is selected, use

	BOOL			m_bSelecting;
	BOOL			m_bContextMenuPaste;

private:
	CTimeSigItem* GetTimeSigFromPoint( long lPos );
	CTimeSigItem* GetTimeSigFromMeasureBeat( DWORD dwMeasure, BYTE bBeat );
	HRESULT SelectRange( CTimeSigItem* pTimeSig );

	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits

	IDataObject*m_pISourceDataObject;	// Object being dragged 
	IDataObject*m_pITargetDataObject;
	short		m_nStripIsDragDropSource;	
	DWORD		m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD		m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD		m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	DWORD		m_dwDragRMenuEffect;	// Result from drag context menu
	UINT		m_cfTimeSigList;			// CF_TIMESIGLIST Clipboard format
	UINT		m_cfStyle;					// CF_STYLE Clipboard format
	LONG		m_lStartDragPosition;	// xpos where drag was started
	UINT		m_nLastEdit;			// resource id of last edit
	BOOL		m_fShowTimeSigProps;		// if TRUE, show TimeSig property page, else show group property page
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	BOOL		m_fInRightClickMenu;
	BOOL		m_fSingleSelect;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	DWORD		m_dwShiftSelectFromMeasure;
};
#endif //__TIMESIGMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\TimeSignatureDlg.cpp ===
// TimeSignatureDlg.cpp : implementation file
//

#include "stdafx.h"
#include "TimeSignatureDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern UINT g_nGridsPerBeatBitmaps[MAX_GRIDS_PER_BEAT_ENTRIES];


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg dialog

CTimeSignatureDlg::CTimeSignatureDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTimeSignatureDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTimeSignatureDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_TimeSignature.bBeatsPerMeasure = 4;
	m_TimeSignature.bBeat = 4;
	m_TimeSignature.wGridsPerBeat = 2;
}


void CTimeSignatureDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTimeSignatureDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_GRID, m_cmbxGrid);
	DDX_Control(pDX, IDC_BPM_SPIN, m_spinBPM);
	DDX_Control(pDX, IDC_BPM, m_editBPM);
	DDX_Control(pDX, IDC_BEAT, m_cmbxBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTimeSignatureDlg, CDialog)
	//{{AFX_MSG_MAP(CTimeSignatureDlg)
	ON_WM_MEASUREITEM()
	ON_WM_DRAWITEM()
	ON_CBN_SELCHANGE(IDC_BEAT, OnSelChangeBeat)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnInitDialog

BOOL CTimeSignatureDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Set title
	/*
	CString strTitle;
	CString strContext;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );
	strContext.LoadString( m_nContext );
	AfxFormatString1( strTitle, IDS_SET_TIME_SIGNATURE, strContext );
	AfxSetResourceHandle( hInstance );
	SetWindowText( strTitle );
	*/

	// Set beats per measure
	m_editBPM.LimitText( 3 );
	m_spinBPM.SetRange( MIN_BEATS_PER_MEASURE, MAX_BEATS_PER_MEASURE );
	m_spinBPM.SetPos( m_TimeSignature.bBeatsPerMeasure );

	// Fill beat combo box
	CString cstrText;
	int i;

	for ( i = IDS_BEAT1 ;  i <= IDS_BEAT6 ;  i++ )
	{
		cstrText.LoadString( i );
		m_cmbxBeat.AddString( cstrText );
	}

	// Set beat
	CString strBeat;

	strBeat.Format( "%d", m_TimeSignature.bBeat );
	int nPos = m_cmbxBeat.FindStringExact( -1, strBeat ); 
	m_cmbxBeat.SetCurSel( nPos );

	// Fill grids per beat combo box
	for( i = MIN_GRIDS_PER_BEAT ;  i <= MAX_GRIDS_PER_BEAT ;  i++ )
	{
		m_cmbxGrid.AddString( _T("") );
	}

	// Set grids per beat
	m_cmbxGrid.SetCurSel( m_TimeSignature.wGridsPerBeat - 1 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnSelChangeBeat

void CTimeSignatureDlg::OnSelChangeBeat() 
{
	m_cmbxGrid.Invalidate();	
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateBeatsPerMeasure

BOOL CTimeSignatureDlg::ValidateBeatsPerMeasure()
{
	CString strBeatsPerMeasure;

	m_editBPM.GetWindowText( strBeatsPerMeasure );

	// Strip leading and trailing spaces
	strBeatsPerMeasure.TrimRight();
	strBeatsPerMeasure.TrimLeft();

	WORD wBeatsPerMeasure = (WORD)_ttoi( strBeatsPerMeasure );

	// Validate new length
	if( wBeatsPerMeasure < MIN_BEATS_PER_MEASURE
	||  wBeatsPerMeasure > MAX_BEATS_PER_MEASURE )
	{
		CString strMsg;
		CString strMin;
		CString strMax;
		
		strMin.Format( "%d", MIN_BEATS_PER_MEASURE );
		strMax.Format( "%d", MAX_BEATS_PER_MEASURE );
		
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( AfxGetInstanceHandle() );
		AfxFormatString2( strMsg, IDS_ERR_MIN_MAX, strMin, strMax );
		AfxSetResourceHandle( hInstance );
		AfxMessageBox( strMsg );

		m_editBPM.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateBeat

BOOL CTimeSignatureDlg::ValidateBeat()
{
	int nPos = m_cmbxBeat.GetCurSel();
	if( nPos == CB_ERR )
	{
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( AfxGetInstanceHandle() );
		AfxMessageBox( IDS_ERR_BEAT );
		AfxSetResourceHandle( hInstance );

		m_cmbxBeat.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateGridsPerBeat

BOOL CTimeSignatureDlg::ValidateGridsPerBeat()
{
	int nPos = m_cmbxGrid.GetCurSel();
	if( nPos == CB_ERR )
	{
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( AfxGetInstanceHandle() );
		AfxMessageBox( IDS_ERR_GRIDS_PER_BEAT );
		AfxSetResourceHandle( hInstance );

		m_cmbxGrid.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnOK

void CTimeSignatureDlg::OnOK() 
{
	if( ValidateBeatsPerMeasure() == FALSE
	||  ValidateBeat() == FALSE
	||  ValidateGridsPerBeat() == FALSE )
	{
		return;
	}

	// Get beats per measure
	CString strBeatsPerMeasure;

	m_editBPM.GetWindowText( strBeatsPerMeasure );
	strBeatsPerMeasure.TrimRight();
	strBeatsPerMeasure.TrimLeft();
	m_TimeSignature.bBeatsPerMeasure = (BYTE)_ttoi( strBeatsPerMeasure );

	// Get beat
	int nPos = m_cmbxBeat.GetCurSel();
	if( nPos != CB_ERR )
	{
		CString strBeat;

		m_cmbxBeat.GetLBText( nPos, strBeat );
		m_TimeSignature.bBeat = (BYTE)_ttoi( strBeat );
	}

	// Get grids per beat
	nPos = m_cmbxGrid.GetCurSel();
	if( nPos != CB_ERR )
	{
		m_TimeSignature.wGridsPerBeat = (WORD)(nPos + 1);
	}

	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnMeasureItem

void CTimeSignatureDlg::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			CBitmap bitmap;

			// Set height
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( AfxGetInstanceHandle() );
			if( bitmap.LoadBitmap( IDB_GPB1 ) )
			{
				BITMAP bm;

				bitmap.GetBitmap( &bm );
				lpMeasureItemStruct->itemHeight = bm.bmHeight + 3;
			}
			AfxSetResourceHandle( hInstance );

			// Set width
			RECT rect;

			CWnd* pWnd = GetDlgItem( IDC_GRID );
			if( pWnd )
			{
				pWnd->GetClientRect( &rect );
				lpMeasureItemStruct->itemWidth = rect.right - rect.left;
			}
			return;
		}
	}
	
	CDialog::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnDrawItem

void CTimeSignatureDlg::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			if( lpDrawItemStruct->itemID == -1 )
			{
				return;
			}

			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_FOCUS )
			{
		        InflateRect( &lpDrawItemStruct->rcItem, -1, -1 ) ;
                pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
		        InflateRect( &lpDrawItemStruct->rcItem, 1, 1 ) ;
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
            ||  lpDrawItemStruct->itemAction & ODA_SELECT )
			{
				CBitmap bitmap;

				// Get the resource id for the bitmap
				int nBeatPos = m_cmbxBeat.GetCurSel();
				int nResourceID = lpDrawItemStruct->itemID;
				if( nBeatPos != CB_ERR
				&&  nBeatPos != 2 )		// 2 = quarter note gets the beat
				{
					nResourceID += MAX_GRIDS_PER_BEAT;
				}
				ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) ); 

				// Load the bitmap
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( AfxGetInstanceHandle() );

				if( bitmap.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
				{
					CDC dcBitmap;

					if( dcBitmap.CreateCompatibleDC( pDC ) )
					{
						BITMAP bm;

						// Get the size of the bitmap
						bitmap.GetBitmap( &bm );

						// Clear the rectangle
						pDC->FillRect( &lpDrawItemStruct->rcItem,
									   CBrush::FromHandle( (HBRUSH)GetStockObject(WHITE_BRUSH) ) );

						// Paint the bitmap
						CBitmap* pOldBitmap = dcBitmap.SelectObject( &bitmap );
						pDC->BitBlt( lpDrawItemStruct->rcItem.left + 5, lpDrawItemStruct->rcItem.top + 1,
									 bm.bmWidth, bm.bmHeight,
									 &dcBitmap, 0, 0, SRCCOPY );
						dcBitmap.SelectObject( pOldBitmap );
					}
				}

				AfxSetResourceHandle( hInstance );

				// Invert if selected
                if( lpDrawItemStruct->itemState & ODS_SELECTED )
				{
					pDC->InvertRect( &lpDrawItemStruct->rcItem );
				}
			}

			return;
		}
	}
	
	CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\TimeSigStrip.cpp ===
// TimeSigStrip.cpp : Implementation of CTimeSigStrip
#include "stdafx.h"
#include "TimeSigIO.h"
#include "TimeSigStripMgr.h"
#include "TimeSigMgr.h"
#include "DLLJazzDataObject.h"
#include "GroupBitsPPG.h"
#include <RiffStrm.h>
#include <StyleDesigner.h>
#include "musictimeconverter.h"
#include "SegmentIO.h"
#include "TrackFlagsPPG.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STRIP_HEIGHT 20

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip constructor/destructor

CTimeSigStrip::CTimeSigStrip( CTimeSigMgr* pTimeSigMgr )
{
	ASSERT( pTimeSigMgr );
	if ( pTimeSigMgr == NULL )
	{
		return;
	}

	m_pTimeSigMgr = pTimeSigMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pTimeSigMgr;
	//m_pStripMgr->AddRef();

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_lGutterBeginSelect = 0;
	m_lGutterEndSelect = 0;
	m_bGutterSelected = FALSE;

	m_cfTimeSigList = 0;
	m_cfStyle = 0;

	m_lXPos = -1;
	m_bSelecting = FALSE;
	m_bContextMenuPaste = FALSE;
	m_pISourceDataObject = NULL;
	m_pITargetDataObject = NULL;
	m_nStripIsDragDropSource = 0;
	m_dwStartDragButton = 0;
	m_lStartDragPosition = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_nLastEdit = 0;
	m_fShowTimeSigProps = FALSE;
	m_fPropPageActive = FALSE;
	m_pPropPageMgr = NULL;
	m_fInRightClickMenu = FALSE;
	m_fSingleSelect = FALSE;
	m_dwShiftSelectFromMeasure = 0;
}

CTimeSigStrip::~CTimeSigStrip()
{
	ASSERT( m_pStripMgr );
	if ( m_pStripMgr )
	{
		//m_pStripMgr->Release();
		m_pStripMgr = NULL;
		m_pTimeSigMgr = NULL;
	}
	RELEASE( m_pISourceDataObject );
	RELEASE( m_pITargetDataObject );
	RELEASE( m_pPropPageMgr );
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::QueryInterface

STDMETHODIMP CTimeSigStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::AddRef

STDMETHODIMP_(ULONG) CTimeSigStrip::AddRef(void)
{
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::Release

STDMETHODIMP_(ULONG) CTimeSigStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::Draw

HRESULT	STDMETHODCALLTYPE CTimeSigStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	BOOL fUseGutterSelectRange = FALSE;
	if( m_bGutterSelected
	&&  m_lGutterBeginSelect != m_lGutterEndSelect )
	{
		fUseGutterSelectRange = TRUE;
	}

	// Validate pointer to the Timeline
	if( m_pTimeSigMgr->m_pTimeline )
	{
		// Draw Measure and Beat lines in our strip
		m_pTimeSigMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pTimeSigMgr->m_dwGroupBits, 0, lXOffset );
		
		// variables for ghosting
		CDC dc;
		IDMUSProdTimeline* pTimeline = m_pTimeSigMgr->m_pTimeline;
		CString	strGhost;
		RECT	rectGhost;
		long	lFirstVisibleMeasure, lPartialVisibleMeasure;
		long	lClocks;
		bool	bGhostTimeSigCovered = false;
		CTimeSigItem*	pGhostTimeSig = NULL;

		// Validate our device context
		if( hDC && dc.Attach(hDC))
		{
			RECT	rectClip, rectHighlight;
			long	lStartTime, lPosition;
			CTimeSigItem* pTimeSigItem;
			SIZE	sizeText;

			::GetClipBox( hDC, &rectClip );
			rectHighlight.top = 0;
			rectHighlight.bottom = STRIP_HEIGHT;
			rectGhost.top = rectGhost.left = rectGhost.right = 0;
			rectGhost.bottom = STRIP_HEIGHT;
			// find first visible measure for ghosting timesigs
			pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
			CMusicTimeConverter cmtFirstVisible(lClocks);
			cmtFirstVisible.GetMeasure(lPartialVisibleMeasure, pTimeline, m_pTimeSigMgr->m_dwGroupBits);
			CMusicTimeConverter cmtNearestMeasureBeat(lPartialVisibleMeasure, 0, pTimeline, 
														m_pTimeSigMgr->m_dwGroupBits);
			if(cmtNearestMeasureBeat.Time() < cmtFirstVisible.Time())
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure + 1;
			}
			else
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure;
			}
	
			// find last timesig before first visible measure
			POSITION pos = m_pTimeSigMgr->m_lstTimeSigs.GetHeadPosition();
			while(pos)
			{
				pTimeSigItem = m_pTimeSigMgr->m_lstTimeSigs.GetNext(pos);
				if(pTimeSigItem->m_dwMeasure < (unsigned)lFirstVisibleMeasure
					&& !(*pTimeSigItem->GetString() == 0))
				{
					pGhostTimeSig = pTimeSigItem;
				}
				else
				{
					break;
				}
			}
			if(pGhostTimeSig)
			{
				// get rect of style, will have to truncate if ghost style covers part of real style
				pTimeline->MeasureBeatToPosition(m_pTimeSigMgr->m_dwGroupBits, 0, lFirstVisibleMeasure,
												0, &lPosition);
				lPosition++;
				CSize csize;
				csize = dc.GetTextExtent(pGhostTimeSig->GetString());
				rectGhost.left = lPosition - lXOffset;
				rectGhost.right = rectGhost.left + csize.cx;
			}

			// we'll draw ghost timesig after checking whether real timesig covers it

			m_pTimeSigMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

			// Initialize the text color
			COLORREF crOldTextColor = ::SetTextColor( hDC, m_pTimeSigMgr->m_fHaveStyleRefStrip ? RGB(168, 168, 168) : RGB(0, 0, 0) );

			// Iterate through all time sigs
			pos = m_pTimeSigMgr->m_lstTimeSigs.GetHeadPosition();
			while( pos )
			{
				pTimeSigItem = m_pTimeSigMgr->m_lstTimeSigs.GetNext( pos );

				if(pTimeSigItem->m_dwMeasure == (unsigned)lFirstVisibleMeasure)
				{
					// real timesig covers ghost
					bGhostTimeSigCovered = true;
				}

				// Compute the position of the time signatures
				m_pTimeSigMgr->m_pTimeline->MeasureBeatToPosition( m_pTimeSigMgr->m_dwGroupBits, 0, pTimeSigItem->m_dwMeasure, 0, &lPosition );

				if(pGhostTimeSig)
				{
					//truncate ghost timesig's text so it doesn't cover up real timesig's text
					long lTruePos = lPosition - lXOffset;
					if(lTruePos > rectGhost.left && lTruePos < rectGhost.right)
					{
						rectGhost.right = lTruePos;
					}
				}

				// If it's not visible, break out of the loop
				if( lPosition - lXOffset > rectClip.right )
				{
					break;
				}

				// Otherwise, draw it one pixel to the right (so it doesn't overwrite the measure line)
				::TextOut( hDC, lPosition - lXOffset + 1, 0, pTimeSigItem->GetString(), _tcslen(pTimeSigItem->GetString()) );
			}


			// make sure the first selected TimeSig is shown in its entirety
			pTimeSigItem = m_pTimeSigMgr->FirstSelectedTimeSig();
			if( pTimeSigItem )
			{
				pos = m_pTimeSigMgr->m_lstTimeSigs.Find( pTimeSigItem, NULL );
				while( pos )
				{
					if( pTimeSigItem->m_fSelected )
					{
						long lMeasureLength = 0;
						m_pTimeSigMgr->m_pTimeline->MeasureBeatToPosition( m_pTimeSigMgr->m_dwGroupBits, 0,
														  pTimeSigItem->m_dwMeasure, 0, &lPosition );
						m_pTimeSigMgr->m_pTimeline->MeasureBeatToPosition( m_pTimeSigMgr->m_dwGroupBits, 0,
														 (pTimeSigItem->m_dwMeasure + 1), 0, &lMeasureLength );
						lMeasureLength -= lPosition;

						// find extent of text
						::GetTextExtentPoint32( hDC, pTimeSigItem->GetString(), _tcslen(pTimeSigItem->GetString()), &sizeText );
						if( sizeText.cx < lMeasureLength )
						{
							sizeText.cx = lMeasureLength;
						}
						long lExtent = lPosition + sizeText.cx;

						// truncate if a selected TimeSig covers part of text
						POSITION pos2 = pos;
						CTimeSigItem* pTempTimeSig;
						bool fDone = false;
						while( pos2 && !fDone)
						{
							m_pTimeSigMgr->m_lstTimeSigs.GetNext( pos2 );
							if (!pos2) break;
							pTempTimeSig = m_pTimeSigMgr->m_lstTimeSigs.GetAt( pos2 );
							if( pTempTimeSig->m_fSelected )
							{	
								long lRPos;
								m_pTimeSigMgr->m_pTimeline->MeasureBeatToPosition( m_pTimeSigMgr->m_dwGroupBits, 0, pTempTimeSig->m_dwMeasure, 0, &lRPos );
								if( lRPos <= lExtent )
								{
									lExtent = lRPos;
								}
								fDone = true;
							}
						}

						if( fUseGutterSelectRange == FALSE )
						{
							rectHighlight.left = lPosition - lXOffset;
							rectHighlight.right = lExtent - lXOffset;
							::DrawText( hDC, pTimeSigItem->GetString(), _tcslen(pTimeSigItem->GetString()), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
							GrayOutRect( hDC, &rectHighlight );
						}
					}
					m_pTimeSigMgr->m_lstTimeSigs.GetNext( pos );
					if (pos) pTimeSigItem = m_pTimeSigMgr->m_lstTimeSigs.GetAt( pos );
				}
			}

			// now draw ghost TimeSig
			// but not if original TimeSig is still showing
			if(!bGhostTimeSigCovered && pGhostTimeSig)
			{
				pTimeline->MeasureBeatToPosition(m_pTimeSigMgr->m_dwGroupBits, 0,
													pGhostTimeSig->m_dwMeasure, 0, &lPosition);
						
				// lPosition -= lXOffset deliberately left off as left margin already has scrolling taking into accout
				CSize extent = dc.GetTextExtent(pGhostTimeSig->GetString());
				if(!((lPosition + extent.cx) > LeftMargin(pTimeline)))
				{
					COLORREF cr = dc.SetTextColor(RGB(168, 168, 168));
					dc.DrawText(pGhostTimeSig->GetString(), &rectGhost, (DT_LEFT | DT_NOPREFIX));
					dc.SetTextColor(cr);
				}
			}

			// Reset Text color
			::SetTextColor( hDC, crOldTextColor );

			// Highlight the selected range if there is one.
			if( fUseGutterSelectRange )
			{
				long lBeginSelect = m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterEndSelect : m_lGutterBeginSelect;
				long lEndSelect = m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterBeginSelect : m_lGutterEndSelect;

				long lMeasure;
				long lBeat;
				long lClocks;

				m_pTimeSigMgr->m_pTimeline->ClocksToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits, 0, lBeginSelect, &lMeasure, &lBeat );
				m_pTimeSigMgr->m_pTimeline->MeasureBeatToClocks( m_pTimeSigMgr->m_dwGroupBits, 0, lMeasure, 0, &lClocks );
				m_pTimeSigMgr->m_pTimeline->ClocksToPosition( lClocks, &(rectHighlight.left));

				m_pTimeSigMgr->m_pTimeline->ClocksToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits, 0, lEndSelect, &lMeasure, &lBeat );
				m_pTimeSigMgr->m_pTimeline->MeasureBeatToClocks( m_pTimeSigMgr->m_dwGroupBits, 0, (lMeasure + 1), 0, &lClocks );
				m_pTimeSigMgr->m_pTimeline->ClocksToPosition( (lClocks - 1), &(rectHighlight.right));

				rectHighlight.left -= lXOffset;
				rectHighlight.right -= lXOffset;

				// Invert it.
				GrayOutRect( hDC, &rectHighlight );
			}
			dc.Detach();
		}
	}
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CTimeSigStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;

	case SP_NAME:
		{
			BSTR bstr;
			CString strBaseName;
			strBaseName.LoadString( IDS_FUNCTIONBAR_NAME );
			CString str = GetName(m_pTimeSigMgr->m_dwGroupBits, strBaseName);

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pTimeSigMgr )
		{
			m_pTimeSigMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CTimeSigStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL fRefresh = FALSE;

	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if( sp == SP_BEGINSELECT )
		{
			m_lGutterBeginSelect = V_I4( &var );
		}
		else
		{
			m_lGutterEndSelect = V_I4( &var );
		}

		if( m_bSelecting )
		{
			break;
		}

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			if( m_pTimeSigMgr->UnselectAll() )
			{
				// Only redraw if something changed
				m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
			break;
		}

		if( m_bGutterSelected )
		{
			//TODO: Optimize this
			m_pTimeSigMgr->UnselectAll();
			m_pTimeSigMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
			fRefresh = TRUE;
		}
		else
		{
			// Why does this need to happen?
			fRefresh |= m_pTimeSigMgr->UnselectAll();
		}

		if( fRefresh )
		{
			m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

			// Update the property page
			if( m_pTimeSigMgr->m_pPropPageMgr != NULL )
			{
				m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case SP_GUTTERSELECT:
		m_bGutterSelected = V_BOOL(&var);

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			m_pTimeSigMgr->UnselectAll();
			m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}

		if( m_bGutterSelected )
		{
			m_pTimeSigMgr->UnselectAll();
			m_pTimeSigMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			m_pTimeSigMgr->UnselectAll();
		}
		m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pTimeSigMgr->m_pPropPageMgr != NULL )
		{
			m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::GetTimeSigFromMeasureBeat

CTimeSigItem *CTimeSigStrip::GetTimeSigFromMeasureBeat( DWORD dwMeasure, BYTE bBeat )
{
	ASSERT( bBeat == 0 );	// Time Sigs must be on a measure boundary
	
	CTimeSigItem* pTimeSigItem = NULL;

	POSITION pos = m_pTimeSigMgr->m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		pTimeSigItem = m_pTimeSigMgr->m_lstTimeSigs.GetNext( pos );
		ASSERT( pTimeSigItem != NULL );
		if ( pTimeSigItem != NULL )
		{
			if ( pTimeSigItem->m_dwMeasure == dwMeasure )
			{
				return pTimeSigItem;
			}
			else if ( pTimeSigItem->m_dwMeasure > dwMeasure )
			{
				break;
			}
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::GetTimeSigFromPoint

CTimeSigItem *CTimeSigStrip::GetTimeSigFromPoint( long lPos )
{
	CTimeSigItem*		pTimeSigReturn = NULL;

	if( m_pTimeSigMgr->m_pTimeline )
	{
		long lMeasure, lBeat;
		if( SUCCEEDED( m_pTimeSigMgr->m_pTimeline->PositionToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			pTimeSigReturn = GetTimeSigFromMeasureBeat( lMeasure, 0 );
		}
	}
	return pTimeSigReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CTimeSigStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lYPos);

	// Process the window message
	HRESULT hr = S_OK;
	if( m_pTimeSigMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		m_fShowTimeSigProps = TRUE;
		hr = OnLButtonDown( wParam, lXPos );
		break;

	case WM_RBUTTONDOWN:
		hr = OnRButtonDown( wParam, lXPos );
		break;

	case WM_RBUTTONUP:
		// Display a right-click context menu.
		POINT pt;
		BOOL	bResult;
		// Get the cursor position (To put the menu there)
		bResult = GetCursorPos( &pt );
		ASSERT( bResult );
		if( !bResult )
		{
			hr = E_UNEXPECTED;
			break;
		}

		// Save the position of the click so we know where to insert a TimeSig. if Insert is selected.
		m_lXPos = lXPos;
		m_fInRightClickMenu = TRUE;
		m_pTimeSigMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
		m_fInRightClickMenu = FALSE;

		hr = S_OK;
		break;

	case WM_MOUSEMOVE:
		if( m_dwStartDragButton )
		{
			m_nStripIsDragDropSource = 1;
	
			if( DoDragDrop() )
			{
				// Redraw the strip and refresh the TimeSig property page
				m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
				m_pTimeSigMgr->OnShowProperties();
				if( m_pTimeSigMgr->m_pPropPageMgr )
				{
					m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
				}
			}

			m_dwStartDragButton = 0;
			m_nStripIsDragDropSource = 0;
		}
		break;

	case WM_SETFOCUS:
		m_dwShiftSelectFromMeasure = 0;
		hr = S_OK;
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = DisplayPropertySheet(m_pTimeSigMgr->m_pTimeline);
			if (m_fShowTimeSigProps)
			{
				// Change to the Time sig reference property page
				m_pTimeSigMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			if( m_lXPos >= 0 )
			{
				m_bContextMenuPaste = TRUE;
			}
			hr = Paste();
			m_bContextMenuPaste = FALSE;
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		default:
			break;
		}
		break;

	case WM_LBUTTONUP:
		if( m_fSingleSelect )
		{
			CTimeSigItem* pTimeSig = GetTimeSigFromPoint( lXPos );
			if( pTimeSig
			&&  !(pTimeSig->m_dwBits & UD_FAKE) )
			{
				m_pTimeSigMgr->UnselectAll();
				pTimeSig->SetSelectFlag( TRUE );

				// Redraw the strip and refresh the Tempo property page
				m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
				m_pTimeSigMgr->OnShowProperties();
				if( m_pTimeSigMgr->m_pPropPageMgr )
				{
					m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
				}
			}
			m_fSingleSelect = FALSE;
		}
		m_lXPos = lXPos;
		hr = S_OK;
		break;

	case WM_CREATE:
		m_cfTimeSigList = RegisterClipboardFormat( CF_TIMESIGLIST );
		m_cfStyle = RegisterClipboardFormat( CF_STYLE);

		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pTimeSigMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lGutterBeginSelect );
		m_pTimeSigMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lGutterEndSelect );

		// Unselect all
		m_pTimeSigMgr->UnselectAll();

		// Reset m_dwShiftSelectFromMeasure
		m_dwShiftSelectFromMeasure = 0;
		break;

	default:
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::FBDraw

HRESULT CTimeSigStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	UNREFERENCED_PARAMETER(hDC);
	UNREFERENCED_PARAMETER(sv);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::FBOnWMMessage

HRESULT CTimeSigStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_fShowTimeSigProps = FALSE;
		OnShowProperties();
		break;

	case WM_RBUTTONUP:
		m_fShowTimeSigProps = FALSE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pTimeSigMgr->m_pTimeline )
		{
			m_fInRightClickMenu = TRUE;
			m_pTimeSigMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
			m_fInRightClickMenu = FALSE;
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::Cut

HRESULT CTimeSigStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		return S_FALSE;
	}

	// Cut is simply a Copy followed by a Delete.
	hr = Copy(pITimelineDataObject);
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::Copy

HRESULT CTimeSigStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTimeSigMgr != NULL );
	if( m_pTimeSigMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfTimeSigList == 0 )
	{
		m_cfTimeSigList = RegisterClipboardFormat( CF_TIMESIGLIST );
		if( m_cfTimeSigList == 0 )
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	m_pTimeSigMgr->MarkSelectedTimeSigs(UD_DRAGSELECT);

	MUSIC_TIME mtTime;
	if( pITimelineDataObject )
	{
		long lMeasure, lBeat;

		// Get measure boundary of pITimelineDataObject clock
		if( FAILED( pITimelineDataObject->GetBoundaries( &mtTime, NULL ) ) )
		{
			return E_UNEXPECTED;
		}
		m_pTimeSigMgr->m_pTimeline->ClocksToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
		m_pTimeSigMgr->m_pTimeline->MeasureBeatToClocks( m_pTimeSigMgr->m_dwGroupBits, 0, lMeasure, 0, &mtTime );
	}
	else
	{
		// Get clock of first selected Time Sig's measure
		CTimeSigItem* pTimeSigAtDragPoint = m_pTimeSigMgr->FirstSelectedTimeSig();
		ASSERT( pTimeSigAtDragPoint != NULL );
		if( pTimeSigAtDragPoint == NULL )
		{
			return E_UNEXPECTED;
		}
		m_pTimeSigMgr->m_pTimeline->MeasureBeatToClocks( m_pTimeSigMgr->m_dwGroupBits, 0, pTimeSigAtDragPoint->m_dwMeasure, 0, &mtTime );
	}

	// Save the Time Sigs into the stream.
	hr = m_pTimeSigMgr->SaveSelectedTimeSigs( pStreamCopy, mtTime );
	if( FAILED( hr ))
	{
		RELEASE( pStreamCopy );
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfTimeSigList, pStreamCopy );
		RELEASE( pStreamCopy );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pTimeSigMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pTimeSigMgr->GetBoundariesOfSelectedTimeSigs( &lStartTime, &lEndTime );
		hr = pITimelineDataObject->SetBoundaries( lStartTime, lEndTime );

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfTimeSigList, pStreamCopy );

		// Release the IStream we copied into
		RELEASE( pStreamCopy );

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the IDMUSProdTimelineDataObject
		RELEASE( pITimelineDataObject );

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		RELEASE( m_pTimeSigMgr->m_pCopyDataObject);

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pTimeSigMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// m_pTimeSigMgr->m_pCopyDataObject->AddRef();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::PasteAt

HRESULT CTimeSigStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtPasteTime, BOOL fDropNotEditPaste, BOOL &fChanged)
{
	ASSERT( m_pTimeSigMgr != NULL );
	ASSERT( m_pTimeSigMgr->m_pTimeline != NULL );

	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Determine paste measure
	long lMeasure;
	long lBeat;
	m_pTimeSigMgr->m_pTimeline->ClocksToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits,
				 									  0,
													  mtPasteTime,
													  &lMeasure,
													  &lBeat );

	// Don't bother to do anything if user simply moved cursor within same measure in same strip
	if( fDropNotEditPaste )
	{
		if( m_nStripIsDragDropSource )
		{
			long lSourceMeasure;
			long lSourceBeat;
			if( SUCCEEDED ( m_pTimeSigMgr->m_pTimeline->PositionToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits,
																				0,
																				m_lStartDragPosition,
																				&lSourceMeasure,
																				&lSourceBeat ) ) )
			{
				if( lSourceMeasure == lMeasure )
				{
					return S_FALSE;
				}
			}
		}
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfTimeSigList ) == S_OK )
	{
		IStream* pIStream;
		
		if( m_nStripIsDragDropSource )
		{
			m_pTimeSigMgr->UnselectAllKeepBits();
		}
		else
		{
			m_pTimeSigMgr->UnselectAll();
		}

		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfTimeSigList, &pIStream)))
		{
			STATSTG StatStg;
			ZeroMemory( &StatStg, sizeof(STATSTG) );
			pIStream->Stat( &StatStg, STATFLAG_NONAME );
			hr = m_pTimeSigMgr->LoadTimeSigChunk( pIStream, StatStg.cbSize.LowPart, TRUE, mtPasteTime );
			if( hr == S_OK )
			{
				fChanged = TRUE;
			}
		}
	}

	if( m_nStripIsDragDropSource )
	{
		// Drag/drop Target and Source are the same TimeSig strip
		m_nStripIsDragDropSource = 2;
	}

	RELEASE( pIRiffStream );
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::Paste

HRESULT CTimeSigStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
	
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTimeSigMgr != NULL );
	if( m_pTimeSigMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		return S_FALSE;
	}

	ASSERT( m_pTimeSigMgr->m_pTimeline != NULL );
	if( m_pTimeSigMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfTimeSigList == 0 )
	{
		m_cfTimeSigList = RegisterClipboardFormat( CF_TIMESIGLIST );
		if( m_cfTimeSigList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfStyle == 0 )
	{
		m_cfStyle = RegisterClipboardFormat( CF_STYLE );
		if( m_cfStyle == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pTimeSigMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Determine paste measure
	MUSIC_TIME mtTime;
	long lMeasure, lBeat;
	if( m_bContextMenuPaste )
	{
		m_pTimeSigMgr->m_pTimeline->PositionToClocks( m_lXPos, &mtTime );
	}
	else
	{
		if( FAILED( m_pTimeSigMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}
	}
	m_pTimeSigMgr->m_pTimeline->ClocksToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
	m_pTimeSigMgr->m_pTimeline->MeasureBeatToClocks( m_pTimeSigMgr->m_dwGroupBits, 0, lMeasure, 0, &mtTime );

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pTimeSigMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		RELEASE( pITimelineDataObject );
		return E_FAIL;
	}

	BOOL fChanged = FALSE;

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd, lDiff;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			ASSERT( lStart < lEnd );

			lDiff = lEnd - lStart;
			lStart = mtTime;
			lEnd = lStart + lDiff;

			fChanged = m_pTimeSigMgr->DeleteBetweenTimes( lStart, lEnd );
		}
	}

	// Now, do the paste operation
	hr = PasteAt(pITimelineDataObject, mtTime, false, fChanged);
	RELEASE( pITimelineDataObject );

	// If S_OK, redraw our strip
	if( SUCCEEDED(hr)  &&  fChanged )
	{
		m_nLastEdit = IDS_PASTE;
		m_pTimeSigMgr->OnDataChanged();
		m_pTimeSigMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

		// Update the property page
		if( m_pTimeSigMgr->m_pPropPageMgr != NULL )
		{
			m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
		}

		m_pTimeSigMgr->SyncWithDirectMusic();

		// Notify the other strips of possible TimeSig change
		m_pTimeSigMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pTimeSigMgr->m_dwGroupBits, NULL );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::Insert

HRESULT CTimeSigStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = CanInsert();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		return S_FALSE;
	}

	// Unselect all items in this strip 
	m_pTimeSigMgr->UnselectAll();
	
	// Unselect items in other strips
	UnselectGutterRange();

	long	lMeasure, lBeat;
	CTimeSigItem* pTimeSig = NULL;
	BOOL fNewTimeSig = FALSE;
	if( m_pTimeSigMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	hr = m_pTimeSigMgr->m_pTimeline->PositionToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat );
	ASSERT( SUCCEEDED( hr ) );

	pTimeSig = GetTimeSigFromPoint( m_lXPos );
	if( pTimeSig == NULL )
	{
		pTimeSig = new CTimeSigItem( m_pTimeSigMgr );
		fNewTimeSig = TRUE;
	}
	if( pTimeSig == NULL )
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pTimeSig->m_dwMeasure = lMeasure;
		pTimeSig->SetSelectFlag( TRUE );
		pTimeSig->m_dwBits &= ~UD_FAKE;
		pTimeSig->m_TimeSignature.mtTime = 0;
		pTimeSig->m_TimeSignature.bBeatsPerMeasure = 4;
		pTimeSig->m_TimeSignature.bBeat = 4;
		pTimeSig->m_TimeSignature.wGridsPerBeat = 4;
		if( fNewTimeSig )
		{
			m_pTimeSigMgr->InsertByAscendingTime(pTimeSig);
		}

		// Redraw our strip
		m_pTimeSigMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

		// Display the property sheet
		DisplayPropertySheet(m_pTimeSigMgr->m_pTimeline);
		m_pTimeSigMgr->OnShowProperties();

		// If the property page manager exists, refresh it (it should exist)
		if( m_pTimeSigMgr->m_pPropPageMgr )
		{
			m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
		}

		// Update the Segment Designer
		m_nLastEdit = IDS_INSERT;
		m_pTimeSigMgr->OnDataChanged();

		// Sync with DirectMusic
		m_pTimeSigMgr->SyncWithDirectMusic();

		// Notify the other strips of possible TimeSig change
		m_pTimeSigMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pTimeSigMgr->m_dwGroupBits, NULL );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::Delete

HRESULT CTimeSigStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* Ignore this, since we can be in a Cut() operation.  We can cut blank data, but we can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		return S_FALSE;
	}

	ASSERT( m_pTimeSigMgr->m_pTimeline != NULL );
	if( m_pTimeSigMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pTimeSigMgr->DeleteSelectedTimeSigs();

	m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	if( m_pTimeSigMgr->m_pPropPageMgr )
	{
		m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
	}

	// Update the Segment Designer
	m_nLastEdit = IDS_DELETE;
	m_pTimeSigMgr->OnDataChanged();

	// Sync with DirectMusic
	m_pTimeSigMgr->SyncWithDirectMusic();

	// Notify the other strips of possible TimeSig change
	m_pTimeSigMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pTimeSigMgr->m_dwGroupBits, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::SelectAll

HRESULT CTimeSigStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeSigMgr != NULL );
	if( m_pTimeSigMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTimeSigMgr->m_pTimeline != NULL );
	if( m_pTimeSigMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pTimeSigMgr->SelectAll();

	m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::CanCut

HRESULT CTimeSigStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeSigMgr != NULL );
	if( m_pTimeSigMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		return S_FALSE;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pTimeSigMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pTimeSigMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pTimeSigMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::CanCopy

HRESULT CTimeSigStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pTimeSigMgr != NULL );
	if( m_pTimeSigMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pTimeSigMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pTimeSigMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pTimeSigMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	return m_pTimeSigMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::CanPaste

HRESULT CTimeSigStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr = S_FALSE;

	ASSERT( m_pTimeSigMgr != NULL );
	if( m_pTimeSigMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		return S_FALSE;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfTimeSigList == 0 )
	{
		m_cfTimeSigList = RegisterClipboardFormat( CF_TIMESIGLIST );
		if( m_cfTimeSigList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfStyle== 0 )
	{
		m_cfStyle = RegisterClipboardFormat( CF_STYLE );
		if( m_cfStyle == 0 )
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		if( (pITimelineDataObject->IsClipFormatAvailable( m_cfTimeSigList ) == S_OK)
		/*||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK)*/ )
		{
			hr = S_OK;
		}
		else
		{
			hr = S_FALSE;
		}
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pTimeSigMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					if( (pITimelineDataObject->IsClipFormatAvailable( m_cfTimeSigList ) == S_OK)
					/*||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK)*/ )
					{
						hr = S_OK;
					}
					else
					{
						hr = S_FALSE;
					}
				}
				RELEASE( pITimelineDataObject );
			}
			RELEASE( pIDataObject );
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::CanInsert

HRESULT CTimeSigStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeSigMgr != NULL );
	ASSERT( m_pTimeSigMgr->m_pTimeline != NULL );

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		return S_FALSE;
	}

	// Check for existing TimeSig
	if( m_lXPos >= 0 )
	{
		CPropTimeSig* pTimeSig = GetTimeSigFromPoint( m_lXPos );
		if( pTimeSig == NULL
		||  (pTimeSig->m_dwBits & UD_FAKE) )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::CanDelete

HRESULT CTimeSigStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		return S_FALSE;
	}

	return m_pTimeSigMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::CanSelectAll

HRESULT CTimeSigStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fInRightClickMenu == FALSE )
	{
		// Always enable when gutter is selected
		if( m_bGutterSelected )
		{
			return S_OK;
		}
	}

	CTimeSigItem* pTimeSigItem;

	POSITION pos = m_pTimeSigMgr->m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		pTimeSigItem = m_pTimeSigMgr->m_lstTimeSigs.GetNext( pos );

		if( !(pTimeSigItem->m_dwBits & UD_FAKE) )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::QueryContinueDrag

HRESULT CTimeSigStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::GiveFeedback

HRESULT CTimeSigStrip::GiveFeedback( DWORD dwEffect )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwEffect);

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::CreateDataObject

HRESULT	CTimeSigStrip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Convert lPosition from pixels to clocks
	long lMeasure, lBeat;
	if( FAILED( m_pTimeSigMgr->m_pTimeline->PositionToMeasureBeat( m_pTimeSigMgr->m_dwGroupBits, 0, lPosition, &lMeasure, &lBeat ) ) )
	{
		return E_UNEXPECTED;
	}
	long lClocks;
	if( FAILED( m_pTimeSigMgr->m_pTimeline->MeasureBeatToClocks( m_pTimeSigMgr->m_dwGroupBits, 0, lMeasure, 0, &lClocks ) ) )
	{
		return E_UNEXPECTED;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected TimeSigs into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pTimeSigMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// mark the time signatures as being dragged: this used later for deleting time signatures in drag move
		m_pTimeSigMgr->MarkSelectedTimeSigs(UD_DRAGSELECT);
		if( SUCCEEDED ( m_pTimeSigMgr->SaveSelectedTimeSigs( pIStream, lClocks ) ) )
		{
			// Place CF_TIMESIGLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfTimeSigList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;

}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::DragEnter

HRESULT CTimeSigStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::DragOver

HRESULT CTimeSigStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( m_pTimeSigMgr->m_fHaveStyleRefStrip )
	{
		*pdwEffect = dwEffect;
		return S_OK;
	}

	MUSIC_TIME mtTime;
	if( SUCCEEDED( m_pTimeSigMgr->m_pTimeline->PositionToClocks( pt.x, &mtTime ) ) )
	{
		if( (mtTime >= 0) && (CanPasteFromData( m_pITargetDataObject ) == S_OK) )
		{
			BOOL fCF_STYLE = FALSE;

			// Does m_pITargetDataObject contain format CF_STYLE?
			CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
			if( pDataObject )
			{
				/*
				if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfStyle ) ) )
				{
					fCF_STYLE = TRUE;
				}
				*/
				pDataObject->Release();
			}

			// Can only copy CF_STYLE data!
			if( fCF_STYLE )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( grfKeyState & MK_RBUTTON )
				{
					dwEffect = *pdwEffect;
				}
				else
				{
					if( grfKeyState & MK_CONTROL )
					{
						dwEffect = DROPEFFECT_COPY;
					}
					else
					{
						if( *pdwEffect & DROPEFFECT_COPY
						&&  *pdwEffect & DROPEFFECT_MOVE )
						{
							dwEffect = DROPEFFECT_MOVE;
						}
						else
						{
							dwEffect = *pdwEffect;
						}
					}
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::DragLeave

HRESULT CTimeSigStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		RELEASE( m_pITargetDataObject );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::Drop

HRESULT CTimeSigStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if( pWnd )
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pTimeSigMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				MUSIC_TIME mtTime;
				if( SUCCEEDED( m_pTimeSigMgr->m_pTimeline->PositionToClocks( pt.x, &mtTime ) ) )
				{
					BOOL fChanged = FALSE;
					hr = PasteAt( pITimelineDataObject, mtTime, true, fChanged );
					if( hr == S_OK )
					{
						*pdwEffect = m_dwOverDragEffect;

						if( fChanged )
						{
							if( m_nStripIsDragDropSource != 2 )
							{
								// Target strip is different from source strip
								m_nLastEdit = IDS_PASTE;
								m_pTimeSigMgr->OnDataChanged();
								m_pTimeSigMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

								// Update the property page
								if( m_pTimeSigMgr->m_pPropPageMgr != NULL )
								{
									m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
								}

								m_pTimeSigMgr->SyncWithDirectMusic();

								// Notify the other strips of possible TimeSig change
								m_pTimeSigMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pTimeSigMgr->m_dwGroupBits, NULL );
							}
						}
					}
					else if( hr == S_FALSE )
					{
						*pdwEffect = DROPEFFECT_NONE;
					}
				}
			}
			RELEASE( pITimelineDataObject );
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::GetTimelineCWnd

CWnd* CTimeSigStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
	if( m_pTimeSigMgr->m_pTimeline )
	{
		if( SUCCEEDED(m_pTimeSigMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return pWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::CanPasteFromData

HRESULT CTimeSigStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfTimeSigList ) )
	/*||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfStyle ) )*/ )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::GetData

HRESULT CTimeSigStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( ppData == NULL
	||	*ppData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case 0:
	{
		ioGroupBitsPPGData *pGroupBitsPPGData = reinterpret_cast<ioGroupBitsPPGData *>(*ppData);
		pGroupBitsPPGData->dwGroupBits = m_pTimeSigMgr->m_dwGroupBits;
		break;
	}
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pTimeSigMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pTimeSigMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	default:
		ASSERT(FALSE);
		break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::SetData

HRESULT CTimeSigStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case 0:
	{
		ioGroupBitsPPGData *pGroupBitsPPGData = reinterpret_cast<ioGroupBitsPPGData *>(pData);

		if( pGroupBitsPPGData->dwGroupBits != m_pTimeSigMgr->m_dwGroupBits )
		{
			DWORD dwOrigGroupBits = m_pTimeSigMgr->m_dwGroupBits; 
			m_pTimeSigMgr->m_dwGroupBits = pGroupBitsPPGData->dwGroupBits;

			m_nLastEdit = IDS_TRACK_GROUP;
			m_pTimeSigMgr->m_pTimeline->OnDataChanged( (ITimeSigMgr*)m_pTimeSigMgr );

			// Time signature may have changed
			m_pTimeSigMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature,
														 (dwOrigGroupBits | m_pTimeSigMgr->m_dwGroupBits),
														  NULL );
		}
		return S_OK;
		break;
	}
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pTimeSigMgr->m_dwTrackExtrasFlags )
		{
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pTimeSigMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;
			m_pTimeSigMgr->m_pTimeline->OnDataChanged( (ITimeSigMgr*)m_pTimeSigMgr );
		}
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pTimeSigMgr->m_dwProducerOnlyFlags )
		{
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pTimeSigMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;
			m_pTimeSigMgr->m_pTimeline->OnDataChanged( (ITimeSigMgr*)m_pTimeSigMgr );
		}
		return S_OK;
		break;
	}
	default:
		ASSERT(FALSE);
		break;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::OnShowProperties

HRESULT CTimeSigStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( m_pTimeSigMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pTimeSigMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	RELEASE( pIFramework );
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
	
		// release our reference to the property sheet
		RELEASE( pIPropSheet );
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM ) return E_OUTOFMEMORY;
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the Piano Roll property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pTimeSigMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	RELEASE( pIPropSheet );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::OnRemoveFromPageManager

HRESULT CTimeSigStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::DisplayPropertySheet

HRESULT CTimeSigStrip::DisplayPropertySheet(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				RELEASE( pIPropSheet );
			}
			RELEASE( punk );
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::DoDragDrop

BOOL CTimeSigStrip::DoDragDrop( void )
{
	// Drag drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pTimeSigMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Query ourself for our IDropSource interface
	IDropSource* pIDropSource;
	if( FAILED ( QueryInterface(IID_IDropSource, (void**)&pIDropSource) ) )
	{
		return FALSE;
	}

	DWORD dwEffect = DROPEFFECT_NONE;

	// Create a data object from the selected time signatures
	HRESULT hr = CreateDataObject( &m_pISourceDataObject, m_lStartDragPosition );
	if( SUCCEEDED( hr ) )
	{
		// We can always copy time signatures
		DWORD dwOKDragEffects = DROPEFFECT_COPY;
		if( CanCut() == S_OK )
		{
			// If we can Cut(), allow the user to move the time signatures as well.
			dwOKDragEffects |= DROPEFFECT_MOVE;
		}

		// Do the Drag/Drop.
		hr = ::DoDragDrop( m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect );

		switch( hr )
		{
			case DRAGDROP_S_DROP:
				if( dwEffect & DROPEFFECT_MOVE )
				{
					m_pTimeSigMgr->DeleteMarked( UD_DRAGSELECT );
				}
				break;

			default:
				dwEffect = DROPEFFECT_NONE;
				break;
		}
		hr = S_OK;
		RELEASE( m_pISourceDataObject );
	}

	RELEASE( pIDropSource );

	m_pTimeSigMgr->UnMarkTimeSigs(UD_DRAGSELECT);
	m_pTimeSigMgr->SyncWithDirectMusic();

	if( dwEffect != DROPEFFECT_NONE )
	{
		if( m_nStripIsDragDropSource == 2 )
		{
			// Drag/drop target and source are the same TimeSig strip
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_UNDO_MOVE;
				m_pTimeSigMgr->OnDataChanged();
				
				// Notify the other strips of possible TimeSig change
				m_pTimeSigMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pTimeSigMgr->m_dwGroupBits, NULL );
			}
			else
			{
				m_nLastEdit = IDS_PASTE;
				m_pTimeSigMgr->OnDataChanged();
				
				// Notify the other strips of possible TimeSig change
				m_pTimeSigMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pTimeSigMgr->m_dwGroupBits, NULL );
			}
		}
		else
		{
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_DELETE;
				m_pTimeSigMgr->OnDataChanged();
				
				// Notify the other strips of possible TimeSig change
				m_pTimeSigMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pTimeSigMgr->m_dwGroupBits, NULL );
			}
			else
			{
				m_pTimeSigMgr->UnselectAll();
			}
		}
	}

	if( dwEffect == DROPEFFECT_NONE )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::OnLButtonDown

HRESULT CTimeSigStrip::OnLButtonDown( WPARAM wParam, LONG lXPos)
{
	ASSERT( m_pTimeSigMgr != NULL );
	ASSERT( m_pTimeSigMgr->m_pTimeline != NULL );

	m_fSingleSelect = FALSE;

	// If we're already dragging, just return
	// TODO: Implement

	// Get Timeline length
	VARIANT var;
	m_pTimeSigMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Exit if user clicked past end of Strip
	long lClock;
	m_pTimeSigMgr->m_pTimeline->PositionToClocks( lXPos, &lClock );
	if( lClock >= lTimelineLength )
	{
		return S_OK;
	}
	
	// Unselect items in other strips
	UnselectGutterRange();

	HRESULT hr = S_OK;

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTimeSigMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// See if there is a time signature under the cursor.
	CTimeSigItem* pTimeSig = GetTimeSigFromPoint( lXPos );
	if( pTimeSig
	&&  !(pTimeSig->m_dwBits & UD_FAKE) )
	{
		// There is a TimeSig on this measure
		if( wParam & MK_CONTROL )
		{
			if( pTimeSig->m_fSelected )
			{
				// Do drag/drop
				m_dwStartDragButton = (unsigned long)wParam;
				m_lStartDragPosition = lXPos;
				m_nStripIsDragDropSource = 1;
		
				BOOL fDrop = DoDragDrop();

				m_dwStartDragButton = 0;
				m_nStripIsDragDropSource = 0;

				if( !fDrop )
				{
					pTimeSig->SetSelectFlag( !pTimeSig->m_fSelected );
				}
			}
			else
			{
				pTimeSig->SetSelectFlag( TRUE );

				// Set fields to initiate drag/drop on next mousemove
				m_dwStartDragButton = (unsigned long)wParam;
				m_lStartDragPosition = lXPos;

				m_dwShiftSelectFromMeasure = pTimeSig->m_dwMeasure;
			}
		}
		else if( wParam & MK_SHIFT )
		{
			pTimeSig->SetSelectFlag( TRUE );
			SelectRange( pTimeSig );
		}
		else
		{
			if( pTimeSig->m_fSelected == FALSE )
			{
				m_pTimeSigMgr->UnselectAll();
				pTimeSig->SetSelectFlag( TRUE );
			}
			else
			{
				m_fSingleSelect = TRUE;
			}
			
			// Set fields to initiate drag/drop on next mousemove
			m_dwStartDragButton = (unsigned long)wParam;
			m_lStartDragPosition = lXPos;
			m_dwShiftSelectFromMeasure = pTimeSig->m_dwMeasure;
		}
	}
	else
	{
		// There is not a "real" TimeSig on this measure
		hr = S_OK;
		if( pTimeSig == NULL )
		{
			// Create a "fake" TimeSig
			MUSIC_TIME mtTime = 0;
			m_pTimeSigMgr->m_pTimeline->PositionToClocks( lXPos, &mtTime );
			hr = m_pTimeSigMgr->CreateTimeSig( mtTime, pTimeSig );
		}

		if( SUCCEEDED ( hr ) )
		{
			if( wParam & MK_CONTROL )
			{
				pTimeSig->SetSelectFlag( !pTimeSig->m_fSelected );
				m_dwShiftSelectFromMeasure = pTimeSig->m_dwMeasure;
			}
			else if( wParam & MK_SHIFT )
			{
				pTimeSig->SetSelectFlag( TRUE );
				SelectRange( pTimeSig );
			}
			else
			{
				// Click on empty space deselects all
				m_pTimeSigMgr->UnselectAll();

				pTimeSig->SetSelectFlag( TRUE );
				m_dwShiftSelectFromMeasure = pTimeSig->m_dwMeasure;
			}
		}
	}

	// Redraw the strip and refresh the TimeSig property page
	m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	m_pTimeSigMgr->OnShowProperties();
	if( m_pTimeSigMgr->m_pPropPageMgr )
	{
		m_pTimeSigMgr->m_pPropPageMgr->RefreshData();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::OnRButtonDown

HRESULT CTimeSigStrip::OnRButtonDown( WPARAM wParam, LONG lXPos )
{
	ASSERT( m_pTimeSigMgr != NULL );
	ASSERT( m_pTimeSigMgr->m_pTimeline != NULL );

	// Get Timeline length
	VARIANT var;
	m_pTimeSigMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Exit if user clicked past end of Strip
	long lClock;
	m_pTimeSigMgr->m_pTimeline->PositionToClocks( lXPos, &lClock );
	if( lClock >= lTimelineLength )
	{
		return S_OK;
	}

	UnselectGutterRange();

	// Get the item at the mouse click.
	CTimeSigItem* pTimeSig = GetTimeSigFromPoint( lXPos );
	
	if( pTimeSig == NULL )
	{
		// No TimeSig so create a "fake" one
		m_pTimeSigMgr->UnselectAll();
		MUSIC_TIME mtTime = 0;
		m_pTimeSigMgr->m_pTimeline->PositionToClocks( lXPos, &mtTime );
		if( SUCCEEDED ( m_pTimeSigMgr->CreateTimeSig( mtTime, pTimeSig ) ) )
		{
			pTimeSig->SetSelectFlag( TRUE );
		}
	}
	else if( !(wParam & MK_CONTROL)
		 &&  !(wParam & MK_SHIFT) )
	{
		if( pTimeSig )
		{
			if( pTimeSig->m_fSelected == FALSE )
			{
				m_pTimeSigMgr->UnselectAll();
				pTimeSig->SetSelectFlag( TRUE );
			}
		}
	}

	m_pTimeSigMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	m_fShowTimeSigProps = TRUE;
	m_pTimeSigMgr->OnShowProperties(); 
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::UnselectGutterRange

void CTimeSigStrip::UnselectGutterRange( void )
{
	ASSERT( m_pTimeSigMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pTimeSigMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pTimeSigMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSigStrip::SelectRange

HRESULT CTimeSigStrip::SelectRange( CTimeSigItem* pTimeSig )
{
	HRESULT hr = S_OK;

	// Find measure for TimeSig to start from and TimeSig to end at
	DWORD dwEarlyMeasure = m_dwShiftSelectFromMeasure;
	DWORD dwLateMeasure = pTimeSig->m_dwMeasure;

	// If the order is backwards, swap
	if( dwLateMeasure < dwEarlyMeasure )
	{
		DWORD dwTemp = dwEarlyMeasure;
		dwEarlyMeasure = dwLateMeasure;
		dwLateMeasure = dwTemp;
	}

	// Add empty empty TimeSigs to fill in gaps
	CTimeSigItem* pTimeSigItem = NULL;
	DWORD dwCurrentMeasure = dwEarlyMeasure;
	while( dwCurrentMeasure <= dwLateMeasure )
	{
		if( GetTimeSigFromMeasureBeat(dwCurrentMeasure, 0) == NULL )
		{
			MUSIC_TIME mtPosition = 0;
			m_pTimeSigMgr->m_pTimeline->MeasureBeatToClocks( 
				m_pTimeSigMgr->m_dwGroupBits, 0, dwCurrentMeasure, 0, &mtPosition );
			pTimeSigItem = NULL;
			hr = m_pTimeSigMgr->CreateTimeSig( mtPosition, pTimeSigItem );
		}
		dwCurrentMeasure++;
	}

	// Unselect all TimeSigs in the strip
	m_pTimeSigMgr->UnselectAll();

	// Select all TimeSigs in the range (can't simply select TimeSigs in the
	// above loop, because there may be multiple TimeSigs at the same measure)
	POSITION pos = m_pTimeSigMgr->m_lstTimeSigs.GetHeadPosition();
	while( pos )
	{
		pTimeSigItem = m_pTimeSigMgr->m_lstTimeSigs.GetNext( pos );

		if( pTimeSigItem->m_dwMeasure >= dwEarlyMeasure
		&&	pTimeSigItem->m_dwMeasure <= dwLateMeasure )
		{
			pTimeSigItem->SetSelectFlag( TRUE );
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\Graph.cpp ===
// Graph.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "RiffStrm.h"
#include "Graph.h"
#include "GraphCtl.h"
#include "TabGraph.h"
#include "TabInfo.h"
#include <SegmentDesigner.h>
#include <AudioPathDesigner.h>
#include <dmusicf.h>
#include <mmreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// {D66E3599-5879-4bc4-A93A-3E05165E27F7}
static const GUID GUID_GraphPropPageManager = 
{ 0xd66e3599, 0x5879, 0x4bc4, { 0xa9, 0x3a, 0x3e, 0x5, 0x16, 0x5e, 0x27, 0xf7 } };

short CGraphPropPageManager::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CGraphPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGraphPropPageManager::CGraphPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabGraph = NULL;
	m_pTabInfo = NULL;
}

CGraphPropPageManager::~CGraphPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabGraph )
	{
		delete m_pTabGraph;
	}

	if( m_pTabInfo )
	{
		delete m_pTabInfo;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager::RemoveCurrentObject

void CGraphPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager IUnknown implementation

HRESULT CGraphPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CGraphPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CGraphPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CGraphPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_TOOLGRAPH_TEXT );

	CDirectMusicGraph *pGraph;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pGraph))) )
	{
		CString strNodeName;
		BSTR bstrNodeName;

		if( SUCCEEDED ( pGraph->GetNodeName( &bstrNodeName ) ) )
		{
			strNodeName = bstrNodeName;
			::SysFreeString( bstrNodeName );
		}
		strTitle = strNodeName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CGraphPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Graph tab
	m_pTabGraph = new CTabGraph( this );
	if( m_pTabGraph )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabGraph->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Info tab
	m_pTabInfo = new CTabInfo( this );
	if( m_pTabInfo )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabInfo->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CGraphPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CGraphPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CGraphPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CGraphPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CGraphPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CGraphPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicGraph* pGraph;
	
	if( m_pIPropPageObject == NULL )
	{
		pGraph = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pGraph ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Graph are processed in OnKillFocus
	// messages before setting the new Graph
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabGraph->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Graph
	m_pTabGraph->SetGraph( pGraph );
	m_pTabInfo->SetGraph( pGraph );

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CGraphPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_GraphPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph constructor/destructor

CDirectMusicGraph::CDirectMusicGraph()
{
	ASSERT( theApp.m_pGraphComponent != NULL );

	// Graph needs Graph Component
	theApp.m_pGraphComponent->AddRef();

    m_dwRef = 0;
	AddRef();

	m_pUndoMgr = NULL;
	m_fModified = FALSE;

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pIDMGraph = NULL;

	m_hWndEditor = NULL;
	m_pGraphCtrl = NULL;

	TCHAR achName[SMALL_BUFFER];
	::LoadString( theApp.m_hInstance, IDS_TOOLGRAPH_TEXT, achName, SMALL_BUFFER );
    m_strName.Format( "%s%d", achName, ++theApp.m_pGraphComponent->m_nNextGraph );

	CoCreateGuid( &m_guidGraph ); 
	m_vVersion.dwVersionMS = 0x00010000;
	m_vVersion.dwVersionLS = 0x00000000;
}

CDirectMusicGraph::~CDirectMusicGraph()
{
	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	// Remove Graph from clipboard
	theApp.FlushClipboard( this );

	// Remove Graph from property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	// Cleanup the Undo Manager
	if( m_pUndoMgr )
	{
		delete m_pUndoMgr;
	}

	// Cleanup references
	RELEASE( m_pIDMGraph );

	// Release tools
	CTool* pTool;
	while( !m_lstGraphTools.IsEmpty() )
	{
		pTool = m_lstGraphTools.RemoveHead();
		RELEASE( pTool );
	}

	// Delete PChannel groups
	CPChannelGroup* pPChannelGroup;
	while( !m_lstGraphPChannelGroups.IsEmpty() )
	{
		pPChannelGroup = m_lstGraphPChannelGroups.RemoveHead();
		delete pPChannelGroup;
	}

	// Release Graph users
	IUnknown* pIUnknown;
	while( !m_lstGraphUsers.IsEmpty() )
	{
		pIUnknown = m_lstGraphUsers.RemoveHead();
		RELEASE( pIUnknown );
	}

	// Graph no longer needs Graph Component
	theApp.m_pGraphComponent->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::CreateUndoMgr

BOOL CDirectMusicGraph::CreateUndoMgr()
{
	// Should only be called once - after Graph first created
	ASSERT( m_pUndoMgr == NULL );

	ASSERT( theApp.m_pGraphComponent != NULL ); 
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL ); 

	m_pUndoMgr = new CJazzUndoMan( theApp.m_pGraphComponent->m_pIFramework );
	if( m_pUndoMgr )
	{
		m_pUndoMgr->SetStreamAttributes( FT_DESIGN, GUID_CurrentVersion );
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::MyEnumTools

CTool* CDirectMusicGraph::MyEnumTools( int nToolIndex )
{
	CTool* pTool = NULL;

	POSITION pos = m_lstGraphTools.FindIndex( nToolIndex );
	if( pos )
	{
		pTool = m_lstGraphTools.GetAt( pos );
	}

	return pTool;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::IndexToTool

CTool* CDirectMusicGraph::IndexToTool( int nToolIndex )
{
	CTool* pTheTool = NULL;

	int nNbrTools = m_lstGraphTools.GetCount();

	if( nToolIndex >= 0
	&&  nToolIndex < nNbrTools )
	{
		POSITION pos = m_lstGraphTools.FindIndex( nToolIndex );
		if( pos )
		{
			pTheTool = m_lstGraphTools.GetAt( pos );
		}
	}

	return pTheTool;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::GetFirstSelectedTool

CTool* CDirectMusicGraph::GetFirstSelectedTool( void )
{
	CTool* pTool = NULL;

	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pToolList = m_lstGraphTools.GetNext( pos );

		if( pToolList->m_fSelected )
		{
			pTool = pToolList;
			break;
		}
	}

	return pTool;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::IsToolNameUnique

BOOL CDirectMusicGraph::IsToolNameUnique( CTool* pTool )
{
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pToolList = m_lstGraphTools.GetNext( pos );
		if( pToolList != pTool )
		{
			if( pToolList->m_strName.CompareNoCase( pTool->m_strName ) == 0 )
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::GetUniqueToolName

void CDirectMusicGraph::GetUniqueToolName( CTool* pTool )
{
	CString	strOrigName;
	CString	strNbr;
	int	nOrigNameLength;
	int	nNbrLength;
	int	i;

	if( pTool->m_strName.IsEmpty() )
	{
		theApp.m_pGraphComponent->GetRegisteredToolName( pTool->m_clsidTool, pTool->m_strName );
		pTool->m_strName += _T( "1" );
	}
	ASSERT( pTool->m_strName.IsEmpty() == FALSE );

	if( pTool->m_strName.GetLength() > DMUS_MAX_NAME )
	{
		pTool->m_strName = pTool->m_strName.Left( DMUS_MAX_NAME );
		pTool->m_strName.TrimRight();
	}

	strOrigName = pTool->m_strName;

	i = 0;
	while( !strOrigName.IsEmpty()  &&  _istdigit(strOrigName[strOrigName.GetLength() - 1]) )
	{
		strNbr = strOrigName.Right(1) + strNbr;
		strOrigName = strOrigName.Left( strOrigName.GetLength() - 1 );
		if( ++i > 6 )
		{
			break;
		}
	}

	nOrigNameLength = strOrigName.GetLength();
	i = _ttoi( strNbr );

	while( IsToolNameUnique( pTool ) == FALSE )
	{
		strNbr.Format( "%d", ++i ); 
		nNbrLength = strNbr.GetLength();
		
		if( (nOrigNameLength + nNbrLength) <= DMUS_MAX_NAME )
		{
			pTool->m_strName = strOrigName + strNbr;
		}
		else
		{
			pTool->m_strName = strOrigName.Left(DMUS_MAX_NAME - nNbrLength) + strNbr;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::ToolToIndex

int CDirectMusicGraph::ToolToIndex( CTool* pTool )
{
	int nTheIndex = 0;

	if( pTool )
	{
		int nIndex = 0;

		POSITION pos = m_lstGraphTools.GetHeadPosition();
		while( pos )
		{
			CTool* pToolList = m_lstGraphTools.GetNext( pos );

			if( pToolList == pTool )
			{
				nTheIndex = nIndex;
				break;
			}

			nIndex++;
		}

	}

	return nTheIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::SyncGraphEditor

void CDirectMusicGraph::SyncGraphEditor( void )
{
	if( m_pGraphCtrl
	&&  m_pGraphCtrl->m_pGraphDlg )
	{
		m_pGraphCtrl->m_pGraphDlg->RefreshControls();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::ResetContentGraphEditor

void CDirectMusicGraph::ResetContentGraphEditor( void )
{
	if( m_pGraphCtrl
	&&  m_pGraphCtrl->m_pGraphDlg )
	{
		m_pGraphCtrl->m_pGraphDlg->ResetContent();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::SyncGraphWithDirectMusic

HRESULT CDirectMusicGraph::SyncGraphWithDirectMusic( void )
{
	CWaitCursor wait;
	IStream* pIMemStream;
	IPersistStream* pIPersistStream;
	HRESULT hr;

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	// Make sure we have a DirectMusic Engine Graph
	if( m_pIDMGraph == NULL )
	{
		if( FAILED ( ::CoCreateInstance( CLSID_DirectMusicGraph, NULL, CLSCTX_INPROC_SERVER,
										 IID_IDirectMusicGraph, (void**)&m_pIDMGraph ) ) )
		{
			RELEASE( m_pIDMGraph );
		}
	}

	if( m_pIDMGraph == NULL )
	{
		// Nothing to do
		return S_OK;
	}

	hr = theApp.m_pGraphComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );

	if( SUCCEEDED ( hr ) )
	{
		hr = Save( pIMemStream, FALSE );
		if( SUCCEEDED ( hr ) )
		{
			m_pIDMGraph->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
			if( pIPersistStream )
			{
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				hr = pIPersistStream->Load( pIMemStream );

				RELEASE( pIPersistStream );
			}
		}

		RELEASE( pIMemStream );
	}

	// Make sure all "copies" of toolgraph have been updated
	POSITION pos = m_lstGraphUsers.GetHeadPosition();
	while( pos )
	{
		IUnknown* pIUnknown = m_lstGraphUsers.GetNext( pos );

		SyncGraphUser_RemoveTools( pIUnknown );
		SyncGraphUser_AddTools( pIUnknown );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::SetModified

void CDirectMusicGraph::SetModified( BOOL fModified )
{
	m_fModified = fModified;

	if( m_fModified )
	{
		if( m_pIDocRootNode
		&&  m_pIDocRootNode != this )
		{
			// Notify DocRoot that the toolgraph has changed
			IDMUSProdNotifySink* pINotifySink;
			if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
			{
				pINotifySink->OnUpdate( this, TOOLGRAPH_ChangeNotification, NULL );

				RELEASE( pINotifySink );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IUnknown implementation

HRESULT CDirectMusicGraph::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdNode *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersist) )
    {
        *ppvObj = (IPersist *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        *ppvObj = (IPersistStream *)this;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdToolGraphInfo) )
    {
        *ppvObj = (IDMUSProdToolGraphInfo *)this;
    }
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CDirectMusicGraph::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CDirectMusicGraph::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetNodeImageIndex

HRESULT CDirectMusicGraph::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );

	return( theApp.m_pGraphComponent->GetGraphImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetFirstChild

HRESULT CDirectMusicGraph::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// Graph node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetNextChild

HRESULT CDirectMusicGraph::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// Graph node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetComponent

HRESULT CDirectMusicGraph::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );

	return theApp.m_pGraphComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetDocRootNode

HRESULT CDirectMusicGraph::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::SetDocRootNode

HRESULT CDirectMusicGraph::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetParentNode

HRESULT CDirectMusicGraph::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::SetParentNode

HRESULT CDirectMusicGraph::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetNodeId

HRESULT CDirectMusicGraph::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ToolGraphNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetNodeName

HRESULT CDirectMusicGraph::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetNodeNameMaxLength

HRESULT CDirectMusicGraph::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = DMUS_MAX_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::ValidateNodeName

HRESULT CDirectMusicGraph::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	::SysFreeString( bstrName );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::SetNodeName

HRESULT CDirectMusicGraph::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_strName == strName )
	{
		return S_OK;
	}

	m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_GRAPH_NAME );
	m_strName = strName;

	// Sync change with property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		RELEASE( pIPropSheet );
	}
	
	SyncGraphWithDirectMusic();
	SetModified( TRUE );

	if( m_pIDocRootNode
	&&  m_pIDocRootNode != this )
	{
		// Notify DocRoot node that ToolGraph name has changed
		IDMUSProdNotifySink* pINotifySink;

		if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
		{
			pINotifySink->OnUpdate( this, TOOLGRAPH_NameChange, NULL  );
			pINotifySink->Release();
		}
	}
	else
	{
		// Notify connected nodes that ToolGraph name has changed
		theApp.m_pGraphComponent->m_pIFramework->NotifyNodes( this, TOOLGRAPH_NameChange, NULL );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetNodeListInfo

HRESULT CDirectMusicGraph::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strDescriptor;

    pListInfo->bstrName = m_strName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_guidGraph, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetEditorClsId

HRESULT CDirectMusicGraph::GetEditorClsId( CLSID* pClsId )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   *pClsId = CLSID_GraphEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetEditorTitle

HRESULT CDirectMusicGraph::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_TOOLGRAPH_TEXT, achTitle, MID_BUFFER );
	strTitle  = achTitle;
	strTitle += _T(": " );
	strTitle += m_strName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetEditorWindow

HRESULT CDirectMusicGraph::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::SetEditorWindow

HRESULT CDirectMusicGraph::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::UseOpenCloseImages

HRESULT CDirectMusicGraph::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetRightClickMenuId

HRESULT CDirectMusicGraph::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_GRAPH_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::OnRightClickMenuInit

HRESULT CDirectMusicGraph::OnRightClickMenuInit( HMENU hMenu )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::OnRightClickMenuSelect

HRESULT CDirectMusicGraph::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_RENAME:
			hr = theApp.m_pGraphComponent->m_pIFramework->EditNodeLabel( this );
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::DeleteChildNode

HRESULT CDirectMusicGraph::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// Graph nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::InsertChildNode

HRESULT CDirectMusicGraph::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// Graph nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::DeleteNode

HRESULT CDirectMusicGraph::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIParentNode;

	// Let our parent delete us
	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			RELEASE( pIParentNode );
			return hr;
		}
	}

	// No parent so we will delete ourself
	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	// Remove from Project Tree
	if( theApp.m_pGraphComponent->m_pIFramework->RemoveNode( this, fPromptUser ) == S_FALSE )
	{
		// User cancelled delete
		return E_FAIL;
	}

	// Remove from Component Graph list
	theApp.m_pGraphComponent->RemoveFromGraphFileList( this );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::OnNodeSelChanged

HRESULT CDirectMusicGraph::OnNodeSelChanged( BOOL fSelected )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::CreateDataObject

HRESULT CDirectMusicGraph::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Graph into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_GRAPH into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pGraphComponent->m_cfGraph, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->SaveClipFormat( theApp.m_pGraphComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// Graph nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pGraphComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			RELEASE( pIStream );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::CanCut

HRESULT CDirectMusicGraph::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::CanCopy

HRESULT CDirectMusicGraph::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::CanDelete

HRESULT CDirectMusicGraph::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode != this )
	{
		ASSERT( m_pIParentNode != NULL );

		return m_pIParentNode->CanDeleteChildNode( this );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::CanDeleteChildNode

HRESULT CDirectMusicGraph::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// Graph node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::CanPasteFromData

HRESULT CDirectMusicGraph::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}
	
	if( m_pIDocRootNode != this )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent node decide what can be dropped
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::PasteFromData

HRESULT CDirectMusicGraph::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode != this )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle paste
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}
	
	ASSERT( 0 );	// Should not happen!
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::CanChildPasteFromData

HRESULT CDirectMusicGraph::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	ASSERT( 0 );

	return E_NOTIMPL;	// Graph nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::ChildPasteFromData

HRESULT CDirectMusicGraph::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Graph nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNode::GetObject

HRESULT CDirectMusicGraph::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Must be asking for an interface to a CLSID_DMGraph object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicGraph ) )
	{
		if( m_pIDMGraph )
		{
			return m_pIDMGraph->QueryInterface( riid, ppvObject );
		}
	}

    *ppvObject = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdPropPageObject::GetData

HRESULT CDirectMusicGraph::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdPropPageObject::SetData

HRESULT CDirectMusicGraph::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdPropPageObject::OnShowProperties

HRESULT CDirectMusicGraph::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	// Get the Graph page manager
	CGraphPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_GraphPropPageManager ) == S_OK )
	{
		pPageManager = (CGraphPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CGraphPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Graph properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CGraphPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CDirectMusicGraph::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IPersist::GetClassID

HRESULT CDirectMusicGraph::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IPersistStream::IsDirty

HRESULT CDirectMusicGraph::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fModified )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::LoadUIState

HRESULT CDirectMusicGraph::LoadUIState( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*      pIStream;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
	DWORD		  dwPos;
    HRESULT       hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_GRAPH_UI_CHUNK:
				dwSize = min( ck.cksize, sizeof(GraphUI) );
				hr = pIStream->Read( &m_GraphUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_PCHANNELGROUP_UI_LIST: 
					{
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_PCHANNELGROUP_UI_CHUNK:
								{
									CPChannelGroup* pPChannelGroup = new CPChannelGroup();
									if( pPChannelGroup == NULL )
									{
										hr = E_OUTOFMEMORY;
										goto ON_ERROR;
									}
									hr = pIStream->Read( &pPChannelGroup->m_dwNbrPChannels, sizeof(DWORD), &dwByteCount );
									if( FAILED( hr )
									||  dwByteCount != sizeof(DWORD) )
									{
										hr = E_FAIL;
										delete pPChannelGroup;
										goto ON_ERROR;
									}
									pPChannelGroup->m_pdwPChannel = new DWORD[pPChannelGroup->m_dwNbrPChannels];
									if( pPChannelGroup->m_pdwPChannel == NULL )
									{
										hr = E_OUTOFMEMORY;
										delete pPChannelGroup;
										goto ON_ERROR;
									}
									dwSize = pPChannelGroup->m_dwNbrPChannels * sizeof(DWORD);
									ASSERT( dwSize == (ckList.cksize - sizeof(DWORD)) );
									hr = pIStream->Read( pPChannelGroup->m_pdwPChannel, dwSize, &dwByteCount );
									if( FAILED( hr )
									||  dwByteCount != dwSize )
									{
										hr = E_FAIL;
										delete pPChannelGroup;
										goto ON_ERROR;
									}
									InsertPChannelGroup( pPChannelGroup );
									break;
								}
							}
							pIRiffStream->Ascend( &ckList, 0 );
						}
					}
				}
				break;
		}

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::LoadGraph

HRESULT CDirectMusicGraph::LoadGraph( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*      pIStream;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
	DWORD		  dwPos;
    HRESULT       hr = S_OK;

	ASSERT( theApp.m_pGraphComponent != NULL );

	// Clear the Graph to prepare for load
	{
		// Remove pointers from Graph editor (when open)
		ResetContentGraphEditor();

		// Following strings only saved when they have values
		// So make sure they are initialized!!
		m_strAuthor.Empty();
		m_strCopyright.Empty();
		m_strSubject.Empty();
		m_strInfo.Empty();

		// Release tools
		CTool* pTool;
		while( !m_lstGraphTools.IsEmpty() )
		{
			pTool = m_lstGraphTools.RemoveHead();
			RELEASE( pTool );
		}

		// Delete PChannel groups
		CPChannelGroup* pPChannelGroup;
		while( !m_lstGraphPChannelGroups.IsEmpty() )
		{
			pPChannelGroup = m_lstGraphPChannelGroups.RemoveHead();
			delete pPChannelGroup;
		}
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_GUID_CHUNK:
				dwSize = min( ck.cksize, sizeof( GUID ) );
				hr = pIStream->Read( &m_guidGraph, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
			{
			    DMUS_IO_VERSION dmusVersionIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
				hr = pIStream->Read( &dmusVersionIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_vVersion.dwVersionMS = dmusVersionIO.dwVersionMS;
				m_vVersion.dwVersionLS = dmusVersionIO.dwVersionLS;
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
								{
									CString strName;

									ReadMBSfromWCS( pIStream, ckList.cksize, &strName );
									if( strName.CompareNoCase( m_strName ) != 0 )
									{
										m_strName = strName;
										theApp.m_pGraphComponent->m_pIFramework->RefreshNode( this );

										// Notify connected nodes that the Graph name has changed
										theApp.m_pGraphComponent->m_pIFramework->NotifyNodes( this, TOOLGRAPH_NameChange, NULL );
									}
									break;
								}

								case DMUS_FOURCC_UART_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
									break;

								case DMUS_FOURCC_UCOP_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
									break;

								case DMUS_FOURCC_USBJ_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
									break;

								case DMUS_FOURCC_UCMT_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strInfo );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_GRAPH_UI_LIST:
						hr = LoadUIState( pIRiffStream, &ck );
						if( FAILED ( hr ) )
						{
							goto ON_ERROR;
						}
						break;

					case DMUS_FOURCC_TOOL_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_RIFF:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_TOOL_FORM: 
										{
											CTool* pTool = new CTool();
											if( pTool == NULL )
											{
												hr = E_OUTOFMEMORY;
												goto ON_ERROR;
											}
											hr = pTool->LoadTool( pIRiffStream, &ckList );
											if( FAILED ( hr ) )
											{
												RELEASE( pTool );
												goto ON_ERROR;
											}
											if( hr == S_FALSE )
											{
												hr = S_OK;
												RELEASE( pTool );
											}
											else
											{
												InsertTool( pTool, -1 );
												RELEASE( pTool );
											}
											break;
										}
									}
									break;
							}
							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

	// Refresh Graph editor (when open)
	SyncGraphEditor();

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IPersistStream::Load

HRESULT CDirectMusicGraph::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

    DWORD dwPos = StreamTell( pIStream );

	// Check for Direct Music format
	BOOL fFoundFormat = FALSE;
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_TOOLGRAPH_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			fFoundFormat = TRUE;
			hr = LoadGraph( pIRiffStream, &ckMain );
		}

		RELEASE( pIRiffStream );
	}

	if( m_pIDocRootNode )
	{
		// Already in Project Tree so sync changes
		// Sync change with property sheet
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RefreshTitle();
			pIPropSheet->RefreshActivePage();
			RELEASE( pIPropSheet );
		}
	}

	//	Persist Graph to the DirectMusic DLLs.
	if( SUCCEEDED( hr ) )
	{
		SyncGraphWithDirectMusic();
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph Refresh
    
void CDirectMusicGraph::Refresh( void )
{
	// Sync changes with editor
	SyncGraphEditor();

	// Sync change with property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitle();
		pIPropSheet->RefreshActivePage();
		RELEASE( pIPropSheet );
	}

	// Sync changes with DMusic DLLs
	SyncGraphWithDirectMusic();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::GetName

void CDirectMusicGraph::GetName( CString& strName )
{
	strName = m_strName;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph SaveInfoList
    
HRESULT CDirectMusicGraph::SaveInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_strName.IsEmpty()
	&&  m_strAuthor.IsEmpty()
	&&  m_strCopyright.IsEmpty()
	&&  m_strSubject.IsEmpty() 
	&&  m_strInfo.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Graph name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Graph author
	if( !m_strAuthor.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strAuthor );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Graph copyright
	if( !m_strCopyright.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCOP_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCopyright );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Graph subject
	if( !m_strSubject.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_USBJ_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strSubject );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Graph comments
	if( !m_strInfo.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCMT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strInfo );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph SaveVersion
    
HRESULT CDirectMusicGraph::SaveVersion( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_VERSION dmusVersionIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Version chunk header
	ck.ckid = DMUS_FOURCC_VERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_VERSION structure
	memset( &dmusVersionIO, 0, sizeof(DMUS_IO_VERSION) );

	dmusVersionIO.dwVersionMS = m_vVersion.dwVersionMS ;
	dmusVersionIO.dwVersionLS = m_vVersion.dwVersionLS;

	// Write Version chunk data
	hr = pIStream->Write( &dmusVersionIO, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph SaveGUID
    
HRESULT CDirectMusicGraph::SaveGUID( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write GUID chunk header
	ck.ckid = DMUS_FOURCC_GUID_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Graph GUID
	hr = pIStream->Write( &m_guidGraph, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph SaveUIState
    
HRESULT CDirectMusicGraph::SaveUIState( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ckList;
    MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Don't need to save unless this is a design stream
	if( ftFileType != FT_DESIGN )
	{
		hr = S_OK;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_GRAPH_UI_LIST header
	ckMain.fccType = DMUS_FOURCC_GRAPH_UI_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save DMUS_FOURCC_GRAPH_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_GRAPH_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write GraphUI data
		hr = pIStream->Write( &m_GraphUI, sizeof(GraphUI), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(GraphUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save DMUS_FOURCC_PCHANNELGROUP_UI_LIST chunk
	{
		ckList.fccType = DMUS_FOURCC_PCHANNELGROUP_UI_LIST;
		if( pIRiffStream->CreateChunk(&ckList, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Save PChannel groups
		{
			CPChannelGroup* pPChannelGroup;
			DWORD dwSize;
			POSITION pos;

			pos = m_lstGraphPChannelGroups.GetHeadPosition();
			while( pos )
			{
				pPChannelGroup = m_lstGraphPChannelGroups.GetNext( pos );

				// Save DMUS_FOURCC_PCHANNELGROUP_UI_CHUNK chunk
				ck.ckid = DMUS_FOURCC_PCHANNELGROUP_UI_CHUNK;
				if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Write number of elements in PChannel array
				hr = pIStream->Write( &pPChannelGroup->m_dwNbrPChannels, sizeof(DWORD), &dwBytesWritten);
				if( FAILED( hr )
				||  dwBytesWritten != sizeof(DWORD) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Write PChannel array
				dwSize = pPChannelGroup->m_dwNbrPChannels * sizeof(DWORD);
				hr = pIStream->Write( pPChannelGroup->m_pdwPChannel, dwSize, &dwBytesWritten);
				if( FAILED( hr )
				||  dwBytesWritten != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			
				if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
				{
 					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
		
		if( pIRiffStream->Ascend( &ckList, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph SaveGraph
    
HRESULT CDirectMusicGraph::SaveGraph( IDMUSProdRIFFStream* pIRiffStream )
{
	HRESULT hr = S_OK;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

// Save Graph GUID
	hr = SaveGUID( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Graph version
	hr = SaveVersion( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Graph info
	hr = SaveInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Graph UI
	hr = SaveUIState( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Tools
	{
		POSITION pos;
		MMCKINFO ck;

		ck.fccType = DMUS_FOURCC_TOOL_LIST;
		if( pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		pos = m_lstGraphTools.GetHeadPosition();
		while( pos )
		{
			CTool* pTool = m_lstGraphTools.GetNext( pos );
			hr = pTool->SaveTool( pIRiffStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IPersistStream::Save

HRESULT CDirectMusicGraph::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	// Validate requested data format
	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion )
	||  IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject )
	||  IsEqualGUID( StreamInfo.guidDataFormat, GUID_SaveSelectedTools ) )
	{
		// DirectMusic format
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_TOOLGRAPH_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveGraph( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}

				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IPersistStream::GetSizeMax

HRESULT CDirectMusicGraph::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdNotifySink implementation

///////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph  IDMUSProdNotifySink::OnUpdate

HRESULT CDirectMusicGraph::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDocRootNode);
	UNREFERENCED_PARAMETER(guidUpdateType);
	UNREFERENCED_PARAMETER(pData);

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdToolGraphInfo implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdToolGraphInfo::EnumTools

HRESULT CDirectMusicGraph::EnumTools( DWORD dwToolIndex, IUnknown** ppIDirectMusicTool )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDirectMusicTool == NULL )
	{
		return E_POINTER;
	}
	*ppIDirectMusicTool = NULL;

	POSITION pos = m_lstGraphTools.FindIndex( dwToolIndex );
	if( pos )
	{
		CTool* pTool = m_lstGraphTools.GetAt( pos );

		ASSERT( pTool->m_pIDMTool != NULL );
		if( pTool->m_pIDMTool )
		{
			pTool->m_pIDMTool->AddRef();
			*ppIDirectMusicTool = pTool->m_pIDMTool;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CompareDWORD()

static int __cdecl CompareDWORD( const void* arg1, const void* arg2 )
{
	if( *(DWORD**)arg1 < *(DWORD**)arg2 )
	{
		return -1;
	}
	if( *(DWORD**)arg1 > *(DWORD**)arg2 )
	{
		return 1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdToolGraphInfo::GetToolInfo

HRESULT CDirectMusicGraph::GetToolInfo( IUnknown* pIDirectMusicTool, DMUSProdToolInfo* pToolInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDirectMusicTool == NULL 
	||  pToolInfo == NULL
	||  pToolInfo->wSize == 0 )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	IDirectMusicTool* pIDMTool;
	if( SUCCEEDED ( pIDirectMusicTool->QueryInterface( IID_IDirectMusicTool, (void**)&pIDMTool ) ) )
	{
		POSITION pos = m_lstGraphTools.GetHeadPosition();
		while( pos )
		{
			CTool* pTool = m_lstGraphTools.GetNext( pos );

			if( pTool->m_pIDMTool == pIDMTool )
			{
				// Build the PChannel array
				CDWordArray aPChannels;
				POSITION pos = pTool->m_lstPChannelGroups.GetHeadPosition();
				while( pos )
				{
					CPChannelGroup* pPChannelGroup = pTool->m_lstPChannelGroups.GetNext( pos );

					for( DWORD i = 0 ;  i < pPChannelGroup->m_dwNbrPChannels ; i++ )
					{
						aPChannels.Add( pPChannelGroup->m_pdwPChannel[i] );
					}
				}

				// Sort the PChannel array
				qsort( aPChannels.GetData(), aPChannels.GetSize(), sizeof(DWORD), CompareDWORD );

				// Set CLSID
				pToolInfo->clsidTool = pTool->m_clsidTool;

				// Set dwFirstPChannel
				if( aPChannels.GetSize() > 0 )
				{
					pToolInfo->dwFirstPChannel = aPChannels[0];
				}
				else
				{
					// This Tool has no PChannels
					//	We must force use of a bogus PChannel
					//	so that tool has no effect
					pToolInfo->dwFirstPChannel = TOOL_NO_PCHANNELS;
				}

				// Set awchToolName
				if( MultiByteToWideChar( CP_ACP, 0, pTool->m_strName, -1, pToolInfo->awchToolName, 65 ) )
				{
					// For PChannels text
					CString strText;
					if( aPChannels.GetSize() > 0 )
					{
						CPChannelGroup* pPChannelGroup = new CPChannelGroup();
						if( pPChannelGroup )
						{
							// Create a new array to store the PChannels in
							DWORD *pdwNewPChannels = new DWORD[aPChannels.GetSize()];
							if( pdwNewPChannels )
							{
								// Copy the PChannels into the new array
								memcpy( pdwNewPChannels, aPChannels.GetData(), sizeof(DWORD) * aPChannels.GetSize() );

								// Set the size of, and point to the new array
								pPChannelGroup->m_pdwPChannel = pdwNewPChannels;
								pPChannelGroup->m_dwNbrPChannels = aPChannels.GetSize();

								// Format text
								pPChannelGroup->FormatPChannelText( strText );
							}
								
							delete pPChannelGroup;
						}
					}

					// Set awchPChannels
					if( MultiByteToWideChar( CP_ACP, 0, strText, -1, pToolInfo->awchPChannels, 128 ) )
					{
						hr = S_OK;
					}
				}
			}
		}

		RELEASE( pIDMTool );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdToolGraphInfo::GetToolCount

HRESULT CDirectMusicGraph::GetToolCount( DWORD* pdwNbrTools )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pdwNbrTools == NULL )
	{
		return E_POINTER;
	}

	*pdwNbrTools = m_lstGraphTools.GetCount();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdToolGraphInfo::AddToGraphUserList

HRESULT CDirectMusicGraph::AddToGraphUserList( IUnknown* pIUnknown )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIUnknown == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure pIUnknown is not already in the list
	POSITION pos = m_lstGraphUsers.GetHeadPosition();
	while( pos )
	{
		IUnknown* pIUnknownList = m_lstGraphUsers.GetNext( pos );

		if( pIUnknownList == pIUnknown )
		{
			return S_OK;
		}
	}

	// Place pIUnknown in the list
	pIUnknown->AddRef();
	m_lstGraphUsers.AddTail( pIUnknown );

	// Sync corresponding graph
	SyncGraphUser_AddTools( pIUnknown );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdToolGraphInfo::RemoveFromGraphUserList

HRESULT CDirectMusicGraph::RemoveFromGraphUserList( IUnknown* pIUnknown )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIUnknown == NULL )
	{
		return E_INVALIDARG;
	}

	// If item is in m_lstGraphUsers, remove it
	POSITION pos = m_lstGraphUsers.Find( pIUnknown );
	if( pos )
	{
		// Sync corresponding graph
		SyncGraphUser_RemoveTools( pIUnknown );

		// Release our reference on the interface
		pIUnknown->Release();

		// Remove from list
		m_lstGraphUsers.RemoveAt( pos );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph Additional functions

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::ReadListInfoFromStream

HRESULT CDirectMusicGraph::ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString strName;
	CString strDescriptor;
	GUID guidGraph;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidGraph, 0, sizeof(GUID) );

    DWORD dwPos = StreamTell( pIStream );

	// Check for Direct Music format
	BOOL fFoundFormat = FALSE;
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_TOOLGRAPH_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			fFoundFormat = TRUE;

			// Get Graph GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidGraph, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidGraph, 0, sizeof(GUID) );
				}
			}

			// Get Graph name
			ck.fccType = DMUS_FOURCC_UNFO_LIST;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	if( !strName.IsEmpty() )
	{
		pListInfo->bstrName = strName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidGraph, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::GetObjectDescriptor

HRESULT CDirectMusicGraph::GetObjectDescriptor( void* pObjectDesc )
{
	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &m_guidGraph, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicGraph, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_strName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::InsertPChannelGroup

void CDirectMusicGraph::InsertPChannelGroup( CPChannelGroup* pPChannelGroupToInsert )
{
	if( pPChannelGroupToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	ASSERT( pPChannelGroupToInsert->m_dwNbrPChannels > 0 );

	CPChannelGroup* pPChannelGroup;
	POSITION posCurrent, posNext = m_lstGraphPChannelGroups.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pPChannelGroup = m_lstGraphPChannelGroups.GetNext( posNext );

		ASSERT( pPChannelGroup->m_dwNbrPChannels > 0 );

		if( *pPChannelGroup->m_pdwPChannel > *pPChannelGroupToInsert->m_pdwPChannel )
		{
			m_lstGraphPChannelGroups.InsertBefore( posCurrent, pPChannelGroupToInsert );
			return;
		}
	}

	m_lstGraphPChannelGroups.AddTail( pPChannelGroupToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::RepositionPChannelGroup

void CDirectMusicGraph::RepositionPChannelGroup( CPChannelGroup* pPChannelGroupToReposition )
{
	if( pPChannelGroupToReposition == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	ASSERT( pPChannelGroupToReposition->m_dwNbrPChannels > 0 );

	// Make sure PChannelGroups in tools remain in ascending order
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		pTool->RepositionPChannelGroup( pPChannelGroupToReposition );
	}

	// If item is already in m_lstGraphPChannelGroups, remove it
	pos = m_lstGraphPChannelGroups.Find( pPChannelGroupToReposition );
	if( pos )
	{
		m_lstGraphPChannelGroups.RemoveAt( pos );
	}

	// Reinsert into the list in its new position
	InsertPChannelGroup( pPChannelGroupToReposition );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::RemovePChannelGroup

void CDirectMusicGraph::RemovePChannelGroup( CPChannelGroup* pPChannelGroupToRemove )
{
	if( pPChannelGroupToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Make sure tools do not point to pPChannelGroupToRemove
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		pTool->RemovePChannelGroup( pPChannelGroupToRemove );
	}

	// If item is in m_lstGraphPChannelGroups, remove it
	pos = m_lstGraphPChannelGroups.Find( pPChannelGroupToRemove );
	if( pos )
	{
		m_lstGraphPChannelGroups.RemoveAt( pos );
		delete pPChannelGroupToRemove;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::CreateToolPChannelList

void CDirectMusicGraph::CreateToolPChannelList( CTool* pTool, CPChannelGroup* pPChannelGroup )
{
	ASSERT( pTool->m_lstPChannelGroups.IsEmpty() );
	ASSERT( m_lstGraphPChannelGroups.IsEmpty() == FALSE );

	DWORD dwNbrPChannels = pPChannelGroup->m_dwNbrPChannels;
	DWORD* pdwPChannel = new DWORD[dwNbrPChannels];
	if( pdwPChannel == NULL )
	{
		return;
	}
	memcpy( pdwPChannel, pPChannelGroup->m_pdwPChannel, sizeof(DWORD) * pPChannelGroup->m_dwNbrPChannels );

	POSITION pos = m_lstGraphPChannelGroups.GetHeadPosition();
	while( pos )
	{
		CPChannelGroup* pPChannelGroupList = m_lstGraphPChannelGroups.GetNext( pos );

		if( pPChannelGroupList->m_pdwPChannel
		&&  pPChannelGroupList->m_pdwPChannel[0] == pdwPChannel[0] )
		{
			pTool->InsertPChannelGroup( pPChannelGroupList );

			DWORD dwNext = 0;
			for( DWORD i=0, j=0 ;  i < dwNbrPChannels ;  i++ )
			{
				if( pdwPChannel[i] == pPChannelGroupList->m_pdwPChannel[j] )
				{
					j++;
				}
				else
				{
					pdwPChannel[dwNext++] = pdwPChannel[i];
				}
			}

			dwNbrPChannels = dwNext;
			if( dwNbrPChannels == 0 )
			{
				break;
			}
		}
	}
	
	ASSERT( dwNbrPChannels == 0 );
	delete [] pdwPChannel; 
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::InsertTool

void CDirectMusicGraph::InsertTool( CTool* pToolToInsert, int nIndex )
{
	if( pToolToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	ASSERT( pToolToInsert->m_pIDMTool != NULL );

	// Make sure the tool has a unique name
	GetUniqueToolName( pToolToInsert );

	ASSERT( pToolToInsert->m_pGraph == NULL );
	pToolToInsert->m_pGraph = this;
	pToolToInsert->AddRef();

	// m_lstPChannelGroups may be empty -OR-
	// LoadTool() places exactly one item in a tool's m_lstPChannelGroups
	// The following code uses this item to create a valid
	//		m_lstPChannelGroups list and then deletes it
	if( pToolToInsert->m_lstPChannelGroups.IsEmpty() == FALSE )
	{
		CPChannelGroup* pPChannelGroup = pToolToInsert->m_lstPChannelGroups.RemoveHead();
		CreateToolPChannelList( pToolToInsert, pPChannelGroup );
		delete pPChannelGroup;
	}

	// Place tool in m_lstGraphTools
	POSITION pos = m_lstGraphTools.FindIndex( nIndex );
	if( pos )
	{
		m_lstGraphTools.InsertBefore( pos, pToolToInsert );
		return;
	}

	m_lstGraphTools.AddTail( pToolToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::RemoveTool

void CDirectMusicGraph::RemoveTool( CTool* pToolToRemove )
{
	if( pToolToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Make sure PChannelGroups do not point to pToolToRemove
	POSITION pos = m_lstGraphPChannelGroups.GetHeadPosition();
	while( pos )
	{
		CPChannelGroup* pPChannelGroup = m_lstGraphPChannelGroups.GetNext( pos );

		POSITION posTool = pPChannelGroup->m_lstTools.GetHeadPosition();
		while( posTool )
		{
			POSITION posToolThis = posTool;
			CTool* pTool = pPChannelGroup->m_lstTools.GetNext( posTool );

			if( pTool == pToolToRemove )
			{
				pPChannelGroup->m_lstTools.RemoveAt( posToolThis );
				RELEASE( pTool );
			}
		}
	}

	// Set m_pGraph to NULL
	pToolToRemove->m_pGraph = NULL;

	// If item is in m_lstGraphTools, remove it
	pos = m_lstGraphTools.Find( pToolToRemove );
	if( pos )
	{
		m_lstGraphTools.RemoveAt( pos );
		RELEASE( pToolToRemove );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::IsMultipleSelectTools

BOOL CDirectMusicGraph::IsMultipleSelectTools()
{
	int nSelCount = 0;

	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		if( pTool->m_fSelected )
		{
			if( nSelCount > 0 )
			{
				return TRUE;
			}

			nSelCount++;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::SelectAllTools

void CDirectMusicGraph::SelectAllTools()
{
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		pTool->m_fSelected = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::UnselectAllTools

void CDirectMusicGraph::UnselectAllTools()
{
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		pTool->m_fSelected = FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::MarkSelectedTools

void CDirectMusicGraph::MarkSelectedTools( DWORD dwFlags )
{
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		if( pTool->m_fSelected )
		{
			pTool->m_dwBitsUI |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::UnMarkTools

void CDirectMusicGraph::UnMarkTools( DWORD dwFlags )
{
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		pTool->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::DeleteMarkedTools

void CDirectMusicGraph::DeleteMarkedTools( DWORD dwFlags )
{
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		if( pTool->m_dwBitsUI & dwFlags )
		{
			RemoveTool( pTool );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::DeleteSelectedTools

void CDirectMusicGraph::DeleteSelectedTools()
{
	POSITION pos = m_lstGraphTools.GetHeadPosition();
	while( pos )
	{
		CTool* pTool = m_lstGraphTools.GetNext( pos );

		if( pTool->m_fSelected )
		{
			RemoveTool( pTool );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::SelectToolsInRange

void CDirectMusicGraph::SelectToolsInRange( int nStartIndex, int nEndIndex )
{
	UnselectAllTools();

	POSITION pos = m_lstGraphTools.FindIndex( nStartIndex );
	while( pos )
	{
		CTool* pToolList = m_lstGraphTools.GetNext( pos );

		pToolList->m_fSelected = TRUE;

		if( ++nStartIndex > nEndIndex )
		{
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::IsInSegment

BOOL CDirectMusicGraph::IsInSegment( void )
{
	BOOL fInSegment = FALSE;

	if( m_pIParentNode )
	{
		GUID guidNodeId;
		if( SUCCEEDED ( m_pIParentNode->GetNodeId( &guidNodeId ) ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_SegmentNode ) )
			{
				fInSegment = TRUE;
			}
		}
	}

	return fInSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::IsInAudioPath

BOOL CDirectMusicGraph::IsInAudioPath( void )
{
	BOOL fInAudioPath = FALSE;

	if( m_pIParentNode )
	{
		GUID guidNodeId;
		if( SUCCEEDED ( m_pIParentNode->GetNodeId( &guidNodeId ) ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_AudioPathNode ) )
			{
				fInAudioPath = TRUE;
			}
		}
	}

	return fInAudioPath;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::UseGraphPChannelGroups

void CDirectMusicGraph::UseGraphPChannelGroups( CTool* pTool )
{
	if( pTool == NULL )
	{
		ASSERT( 0 );
		return;
	}

	// Remove existing PChannelGroups from Tool
	pTool->RemoveAllPChannelGroups();

	// Add all PChannelGroups currently in Graph
	POSITION pos = m_lstGraphPChannelGroups.GetHeadPosition();
	while( pos )
	{
		CPChannelGroup* pPChannelGroup = m_lstGraphPChannelGroups.GetNext( pos );

		// Don't call InsertPChannelGroup() because we do not want PChannelGroup to point to Tool
		pTool->m_lstPChannelGroups.AddTail( pPChannelGroup );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::GetGUID

void CDirectMusicGraph::GetGUID( GUID* pguidGraph )
{
	if( pguidGraph )
	{
		*pguidGraph = m_guidGraph;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph::SetGUID

void CDirectMusicGraph::SetGUID( GUID guidGraph )
{
	m_guidGraph = guidGraph;

	// Sync changes
	SyncGraphWithDirectMusic();
	SetModified( TRUE );

	// Notify connected nodes that Graph GUID has changed
	theApp.m_pGraphComponent->m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdToolGraphInfo::SyncGraphUser_AddTools

HRESULT CDirectMusicGraph::SyncGraphUser_AddTools( IUnknown* pIUnknown )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIUnknown == NULL )
	{
		return E_INVALIDARG;
	}

	IDirectMusicGraph* pIDMGraph = NULL;

	// Is this an AudioPath?
	IDirectMusicAudioPath* pIDMAudioPath;
	if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDirectMusicAudioPath, (void**)&pIDMAudioPath ) ) )
	{
		// Get the AudioPath's ToolGraph
		HRESULT hr2 = pIDMAudioPath->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH_GRAPH, 0, GUID_All_Objects, 0,
										IID_IDirectMusicGraph, (void**)&pIDMGraph );
		RELEASE( pIDMAudioPath );
	}
	else
	{
		// Is this a Segment?
		IDirectMusicSegment* pIDMSegment;
		if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDirectMusicSegment, (void**)&pIDMSegment ) ) )
		{
			MUSIC_TIME mtTimeNow;
			IDirectMusicSegmentState* pIDMSegmentState;

			// Is something playing?
			if( theApp.m_pGraphComponent->m_pIDMPerformance
			&&	SUCCEEDED( theApp.m_pGraphComponent->m_pIDMPerformance->GetTime( NULL, &mtTimeNow ) )
			&&	SUCCEEDED( theApp.m_pGraphComponent->m_pIDMPerformance->GetSegmentState( &pIDMSegmentState, mtTimeNow ) ) )
			{
				// Get the segment that is playing
				IDirectMusicSegment* pIDMSegmentThatIsPlaying;
				if( SUCCEEDED( pIDMSegmentState->GetSegment( &pIDMSegmentThatIsPlaying ) ) )
				{
					if( pIDMSegment == pIDMSegmentThatIsPlaying )
					{
						IDirectMusicSegmentState8* pIDMSegmentState8;
						if( SUCCEEDED ( pIDMSegmentState->QueryInterface( IID_IDirectMusicSegmentState8, (void**)&pIDMSegmentState8 ) ) )
						{
							// Get the Segment's ToolGraph
							pIDMSegmentState8->GetObjectInPath( 0, DMUS_PATH_SEGMENT_GRAPH,
															    0, GUID_All_Objects, 0,
															    IID_IDirectMusicGraph, (void**)&pIDMGraph );

							RELEASE( pIDMSegmentState8 );
						}
					}
		
					RELEASE( pIDMSegmentThatIsPlaying );
				}

				RELEASE( pIDMSegmentState );
			}

			RELEASE( pIDMSegment );
		}
	}

	if( pIDMGraph == NULL )
	{
		return E_UNEXPECTED;
	}

	HRESULT hr = S_OK;

	// Enumerate tools
	CTool* pTool;
	for( DWORD dwIndex = 0 ;  pTool = MyEnumTools(dwIndex) ;  dwIndex++ )
	{
		if( pTool == NULL )
		{
			break;
		}

		// Build the PChannel array
		CDWordArray aPChannels;
		POSITION pos = pTool->m_lstPChannelGroups.GetHeadPosition();
		while( pos )
		{
			CPChannelGroup* pPChannelGroup = pTool->m_lstPChannelGroups.GetNext( pos );

			for( DWORD i = 0 ;  i < pPChannelGroup->m_dwNbrPChannels ; i++ )
			{
				aPChannels.Add( pPChannelGroup->m_pdwPChannel[i] );
			}
		}

		if( aPChannels.GetSize() > 0 )
		{
			// Sort the PChannel array
			qsort( aPChannels.GetData(), aPChannels.GetSize(), sizeof(DWORD), CompareDWORD );
		}
		else
		{
			// This Tool has no PChannels
			//	We must force use of a bogus PChannel
			//	so that tool has no effect
			aPChannels.Add( TOOL_NO_PCHANNELS );
		}

		// Insert tools into the corresponding ToolGraph
		if( pTool->m_pIDMTool )
		{
			if( FAILED ( pIDMGraph->InsertTool( pTool->m_pIDMTool, aPChannels.GetData(), aPChannels.GetSize(), dwIndex ) ) )
			{
				hr = E_FAIL;
			}
		}
	}

	RELEASE( pIDMGraph );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicGraph IDMUSProdToolGraphInfo::SyncGraphUser_RemoveTools

HRESULT CDirectMusicGraph::SyncGraphUser_RemoveTools( IUnknown* pIUnknown )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIUnknown == NULL )
	{
		return E_INVALIDARG;
	}

	IDirectMusicGraph* pIDMGraph = NULL;

	// Is this an AudioPath?
	IDirectMusicAudioPath* pIDMAudioPath;
	if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDirectMusicAudioPath, (void**)&pIDMAudioPath ) ) )
	{
		// Get the AudioPath's ToolGraph
		pIDMAudioPath->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH_GRAPH, 0, GUID_All_Objects, 0,
										IID_IDirectMusicGraph, (void**)&pIDMGraph );
		RELEASE( pIDMAudioPath );
	}
	else
	{
		// Is this a Segment?
		IDirectMusicSegment* pIDMSegment;
		if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDirectMusicSegment, (void**)&pIDMSegment ) ) )
		{
			MUSIC_TIME mtTimeNow;
			IDirectMusicSegmentState* pIDMSegmentState;

			// Is something playing?
			if( theApp.m_pGraphComponent->m_pIDMPerformance
			&&	SUCCEEDED( theApp.m_pGraphComponent->m_pIDMPerformance->GetTime( NULL, &mtTimeNow ) )
			&&	SUCCEEDED( theApp.m_pGraphComponent->m_pIDMPerformance->GetSegmentState( &pIDMSegmentState, mtTimeNow ) ) )
			{
				// Get the segment that is playing
				IDirectMusicSegment* pIDMSegmentThatIsPlaying;
				if( SUCCEEDED( pIDMSegmentState->GetSegment( &pIDMSegmentThatIsPlaying ) ) )
				{
					if( pIDMSegment == pIDMSegmentThatIsPlaying )
					{
						IDirectMusicSegmentState8* pIDMSegmentState8;
						if( SUCCEEDED ( pIDMSegmentState->QueryInterface( IID_IDirectMusicSegmentState8, (void**)&pIDMSegmentState8 ) ) )
						{
							// Get the Segment's ToolGraph
							pIDMSegmentState8->GetObjectInPath( 0, DMUS_PATH_SEGMENT_GRAPH,
															    0, GUID_All_Objects, 0,
															    IID_IDirectMusicGraph, (void**)&pIDMGraph );

							RELEASE( pIDMSegmentState8 );
						}
					}
		
					RELEASE( pIDMSegmentThatIsPlaying );
				}

				RELEASE( pIDMSegmentState );
			}

			RELEASE( pIDMSegment );
		}
	}

	if( pIDMGraph == NULL )
	{
		return E_UNEXPECTED;
	}

	HRESULT hr = S_OK;

	// Enumerate the tools
	IDirectMusicTool* pIDMTool;
	int i = 0;
	while( pIDMGraph->GetTool( i, &pIDMTool ) == S_OK )
	{
		bool fRemove = false;

		IPersistStream* pIPersistStream;
		if( SUCCEEDED ( pIDMTool->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
		{
			CLSID clsidTool;
			if( SUCCEEDED ( pIPersistStream->GetClassID( &clsidTool ) ) )
			{
				if( theApp.m_pGraphComponent->IsRegisteredTool( clsidTool ) )
				{
					fRemove = true;
				}
			}

			RELEASE( pIPersistStream );
		}

		if( fRemove )
		{
			pIDMGraph->RemoveTool( pIDMTool );
		}
		else
		{
			i++;
		}

		RELEASE( pIDMTool );
	}

	RELEASE( pIDMGraph );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\TimeSigStripMgr.cpp ===
// TimeSigStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f TimeSigStripMgrps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "TimeSigStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include "TimeSigMgr.h"
#include <dmusici.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_TimeSigMgr, CTimeSigMgr)
END_OBJECT_MAP()

class CTimeSigStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CTimeSigStripMgrApp theApp;

BOOL CTimeSigStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CTimeSigStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_TimeSigMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicTimeSigTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicTimeSigTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_TIMESIGSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TimeSigStripMgr\TimeSignatureDlg.h ===
#if !defined(AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TimeSignatureDlg.h : header file
//

#include "resource.h"
#include <dmusici.h>

#define MIN_BEATS_PER_MEASURE	1
#define MAX_BEATS_PER_MEASURE	100

#define MIN_GRIDS_PER_BEAT			1
#define MAX_GRIDS_PER_BEAT			24
#define MAX_GRIDS_PER_BEAT_ENTRIES	48

/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg dialog

class CTimeSignatureDlg : public CDialog
{
// Construction
public:
	CTimeSignatureDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTimeSignatureDlg)
	enum { IDD = IDD_TIME_SIGNATURE };
	CButton	m_btnOK;
	CComboBox	m_cmbxGrid;
	CSpinButtonCtrl	m_spinBPM;
	CEdit	m_editBPM;
	CComboBox	m_cmbxBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTimeSignatureDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	DMUS_TIMESIGNATURE	m_TimeSignature;
	UINT				m_nContext;

protected:
	BOOL ValidateBeatsPerMeasure();
	BOOL ValidateBeat();
	BOOL ValidateGridsPerBeat();

	// Generated message map functions
	//{{AFX_MSG(CTimeSignatureDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnSelChangeBeat();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\Graph.h ===
#ifndef __GRAPH_H__
#define __GRAPH_H__

// Graph.h : header file
//

#include "GraphComponent.h"
#include "GraphDocType.h"
#include "PChannelGroup.h"
#include "Tool.h"
#include <RiffStrm.h>


#define DMUS_FOURCC_GRAPH_UI_LIST			mmioFOURCC('t','g','l','u')
#define DMUS_FOURCC_GRAPH_UI_CHUNK			mmioFOURCC('t','g','c','u')
#define DMUS_FOURCC_PCHANNELGROUP_UI_LIST	mmioFOURCC('c','h','l','u')
#define DMUS_FOURCC_PCHANNELGROUP_UI_CHUNK	mmioFOURCC('c','h','c','u')
#define DMUS_FOURCC_TOOL_UI_LIST			mmioFOURCC('t','o','l','u')
#define DMUS_FOURCC_TOOL_UI_CHUNK			mmioFOURCC('t','o','c','u')

#define DEFAULT_TOOL_PANE_WIDTH			100
#define DEFAULT_PCHANNEL_COLUMN_WIDTH	90
#define GRAPH_HEADER_HEIGHT				20

// m_dwBitsUI
#define UD_DRAGSELECT		0x00000001
#define UD_MULTIPLESELECT	0x00000002

#pragma pack(2)

typedef struct GraphUI
{
	GraphUI()
	{
		nPChannelColumnWidth = DEFAULT_PCHANNEL_COLUMN_WIDTH;
		nRegisteredToolPaneWidth = DEFAULT_TOOL_PANE_WIDTH;
		dwFlagsUI = 0;
	}

	int		nPChannelColumnWidth;
	int		nRegisteredToolPaneWidth;
	DWORD	dwFlagsUI;
} GraphUI;

#pragma pack()

// Flags for GraphUI.dwFlagsUI
#define GRAPHUI_FROM_TOOL_PALETTE	0x00000001


class CTool;

//////////////////////////////////////////////////////////////////////
//  CGraphPropPageManager

class CGraphPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabGraph;
friend class CTabInfo;

public:
	CGraphPropPageManager();
	virtual ~CGraphPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabGraph*					m_pTabGraph;
	CTabInfo*					m_pTabInfo;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CDirectMusicGraph

class CDirectMusicGraph : public IDMUSProdNode, public IPersistStream, public IDMUSProdPropPageObject,
						  public IDMUSProdNotifySink, public IDMUSProdToolGraphInfo
{
friend class CGraphCtrl;
friend class CGraphDlg;
friend class CGraphListBox;
friend class CToolListBox;
friend class CTabGraph;
friend class CTabInfo;
friend class CTabTool;

public:
    CDirectMusicGraph();
	~CDirectMusicGraph();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate( IDMUSProdNode* pINode, GUID guidUpdateType, VOID* pData );

    // IDMUSProdToolGraphInfo functions
    HRESULT STDMETHODCALLTYPE EnumTools( DWORD dwIndex, IUnknown** ppIDirectMusicTool );
    HRESULT STDMETHODCALLTYPE GetToolInfo( IUnknown* pIDirectMusicTool, DMUSProdToolInfo* pToolInfo );
    HRESULT STDMETHODCALLTYPE GetToolCount( DWORD* pdwNbrTools );
    HRESULT STDMETHODCALLTYPE AddToGraphUserList( IUnknown* pIUnknown );
    HRESULT STDMETHODCALLTYPE RemoveFromGraphUserList( IUnknown* pIUnknown );

	//Additional functions
protected:
	HRESULT LoadGraph( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT LoadUIState( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT SaveGraph( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveGUID( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveInfoList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveVersion( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveUIState( IDMUSProdRIFFStream* pIRiffStream );

    // Pertains to m_lstGraphUsers
	HRESULT SyncGraphUser_AddTools( IUnknown* pIUnknown );
    HRESULT SyncGraphUser_RemoveTools( IUnknown* pIUnknown );

	BOOL IsInSegment();
	BOOL IsInAudioPath();

	void InsertPChannelGroup( CPChannelGroup* pPChannelGroupToInsert );
	void RemovePChannelGroup( CPChannelGroup* pPChannelGroupToRemove );
	void RepositionPChannelGroup( CPChannelGroup* pPChannelGroupToReposition );

	void RemoveTool( CTool* pToolToRemove );
	void CreateToolPChannelList( CTool* pTool, CPChannelGroup* pChannelGroup );

public:
	BOOL IsMultipleSelectTools();
	BOOL IsToolNameUnique( CTool* pTool );
	CTool* MyEnumTools( int nToolIndex );
	CTool* IndexToTool( int nToolIndex );
	CTool* GetFirstSelectedTool();
	int ToolToIndex( CTool* pTool );
	void GetUniqueToolName( CTool* pTool );
	void InsertTool( CTool* pToolToInsert, int nIndex );
	void SelectAllTools();
	void UnselectAllTools();
	void MarkSelectedTools( DWORD flags );
	void UnMarkTools( DWORD flags );
	void DeleteMarkedTools( DWORD flags );
	void DeleteSelectedTools();
	void SelectToolsInRange( int nStartIndex, int nEndIndex );
	void UseGraphPChannelGroups( CTool* pTool );

public:
	HRESULT ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo );
    HRESULT GetObjectDescriptor( void* pObjectDesc );

public:
	BOOL CreateUndoMgr();
	void SetModified( BOOL fModified );
	void SyncGraphEditor();
	void ResetContentGraphEditor();
	HRESULT SyncGraphWithDirectMusic();
	void Refresh();
	void GetName( CString& strName );
	void GetGUID( GUID* pguidStyle );
	void SetGUID( GUID guidStyle);

private:
    DWORD				m_dwRef;
	BOOL				m_fModified;

	CJazzUndoMan*		m_pUndoMgr;

	IDirectMusicGraph*	m_pIDMGraph;

	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*	    m_pIParentNode;

	HWND				m_hWndEditor;

public:
	CGraphCtrl*			m_pGraphCtrl;
	CString				m_strOrigFileName;

private:
	// Persisted for UI
	GraphUI				m_GraphUI;
	CTypedPtrList<CPtrList, CPChannelGroup*> m_lstGraphPChannelGroups;

	// Persisted for DirectMusic
	GUID				m_guidGraph;
	DMUS_VERSION        m_vVersion;
    CString				m_strName;
    CString				m_strAuthor;
    CString				m_strCopyright;
    CString				m_strSubject;
    CString				m_strInfo;
	CTypedPtrList<CPtrList, CTool*> m_lstGraphTools;

	// Other
	CTypedPtrList<CPtrList, IUnknown*> m_lstGraphUsers;	// Segments and/or AudioPaths
};

#endif // __GRAPH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphCtl.cpp ===
// GraphCtl.cpp : Implementation of the CGraphCtrl ActiveX Control class.

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Graph.h"
#include "GraphCtl.h"
#include "GraphRef.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CGraphCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CGraphCtrl, COleControl)
	//{{AFX_MSG_MAP(CGraphCtrl)
	ON_WM_CREATE()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, OnUpdateEditInsert)
	ON_COMMAND(ID_EDIT_INSERT, OnEditInsert)
	ON_COMMAND(IDM_SELECT_ALL, OnEditSelectAll)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CGraphCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CGraphCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CGraphCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CGraphCtrl, COleControl)
	//{{AFX_EVENT_MAP(CGraphCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl Interface map

BEGIN_INTERFACE_MAP(CGraphCtrl, COleControl)
    INTERFACE_PART(CGraphCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CGraphCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CGraphCtrl, "TOOLGRAPHDESIGNER.GraphCtrl.1",
	0x7A6D839D, 0xE531, 0x4bbd, 0xB3, 0xBC, 0xDD, 0x16, 0xF5, 0xD3, 0x5B, 0x43)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CGraphCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DGraph =
		{ 0x7053BA5E, 0xD076, 0x486d, { 0x8B, 0xA8, 0xD8, 0x91, 0x8F, 0x22, 0x8C, 0xB8 } };
const IID BASED_CODE IID_DGraphEvents =
		{ 0xB4932E33, 0x8924, 0x4a3b, { 0x9D, 0x6D, 0xE7, 0x07, 0x9B, 0x8E, 0xE1, 0x3A } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwGraphOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CGraphCtrl, IDS_GRAPH, _dwGraphOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::CGraphCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CGraphCtrl

BOOL CGraphCtrl::CGraphCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_GRAPH,
			IDB_GRAPH,
			afxRegApartmentThreading,
			_dwGraphOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::CGraphCtrl - Constructor

CGraphCtrl::CGraphCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DGraph, &IID_DGraphEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DGraph;
	m_piidEvents = &IID_DGraphEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_pGraphDlg = NULL;
	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_hAcceleratorTable	= NULL;
	m_pGraph = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::~CGraphCtrl - Destructor

CGraphCtrl::~CGraphCtrl()
{
	RELEASE( m_pGraph );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CGraphCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CGraphCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CGraphCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CGraphCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::QueryInterface

STDMETHODIMP CGraphCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CGraphCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::AttachObjects implementation

HRESULT CGraphCtrl::XEditor::AttachObjects( IDMUSProdNode* pINode )
{
	METHOD_MANAGE_STATE( CGraphCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pINode != NULL );

	GUID guidNode;

	pINode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_ToolGraphRefNode ) )
	{
		CGraphRef* pGraphRef = (CGraphRef *)pINode;
		ASSERT( pGraphRef->m_pGraph != NULL );
		pThis->m_pGraph = pGraphRef->m_pGraph;
	}
	else
	{
		pThis->m_pGraph = (CDirectMusicGraph *)pINode;
	}

	ASSERT( pThis->m_pGraph != NULL );
	pThis->m_pGraph->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::OnInitMenuFilePrint

HRESULT CGraphCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CGraphCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::OnFilePrint

HRESULT CGraphCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CGraphCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CGraphCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CGraphCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::OnFilePrintPreview

HRESULT CGraphCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CGraphCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::OnViewProperties

HRESULT CGraphCtrl::XEditor::OnViewProperties( void )
{
	METHOD_MANAGE_STATE( CGraphCtrl, Editor )

	HRESULT hr = E_FAIL;

	if( pThis->m_pGraphDlg )
	{
		if( pThis->m_pGraphDlg->OnViewProperties() )
		{
			hr = S_OK;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XEditor::OnF1Help

HRESULT CGraphCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CGraphCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/ToolgraphDesignerWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CGraphCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CGraphCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CGraphCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CGraphCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CGraphCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CGraphCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	// Translate only if one of the cntrol's in this editor has focus
	if( pThis->m_pGraphDlg )
	{
		CWnd* pWnd = CWnd::GetFocus();
		while( pWnd )
		{
			if( pWnd == pThis->m_pGraphDlg )
			{
				if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
				{
					return S_OK;
				}
				break;
			}
			pWnd = pWnd->GetParent();
		}
	}

//	OLEINPLACEFRAMEINFO frameInfo = pThis->m_frameInfo;
//	if( ::OleTranslateAccelerator(pThis->m_pInPlaceFrame, &frameInfo, lpmsg) == S_OK )
//	{
//		return S_OK;
//	}

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CGraphCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CGraphCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CGraphCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CGraphCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CGraphCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnDraw - Drawing function

void CGraphCtrl::OnDraw( CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid )
{
	UNREFERENCED_PARAMETER(pdc);
	UNREFERENCED_PARAMETER(rcBounds);
	UNREFERENCED_PARAMETER(rcInvalid);
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::DoPropExchange - Persistence support

void CGraphCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnResetState - Reset control to default state

void CGraphCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CGraphAbout dialog used for Graph Editor About Box

class CGraphAbout : public CDialog
{
public:
	CGraphAbout();

// Dialog Data
	//{{AFX_DATA(CGraphAbout)
	enum { IDD = IDD_ABOUTBOX_GRAPH };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGraphAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CGraphAbout)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CGraphAbout::CGraphAbout() : CDialog(CGraphAbout::IDD)
{
	//{{AFX_DATA_INIT(CGraphAbout)
	//}}AFX_DATA_INIT
}

void CGraphAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGraphAbout)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CGraphAbout, CDialog)
	//{{AFX_MSG_MAP(CGraphAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CGraphAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achExeName, FILENAME_MAX ) )
	{
		if( theApp.GetFileVersion( achExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_GRAPH_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::AboutBox - Display an "About" box to the user

void CGraphCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CGraphAbout dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnHideToolBars

void CGraphCtrl::OnHideToolBars() 
{
	COleControl::OnHideToolBars();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnShowToolBars

void CGraphCtrl::OnShowToolBars() 
{
	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	COleControl::OnShowToolBars();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnGetInPlaceMenu

HMENU CGraphCtrl::OnGetInPlaceMenu() 
{
	return m_hMenuInPlace;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnCreate

int CGraphCtrl::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	if( COleControl::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_GRAPH_EDITOR) );

	// Load control's accelerator table
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_GRAPH_ACCELS) );

	// Create control's dialog
	m_pGraphDlg = new CGraphDlg;
	if( m_pGraphDlg == NULL )
	{
		return -1;
	}

	m_pGraph->m_pGraphCtrl = this;

	m_pGraphDlg->m_pGraph = m_pGraph;
	m_pGraphDlg->m_pGraphCtrl = this;
	m_pGraphDlg->Create( NULL, "WindowName", WS_CHILD | WS_VISIBLE, CRect( 0, 0, 800, 400 ), this, 888, NULL );
	m_pGraphDlg->OnInitialUpdate();
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnDestroy

void CGraphCtrl::OnDestroy() 
{
	COleControl::OnDestroy();

	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}

	if( m_hAcceleratorTable )
	{
		::DestroyAcceleratorTable( m_hAcceleratorTable );
		m_hAcceleratorTable = NULL;
	}

	ASSERT( m_pGraph != NULL );

	m_pGraph->m_pGraphCtrl = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnSize

void CGraphCtrl::OnSize( UINT nType, int cx, int cy ) 
{
	COleControl::OnSize( nType, cx, cy );

	m_pGraphDlg->MoveWindow( 0, 0, cx, cy );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnUpdateEditUndo

void CGraphCtrl::OnUpdateEditUndo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pGraph )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pGraph->m_pUndoMgr != NULL );

		if( m_pGraph->m_pUndoMgr )
		{
			if( m_pGraph->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strUndo += " ";
					strUndo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnEditUndo

void CGraphCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	if( m_pGraph )
	{
		ASSERT( m_pGraph->m_pUndoMgr != NULL );

		if( m_pGraph->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pGraph->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				m_pGraph->m_pUndoMgr->Undo( m_pGraph );
				m_pGraph->SetModified( TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnUpdateEditRedo

void CGraphCtrl::OnUpdateEditRedo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pGraph )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pGraph->m_pUndoMgr != NULL );

		if( m_pGraph->m_pUndoMgr )
		{
			if( m_pGraph->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strRedo += " ";
					strRedo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnEditRedo

void CGraphCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	if( m_pGraph )
	{
		ASSERT( m_pGraph->m_pUndoMgr != NULL );

		if( m_pGraph->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pGraph->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				m_pGraph->m_pUndoMgr->Redo( m_pGraph );
				m_pGraph->SetModified( TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnUpdateEditCut

void CGraphCtrl::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnUpdateEditCut( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnEditCut

void CGraphCtrl::OnEditCut() 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnEditCut();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnUpdateEditCopy

void CGraphCtrl::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnUpdateEditCopy( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnEditCopy

void CGraphCtrl::OnEditCopy() 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnEditCopy();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnUpdateEditPaste

void CGraphCtrl::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnUpdateEditPaste( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnEditPaste

void CGraphCtrl::OnEditPaste() 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnEditPaste();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnUpdateEditInsert

void CGraphCtrl::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnUpdateEditInsert( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnEditInsert

void CGraphCtrl::OnEditInsert() 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnEditInsert();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnEditSelectAll

void CGraphCtrl::OnEditSelectAll() 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnEditSelectAll();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnUpdateEditDelete

void CGraphCtrl::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnUpdateEditDelete( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnEditDelete

void CGraphCtrl::OnEditDelete() 
{
	if( m_pGraphDlg )
	{
		m_pGraphDlg->OnEditDelete();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl::OnHelpFinder

void CGraphCtrl::OnHelpFinder() 
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphComponent.cpp ===
// GraphComponent.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Graph.h"
#include "GraphRef.h"
#include <dmusici.h>


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent constructor/destructor 

CGraphComponent::CGraphComponent()
{
    m_dwRef = 0;
	
	m_pIFramework = NULL;
	m_pIDMPerformance = NULL;
	m_pIConductor = NULL;

	m_nNextGraph = 0;

	m_cfProducerFile = 0;
	m_cfGraph = 0;
	m_cfGraphList = 0;

	m_pIGraphDocType8 = NULL;
	m_nFirstImage = 0;
}

CGraphComponent::~CGraphComponent()
{
	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::ReleaseAll

void CGraphComponent::ReleaseAll( void )
{
 	CDirectMusicGraph* pGraph;
	while( !m_lstGraphs.IsEmpty() )
	{
		pGraph = m_lstGraphs.RemoveHead();
		RELEASE( pGraph );
	}

 	RegisteredTool* pRegisteredTool;
	while( !m_lstRegisteredTools.IsEmpty() )
	{
		pRegisteredTool = m_lstRegisteredTools.RemoveHead();
		delete pRegisteredTool;
	}

	RELEASE( m_pIFramework );
	RELEASE( m_pIDMPerformance );
	RELEASE( m_pIConductor );
	RELEASE( m_pIGraphDocType8 );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent IUnknown implementation

HRESULT CGraphComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdComponent *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdRIFFExt *)this;
        return S_OK;
    }
	
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CGraphComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CGraphComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CGraphComponent IDMUSProdComponent::Initialize

HRESULT CGraphComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	ASSERT( pIFramework != NULL );
	ASSERT( pbstrErrMsg != NULL );

	if( pbstrErrMsg == NULL )
	{
		return E_POINTER;
	}

	if( pIFramework == NULL )
	{
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_INVALIDARG;
	}

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	theApp.m_pGraphComponent = this;
//	theApp.m_pGraphComponent->AddRef();	intentionally missing

	// Get IConductor and IDirectMusicPerformance interface pointers 
	if( FAILED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  FAILED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) )
	||  FAILED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			RELEASE( pIComponent );
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIComponent );

	// Add applicable images to the Project Tree control's image list 
	if( FAILED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clipboard format for an .tgp file 
	CString strExt = _T(".tgp");
	BSTR bstrExt = strExt.AllocSysString();
	if( FAILED ( pIFramework->RegisterClipFormatForFile(m_cfGraph, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register applicable doc types with the Framework 
	m_pIGraphDocType8 = new CGraphDocType;
    if( m_pIGraphDocType8 == NULL )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_OUTOFMEMORY;
	}

	m_pIGraphDocType8->AddRef();

	if( FAILED ( pIFramework->AddDocType(m_pIGraphDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	LoadRegisteredTools();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent IDMUSProdComponent::CleanUp

HRESULT CGraphComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Release references to graphs
	CDirectMusicGraph *pGraph;
	while( !m_lstGraphs.IsEmpty() )
	{
		pGraph = m_lstGraphs.RemoveHead();
		RELEASE( pGraph );
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent IDMUSProdComponent::GetName

HRESULT CGraphComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_GRAPH_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::IDMUSProdComponent::AllocReferenceNode

HRESULT CGraphComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_ToolGraphRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create GraphRefNode
	CGraphRef* pGraphRef = new CGraphRef;
	if( pGraphRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pGraphRef;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent IDMUSProdComponent::OnActivateApp

HRESULT CGraphComponent::OnActivateApp( BOOL fActivate )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CGraphComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicGraph* pGraph;
	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new Graph 
	pGraph = new CDirectMusicGraph;
	if( pGraph == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	// Create the Undo Manager
	if( pGraph->CreateUndoMgr() == FALSE )
	{
		pGraph->Release();
		return E_OUTOFMEMORY;
	}

	// Load Graph file
	hr = pGraph->Load( pIStream );
	if( FAILED ( hr ) )
	{
		pGraph->Release();
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pGraph;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::AddNodeImageLists

HRESULT CGraphComponent::AddNodeImageLists( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 4, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_GRAPH_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_GRAPH_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_GRAPHREF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_GRAPHREF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( FAILED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstImage ) ) )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::RegisterClipboardFormats

BOOL CGraphComponent::RegisterClipboardFormats( void )
{
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfGraph = ::RegisterClipboardFormat( CF_GRAPH );
	m_cfGraphList = ::RegisterClipboardFormat( CF_GRAPHLIST );

	if( m_cfProducerFile == 0
	||  m_cfGraph == 0
	||  m_cfGraphList == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::LoadRegisteredTools

HRESULT CGraphComponent::LoadRegisteredTools( void )
{
	HKEY	  hKeyOpen;
	HKEY	  hKeyOpenClsId;
	DWORD	  dwType;
	DWORD	  dwCbData;
	FILETIME  ftFileTime;
	_TCHAR	  achClsId[MID_BUFFER];
	_TCHAR	  achName[MID_BUFFER];

	LONG lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
							  	   _T("Software\\Microsoft\\DirectMusic\\Tools"),
								   0, KEY_READ, &hKeyOpen );
	if( lResult != ERROR_SUCCESS )
	{
		return S_FALSE;
	}

	HRESULT hr = S_FALSE;

	DWORD dwIndex = 0;
	for( ; ; )
	{
		dwCbData = MID_BUFFER;
		lResult  = ::RegEnumKeyEx( hKeyOpen, dwIndex++, achClsId, &dwCbData,
								   NULL, NULL, NULL, &ftFileTime );
		if( lResult != ERROR_SUCCESS )
		{
			break;
		}

		_tcscpy( achName, _T("") );
		lResult    = ::RegOpenKeyEx( hKeyOpen, achClsId,
								     0, KEY_QUERY_VALUE, &hKeyOpenClsId );
		if( lResult == ERROR_SUCCESS )
		{
			dwCbData = MID_BUFFER;
			lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T("ShortName"), NULL,
										  &dwType, (LPBYTE)&achName, &dwCbData );
			if( (lResult == ERROR_SUCCESS)
			&&  (dwType == REG_SZ) )
			{
				CLSID clsid;
				wchar_t awchClsId[80];

				if( MultiByteToWideChar( CP_ACP, 0, achClsId, -1, awchClsId, sizeof(awchClsId) / sizeof(wchar_t) ) != 0 )
				{
					IIDFromString( awchClsId, &clsid );

					IDirectMusicTool* pIDMTool;
					if( SUCCEEDED ( ::CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, IID_IDirectMusicTool, (void**)&pIDMTool ) ) )
					{
						RegisteredTool* pRegisteredTool = new RegisteredTool;
						if( pRegisteredTool )
						{
							pRegisteredTool->clsidTool = clsid;
							pRegisteredTool->strName = achName;

							m_lstRegisteredTools.AddTail( pRegisteredTool );
							hr = S_OK;
						}

						RELEASE( pIDMTool );
					}
				}
			}

			::RegCloseKey( hKeyOpenClsId );
		}
	}

	::RegCloseKey( hKeyOpen );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::GetGraphImageIndex

HRESULT CGraphComponent::GetGraphImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_GRAPH_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::GetGraphRefImageIndex

HRESULT CGraphComponent::GetGraphRefImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_GRAPHREF_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::EnumRegisteredTools

RegisteredTool* CGraphComponent::EnumRegisteredTools( int nIndex )
{
	RegisteredTool* pRegisteredTool = NULL;

	POSITION pos = m_lstRegisteredTools.FindIndex( nIndex );
	if( pos )
	{
		pRegisteredTool = m_lstRegisteredTools.GetAt( pos );
	}

	return pRegisteredTool;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::GetRegisteredToolName

void CGraphComponent::GetRegisteredToolName( CLSID clsidTool, CString& strName )
{
	strName.Empty();

	POSITION pos = m_lstRegisteredTools.GetHeadPosition();
	while( pos )
	{
		RegisteredTool* pRegisteredTool = m_lstRegisteredTools.GetNext( pos );

		if( ::IsEqualGUID( pRegisteredTool->clsidTool, clsidTool ) )
		{
			strName = pRegisteredTool->strName;
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::IsRegisteredTool

BOOL CGraphComponent::IsRegisteredTool( CLSID clsidTool )
{
	POSITION pos = m_lstRegisteredTools.GetHeadPosition();
	while( pos )
	{
		RegisteredTool* pRegisteredTool = m_lstRegisteredTools.GetNext( pos );

		if( ::IsEqualGUID( pRegisteredTool->clsidTool, clsidTool ) )
		{
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::AddToGraphFileList

void CGraphComponent::AddToGraphFileList( CDirectMusicGraph* pGraph )
{
	if( pGraph )
	{
		GUID guidGraph;
		pGraph->GetGUID( &guidGraph );

		// Prevent duplicate object GUIDs
		GUID guidGraphList;
		POSITION pos = m_lstGraphs.GetHeadPosition();
		while( pos )
		{
			CDirectMusicGraph* pGraphList = m_lstGraphs.GetNext( pos );

			pGraphList->GetGUID( &guidGraphList );
			if( ::IsEqualGUID( guidGraphList, guidGraph ) )
			{
				::CoCreateGuid( &guidGraph );
				pGraph->SetGUID( guidGraph );
				break;
			}
		}

		// Add to list
		pGraph->AddRef();
		m_lstGraphs.AddTail( pGraph );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphComponent::RemoveFromGraphFileList

void CGraphComponent::RemoveFromGraphFileList( CDirectMusicGraph* pGraph )
{
	if( pGraph )
	{
		// Remove from list
		POSITION pos = m_lstGraphs.Find( pGraph );
		if( pos )
		{
			m_lstGraphs.RemoveAt( pos );
			pGraph->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphComponent.h ===
#ifndef __GRAPHCOMPONENT_H__
#define __GRAPHCOMPONENT_H__

// GraphComponent.h : header file
//

#include <afxtempl.h>
#include <Conductor.h>

class CDirectMusicGraph;


#pragma pack(2)

typedef struct RegisteredTool
{
	RegisteredTool()
	{
		memset( &clsidTool, 0, sizeof(CLSID) );
	}

	CLSID				clsidTool;
	CString				strName;
} RegisteredTool;

#pragma pack()


////////////////////////////////////////////////////////////////////////////////
class CGraphComponent : public IDMUSProdComponent, public IDMUSProdRIFFExt
{
public:
    CGraphComponent();
	~CGraphComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivate );

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

    // Additional functions
private:
    HRESULT AddNodeImageLists();
    HRESULT LoadRegisteredTools();
	BOOL RegisterClipboardFormats();
	void ReleaseAll();

public:
    HRESULT STDMETHODCALLTYPE GetGraphImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetGraphRefImageIndex( short* pnNbrFirstImage );
	RegisteredTool* EnumRegisteredTools( int nIndex );
	void GetRegisteredToolName( CLSID clsidTool, CString& strName );
	BOOL IsRegisteredTool( CLSID clsidTool );
	void AddToGraphFileList( CDirectMusicGraph* pGraph );
	void RemoveFromGraphFileList( CDirectMusicGraph* pGraph );

public:
	IDMUSProdFramework*			m_pIFramework;
	IDirectMusicPerformance*	m_pIDMPerformance;
	IDMUSProdConductor*			m_pIConductor;
	IDMUSProdDocType8*			m_pIGraphDocType8;

	short						m_nNextGraph;		// appended to name of new Graph
	UINT						m_cfProducerFile;	// CF_DMUSPROD_FILE clipboard format
	UINT						m_cfGraph;			// CF_GRAPH clipboard format
	UINT						m_cfGraphList;		// CF_GRAPHLIST clipboard format

private:
    DWORD						m_dwRef;
	short						m_nFirstImage;

	CTypedPtrList<CPtrList, CDirectMusicGraph*> m_lstGraphs;
	CTypedPtrList<CPtrList, RegisteredTool*> m_lstRegisteredTools;
};

#endif // __GRAPHCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphDlg.cpp ===
// GraphDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Graph.h"
#include "GraphCtl.h"
#include "GraphDlg.h"
#include <PChannelName.h>
#include "DlgAddPChannel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPChannelHeaderBtn

CPChannelHeaderBtn::CPChannelHeaderBtn()
{
	m_pGraphDlg = NULL;
}

CPChannelHeaderBtn::~CPChannelHeaderBtn()
{
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelHeaderBtn message handlers

BEGIN_MESSAGE_MAP(CPChannelHeaderBtn, CButton)
	//{{AFX_MSG_MAP(CPChannelHeaderBtn)
	ON_WM_ERASEBKGND()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPChannelHeaderBtn::OnSetFocus

void CPChannelHeaderBtn::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CButton::OnSetFocus( pOldWnd );
	
	m_pGraphDlg->m_nEditMenuCtrlID = IDC_PCHANNEL_HEADER;
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelHeaderBtn::OnEraseBkgnd

BOOL CPChannelHeaderBtn::OnEraseBkgnd( CDC* pDC ) 
{
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelHeaderBtn::DrawItem

void CPChannelHeaderBtn::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CRect rect( lpDrawItemStruct->rcItem );

	CString strPChannel;
	strPChannel.LoadString( IDS_PCHANNEL_GROUP_TEXT );

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC )
	{
		CBrush brush;
		if( brush.CreateSolidBrush( GetSysColor(COLOR_BTNFACE) ) )
		{
			CBrush* pOldBrush = pDC->SelectObject( &brush );
	        int nBkModeOld = pDC->SetBkMode( TRANSPARENT );

			// PChannel column
			pDC->Draw3dRect( &rect, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW) );
			rect.InflateRect( -1, -1 );
			pDC->FillRect( &rect, &brush );
			rect.InflateRect( 1, 1 );
			rect.left += 2;
			rect.right -= 3;
			pDC->DrawText( strPChannel, -1, &rect, (DT_SINGLELINE | DT_VCENTER | DT_LEFT | DT_NOPREFIX) );
			
			pDC->SelectObject( pOldBrush );
	        pDC->SetBkMode( nBkModeOld );
		}		
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox

CPChannelListBox::CPChannelListBox()
{
	m_pGraphDlg = NULL;
}

CPChannelListBox::~CPChannelListBox()
{
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox message handlers

BEGIN_MESSAGE_MAP(CPChannelListBox, CListBox)
	//{{AFX_MSG_MAP(CPChannelListBox)
	ON_WM_RBUTTONDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblClk)
	ON_WM_VKEYTOITEM_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox::OnSetFocus

void CPChannelListBox::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnSetFocus( pOldWnd );
	
	m_pGraphDlg->m_nEditMenuCtrlID = IDC_PCHANNEL_LIST;
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox::OnKillFocus

void CPChannelListBox::OnKillFocus( CWnd* pNewWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnKillFocus( pNewWnd );
	
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox::DrawItem

void CPChannelListBox::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( lpDrawItemStruct->itemID == -1 )
	{
		return;
	}

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
    ||  lpDrawItemStruct->itemAction & ODA_SELECT 
    ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
	{
		CPChannelGroup* pPChannelGroup = (CPChannelGroup *)lpDrawItemStruct->itemData; 
		ASSERT( pPChannelGroup != NULL );

		// Determine text
		CString strText;
		pPChannelGroup->FormatPChannelText( strText );

	    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
		int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

		CRect rect( 0, 0, nWidth, nHeight );

		CDC dc;
		CBitmap bmp;

		if( dc.CreateCompatibleDC( pDC )
		&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
		{
			CFont* pFontOld = NULL;
			CFont* pFont = m_pGraphDlg->CreateFont();
			if( pFont )
			{
				pFontOld = dc.SelectObject( pFont );
			}
			CBitmap* pBitmapOld = dc.SelectObject( &bmp );
			int nBkModeOld = dc.SetBkMode( TRANSPARENT );

			// Set horizontal extent
			TEXTMETRIC tm;
			dc.GetTextMetrics( &tm );
			CSize sizeText = dc.GetTextExtent( strText );
			sizeText.cx += tm.tmMaxCharWidth;
			if( sizeText.cx > GetHorizontalExtent() )
			{
				SetHorizontalExtent( sizeText.cx );
			}

			if( lpDrawItemStruct->itemState & ODS_SELECTED )
			{
				if( ::GetFocus() == GetSafeHwnd() )
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
					dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
				}
				else
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_INACTIVECAPTION) );
					dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT) );
				}
			}
			else
			{
				dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
				dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
			}

			// Draw the item
			rect.left  += 3;
			dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );
			pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
						 &dc, 0, 0, SRCCOPY );

			// Clean up
			dc.SetBkMode( nBkModeOld );
			if( pFontOld )
			{
				dc.SelectObject( pFontOld );
				pFont->DeleteObject();
				delete pFont;
			}
			if( pBitmapOld )
			{
				dc.SelectObject( pBitmapOld );
			}
		}

		if( ::GetFocus() == GetSafeHwnd() )
		{
			if( (lpDrawItemStruct->itemAction & ODA_FOCUS)
			&&  (lpDrawItemStruct->itemState & ODS_FOCUS) )
			{
				InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
				pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
				InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox::MeasureItem

void CPChannelListBox::MeasureItem( LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDC* pDC = GetDC();
	if( pDC )
	{
		CFont* pFontOld = NULL;
		CFont* pFont = m_pGraphDlg->CreateFont();
		if( pFont )
		{
			pFontOld = pDC->SelectObject( pFont );
		}

		TEXTMETRIC tm;
		pDC->GetTextMetrics( &tm );
		lpMeasureItemStruct->itemHeight = tm.tmHeight + 1;
		
		if( pFontOld )
		{
			pDC->SelectObject( pFontOld );
			pFont->DeleteObject();
			delete pFont;
		}

		ReleaseDC( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox::OnRButtonDown

void CPChannelListBox::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get nearest item
	BOOL fOutside;
	int nPos = ItemFromPoint( point, fOutside );

	if( fOutside == FALSE
	&&  nPos != LB_ERR )
	{
		CRect rect;
		GetItemRect( nPos, &rect );
		if( rect.PtInRect( point ) )
		{
			if( GetSel( nPos ) == 0 )
			{
				// Cursor is in the nearest item
				SetSel( -1, FALSE ); 
				SetSel( nPos, TRUE ); 
			}
			SetCaretIndex( nPos, 0 ); 
		}
	}

	CListBox::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox::OnDblClk

void CPChannelListBox::OnDblClk() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPoint pt;
	GetCursorPos( &pt );

	m_pGraphDlg->OnChangePChannelGroup( pt, false );
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox::VKeyToItem

int CPChannelListBox::VKeyToItem( UINT nKey, UINT nIndex ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( nKey )
	{
		case VK_INSERT :
		{
			POINT pt = {0, 0};
			m_pGraphDlg->OnChangePChannelGroup( pt, true );
			return -2;
		}

		case VK_RETURN :
		{
			RECT rect;
			if( GetItemRect(nIndex, &rect) != LB_ERR )
			{
				ClientToScreen( &rect );
				POINT pt = {rect.left, rect.top};
				m_pGraphDlg->OnChangePChannelGroup( pt, false );
			}
			return -2;
		}

		case VK_DELETE :
			m_pGraphDlg->OnDeletePChannelGroups();
			return -2;
	}
	
	return -1;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn

CGraphHeaderBtn::CGraphHeaderBtn()
{
	m_pGraphDlg = NULL;
	m_nLastXPos = INT_MAX;
}

CGraphHeaderBtn::~CGraphHeaderBtn()
{
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::CreateDataObject

HRESULT CGraphHeaderBtn::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraphDlg->m_pGraph != NULL );
	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}
	*ppIDataObject = NULL;

	HRESULT hr = E_FAIL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Save selected tools in Graph
	IStream* pIStream;
	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_SaveSelectedTools, &pIStream) ) )
	{
		if( SUCCEEDED ( m_pGraphDlg->m_pGraph->Save( pIStream, FALSE ) ) )
		{
			// Place CF_GRAPH into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pGraphComponent->m_cfGraph, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->SaveClipFormat( theApp.m_pGraphComponent->m_cfProducerFile, m_pGraphDlg->m_pGraph, &pIStream ) ) )
		{
			// Graph nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pGraphComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			RELEASE( pIStream );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn message handlers

BEGIN_MESSAGE_MAP(CGraphHeaderBtn, CButton)
	//{{AFX_MSG_MAP(CGraphHeaderBtn)
	ON_WM_ERASEBKGND()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_KEYDOWN()
	ON_WM_SETFOCUS()
	ON_WM_CAPTURECHANGED()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnSetFocus

void CGraphHeaderBtn::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CButton::OnSetFocus( pOldWnd );
	
	m_pGraphDlg->m_nEditMenuCtrlID = IDC_GRAPH_HEADER;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnEraseBkgnd

BOOL CGraphHeaderBtn::OnEraseBkgnd( CDC* pDC ) 
{
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::DrawItem

void CGraphHeaderBtn::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CRect rect( lpDrawItemStruct->rcItem );

	// Account for horizontal scrolling
	rect.left = -m_pGraphDlg->m_lstbxGraph.m_nHScrollPos;

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC )
	{
		CString strName;
		CBrush brush;
		if( brush.CreateSolidBrush( GetSysColor(COLOR_BTNFACE) ) )
		{
			CBrush* pOldBrush = pDC->SelectObject( &brush );
	        int nBkModeOld = pDC->SetBkMode( TRANSPARENT );

			CTool* pTool;
			for( int i = 0 ;  pTool = m_pGraphDlg->m_pGraph->MyEnumTools(i) ;  i++ )
			{
				if( pTool == NULL )
				{
					break;
				}

				rect.right = min( (rect.left + pTool->GetColumnWidth()), lpDrawItemStruct->rcItem.right );
				if( rect.right >= 0 )
				{
					if( pTool->m_fSelected )
					{
						pDC->Draw3dRect( &rect, GetSysColor(COLOR_BTNSHADOW), GetSysColor(COLOR_BTNHIGHLIGHT) );
					}
					else
					{
						pDC->Draw3dRect( &rect, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW) );
					}
					rect.InflateRect( -1, -1 );
					pDC->FillRect( &rect, &brush );
					rect.InflateRect( 1, 1 );
					rect.left += 2;
					rect.right -= 3;

					if( pTool->m_fSelected )
					{
						rect.OffsetRect( 1, 1 );
					}
					pTool->GetName( strName );
					pDC->DrawText( strName, -1, &rect, (DT_SINGLELINE | DT_VCENTER | DT_LEFT | DT_NOPREFIX) );
					if( pTool->m_fSelected )
					{
						rect.OffsetRect( -1, -1 );
					}
					rect.right += 3;
				}

				rect.left = rect.right;
				rect.right = lpDrawItemStruct->rcItem.right;
				if( rect.left >= rect.right )
				{
					break;
				}
			}

			if( rect.left < rect.right )
			{
				pDC->Draw3dRect( &rect, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW) );
				rect.InflateRect( -1, -1 );
				pDC->FillRect( &rect, &brush );
				rect.InflateRect( 1, 1 );

				if( m_pGraphDlg->m_pGraph->MyEnumTools(0) == NULL )
				{
					CString strPrompt;
					strPrompt.LoadString( IDS_NO_TOOLS_PROMPT );
					rect.left += 2;
					pDC->DrawText( strPrompt, -1, &rect, (DT_SINGLELINE | DT_VCENTER | DT_LEFT | DT_NOPREFIX) );
					rect.left -= 2;
				}
			}
			
			pDC->SelectObject( pOldBrush );
	        pDC->SetBkMode( nBkModeOld );
		}		
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnCaptureChanged

void CGraphHeaderBtn::OnCaptureChanged( CWnd *pWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pWnd == this )
	{
		return;
	}

	m_pGraphDlg->m_dwMouseDownButton = 0;
	m_pGraphDlg->m_rectMouseDown.SetRectEmpty();

	if( m_pGraphDlg->m_pToolToToggle )
	{
		// Nothing to do
		m_pGraphDlg->m_pToolToToggle = NULL;
	}
	
	CButton::OnCaptureChanged( pWnd );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnLButtonDblClk

void CGraphHeaderBtn::OnLButtonDblClk( UINT nFlags, CPoint point ) 
{
	OnLButtonDown( nFlags, point );

	// Get nearest tool
	CTool* pTool = m_pGraphDlg->GetToolFromXPos( point.x );
	if( pTool )
	{
		// Show the Tool properties
		pTool->OnShowProperties();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnLButtonDown

void CGraphHeaderBtn::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraphDlg != NULL );

	SetFocus();

	m_pGraphDlg->m_pToolToToggle = NULL;
	m_nLastXPos = point.x;

	if( m_pGraphDlg->m_dwMouseDownButton == 0 )
	{
		// Get nearest tool
		CTool* pTool = m_pGraphDlg->GetToolFromXPos( point.x );
		if( pTool )
		{
			// SHIFT
			if( nFlags & MK_SHIFT )
			{
				// Figure out range
				int nStartIndex;
				int nEndIndex;
				if(m_pGraphDlg-> m_pToolForShiftClick == NULL )
				{
					nStartIndex = 0;
				}
				else
				{
					nStartIndex = m_pGraphDlg->m_pGraph->ToolToIndex( m_pGraphDlg->m_pToolForShiftClick );
				}
				nEndIndex = m_pGraphDlg->m_pGraph->ToolToIndex( pTool );
				if( nStartIndex > nEndIndex )
				{
					int nTempIndex = nStartIndex;
					nStartIndex = nEndIndex;
					nEndIndex = nTempIndex;
				}

				// Select Tools in range
				m_pGraphDlg->m_pGraph->SelectToolsInRange( nStartIndex, nEndIndex );
			}
			else
			{
				// CTRL
				if( nFlags & MK_CONTROL )
				{
					if( pTool->m_fSelected )
					{
						m_pGraphDlg->m_pToolToToggle = pTool;
					}
					else
					{
						pTool->m_fSelected = TRUE;
					}
				}
				// No CTRL or SHIFT
				else
				{
					m_pGraphDlg->m_pGraph->UnselectAllTools();
					pTool->m_fSelected = TRUE;
				}

				// Set anchor for future shift-select operations
				m_pGraphDlg->m_pToolForShiftClick = pTool;
			}
			ASSERT( pTool->m_fSelected );

			// First set capture
			SetCapture();

			// Now store fields used when drag drop is initiated
			m_pGraphDlg->m_dwMouseDownButton = MK_LBUTTON;

			m_pGraphDlg->m_pointMouseDown.x = point.x;
			m_pGraphDlg->m_pointMouseDown.y = point.y;

			m_pGraphDlg->m_rectMouseDown.left = point.x - 5;
			m_pGraphDlg->m_rectMouseDown.top = point.y - 5;
			m_pGraphDlg->m_rectMouseDown.right = point.x + 5;
			m_pGraphDlg->m_rectMouseDown.bottom = point.y + 5;

			// Redraw header control
			Invalidate();
		}

		// Refresh properties
		m_pGraphDlg->OnViewProperties();
	}
	
	CButton::OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnLButtonUp

void CGraphHeaderBtn::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraphDlg->m_dwMouseDownButton == MK_LBUTTON )
	{
		// Do this before we release capture
		if( m_pGraphDlg->m_pToolToToggle )
		{
			m_pGraphDlg->m_pToolToToggle->m_fSelected = !m_pGraphDlg->m_pToolToToggle->m_fSelected;
			m_pGraphDlg->m_pToolToToggle = NULL;
			Invalidate();
		}

		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}

		// Refresh properties
		m_pGraphDlg->OnViewProperties();
	}
	
	CButton::OnLButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnRButtonDown

void CGraphHeaderBtn::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraphDlg != NULL );

	m_pGraphDlg->m_pToolForShiftClick = NULL;
	m_nLastXPos = point.x;

	SetFocus();

	if( m_pGraphDlg->m_dwMouseDownButton == 0 )
	{
		// Get nearest tool
		CTool* pTool = m_pGraphDlg->GetToolFromXPos( point.x );
		if( pTool )
		{
			// Select tool
			if( !(nFlags & MK_CONTROL) )
			{
				if( pTool->m_fSelected == FALSE )
				{
					m_pGraphDlg->m_pGraph->UnselectAllTools();
					pTool->m_fSelected = TRUE;
				}
				ASSERT( pTool->m_fSelected );

				// Set anchor for future shift-select operations
				m_pGraphDlg->m_pToolForShiftClick = pTool;
			}

			if( pTool->m_fSelected )
			{
				// First set capture
				SetCapture();

				// Now store fields used when drag drop is initiated
				m_pGraphDlg->m_dwMouseDownButton = MK_RBUTTON;

				m_pGraphDlg->m_pointMouseDown.x = point.x;
				m_pGraphDlg->m_pointMouseDown.y = point.y;

				m_pGraphDlg->m_rectMouseDown.left = point.x - 5;
				m_pGraphDlg->m_rectMouseDown.top = point.y - 5;
				m_pGraphDlg->m_rectMouseDown.right = point.x + 5;
				m_pGraphDlg->m_rectMouseDown.bottom = point.y + 5;
			}

			// Redraw header control
			Invalidate();
		}

		// Refresh properties
		m_pGraphDlg->OnViewProperties();
	}
	
	CButton::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnRButtonUp

void CGraphHeaderBtn::OnRButtonUp( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraphDlg->m_dwMouseDownButton == MK_RBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}

		// Refresh properties
		m_pGraphDlg->OnViewProperties();
	}
	
	CButton::OnRButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnMouseMove

void CGraphHeaderBtn::OnMouseMove( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER( nFlags );

	ASSERT( m_pGraphDlg != NULL );
	
	if( CWnd::GetCapture() == this )
	{
		if( m_pGraphDlg->m_dwMouseDownButton != 0 )
		{
			// See if user is moving the mouse
			if( m_pGraphDlg->m_rectMouseDown.PtInRect( point ) == FALSE )
			{
				// Start drag drop
				m_pGraphDlg->DoDrag( IDC_GRAPH_HEADER, m_pGraphDlg->m_dwMouseDownButton ); 
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn::OnKeyDown

void CGraphHeaderBtn::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( nRepCnt == 1 )
	{
		switch( nChar )
		{
			case VK_DELETE :
				m_pGraphDlg->OnDeleteTools();
				break;
		}
	}
	
	CButton::OnKeyDown( nChar, nRepCnt, nFlags );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGraphListBox

CGraphListBox::CGraphListBox()
{
	m_pGraphDlg = NULL;

	m_nHScrollPos = 0;
	m_nVScrollPos = 0;

	m_nSetPChannelState = -1;
}

CGraphListBox::~CGraphListBox()
{
}


BEGIN_MESSAGE_MAP(CGraphListBox, CListBox)
	//{{AFX_MSG_MAP(CGraphListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEMOVE()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGraphListBox::OnSetFocus

void CGraphListBox::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnSetFocus( pOldWnd );
	
	m_pGraphDlg->m_nEditMenuCtrlID = IDC_GRAPH_LIST;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphListBox::DrawItem

void CGraphListBox::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( lpDrawItemStruct->itemID == -1 )
	{
		return;
	}

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

	// Handle HScroll
	CPoint pt = pDC->GetWindowOrg();
	if( pt.x != m_nHScrollPos )
	{
		m_nHScrollPos = pt.x;
		m_pGraphDlg->m_btnGraphHeader.Invalidate();	
	}

	// Handle VScroll
	int nTopIndex = GetTopIndex();
	if( nTopIndex != m_nVScrollPos )
	{
		m_nVScrollPos = nTopIndex;
		m_pGraphDlg->m_lstbxPChannels.SetTopIndex( nTopIndex );
	}

	CPen pen;
	if( pen.CreatePen(PS_SOLID, 1, RGB(0, 0, 0)) == FALSE )
	{
		return;
	}

    if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
    ||  lpDrawItemStruct->itemAction & ODA_SELECT 
    ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
	{
		CPChannelGroup* pPChannelGroup = (CPChannelGroup *)lpDrawItemStruct->itemData; 
		ASSERT( pPChannelGroup != NULL );

		CRect rect( lpDrawItemStruct->rcItem );

		// Draw the item
		{
			CPen* pPenOld = pDC->SelectObject( &pen );

			pDC->FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );

			rect.bottom--;

			CTool* pTool;
			int nXPos = 0;
			for( int i = 0 ;  pTool = m_pGraphDlg->m_pGraph->MyEnumTools(i) ;  i++ )
			{
				if( pTool == NULL )
				{
					break;
				}

				// Determine rectangle
				rect.left = nXPos;
				nXPos += pTool->GetColumnWidth();
				rect.right = nXPos;

				// Draw horizontal line (bottom)
				pDC->MoveTo( rect.left, rect.bottom );
				pDC->LineTo( rect.right, rect.bottom );

				// Draw vertical lines (separate tools)
				pDC->MoveTo( rect.right-1, rect.top );
				pDC->LineTo( rect.right-1, rect.bottom );

				if( pTool->ContainsPChannelGroup(pPChannelGroup) )
				{
					InflateRect( &rect, -1, -1 );
					rect.right--;
					pDC->FillSolidRect( &rect, pDC->GetNearestColor(RGB(10,10,255)) );
					rect.right++;
					InflateRect( &rect, 1, 1 );
				}
			}

			if( pPenOld )
			{
				pDC->SelectObject( pPenOld );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphListBox::MeasureItem

void CGraphListBox::MeasureItem( LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDC* pDC = GetDC();
	if( pDC )
	{
		CFont* pFontOld = NULL;
		CFont* pFont = m_pGraphDlg->CreateFont();
		if( pFont )
		{
			pFontOld = pDC->SelectObject( pFont );
		}

		TEXTMETRIC tm;
		pDC->GetTextMetrics( &tm );
		lpMeasureItemStruct->itemHeight = tm.tmHeight + 1;
		
		if( pFontOld )
		{
			pDC->SelectObject( pFontOld );
			pFont->DeleteObject();
			delete pFont;
		}

		ReleaseDC( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphListBox::OnMouseMove

void CGraphListBox::OnMouseMove( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER( nFlags );

	ASSERT( m_pGraphDlg != NULL );
	
	if( CWnd::GetCapture() == this )
	{
		if( m_nSetPChannelState != -1 )
		{
			// Get nearest item
			BOOL fOutside;
			int nPos = ItemFromPoint( point, fOutside );
			if( fOutside == FALSE
			&&  nPos != LB_ERR )
			{
				// Get PChannelGroup
				CPChannelGroup* pPChannelGroup = (CPChannelGroup *)m_pGraphDlg->m_lstbxPChannels.GetItemDataPtr( nPos );
				ASSERT( pPChannelGroup != NULL );
				ASSERT( pPChannelGroup != (CPChannelGroup *)0xFFFFFFFF );

				// Highlight corresponding item in PChannel listbox
				m_pGraphDlg->m_lstbxPChannels.SetSel( -1, FALSE ); 
				m_pGraphDlg->m_lstbxPChannels.SetSel( nPos, TRUE ); 
				m_pGraphDlg->m_lstbxPChannels.SetCaretIndex( nPos, 0 ); 

				// Get nearest tool
				CTool* pTool = m_pGraphDlg->GetToolFromXPos( point.x );
				if( pTool )
				{
					// Set m_nSetPChannelState
					if( pTool->ContainsPChannelGroup( pPChannelGroup ) )
					{
						if( m_nSetPChannelState == FALSE )
						{
							pTool->RemovePChannelGroup( pPChannelGroup );

							// Redraw graph
							RECT rect;
							GetItemRect( nPos, &rect );
							InvalidateRect( &rect, FALSE );
						}
					}
					else
					{
						if( m_nSetPChannelState == TRUE )
						{
							pTool->InsertPChannelGroup( pPChannelGroup );

							// Redraw graph
							RECT rect;
							GetItemRect( nPos, &rect );
							InvalidateRect( &rect, FALSE );
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphListBox::OnLButtonDown

void CGraphListBox::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraphDlg != NULL );

	// Get nearest item
	BOOL fOutside;
	int nPos = ItemFromPoint( point, fOutside );
	if( fOutside == FALSE
	&&  nPos != LB_ERR )
	{
		// Get PChannelGroup
		CPChannelGroup* pPChannelGroup = (CPChannelGroup *)m_pGraphDlg->m_lstbxPChannels.GetItemDataPtr( nPos );
		ASSERT( pPChannelGroup != NULL );
		ASSERT( pPChannelGroup != (CPChannelGroup *)0xFFFFFFFF );

		// Highlight corresponding item in PChannel listbox
		m_pGraphDlg->m_lstbxPChannels.SetSel( -1, FALSE ); 
		m_pGraphDlg->m_lstbxPChannels.SetSel( nPos, TRUE ); 
		m_pGraphDlg->m_lstbxPChannels.SetCaretIndex( nPos, 0 ); 

		// Get nearest tool
		CTool* pTool = m_pGraphDlg->GetToolFromXPos( point.x );
		if( pTool )
		{
			// First set capture
			SetCapture();

			// Save undo state
			m_pGraphDlg->m_pGraph->m_pUndoMgr->SaveState( m_pGraphDlg->m_pGraph, theApp.m_hInstance, IDS_UNDO_CHANGE_PCHANNELS );

			// Set m_nSetPChannelState
			if( pTool->ContainsPChannelGroup( pPChannelGroup ) )
			{
				m_nSetPChannelState = FALSE;
				pTool->RemovePChannelGroup( pPChannelGroup );
			}
			else
			{
				m_nSetPChannelState = TRUE;
				pTool->InsertPChannelGroup( pPChannelGroup );
			}

			// Redraw graph
			RECT rect;
			GetItemRect( nPos, &rect );
			InvalidateRect( &rect, FALSE );
		}
	}

	CListBox::OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphListBox::OnLButtonDblClk

void CGraphListBox::OnLButtonDblClk( UINT nFlags, CPoint point ) 
{
	OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphListBox::OnLButtonUp

void CGraphListBox::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( CWnd::GetCapture() == this )
	{
		::ReleaseCapture();

		m_pGraphDlg->m_pGraph->SetModified( TRUE );
		m_pGraphDlg->m_pGraph->SyncGraphWithDirectMusic();
	}
	
	m_nSetPChannelState = -1;

	CListBox::OnLButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CToolHeaderBtn

CToolHeaderBtn::CToolHeaderBtn()
{
	m_pGraphDlg = NULL;
}

CToolHeaderBtn::~CToolHeaderBtn()
{
}


/////////////////////////////////////////////////////////////////////////////
// CToolHeaderBtn message handlers

BEGIN_MESSAGE_MAP(CToolHeaderBtn, CButton)
	//{{AFX_MSG_MAP(CToolHeaderBtn)
	ON_WM_ERASEBKGND()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CToolHeaderBtn::OnSetFocus

void CToolHeaderBtn::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CButton::OnSetFocus( pOldWnd );
	
	m_pGraphDlg->m_nEditMenuCtrlID = IDC_TOOL_HEADER;
}


/////////////////////////////////////////////////////////////////////////////
// CToolHeaderBtn::OnEraseBkgnd

BOOL CToolHeaderBtn::OnEraseBkgnd( CDC* pDC ) 
{
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CToolHeaderBtn::DrawItem

void CToolHeaderBtn::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC )
	{
		CRect rect( lpDrawItemStruct->rcItem );
		CBrush brush;

		pDC->Draw3dRect( &rect, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW) );

		if( brush.CreateSolidBrush( GetSysColor(COLOR_BTNFACE) ) )
		{
			CBrush* pOldBrush = pDC->SelectObject( &brush );
			rect.InflateRect( -1, -1 );
			pDC->FillRect( &rect, &brush );
			pDC->SelectObject( pOldBrush );
		}		

		CString strTools;
		strTools.LoadString( IDS_TOOL_PALETTE_TEXT );
		rect.left += 2;
        int nBkModeOld = pDC->SetBkMode( TRANSPARENT );
        pDC->DrawText( strTools, -1, &rect, (DT_SINGLELINE | DT_VCENTER | DT_LEFT | DT_NOPREFIX) );
        pDC->SetBkMode( nBkModeOld );
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CToolListBox

CToolListBox::CToolListBox()
{
	m_pGraphDlg = NULL;
}

CToolListBox::~CToolListBox()
{
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::CreateDataObject

HRESULT CToolListBox::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIGraphDocType8 != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}
	*ppIDataObject = NULL;

	HRESULT hr = E_FAIL;

	CDirectMusicGraph* pTempGraph = NULL;
	IDMUSProdNode* pITempGraphNode = NULL;

	// Create temporary graph and insert selected tool
	int nPos = GetCurSel();
	if( nPos != LB_ERR )
	{
		RegisteredTool* pRegisteredTool = (RegisteredTool *)GetItemDataPtr( nPos );
		
		if( pRegisteredTool != NULL 
		&&  pRegisteredTool != (RegisteredTool *)0xFFFFFFFF )
		{
			IDirectMusicTool* pIDMTool;
			if( SUCCEEDED ( ::CoCreateInstance( pRegisteredTool->clsidTool, NULL, CLSCTX_INPROC_SERVER,
												IID_IDirectMusicTool, (void**)&pIDMTool ) ) )
			{
				if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIGraphDocType8->AllocNode( GUID_ToolGraphNode, &pITempGraphNode ) ) )
				{
					pTempGraph = (CDirectMusicGraph *)pITempGraphNode;

					// Set root and parent node of ALL children
					theApp.SetNodePointers( pITempGraphNode, pITempGraphNode, NULL );

					CTool* pTool = new CTool( pRegisteredTool->clsidTool, pIDMTool );
					if( pTool )
					{
						pTool->RefreshStreamOfData();
						pTempGraph->InsertTool( pTool, -1 );
						RELEASE( pTool );
					}
					else
					{
						pTempGraph = NULL;
					}
				}

				RELEASE( pIDMTool );
			}
		}
	}
	if( pTempGraph == NULL )
	{
		RELEASE( pITempGraphNode );
		return E_FAIL;
	}

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		RELEASE( pITempGraphNode );
		return E_OUTOFMEMORY;
	}

	// Save temporary Graph
	IStream* pIStream;
	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// Make sure we know this tool is from the palette 
		pTempGraph->m_GraphUI.dwFlagsUI |= GRAPHUI_FROM_TOOL_PALETTE;
		
		if( SUCCEEDED ( pTempGraph->Save( pIStream, FALSE ) ) )
		{
			// Place CF_GRAPH into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pGraphComponent->m_cfGraph, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->SaveClipFormat( theApp.m_pGraphComponent->m_cfProducerFile, pITempGraphNode, &pIStream ) ) )
		{
			// Graph nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pGraphComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			RELEASE( pIStream );
		}
	}

	// Delete temporary graph and selected tool
	RELEASE( pITempGraphNode );

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox message handlers

BEGIN_MESSAGE_MAP(CToolListBox, CListBox)
	//{{AFX_MSG_MAP(CToolListBox)
	ON_WM_CAPTURECHANGED()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::OnSetFocus

void CToolListBox::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnSetFocus( pOldWnd );
	
	m_pGraphDlg->m_nEditMenuCtrlID = IDC_TOOL_LIST;
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::DrawItem

void CToolListBox::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( lpDrawItemStruct->itemID == -1 )
	{
		return;
	}

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
    ||  lpDrawItemStruct->itemAction & ODA_SELECT 
    ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
	{
		RegisteredTool* pRegisteredTool = (RegisteredTool *)lpDrawItemStruct->itemData; 
		ASSERT( pRegisteredTool != NULL );

	    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
		int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

		CRect rect( 0, 0, nWidth, nHeight );

		CDC dc;
		CBitmap bmp;

		if( dc.CreateCompatibleDC( pDC )
		&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
		{
			CFont* pFontOld = NULL;
			CFont* pFont = m_pGraphDlg->CreateFont();
			if( pFont )
			{
				pFontOld = dc.SelectObject( pFont );
			}
			CBitmap* pBitmapOld = dc.SelectObject( &bmp );
			int nBkModeOld = dc.SetBkMode( TRANSPARENT );

			if( lpDrawItemStruct->itemState & ODS_SELECTED )
			{
				if( ::GetFocus() == GetSafeHwnd() )
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
					dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
				}
				else
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
					dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
				}
			}
			else
			{
				dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
				dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
			}

			// Draw the item
			rect.left  += 3;
			dc.DrawText( pRegisteredTool->strName, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );
			pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
						 &dc, 0, 0, SRCCOPY );

			// Clean up
			dc.SetBkMode( nBkModeOld );
			if( pFontOld )
			{
				dc.SelectObject( pFontOld );
				pFont->DeleteObject();
				delete pFont;
			}
			if( pBitmapOld )
			{
				dc.SelectObject( pBitmapOld );
			}
		}

		if( ::GetFocus() == GetSafeHwnd() )
		{
			if( (lpDrawItemStruct->itemAction & ODA_FOCUS)
			&&  (lpDrawItemStruct->itemState & ODS_SELECTED) )
			{
				InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
				pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
				InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::MeasureItem

void CToolListBox::MeasureItem( LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDC* pDC = GetDC();
	if( pDC )
	{
		CFont* pFontOld = NULL;
		CFont* pFont = m_pGraphDlg->CreateFont();
		if( pFont )
		{
			pFontOld = pDC->SelectObject( pFont );
		}

		TEXTMETRIC tm;
		pDC->GetTextMetrics( &tm );
		lpMeasureItemStruct->itemHeight = tm.tmHeight + 1;
		
		if( pFontOld )
		{
			pDC->SelectObject( pFontOld );
			pFont->DeleteObject();
			delete pFont;
		}

		ReleaseDC( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::OnMouseMove

void CToolListBox::OnMouseMove( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER( nFlags );

	ASSERT( m_pGraphDlg != NULL );
	
	if( CWnd::GetCapture() == this )
	{
		if( m_pGraphDlg->m_dwMouseDownButton != 0 )
		{
			// See if user is moving the mouse
			if( m_pGraphDlg->m_rectMouseDown.PtInRect( point ) == FALSE )
			{
				// Start drag drop
				m_pGraphDlg->DoDrag( IDC_TOOL_LIST, m_pGraphDlg->m_dwMouseDownButton ); 
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::OnCaptureChanged

void CToolListBox::OnCaptureChanged( CWnd *pWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pWnd == this )
	{
		return;
	}

	m_pGraphDlg->m_dwMouseDownButton = 0;
	m_pGraphDlg->m_rectMouseDown.SetRectEmpty();

	
	CListBox::OnCaptureChanged( pWnd );
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::OnLButtonDown

void CToolListBox::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraphDlg != NULL );

	if( m_pGraphDlg->m_dwMouseDownButton == 0 )
	{
		BOOL fOutside;

		// Get nearest item
		int nPos = ItemFromPoint( point, fOutside );
		if( fOutside == FALSE
		&&  nPos != LB_ERR )
		{ 
			CRect rect;

			GetItemRect( nPos, &rect );
			if( rect.PtInRect( point ) )
			{
				// Cursor is in the nearest item
				SetCurSel( nPos );

				// First set capture
				SetCapture();

				// Now store fields used when drag drop is initiated
				m_pGraphDlg->m_dwMouseDownButton = MK_LBUTTON;

				m_pGraphDlg->m_pointMouseDown.x = point.x;
				m_pGraphDlg->m_pointMouseDown.y = point.y;

				m_pGraphDlg->m_rectMouseDown.left = point.x - 5;
				m_pGraphDlg->m_rectMouseDown.top = point.y - 5;
				m_pGraphDlg->m_rectMouseDown.right = point.x + 5;
				m_pGraphDlg->m_rectMouseDown.bottom = point.y + 5;
			}
		}
	}

	CListBox::OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::OnLButtonUp

void CToolListBox::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraphDlg->m_dwMouseDownButton == MK_LBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}
	}
	
	CListBox::OnLButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::OnRButtonDown

void CToolListBox::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraphDlg != NULL );

	if( m_pGraphDlg->m_dwMouseDownButton == 0 )
	{
		BOOL fOutside;

		// Get nearest item
		int nPos = ItemFromPoint( point, fOutside );
		if( fOutside == FALSE
		&&  nPos != LB_ERR )
		{
			CRect rect;

			GetItemRect( nPos, &rect );
			if( rect.PtInRect( point ) )
			{
				// Cursor is in the nearest item
				SetCurSel( nPos ); 

				// First set capture
				SetCapture();

				// Now store fields used when drag drop is initiated
				m_pGraphDlg->m_dwMouseDownButton = MK_RBUTTON;

				m_pGraphDlg->m_pointMouseDown.x = point.x;
				m_pGraphDlg->m_pointMouseDown.y = point.y;

				m_pGraphDlg->m_rectMouseDown.left = point.x - 5;
				m_pGraphDlg->m_rectMouseDown.top = point.y - 5;
				m_pGraphDlg->m_rectMouseDown.right = point.x + 5;
				m_pGraphDlg->m_rectMouseDown.bottom = point.y + 5;
			}
		}
	}

	CListBox::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CToolListBox::OnRButtonUp

void CToolListBox::OnRButtonUp( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraphDlg->m_dwMouseDownButton == MK_RBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}
	}
	
	CListBox::OnRButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg

//IMPLEMENT_DYNCREATE(CGraphDlg, CFormView)

CGraphDlg::CGraphDlg()
	: CFormView(CGraphDlg::IDD)
{
	//{{AFX_DATA_INIT(CGraphDlg)
	//}}AFX_DATA_INIT

	m_pGraphCtrl = NULL;
	m_pGraph = NULL;

	m_nPChannelSplitterXPos = 0;
	m_nToolSplitterXPos = 0;

	m_nEditMenuCtrlID = 0;

	m_pIDataObject = NULL;
	m_nStartDragControlID = 0;
	m_dwStartDragButton = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_pDragImage = NULL;
	m_pDragGraph = NULL;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_fDragToSameGraph = false;
	m_pointMouseDown.x = 0;
	m_pointMouseDown.y = 0;

	m_pINodeRightMenu = NULL;
	m_pointRightMenu.x = -1;
	m_pointRightMenu.y = -1;

	m_dwMouseDownButton = 0;
	m_pToolForShiftClick = NULL;
	m_pToolToToggle = NULL;
	m_dwScrollTick = 0;
}

CGraphDlg::~CGraphDlg()
{
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::RefreshControls

void CGraphDlg::RefreshControls( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	FillPChannelListBox();
	FillGraphListBox();
	m_btnGraphHeader.Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::ResetContent

void CGraphDlg::ResetContent( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_lstbxPChannels.ResetContent();
	m_lstbxGraph.ResetContent();
	m_btnGraphHeader.Invalidate();
}


void CGraphDlg::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGraphDlg)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGraphDlg, CFormView)
	//{{AFX_MSG_MAP(CGraphDlg)
	ON_COMMAND(IDM_DRAG_MOVE, OnDragRMenuMove)
	ON_COMMAND(IDM_DRAG_COPY, OnDragRMenuCopy)
	ON_COMMAND(IDM_DRAG_CANCEL, OnDragRMenuCancel)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg diagnostics

#ifdef _DEBUG
void CGraphDlg::AssertValid() const
{
	CFormView::AssertValid();
}

void CGraphDlg::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// IUknown CGraphDlg::QueryInterface

HRESULT CGraphDlg::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDropSource)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDropSource *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDropTarget) )
    {
        AddRef();
        *ppvObj = (IDropTarget *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown CGraphDlg::AddRef

ULONG CGraphDlg::AddRef( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown CGraphDlg::Release

ULONG CGraphDlg::Release( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    ASSERT( m_dwRef != 0 );	// m_dwRef should never get to zero.

//  if( m_dwRef == 0 )		   CGraphDlg should be deleted when		
//  {						   control is destroyed. 						
//		delete this;		
//		return 0;
//  }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg IDropSource implementation

/////////////////////////////////////////////////////////////////////////////
// IDropSource CGraphDlg::QueryContinueDrag

HRESULT CGraphDlg::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton == MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton == MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropSource CGraphDlg::GiveFeedback

HRESULT CGraphDlg::GiveFeedback( DWORD dwEffect )
{
	UNREFERENCED_PARAMETER( dwEffect );

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg IDropTarget implementation

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CGraphDlg::DragEnter

HRESULT CGraphDlg::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pIDataObject == NULL );

	m_dwScrollTick = 0;

	// Store IDataObject associated with current drag-drop operation
	m_pIDataObject = pIDataObject;
	m_pIDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		// Show the feedback image
		m_pDragImage->DragEnter( GetDesktopWindow (), point );
	}

	// Make sure editor is on top
	if( m_pGraph->m_hWndEditor )
	{
		::BringWindowToTop( m_pGraph->m_hWndEditor );
	}

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CGraphDlg::DragOver

HRESULT CGraphDlg::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIDataObject != NULL );

	POINT point;
	point.x = pt.x;
	point.y = pt.y;

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( CanPasteFromData( m_pIDataObject, true, point ) == S_OK )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	// Scroll?
	{
		RECT rect;
		m_btnGraphHeader.ScreenToClient( &point );
		m_btnGraphHeader.GetClientRect( &rect );

		if( point.x < 0
		||  point.x > rect.right )
		{
			if( m_dwScrollTick == 0 )
			{
				m_dwScrollTick = GetTickCount() + 350;
			}
			else if( m_dwScrollTick < GetTickCount() )
			{
				if( point.x < 0 )
				{
					m_lstbxGraph.SendMessage( WM_HSCROLL,
											  MAKEWPARAM( SB_THUMBPOSITION, max(0, m_lstbxGraph.m_nHScrollPos - 30) ),
											  NULL );
				}
				else
				{
					int nExtent = m_lstbxGraph.GetHorizontalExtent();
					m_lstbxGraph.SendMessage( WM_HSCROLL,
											  MAKEWPARAM( SB_THUMBPOSITION, min(nExtent, m_lstbxGraph.m_nHScrollPos + 30) ),
											  NULL );
				}

				m_dwScrollTick += 100;
			}
			
			dwEffect |= DROPEFFECT_SCROLL;
		}
		else
		{
			m_dwScrollTick = 0;
		}

		m_btnGraphHeader.ClientToScreen( &point );
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CGraphDlg::DragLeave

HRESULT CGraphDlg::DragLeave( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_dwScrollTick = 0;

	// Release IDataObject
	RELEASE( m_pIDataObject );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CGraphDlg::Drop

HRESULT CGraphDlg::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	UNREFERENCED_PARAMETER( grfKeyState );

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIDataObject != NULL );
	ASSERT( m_pIDataObject == pIDataObject );
	ASSERT( m_pGraph != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	POINT point;
	point.x = pt.x;
	point.y = pt.y;
	if( m_pDragGraph == m_pGraph )
	{
		if( m_nStartDragControlID == IDC_GRAPH_HEADER )
		{
			CTool* pToolStart = GetToolFromXPos( m_pointMouseDown.x );
			if( pToolStart )
			{
				m_btnGraphHeader.ScreenToClient( &point );
				CTool* pToolEnd = GetToolFromXPos( point.x );
				m_btnGraphHeader.ClientToScreen( &point );

				if( pToolStart == pToolEnd )
				{
					// Nothing to do
					DragLeave();
					return hr;
				}
			}
		}
	}

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( theApp.m_hInstance, IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Display and track menu
			CPoint point( pt.x, pt.y );
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			DestroyMenu( hMenu );

			// Need to process WM_COMMAND from TrackPopupMenu
			MSG msg;
			while( ::PeekMessage( &msg, GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}

			// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
			m_dwOverDragEffect = m_dwDragRMenuEffect;
			m_dwDragRMenuEffect = DROPEFFECT_NONE;
		}
	}

	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Paste data
		if( m_pDragGraph == m_pGraph )
		{
			m_fDragToSameGraph = true;
		}
		if( m_dwOverDragEffect == DROPEFFECT_MOVE 
		&&  m_fDragToSameGraph )
		{
			m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_MOVE_TOOLS );
			m_pGraph->DeleteMarkedTools( UD_DRAGSELECT );
		}
		else
		{
			m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_INSERT_TOOLS );
		}
		hr = PasteFromData( pIDataObject, true, point );
		if( SUCCEEDED ( hr ) )
		{
			*pdwEffect = m_dwOverDragEffect;
		}

		m_pGraph->SetModified( TRUE );
		if( m_fDragToSameGraph == false )
		{
			m_pGraph->Refresh();
		}

		// Refresh properties
		OnViewProperties();
	}

	// Cleanup
	DragLeave();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::Create

BOOL CGraphDlg::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !CFormView::Create( lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext ) )
	{
		return FALSE;
	}

	// Create the splitter bars
	m_wndPChannelSplitter.Create( this, 3, IDC_PCHANNEL_SPLITTER );
	m_wndToolSplitter.Create( this, 6, IDC_TOOL_SPLITTER );
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnInitialUpdate

void CGraphDlg::OnInitialUpdate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	CFormView::OnInitialUpdate();
	
	HRESULT hr = ::RegisterDragDrop( GetSafeHwnd(), (IDropTarget *)this );
	ASSERT(SUCCEEDED(hr));

	// Subclass controls
	m_btnPChannelHeader.SubclassDlgItem( IDC_PCHANNEL_HEADER, this );
	m_btnPChannelHeader.m_pGraphDlg = this;

	m_lstbxPChannels.SubclassDlgItem( IDC_PCHANNEL_LIST, this );
	m_lstbxPChannels.m_pGraphDlg = this;

	m_btnGraphHeader.SubclassDlgItem( IDC_GRAPH_HEADER, this );
	m_btnGraphHeader.m_pGraphDlg = this;

	m_lstbxGraph.SubclassDlgItem( IDC_GRAPH_LIST, this );
	m_lstbxGraph.m_pGraphDlg = this;

	m_btnToolHeader.SubclassDlgItem( IDC_TOOL_HEADER, this );
	m_btnToolHeader.m_pGraphDlg = this;

	m_lstbxTools.SubclassDlgItem( IDC_TOOL_LIST, this );
	m_lstbxTools.m_pGraphDlg = this;

	// Populate controls
	FillToolsListBox();
	FillPChannelListBox();
	FillGraphListBox();

	// If the graph has no PChannels, open up the Add/Remove PChannels dialog
	if( m_pGraph
	&&  m_pGraph->m_lstGraphPChannelGroups.IsEmpty() )
	{
		::PostMessage( GetSafeHwnd(), WM_COMMAND, IDM_INSERT_PCHANNEL_GROUP, 0 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnDestroy

void CGraphDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = ::RevokeDragDrop( GetSafeHwnd() );
	ASSERT( SUCCEEDED( hr ) );

	CFormView::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnDragRMenuMove

void CGraphDlg::OnDragRMenuMove() 
{
	m_dwDragRMenuEffect = DROPEFFECT_MOVE;	
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnDragRMenuCopy

void CGraphDlg::OnDragRMenuCopy() 
{
	m_dwDragRMenuEffect = DROPEFFECT_COPY;	
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnDragRMenuCancel

void CGraphDlg::OnDragRMenuCancel() 
{
	m_dwDragRMenuEffect = DROPEFFECT_NONE;	
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnSize

void CGraphDlg::OnSize( UINT nType, int cx, int cy ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow(m_wndPChannelSplitter) )
	{
		return;
	}

	ASSERT( m_pGraph != NULL );

	CRect rect;
	GetClientRect( &rect );

	// Determine tool splitter bar position
	m_nToolSplitterXPos = cx - m_pGraph->m_GraphUI.nRegisteredToolPaneWidth;
	m_nToolSplitterXPos = max( m_wndPChannelSplitter.GetWidth(), m_nToolSplitterXPos ); 
	m_nToolSplitterXPos = min( m_nToolSplitterXPos, (cx - m_wndToolSplitter.GetWidth()) );
	
	// Move the tool splitter bar
    m_wndToolSplitter.MoveWindow( m_nToolSplitterXPos, 0, m_wndToolSplitter.GetWidth(), cy, TRUE );

	// Recalc registered tools pane
	int nX  = m_nToolSplitterXPos + m_wndToolSplitter.GetWidth();
	int nCX = max( 0, (cx - nX) );
	int nCY = max( 0, (cy - GRAPH_HEADER_HEIGHT) );
    m_btnToolHeader.MoveWindow( nX, 0, (nCX + 1), GRAPH_HEADER_HEIGHT, TRUE );
    m_lstbxTools.MoveWindow( nX, GRAPH_HEADER_HEIGHT, nCX, nCY, TRUE );

	// Determine pchannel splitter bar position
	m_nPChannelSplitterXPos = m_pGraph->m_GraphUI.nPChannelColumnWidth;
	m_nPChannelSplitterXPos = max( 0, m_nPChannelSplitterXPos ); 
	m_nPChannelSplitterXPos = min( m_nPChannelSplitterXPos, (m_nToolSplitterXPos - m_wndPChannelSplitter.GetWidth()) );
	
	// Move the pchannel splitter bar
    m_wndPChannelSplitter.MoveWindow( m_nPChannelSplitterXPos, 0, m_wndPChannelSplitter.GetWidth(), cy, TRUE );
	
	// Recalc graph pane
	nCX = min( m_pGraph->m_GraphUI.nPChannelColumnWidth, m_nPChannelSplitterXPos );
    m_btnPChannelHeader.MoveWindow( 0, 0, nCX, GRAPH_HEADER_HEIGHT, TRUE );
    m_lstbxPChannels.MoveWindow( 0, GRAPH_HEADER_HEIGHT, nCX, nCY, TRUE );

	nX = m_nPChannelSplitterXPos + m_wndPChannelSplitter.GetWidth()+ 1;
	nCX = max( 0, (m_nToolSplitterXPos - nX) );
    m_btnGraphHeader.MoveWindow( nX, 0, nCX, GRAPH_HEADER_HEIGHT, TRUE );
    m_lstbxGraph.MoveWindow( nX, GRAPH_HEADER_HEIGHT, nCX, nCY, TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::DoDrag

void CGraphDlg::DoDrag( UINT nID, DWORD dwStartDragButton )
{
	// If already dragging, just return
	if( m_pDragImage )
	{
		return;
	}

	IDataObject* pIDataObject = NULL;
	switch( nID )
	{
		case IDC_TOOL_LIST:
			m_lstbxTools.CreateDataObject( &pIDataObject );
			break;

		case IDC_GRAPH_HEADER:
			m_pGraph->MarkSelectedTools( UD_DRAGSELECT );
			m_btnGraphHeader.CreateDataObject( &pIDataObject );
			break;

		default:
			ASSERT( 0 );
			break;
	}

	if( pIDataObject )
	{
		DWORD dwEffect;
		HRESULT hr;

		// Create image used for drag-drop feedback
		if( m_pDragImage )
		{
			m_pDragImage->BeginDrag( 0, CPoint(8, 12) );
		}

		// Start drag-drop operation
		DWORD dwOKDragEffects = DROPEFFECT_COPY;
		if( nID == IDC_GRAPH_HEADER )
		{
			dwOKDragEffects |= DROPEFFECT_MOVE;
		}

		m_pDragGraph = m_pGraph;
		m_nStartDragControlID = nID;
		m_dwStartDragButton = dwStartDragButton;
		m_fDragToSameGraph = false;
		hr = ::DoDragDrop( pIDataObject, (IDropSource *)this, dwOKDragEffects, &dwEffect );
		m_pDragGraph = NULL;
		m_nStartDragControlID = 0;
		m_dwStartDragButton = 0;
		m_pointMouseDown.x = 0;
		m_pointMouseDown.y = 0;

		// Delete image used for drag-drop feedback
		if( m_pDragImage )
		{
			m_pDragImage->EndDrag();

			delete m_pDragImage;
			m_pDragImage = NULL;
		}

		switch( hr )
		{
			case DRAGDROP_S_DROP:
				if( dwEffect & DROPEFFECT_MOVE )
				{
					ASSERT( nID == IDC_GRAPH_HEADER );
					if( m_fDragToSameGraph == false )
					{
						m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_DELETE_TOOLS );
						m_pGraph->DeleteMarkedTools( UD_DRAGSELECT );
						m_pGraph->SetModified( TRUE );
					}
					m_pGraph->Refresh();
				}
				else if( dwEffect & DROPEFFECT_COPY )
				{
					if( m_fDragToSameGraph == false )
					{
						m_pGraph->UnselectAllTools();
					}
					m_pGraph->Refresh();
				}
				break;
		}

		m_fDragToSameGraph = false;
		m_pGraph->UnMarkTools( UD_DRAGSELECT ); 
			
		RELEASE( pIDataObject );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::CanPasteFromData

HRESULT CGraphDlg::CanPasteFromData( IDataObject* pIDataObject, bool fInDragDrop, POINT pt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( fInDragDrop )
	{
		CRect rect;

		bool fCursorOverGraph = false;

		// Make sure cursor is over Graph
		if( fCursorOverGraph == false )
		{
			m_btnGraphHeader.ScreenToClient( &pt );
			m_btnGraphHeader.GetClientRect( &rect );
			if( rect.PtInRect( pt ) )
			{
				fCursorOverGraph = true;
			}
			m_btnGraphHeader.ClientToScreen( &pt );
		}
		if( fCursorOverGraph == false )
		{
			m_lstbxGraph.ScreenToClient( &pt );
			m_lstbxGraph.GetClientRect( &rect );
			if( rect.PtInRect( pt ) )
			{
				fCursorOverGraph = true;
			}
			m_lstbxGraph.ClientToScreen( &pt );
		}
		if( fCursorOverGraph == false )
		{
			return S_FALSE;
		}
	}

	// Create a new CDllJazzDataObject and see if it contains a Graph
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pGraphComponent->m_cfGraph );

	RELEASE( pDataObject );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::PasteFromData

HRESULT CGraphDlg::PasteFromData( IDataObject* pIDataObject, bool fInDragDrop, POINT pt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( CanPasteFromData( pIDataObject, fInDragDrop, pt ) != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pGraphComponent->m_cfGraph ) ) )
	{
		// Handle CF_GRAPH format
		hr = PasteCF_GRAPH( pDataObject, pIDataObject, fInDragDrop, pt );
	}

	RELEASE( pDataObject );
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::PasteCF_GRAPH

HRESULT CGraphDlg::PasteCF_GRAPH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	// Unselect all Tools
	m_pGraph->UnselectAllTools();

	// Determine paste index
	int nPasteIndex = -1;
	if( fInDragDrop )
	{
		// Drop
		m_btnGraphHeader.ScreenToClient( &pt );
		CTool* pTool = GetToolFromXPos( pt.x );
		if( pTool )
		{
			nPasteIndex = m_pGraph->ToolToIndex( pTool );
		}
	}
	else
	{
		// Paste
		CTool* pTool = GetToolFromXPos( m_btnGraphHeader.m_nLastXPos );
		if( pTool )
		{
			nPasteIndex = m_pGraph->ToolToIndex( pTool );
		}
	}

	// Determine whether or not source and target graphs are the same
	bool fToolsFromSameGraph = false;
	if( fInDragDrop )
	{
		// Drop
		if( m_pDragGraph == m_pGraph )
		{
			fToolsFromSameGraph = true;
		}
	}
	else
	{
		// Paste
		if( theApp.IsInClipboard( m_pGraph ) )
		{
			fToolsFromSameGraph = true;
		}
	}

	// Get the stream containing the Graph
	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pGraphComponent->m_cfGraph, &pIStream  ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create a temporary Graph and load the stream
		CDirectMusicGraph* pTempGraph = new CDirectMusicGraph;
		if( pTempGraph )
		{
			hr = pTempGraph->Load( pIStream );

			// Transfer tools from temporary Graph to m_pGraph
			if( SUCCEEDED ( hr ) )
			{
				if( pTempGraph->m_lstGraphTools.IsEmpty() == FALSE )
				{
					// Paste tools
					POSITION pos = pTempGraph->m_lstGraphTools.GetHeadPosition();
					while( pos )
					{
						CTool* pTool = pTempGraph->m_lstGraphTools.GetNext( pos );

						pTool->AddRef();
						{
							pTempGraph->RemoveTool( pTool );

							// If pasting from Tool Palette or a different Graph.....
							if( (pTempGraph->m_GraphUI.dwFlagsUI & GRAPHUI_FROM_TOOL_PALETTE)
							||  (fToolsFromSameGraph == false) )
							{
								// Replace tool's PChannelGroups with all PChannelGroups in this Graph
								m_pGraph->UseGraphPChannelGroups( pTool );
							}
							pTool->CombineAllPChannelGroups();

							pTool->m_fSelected = TRUE;
							m_pGraph->InsertTool( pTool, nPasteIndex );
							if( nPasteIndex >= 0 )
							{
								nPasteIndex++;
							}
						}
						RELEASE( pTool );
					}
				}
			}

			RELEASE( pTempGraph );
		}

		RELEASE( pIStream );
	}

	// Refresh properties
	if( fInDragDrop == FALSE
	||  fToolsFromSameGraph == false )
	{
		OnViewProperties();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::EndTrack

void CGraphDlg::EndTrack( int nID, int nXPos )
{
	ASSERT( m_pGraph != NULL );

	CRect rect;
	GetClientRect( &rect );

	switch( nID )
	{
		case IDC_PCHANNEL_SPLITTER:
			m_pGraph->m_GraphUI.nPChannelColumnWidth = nXPos;
			m_lstbxGraph.InvalidateRect( NULL );
			break;

		case IDC_TOOL_SPLITTER:
			m_pGraph->m_GraphUI.nRegisteredToolPaneWidth = rect.right - nXPos;
			m_lstbxTools.InvalidateRect( NULL );
			break;
	}

	m_pGraph->SetModified( TRUE );
	OnSize( SIZE_RESTORED, rect.Width(), rect.Height() );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::GetToolFromXPos

CTool* CGraphDlg::GetToolFromXPos( int nXPos )
{
	if( nXPos < 0 )
	{
		return NULL;
	}

	// Account for horizontal scrolling
	nXPos += m_lstbxGraph.m_nHScrollPos;

	int nX = 0;

	CTool* pTool;
	for( int i = 0 ;  pTool = m_pGraph->MyEnumTools(i) ;  i++ )
	{
		if( pTool == NULL )
		{
			break;
		}

		nX += pTool->GetColumnWidth();

		if( nXPos <= nX )
		{
			return pTool;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::FillToolsListBox

void CGraphDlg::FillToolsListBox( void )
{
	ASSERT( theApp.m_pGraphComponent != NULL );

	CDC* pDC = m_lstbxTools.GetDC();
	if( pDC )
	{
		TEXTMETRIC tm;
		pDC->GetTextMetrics( &tm );

		RegisteredTool* pRegisteredTool;
		CSize sizeText;
		int nPos;
		int nCurExtent = m_lstbxTools.GetHorizontalExtent();

		for( int i = 0 ;  pRegisteredTool = theApp.m_pGraphComponent->EnumRegisteredTools(i) ;  i++ )
		{
			if( pRegisteredTool == NULL )
			{
				break;
			}

			nPos = m_lstbxTools.AddString( pRegisteredTool->strName );
			m_lstbxTools.SetItemDataPtr( nPos, pRegisteredTool );

			sizeText = pDC->GetTextExtent( pRegisteredTool->strName );
			if( sizeText.cx > nCurExtent )
			{
				nCurExtent = sizeText.cx;
				m_lstbxTools.SetHorizontalExtent( nCurExtent );
			}
		}

		m_lstbxTools.ReleaseDC( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::FillPChannelListBox

void CGraphDlg::FillPChannelListBox( void )
{
	m_lstbxPChannels.ResetContent();
	m_lstbxPChannels.SetHorizontalExtent( 0 );

	POSITION pos = m_pGraph->m_lstGraphPChannelGroups.GetHeadPosition();
	while( pos )
	{ 
		CPChannelGroup* pPChannelGroup = m_pGraph->m_lstGraphPChannelGroups.GetNext( pos );

		int nPos = m_lstbxPChannels.AddString( _T("") );
		m_lstbxPChannels.SetItemDataPtr( nPos, pPChannelGroup );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::FillGraphListBox

void CGraphDlg::FillGraphListBox( void )
{
	ASSERT( theApp.m_pGraphComponent != NULL );

	m_lstbxGraph.SetRedraw( FALSE );
	
	// Fill listbox
	m_lstbxGraph.ResetContent();
	POSITION pos = m_pGraph->m_lstGraphPChannelGroups.GetHeadPosition();
	while( pos )
	{ 
		CPChannelGroup* pPChannelGroup = m_pGraph->m_lstGraphPChannelGroups.GetNext( pos );

		int nPos = m_lstbxGraph.AddString( _T("") );
		m_lstbxGraph.SetItemDataPtr( nPos, pPChannelGroup );
	}

	// Set horizontal extent
	CTool* pTool;
	int nExtent = 0;
	for( int i = 0 ;  pTool = m_pGraph->MyEnumTools(i) ;  i++ )
	{
		if( pTool == NULL )
		{
			break;
		}

		nExtent += pTool->GetColumnWidth();
	}
	m_lstbxGraph.SetHorizontalExtent( nExtent );
	m_lstbxGraph.SendMessage( WM_HSCROLL,
							  MAKEWPARAM( SB_THUMBPOSITION, min(m_lstbxGraph.m_nHScrollPos, nExtent) ),
							  NULL );

	m_lstbxGraph.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::CreateFont

CFont* CGraphDlg::CreateFont( void )
{
	CFont* pFont = new CFont;

	if( pFont 
	&&  pFont->CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						   DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						   DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		return pFont;
	}

	if( pFont )
	{
		delete pFont;
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnUpdateEditCut

void CGraphDlg::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	BOOL fEnable = FALSE;

	switch( m_nEditMenuCtrlID )
	{
		case IDC_PCHANNEL_LIST:
			fEnable = FALSE;
			break;

		default:
			if( m_pGraph->GetFirstSelectedTool() != NULL )
			{
				fEnable = TRUE;
			}
			break;
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnEditCut

void CGraphDlg::OnEditCut() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	switch( m_nEditMenuCtrlID )
	{
		case IDC_PCHANNEL_LIST:
			// Nothing to do
			break;

		default:
			if( m_pGraph->GetFirstSelectedTool() != NULL )
			{
				OnEditCopy();
				OnEditDelete();
			}
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnUpdateEditCopy

void CGraphDlg::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );
	
	BOOL fEnable = FALSE;

	switch( m_nEditMenuCtrlID )
	{
		case IDC_PCHANNEL_LIST:
			fEnable = FALSE;
			break;

		default:
			if( m_pGraph->GetFirstSelectedTool() != NULL )
			{
				fEnable = TRUE;
			}
			break;
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnEditCopy

void CGraphDlg::OnEditCopy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	switch( m_nEditMenuCtrlID )
	{
		case IDC_PCHANNEL_LIST:
			// Nothing to do
			break;

		default:
			if( m_pGraph->GetFirstSelectedTool() != NULL )
			{
				IDataObject* pIDataObject;
				if( SUCCEEDED ( m_btnGraphHeader.CreateDataObject( &pIDataObject ) ) )
				{
					theApp.PutDataInClipboard( pIDataObject, m_pGraph );

					RELEASE( pIDataObject );
				}
			}
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnUpdateEditPaste

void CGraphDlg::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL fEnable = FALSE;

	// Get the IDataObject
	IDataObject* pIDataObject;
	if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
	{
		POINT pt = {0, 0};
		HRESULT hr = CanPasteFromData( pIDataObject, false, pt );
		
		RELEASE( pIDataObject );
		
		if( hr == S_OK )
		{
			fEnable = TRUE;
		}
	}
	
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnEditPaste

void CGraphDlg::OnEditPaste() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the IDataObject
	IDataObject* pIDataObject;
	if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
	{
		m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_INSERT_TOOLS );

		POINT pt = {0, 0};
		PasteFromData( pIDataObject, false, pt );

		m_pGraph->SetModified( TRUE );
		m_pGraph->Refresh();
		
		RELEASE( pIDataObject );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnUpdateEditInsert

void CGraphDlg::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	pCmdUI->Enable( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnEditInsert

void CGraphDlg::OnEditInsert() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	POINT pt = {0, 0};
	OnChangePChannelGroup( pt, true );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnUpdateEditDelete

void CGraphDlg::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );
	
	BOOL fEnable = FALSE;
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_PCHANNEL_LIST:
			if( m_lstbxPChannels.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;

		default:
			if( m_pGraph->GetFirstSelectedTool() != NULL )
			{
				fEnable = TRUE;
			}
			break;
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnEditDelete

void CGraphDlg::OnEditDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_PCHANNEL_LIST:
			OnDeletePChannelGroups();
			break;

		default:
			OnDeleteTools();
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnEditSelectAll

void CGraphDlg::OnEditSelectAll() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_PCHANNEL_LIST:
			m_lstbxPChannels.SetSel( -1, TRUE );
			m_lstbxPChannels.SetCaretIndex( m_lstbxPChannels.GetTopIndex(), 0 ); 
			break;

		default:
			m_pGraph->SelectAllTools();
			m_btnGraphHeader.Invalidate();
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnViewProperties

BOOL CGraphDlg::OnViewProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdPropSheet* pIPropSheet;

	ASSERT( m_pGraph != NULL );
	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	if( FAILED ( theApp.m_pGraphComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		return FALSE;
	}

	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return TRUE;
	}

	BOOL fSuccess = FALSE;
	CTool* pTool = m_pGraph->GetFirstSelectedTool();
	if( pTool )
	{
		// Tool properties
		if( SUCCEEDED ( pTool->OnShowProperties() ) )
		{
			fSuccess = TRUE;
		}
	}
	else
	{
		// Graph properties
		if( SUCCEEDED ( m_pGraph->OnShowProperties() ) )
		{
			fSuccess = TRUE;
		}
	}

	RELEASE( pIPropSheet );

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnChangePChannelGroup

void CGraphDlg::OnChangePChannelGroup( POINT pointChange, bool fInsertNewGroup )
{
	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	CPChannelGroup* pPChannelGroupToEdit = NULL;

	if( fInsertNewGroup == false )
	{
		// Convert from screen to client coordinates
		m_lstbxPChannels.ScreenToClient( &pointChange );

		// Get the item at pointChange
		BOOL fOutside;
		UINT nPos = m_lstbxPChannels.ItemFromPoint( pointChange, fOutside );
		if( nPos != LB_ERR
		&&  fOutside == FALSE )
		{
			pPChannelGroupToEdit = (CPChannelGroup *)m_lstbxPChannels.GetItemDataPtr( nPos );
			ASSERT( pPChannelGroupToEdit != NULL );
			ASSERT( pPChannelGroupToEdit != (CPChannelGroup *)0xFFFFFFFF );
		}
		else
		{
			if( m_lstbxPChannels.GetSelCount() == 1 )
			{
				int nPos;
				m_lstbxPChannels.GetSelItems( 1, &nPos );
				pPChannelGroupToEdit = (CPChannelGroup *)m_lstbxPChannels.GetItemDataPtr( nPos );
				ASSERT( pPChannelGroupToEdit != NULL );
				ASSERT( pPChannelGroupToEdit != (CPChannelGroup *)0xFFFFFFFF );
			}
		}
	}

	// Initialize the add PChannel dialog
	CDlgAddPChannel dlgAddPChannel;

	// Set dialog title
	if( pPChannelGroupToEdit )
	{
		AfxFormatString1( dlgAddPChannel.m_strTitle, IDS_TITLE_CHANGE_PCHANNEL_GROUP, m_pGraph->m_strName );
	}
	else
	{
		AfxFormatString1( dlgAddPChannel.m_strTitle, IDS_TITLE_INSERT_PCHANNEL_GROUP, m_pGraph->m_strName );
	}

	// Set the PChannelName pointer
	IDMUSProdProject* pIProject;
	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->FindProject( m_pGraph, &pIProject ) ) )
	{
		pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&dlgAddPChannel.m_pIPChannelName );
		RELEASE( pIProject );
	}

	// Set up the array of existing PChannels
	POSITION pos = m_pGraph->m_lstGraphPChannelGroups.GetHeadPosition();
	while( pos )
	{
		CPChannelGroup* pPChannelGroup = m_pGraph->m_lstGraphPChannelGroups.GetNext( pos );

		// Skip the item we're editing
		if( pPChannelGroup != pPChannelGroupToEdit )
		{
			// Iterate through all PChannels
			for( DWORD i = 0;  i < pPChannelGroup->m_dwNbrPChannels;  i++ )
			{
				// Add each PChannel to the array (order is irrelevant)
				dlgAddPChannel.m_adwExistingPChannels.Add( pPChannelGroup->m_pdwPChannel[i] );
			}
		}
	}

	// Set up the array of PChannels for the item we're adding
	if( pPChannelGroupToEdit )
	{
		// Itrate through all PChannels
		for( DWORD i=0; i < pPChannelGroupToEdit->m_dwNbrPChannels; i++ )
		{
			// Add each PChannel to the array (order is irrelevant)
			dlgAddPChannel.m_adwPChannels.Add( pPChannelGroupToEdit->m_pdwPChannel[i] );
		}
	}

	if( dlgAddPChannel.DoModal() == IDOK )
	{
		bool fChanged = false;
		bool fNewPChannelGroup = false;
		if( pPChannelGroupToEdit == NULL )
		{
			// Create a new PChannel group
			pPChannelGroupToEdit = new CPChannelGroup();
			fNewPChannelGroup = true;
		}

		if( pPChannelGroupToEdit )
		{
			// Check if anything changed
			if( (pPChannelGroupToEdit->m_dwNbrPChannels != (DWORD)dlgAddPChannel.m_adwPChannels.GetSize())
			||	(memcmp( pPChannelGroupToEdit->m_pdwPChannel, dlgAddPChannel.m_adwPChannels.GetData(),
						 sizeof(DWORD) * pPChannelGroupToEdit->m_dwNbrPChannels )) )
			{
				// Create a new array to store the PChannels in
				DWORD *pdwNewPChannels = new DWORD[dlgAddPChannel.m_adwPChannels.GetSize()];
				if( pdwNewPChannels )
				{
					// Save undo state
					if( pPChannelGroupToEdit->m_dwNbrPChannels == 0 )
					{
						m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_INSERT_PCHANNELGROUP );
					}
					else
					{
						m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_CHANGE_PCHANNELGROUP );
					}

					// Copy the PChannels into the new array
					memcpy( pdwNewPChannels, dlgAddPChannel.m_adwPChannels.GetData(), sizeof(DWORD) * dlgAddPChannel.m_adwPChannels.GetSize() );

					// Delete the old array
					delete [] pPChannelGroupToEdit->m_pdwPChannel;

					// Set the size of, and point to the new array
					pPChannelGroupToEdit->m_pdwPChannel = pdwNewPChannels;
					pPChannelGroupToEdit->m_dwNbrPChannels = dlgAddPChannel.m_adwPChannels.GetSize();

					// Reposition in m_lstPChannelGroups
					m_pGraph->RepositionPChannelGroup( pPChannelGroupToEdit );

					// Add new PChannelGroup to all Tools
					if( fNewPChannelGroup )
					{
						POSITION pos = m_pGraph->m_lstGraphTools.GetHeadPosition();
						while( pos )
						{
							CTool* pTool = m_pGraph->m_lstGraphTools.GetNext( pos );

							pTool->InsertPChannelGroup( pPChannelGroupToEdit );
						}
					}

					// Sync list box controls
					m_pGraph->SetModified( TRUE );
					m_pGraph->Refresh();
				}
			}
		}
	}

	m_lstbxPChannels.SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnDeletePChannelGroups

void CGraphDlg::OnDeletePChannelGroups( void )
{
	int nNbrSelItems = m_lstbxPChannels.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_DELETE_PCHANNELGROUP );

		m_lstbxPChannels.GetSelItems( nNbrSelItems, pnSelItems );

		for( int i = 0;  i < nNbrSelItems ;  i++ )
		{
			CPChannelGroup* pPChannelGroup = (CPChannelGroup *)m_lstbxPChannels.GetItemDataPtr( pnSelItems[i] );
		
			if( pPChannelGroup
			&&  pPChannelGroup != (CPChannelGroup *)0xFFFFFFFF )
			{
				// Remove pPChannelGroup from m_lstPChannelGroups
				m_pGraph->RemovePChannelGroup( pPChannelGroup );
			}
		}

		// Sync list box controls
		m_pGraph->SetModified( TRUE );
		m_pGraph->Refresh();

		delete [] pnSelItems;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnDeleteTools

void CGraphDlg::OnDeleteTools( void )
{
	CTool* pTool = m_pGraph->GetFirstSelectedTool();
	if( pTool == NULL )
	{
		// Nothing to do
		return;
	}

	m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_DELETE_TOOLS );
	m_pGraph->DeleteSelectedTools();

	m_btnGraphHeader.m_nLastXPos = INT_MAX;
	m_pGraph->SetModified( TRUE );
	m_pGraph->Refresh();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnContextMenu

void CGraphDlg::OnContextMenu( CWnd* pWnd, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pWnd != NULL );
	ASSERT( m_pGraph != NULL );

	switch( pWnd->GetDlgCtrlID() )
	{
		case IDC_PCHANNEL_HEADER:
		case IDC_PCHANNEL_LIST:
		{
			CPChannelGroup* pPChannelGroupToEdit = NULL;

			m_lstbxPChannels.SetFocus(); 

			// Get the item under the mouse
			BOOL fOutside;
			POINT ptClient = point;
			m_lstbxPChannels.ScreenToClient( &ptClient );
			UINT nPos = m_lstbxPChannels.ItemFromPoint( ptClient, fOutside );
			if( nPos != LB_ERR
			&&  fOutside == FALSE )
			{
				pPChannelGroupToEdit = (CPChannelGroup *)m_lstbxPChannels.GetItemDataPtr( nPos );
				ASSERT( pPChannelGroupToEdit != NULL );
				ASSERT( pPChannelGroupToEdit != (CPChannelGroup *)0xFFFFFFFF );
			}

			// Load menu
			HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_GRAPH_PCHANNELGROUPS) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			// Initialize menu
			::EnableMenuItem( hMenuPopup, IDM_CHANGE_PCHANNEL_GROUP, ( (pPChannelGroupToEdit != NULL) || (m_lstbxPChannels.GetSelCount() == 1) )
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_DELETE_PCHANNEL_GROUP, ( m_lstbxPChannels.GetSelCount() > 0 )
								? MF_ENABLED : MF_GRAYED );

			m_pointRightMenu = point;
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			::DestroyMenu( hMenu );
			break;
		}
			 
		case IDC_GRAPH_HEADER:
		case IDC_GRAPH_LIST:
		{
			// Get the tool under the mouse
			POINT ptClient = point;
			m_btnGraphHeader.ScreenToClient( &ptClient );
			CTool* pTool = GetToolFromXPos( ptClient.x );

			// Load menu
			HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_GRAPH_TOOLS) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			// Initialize menu
			CTool* pFirstSelectedTool = m_pGraph->GetFirstSelectedTool();
			::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, pFirstSelectedTool ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, pFirstSelectedTool ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_SELECT_ALL, m_pGraph->MyEnumTools(0) ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, pFirstSelectedTool ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_TOOL_PROPERTIES, pFirstSelectedTool ? MF_ENABLED : MF_GRAYED );
			
			BOOL fEnable = FALSE;
			if( ::GetFocus() == m_lstbxPChannels.GetSafeHwnd()
			&&  m_lstbxPChannels.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			::EnableMenuItem( hMenuPopup, IDM_DELETE_PCHANNEL_GROUP, fEnable ? MF_ENABLED : MF_GRAYED );

			fEnable = FALSE;
			IDataObject* pIDataObject;
			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				POINT pt = {0, 0};
				HRESULT hr = CanPasteFromData( pIDataObject, false, pt );
				
				RELEASE( pIDataObject );
				
				if( hr == S_OK )
				{
					fEnable = TRUE;
				}
			}
			::EnableMenuItem( hMenuPopup, ID_EDIT_PASTE, fEnable ? MF_ENABLED : MF_GRAYED );

			m_pointRightMenu = point;
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			::DestroyMenu( hMenu );
			break;
		}
			 
		case IDC_TOOL_HEADER:
		case IDC_TOOL_LIST:
			// Nothing to do
			break;

		default:
		{
			HINSTANCE hInstance;
			UINT nResourceId;
			if( SUCCEEDED ( m_pGraph->GetRightClickMenuId(&hInstance, &nResourceId) ) )
			{
				HMENU hMenu = ::LoadMenu( hInstance, MAKEINTRESOURCE(nResourceId) );
				if( hMenu )
				{
					HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
					m_pGraph->OnRightClickMenuInit( hMenuPopup );

					m_pINodeRightMenu = m_pGraph;
					m_pointRightMenu = point;
					::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
									  point.x, point.y, 0, GetSafeHwnd(), NULL );

					DestroyMenu( hMenu );
				}
			}
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDlg::OnCommand

BOOL CGraphDlg::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( HIWORD(wParam) == 0 )	// menu command
	{
		if( m_pINodeRightMenu )	// can receive menu commands when m_pINodeRightMenu is NULL
		{
			m_pINodeRightMenu->OnRightClickMenuSelect( LOWORD(wParam) );
			m_pINodeRightMenu = NULL ;
			return TRUE;
		}

		switch( LOWORD(wParam) )
		{
			case IDM_CHANGE_PCHANNEL_GROUP:
				OnChangePChannelGroup( m_pointRightMenu, false );
				return TRUE;
			
			case IDM_INSERT_PCHANNEL_GROUP:
				OnChangePChannelGroup( m_pointRightMenu, true );
				return TRUE;

			case IDM_DELETE_PCHANNEL_GROUP:
				OnDeletePChannelGroups();
				return TRUE;

			case ID_EDIT_CUT:
				OnEditCut();
				return TRUE;

			case ID_EDIT_COPY:
				OnEditCopy();
				return TRUE;

			case ID_EDIT_PASTE:
				OnEditPaste();
				return TRUE;

			case IDM_SELECT_ALL:
				OnEditSelectAll();
				return TRUE;

			case ID_EDIT_INSERT:
				OnEditInsert();
				return TRUE;

			case ID_EDIT_DELETE:
				OnEditDelete();
				return TRUE;

			case IDM_TOOL_PROPERTIES:
			{
				CTool* pTool = m_pGraph->GetFirstSelectedTool();
				if( pTool )
				{
					pTool->OnShowProperties();
				}
				return TRUE;
			}
		}
	}
	
	return CFormView::OnCommand( wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphCtl.h ===
#if !defined(AFX_GRAPHCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_GRAPHCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// GraphCtl.h : Declaration of the CGraphCtrl ActiveX Control class.

#include "GraphDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CGraphCtrl : See GraphCtl.cpp for implementation.

class CGraphCtrl : public COleControl
{
	DECLARE_DYNCREATE(CGraphCtrl)

// Constructor
public:
	CGraphCtrl();

// Attributes
public:
	CGraphDlg*			m_pGraphDlg;
	HWND				m_hWndContainer;

private:
	HMENU				m_hMenuInPlace;
	HACCEL				m_hAcceleratorTable;
	CDirectMusicGraph*	m_pGraph;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGraphCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	virtual HMENU OnGetInPlaceMenu();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CGraphCtrl();

	DECLARE_OLECREATE_EX(CGraphCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CGraphCtrl)      // GetTypeInfo
	DECLARE_OLECTLTYPE(CGraphCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CGraphCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void AboutBox();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditDelete();
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnEditInsert();
	afx_msg void OnEditSelectAll();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditRedo();
	afx_msg void OnHelpFinder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CGraphCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CGraphCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CGraphCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GRAPHCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphDocType.h ===
#ifndef __GRAPHDOCTYPE_H__
#define __GRAPHDOCTYPE_H__

// GraphDocType.h : header file
//


class CGraphDocType : public IDMUSProdDocType8
{
public:
    CGraphDocType();
	~CGraphDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );

	HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

	// Additional functions

	// Member variables
private:
    DWORD m_dwRef;
};

#endif // __GRAPHDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphDocType.cpp ===
// GraphDocType.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Graph.h"
#include <dmusicf.h>
#include <mmreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType constructor/destructor

CGraphDocType::CGraphDocType()
{
    m_dwRef = 0;
}

CGraphDocType::~CGraphDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType IUnknown implementation

HRESULT CGraphDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CGraphDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CGraphDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::GetResourceId

HRESULT CGraphDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_GRAPH_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::DoesExtensionMatch

HRESULT CGraphDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_GRAPH_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::DoesIdMatch

HRESULT CGraphDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualGUID(rguid, GUID_ToolGraphNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::AllocNode

HRESULT STDMETHODCALLTYPE CGraphDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_ToolGraphNode) )
	{
		// Create a new Graph 
		CDirectMusicGraph* pGraph = new CDirectMusicGraph;
		if( pGraph == NULL )
		{
			return E_OUTOFMEMORY ;
		}

		// Create the Undo Manager
		if( pGraph->CreateUndoMgr() == FALSE )
		{
			RELEASE( pGraph );
			return E_OUTOFMEMORY;
		}

		*ppINode = (IDMUSProdNode *)pGraph;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType:::OnFileNew

HRESULT CGraphDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
								  IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIGraphNode;

	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Graph 
	hr = AllocNode( GUID_ToolGraphNode, &pIGraphNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pIGraphNode, pIGraphNode, NULL );

		// Add node to Project Tree
		if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->AddNode(pIGraphNode, NULL) ) )
		{
			CDirectMusicGraph* pGraph = (CDirectMusicGraph *)pIGraphNode;

			// Get the filename
			BSTR bstrName;

			if( SUCCEEDED ( pIGraphNode->GetNodeName( &bstrName ) ) )
			{
				pGraph->m_strOrigFileName = bstrName;
				pGraph->m_strOrigFileName += _T(".tgp");
				::SysFreeString( bstrName );
			}

			// Add Graph to Graph component list 
			theApp.m_pGraphComponent->AddToGraphFileList( pGraph );

			*ppIDocRootNode = pIGraphNode;
			pGraph->SetModified( TRUE );
			hr = S_OK;
		}
		else
		{
			RELEASE( pIGraphNode );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::OnFileOpen

HRESULT CGraphDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
								   IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;
	CDirectMusicGraph* pGraph;
	CString strFileName;
	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}
	*ppIDocRootNode = NULL;

	// Create a new Graph 
	pGraph = new CDirectMusicGraph;
	if( pGraph == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	theApp.m_pGraphComponent->m_nNextGraph--;

	// Create the Undo Manager
	if( pGraph->CreateUndoMgr() == FALSE )
	{
		RELEASE( pGraph );
		return E_OUTOFMEMORY;
	}

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		pGraph->m_strOrigFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		int nFindPos = pGraph->m_strOrigFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			pGraph->m_strOrigFileName = pGraph->m_strOrigFileName.Right( pGraph->m_strOrigFileName.GetLength() - nFindPos - 1 );
		}

		pPersistInfo->Release();
	}

	// Load the Graph file
	hr = pGraph->Load( pIStream );
	if( !SUCCEEDED ( hr ) )
	{
		RELEASE( pGraph );
		return hr;
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pGraph, pGraph, NULL );

	// Add node to Project Tree
	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->AddNode(pGraph, NULL) ) )
	{
		pGraph->SetModified( FALSE );

		// Add Graph to Graph component list 
		theApp.m_pGraphComponent->AddToGraphFileList( pGraph );

		*ppIDocRootNode = pGraph;

		hr = S_OK;
	}
	else
	{
		RELEASE( pGraph );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::OnFileSave

HRESULT CGraphDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::GetListInfo

HRESULT CGraphDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Create temporary graph object to retrieve list info
	CDirectMusicGraph* pGraph = new CDirectMusicGraph;
	if( pGraph )
	{
		// Create the Undo Manager
		if( pGraph->CreateUndoMgr() )
		{
			hr = pGraph->ReadListInfoFromStream( pIStream, pListInfo );
		}

		RELEASE( pGraph );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::IsFileTypeExtension

HRESULT CGraphDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".tgp") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".tgr") )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::GetObjectDescriptorFromNode

HRESULT CGraphDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Graph Node
	CDirectMusicGraph* pGraph;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_ToolGraphNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pGraph = (CDirectMusicGraph *)pIDocRootNode;

	return pGraph->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::GetObjectRiffId

HRESULT CGraphDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Graph Node
	if( IsEqualGUID ( guidNodeId, GUID_ToolGraphNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_TOOLGRAPH_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDocType::GetObjectExt

HRESULT CGraphDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Graph Node
	if( IsEqualGUID ( guidNodeId, GUID_ToolGraphNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".tgp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".tgr";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphDlg.h ===
#if !defined(AFX_GRAPHDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_)
#define AFX_GRAPHDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// GraphDlg.h : header file
//

#include "Splitter.h"


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CGraphHeaderBtn window

class CGraphHeaderBtn : public CButton
{
friend class CGraphDlg;

// Construction
public:
	CGraphHeaderBtn();
	virtual ~CGraphHeaderBtn();

// Attributes
public:
	CGraphDlg*	m_pGraphDlg;
	int			m_nLastXPos;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGraphHeaderBtn)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	HRESULT CreateDataObject( IDataObject** ppIDataObject );

	// Generated message map functions
protected:
	//{{AFX_MSG(CGraphHeaderBtn)
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CGraphListBox window

class CGraphListBox : public CListBox
{
// Construction
public:
	CGraphListBox();
	virtual ~CGraphListBox();

// Attributes
public:
	CGraphDlg*	m_pGraphDlg;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGraphListBox)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_VIRTUAL

protected:
	short	m_nSetPChannelState;

// Implementation
public:
	int		m_nHScrollPos;
	int		m_nVScrollPos;

	// Generated message map functions
protected:
	//{{AFX_MSG(CGraphListBox)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CPChannelHeaderBtn window

class CPChannelHeaderBtn : public CButton
{
friend class CGraphDlg;

// Construction
public:
	CPChannelHeaderBtn();

// Attributes
public:
	CGraphDlg*	m_pGraphDlg;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPChannelHeaderBtn)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPChannelHeaderBtn();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPChannelHeaderBtn)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CPChannelListBox window

class CPChannelListBox : public CListBox
{
// Construction
public:
	CPChannelListBox();

// Attributes
public:
	CGraphDlg*	m_pGraphDlg;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPChannelListBox)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPChannelListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPChannelListBox)
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnDblClk();
	afx_msg int VKeyToItem(UINT nKey, UINT nIndex);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CToolHeaderBtn window

class CToolHeaderBtn : public CButton
{
friend class CGraphDlg;

// Construction
public:
	CToolHeaderBtn();

// Attributes
public:
	CGraphDlg*	m_pGraphDlg;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CToolHeaderBtn)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CToolHeaderBtn();

	// Generated message map functions
protected:
	//{{AFX_MSG(CToolHeaderBtn)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CToolListBox window

class CToolListBox : public CListBox
{
// Construction
public:
	CToolListBox();
	virtual ~CToolListBox();

// Attributes
public:
	CGraphDlg*	m_pGraphDlg;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CToolListBox)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	HRESULT CreateDataObject( IDataObject** ppIDataObject );

	// Generated message map functions
protected:
	//{{AFX_MSG(CToolListBox)
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CGraphDlg form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CGraphDlg : public CFormView, public IDropSource, public IDropTarget
{
friend class CPChannelHeaderBtn;
friend class CPChannelListBox;
friend class CGraphHeaderBtn;
friend class CGraphListBox;
friend class CToolHeaderBtn;
friend class CToolListBox;

public:
	CGraphDlg();           // protected constructor used by dynamic creation
	virtual ~CGraphDlg();

    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IDropSource methods
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

	// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

	// Additional methods
protected:
	HRESULT CanPasteFromData( IDataObject* pIDataObject, bool fInDragDrop, POINT pt );
	HRESULT PasteFromData( IDataObject* pIDataObject, bool fInDragDrop, POINT pt );
	HRESULT PasteCF_GRAPH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt );
	void FillToolsListBox();
	void FillPChannelListBox();
	void FillGraphListBox();
	
	void OnChangePChannelGroup( POINT point, bool fInsertNewGroup );
	void OnDeletePChannelGroups();

	CTool* GetToolFromXPos( int nXPos );
	void OnDeleteTools();

public:
	void DoDrag( UINT nID, DWORD dwStartDragButton ); 
	void RefreshControls();
	void ResetContent();
	void OnUpdateEditCut( CCmdUI* pCmdUI );
	void OnEditCut();
	void OnUpdateEditCopy( CCmdUI* pCmdUI );
	void OnEditCopy();
	void OnUpdateEditPaste( CCmdUI* pCmdUI );
	void OnEditPaste();
	void OnUpdateEditInsert( CCmdUI* pCmdUI );
	void OnEditInsert();
	void OnUpdateEditDelete( CCmdUI* pCmdUI );
	void OnEditDelete();
	void OnEditSelectAll();
	BOOL OnViewProperties();
	void EndTrack( int nID, int nXPos );
	CFont* CreateFont();

private:
	CPChannelHeaderBtn	m_btnPChannelHeader;		// Subclasses IDC_PCHANNEL_HEADER
	CPChannelListBox	m_lstbxPChannels;			// Subclasses IDC_PCHANNEL_LIST
	CGraphHeaderBtn		m_btnGraphHeader;			// Subclasses IDC_GRAPH_HEADER
	CGraphListBox		m_lstbxGraph;				// Subclasses IDC_GRAPH_LIST
	CToolHeaderBtn		m_btnToolHeader;			// Subclasses IDC_TOOL_HEADER
	CToolListBox		m_lstbxTools;				// Subclasses IDC_TOOL_LIST

	CSplitter			m_wndPChannelSplitter;
	CSplitter			m_wndToolSplitter;
	int					m_nPChannelSplitterXPos;
	int					m_nToolSplitterXPos;

	int					m_nEditMenuCtrlID;			// Last control to have the focus

	IDataObject*		m_pIDataObject;				// Object being dragged	
	UINT				m_nStartDragControlID;		// Control that initiated drag operation
	DWORD				m_dwStartDragButton;		// Mouse button that initiated drag operation
	DWORD				m_dwOverDragButton;			// Mouse button stored in IDropTarget::DragOver
	DWORD				m_dwOverDragEffect;			// Drag effects stored in IDropTarget::DragOver
	CImageList*			m_pDragImage;				// Image used for drag operation feedback
	DWORD				m_dwDragRMenuEffect;		// Result from drag context menu
	CDirectMusicGraph*	m_pDragGraph;				// Tools being dragged from this Graph
	bool				m_fDragToSameGraph;			// Tools were dropped in same Graph

	IDMUSProdNode*		m_pINodeRightMenu;			// Recipient of right menu command id
	POINT				m_pointRightMenu;			// x,y coords of right click

	DWORD				m_dwMouseDownButton;		// MK_RBUTTON or MK_LBUTTON
	CRect				m_rectMouseDown;			// If user moves out of this rect start drag-drop
	POINT				m_pointMouseDown;			// Origin of drag-drop operation

	CTool*				m_pToolForShiftClick;
	CTool*				m_pToolToToggle;
	DWORD				m_dwScrollTick;

public:
	CGraphCtrl*			m_pGraphCtrl;
	CDirectMusicGraph*	m_pGraph;

// Form Data
public:
	//{{AFX_DATA(CGraphDlg)
	enum { IDD = IDD_DLG_GRAPH };
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGraphDlg)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CGraphDlg)
	afx_msg void OnDragRMenuMove();
	afx_msg void OnDragRMenuCopy();
	afx_msg void OnDragRMenuCancel();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GRAPHDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphRef.h ===
#ifndef __GRAPHREF_H__
#define __GRAPHREF_H__

// GraphRef.h : header file
//

#include "GraphComponent.h"
#include "GraphDocType.h"

class CGraphRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CGraphRef();
	~CGraphRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CDirectMusicGraph*	m_pGraph;		// GraphRef refers to this Graph

private:
    DWORD				m_dwRef;
	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*		m_pIParentNode;
};

#endif // __GRAPHREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\PChannelGroup.cpp ===
// PChannelGroup.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Graph.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// CPChannelGroup Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPChannelGroup::CPChannelGroup( void )
{
	m_dwNbrPChannels = 0;
	m_pdwPChannel = NULL;
}

CPChannelGroup::~CPChannelGroup()
{
	if( m_pdwPChannel )
	{
		delete [] m_pdwPChannel;
	}
	m_dwNbrPChannels = 0;

	// Cleanup references
	CTool* pTool;
	while( !m_lstTools.IsEmpty() )
	{
		pTool = m_lstTools.RemoveHead();
		RELEASE( pTool );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelGroup::FormatPChannelText

void CPChannelGroup::FormatPChannelText( CString& strText )
{
	strText.Empty();

	ASSERT( m_dwNbrPChannels > 0 );

	DWORD dwLastPChannel = m_pdwPChannel[0];
	bool fInRange = false;

	TCHAR achTemp2[20];
	TCHAR achNum[10];

	_itot( m_pdwPChannel[0] + 1, achNum, 10 );
	strText = achNum;

	for( DWORD i = 1 ;  i < m_dwNbrPChannels ;  i++ )
	{
		if( (dwLastPChannel + 1) == m_pdwPChannel[i] )
		{
			dwLastPChannel++;
			fInRange = true;
		}
		else
		{
			if( fInRange )
			{
				// No longer in range
				_itot( dwLastPChannel + 1, achNum, 10 );
				_tcscpy( achTemp2, "-" );
				_tcscat( achTemp2, achNum );
				_tcscat( achTemp2, ", " );
				_itot( m_pdwPChannel[i] + 1, achNum, 10 );
				_tcscat( achTemp2, achNum );
				strText += achTemp2;
				dwLastPChannel = m_pdwPChannel[i];
				fInRange = false;
			}
			else
			{
				// No longer in range
				_itot( m_pdwPChannel[i] + 1, achNum, 10 );
				_tcscpy( achTemp2, ", " );
				_tcscat( achTemp2, achNum );
				strText += achTemp2;
				dwLastPChannel = m_pdwPChannel[i];
			}
		}
	}

	if( fInRange )
	{
		_itot( dwLastPChannel + 1, achNum, 10 );
		_tcscpy( achTemp2, "-" );
		_tcscat( achTemp2, achNum );
		strText += achTemp2;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelGroup::InsertTool

void CPChannelGroup::InsertTool( CDirectMusicGraph* pGraph, CTool* pToolToInsert )
{
	if( pGraph == NULL 
	||  pToolToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	ASSERT( m_dwNbrPChannels > 0 );
	ASSERT( m_lstTools.Find( pToolToInsert ) == NULL );

	int nIndexToolToInsert = pGraph->ToolToIndex( pToolToInsert );

	CTool* pTool;
	POSITION posCurrent, posNext = m_lstTools.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pTool = m_lstTools.GetNext( posNext );

		if( pGraph->ToolToIndex(pTool) > nIndexToolToInsert )
		{
			pToolToInsert->AddRef();
			m_lstTools.InsertBefore( posCurrent, pToolToInsert );
			return;
		}
	}

	pToolToInsert->AddRef();
	m_lstTools.AddTail( pToolToInsert );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\PChannelGroup.h ===
#ifndef __PCHANNELGROUP_H__
#define __PCHANNELGROUP_H__

// PChannelGroup.h : header file
//

class CTool;

//////////////////////////////////////////////////////////////////////
//  CPChannelGroup

class CPChannelGroup
{
friend class CDirectMusicGraph;
friend class CGraphDlg;
friend class CTool;

public:
	CPChannelGroup();
	virtual ~CPChannelGroup();

	void FormatPChannelText( CString& strText );
	void InsertTool( CDirectMusicGraph* pGraph, CTool* pTool );

	// Member variables
private:
	DWORD				m_dwNbrPChannels;
	DWORD*				m_pdwPChannel;	// Variable array

	CTypedPtrList<CPtrList, CTool*> m_lstTools;
};

#endif // __PCHANNELGROUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\GraphRef.cpp ===
// GraphRef.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Graph.h"
#include "GraphRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CGraphRef constructor/destructor

CGraphRef::CGraphRef()
{
    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pGraph = NULL;
}

CGraphRef::~CGraphRef()
{
	RELEASE( m_pGraph );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IUnknown implementation

HRESULT CGraphRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CGraphRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CGraphRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetNodeImageIndex

HRESULT CGraphRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );

	return( theApp.m_pGraphComponent->GetGraphRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetFirstChild

HRESULT CGraphRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// GraphRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetNextChild

HRESULT CGraphRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// GraphRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetComponent

HRESULT CGraphRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );

	return theApp.m_pGraphComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetDocRootNode

HRESULT CGraphRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::SetDocRootNode

HRESULT CGraphRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetParentNode

HRESULT CGraphRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::SetParentNode

HRESULT CGraphRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetNodeId

HRESULT CGraphRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ToolGraphRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetNodeName

HRESULT CGraphRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph == NULL )
	{
		TCHAR achNoGraph[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_GRAPH, achNoGraph, MID_BUFFER );
		CString strNoGraph = achNoGraph;
		*pbstrName = strNoGraph.AllocSysString();
		return S_OK;
	}

    return m_pGraph->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CGraphRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a GraphRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::ValidateNodeName

HRESULT CGraphRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a GraphRef node
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::SetNodeName

HRESULT CGraphRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a GraphRef node
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetNodeListInfo

HRESULT CGraphRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph == NULL )
	{
		return E_FAIL;
	}

    return m_pGraph->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetEditorClsId

HRESULT CGraphRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph == NULL )
	{
		return E_FAIL;
	}

    *pClsId = CLSID_GraphEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetEditorTitle

HRESULT CGraphRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph == NULL )
	{
		return E_FAIL;
	}

    return m_pGraph->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetEditorWindow

HRESULT CGraphRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph == NULL )
	{
		return E_FAIL;
	}

    return m_pGraph->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::SetEditorWindow

HRESULT CGraphRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph == NULL )
	{
		return E_FAIL;
	}

    return m_pGraph->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::UseOpenCloseImages

HRESULT CGraphRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetRightClickMenuId

HRESULT CGraphRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_GRAPHREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CGraphRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CGraphRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pGraph )
			{
				return m_pGraph->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::DeleteChildNode

HRESULT CGraphRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// GraphRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::InsertChildNode

HRESULT CGraphRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// GraphRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::DeleteNode

HRESULT CGraphRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete GraphRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::OnNodeSelChanged

HRESULT CGraphRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::CreateDataObject

HRESULT CGraphRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pGraph )
	{
		// Let Graph create data object
		return m_pGraph->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::CanCut

HRESULT CGraphRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::CanCopy

HRESULT CGraphRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pGraph )
	{
		return S_OK;	// Will copy the Graph
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::CanDelete

HRESULT CGraphRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::CanDeleteChildNode

HRESULT CGraphRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Graph Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::CanPasteFromData

HRESULT CGraphRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Graph
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pGraphComponent->m_cfGraph );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Graph
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pGraph )
	{
		// Let Graph decide what can be dropped
		return m_pGraph->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::PasteFromData

HRESULT CGraphRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Graph
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pGraphComponent->m_cfGraph );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Graph
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pGraph )
	{
		// Let Graph handle paste
		return m_pGraph->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::CanChildPasteFromData

HRESULT CGraphRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Graph Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::ChildPasteFromData

HRESULT CGraphRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Graph Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdNode::GetObject

HRESULT CGraphRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CGraphRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CGraphRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pGraph )
	{
		m_pGraph->AddRef();
		*ppIDocRootNode = m_pGraph;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CGraphRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Graph Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_ToolGraphNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pGraph );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pGraph = (CDirectMusicGraph *)pIDocRootNode;
		m_pGraph->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGraphRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ToolGraphDesignerDLL.rc
//
#define IDI_ABOUTDLL                    1
#define IDS_GRAPH                       2
#define IDD_ABOUTBOX_GRAPH              2
#define IDB_GRAPH                       2
#define IDD_DLG_GRAPH                   101
#define IDC_PCHANNEL_SPLITTER           103
#define IDC_TOOL_SPLITTER               104
#define IDD_OLE_PROPPAGE_LARGE          105
#define IDS_GRAPH_COMPONENT_NAME        201
#define IDC_SOURCE                      201
#define IDC_LIST_CHANNEL                201
#define IDS_HELP_FILE_EXT               202
#define IDS_ERR_INVALIDARG              203
#define IDC_EDIT_PCHANNEL               203
#define IDR_GRAPH_DOCTYPE               204
#define IDC_BUTTON_ADD                  204
#define IDI_GRAPH_DOCTYPE_SEL           205
#define IDS_ERR_REGISTER_CF             205
#define IDM_GRAPH_NODE_RMENU            205
#define IDC_BTN_REMOVE                  205
#define IDI_GRAPHREF                    206
#define IDS_ERR_ADD_CLIPFORMAT          206
#define IDC_SPIN_PCHANNEL               206
#define IDI_GRAPHREF_SEL                207
#define IDS_ERR_ADD_IMAGELIST           207
#define IDC_EDIT_PCHANNEL_NAME          207
#define IDS_ERR_MEMORY                  208
#define IDD_DLG_ADD_PCHANNEL            208
#define IDS_ERR_ADD_DOCTYPE             209
#define IDS_ERR_MISSING_CONDUCTOR       210
#define IDS_TOOLGRAPH_TEXT              211
#define IDS_GRAPH_VERSION_TEXT          212
#define IDS_NO_GRAPH                    213
#define IDS_UNDO_GRAPH_NAME             214
#define IDS_UNDO_GRAPH_GUID             215
#define IDS_UNDO_GRAPH_LANGUAGE         216
#define IDS_UNDO                        217
#define IDS_UNDO_ACCEL                  218
#define IDS_REDO                        219
#define IDS_REDO_ACCEL                  220
#define IDC_FILE_VERSION                222
#define IDS_UNDO_GRAPH_AUTHOR           222
#define IDS_UNDO_GRAPH_COPYRIGHT        223
#define IDS_UNDO_GRAPH_SUBJECT          224
#define IDC_AUTHOR                      225
#define IDS_UNDO_GRAPH_VERSION          225
#define IDC_COPYRIGHT                   226
#define IDS_GRAPH_OBJECT_TEXT           226
#define IDC_VERSION_1                   227
#define IDS_TOOL_TEXT                   227
#define IDC_VERSION_2                   228
#define IDS_UNDO_GRAPH_INFO             228
#define IDC_VERSION_3                   229
#define IDS_TOOL_PALETTE_TEXT           229
#define IDC_VERSION_4                   230
#define IDD_TAB_GRAPH                   230
#define IDS_PCHANNEL_GROUP_TEXT         230
#define IDC_NAME                        231
#define IDC_SUBJECT                     231
#define IDS_TITLE_CHANGE_PCHANNEL_GROUP 231
#define IDS_TITLE_INSERT_PCHANNEL_GROUP 232
#define IDS_UNDO_INSERT_PCHANNELGROUP   233
#define IDS_UNDO_CHANGE_PCHANNELGROUP   234
#define IDS_UNDO_DELETE_PCHANNELGROUP   235
#define IDR_GRAPH_EDITOR                237
#define IDS_UNDO_INSERT_TOOLS           237
#define IDS_UNDO_DELETE_TOOLS           238
#define IDR_GRAPH_ACCELS                239
#define IDS_UNDO_MOVE_TOOLS             239
#define IDS_UNDO_CHANGE_PCHANNELS       240
#define IDS_NO_TOOLS_PROMPT             241
#define IDM_GRAPHREF_NODE_RMENU         242
#define IDS_MULTIPLE_TOOLS_SELECTED     242
#define IDM_DRAG_RMENU                  243
#define IDC_BUTTON_ADD16                243
#define IDS_UNDO_CHANGE_TOOL_NAME       243
#define IDD_DLG_GUID                    244
#define IDM_GRAPH_PCHANNELGROUPS        244
#define IDS_UNDO_CHANGE_TOOL_PROPERTIES 244
#define IDD_TAB_INFO                    245
#define IDM_GRAPH_TOOLS                 245
#define IDD_TAB_TOOL                    246
#define IDM_PROPERTIES                  247
#define IDM_RENAME                      248
#define IDM_INSERT_PCHANNEL_GROUP       249
#define IDM_DELETE_PCHANNEL_GROUP       250
#define IDM_CHANGE_PCHANNEL_GROUP       251
#define IDM_TOOL_PROPERTIES             252
#define IDM_DRAG_MOVE                   253
#define IDM_DRAG_CANCEL                 254
#define IDM_DRAG_COPY                   255
#define IDM_SELECT_ALL                  256
#define IDC_SPLITTER                    300
#define IDC_EDIT_GUID                   305
#define IDC_NEW_GUID                    306
#define IDC_TOOL_HEADER                 503
#define IDC_TOOL_LIST                   504
#define IDC_PCHANNEL_LIST               505
#define IDC_GRAPH_HEADER                506
#define IDC_PCHANNEL_HEADER             507
#define IDC_GRAPH_LIST                  508
#define IDC_BUTTON_TOOL_PROPERTIES      509
#define IDC_INFO                        1017
#define ID_EDIT_DELETE                  32777
#define ID_EDIT_INSERT                  32796
#define IDM_HELP_FINDER                 32815

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        302
#define _APS_NEXT_COMMAND_VALUE         32775
#define _APS_NEXT_CONTROL_VALUE         510
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\Splitter.h ===
#ifndef __SPLITTER_H__
#define __SPLITTER_H__

// Splitter.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSplitter class

class CSplitter : public CWnd
{
protected:
   CRect	m_rcTrack;
   BOOL		m_fTracking;
   BOOL		m_fVisible;
   int		m_nWidth;
   int		m_nID;
   CWnd		*m_pParent;

public:
   CSplitter();
   BOOL Create(CWnd *pParent, int nWidth, int nID, RECT *rect = NULL);
   int GetWidth();

protected:
   void OnEndCapture();
   void InvertTracker();

   //{{AFX_VIRTUAL(CSplitter)
   //}}AFX_VIRTUAL

public:
   virtual ~CSplitter();

protected:
   //{{AFX_MSG(CSplitter)
   afx_msg void OnPaint();
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnCancelMode();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
   afx_msg void OnCaptureChanged(CWnd *pWnd);
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __SPLITTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\Splitter.cpp ===
// Splitter.cpp : implementation file
//

#include "stdafx.h"

#include "ToolGraphDesignerDLL.h"
#include "Graph.h"
#include "Splitter.h"
#include "GraphDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//*****************************************************************************
//***** CSplitter
//*****************************************************************************

BEGIN_MESSAGE_MAP(CSplitter, CWnd)
	//{{AFX_MSG_MAP(CSplitter)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
	ON_WM_CAPTURECHANGED()
END_MESSAGE_MAP()

//*****************************************************************************
CSplitter::CSplitter() :
	m_rcTrack(0, 0, 0, 0),
	m_fTracking(FALSE),
	m_fVisible(FALSE),
	m_nWidth(0),
	m_nID(0),
	m_pParent(NULL)
{
}

//*****************************************************************************
CSplitter::~CSplitter()
{
}

//*****************************************************************************
int CSplitter::GetWidth( void )
{
	return m_nWidth;
}

//*****************************************************************************
BOOL CSplitter::Create( CWnd *pParent, int nWidth, int nID, RECT *rect )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UNREFERENCED_PARAMETER(rect);

	// Save our parent
	m_pParent = pParent;

	// Set our width
	m_nWidth = nWidth;

	// Set our control ID
	m_nID = nID;

	// Create our splitter class
	WNDCLASS wc;

	ZeroMemory( &wc, sizeof(wc) );
	wc.lpszClassName = "JzGraphSplitter";
	wc.style         = CS_HREDRAW | CS_VREDRAW | CS_PARENTDC;
	wc.lpfnWndProc   = ::DefWindowProc;
	wc.hInstance     = theApp.m_hInstance;
	wc.hCursor       = ::LoadCursor( theApp.m_hInstance, MAKEINTRESOURCE(IDC_SPLITTER) );
	wc.hbrBackground = (HBRUSH)( COLOR_BTNFACE + 1 );

	// Register our splitter class
	AfxRegisterClass( &wc );

	// Create our splitter
	return CWnd::Create( wc.lpszClassName, "", WS_VISIBLE | WS_CHILD, 
						 CRect(0, 0, 0, 0), pParent, IDC_SPLITTER );
}

//*****************************************************************************
void CSplitter::OnPaint()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPaintDC dc( this );
	CRect rc;
	CBrush brush;

	GetClientRect( &rc );
	rc.InflateRect( 0, 1 );
	dc.Draw3dRect( &rc, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW) );
	rc.InflateRect( 0, -1 );

	if( brush.CreateSolidBrush( GetSysColor(COLOR_BTNFACE) ) )
	{
		CBrush* pOldBrush = dc.SelectObject( &brush );
		rc.InflateRect( -1, 0 );
		dc.FillRect( &rc, &brush );
		dc.SelectObject( pOldBrush );
	}		
}

//*****************************************************************************
void CSplitter::OnLButtonDown( UINT /*nFlags*/, CPoint /*point*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pParent != NULL );

	// Capture the mouse
	SetCapture();

	// Set our initial splitter position in our parent's client coordinates
	GetWindowRect( &m_rcTrack );
	m_pParent->ScreenToClient( &m_rcTrack );

	// Set our tracking flag
	m_fTracking = TRUE;

	// Draw our initial tracker
	InvertTracker();
}

//*****************************************************************************
void CSplitter::OnLButtonUp(UINT /*nFlags*/, CPoint /*point*/)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pParent != NULL );

	BOOL fWasTracking = m_fTracking;

	OnEndCapture();

	if( fWasTracking )
	{
		CRect rect;
		m_pParent->GetClientRect( &rect );
		static_cast<CGraphDlg*>(m_pParent)->EndTrack( m_nID, m_rcTrack.left );
	}
}

//*****************************************************************************
void CSplitter::OnMouseMove( UINT /*nFlags*/, CPoint point )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fTracking )
	{
		ASSERT( m_pParent != NULL );

		// Convert point to client coordinates of our parent window
		ClientToScreen( &point );
		m_pParent->ScreenToClient( &point );

		// Get the client are of our parent
		CRect rcClient;
		m_pParent->GetClientRect( &rcClient );

		// Force the point to be in our client area
		if( point.x < rcClient.left )
		{
			point.x = rcClient.left;
		}
		if( point.x > (rcClient.right - m_nWidth) )
		{
			point.x = (rcClient.right - m_nWidth);
		}

		// If the point has changed since the last mouse move, then update change
		if( m_rcTrack.left != point.x )
		{
			InvertTracker();
			m_rcTrack.left  = point.x;
			m_rcTrack.right = point.x + m_nWidth;
			InvertTracker();
		}
	}
}

//*****************************************************************************
void CSplitter::OnCancelMode()
{
	OnEndCapture();
	CWnd::OnCancelMode();
}

//*****************************************************************************
void CSplitter::OnCaptureChanged( CWnd *pWnd )
{
	OnEndCapture();
	CWnd::OnCaptureChanged( pWnd );
}

//*****************************************************************************
void CSplitter::OnEndCapture()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fVisible )
	{
		InvertTracker();
	}

	if( m_fTracking )
	{
		ReleaseCapture();
		m_fTracking = FALSE;
	}
}

//*****************************************************************************
void CSplitter::InvertTracker()
{
	ASSERT( m_pParent != NULL );

	// Get the DC of our parent window
	CDC *pDC = GetDC();
	ASSERT( pDC != NULL );

	// Create our inverted brush pattern 
	CBrush *pBrush = CDC::GetHalftoneBrush();

	// Select the brush into our DC  
	HBRUSH hBrushStock = NULL;
	if( pBrush != NULL )
	{
		hBrushStock = (HBRUSH)SelectObject( pDC->m_hDC, pBrush->m_hObject );
	}

	CRect rect( m_rcTrack );
	m_pParent->ClientToScreen( &rect );
	ScreenToClient( &rect );

	// Draw our tracking line
	pDC->PatBlt( rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT );

	// Free our brush and DC
	if( hBrushStock != NULL )
	{
		SelectObject( pDC->m_hDC, hBrushStock );
	}

	ReleaseDC( pDC );

	// Toggle visible flag
	m_fVisible = !m_fVisible;
}

//*****************************************************************************
BOOL CSplitter::OnEraseBkgnd( CDC* pDC ) 
{
	UNREFERENCED_PARAMETER(pDC);

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\TabGraph.cpp ===
// TabGraph.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Graph.h"
#include "TabGraph.h"
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabGraph property page

CTabGraph::CTabGraph( CGraphPropPageManager* pGraphPropPageManager ) : CPropertyPage(CTabGraph::IDD)
{
	//{{AFX_DATA_INIT(CTabGraph)
	//}}AFX_DATA_INIT
	
	ASSERT( pGraphPropPageManager != NULL );

	m_pGraph = NULL;
	m_pPageManager = pGraphPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabGraph::~CTabGraph()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::SetGraph

void CTabGraph::SetGraph( CDirectMusicGraph* pGraph )
{
	m_pGraph = pGraph;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::SetModifiedFlag

void CTabGraph::SetModifiedFlag( void ) 
{
	ASSERT( m_pGraph != NULL );

	m_pGraph->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::EnableControls

void CTabGraph::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::UpdateControls

void CTabGraph::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );

	if( m_pGraph )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pGraph->m_strName );
	}
	else
	{
		m_editName.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabGraph::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabGraph)
	DDX_Control(pDX, IDC_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabGraph, CPropertyPage)
	//{{AFX_MSG_MAP(CTabGraph)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabGraph message handlers


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::OnInitDialog

BOOL CTabGraph::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::OnSetActive

BOOL CTabGraph::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CGraphPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::OnCreate

int CTabGraph::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::OnDestroy

void CTabGraph::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabGraph::OnKillFocusName

void CTabGraph::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	if( m_pGraph )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pGraph->m_strName );
		}
		else
		{
			if( strName.Compare( m_pGraph->m_strName ) != 0 )
			{
				BSTR bstrName = strName.AllocSysString();
				m_pGraph->SetNodeName( bstrName );
				theApp.m_pGraphComponent->m_pIFramework->RefreshNode( m_pGraph );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\TabInfo.cpp ===
// TabInfo.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Graph.h"
#include "TabInfo.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabInfo property page

CTabInfo::CTabInfo( CGraphPropPageManager* pGraphPropPageManager ) : CPropertyPage(CTabInfo::IDD)
{
	//{{AFX_DATA_INIT(CTabInfo)
	//}}AFX_DATA_INIT
	
	ASSERT( pGraphPropPageManager != NULL );

	m_pGraph = NULL;
	m_pPageManager = pGraphPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabInfo::~CTabInfo()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::SetGraph

void CTabInfo::SetGraph( CDirectMusicGraph* pGraph )
{
	m_pGraph = pGraph;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::SetModifiedFlag

void CTabInfo::SetModifiedFlag( void ) 
{
	ASSERT( m_pGraph != NULL );

	m_pGraph->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::EnableControls

void CTabInfo::EnableControls( BOOL fEnable ) 
{
	m_editAuthor.EnableWindow( fEnable );
	m_editCopyright.EnableWindow( fEnable );
	m_editInfo.EnableWindow( fEnable );
	m_editSubject.EnableWindow( fEnable );
	m_editVersion_1.EnableWindow( fEnable );
	m_editVersion_2.EnableWindow( fEnable );
	m_editVersion_3.EnableWindow( fEnable );
	m_editVersion_4.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::UpdateControls

void CTabInfo::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVersion_1.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVersion_1.LimitText( 4 );
	m_editVersion_2.LimitText( 4 );
	m_editVersion_3.LimitText( 4 );
	m_editVersion_4.LimitText( 4 );

	if( m_pGraph )
	{
		CString strText;

		EnableControls( TRUE );

		m_editAuthor.SetWindowText( m_pGraph->m_strAuthor );
		m_editCopyright.SetWindowText( m_pGraph->m_strCopyright );
		m_editInfo.SetWindowText( m_pGraph->m_strInfo );
		m_editSubject.SetWindowText( m_pGraph->m_strSubject );
		
		strText.Format( "%u", ((m_pGraph->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
		m_editVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", (m_pGraph->m_vVersion.dwVersionMS & 0x0000FFFF) );
		m_editVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pGraph->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
		m_editVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", (m_pGraph->m_vVersion.dwVersionLS & 0x0000FFFF) );
		m_editVersion_4.SetWindowText( strText );
	}
	else
	{
		m_editAuthor.SetWindowText( _T("") );
		m_editCopyright.SetWindowText( _T("") );
		m_editInfo.SetWindowText( _T(""));
		m_editSubject.SetWindowText( _T(""));
		m_editVersion_1.SetWindowText( _T("") );
		m_editVersion_2.SetWindowText( _T("") );
		m_editVersion_3.SetWindowText( _T("") );
		m_editVersion_4.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabInfo::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabInfo)
	DDX_Control(pDX, IDC_INFO, m_editInfo);
	DDX_Control(pDX, IDC_VERSION_4, m_editVersion_4);
	DDX_Control(pDX, IDC_VERSION_3, m_editVersion_3);
	DDX_Control(pDX, IDC_VERSION_2, m_editVersion_2);
	DDX_Control(pDX, IDC_VERSION_1, m_editVersion_1);
	DDX_Control(pDX, IDC_SUBJECT, m_editSubject);
	DDX_Control(pDX, IDC_COPYRIGHT, m_editCopyright);
	DDX_Control(pDX, IDC_AUTHOR, m_editAuthor);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CTabInfo)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillFocusAuthor)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillFocusCopyright)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillFocusSubject)
	ON_EN_KILLFOCUS(IDC_VERSION_1, OnKillFocusVersion_1)
	ON_EN_KILLFOCUS(IDC_VERSION_2, OnKillFocusVersion_2)
	ON_EN_KILLFOCUS(IDC_VERSION_3, OnKillFocusVersion_3)
	ON_EN_KILLFOCUS(IDC_VERSION_4, OnKillFocusVersion_4)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	ON_EN_KILLFOCUS(IDC_INFO, OnKillFocusInfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabInfo message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnSetActive

BOOL CTabInfo::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CGraphPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnCreate

int CTabInfo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnDestroy

void CTabInfo::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusAuthor

void CTabInfo::OnKillFocusAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CString strAuthor;

		m_editAuthor.GetWindowText( strAuthor );

		// Strip leading and trailing spaces
		strAuthor.TrimRight();
		strAuthor.TrimLeft();

		if( strAuthor.Compare( m_pGraph->m_strAuthor ) != 0 )
		{
			m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_AUTHOR );
			m_pGraph->m_strAuthor = strAuthor;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusCopyright

void CTabInfo::OnKillFocusCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CString strCopyright;

		m_editCopyright.GetWindowText( strCopyright );

		// Strip leading and trailing spaces
		strCopyright.TrimRight();
		strCopyright.TrimLeft();

		if( strCopyright.Compare( m_pGraph->m_strCopyright ) != 0 )
		{
			m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_COPYRIGHT );
			m_pGraph->m_strCopyright = strCopyright;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusInfo

void CTabInfo::OnKillFocusInfo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CString strInfo;

		m_editInfo.GetWindowText( strInfo );

		// Strip leading and trailing spaces
		strInfo.TrimRight();
		strInfo.TrimLeft();

		if( strInfo.Compare( m_pGraph->m_strInfo ) != 0 )
		{
			m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_INFO );
			m_pGraph->m_strInfo = strInfo;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusSubject

void CTabInfo::OnKillFocusSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CString strSubject;

		m_editSubject.GetWindowText( strSubject );

		// Strip leading and trailing spaces
		strSubject.TrimRight();
		strSubject.TrimLeft();

		if( strSubject.Compare( m_pGraph->m_strSubject ) != 0 )
		{
			m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_SUBJECT );
			m_pGraph->m_strSubject = strSubject;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_1

void CTabInfo::OnKillFocusVersion_1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CString strVersion_1;
		CString strGraphVersion_1;

		m_editVersion_1.GetWindowText( strVersion_1 );

		// Strip leading and trailing spaces
		strVersion_1.TrimRight();
		strVersion_1.TrimLeft();

		if( strVersion_1.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pGraph->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			m_editVersion_1.SetWindowText( strText );
		}
		else
		{
			strGraphVersion_1.Format( "%u", ((m_pGraph->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			
			if( strVersion_1.Compare( strGraphVersion_1 ) != 0 )
			{
				DWORD dwVersion_1 = _ttoi( strVersion_1 );
				dwVersion_1 = (dwVersion_1 & 0x0000FFFF) << 16;

				m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_VERSION );
				m_pGraph->m_vVersion.dwVersionMS &= 0x0000FFFF;
				m_pGraph->m_vVersion.dwVersionMS |= dwVersion_1;
				SetModifiedFlag();

				// Sync Graph with DirectMusic
				m_pGraph->SyncGraphWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_2

void CTabInfo::OnKillFocusVersion_2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CString strVersion_2;
		CString strGraphVersion_2;

		m_editVersion_2.GetWindowText( strVersion_2 );

		// Strip leading and trailing spaces
		strVersion_2.TrimRight();
		strVersion_2.TrimLeft();

		if( strVersion_2.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pGraph->m_vVersion.dwVersionMS & 0x0000FFFF) );
			m_editVersion_2.SetWindowText( strText );
		}
		else
		{
			strGraphVersion_2.Format( "%u", (m_pGraph->m_vVersion.dwVersionMS & 0x0000FFFF) );
			
			if( strVersion_2.Compare( strGraphVersion_2 ) != 0 )
			{
				DWORD dwVersion_2 = _ttoi( strVersion_2 );
				dwVersion_2 &= 0x0000FFFF;

				m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_VERSION );
				m_pGraph->m_vVersion.dwVersionMS &= 0xFFFF0000;
				m_pGraph->m_vVersion.dwVersionMS |= dwVersion_2;
				SetModifiedFlag();

				// Sync Graph with DirectMusic
				m_pGraph->SyncGraphWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_3

void CTabInfo::OnKillFocusVersion_3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CString strVersion_3;
		CString strGraphVersion_3;

		m_editVersion_3.GetWindowText( strVersion_3 );

		// Strip leading and trailing spaces
		strVersion_3.TrimRight();
		strVersion_3.TrimLeft();

		if( strVersion_3.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pGraph->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			m_editVersion_3.SetWindowText( strText );
		}
		else
		{
			strGraphVersion_3.Format( "%u", ((m_pGraph->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			
			if( strVersion_3.Compare( strGraphVersion_3 ) != 0 )
			{
				DWORD dwVersion_3 = _ttoi( strVersion_3 );
				dwVersion_3 = (dwVersion_3 & 0x0000FFFF) << 16;

				m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_VERSION );
				m_pGraph->m_vVersion.dwVersionLS &= 0x0000FFFF;
				m_pGraph->m_vVersion.dwVersionLS |= dwVersion_3;
				SetModifiedFlag();

				// Sync Graph with DirectMusic
				m_pGraph->SyncGraphWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_4

void CTabInfo::OnKillFocusVersion_4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CString strVersion_4;
		CString strGraphVersion_4;

		m_editVersion_4.GetWindowText( strVersion_4 );

		// Strip leading and trailing spaces
		strVersion_4.TrimRight();
		strVersion_4.TrimLeft();

		if( strVersion_4.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pGraph->m_vVersion.dwVersionLS & 0x0000FFFF) );
			m_editVersion_4.SetWindowText( strText );
		}
		else
		{
			strGraphVersion_4.Format( "%u", (m_pGraph->m_vVersion.dwVersionLS & 0x0000FFFF) );
			
			if( strVersion_4.Compare( strGraphVersion_4 ) != 0 )
			{
				DWORD dwVersion_4 = _ttoi( strVersion_4 );
				dwVersion_4 &= 0x0000FFFF;

				m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_VERSION );
				m_pGraph->m_vVersion.dwVersionLS &= 0xFFFF0000;
				m_pGraph->m_vVersion.dwVersionLS |= dwVersion_4;
				SetModifiedFlag();

				// Sync Graph with DirectMusic
				m_pGraph->SyncGraphWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnEditGUID

void CTabInfo::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pGraph )
	{
		CGuidDlg dlg;

		memcpy( &dlg.m_guid, &m_pGraph->m_guidGraph, sizeof(GUID) );

		if( dlg.DoModal() == IDOK )
		{
			m_pGraph->m_pUndoMgr->SaveState( m_pGraph, theApp.m_hInstance, IDS_UNDO_GRAPH_GUID );
			memcpy( &m_pGraph->m_guidGraph, &dlg.m_guid, sizeof(GUID) );
			SetModifiedFlag();

			// Sync Graph with DirectMusic
			m_pGraph->SyncGraphWithDirectMusic();

			// Notify connected nodes that Graph GUID has changed
			theApp.m_pGraphComponent->m_pIFramework->NotifyNodes( m_pGraph, DOCROOT_GuidChange, NULL );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\StdAfx.h ===
#if !defined(AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
#include <Afxdisp.h>
#include <htmlhelp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\TabInfo.h ===
#if !defined(AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabInfo.h : header file
//

#include "resource.h"

class CGraphPropPageManager;
class CDirectMusicGraph;

/////////////////////////////////////////////////////////////////////////////
// CTabInfo dialog

class CTabInfo : public CPropertyPage
{
// Construction
public:
	CTabInfo( CGraphPropPageManager* pGraphPropPageManager );
	virtual ~CTabInfo();
	void SetGraph( CDirectMusicGraph* pGraph );

// Dialog Data
	//{{AFX_DATA(CTabInfo)
	enum { IDD = IDD_TAB_INFO };
	CEdit	m_editInfo;
	CEdit	m_editVersion_4;
	CEdit	m_editVersion_3;
	CEdit	m_editVersion_2;
	CEdit	m_editVersion_1;
	CEdit	m_editSubject;
	CEdit	m_editCopyright;
	CEdit	m_editAuthor;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabInfo)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicGraph*		m_pGraph;
	CGraphPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabInfo)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusAuthor();
	afx_msg void OnKillFocusCopyright();
	afx_msg void OnKillFocusSubject();
	afx_msg void OnKillFocusVersion_1();
	afx_msg void OnKillFocusVersion_2();
	afx_msg void OnKillFocusVersion_3();
	afx_msg void OnKillFocusVersion_4();
	afx_msg void OnEditGuid();
	afx_msg void OnKillFocusInfo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\TabGraph.h ===
#if !defined(AFX_TABGRAPH_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABGRAPH_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabGraph.h : header file
//

#include "resource.h"

class CGraphPropPageManager;
class CDirectMusicGraph;

/////////////////////////////////////////////////////////////////////////////
// CTabGraph dialog

class CTabGraph : public CPropertyPage
{
// Construction
public:
	CTabGraph( CGraphPropPageManager* pGraphPropPageManager );
	virtual ~CTabGraph();
	void SetGraph( CDirectMusicGraph* pGraph );

// Dialog Data
	//{{AFX_DATA(CTabGraph)
	enum { IDD = IDD_TAB_GRAPH };
	CEdit	m_editName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabGraph)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicGraph*		m_pGraph;
	CGraphPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabGraph)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABGRAPH_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\TabTool.h ===
#if !defined(AFX_TABTOOL_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABTOOL_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabTool.h : header file
//

#include "resource.h"

class CToolPropPageManager;
class CTool;

/////////////////////////////////////////////////////////////////////////////
// CTabTool dialog

class CTabTool : public CPropertyPage
{
// Construction
public:
	CTabTool( CToolPropPageManager* pToolPropPageManager );
	virtual ~CTabTool();
	void SetTool( CTool* pTool );
	DWORD GetBitsUI();

// Dialog Data
	//{{AFX_DATA(CTabTool)
	enum { IDD = IDD_TAB_TOOL };
	CButton	m_btnToolProperties;
	CEdit	m_editName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabTool)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CTool*					m_pTool;
	CToolPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;
	DWORD					m_dwBitsUI;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabTool)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillFocusName();
	afx_msg void OnToolProperties();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABTOOL_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\Tool.cpp ===
// Tool.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Tool.h"
#include "TabTool.h"
#include <RiffStrm.h>
#include <dmusicf.h>
#include <mmreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// {FF085241-5314-4619-B4CA-11B101BE266A}
static const GUID GUID_ToolPropPageManager = 
{ 0xff085241, 0x5314, 0x4619, { 0xb4, 0xca, 0x11, 0xb1, 0x1, 0xbe, 0x26, 0x6a } };


//////////////////////////////////////////////////////////////////////
// CToolPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CToolPropPageManager::CToolPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabTool = NULL;
}

CToolPropPageManager::~CToolPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabTool )
	{
		delete m_pTabTool;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager::RemoveCurrentObject

void CToolPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager IUnknown implementation

HRESULT CToolPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CToolPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CToolPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager IDMUSProdPropPageManager implementation


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CToolPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_TOOL_TEXT );

	CTool *pTool;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pTool))) )
	{
		if(  m_pTabTool == NULL
		|| !(m_pTabTool->GetBitsUI() & UD_MULTIPLESELECT) )
		{
			CString strTemp;
			if( pTool->GetGraph() )
			{
				pTool->GetGraph()->GetName( strTemp );
				strTemp += _T(" - ");
			}

			CLSID clsidTool;
			pTool->GetCLSID( &clsidTool );

			CString strToolName;
			theApp.m_pGraphComponent->GetRegisteredToolName( clsidTool, strToolName );

			strTitle = strTemp + pTool->m_strName  + _T(" ") + strToolName + _T(" ") + strTitle;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CToolPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Tool tab
	m_pTabTool = new CTabTool( this );
	if( m_pTabTool )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabTool->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CToolPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CToolPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CToolPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CToolPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CToolPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CTool* pTool;
	
	if( m_pIPropPageObject == NULL )
	{
		pTool = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pTool ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Tool are processed in OnKillFocus
	// messages before setting the new Tool
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabTool->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Tool
	m_pTabTool->SetTool( pTool );

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CToolPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_ToolPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CTool constructor/destructor

CTool::CTool( void )
{
    m_dwRef = 0;
	AddRef();

	m_fSelected = FALSE;
	m_dwBitsUI = 0;

	m_pGraph = NULL;
	m_pIDMTool = NULL;
	m_pIStream = NULL;

	memset( &m_clsidTool, 0, sizeof(CLSID) );
}

CTool::CTool( CLSID clsidTool, IDirectMusicTool* pIDMTool )
{
    m_dwRef = 0;
	AddRef();

	m_pGraph = NULL;

	ASSERT( m_pIDMTool != NULL );
	m_pIDMTool = pIDMTool;
	m_pIDMTool->AddRef();

	m_pIStream = NULL;
	m_clsidTool = clsidTool;
}

CTool::~CTool()
{
	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	// Remove Tool from clipboard
	theApp.FlushClipboard( this );

	// Remove Tool from property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	// Cleanup references
	RELEASE( m_pIDMTool );
	RELEASE( m_pIStream );
}


/////////////////////////////////////////////////////////////////////////////
// CTool::SetModified

void CTool::SetModified( BOOL fModified )
{
	ASSERT( m_pGraph != NULL );
	if( m_pGraph )
	{
		m_pGraph->SetModified( fModified );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTool::InsertPChannelGroup

void CTool::InsertPChannelGroup( CPChannelGroup* pPChannelGroupToInsert )
{
	if( pPChannelGroupToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	ASSERT( pPChannelGroupToInsert->m_dwNbrPChannels > 0 );

	CPChannelGroup* pPChannelGroup;
	POSITION posCurrent, posNext = m_lstPChannelGroups.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pPChannelGroup = m_lstPChannelGroups.GetNext( posNext );

		ASSERT( pPChannelGroup->m_dwNbrPChannels > 0 );

		if( *pPChannelGroup->m_pdwPChannel > *pPChannelGroupToInsert->m_pdwPChannel )
		{
			// PChannelGroup should point to Tool
			pPChannelGroupToInsert->InsertTool( m_pGraph, this );

			// Tool should point to PChannelGroup
			ASSERT( m_lstPChannelGroups.Find( pPChannelGroupToInsert ) == NULL );
			m_lstPChannelGroups.InsertBefore( posCurrent, pPChannelGroupToInsert );
			return;
		}
	}

	// PChannelGroup should point to Tool
	pPChannelGroupToInsert->InsertTool( m_pGraph, this );

	// Tool should point to PChannelGroup
	ASSERT( m_lstPChannelGroups.Find( pPChannelGroupToInsert ) == NULL );
	m_lstPChannelGroups.AddTail( pPChannelGroupToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CTool::RemovePChannelGroup

void CTool::RemovePChannelGroup( CPChannelGroup* pPChannelGroupToRemove )
{
	if( pPChannelGroupToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	AddRef();
	{
		// If tool is in pPChannelGroupToRemove->m_lstTools, remove it
		POSITION pos = pPChannelGroupToRemove->m_lstTools.Find( this );
		if( pos )
		{
			pPChannelGroupToRemove->m_lstTools.RemoveAt( pos );
			Release();
		}

		// If item is in m_lstPChannelGroups, remove it
		pos = m_lstPChannelGroups.Find( pPChannelGroupToRemove );
		if( pos )
		{
			m_lstPChannelGroups.RemoveAt( pos );
		}
	}
	Release();
}


/////////////////////////////////////////////////////////////////////////////
// CTool::RemoveAllPChannelGroups

void CTool::RemoveAllPChannelGroups( void )
{
	while( !m_lstPChannelGroups.IsEmpty() )
	{
		CPChannelGroup* pPChannelGroup = m_lstPChannelGroups.GetHead();

		RemovePChannelGroup( pPChannelGroup );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CompareDWORD()

static int __cdecl CompareDWORD( const void* arg1, const void* arg2 )
{
	if( *(DWORD**)arg1 < *(DWORD**)arg2 )
	{
		return -1;
	}
	if( *(DWORD**)arg1 > *(DWORD**)arg2 )
	{
		return 1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::CombineAllPChannelGroups

void CTool::CombineAllPChannelGroups( void )
{
	// This method leaves a tool in invalid state
	// Must call InsertTool() immediately after
	//	to get everything back in working order

	// Build the PChannel array
	CDWordArray aPChannels;
	while( !m_lstPChannelGroups.IsEmpty() )
	{
		CPChannelGroup* pPChannelGroup = m_lstPChannelGroups.GetHead();

		RemovePChannelGroup( pPChannelGroup );
		for( DWORD i = 0 ;  i < pPChannelGroup->m_dwNbrPChannels ; i++ )
		{
			aPChannels.Add( pPChannelGroup->m_pdwPChannel[i] );
		}
	}

	// Sort the PChannel array
	qsort( aPChannels.GetData(), aPChannels.GetSize(), sizeof(DWORD), CompareDWORD );

	// Now create an orphan CPChannelGroup that InsertTool()
	//	will convert into valid pointers
	CPChannelGroup* pPChannelGroup = new CPChannelGroup();
	if( pPChannelGroup )
	{
		pPChannelGroup->m_dwNbrPChannels = aPChannels.GetSize();
		pPChannelGroup->m_pdwPChannel = new DWORD[aPChannels.GetSize()];
		if( pPChannelGroup->m_pdwPChannel )
		{
			memcpy( pPChannelGroup->m_pdwPChannel, aPChannels.GetData(), sizeof(DWORD) * pPChannelGroup->m_dwNbrPChannels);
		}

		// Don't call InsertPChannelGroup() because we do not want PChannelGroup to point to Tool
		ASSERT( m_lstPChannelGroups.IsEmpty() );
		m_lstPChannelGroups.AddTail( pPChannelGroup );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTool::RepositionPChannelGroup

void CTool::RepositionPChannelGroup( CPChannelGroup* pPChannelGroupToReposition )
{
	if( pPChannelGroupToReposition == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	ASSERT( pPChannelGroupToReposition->m_dwNbrPChannels > 0 );

	AddRef();
	{
		// If item is already in m_lstPChannelGroups, remove it
		POSITION pos = m_lstPChannelGroups.Find( pPChannelGroupToReposition );
		if( pos )
		{
			RemovePChannelGroup( pPChannelGroupToReposition );

			// Reinsert into the list in its new position
			InsertPChannelGroup( pPChannelGroupToReposition );
		}
	}
	Release();
}


/////////////////////////////////////////////////////////////////////////////
// CTool::ContainsPChannelGroup

bool CTool::ContainsPChannelGroup( CPChannelGroup* pPChannelGroup )
{
	POSITION pos = m_lstPChannelGroups.Find( pPChannelGroup );
	if( pos )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::GetColumnWidth

int CTool::GetColumnWidth( void )
{
	return m_ToolUI.nColumnWidth;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::SetColumnWidth

void CTool::SetColumnWidth( int nWidth )
{
	m_ToolUI.nColumnWidth = nWidth;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::GetName

void CTool::GetName( CString& strName )
{
	strName = m_strName;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::GetCLSID

void CTool::GetCLSID( CLSID* pclsidTool )
{
	*pclsidTool = m_clsidTool;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::GetBitsUI

DWORD CTool::GetBitsUI( void )
{
	return m_dwBitsUI;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::GetGraph

CDirectMusicGraph* CTool::GetGraph( void )
{
	return m_pGraph;
}


/////////////////////////////////////////////////////////////////////////////
// CTool IUnknown implementation

HRESULT CTool::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IUnknown) 
    ||  ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }

	else if( ::IsEqualIID(riid, IID_IDMUSProdUpdateObjectNow) )
	{
		*ppvObj = (IDMUSProdUpdateObjectNow *)this;
	}

	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CTool::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CTool::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTool IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTool IDMUSProdPropPageObject::GetData

HRESULT CTool::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTool IDMUSProdPropPageObject::SetData

HRESULT CTool::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTool IDMUSProdPropPageObject::OnShowProperties

HRESULT CTool::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pGraphComponent != NULL );
	ASSERT( theApp.m_pGraphComponent->m_pIFramework != NULL );

	// Get the Tool page manager
	CToolPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_ToolPropPageManager ) == S_OK )
	{
		pPageManager = (CToolPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CToolPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Tool properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pGraphComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;

			if( m_pGraph->IsMultipleSelectTools() )
			{
				m_dwBitsUI |= UD_MULTIPLESELECT;
			}
			if( pPageManager->IsEqualObject( this ) == S_OK )
			{
				pIPropSheet->RefreshTitleByObject( this );
				pIPropSheet->RefreshActivePageByObject( this );
			}
			else
			{
				pPageManager->SetObject( this );
			}
			m_dwBitsUI &= ~UD_MULTIPLESELECT;
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTool IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CTool::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTool IDMUSProdUpdateObjectNow implementation

/////////////////////////////////////////////////////////////////////////////
// CTool IDMUSProdUpdateObjectNow::UpdateObjectNow

HRESULT CTool::UpdateObjectNow( LPUNKNOWN punkObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate the object pointer
	if( punkObject == NULL )
	{
		return E_POINTER;
	}

	// Store the original stream of DirectMusic tool data
	IStream* pIOrigStream = m_pIStream;
	if( pIOrigStream )
	{
		pIOrigStream->AddRef();
	}

	// Get the "updated" stream
	RefreshStreamOfData();

	// Was anything changed?
	if( IsStreamOfDataEqual( pIOrigStream ) == false )
	{
		// Sync changes with DMusic DLLs
		m_pGraph->SyncGraphWithDirectMusic();
	}

	RELEASE( pIOrigStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::SaveHeader
    
HRESULT CTool::SaveHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_TOOL_HEADER dmusToolIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Build the PChannel array
	CDWordArray aPChannels;
	POSITION pos = m_lstPChannelGroups.GetHeadPosition();
	while( pos )
	{
		CPChannelGroup* pPChannelGroup = m_lstPChannelGroups.GetNext( pos );

		for( DWORD i = 0 ;  i < pPChannelGroup->m_dwNbrPChannels ; i++ )
		{
			aPChannels.Add( pPChannelGroup->m_pdwPChannel[i] );
		}
	}

	// Sort the PChannel array
	qsort( aPChannels.GetData(), aPChannels.GetSize(), sizeof(DWORD), CompareDWORD );

	// Write Tool chunk header
	ck.ckid = DMUS_FOURCC_TOOL_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_TOOL_HEADER structure
	memset( &dmusToolIO, 0, sizeof(DMUS_IO_TOOL_HEADER) );

	dmusToolIO.guidClassID = m_clsidTool;
	dmusToolIO.lIndex = m_pGraph->ToolToIndex( this );
	ASSERT( dmusToolIO.lIndex !=  -1 );
	dmusToolIO.cPChannels = aPChannels.GetSize();
	dmusToolIO.ckid = 0;		// Will be filled in later
	dmusToolIO.fccType = 0;		// Will be filled in later
	if( dmusToolIO.cPChannels > 0 )
	{
		dmusToolIO.dwPChannels[0] = aPChannels[0];
	}
	else
	{
		// This Tool has no PChannels
		// Since count of zero means ALL PChannels
		//	we must force use of a bogus PChannel
		//	so that tool has no effect
		dmusToolIO.cPChannels = 1;
		dmusToolIO.dwPChannels[0] = TOOL_NO_PCHANNELS;
	}

	// Write Graph chunk data
	hr = pIStream->Write( &dmusToolIO, sizeof(DMUS_IO_TOOL_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_TOOL_HEADER) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	// Write rest of PChannel array
	if( dmusToolIO.cPChannels > 1 )
	{
		// First element written as part of DMUS_IO_TOOL_HEADER struct
		aPChannels.RemoveAt( 0, 1 );

		hr = pIStream->Write( aPChannels.GetData(), (aPChannels.GetSize() * sizeof(DWORD)), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != (aPChannels.GetSize() * sizeof(DWORD)) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTool SaveUIState
    
HRESULT CTool::SaveUIState( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ckList;
    MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Don't need to save unless this is a design stream
	if( ftFileType != FT_DESIGN )
	{
		hr = S_OK;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_TOOL_UI_LIST header
	ckMain.fccType = DMUS_FOURCC_TOOL_UI_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save DMUS_FOURCC_TOOL_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_TOOL_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write ToolUI data
		hr = pIStream->Write( &m_ToolUI, sizeof(ToolUI), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ToolUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save DMUS_FOURCC_UNFO_LIST list
	{
		ckList.fccType = DMUS_FOURCC_UNFO_LIST;
		if( pIRiffStream->CreateChunk(&ckList, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write Tool name
		{
			ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = SaveMBStoWCS( pIStream, &m_strName );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
		
		if( pIRiffStream->Ascend( &ckList, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::SaveTool

HRESULT CTool::SaveTool( IDMUSProdRIFFStream* pIRiffStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pGraph != NULL );

	DWORD dwHeaderFilePos;
	IPersistStream* pIPersistStream = NULL;
	FOURCC ckid_Tool = 0;
	FOURCC fccType_Tool = 0;

	if( pIRiffStream == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	if( ::IsEqualGUID( guidDataFormat, GUID_SaveSelectedTools ) 
	&&  m_fSelected == FALSE )
	{
		// Nothing to do
		hr = S_OK;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_TOOL_FORM header
	MMCKINFO ck;
	ck.fccType = DMUS_FOURCC_TOOL_FORM;
	if( pIRiffStream->CreateChunk( &ck, MMIO_CREATERIFF ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save Tool header chunk
    dwHeaderFilePos = StreamTell( pIStream );
	hr = SaveHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save Tool UI
	hr = SaveUIState( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save Tool data
	ASSERT( m_pIDMTool != NULL );
	ASSERT( m_pIStream != NULL );
	if( m_pIDMTool 
	&&  m_pIStream )
	{
		DWORD dwByteCount;

		// Get m_pIStream's size
		STATSTG statstg;
		ULARGE_INTEGER uliSizeOut, uliSizeRead, uliSizeWritten;
		hr = m_pIStream->Stat( &statstg, STATFLAG_NONAME );
		if( FAILED( hr ) )
		{
			return E_FAIL;
		}
		uliSizeOut = statstg.cbSize;

		// Save data
		StreamSeek( m_pIStream, 0, STREAM_SEEK_SET );
		hr = m_pIStream->CopyTo( pIStream, uliSizeOut, &uliSizeRead, &uliSizeWritten );
		if( FAILED( hr )
		||  uliSizeRead.QuadPart != uliSizeOut.QuadPart
		||  uliSizeWritten.QuadPart != uliSizeOut.QuadPart )
		{
			goto ON_ERROR;
		}
//		hr = m_pIDMTool->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
//		if( FAILED ( hr ) )
//		{
//			goto ON_ERROR;
//		}
//		hr = pIPersistStream->Save( pIStream, FALSE );
//		if( FAILED ( hr ) )
//		{
//			goto ON_ERROR;
//		}

		// Get RIFF chunk ids
		StreamSeek( m_pIStream, 0, STREAM_SEEK_SET );
		hr = m_pIStream->Read( &ckid_Tool, sizeof(FOURCC), &dwByteCount );
		if( FAILED( hr )
		||  dwByteCount != sizeof(FOURCC) )
		{
			goto ON_ERROR;
		}
		if( ckid_Tool == FOURCC_RIFF
		||  ckid_Tool == FOURCC_LIST )
		{
			hr = m_pIStream->Read( &fccType_Tool, sizeof(FOURCC), &dwByteCount );
			if( FAILED( hr )
			||  dwByteCount != sizeof(FOURCC) )
			{
				goto ON_ERROR;
			}
		}
		else
		{
			fccType_Tool = 0;
		}
	}

	// Place RIFF chunk ids in Tool header
	if( ckid_Tool != 0
	||  fccType_Tool != 0 )
	{
		DWORD dwBytesWritten;

		DWORD dwCurFilePos = StreamTell( pIStream );
		StreamSeek( pIStream, dwHeaderFilePos + 32, STREAM_SEEK_SET );

		hr = pIStream->Write( &ckid_Tool, sizeof(FOURCC), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(FOURCC) )
		{
			goto ON_ERROR;
		}
		hr = pIStream->Write( &fccType_Tool, sizeof(FOURCC), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(FOURCC) )
		{
			goto ON_ERROR;
		}

		StreamSeek( pIStream, dwCurFilePos, STREAM_SEEK_SET );
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    RELEASE( pIPersistStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::LoadUIState

HRESULT CTool::LoadUIState( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*      pIStream;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
	DWORD		  dwPos;
    HRESULT       hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_TOOL_UI_CHUNK:
				dwSize = min( ck.cksize, sizeof(ToolUI) );
				hr = pIStream->Read( &m_ToolUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST: 
					{
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;
							}
							pIRiffStream->Ascend( &ckList, 0 );
						}
					}
				}
				break;
		}

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::LoadTool

HRESULT CTool::LoadTool( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IStream*	pIStream;
	MMCKINFO	ck;
	DWORD		dwByteCount;
	DWORD		dwSize;
	DWORD		dwCurrentFilePos;
    HRESULT     hr = S_OK;

	FOURCC		ckid_Tool = 0;
	FOURCC		fccType_Tool = 0;

	ASSERT( theApp.m_pGraphComponent != NULL );

	if( pIRiffStream == NULL 
	||  pckMain == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwCurrentFilePos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_TOOL_CHUNK:
			{
			    DMUS_IO_TOOL_HEADER dmusToolIO;

				dwSize = sizeof( DMUS_IO_TOOL_HEADER );
				hr = pIStream->Read( &dmusToolIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( dmusToolIO.cPChannels == 1
				&&  dmusToolIO.dwPChannels[0] == TOOL_NO_PCHANNELS )
				{
					// This Tool has no PChannels
					// Since count of zero means ALL PChannels
					//	we had to save a bogus PChannel
					//	so that tool has no effect
					dmusToolIO.cPChannels = 0;
					dmusToolIO.dwPChannels[0] = 0;
				}

				m_clsidTool = dmusToolIO.guidClassID;
				ckid_Tool = dmusToolIO.ckid;
				fccType_Tool = dmusToolIO.fccType;

				if( dmusToolIO.cPChannels )
				{
					CPChannelGroup* pPChannelGroup = new CPChannelGroup();
					if( pPChannelGroup == NULL )
					{
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}

					pPChannelGroup->m_dwNbrPChannels = dmusToolIO.cPChannels;
					pPChannelGroup->m_pdwPChannel = new DWORD[pPChannelGroup->m_dwNbrPChannels];
					if( pPChannelGroup->m_pdwPChannel )
					{
						pPChannelGroup->m_pdwPChannel[0] = dmusToolIO.dwPChannels[0];
						// subtract 1 from m_dwNbrPChannels, because 1 element is actually stored
						// in the dmusToolIO array.
						dwSize = (pPChannelGroup->m_dwNbrPChannels - 1) * sizeof(DWORD);
						if( dwSize )
						{
							hr = pIStream->Read( &pPChannelGroup->m_pdwPChannel[1], dwSize, &dwByteCount );
							if( FAILED( hr )
							||  dwByteCount != dwSize )
							{
								delete pPChannelGroup;
								hr = E_FAIL;
								goto ON_ERROR;
							}
						}
					}
					else
					{
						delete pPChannelGroup;
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}
					m_lstPChannelGroups.AddTail( pPChannelGroup );
				}
				break;
			}
        
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_TOOL_UI_LIST:
						hr = LoadUIState( pIRiffStream, &ck );
						if( FAILED ( hr ) )
						{
							goto ON_ERROR;
						}
						break;
				}
				break;

			default:
				if( ck.ckid == ckid_Tool
				&&  ck.fccType == fccType_Tool )
				{
					// CoCreate the DirectMusic tool
					if( SUCCEEDED ( ::CoCreateInstance( m_clsidTool, NULL, CLSCTX_INPROC_SERVER,
														IID_IDirectMusicTool, (void**)&m_pIDMTool ) ) )
					{
						// Load the DirectMusic tool
						IPersistStream* pIPersistStream;
						hr = m_pIDMTool->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
						if( FAILED ( hr ) )
						{
							goto ON_ERROR;
						}
						StreamSeek( pIStream, dwCurrentFilePos, STREAM_SEEK_SET );
						hr = pIPersistStream->Load( pIStream );
						if( FAILED ( hr ) )
						{
							goto ON_ERROR;
						}
						RELEASE( pIPersistStream );

						// Store a copy of the DirectMusic tool's data
						RefreshStreamOfData();
					}
					else
					{
						m_pIDMTool = NULL;
					}
				}
				break;

		}

        pIRiffStream->Ascend( &ck, 0 );
	    dwCurrentFilePos = StreamTell( pIStream );
    }

	// Bypass this tool if we can't CoCreate a DirectMusic object
	if( m_pIDMTool == NULL )
	{
		// PChannelGroups are not yet in Graph (must be deleted here)
		CPChannelGroup* pPChannelGroup;
		while( !m_lstPChannelGroups.IsEmpty() )
		{
			pPChannelGroup = m_lstPChannelGroups.RemoveHead();
			delete pPChannelGroup;
		}

		hr = S_FALSE;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTool::RefreshStreamOfData

HRESULT CTool::RefreshStreamOfData( void )
{
	HRESULT hr = S_OK;

	RELEASE( m_pIStream );

	ASSERT( m_pIDMTool != NULL );
	if( m_pIDMTool )
	{
		hr = theApp.m_pGraphComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_CurrentVersion, &m_pIStream );
		if( SUCCEEDED ( hr ) )
		{
			IPersistStream* pIPersistStream;
			hr = m_pIDMTool->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
			if( SUCCEEDED ( hr ) )
			{
				hr = pIPersistStream->Save( m_pIStream, FALSE );

				RELEASE( pIPersistStream );
			}
		}
	}

	return hr;
}


#define BUFFER_SIZE 256

/////////////////////////////////////////////////////////////////////////////
// CTool::IsStreamOfDataEqual

bool CTool::IsStreamOfDataEqual( IStream* pIStream )
{
	// Check if stream pointers are equal (including both NULL)
	if( m_pIStream == pIStream )
	{
		return true;
	}

	// Check if either stream pointer is NULL
	if( m_pIStream == NULL
	||	pIStream == NULL )
	{
		return false;
	}

	// Get the length of each stream
	STATSTG statStg1, statStg2;
	if( FAILED( m_pIStream->Stat( &statStg1, STATFLAG_NONAME ) )
	||	FAILED( pIStream->Stat( &statStg2, STATFLAG_NONAME ) )
	||	(statStg1.cbSize.QuadPart != statStg2.cbSize.QuadPart) )
	{
		// If either call to Stat failed, or the length are different, return false
		return false;
	}

	// Seek back to the start of each stream
	if( FAILED( StreamSeek( m_pIStream, 0, STREAM_SEEK_SET ) )
	||	FAILED( StreamSeek( pIStream, 0, STREAM_SEEK_SET ) ) )
	{
		// If either seek failed, return false
		return false;
	}

	// Try and allocate buffers to read data into
	BYTE *pbData1 = new BYTE[BUFFER_SIZE];
	if( pbData1 == NULL )
	{
		return false;
	}
	BYTE *pbData2 = new BYTE[BUFFER_SIZE];
	if( pbData2 == NULL )
	{
		delete []pbData1;
		return false;
	}

	// Initialize the amount of data to compare
	long lStreamSize = min( statStg1.cbSize.LowPart, LONG_MAX );

	while( lStreamSize > 0 )
	{
		// Try and read in a chunk of data
		ULONG cbRead1, cbRead2;
		const ULONG lReadSize = min( lStreamSize, BUFFER_SIZE );
		if( FAILED( m_pIStream->Read( pbData1, lReadSize, &cbRead1 ) )
		||	FAILED( pIStream->Read( pbData2, lReadSize, &cbRead2 ) )
		||	(lReadSize != cbRead1)
		||	(lReadSize != cbRead2) )
		{
			// If either read failed, or we didn't read in
			// the correct amount of data, return false
			break;
		}

		// Check if the data we read is identical
		if( memcmp( pbData1, pbData2, lReadSize ) != 0 )
		{
			// Nope
			break;
		}

		lStreamSize -= lReadSize;
	}

	delete []pbData1;
	delete []pbData2;

	// If we read all the data, return true.  Otherwise, return false
	return lStreamSize <= 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\TabTool.cpp ===
// TabTool.cpp : implementation file
//

#include "stdafx.h"
#include "ToolGraphDesignerDLL.h"
#include "Tool.h"
#include "GraphCtl.h"
#include "TabTool.h"
#include "OlePropSheet.h"
#include "OlePropPage.h"
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabTool property page

CTabTool::CTabTool( CToolPropPageManager* pToolPropPageManager ) : CPropertyPage(CTabTool::IDD)
{
	//{{AFX_DATA_INIT(CTabTool)
	//}}AFX_DATA_INIT
	
	ASSERT( pToolPropPageManager != NULL );

	m_pTool = NULL;
	m_pPageManager = pToolPropPageManager;
	m_fNeedToDetach = FALSE;
	m_dwBitsUI = 0;
}

CTabTool::~CTabTool()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::SetTool

void CTabTool::SetTool( CTool* pTool )
{
	m_pTool = pTool;
	m_dwBitsUI = 0;

	if( m_pTool
	&&  m_pTool->m_dwBitsUI & UD_MULTIPLESELECT )
	{
		m_pTool = NULL;
		m_dwBitsUI |= UD_MULTIPLESELECT;
	}

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::GetBitsUI

DWORD CTabTool::GetBitsUI( void )
{
	return m_dwBitsUI;
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::SetModifiedFlag

void CTabTool::SetModifiedFlag( void ) 
{
	ASSERT( m_pTool != NULL );

	m_pTool->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::EnableControls

void CTabTool::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
	m_btnToolProperties.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::UpdateControls

void CTabTool::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );

	if( m_pTool )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pTool->m_strName );
	}
	else
	{
		if( m_dwBitsUI & UD_MULTIPLESELECT )
		{
			CString strMultiple;
			strMultiple.LoadString( IDS_MULTIPLE_TOOLS_SELECTED );
			m_editName.SetWindowText( strMultiple );
		}
		else
		{
			m_editName.SetWindowText( _T("") );
		}

		EnableControls( FALSE );
	}
}


void CTabTool::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabTool)
	DDX_Control(pDX, IDC_BUTTON_TOOL_PROPERTIES, m_btnToolProperties);
	DDX_Control(pDX, IDC_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabTool, CPropertyPage)
	//{{AFX_MSG_MAP(CTabTool)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	ON_BN_CLICKED(IDC_BUTTON_TOOL_PROPERTIES, OnToolProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabTool message handlers


/////////////////////////////////////////////////////////////////////////////
// CTabTool::OnInitDialog

BOOL CTabTool::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::OnSetActive

BOOL CTabTool::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::OnCreate

int CTabTool::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::OnDestroy

void CTabTool::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabTool::OnKillFocusName

void CTabTool::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pTool == NULL
	||  m_pTool->m_pGraph == NULL )
	{
		ASSERT( 0 );
		return;

	}

	CString strName;
	m_editName.GetWindowText( strName );

	// Strip leading and trailing spaces
	strName.TrimRight();
	strName.TrimLeft();

	if( strName.IsEmpty() )
	{
		m_editName.SetWindowText( m_pTool->m_strName );
	}
	else
	{
		if( strName.Compare( m_pTool->m_strName ) != 0 )
		{
			// Save undo state
			m_pTool->m_pGraph->m_pUndoMgr->SaveState( m_pTool->m_pGraph, theApp.m_hInstance, IDS_UNDO_CHANGE_TOOL_NAME );
			
			// Update tool's name
			m_pTool->m_strName = strName;
			m_pTool->m_pGraph->SetModified( TRUE );

			//Refresh UI
			m_pTool->m_pGraph->Refresh();
		}
	}
}


#define PROPPAGE_WIDTH	250
#define PROPPAGE_HEIGHT	150

/////////////////////////////////////////////////////////////////////////////
// CTabTool::OnToolProperties

void CTabTool::OnToolProperties() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pTool == NULL
	||  m_pTool->m_pIDMTool == NULL 
	||  m_pTool->m_pGraph == NULL 
	||  m_pTool->m_pGraph->m_pGraphCtrl == NULL )
	{
		ASSERT( 0 );
		return;

	}

	// Store the original stream of DirectMusic tool data
	IStream* pIOrigStream = m_pTool->m_pIStream;
	if( pIOrigStream )
	{
		pIOrigStream->AddRef();
	}

	// Determine title
	CString strTitle;
	strTitle= m_pTool->m_pGraph->m_strName + _T(" - ") + m_pTool->m_strName;

	IDMUSProdUpdateObjectNow *pIDMUSProdUpdateObjectNow = NULL;
	m_pTool->QueryInterface( IID_IDMUSProdUpdateObjectNow, (void**)&pIDMUSProdUpdateObjectNow );

	// Display the property sheet
	COlePropSheet* pPropSheet = new COlePropSheet( m_pTool->m_pIDMTool, strTitle, pIDMUSProdUpdateObjectNow );
	if( pPropSheet )
	{
		int nResult = pPropSheet->DoModal();

		// Get the "updated" stream
		m_pTool->RefreshStreamOfData();
		IStream* pINewStream = m_pTool->m_pIStream;
		if( pINewStream )
		{
			pINewStream->AddRef();
		}

		// Was anything changed?
		if( m_pTool->IsStreamOfDataEqual( pIOrigStream ) == false )
		{
			// Handle "OK"
			if( nResult == IDOK )
			{
				// Save undo state
				m_pTool->m_pIStream = pIOrigStream;
				m_pTool->m_pGraph->m_pUndoMgr->SaveState( m_pTool->m_pGraph, theApp.m_hInstance, IDS_UNDO_CHANGE_TOOL_PROPERTIES );
			
				m_pTool->m_pIStream = pINewStream;
				m_pTool->m_pGraph->SetModified( TRUE );
			}

			// Handle "Cancel"
			else
			{
				// Restore original data
				IPersistStream* pIPersistStream;
				if( SUCCEEDED ( m_pTool->m_pIDMTool->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
				{
					StreamSeek( pIOrigStream, 0, STREAM_SEEK_SET );
					pIPersistStream->Load( pIOrigStream );

					RELEASE( pIPersistStream );
				}

				// Get the "original" stream
				m_pTool->RefreshStreamOfData();
			}

			// Sync changes with DMusic DLLs
			m_pTool->m_pGraph->SyncGraphWithDirectMusic();
		}
			
		RELEASE( pINewStream );
	}

	RELEASE( pIOrigStream );
	RELEASE( pIDMUSProdUpdateObjectNow );

	m_btnToolProperties.SetFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\ToolGraphDesignerDLL.h ===
#if !defined(AFX_TOOLGRAPHDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_TOOLGRAPHDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ToolGraphDesignerDLL.h : main header file for TOOLGRAPHDESIGNER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusicc.h>
#include <dmusici.h>
#pragma warning( pop )
#include "DMUSProd.h"
#include "ToolGraphDesigner.h"
#include "Conductor.h"		// Conductor interface and CLSID
#include "DllJazzDataObject.h"
#include "DllBasePropPageManager.h"
#include "JazzUndoMan.h"


/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define CF_GRAPH "DMUSProd v.1 Graph"
#define CF_GRAPHLIST "DMUSProd v.1 Graph List"

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256

#define FIRST_GRAPH_IMAGE		0
#define FIRST_GRAPHREF_IMAGE	2


// {0A1A99C6-CC76-4613-A1DF-B167518B1414}
DEFINE_GUID( GUID_SaveSelectedTools, 0xa1a99c6, 0xcc76, 0x4613, 0xa1, 0xdf, 0xb1, 0x67, 0x51, 0x8b, 0x14, 0x14);

class CGraphComponent;


/////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp : See ToolGraphDesignerDLL.cpp for implementation.

class CGraphDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
	BOOL PutDataInClipboard( IDataObject* pIDataObject, void* pClipboardObject );
	void FlushClipboard( void* pClipboardObject );
	BOOL IsInClipboard( void* pClipboardObject );

private:
	IDataObject*	m_pIClipboardDataObject;	// Data copied into clipboard
	void*			m_pClipboardObject;			// Object responsible for data copied into clipboard

public:
	IDMUSProdPropPageManager*	m_pIPageManager;
	CGraphComponent*			m_pGraphComponent;
};

extern CGraphDesignerApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TOOLGRAPHDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\Tool.h ===
#ifndef __TOOL_H__
#define __TOOL_H__

// Tool.h : header file
//

#include "Graph.h"
#include "OlePropPage.h"
#include <RiffStrm.h>
#include <dmusici.h>


#define DEFAULT_TOOL_COLUMN_WIDTH		65


#pragma pack(2)

typedef struct ToolUI
{
	ToolUI()
	{
		nColumnWidth = DEFAULT_TOOL_COLUMN_WIDTH;
	}

	int			nColumnWidth;
} ToolUI;

#pragma pack()


//////////////////////////////////////////////////////////////////////
//  CToolPropPageManager

class CToolPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabTool;

public:
	CToolPropPageManager();
	virtual ~CToolPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabTool*					m_pTabTool;
};


//////////////////////////////////////////////////////////////////////
//  CTool

class CTool : public IDMUSProdPropPageObject, public IDMUSProdUpdateObjectNow
{
friend class CDirectMusicGraph;
friend class CGraphDlg;
friend class CTabTool;

public:
    CTool();
    CTool( CLSID clsidTool, IDirectMusicTool* pIDMTool );
	~CTool();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdUpdateObjectNow functions
    HRESULT STDMETHODCALLTYPE UpdateObjectNow( LPUNKNOWN punkObject );

//Additional functions
private:
    HRESULT SaveHeader( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveUIState( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT LoadUIState( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );

public:
	HRESULT SaveTool( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT LoadTool( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	void SetModified( BOOL fModified );

	void InsertPChannelGroup( CPChannelGroup* pPChannelGroupToInsert );
	void RemovePChannelGroup( CPChannelGroup* pPChannelGroupToRemove );
	void RemoveAllPChannelGroups();
	void CombineAllPChannelGroups();
	void RepositionPChannelGroup( CPChannelGroup* pPChannelGroupToReposition );
	bool ContainsPChannelGroup( CPChannelGroup* pPChannelGroup );

	int GetColumnWidth();
	void SetColumnWidth( int nWidth );
	void GetName( CString& strName );
	void GetCLSID( CLSID* pclsidTool );
	DWORD GetBitsUI();
	CDirectMusicGraph* GetGraph();

	HRESULT RefreshStreamOfData();
	bool IsStreamOfDataEqual( IStream* pIStream );

public:
	// UI
	BOOL				m_fSelected;

	// Persisted for UI
	ToolUI				m_ToolUI;
	CString				m_strName;

private:
    DWORD				m_dwRef;
	CDirectMusicGraph*	m_pGraph;

	// UI
	DWORD				m_dwBitsUI;

	// Persisted for DirectMusic
	CLSID				m_clsidTool;
	IDirectMusicTool*	m_pIDMTool;
	IStream*			m_pIStream;		// Tool's internal data 
	CTypedPtrList<CPtrList, CPChannelGroup*> m_lstPChannelGroups;
};

#endif // __TOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\ToolGraphEditorGuids.c ===
// GraphEditorGuids.c : Contains GUIDs not found in MIDL generated GraphDesigner_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */

const GUID CLSID_ToolGraphComponent = {0xeab971ee,0x6601,0x4f70,{0x94,0x34,0x32,0xce,0x56,0x8a,0xe3,0xf3}};

const GUID GUID_ToolGraphNode = {0x5a5a8e5,0xde1b,0x4bad,{0xb2,0x40,0xf5,0xa9,0xf2,0x11,0x7,0x86}};
const GUID GUID_ToolGraphRefNode = {0x5f28e0c4,0xde1c,0x492a,{0x93,0x2,0x75,0x38,0xba,0xc2,0xfb,0xc2}};

const GUID TOOLGRAPH_NameChange = {0xf1007af8,0xb98f,0x4a4a,{0x88,0xcf,0x7b,0x38,0x8f,0xdc,0x66,0xcf}};
const GUID TOOLGRAPH_ChangeNotification = {0x6681d08e,0xfde0,0x4006,{0xb6,0xbd,0x9c,0x1f,0x5f,0x16,0x1f,0xb3}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ToolGraphDesigner\ToolGraphDesignerDLL.cpp ===
// ToolGraphDesignerDLL.cpp : Implementation of CGraphDesignerApp and DLL registration.

#include "stdafx.h"
#include <initguid.h>
#include "ToolGraphDesignerDLL.h"
#include "GraphComponent.h"
#include <SegmentDesigner.h>
#include <AudioPathDesigner.h>
#include <PChannelName.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CGraphDesignerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid = 
		{ 0xb39b2935, 0x8e62, 0x4ceb, { 0xae, 0xf6, 0x29, 0x42, 0x86, 0xa0, 0x85, 0x18 } };

const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp::InitInstance - DLL initialization

BOOL CGraphDesignerApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();
	}

	m_pIPageManager = NULL;
	m_pGraphComponent = NULL;

	m_pClipboardObject = NULL;
	m_pIClipboardDataObject = NULL;

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp::ExitInstance - DLL termination

int CGraphDesignerApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp::GetHelpFileName

BOOL CGraphDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp::SetNodePointers  (used by all components)

void CGraphDesignerApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		RELEASE( pIChild );
	}
}


////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp::PutDataInClipboard

BOOL CGraphDesignerApp::PutDataInClipboard( IDataObject* pIDataObject, void* pObject )
{
	if( pIDataObject )
	{
		if( ::OleSetClipboard( pIDataObject ) == S_OK )
		{
			RELEASE( m_pIClipboardDataObject );

			m_pIClipboardDataObject = pIDataObject;
			m_pIClipboardDataObject->AddRef();

			m_pClipboardObject = pObject;

			return TRUE;
		}
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp::FlushClipboard

void CGraphDesignerApp::FlushClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		ASSERT( m_pIClipboardDataObject != NULL );

		if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
		{
			::OleFlushClipboard();
		}

		RELEASE( m_pIClipboardDataObject );

		m_pClipboardObject = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp::IsInClipboard

BOOL CGraphDesignerApp::IsInClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CGraphDesignerApp::GetFileVersion  (used by all components)

BOOL CGraphDesignerApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds registry entries for DMUS Producer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szInProcServer32[SMALL_BUFFER];
	TCHAR	 szThreadingModel[SMALL_BUFFER];
	TCHAR	 szApartment[SMALL_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
    TCHAR    szComponentPath[MAX_BUFFER];
	TCHAR	 szSkip[SMALL_BUFFER];
	DWORD    dwSkip = 0;
    TCHAR    szContainerPath[MAX_BUFFER];
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );

	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	
// Register Graph Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_GraphEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_GRAPH_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_ToolGraphComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_GRAPH_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_ToolGraphNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_ToolGraphRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_ToolGraphComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicGraph, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_GRAPH_OBJECT_TEXT );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes registry entries for DMUS Producer components

static BOOL UnregisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
    TCHAR    szGuid[MID_BUFFER];
    TCHAR    szComponentPath[MAX_BUFFER];
    TCHAR    szContainerPath[MAX_BUFFER];
	TCHAR	 szRefNode[SMALL_BUFFER];
    
	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	_tcscpy( szRefNode, _T("RefNode") );
	
// Unregister Graph Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_GraphEditor, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_ToolGraphComponent, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_ToolGraphNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
			AfxOleLockApp(); 
        }
        else
        {
			AfxOleUnlockApp(); 
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CGraphComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_ToolGraphComponent) )
	{
        pfunc = CGraphComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else if( IsEqualCLSID(rclsid, CLSID_GraphEditor) )
	{
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Tutorial2\FarmGameApp\Source\RESOURCE.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Farm.rc
//
#define IDD_MAIN                        101
#define IDR_MAINFRAME                   102
#define IDR_MENU1                       106
#define IDB_BITMAP1                     107
#define IDC_ALLSTOP                     1020
#define IDC_BIRD                        1021
#define IDC_NIGHT                       1022
#define IDC_PREDAWN                     1023
#define IDC_DAWN                        1024
#define IDC_END                         1025
#define IDC_COUGAR                      1026
#define IDC_COW                         1027
#define IDC_ROOSTER                     1028
#define IDC_SHEEP                       1029
#define IDC_WOLF                        1030
#define IDC_ALARM                       1031
#define IDC_SECONDARY                   1033
#define IDC_BACKGROUNDS                 1034
#define IDC_SOUND_EFFECTS               1035

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1036
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Tutorial2\FarmGameApp\Source\FARM.CPP ===
//-----------------------------------------------------------------------------
// File: Farm.cpp
//
// Desc: Plays a script file using DirectMusic
//
//@@BEGIN_MSINTERNAL
//
// Hist: 02.24.00 - forrest - Created from PlaySegment
//
//@@END_MSINTERNAL
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT
#include <windows.h>
#include <basetsd.h>
#include <commdlg.h>
#include <objbase.h>
#include <stdio.h>
#include <dmusicc.h>
#include <dmusici.h>
#include <dxerr8.h>
#include "resource.h"
#include <tchar.h>
#include "DMUtil.h"
#include "DXUtil.h"




//-----------------------------------------------------------------------------
// Function-prototypes
//-----------------------------------------------------------------------------
INT_PTR CALLBACK MainDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
HRESULT OnInitDialog( HWND hDlg );
HRESULT OnChangeScriptFile( HWND hDlg, TCHAR* strFileName );
HRESULT OnCallRoutine( HWND hDlg, TCHAR* strRoutine );
HRESULT UpdateVariables( HWND hDlg );
HRESULT SetVariable( HWND hDlg, int nIDDlgItem );
void    DrawButton( int nDlgItem, HWND hDlgItem, LPDRAWITEMSTRUCT lpDrawItemStruct );
void    DrawStatic( int nDlgItem, HWND hDlgItem, LPDRAWITEMSTRUCT lpDrawItemStruct );
void    PlayButton( HWND hDlg, int nDlgItem );
HRESULT ProcessDirectMusicMessages( HWND hDlg );
BOOL    LoadBitmapFromResource( int nResourceID, HBITMAP *phBitmap, HPALETTE *phPalette );
HRESULT CreateAudioPathFromFile( IDirectMusicAudioPath** ppAudioPath, TCHAR* strFileName );

#define ORANGE_COLOR        RGB(255, 130, 0)
#define GREEN_COLOR         RGB(0, 195, 0)
#define YELLOW_COLOR        RGB(198, 195, 0)
#define LT_ORANGE_COLOR     RGB(255, 195, 132)
#define LT_GREEN_COLOR      RGB(132, 255, 132)
#define LT_YELLOW_COLOR     RGB(255, 255, 198)
#define RED_COLOR           RGB(255, 0, 0)
#define BACKGROUND_COLOR    RGB(198, 65, 0)
#define BLACK_COLOR         RGB(0, 0, 0)
#define WHITE_COLOR         RGB(255, 255, 255)




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define NUM_PLAY_BUTTONS (IDC_ALARM - IDC_BIRD + 1)

CMusicManager* g_pMusicManager      = NULL;
CMusicScript*  g_pMusicScript       = NULL;
IDirectMusicAudioPath* g_pFarmAudioPath = NULL;
HINSTANCE      g_hInst              = NULL;
HBRUSH         g_hOrangeBrush       = NULL;
HBRUSH         g_hGreenBrush        = NULL;
HBRUSH         g_hYellowBrush       = NULL;
HBRUSH         g_hLtOrangeBrush     = NULL;
HBRUSH         g_hLtGreenBrush      = NULL;
HBRUSH         g_hLtYellowBrush     = NULL;
HBRUSH         g_hBackgroundBrush   = NULL;
HBRUSH         g_hRedBrush          = NULL;
BOOL           g_bButtonPlaying[ NUM_PLAY_BUTTONS ];
HBITMAP        g_hBitmap            = NULL;
HPALETTE       g_hPalette           = NULL;





//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point for the application.  Since we use a simple dialog for 
//       user interaction we don't need to pump messages.
//-----------------------------------------------------------------------------
INT APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR pCmdLine, 
                      INT nCmdShow )
{
    HWND    hDlg = NULL;
    BOOL    bDone = FALSE;
    int     nExitCode;
    MSG     msg;

    g_hInst = hInst;
    ZeroMemory( g_bButtonPlaying, sizeof(BOOL)*NUM_PLAY_BUTTONS );

    // Display the main dialog box.
    hDlg = CreateDialog( hInst, MAKEINTRESOURCE(IDD_MAIN), 
                         NULL, MainDlgProc );

    while( !bDone ) 
    { 
        // Windows messages are available
        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) ) 
        { 
            if( !IsDialogMessage( hDlg, &msg ) )  
            {
                TranslateMessage( &msg ); 
                DispatchMessage( &msg ); 
            }

            if( msg.message == WM_QUIT )
            {
                nExitCode = (int)msg.wParam;
                bDone     = TRUE;
                DestroyWindow( hDlg );
            }
        }
    }

    return nExitCode;
}




//-----------------------------------------------------------------------------
// Name: MainDlgProc()
// Desc: Handles dialog messages
//-----------------------------------------------------------------------------
INT_PTR CALLBACK MainDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    HRESULT hr;

    switch( msg ) 
    {
        case WM_INITDIALOG:
            if( FAILED( hr = OnInitDialog( hDlg ) ) )
            {
                DXTRACE_ERR( TEXT("OnInitDialog"), hr );
                MessageBox( hDlg, "Error initializing DirectMusic.  Sample will now exit.", 
                                  "DirectMusic Sample", MB_OK | MB_ICONERROR );
                PostQuitMessage( IDCANCEL );
                return TRUE;
            }
            break;

        case WM_PAINT:
        {
            PAINTSTRUCT   ps;
            HBITMAP       hOldBitmap;
            HPALETTE      hOldPalette;
            HDC           hDC, hMemDC;
            BITMAP        bm;

            hDC = BeginPaint( hDlg, &ps );

            if( g_hBitmap )
            {
                GetObject( g_hBitmap, sizeof(BITMAP), &bm );
                hMemDC = CreateCompatibleDC( hDC );
                hOldBitmap = (HBITMAP)SelectObject( hMemDC, g_hBitmap );
                hOldPalette = SelectPalette( hDC, g_hPalette, FALSE );
                RealizePalette( hDC );

                BitBlt( hDC, 0, 0, bm.bmWidth, bm.bmHeight, hMemDC, 0, 0, SRCCOPY );

                SelectObject( hMemDC, hOldBitmap );
                SelectPalette( hDC, hOldPalette, FALSE );
            }

            EndPaint( hDlg, &ps );
            break;
        }

        case WM_DRAWITEM:
            switch( ((LPDRAWITEMSTRUCT) lParam)->CtlType )
            {
            case ODT_BUTTON:
                DrawButton( wParam, GetDlgItem(hDlg, wParam), (LPDRAWITEMSTRUCT) lParam );
                break;

            case ODT_STATIC:
                DrawStatic( wParam, GetDlgItem(hDlg, wParam), (LPDRAWITEMSTRUCT) lParam );
                break;

            default:
                return FALSE;
            }

            return TRUE;
            break;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_ALLSTOP:
                case IDC_BIRD:
                case IDC_NIGHT:
                case IDC_PREDAWN:
                case IDC_DAWN:
                case IDC_END:
                case IDC_COUGAR:
                case IDC_COW:
                case IDC_ROOSTER:
                case IDC_SHEEP:
                case IDC_WOLF:
                case IDC_ALARM:
                {
                    PlayButton( hDlg, LOWORD(wParam) );
                    break;
                }

                case IDCANCEL:
                {
                    PostQuitMessage( IDCANCEL );
                    break;
                }

                default:
                {
                    return FALSE; // Didn't handle message
                }
            }
            break;

        case WM_DESTROY:
            // Cleanup everything
            SAFE_RELEASE( g_pFarmAudioPath );
            SAFE_DELETE( g_pMusicScript );
            SAFE_DELETE( g_pMusicManager );

            DeleteObject( g_hOrangeBrush );
            DeleteObject( g_hGreenBrush );
            DeleteObject( g_hYellowBrush );
            DeleteObject( g_hLtOrangeBrush );
            DeleteObject( g_hLtGreenBrush );
            DeleteObject( g_hLtYellowBrush );
            DeleteObject( g_hRedBrush );
            DeleteObject( g_hBackgroundBrush );
            DeleteObject( g_hBitmap );
            DeleteObject( g_hPalette );

            break; 

        default:
            return FALSE; // Didn't handle message
    }

    return TRUE; // Handled message
}




//-----------------------------------------------------------------------------
// Name: OnInitDialog()
// Desc: Initializes the dialogs (sets up UI controls, etc.)
//-----------------------------------------------------------------------------
HRESULT OnInitDialog( HWND hDlg )
{
    HRESULT hr;

    // Load the icon
    HICON hIcon = LoadIcon( g_hInst, MAKEINTRESOURCE( IDR_MAINFRAME ) );

    // Set the icon for this dialog.
    SendMessage( hDlg, WM_SETICON, ICON_BIG,   (LPARAM) hIcon );  // Set big icon
    SendMessage( hDlg, WM_SETICON, ICON_SMALL, (LPARAM) hIcon );  // Set small icon

    g_hOrangeBrush    = CreateSolidBrush(ORANGE_COLOR);
    g_hGreenBrush     = CreateSolidBrush(GREEN_COLOR);
    g_hYellowBrush    = CreateSolidBrush(YELLOW_COLOR);
    g_hLtOrangeBrush  = CreateSolidBrush(LT_ORANGE_COLOR);
    g_hLtGreenBrush   = CreateSolidBrush(LT_GREEN_COLOR);
    g_hLtYellowBrush  = CreateSolidBrush(LT_YELLOW_COLOR);
    g_hRedBrush       = CreateSolidBrush(RED_COLOR);
    g_hBackgroundBrush= CreateSolidBrush(BACKGROUND_COLOR);

    g_pMusicManager = new CMusicManager();

    if( FAILED( hr = g_pMusicManager->Initialize( hDlg ) ) )
        return hr;

    // Free any previous script, and make a new one
    SAFE_DELETE( g_pMusicScript );

    // Have the loader collect any garbage now that the old 
    // script has been released
    g_pMusicManager->CollectGarbage();

    // Set the default media path (something like C:\MSSDK\SAMPLES\MULTIMEDIA\MEDIA)
    // to be used as the search directory for finding DirectMusic content.
    TCHAR strPath[MAX_PATH];

    GetCurrentDirectory( MAX_PATH, strPath );
    lstrcat( strPath, TEXT("\\res") );
    g_pMusicManager->SetSearchDirectory( strPath );

    // Load the script file
    if( FAILED( hr = g_pMusicManager->CreateScriptFromFile( &g_pMusicScript, "farmmusic.spt" ) ) )
    {
        GetCurrentDirectory( MAX_PATH, strPath );
        lstrcat( strPath, TEXT("\\..\\res") );
        g_pMusicManager->SetSearchDirectory( strPath );

        if( FAILED( hr = g_pMusicManager->CreateScriptFromFile( &g_pMusicScript, "farmmusic.spt" ) ) )
            return DXTRACE_ERR( TEXT("CreateScriptFromFile"), hr );
    }

    LoadBitmapFromResource( IDB_BITMAP1, &g_hBitmap, &g_hPalette );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: OnCallRoutine()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT OnCallRoutine( HWND hDlg, TCHAR* strRoutine )
{
    HRESULT hr;

    if( FAILED( hr = g_pMusicScript->CallRoutine( strRoutine ) ) )
        return DXTRACE_ERR( TEXT("CallRoutine"), hr );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawButton()
// Desc: 
//-----------------------------------------------------------------------------
void DrawButton( int nDlgItem, HWND hDlgItem, LPDRAWITEMSTRUCT lpDrawItemStruct )  
{
    TCHAR strText[MAX_PATH];
    UINT uStyle = DFCS_BUTTONPUSH;
    COLORREF crBkColor;
    HBRUSH* phBrush = NULL;
    int nIndex = nDlgItem - IDC_BIRD;
    
    // If drawing selected, add the pushed style to DrawFrameControl.
    if (lpDrawItemStruct->itemState & ODS_SELECTED)
        uStyle |= DFCS_PUSHED;
    
    switch( nDlgItem )
    {
        case IDCANCEL:
        case IDC_ALLSTOP:
        {
            phBrush = &g_hRedBrush;
            crBkColor = RED_COLOR;
            break;
        }

        case IDC_BIRD:
        {
            if( g_bButtonPlaying[nIndex] )
            {
                phBrush = &g_hLtYellowBrush;
                crBkColor = LT_YELLOW_COLOR;
            }
            else
            {
                phBrush = &g_hYellowBrush;
                crBkColor = YELLOW_COLOR;
            }
            break;
        }

        case IDC_NIGHT:
        case IDC_PREDAWN:
        case IDC_DAWN:
        case IDC_END:
        {
            if( g_bButtonPlaying[nIndex] )
            {
                phBrush = &g_hLtGreenBrush;
                crBkColor = LT_GREEN_COLOR;
            }
            else
            {
                phBrush = &g_hGreenBrush;
                crBkColor = GREEN_COLOR;
            }
            break;
        }

        case IDC_COUGAR:
        case IDC_COW:
        case IDC_ROOSTER:
        case IDC_SHEEP:
        case IDC_WOLF:
        case IDC_ALARM:
        {
            if( g_bButtonPlaying[nIndex] )
            {
                phBrush = &g_hLtOrangeBrush;
                crBkColor = LT_ORANGE_COLOR;
            }
            else
            {
                phBrush = &g_hOrangeBrush;
                crBkColor = ORANGE_COLOR;
            }
            break;
        }
    }

    SetTextColor( lpDrawItemStruct->hDC, BLACK_COLOR );
    SetBkColor( lpDrawItemStruct->hDC, crBkColor );
    SelectObject( lpDrawItemStruct->hDC, *phBrush );

    // Draw the button frame.
    DrawFrameControl( lpDrawItemStruct->hDC, &lpDrawItemStruct->rcItem, 
        DFC_BUTTON, uStyle );

    // Fill center with new color
    RECT rc = lpDrawItemStruct->rcItem;
    rc.left     += 2;
    rc.top      += 2;
    rc.bottom   -= 2;
    rc.right    -= 2;
    FillRect( lpDrawItemStruct->hDC, &rc, *phBrush );

    // Draw text
    GetWindowText( hDlgItem, strText, MAX_PATH );
    DrawText( lpDrawItemStruct->hDC, strText, _tcslen(strText), 
              &lpDrawItemStruct->rcItem, DT_SINGLELINE|DT_VCENTER|DT_CENTER );
}




//-----------------------------------------------------------------------------
// Name: DrawStatic()
// Desc: 
//-----------------------------------------------------------------------------
void DrawStatic( int nDlgItem, HWND hDlgItem, LPDRAWITEMSTRUCT lpDrawItemStruct )  
{
    SetTextColor( lpDrawItemStruct->hDC, WHITE_COLOR );
    SetBkMode( lpDrawItemStruct->hDC, TRANSPARENT );

    // Draw text
    TCHAR strText[MAX_PATH];
    GetWindowText( hDlgItem, strText, MAX_PATH );
    DrawText( lpDrawItemStruct->hDC, strText, _tcslen(strText), 
              &lpDrawItemStruct->rcItem, DT_SINGLELINE|DT_VCENTER|DT_CENTER );

    SetBkMode( lpDrawItemStruct->hDC, OPAQUE );
}




//-----------------------------------------------------------------------------
// Name: PlayButton()
// Desc: 
//-----------------------------------------------------------------------------
void PlayButton( HWND hDlg, int nDlgItem )
{
    int nIndex = nDlgItem - IDC_BIRD;
    switch( nDlgItem )
    {       
        case IDC_ALLSTOP:
            g_pMusicScript->CallRoutine( TEXT("dmAllStop") );
            break;

        case IDC_BIRD:
            g_pMusicScript->CallRoutine( TEXT("dmSSBird") );
            break;

        case IDC_NIGHT:
            g_pMusicScript->CallRoutine( TEXT("dmBGNight") );
            break;

        case IDC_PREDAWN:
            g_pMusicScript->CallRoutine( TEXT("dmBGPredawn") );
            break;

        case IDC_DAWN:
            g_pMusicScript->CallRoutine( TEXT("dmBGDawn") );
            break;

        case IDC_END:
            g_pMusicScript->CallRoutine( TEXT("dmEnding") );
            break;

        case IDC_COUGAR:
            g_pMusicScript->CallRoutine( TEXT("dmSfxCougar") );
            break;

        case IDC_COW:
            g_pMusicScript->CallRoutine( TEXT("dmSfxCow") );
            break;

        case IDC_ROOSTER:
            g_pMusicScript->CallRoutine( TEXT("dmSfxRooster") );
            break;

        case IDC_SHEEP:
            g_pMusicScript->CallRoutine( TEXT("dmSfxSheep") );
            break;

        case IDC_WOLF:            
            g_pMusicScript->CallRoutine( TEXT("dmSfxWolf") );
            break;

        case IDC_ALARM:
            g_pMusicScript->CallRoutine( TEXT("dmSfxAlarm") );
            break;
    }

    InvalidateRect( GetDlgItem( hDlg, nDlgItem ), NULL, TRUE );
}




//-----------------------------------------------------------------------------
// Name: LoadBitmapFromResource()
// Desc: 
//-----------------------------------------------------------------------------
BOOL LoadBitmapFromResource( int nResourceID, HBITMAP *phBitmap, HPALETTE *phPalette )
{
    
    BITMAP  bm;
    
    *phBitmap = NULL;
    *phPalette = NULL;
    
    // Use LoadImage() to get the image loaded into a DIBSection
    *phBitmap = (HBITMAP)LoadImage( g_hInst, MAKEINTRESOURCE(nResourceID), IMAGE_BITMAP, 0, 0,
                                    LR_CREATEDIBSECTION | LR_DEFAULTSIZE );
    if( *phBitmap == NULL )
        return FALSE;
    
    // Get the color depth of the DIBSection
    GetObject(*phBitmap, sizeof(BITMAP), &bm );

    // If the DIBSection is 256 color or less, it has a color table
    if( ( bm.bmBitsPixel * bm.bmPlanes ) <= 8 )
    {
        HDC           hMemDC;
        HBITMAP       hOldBitmap;
        RGBQUAD       rgb[256];
        LPLOGPALETTE  pLogPal;
        WORD          i;
        
        // Create a memory DC and select the DIBSection into it
        hMemDC = CreateCompatibleDC( NULL );
        hOldBitmap = (HBITMAP)SelectObject( hMemDC, *phBitmap );
        // Get the DIBSection's color table
        GetDIBColorTable( hMemDC, 0, 256, rgb );
        // Create a palette from the color tabl
        pLogPal = (LOGPALETTE *)malloc( sizeof(LOGPALETTE) + (256*sizeof(PALETTEENTRY)) );
        pLogPal->palVersion = 0x300;
        pLogPal->palNumEntries = 256;
        for(i=0;i<256;i++)
        {
            pLogPal->palPalEntry[i].peRed = rgb[i].rgbRed;
            pLogPal->palPalEntry[i].peGreen = rgb[i].rgbGreen;
            pLogPal->palPalEntry[i].peBlue = rgb[i].rgbBlue;
            pLogPal->palPalEntry[i].peFlags = 0;
        }
        *phPalette = CreatePalette( pLogPal );
        // Clean up
        free( pLogPal );
        SelectObject( hMemDC, hOldBitmap );
        DeleteDC( hMemDC );
    }
    else   
    {
        // It has no color table, so use a halftone palette
        HDC    hRefDC;       
        hRefDC = GetDC( NULL );
        *phPalette = CreateHalftonePalette( hRefDC );
        ReleaseDC( NULL, hRefDC );
    }

    return TRUE;   
} 



//-----------------------------------------------------------------------------
// Name: CreateAudioPathFromFile()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CreateAudioPathFromFile( IDirectMusicAudioPath8** ppAudioPath, TCHAR* strFileName )
{
    HRESULT               hr;
    IDirectMusicSegment8* pSegment = NULL;
    IUnknown*             pUnknown = NULL;

    // DMusic only takes wide strings
    WCHAR wstrFileName[MAX_PATH];
    DXUtil_ConvertGenericStringToWide( wstrFileName, strFileName );

    IDirectMusicLoader8* pLoader = g_pMusicManager->GetLoader();

    if ( FAILED( hr = pLoader->LoadObjectFromFile( CLSID_DirectMusicAudioPathConfig,
                                                   IID_IUnknown,
                                                   wstrFileName,
                                                   (LPVOID*) &pUnknown ) ) )
    {
        if( hr == DMUS_E_LOADER_FAILEDOPEN )
            return hr;
        return DXTRACE_ERR( TEXT("LoadObjectFromFile"), hr );
    }

    IDirectMusicPerformance8* pPerformance = g_pMusicManager->GetPerformance();

    if( FAILED( hr = pPerformance->CreateAudioPath( pUnknown, TRUE, ppAudioPath ) ) )
        return DXTRACE_ERR( TEXT("CreateAudioPath"), hr );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Uninst\Uninst.cpp ===
#include <windows.h>
#include <process.h>
#include <tchar.h>
#include <ole2.h>

BOOL GetBaseDir(LPTSTR,LPTSTR);
void SplitName(LPCTSTR,LPTSTR,LPTSTR,TCHAR);

TCHAR szBaseDir[_MAX_PATH];
static char _szDllUnregSvr[] = "DllUnregisterServer";
#define MAX_STRING 1024

BOOL WINAPI DllMain(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpvReserved)
{
   	return (1);
}

extern "C"
{

void UnRegister( LPCTSTR szName )
{
	// Load the library.	
	HINSTANCE hLib = LoadLibrary(szName);
	if (hLib >= (HINSTANCE)HINSTANCE_ERROR)
	{
		HRESULT (FAR STDAPICALLTYPE * lpDllEntryPoint)(void);

		// Find the entry point.		
		(FARPROC&)lpDllEntryPoint = GetProcAddress(hLib, _szDllUnregSvr);
		if (lpDllEntryPoint != NULL)
		{
			if (SUCCEEDED((*lpDllEntryPoint)()))
			{
				// We've succeeded - display fireworks here
				//TCHAR szMessage[_MAX_PATH];
				//wsprintf(szMessage,_T("Successfully UnRegistered:\n\n%s"),szName);
				//MessageBox(GetFocus(), szMessage ,"",MB_OK);
			}
		}
		FreeLibrary(hLib);
	}
}

void DeleteKeyHelper( LPCTSTR szName )
{
	HKEY hKey;
	if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, szName, 0, KEY_QUERY_VALUE, &hKey ) )
	{
		DWORD dwSubKeys = 0;
		DWORD dwValues = 0;
		if( ERROR_SUCCESS == RegQueryInfoKey( hKey, NULL, NULL, NULL, &dwSubKeys, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL ) )
		{
			if( dwSubKeys == 0 )
			{
				// Only delete the key if it has zero subkeys
				RegDeleteKey( HKEY_LOCAL_MACHINE, szName );
			}
			RegCloseKey( hKey );
		}
		else
		{
			RegCloseKey( hKey );
		}
	}
}

int UninstInitialize(HWND hwndDlg, HWND hInstance, long int lReserved)
{
	LPTSTR lpStr;
	TCHAR szCurrentDirectory[_MAX_PATH];
	TCHAR szTemp[_MAX_PATH];
	TCHAR szTemp2[_MAX_PATH];
	
	//Figure where the LOG and DLL file are located
	lpStr = GetCommandLine();
	
	GetBaseDir(lpStr,szBaseDir);
	
	_tcscpy( szTemp, szBaseDir );
	_tcscat( szTemp, _T("DMUSProd.exe") );
	_tcscpy( szTemp2, _T("/UNREGSERVER") );

	// Save the current directory
	if( 0 == GetCurrentDirectory( _MAX_PATH, szCurrentDirectory ) )
	{
		szCurrentDirectory[0] = 0;
	}

	// Set the current directory to Producer's installation directory
	SetCurrentDirectory( szBaseDir );

	int nResult;
	nResult = _tspawnl( _P_WAIT, szTemp, szTemp, szTemp2, NULL );
	Sleep( 10000 );
	/*
	if( !nResult )
	{
		// We've succeeded - display fireworks here
		TCHAR szMessage[_MAX_PATH];
		wsprintf(szMessage,_T("Successfully UnRegistered:\n\n%s"),szTemp);
		MessageBox(GetFocus(), szMessage ,"",MB_OK);
	}
	else
	{
		// We've failed - display bomb here
		TCHAR szMessage[_MAX_PATH];
		wsprintf(szMessage,_T("UnSuccessfully UnRegistered:\n\n%s"),szTemp);
		MessageBox(GetFocus(), szMessage ,"",MB_OK);
	}
	*/

	if (SUCCEEDED(OleInitialize(NULL)))
	{
		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ContainerDesigner.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("AudioPathDesigner.ocx") );
		UnRegister( szTemp );

		/*
		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("MelGenStripMgr.dll") );
		UnRegister( szTemp );
		*/

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("XboxAddin.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("xboxsynth.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ParamStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("WaveStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("MarkerStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ToolGraphDesigner.ocx") );
		UnRegister( szTemp );

		/*
		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("SongDesigner.ocx") );
		UnRegister( szTemp );
		*/

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("SegmentStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ScriptStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ScriptDesigner.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("SegmentDesigner.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("StyleDesigner.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ChordMapDesigner.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("DLSDesigner.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("BandEditor.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("PanVol.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ADSREnvelope.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("RegionKeyboard.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("CommandStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ChordStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ChordMapStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("MIDIStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("SignPostStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("LyricStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("StyleRefStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("ChordMapRefStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("BandStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("TempoStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("SequenceStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("MuteStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("TimeSigStripMgr.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("Msflxgrd.ocx") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("Timeline.dll") );
		UnRegister( szTemp );

		_tcscpy( szTemp, szBaseDir );
		_tcscat( szTemp, _T("Conductor.dll") );
		UnRegister( szTemp );

		OleUninitialize();
	}

	if( szCurrentDirectory[0] )
	{
		SetCurrentDirectory( szCurrentDirectory );
	}

	// Now check to see if HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\DMUSProducer\Components,
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\DMUSProducer\Container Objects,
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\DMUSProducer\StripEditors, and
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\DMUSProducer are empty, and remove them if they are

	DeleteKeyHelper( _T("SOFTWARE\\Microsoft\\DMUSProducer\\Components") );
	DeleteKeyHelper( _T("SOFTWARE\\Microsoft\\DMUSProducer\\Container Objects") );
	DeleteKeyHelper( _T("SOFTWARE\\Microsoft\\DMUSProducer\\StripEditors") );
	DeleteKeyHelper( _T("SOFTWARE\\Microsoft\\DMUSProducer") );

	return(0);
}

int UninstUnInitialize(HWND hwndDlg, HWND hInstance, long int lReserved)
{
	return 0;
}

} ;

// Check the last character in a string to see if it is a given character
BOOL LastChar(LPTSTR szString,TCHAR chSearch)
{
	LPTSTR lpstr,lplast;

	if (lstrlen(szString)==0)
		return(FALSE);

	lplast=(LPTSTR)szString;
	lpstr=CharNext(szString);
	while (*lpstr)
	{
		lplast=lpstr;
		lpstr=CharNext(lplast);
	} 

	//if (IsDBCSLeadByte(*lplast))
	//	return(FALSE);

	if (*lplast==chSearch)
		return(TRUE);
	else
		return(FALSE);
}

//Get the directory where the DLL is found
BOOL GetBaseDir(LPTSTR lpLine,LPTSTR szBase)
{
	TCHAR szLine[_MAX_PATH],szFile[_MAX_PATH];
	LPTSTR ptr;
	int len;

	lstrcpy(szLine,lpLine);
	ptr=_tcsstr(szLine,_T("-c"));
	if (ptr==NULL)
	{
		szBase[0]=0;
		return(0);
	}

	ptr=CharNext(ptr); //skip past -c and up to filename portion
	ptr=CharNext(ptr); 

	//remove leading " if present
	//if ((IsDBCSLeadByte(*ptr)==0) && (*ptr=='"'))
	if ( *ptr=='"' )
		++ptr;
	lstrcpy(szFile,ptr);

	//remove trailing " if present
	if (LastChar(szFile,'"'))
	{
		len=lstrlen(szFile);
		szFile[len-1]=0;
	}

	//split the path\my.dll string
	SplitName(szFile,szBase,szLine,'\\');
	return(TRUE);
}

//Split a string at the last occurance of a given character
void SplitName(LPCTSTR szWholeName,LPTSTR szPath,LPTSTR szFile,TCHAR chSep)
{ 
	int i,len,j;
	LPTSTR lpstr,lplast;

	len=i=lstrlen(szWholeName);
	if (len==0)
	{
		szPath[0]=0; szFile[0]=0; return;
	}

	//First walk out to the end of the string
	lplast=(LPTSTR)szWholeName;
	lpstr=CharNext(szWholeName);
	while (*lpstr)
	{
		lplast=lpstr;
		lpstr=CharNext(lplast);
	} 

	//Now walk backward to the beginning
	while (*lplast)
	{
		/*
		if (IsDBCSLeadByte(*lplast))
		{
			lplast=CharPrev(szWholeName,lplast);
			if (lplast==szWholeName)
			{
				szPath[0]=0;
				lstrcpy(szFile,szWholeName);
				return;
			}
		}
		else*/ if (*lplast==chSep)
		{										 
			i=lplast-szWholeName+1;
			lstrcpyn(szPath,szWholeName,i+1);
			szPath[i]=0;
			j=len-i;
			lstrcpyn(szFile,&szWholeName[i],j+1);
			szFile[j]=0;
			return;
		}
		else
		{
			lplast=CharPrev(szWholeName,lplast);
			if (lplast==szWholeName)
			{
				szPath[0]=0;
				lstrcpy(szFile,szWholeName);
				return;
			}
		}
	}

	//Didn't find it so just default the values
	szPath[0]=0;
	lstrcpy(szFile,szWholeName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "EAXChorus"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\dsdmobse.cpp ===
/*
 * DirectSound DirectMediaObject base classes 
 *
 * Copyright (c) 1999-2000 Microsoft Corporation.  All Rights Reserved.  
 */

#include "DsDmoBse.h"

// XXX C1in1out calls InitializeCriticalSection in a constructor with
// no handler.
//

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::CDirectSoundDMO
//
CDirectSoundDMO::CDirectSoundDMO()
{
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::~CDirectSoundDMO
//
CDirectSoundDMO::~CDirectSoundDMO() 
{
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetClassID
//
// This should always return E_NOTIMPL
//
STDMETHODIMP CDirectSoundDMO::GetClassID(THIS_ CLSID *pClassID)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::IsDirty
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::IsDirty(THIS)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Load
//
// Override if doing something other than just standard load.
//
STDMETHODIMP CDirectSoundDMO::Load(THIS_ IStream *pStm) 
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Save
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::Save(THIS_ IStream *pStm, BOOL fClearDirty)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetSizeMax
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::GetSizeMax(THIS_ ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Process
//
STDMETHODIMP CDirectSoundDMO::Process(THIS_ ULONG ulSize, BYTE *pData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    DMO_MEDIA_TYPE *pmt = InputType();
    if (pmt == NULL)
        return E_FAIL;

    assert(pmt->formattype == FORMAT_WaveFormatEx);
    ulSize /= LPWAVEFORMATEX(pmt->pbFormat)->nBlockAlign;
    return ProcessInPlace(ulSize, pData, rtStart, dwFlags);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetLatency
//
STDMETHODIMP CDirectSoundDMO::GetLatency(THIS_ REFERENCE_TIME *prt)
{
    *prt = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\dllmain.cpp ===
//
// dllmain.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//

#include <objbase.h>
#include "debug.h"
#include "oledll.h"
#include "testdmo.h"
#include "dumpp.h"

DWORD g_amPlatform;

#define DefineClassFactory(x)                                               \
class x ## Factory : public IClassFactory                                   \
{                                                                           \
public:                                                                     \
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);        \
	virtual STDMETHODIMP_(ULONG) AddRef();                                  \
	virtual STDMETHODIMP_(ULONG) Release();                                 \
                                                                            \
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter,            \
    	const IID& iid, void** ppv);                                        \
	virtual STDMETHODIMP LockServer(BOOL bLock);                            \
                                                                            \
	 x ## Factory() : m_cRef(1) {}                                          \
                                                                            \
	~ x ## Factory() {}                                                     \
                                                                            \
private:                                                                    \
	long m_cRef;                                                            \
};                                                                          \
STDMETHODIMP x ## Factory::QueryInterface(                                  \
    const IID &iid, void **ppv)                                             \
{                                                                           \
	if(iid == IID_IUnknown || iid == IID_IClassFactory)                     \
	{                                                                       \
		*ppv = static_cast<IClassFactory*>(this);                           \
    }                                                                       \
	else                                                                    \
    {                                                                       \
		*ppv = NULL;                                                        \
		return E_NOINTERFACE;                                               \
    }                                                                       \
                                                                            \
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();                            \
                                                                            \
    return S_OK;                                                            \
}                                                                           \
STDMETHODIMP_(ULONG) x ## Factory::AddRef()                                 \
{                                                                           \
	return InterlockedIncrement(&m_cRef);                                   \
}                                                                           \
                                                                            \
STDMETHODIMP_(ULONG) x ## Factory::Release()                                \
{                                                                           \
    if(!InterlockedDecrement(&m_cRef))                                      \
	{                                                                       \
		delete this;                                                        \
		return 0;                                                           \
    }                                                                       \
                                                                            \
    return m_cRef;                                                          \
}                                                                           \
                                                                            \
STDMETHODIMP x ## Factory::LockServer(BOOL bLock)                           \
{                                                                           \
    if(bLock)                                                               \
	{                                                                       \
		InterlockedIncrement(&g_cLock);                                     \
    }                                                                       \
	else                                                                    \
	{                                                                       \
		InterlockedDecrement(&g_cLock);                                     \
    }                                                                       \
                                                                            \
    return S_OK;                                                            \
}

/*
STDMETHODIMP x ## Factory::CreateInstance(                                  \
    IUnknown* pUnknownOuter,  const IID& iid, void** ppv)                   \
{                                                                           \
    OutputDebugString("Create " #x  "\n");                                  \
	if (ppv == NULL)                                                        \
	{                                                                       \
		return E_POINTER;                                                   \
	}                                                                       \
                                                                            \
	if (pUnknownOuter)                                                      \
    {                                                                       \
		 return CLASS_E_NOAGGREGATION;                                      \
    }                                                                       \
                                                                            \
    x *p;                                                                   \
                                                                            \
    try                                                                     \
    {                                                                       \
        p = new x;                                                          \
    }                                                                       \
    catch( ... )                                                            \
    {                                                                       \
        return E_OUTOFMEMORY;                                               \
    }                                                                       \
                                                                            \
    if (p == NULL)                                                          \
	{                                                                       \
		return E_OUTOFMEMORY;                                               \
    }                                                                       \
                                                                            \
    HRESULT hr = p->QueryInterface(iid, ppv);                               \
                                                                            \
    p->Release();                                                           \
                                                                            \
    return hr;                                                              \
}                                                                           \

*/


#define DefineDMOClassFactory(x) DefineClassFactory(CDirectSound ## x ## DMO)

//////////////////////////////////////////////////////////////////////
// Globals
//

// Registry Info
//
#define DefineNames(x)                                                              \
TCHAR g_sz## x ##FriendlyName[]    = TEXT("DirectSound" #x "DMO");                  \
TCHAR g_sz## x ##VerIndProgID[]    = TEXT("Microsoft.DirectSound" #x "DMO");        \
TCHAR g_sz## x ##ProgID[]          = TEXT("Microsoft.DirectSound" #x "DMO.1");
/*
TCHAR g_sz## x ##PropFriendlyName[] = TEXT("DirectSound" #x "DMOPropPage");         \
TCHAR g_sz## x ##PropVerIndProgID[] = TEXT("Microsoft.DirectSound" #x "DMOPropPage");   \
TCHAR g_sz## x ##PropProgID[]      = TEXT("Microsoft.DirectSound" #x "DMOPropPage.1");
*/

DefineNames(FileOutput)

// Dll's hModule
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
long g_cComponent = 0;
long g_cLock = 0;

DefineDMOClassFactory(FileOutput)
STDMETHODIMP CDirectSoundFileOutputDMOFactory::CreateInstance(
    IUnknown* pUnknownOuter,  const IID& iid, void** ppv)
{
	if (ppv == NULL)
	{
		return E_POINTER;
	}

	if (pUnknownOuter)
    {
		 return CLASS_E_NOAGGREGATION;
    }

    CDirectSoundDumpDMO *p;

    try
    {
        p = new CDirectSoundDumpDMO;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (p == NULL)
	{
		return E_OUTOFMEMORY;
    }

    HRESULT hr = p->QueryInterface(iid, ppv);

    p->Release();

    return hr;
}

/*
DefineClassFactory(CDumpProperties)
STDMETHODIMP CDumpPropertiesFactory::CreateInstance(
    IUnknown* pUnknownOuter,  const IID& iid, void** ppv)
{
	if (ppv == NULL)
	{
		return E_POINTER;
	}

	if (pUnknownOuter)
    {
		 return CLASS_E_NOAGGREGATION;
    }

    CDumpPropertyPage *p;

    try
    {
        p = new CDumpPropertyPage;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (p == NULL)
	{
		return E_OUTOFMEMORY;
    }

    HRESULT hr = p->QueryInterface(iid, ppv);

    p->Release();

    return hr;
}
*/

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) 
	{
		return S_FALSE;
    }

    return S_OK;
}

// Hack to make these macros continue to work:
#define GUID_DSFX_STANDARD_FileOutput       GUID_DSFX_STANDARD_DUMP

#define GetClassObjectCase(x,t) \
    if (clsid == x) { \
        p = static_cast<IUnknown*> ((IClassFactory*) (new t)); \
    } else 

#define GetClassObjectCaseEnd \
    { return CLASS_E_CLASSNOTAVAILABLE; }

#define GetClassObjectCaseFX(x) \
    GetClassObjectCase(GUID_DSFX_STANDARD_ ## x, CDirectSound ## x ## DMOFactory)

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
						 const IID& iid,
						 void** ppv)
{
	if (ppv == NULL)
	{
		return E_POINTER;
	}

	IUnknown* p = NULL;

    GetClassObjectCaseFX(FileOutput)

	//GetClassObjectCase(CLSID_DirectSoundPropDump,  CDumpPropertiesFactory)

    GetClassObjectCaseEnd

	if(!p) 
	{
		return E_OUTOFMEMORY;
	}

    HRESULT hr = p->QueryInterface(iid, ppv);
    p->Release();

    return hr;
}

#define DoUnregister(x)                                                 \
         UnregisterServer(GUID_DSFX_STANDARD_ ## x,                     \
                          g_sz ## x ## FriendlyName,                    \
                          g_sz ## x ## VerIndProgID,                    \
                          g_sz ## x ## ProgID)

#define DoRegister(x)                                                   \
         RegisterServer(g_hModule,                                      \
                        GUID_DSFX_STANDARD_ ## x,                       \
                        g_sz ## x ## FriendlyName,                      \
                        g_sz ## x ## VerIndProgID,                      \
                        g_sz ## x ## ProgID)

#define DoDMORegister(x)                                                \
         DMORegister(L#x,                                              \
         GUID_DSFX_STANDARD_ ## x,                                      \
         DMOCATEGORY_AUDIO_EFFECT,                                      \
         0, 1, &mt, 1, &mt)

#define DoDMOUnregister(x)                                              \
         DMOUnregister(GUID_DSFX_STANDARD_ ## x,                        \
         DMOCATEGORY_AUDIO_EFFECT)

#define Unregister(x)                                                   \
    if (SUCCEEDED(hr)) hr = DoDMOUnregister(x);                         \
    if (SUCCEEDED(hr)) hr = DoUnregister(x); 

#define Register(x)                                                     \
    if (SUCCEEDED(hr)) hr = DoRegister(x);                              \
    if (SUCCEEDED(hr)) hr = DoDMORegister(x);

/*
#define DoPropRegister(x)                                               \
    if (SUCCEEDED(hr)) hr = RegisterServer(                             \
        g_hModule,                                                      \
        CLSID_DirectSoundProp ## x,                                     \
        g_sz ## x ## PropFriendlyName,                                  \
        g_sz ## x ## PropVerIndProgID,                                  \
        g_sz ## x ## PropProgID);

#define DoPropUnregister(x)                                             \
    if (SUCCEEDED(hr)) hr = UnregisterServer(                           \
        CLSID_DirectSoundProp ## x,                                     \
        g_sz ## x ## PropFriendlyName,                                  \
        g_sz ## x ## PropVerIndProgID,                                  \
        g_sz ## x ## PropProgID);
*/

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    HRESULT hr = S_OK;

    Unregister(FileOutput);
    //DoPropUnregister(Dump)

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    HRESULT hr = S_OK;

    DMO_PARTIAL_MEDIATYPE mt;
    mt.type = MEDIATYPE_Audio;
    mt.subtype = MEDIASUBTYPE_PCM;

    Register(FileOutput);
    //DoPropRegister(Dump);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
				      DWORD dwReason,
				      void *lpReserved)
{
	static int nReferenceCount = 0;

#ifdef DBG
    if(dwReason < nReasons)
    {
		Trace(DM_DEBUG_STATUS, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
		Trace(DM_DEBUG_STATUS, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
		case DLL_PROCESS_ATTACH:
		    if(++nReferenceCount == 1)
			{
			#ifdef DBG
				DebugInit();
			#endif

				//_Module.Init(NULL, hModule, NULL);
				if(!DisableThreadLibraryCalls(hModule))
				{
					Trace(DM_DEBUG_STATUS, "DisableThreadLibraryCalls failed.\n");
				}

				g_hModule = hModule;

                g_amPlatform = VER_PLATFORM_WIN32_WINDOWS; // win95 assumed in case GetVersionEx fails

                OSVERSIONINFO osInfo;
                osInfo.dwOSVersionInfoSize = sizeof(osInfo);
                if (GetVersionEx(&osInfo))
                {
                    g_amPlatform = osInfo.dwPlatformId;
                }
            }
			break;

		case DLL_PROCESS_DETACH:
		    if(--nReferenceCount == 0)
			{
				Trace(DM_DEBUG_STATUS, "Unloading\n");
			}
			//_Module.Term();
			break;
    }
	
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\guid.cpp ===
#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include "testdmo.h"
#include <dmo.h>
#include <medparam.h>
#include <uuids.h>

// FIXME: this includes a lot more GUIDs than it needs to (do "strings testdmo.dll")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\dsdmobse.h ===
/*
 * DirectSound DirectMediaObject base classes 
 *
 * Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.  
 */
#ifndef _DsDmoBase_
#define _DsDmoBase_

#define DMO_NOATL

#include <objbase.h>
#include <dmobase.h>
#include <medparam.h>

#ifndef RELEASE
#define RELEASE(x) { if (x) (x)->Release(); x = NULL; }
#endif

class CDirectSoundDMO :
      public CPCMDMO,
      public IPersistStream,
      public IMediaObjectInPlace
{
public:
    CDirectSoundDMO();
    virtual ~CDirectSoundDMO();

    /* IPersist */
    STDMETHODIMP GetClassID                 (THIS_ CLSID *pClassID);
    
    /* IPersistStream */
    STDMETHODIMP IsDirty                    (THIS);
    STDMETHODIMP Load                       (THIS_ IStream *pStm); 
    STDMETHODIMP Save                       (THIS_ IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax                 (THIS_ ULARGE_INTEGER *pcbSize);

    /* IMediaObjectInPlace */
    STDMETHODIMP Process                    (THIS_ ULONG ulSize, BYTE *pData, REFERENCE_TIME rtStart, DWORD dwFlags);
    STDMETHODIMP GetLatency                 (THIS_ REFERENCE_TIME *prt);

protected:
    // Process in place
    //
    virtual HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\resource.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Definitions of symbolic constants used in GargProp.rc and gargprop.cpp.
//

#ifndef __DUMPRESOURCE__
#define __DUMPRESOURCE__

#ifdef __cplusplus
extern "C" {
#endif

#define IDD_WAVESAVEPROP                101
#define IDS_STATIC                      -1
#define IDS_NAME                        102
#define IDC_BUTTON_EDITNAME				103
#define IDC_EDIT_FILENAME				104
#define IDC_CHECK_OVERWRITE				105
#define IDS_TITLE                       106


#ifdef __cplusplus
}
#endif

#endif // __DUMPRESOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\dumpp.h ===
//
//
//
#ifndef _Dumpp_
#define _Dumpp_

#include <mmsystem.h>
#include <dsound.h>
#include "dsdmobse.h"
#include <dmobase.h>
#include "testdmo.h"


class CDirectSoundDumpDMO : public CDirectSoundDMO,
				public IDump
{

public:
    CDirectSoundDumpDMO();
    ~CDirectSoundDumpDMO();

    /* IUnknown */
    STDMETHODIMP QueryInterface             (THIS_ REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef             (THIS);
    STDMETHODIMP_(ULONG) Release            (THIS);

	// IPersist methods
	virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

	// IPersistStream methods
	virtual HRESULT STDMETHODCALLTYPE IsDirty(void);
	virtual HRESULT STDMETHODCALLTYPE Load( IStream *pStm );
	virtual HRESULT STDMETHODCALLTYPE Save( IStream *pStm, BOOL fClearDirty );
	virtual HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER *pcbSize );

    // IDump
    STDMETHOD(SetDumpWave)	(THIS_ WCHAR *wszDumpWave);
    STDMETHOD(GetDumpWave)	(THIS_ WCHAR *wszDumpWave);
    STDMETHOD(GetOverwrite)	(THIS_ BOOL *pbOverwrite);
    STDMETHOD(SetOverwrite)	(THIS_ BOOL bOverwrite);
    STDMETHOD(Start)		(THIS);
    STDMETHOD(Stop)			(THIS);

    /* IMediaObjectInPlace */
    STDMETHODIMP Clone                      (THIS_ IMediaObjectInPlace **pDest);

	// All of these methods are called by the base class
	HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
	HRESULT Init();
	HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    
private:
    long m_cRef;
    HRESULT InitWave(WCHAR *wszDumpWave);

private:
    // dump params
    WCHAR m_wszDumpWave[_MAX_PATH];
   
    BOOL m_fDirty;
    BOOL m_bInitialized;
	BOOL m_fOverwriteExisting;
	BOOL m_fWritingWavFile;
	CRITICAL_SECTION	m_csFileHandle;

    MMCKINFO            m_ckDst;
    MMCKINFO            m_ckDstRIFF;
    HMMIO               m_hmmioDst;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\testdmo.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// testdmo.h
//

// A custom interface to allow the user to adjust the dump parameters.
// It defines the interface between the user interface component (the
// property sheet) and the filter itself.
// This interface is exported by the code in dump.cpp and is used
// by the code in dumpprop.cpp.

#ifndef __TESTDMO_H__
#define __TESTDMO_H__

#include <mmsystem.h>

#ifdef __cplusplus
extern "C" {
#endif

#define DEFAULT_DUMP_FILE L".\\dump.wav"

//
// IDump
//
DECLARE_INTERFACE_(IDump, IUnknown)
{
    STDMETHOD(SetDumpWave)	(THIS_ WCHAR *wszDumpWave) PURE;
    STDMETHOD(GetDumpWave)	(THIS_ WCHAR *wszDumpWave) PURE;
    STDMETHOD(GetOverwrite)	(THIS_ BOOL *pbOverwrite) PURE;
    STDMETHOD(SetOverwrite)	(THIS_ BOOL bOverwrite) PURE;
    STDMETHOD(Start)		(THIS) PURE;
    STDMETHOD(Stop)			(THIS) PURE;
};


// This GUID also exists in the Audiopath Designer, in audiopath.cpp
// {2D6D1411-DCD7-45e7-ADDE-ACAC85A2425D}
DEFINE_GUID(GUID_DSFX_STANDARD_DUMP, 0x2d6d1411, 0xdcd7, 0x45e7, 0xad, 0xde, 0xac, 0xac, 0x85, 0xa2, 0x42, 0x5d);


// {E13DCE68-47D1-4b77-AEBA-BFAC78F7AA17}
DEFINE_GUID(IID_IDump, 0xe13dce68, 0x47d1, 0x4b77, 0xae, 0xba, 0xbf, 0xac, 0x78, 0xf7, 0xaa, 0x17);
// {E0CF68ED-0E3C-4f8c-ADE1-ECDC04B57907}
DEFINE_GUID(CLSID_DirectSoundPropDump, 0xe0cf68ed, 0xe3c, 0x4f8c, 0xad, 0xe1, 0xec, 0xdc, 0x4, 0xb5, 0x79, 0x7);


#ifdef __cplusplus
}
#endif

#endif // __TESTDMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\dump.cpp ===
#include <windows.h>
#include "dumpp.h"


extern long g_cComponent;

STDAPI_(HRESULT) MMRESULTtoHRESULT(MMRESULT mmr)
{
	HRESULT hr;

	switch(mmr)
	{
	case MMSYSERR_NOERROR:
		hr = DS_OK;
		break;

	case MMSYSERR_BADDEVICEID:
	case MMSYSERR_NODRIVER:
		hr = DSERR_NODRIVER;
		break;

	case MMSYSERR_ALLOCATED:
		hr = DSERR_ALLOCATED;
		break;

	case MMSYSERR_NOMEM:
		hr = DSERR_OUTOFMEMORY;
		break;

	case MMSYSERR_NOTSUPPORTED:
		hr = DSERR_UNSUPPORTED;
		break;

	case WAVERR_BADFORMAT:
		hr = DSERR_BADFORMAT;
		break;

	default:
		hr = DSERR_GENERIC;
		break;
	}
	
	return hr;
}

STDMETHODIMP CDirectSoundDumpDMO::QueryInterface(THIS_ REFIID iid, LPVOID *ppv)
{
	if (ppv == NULL)
	{
		return E_POINTER;
	}

	if (iid == IID_IUnknown || iid == IID_IPersist)
	{
		*ppv = (LPVOID*)static_cast<IPersist*>(this);
	}
	else if (iid == IID_IPersistStream)
	{
		*ppv = (LPVOID*)static_cast<IPersistStream*>(this);
	}
	else if (iid == IID_IMediaObject)
	{
		*ppv = (LPVOID*)static_cast<IMediaObject*>(this);
	}
	else if (iid == IID_IMediaObjectInPlace)
	{
		*ppv = (LPVOID*)static_cast<IMediaObjectInPlace*>(this);
	}
	else if (iid == IID_IDump)
	{
		*ppv = (LPVOID*)static_cast<IDump*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CDirectSoundDumpDMO::AddRef(THIS)
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDirectSoundDumpDMO::Release(THIS)
{
	LONG l = InterlockedDecrement(&m_cRef);

	if (l == 0) 
	{
		delete this;
		return 0;
	}

	return l;
}

CDirectSoundDumpDMO::CDirectSoundDumpDMO() :
m_fDirty(FALSE),
m_bInitialized(FALSE),
m_fOverwriteExisting(FALSE),
m_cRef(1),
m_hmmioDst(NULL)
{
	InterlockedIncrement(&g_cComponent);

	wcscpy( m_wszDumpWave, DEFAULT_DUMP_FILE );

	::InitializeCriticalSection( &m_csFileHandle );
}

CDirectSoundDumpDMO::~CDirectSoundDumpDMO()
{
	if ( m_hmmioDst )
	{
		if (MMSYSERR_NOERROR == mmioAscend(m_hmmioDst, &m_ckDst, 0))
		{
			if (MMSYSERR_NOERROR == mmioAscend(m_hmmioDst, &m_ckDstRIFF, 0))
			{
				mmioClose(m_hmmioDst, 0);
			}
		}
	}
	m_hmmioDst = 0;

	::DeleteCriticalSection( &m_csFileHandle );

	InterlockedDecrement(&g_cComponent);
}

HRESULT CDirectSoundDumpDMO::Init()
{
	HRESULT hr = DS_OK;

	m_bInitialized = TRUE;
	return hr;
}

HRESULT CDirectSoundDumpDMO::Discontinuity()
{
	return NOERROR;
}

HRESULT CDirectSoundDumpDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
	HRESULT 		hr = DS_OK;
	LONG			lOut = cSamples * m_cChannels * (m_b8bit ? 1 : 2);

	if (!m_bInitialized)
		return DMO_E_TYPE_NOT_SET;

	memcpy(pOut, pIn, cSamples * m_cChannels * (m_b8bit ? 1 : 2));

	::EnterCriticalSection( &m_csFileHandle );
	if ( m_hmmioDst )
	{
		if ( lOut != mmioWrite(m_hmmioDst, (HPSTR) pIn, lOut) )
		{
			hr = DSERR_GENERIC;
		}
	}
	::LeaveCriticalSection( &m_csFileHandle );

	return hr;
}


// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// a dump in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundDumpDMO::GetClassID(CLSID *pClsid)
{
	if (pClsid==NULL) {
		return E_POINTER;
	}
	*pClsid = GUID_DSFX_STANDARD_DUMP;
	return NOERROR;

} // GetClassID


//
// GetSizeMax
//
// State the maximum number of bytes we would ever write in a file
// to save our properties.
//
HRESULT CDirectSoundDumpDMO::GetSizeMax( ULARGE_INTEGER *pcbSize )
{
	if( !pcbSize )
	{
		return E_POINTER;
	}

	// dump wave file name and overwrite flag
	pcbSize->QuadPart = _MAX_PATH*sizeof(WCHAR) + sizeof(BOOL);
	return S_OK;

}  // GetSizeMax

//
// Save
//
// Write our properties to the stream.
//
HRESULT CDirectSoundDumpDMO::Save(IStream *pStm, BOOL fClearDirty)
{
	DWORD cbWritten;
	HRESULT hr = pStm->Write( &m_fOverwriteExisting, sizeof(BOOL), &cbWritten );
	if( cbWritten != sizeof(BOOL) )
	{
		hr = E_FAIL;
	}
	if( SUCCEEDED( hr ) )
	{
		hr = pStm->Write(&(m_wszDumpWave[0]), _MAX_PATH*sizeof(WCHAR), &cbWritten);
		if( cbWritten != _MAX_PATH*sizeof(WCHAR) )
		{
			hr = E_FAIL;
		}
	}

	if( SUCCEEDED( hr )
		&&	fClearDirty )
	{
		m_fDirty = FALSE;
	}

	return hr;
} // Save


//
// Load
//
// Read our properties from the stream.
//
HRESULT CDirectSoundDumpDMO::Load(IStream *pStream)
{
	DWORD cbRead;
	HRESULT hr = pStream->Read( &m_fOverwriteExisting, sizeof(BOOL), &cbRead );
	if( cbRead != sizeof(BOOL) )
	{
		hr = E_FAIL;
	}
	if( SUCCEEDED( hr ) )
	{
		hr = pStream->Read(&(m_wszDumpWave[0]), _MAX_PATH*sizeof(WCHAR), &cbRead);
		if( cbRead != _MAX_PATH*sizeof(WCHAR) )
		{
			hr = E_FAIL;
		}
	}

	return hr;
} // Load

HRESULT CDirectSoundDumpDMO::IsDirty(void)
{
	return ( m_fDirty ) ? S_OK : S_FALSE;
}


// ==============Implementation of the private IDump interface ==========

void GetUniqueFilename( CHAR szDumpWave[_MAX_PATH] )
{
	// If the file exists
	if( mmioOpen( szDumpWave, NULL, MMIO_EXIST ) )
	{
		// Copy the original name
		CHAR szOrigName[_MAX_PATH];
		strcpy( szOrigName, szDumpWave );

		// Find the position of the last '.'
		CHAR *pDot = strrchr( szOrigName, '.' );

		// If we didn't find the dot
		if( pDot == NULL )
		{
			// Point pDot at the trailing NULL
			pDot = szOrigName + strlen( szOrigName );
		}
		else
		{
			// Cut off the name at the dot
			*pDot = NULL;
		}

		// The string to store the number in
		CHAR *pNumberStart = pDot-1;
		CHAR szNbr[_MAX_PATH];
		while( pNumberStart > szOrigName  &&  isdigit( *pNumberStart ) )
		{
			pNumberStart--;
		}

		// Increment to the first number
		*pNumberStart++;

		// Check if we didn't find a number
		if( pNumberStart == pDot )
		{
			// No number - make szNbr empty
			szNbr[0] = NULL;
		}
		else
		{
			// Copy the number to szNbr
			strcpy( szNbr, pNumberStart );

			// Cut off the name at the start of the number
			*pNumberStart = NULL;
		}

		// Save the length of the textual part of the original name
		const int nOrigNameLength = strlen( szOrigName );

		// Set the first number to use
		int i = atoi( szNbr );

		// While the filename exists
		while( mmioOpen( szDumpWave, NULL, MMIO_EXIST ) )
		{
			// Convert from a number to a string
			_itoa( ++i, szNbr, 10 );

			// Get the length of the number text
			int nNbrLength = strlen(szNbr);

			// Ensure the name doesn't go longer than _MAX_PATH (5 = length of ".wav" plus the trailing NULL)
			if( (nOrigNameLength + nNbrLength + 5) <= _MAX_PATH )
			{
				// Name will fit within _MAX_PATH, just copy it
				strcpy( szDumpWave, szOrigName );
				strcat( szDumpWave, szNbr );
				strcat( szDumpWave, ".wav" );
			}
			else
			{
				// Name won't fit within _MAX_PATH, clip szOrigName
				ZeroMemory( szDumpWave, _MAX_PATH );
				strncpy( szDumpWave, szOrigName, _MAX_PATH - nNbrLength - 5 );
				strcat( szDumpWave, szNbr );
				strcat( szDumpWave, ".wav" );
			}
		}
	}
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::InitWave
//
HRESULT CDirectSoundDumpDMO::InitWave(WCHAR *wszDumpWave)
{
	HRESULT 			hr = DS_OK;
	MMRESULT			mmr;

	CHAR				szDumpWave[_MAX_PATH];

	HMMIO				hmmioDst = NULL;
	MMCKINFO			ckDst;
	MMCKINFO			ckDstRIFF;

	PCMWAVEFORMAT		wfx;

	if (wszDumpWave == NULL)
	{
		return E_POINTER;
	}

	::EnterCriticalSection( &m_csFileHandle );
	if ( m_hmmioDst )
	{
		if (MMSYSERR_NOERROR == mmioAscend(m_hmmioDst, &m_ckDst, 0))
		{
			if (MMSYSERR_NOERROR == mmioAscend(m_hmmioDst, &m_ckDstRIFF, 0))
			{
				mmioClose(m_hmmioDst, 0);
			}
		}
	}

	m_hmmioDst = NULL;
	::LeaveCriticalSection( &m_csFileHandle );

	if( !m_bInitialized )
	{
		return E_FAIL;
	}

	WideCharToMultiByte(CP_ACP, 0, wszDumpWave, -1, szDumpWave, sizeof(szDumpWave), NULL, NULL);

	if( !m_fOverwriteExisting )
	{
		GetUniqueFilename( szDumpWave );
	}

	hmmioDst = mmioOpen( szDumpWave, NULL, MMIO_CREATE | MMIO_WRITE | MMIO_EXCLUSIVE | MMIO_ALLOCBUF );
	if (NULL == hmmioDst )
	{
		return E_FAIL;
	}

	ckDstRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
	ckDstRIFF.cksize  = 0L;
	mmr = mmioCreateChunk(hmmioDst, &ckDstRIFF, MMIO_CREATERIFF);
	if (MMSYSERR_NOERROR != mmr)
	{
		hr = MMRESULTtoHRESULT(mmr);
	}

	if ( SUCCEEDED(hr) )
	{
		ckDst.ckid		= mmioFOURCC( 'f', 'm', 't', ' ' );
		ckDst.cksize	= sizeof(PCMWAVEFORMAT);
		mmr = mmioCreateChunk( hmmioDst, &ckDst, 0 );
		if ( MMSYSERR_NOERROR != mmr )
		{
			hr = MMRESULTtoHRESULT(mmr);
		}
	}

	if ( SUCCEEDED(hr) )
	{
		wfx.wBitsPerSample			= m_b8bit ? 8 : 16;
		wfx.wf.wFormatTag			= WAVE_FORMAT_PCM;
		wfx.wf.nChannels			= (WORD) m_cChannels;
		wfx.wf.nSamplesPerSec		= m_ulSamplingRate;
		wfx.wf.nBlockAlign			= wfx.wf.nChannels * wfx.wBitsPerSample / 8;
		wfx.wf.nAvgBytesPerSec		= wfx.wf.nSamplesPerSec * wfx.wf.nBlockAlign;

		if ( sizeof(PCMWAVEFORMAT) != mmioWrite(hmmioDst, (HPSTR) &wfx, sizeof(PCMWAVEFORMAT)) )
		{
			hr = DSERR_GENERIC;
		}
	}

	if ( SUCCEEDED(hr) )
	{
		mmr = mmioAscend( hmmioDst, &ckDst, 0 );
		if ( MMSYSERR_NOERROR != mmr )
		{
			hr = MMRESULTtoHRESULT(mmr);
		}
	}

	if ( SUCCEEDED(hr) )
	{
		ckDst.ckid		= mmioFOURCC( 'd', 'a', 't', 'a' );
		ckDst.cksize	= 0;

		mmr = mmioCreateChunk( hmmioDst, &ckDst, 0 );
		if ( MMSYSERR_NOERROR != mmr )
		{
			hr = MMRESULTtoHRESULT(mmr);
		}
	}

	if (SUCCEEDED(hr))
	{
		::EnterCriticalSection( &m_csFileHandle );
		m_hmmioDst = hmmioDst;
		CopyMemory( &m_ckDst, &ckDst, sizeof(ckDst) );
		CopyMemory( &m_ckDstRIFF, &ckDstRIFF, sizeof(ckDstRIFF) );
		::LeaveCriticalSection( &m_csFileHandle );
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::SetDumpWave
//
STDMETHODIMP CDirectSoundDumpDMO::SetDumpWave(THIS_ WCHAR *wszDumpWave)
{
	HRESULT 			hr = DS_OK;

	if (wszDumpWave == NULL)
	{
		return E_POINTER;
	}

	if ( (0 == _wcsicmp(wszDumpWave, m_wszDumpWave)) && m_hmmioDst )
	{
		// no need to do anything
		return DS_OK;
	}

	// If we're writing out a file
	if( m_hmmioDst )
	{
		// Close the file and open a new one with the new name
		hr = InitWave(wszDumpWave);
	}

	if (SUCCEEDED(hr))
	{
		wcscpy( m_wszDumpWave, wszDumpWave );
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::GetDumpWave
//
STDMETHODIMP CDirectSoundDumpDMO::GetDumpWave(THIS_ WCHAR *wszDumpWave)
{
	if (wszDumpWave == NULL)
	{
		return E_POINTER;
	}

	wcscpy( wszDumpWave, m_wszDumpWave );

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::SetOverwrite
//
STDMETHODIMP CDirectSoundDumpDMO::SetOverwrite(THIS_ BOOL bOverwrite)
{
	m_fOverwriteExisting = bOverwrite;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::GetOverwrite
//
STDMETHODIMP CDirectSoundDumpDMO::GetOverwrite(THIS_ BOOL *pbOverwrite)
{
	if (pbOverwrite == NULL)
	{
		return E_POINTER;
	}

	*pbOverwrite = m_fOverwriteExisting;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::Start
//
STDMETHODIMP CDirectSoundDumpDMO::Start(THIS)
{
	HRESULT hr = S_FALSE;
	if( (NULL == m_hmmioDst) )
	{
		hr = InitWave( m_wszDumpWave );
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::Stop
//
STDMETHODIMP CDirectSoundDumpDMO::Stop(THIS)
{
	::EnterCriticalSection( &m_csFileHandle );
	if ( m_hmmioDst )
	{
		if (MMSYSERR_NOERROR == mmioAscend(m_hmmioDst, &m_ckDst, 0))
		{
			if (MMSYSERR_NOERROR == mmioAscend(m_hmmioDst, &m_ckDstRIFF, 0))
			{
				mmioClose(m_hmmioDst, 0);
			}
		}
	}

	m_hmmioDst = NULL;
	::LeaveCriticalSection( &m_csFileHandle );

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::ProcessInPlace
//
HRESULT CDirectSoundDumpDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
	return FBRProcess(ulQuanta, pcbData, pcbData);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDumpDMO::Clone
//
STDMETHODIMP CDirectSoundDumpDMO::Clone(THIS_ IMediaObjectInPlace **ppDest)
{
	HRESULT hr = S_OK;
	CDirectSoundDumpDMO *pNewDumpDMO = NULL;

	try 
	{
		pNewDumpDMO = new CDirectSoundDumpDMO;
	} catch(...) {}

	if (pNewDumpDMO == NULL) 
	{
		hr = E_OUTOFMEMORY;
	}

	if (SUCCEEDED(hr))
	{
		wcscpy( pNewDumpDMO->m_wszDumpWave, m_wszDumpWave );
		pNewDumpDMO->m_fOverwriteExisting = m_fOverwriteExisting;
	}

	if (SUCCEEDED(hr))
	{	   
		hr = pNewDumpDMO->QueryInterface(IID_IMediaObjectInPlace, (void**)ppDest); 
		pNewDumpDMO->Release();
	}							   
	else
	{
		delete pNewDumpDMO;
	}

	return hr;								 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\oledll.cpp ===
// oledll.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	 = TEXT("ThreadingModel");
static const TCHAR g_szApartment[]		 = TEXT("Apartment");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szApartment);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\GridsPerSecondDlg.h ===
#if !defined(AFX_GRIDSPERSECONDDLG_H__9EA8FD59_CA8B_44D5_A5A7_49D483F35093__INCLUDED_)
#define AFX_GRIDSPERSECONDDLG_H__9EA8FD59_CA8B_44D5_A5A7_49D483F35093__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// GridsPerSecondDlg.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg dialog

class CGridsPerSecondDlg : public CDialog
{
// Construction
public:
	CGridsPerSecondDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGridsPerSecondDlg)
	enum { IDD = IDD_GRIDS_PER_SECOND };
	CStatic	m_staticNbrMS;
	CButton	m_btnOK;
	CSpinButtonCtrl	m_spinNbrGrids;
	CEdit	m_editNbrGrids;
	CButton	m_radioActivePart;
	CButton	m_radioAllParts;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGridsPerSecondDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetNbrMsPerGridText() ;

	// Generated message map functions
	//{{AFX_MSG(CGridsPerSecondDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnKillFocusEditNbrGrids();
	afx_msg void OnDeltaPosSpinNbrGrids(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	short   m_nSnapToRefTime_GridsPerSecond;
	BOOL	m_fAllParts;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GRIDSPERSECONDDLG_H__9EA8FD59_CA8B_44D5_A5A7_49D483F35093__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveSaveDMO\oledll.h ===
//
// OleDLL.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\GridsPerSecondDlg.cpp ===
// GridsPerSecondDlg.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "GridsPerSecondDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg dialog


CGridsPerSecondDlg::CGridsPerSecondDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGridsPerSecondDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGridsPerSecondDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_nSnapToRefTime_GridsPerSecond = 0;
	m_fAllParts = FALSE;
}


void CGridsPerSecondDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGridsPerSecondDlg)
	DDX_Control(pDX, IDC_NBR_MS, m_staticNbrMS);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_SPIN_NBR_GRIDS, m_spinNbrGrids);
	DDX_Control(pDX, IDC_EDIT_NBR_GRIDS, m_editNbrGrids);
	DDX_Control(pDX, IDC_RADIO_ACTIVE_PART, m_radioActivePart);
	DDX_Control(pDX, IDC_RADIO_ALL_PARTS, m_radioAllParts);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::SetNbrMsPerGridText

void CGridsPerSecondDlg::SetNbrMsPerGridText( void ) 
{
	int nGridsPerSecond = m_spinNbrGrids.GetPos();
	ASSERT( nGridsPerSecond >= MIN_NBR_GRIDS_PER_SECOND );
	ASSERT( nGridsPerSecond <= MAX_NBR_GRIDS_PER_SECOND );

	CString strNbr;
	if( 1000 % nGridsPerSecond )
	{
		strNbr.Format( "%.2f", ((float)1000 / nGridsPerSecond) );
	}
	else
	{
		strNbr.Format( "%d", (1000 / nGridsPerSecond) );
	}

	CString strNbrMS;
	AfxFormatString1( strNbrMS, IDS_NBR_MS_PER_GRID_TEXT, strNbr );

	m_staticNbrMS.SetWindowText( strNbrMS );
}


BEGIN_MESSAGE_MAP(CGridsPerSecondDlg, CDialog)
	//{{AFX_MSG_MAP(CGridsPerSecondDlg)
	ON_EN_KILLFOCUS(IDC_EDIT_NBR_GRIDS, OnKillFocusEditNbrGrids)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_NBR_GRIDS, OnDeltaPosSpinNbrGrids)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::OnInitDialog

BOOL CGridsPerSecondDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::OnInitDialog();
	
	// Limit the number of grids
	m_spinNbrGrids.SetRange( MIN_NBR_GRIDS_PER_SECOND, MAX_NBR_GRIDS_PER_SECOND );
	m_editNbrGrids.LimitText( 3 );

	// Set number of grids
	ASSERT( m_nSnapToRefTime_GridsPerSecond != 0 );
	m_spinNbrGrids.SetPos( m_nSnapToRefTime_GridsPerSecond );
	SetNbrMsPerGridText();

	// Set radio buttons
	m_radioActivePart.SetCheck( 1 );
	m_radioAllParts.SetCheck( 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::OnKillFocusEditNbrGrids

void CGridsPerSecondDlg::OnKillFocusEditNbrGrids( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewNbrGrids;

	m_editNbrGrids.GetWindowText( strNewNbrGrids );

	// Strip leading and trailing spaces
	strNewNbrGrids.TrimRight();
	strNewNbrGrids.TrimLeft();

	if( strNewNbrGrids.IsEmpty() )
	{
		m_spinNbrGrids.SetPos( m_nSnapToRefTime_GridsPerSecond );
	}
	else
	{
		short nNewNbrGrids = (short)_ttoi( strNewNbrGrids );

		// Check bounds
		if( nNewNbrGrids > MAX_NBR_GRIDS_PER_SECOND 
		||  nNewNbrGrids < MIN_NBR_GRIDS_PER_SECOND )
		{
			AfxMessageBox( IDS_ERR_NBR_GRIDS_PER_SECOND );
			m_spinNbrGrids.SetPos( m_nSnapToRefTime_GridsPerSecond );
			m_editNbrGrids.SetFocus();
			m_editNbrGrids.SetSel( 0, -1 );
		}
		else
		{
			m_spinNbrGrids.SetPos( nNewNbrGrids );
		}
	}

	SetNbrMsPerGridText();
}


/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::OnDeltaPosSpinNbrGrids

void CGridsPerSecondDlg::OnDeltaPosSpinNbrGrids( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditNbrGrids();

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Get the valid range
		int iLower, iUpper;
		m_spinNbrGrids.GetRange( iLower, iUpper );

		// Get current posiion
		int iPos = m_spinNbrGrids.GetPos();

		// Check ranges
		iPos += ((NM_UPDOWN* )pNMHDR)->iDelta;
		if( iPos > iUpper )
		{
			iPos = iUpper;
		}
		if( iPos < iLower )
		{
			iPos = iLower;
		}

		m_spinNbrGrids.SetPos( iPos );
	}

	SetNbrMsPerGridText();

	// Set the result to 1 to show that we handled this message
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::OnOK

void CGridsPerSecondDlg::OnOK( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(	m_radioAllParts.GetCheck() )
	{
		m_fAllParts = TRUE;
	}

	m_nSnapToRefTime_GridsPerSecond = (short)m_spinNbrGrids.GetPos();
	ASSERT( m_nSnapToRefTime_GridsPerSecond >= MIN_NBR_GRIDS_PER_SECOND );
	ASSERT( m_nSnapToRefTime_GridsPerSecond <= MAX_NBR_GRIDS_PER_SECOND );

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\LayerScrollBar.cpp ===
// LayerScrollBar.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "WaveStripMgr.h"
#include "TrackMgr.h"
#include "LayerScrollBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLayerScrollBar

CLayerScrollBar::CLayerScrollBar()
{
	m_pWaveStrip = NULL;
}

CLayerScrollBar::~CLayerScrollBar()
{
	m_pWaveStrip = NULL;
	DestroyWindow();
}



/////////////////////////////////////////////////////////////////////////////
// CLayerScrollBar::SetWaveStrip

void CLayerScrollBar::SetWaveStrip( CWaveStrip* pWaveStrip )
{
	ASSERT( pWaveStrip != NULL );
	m_pWaveStrip = pWaveStrip;
}


BEGIN_MESSAGE_MAP(CLayerScrollBar, CScrollBar)
	//{{AFX_MSG_MAP(CLayerScrollBar)
	ON_WM_VSCROLL()
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLayerScrollBar message handlers

/////////////////////////////////////////////////////////////////////////////
// CLayerScrollBar::OnVScroll

void CLayerScrollBar::OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pScrollBar != this )
	{
		return;
	}
	
	if( m_pWaveStrip )
	{
		m_pWaveStrip->OnVScrollFromScrollbar( nSBCode, nPos );
	}
}

void CLayerScrollBar::OnTimer(UINT nIDEvent) 
{
	if( m_pWaveStrip )
	{
		m_pWaveStrip->OnVariationTimer();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\LayerScrollBar.h ===
#if !defined(AFX_LAYERSCROLLBAR_H__2D72BA9D_7BDD_11D1_885E_00C04FBF8D15__INCLUDED_)
#define AFX_LAYERSCROLLBAR_H__2D72BA9D_7BDD_11D1_885E_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// LayerScrollBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLayerScrollBar window

class CLayerScrollBar : public CScrollBar
{
// Construction
public:
	CLayerScrollBar();
	virtual ~CLayerScrollBar();

// Attributes
private:
	class CWaveStrip* m_pWaveStrip;

// Operations
public:
	void SetWaveStrip( class CWaveStrip* pWaveStrip );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLayerScrollBar)
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CLayerScrollBar)
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LAYERSCROLLBAR_H__2D72BA9D_7BDD_11D1_885E_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\NewPartDlg.cpp ===
// NewPartDlg.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "NewPartDlg.h"
#include <SegmentDesigner.h>
#include "Timeline.h"
#include <dmusici.h>
#include "TrackMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg dialog


CNewPartDlg::CNewPartDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewPartDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewPartDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_lPChannel = 0;
	m_pTrackMgr = NULL;
}

// Set the track number
void CNewPartDlg::SetTrack( int nTrack )
{
	m_lPChannel = nTrack;
}

// Set m_pTrackMgr
void CNewPartDlg::SetTrackMgr( CTrackMgr *pTrackMgr )
{
	ASSERT( pTrackMgr != NULL );
	if ( pTrackMgr == NULL )
	{
		return;
	}
	m_pTrackMgr = pTrackMgr;
}

void CNewPartDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewPartDlg)
	DDX_Control(pDX, IDC_PCHANNEL_STATUS, m_staticStatus);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_NEWPART_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDC_NEWPART_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHNAME, m_editPChannelName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewPartDlg, CDialog)
	//{{AFX_MSG_MAP(CNewPartDlg)
	ON_EN_CHANGE(IDC_NEWPART_EDIT_PCHANNEL, OnChangeNewpartEditPChannel)
	ON_EN_KILLFOCUS(IDC_NEWPART_EDIT_PCHANNEL, OnKillfocusNewpartEditPChannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg message handlers

BOOL CNewPartDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDialog::OnInitDialog();

	// Make sure the TrackMgr pointer is valid
	ASSERT( m_pTrackMgr );
	if( m_pTrackMgr == NULL )
	{
		return TRUE;
	}

	m_lPChannel = m_pTrackMgr->GetGreatestUsedPChannel() + 1;

	m_spinPChannel.SetRange(1, MAX_PCHANNEL);
	m_spinPChannel.SetPos( m_lPChannel + 1 );

	m_editPChannel.LimitText(3);	// Length of '999'

	m_strEmptyPChannel.LoadString( IDS_EMPTY_PCHANNEL );
	m_strUsedPChannel.LoadString( IDS_USED_PCHANNEL );
	m_strInvalidPChannel.LoadString( IDS_INVALID_PCHANNEL );

	UpdatePChannelName();

	m_btnOK.EnableWindow( TRUE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewPartDlg::OnChangeNewpartEditPChannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinPChannel.GetSafeHwnd() != NULL)
	{
		CString cstrTmp;
		m_editPChannel.GetWindowText( cstrTmp );

		// Strip leading and trailing spaces
		cstrTmp.TrimRight();
		cstrTmp.TrimLeft();

		// Exit if empty
		if ( cstrTmp.IsEmpty() )
		{
			m_staticStatus.SetWindowText(m_strInvalidPChannel);
			m_editPChannelName.SetWindowText("--------");
			m_btnOK.EnableWindow( FALSE );
			return;
		}

		BOOL fTransSucceeded;
		int nPChannel = GetDlgItemInt( IDC_NEWPART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
		if ( !fTransSucceeded || (nPChannel < 1) || (nPChannel > MAX_PCHANNEL) )
		{
			m_staticStatus.SetWindowText(m_strInvalidPChannel);
			m_editPChannelName.SetWindowText("--------");
			m_btnOK.EnableWindow( FALSE );
		}
		else
		{
			m_lPChannel = nPChannel - 1;

			UpdatePChannelName();
			m_btnOK.EnableWindow( TRUE );
		}
	}
}

void CNewPartDlg::OnKillfocusNewpartEditPChannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString cstrTmp;
		m_editPChannel.GetWindowText( cstrTmp );

		// Strip leading and trailing spaces
		cstrTmp.TrimRight();
		cstrTmp.TrimLeft();

		if ( cstrTmp.IsEmpty() )
		{
			m_spinPChannel.SetPos( m_lPChannel + 1 );
			UpdatePChannelName();
			m_btnOK.EnableWindow( TRUE );
			return;
		}

		BOOL fTransSucceeded;
		int nPChannel = GetDlgItemInt( IDC_NEWPART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
		if ( !fTransSucceeded || (nPChannel < 1) )
		{
			m_lPChannel = 0;
			m_spinPChannel.SetPos( 1 );
		}
		else if ( nPChannel > MAX_PCHANNEL )
		{
			m_lPChannel = MAX_PCHANNEL - 1;
			m_spinPChannel.SetPos( MAX_PCHANNEL );
		}
		else
		{
			// m_lPChannel should have been set by OnChangeNewpartEditPchannel()
			ASSERT(m_lPChannel == nPChannel - 1 );
		}

		UpdatePChannelName();

		m_btnOK.EnableWindow( TRUE );
	}
}

void CNewPartDlg::UpdatePChannelName( void )
{
	ASSERT( m_pTrackMgr != NULL );

	if( m_pTrackMgr->StripExists( m_lPChannel ) )
	{
		m_staticStatus.SetWindowText( m_strUsedPChannel );
	}
	else
	{
		m_staticStatus.SetWindowText( m_strEmptyPChannel );
	}

	// Fill the PChannel name edit box with the PChannel's name
	if( m_pTrackMgr )
	{
		CString strPChannelName;

		if( SUCCEEDED( m_pTrackMgr->GetPChannelName( m_lPChannel, strPChannelName ) ) )
		{
			m_editPChannelName.SetWindowText( strPChannelName );
		}
	}
}

void CNewPartDlg::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return;
	}

	// Convert the m_lPChannel to a DWORD
	DWORD dwPChannel;
	if( m_lPChannel >= 0 )
	{
		dwPChannel = m_lPChannel;
	}
	else
	{
		ASSERT( 0 );	// Should not happen
		dwPChannel = 0;
	}

	// Create the Part
	if( SUCCEEDED ( m_pTrackMgr->AddPart( dwPChannel ) ) )
	{
		// Update the UI to the next PChannel
		if( m_lPChannel >= 0 )
		{
			m_lPChannel = min( (m_lPChannel + 1), (MAX_PCHANNEL - 1) );
		}
		else
		{
			m_lPChannel = 0;
		}

		m_spinPChannel.SetPos( m_lPChannel + 1 );
		UpdatePChannelName();
	}
}


// Custom edit control that only accepts numbers, editing keys, 's' and 'p'
IMPLEMENT_DYNCREATE( CNewPartEdit, CEdit )

CNewPartEdit::CNewPartEdit() : CEdit()
{
}

LRESULT CNewPartEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8: // Backspace
		case 's':
		case 'S':
		case 'e':
		case 'E':
		case 'g':
		case 'G':
		case 'p':
		case 'P':
		case 'r':
		case 'R':
		case 'f':
		case 'F':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\GroupBitsPPG.cpp ===
// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "GroupBitsPPG.h"
#include "TabWaveTrack.h"
#include "TabWavePart.h"
#include "SegmentIO.h"
#include "TrackFlagsPPG.h"
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// {D5A4FD39-5753-45d1-953E-E6E01A717957}
static const GUID GUID_WaveStripPPGMgr = 
{ 0xd5a4fd39, 0x5753, 0x45d1, { 0x95, 0x3e, 0xe6, 0xe0, 0x1a, 0x71, 0x79, 0x57 } };

short CGroupBitsPropPageMgr::sm_nActiveTab = 3;
short* CGroupBitsPPG::sm_pnActiveTab = NULL;


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr property page

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr()
{
	// Must use other constructor!!!
	ASSERT( 0 );
}

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store Framework pointer
	ASSERT( pIFramework != NULL ); 
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	ASSERT( pTrackMgr != NULL ); 
	m_pTrackMgr = pTrackMgr;

	// Store GUID
	m_GUIDManager = GUID_WaveStripPPGMgr;

	// Initialize our pointers to NULL
	m_pTabGroupBits = NULL;
	m_pTrackFlagsPPG = NULL;
	m_pTabWaveTrack = NULL;
	m_pTabWavePart = NULL;

	CStaticPropPageManager::CStaticPropPageManager();
}

CGroupBitsPropPageMgr::~CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabGroupBits )
	{
		delete m_pTabGroupBits;
		m_pTabGroupBits = NULL;
	}

	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}

	if( m_pTabWaveTrack )
	{
		delete m_pTabWaveTrack;
		m_pTabWaveTrack = NULL;
	}

	if( m_pTabWavePart )
	{
		delete m_pTabWavePart;
		m_pTabWavePart = NULL;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	CStaticPropPageManager::~CStaticPropPageManager();
}


HRESULT CGroupBitsPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr::GetPropertySheetTitle

HRESULT CGroupBitsPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr::GetPropertySheetPages

HRESULT CGroupBitsPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add group bits tab
	if( m_pTabGroupBits == NULL )
	{
		m_pTabGroupBits = new CGroupBitsPPG();
	}
	if( m_pTabGroupBits )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabGroupBits->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTabGroupBits->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add wave track tab
	if( m_pTabWaveTrack == NULL )
	{
		m_pTabWaveTrack = new CTabWaveTrack();
	}
	if( m_pTabWaveTrack )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabWaveTrack->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTabWaveTrack->m_pIPropSheet = m_pIPropSheet;

		// Point the property page back to this property page manager
		m_pTabWaveTrack->m_pPropPageMgr = this;
	}

	// Add wave part tab
	if( m_pTabWavePart == NULL )
	{
		m_pTabWavePart = new CTabWavePart();
	}
	if( m_pTabWavePart )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabWavePart->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTabWavePart->m_pIPropSheet = m_pIPropSheet;

		// Point the property page back to this property page manager
		m_pTabWavePart->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr::RefreshData

HRESULT CGroupBitsPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabGroupBits )
	{
		m_pTabGroupBits->RefreshData();
	}

	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}

	if( m_pTabWaveTrack )
	{
		m_pTabWaveTrack->RefreshData();
	}

	if( m_pTabWavePart )
	{
		m_pTabWavePart->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr::SetObject

HRESULT CGroupBitsPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabGroupBits )
	{
		m_pTabGroupBits->SetObject( pINewPropPageObject );
	}

	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}

	if( m_pTabWaveTrack )
	{
		m_pTabWaveTrack->SetObject( pINewPropPageObject );
	}

	if( m_pTabWavePart )
	{
		m_pTabWavePart->SetObject( pINewPropPageObject );
	}

	return CStaticPropPageManager::SetObject( pINewPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT

	m_pPPO = NULL;
	m_pIPropSheet = NULL;

	m_PPGTrackParams.dwPageIndex = 0;
	m_PPGTrackParams.dwGroupBits = 0;
	
	m_fNeedToDetach = FALSE;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	DDX_Control(pDX, IDC_COMBO_GROUP_LIST, m_GroupDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_GROUP_LIST, OnSelchangeComboGroupList)
	ON_MESSAGE( WM_APP, OnApp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable )
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( ::IsWindow(m_GroupDropDownList.m_hWnd))
	{
		m_GroupDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CGroupBitsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioGroupBitsPPG* pioGroupBitsPPG = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioGroupBitsPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Group Bits combo box
	if (!m_PPGTrackParams.dwGroupBits)
	{
		m_PPGTrackParams.dwGroupBits = 1;
	}
	for (int iIndex = 0; iIndex < 32; iIndex++)
	{
		if (m_PPGTrackParams.dwGroupBits & (1 << iIndex) )
			break;
	}
	m_GroupDropDownList.SetCurSel(iIndex);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CGroupBitsPPG::OnSelchangeComboGroupList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PostMessage( WM_APP, 0, 0 );
}

LRESULT CGroupBitsPPG::OnApp(WPARAM, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Custom handler for OnSelChanged to work-around bug in user32.dll
	int iIndex = m_GroupDropDownList.GetCurSel();

	if (iIndex >= 0 && iIndex < 32)
	{
		m_PPGTrackParams.dwGroupBits = (1 << iIndex);
	}
	else
	{
		ASSERT(FALSE);
		return 0;
	}

	UpdatePPO();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\PropPageMgr_Item.h ===
// PropPageMgr_Item.h : Handles the property pages for a track item

#ifndef __PROPPAGEMGR_ITEM_H_
#define __PROPPAGEMGR_ITEM_H_

#include <staticproppagemanager.h>

#define TAB_FILEREF		1
#define TAB_LOOP		2
#define TAB_PERFORMANCE	3
#define TAB_VARIATIONS	4

class CTabFileRef;
class CTabLoop;
class CTabPerformance;
class CTabVariations;

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem

class CPropPageMgrItem : public CStaticPropPageManager
{
	friend CTabFileRef;
	friend CTabLoop;
	friend CTabPerformance;
	friend CTabVariations;

public:
	CPropPageMgrItem( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	~CPropPageMgrItem();

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	IDMUSProdFramework*	m_pIFramework;
	CTrackMgr*			m_pTrackMgr;

	CTabFileRef*		m_pTabFileRef;
	CTabLoop*			m_pTabLoop;
	CTabPerformance*	m_pTabPerformance;
	CTabVariations*		m_pTabVariations;

public:
	static short		sm_nActiveTab;
};

#endif // __PROPPAGEMGR_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "timeline.h"
#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\NewPartDlg.h ===
#if !defined(AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_)
#define AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewPartDlg.h : header file
//

#include "resource.h"

// Also defined in TabWaveTrack.h
#define MIN_PCHANNEL	1
#define MAX_PCHANNEL	999

class CTrackMgr;

class CNewPartEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CNewPartEdit)
public:
	CNewPartEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg dialog

class CNewPartDlg : public CDialog
{
// Construction
public:
	CNewPartDlg(CWnd* pParent = NULL);   // standard constructor

	void	SetTrack( int nTrack ); // Set the initial track number
	void	SetTrackMgr( CTrackMgr *pTrackMgr );

// Dialog Data
	//{{AFX_DATA(CNewPartDlg)
	enum { IDD = IDD_NEW_PART };
	CStatic	m_staticStatus;
	CButton	m_btnOK;
	CNewPartEdit	m_editPChannel;
	CSpinButtonCtrl	m_spinPChannel;
	CEdit	m_editPChannelName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewPartDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewPartDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewpartEditPChannel();
	afx_msg void OnKillfocusNewpartEditPChannel();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	long			m_lPChannel;
	CTrackMgr*		m_pTrackMgr;
	CString			m_strEmptyPChannel;
	CString			m_strUsedPChannel;
	CString			m_strInvalidPChannel;

	void UpdatePChannelName( void );
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\GroupBitsPPG.h ===
#if !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "resource.h"

interface IDMUSProdPChannelName;

class CGroupBitsPPG;
class CTabWaveTrack;
class CTabWavePart;
class CTrackMgr;


struct ioGroupBitsPPG
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
};

// Definitions copied from the "shared" groupbitsPPG
// These definitions are not actually used in the implementation,
// they're just here to make basestrip.cpp compile
#define GROUPBITSPPG_INDEX 0

#define GROUPBITSPPG_GROUPBITS_RO 0x1

typedef struct _PPGTrackParams
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
	DWORD	dwPropPageFlags;
} PPGTrackParams;
// End included definitions

// GroupBitsPPG.h : header file
//

#define ALLEXTRAS_FLAGS (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | \
	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_COMPOSE | \
	DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | \
	DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr

class CGroupBitsPropPageMgr : CStaticPropPageManager
{
friend class CGroupBitsPPG;
friend class CTabWaveTrack;
friend class CTabWavePart;

public:
	CGroupBitsPropPageMgr();
	CGroupBitsPropPageMgr( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	~CGroupBitsPropPageMgr();

	// IUnknown functions
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	IDMUSProdFramework*	m_pIFramework;
	CTrackMgr*			m_pTrackMgr;

	CGroupBitsPPG*		m_pTabGroupBits;
	CTabWaveTrack*		m_pTabWaveTrack;
	CTabWavePart*		m_pTabWavePart;
	class CTrackFlagsPPG*	m_pTrackFlagsPPG;

public:
	static short		sm_nActiveTab;
};


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG 

class CGroupBitsPPG : public CPropertyPage
{
friend class CGroupBitsPropPageMgr;

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_WAVE_GROUP };
	CComboBox	m_GroupDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboGroupList();
	afx_msg LRESULT OnApp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioGroupBitsPPG				m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\PropTrackItem.cpp ===
#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "PropTrackItem.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CPropTrackItem Constructors/Destructor

CPropTrackItem::CPropTrackItem( void )
{
	m_nPropertyTab = -1;

	Clear();
}

CPropTrackItem::~CPropTrackItem( void )
{
}


//////////////////////////////////////////////////////////////////////
//	CPropTrackItem::Clear

void CPropTrackItem::Clear()
{
	// Don't touch m_nPropertyTab field

	m_dwChanged = 0;
	m_dwBits = 0;

	m_dwUndetermined_TabFileRef = 0;
	m_dwUndetermined_TabLoop = 0;
	m_dwUndetermined_TabPerformance = 0;
	m_dwUndetermined_TabVariations = 0;

	m_dwChangedVar_TabVariations = 0;

	m_Item.Clear();
	m_Item.SetWaveStripForPropSheet( NULL );
	m_Item.SetTrackMgr( NULL );
}


//////////////////////////////////////////////////////////////////////
//	CPropTrackItem::Copy

void CPropTrackItem::Copy( const CPropTrackItem* pPropItem )
{
	if( pPropItem == NULL )
	{
		ASSERT( 0 );
		return;
	}

	if( pPropItem == this )
	{
		return;
	}

	m_nPropertyTab = pPropItem->m_nPropertyTab;
	m_dwChanged = pPropItem->m_dwChanged;
	m_dwBits = pPropItem->m_dwBits;

	m_dwUndetermined_TabFileRef = pPropItem->m_dwUndetermined_TabFileRef;
	m_dwUndetermined_TabLoop = pPropItem->m_dwUndetermined_TabLoop;
	m_dwUndetermined_TabPerformance = pPropItem->m_dwUndetermined_TabPerformance;
	m_dwUndetermined_TabVariations = pPropItem->m_dwUndetermined_TabVariations;

	m_dwChangedVar_TabVariations = pPropItem->m_dwChangedVar_TabVariations;

	m_Item.Copy( &pPropItem->m_Item );
	m_Item.SetWaveStripForPropSheet( pPropItem->m_Item.GetWaveStripForPropSheet() );
}


//////////////////////////////////////////////////////////////////////
//	CPropTrackItem::CopyTrackItem

void CPropTrackItem::CopyTrackItem( const CTrackItem* pItem )
{
	if( pItem == NULL )
	{
		ASSERT( 0 );
		return;
	}

	m_Item.Copy( pItem );
	m_Item.SetWaveStripForPropSheet( pItem->GetWaveStripForPropSheet() );
}


//////////////////////////////////////////////////////////////////////
//	CPropTrackItem::MergeTrackItem

void CPropTrackItem::MergeTrackItem( const CTrackItem* pItem )
{
	if( pItem == NULL )
	{
		ASSERT( 0 );
		return;
	}

	// TabFileRef
	if( m_Item.m_FileRef.pIDocRootNode != pItem->m_FileRef.pIDocRootNode )
	{
		m_dwUndetermined_TabFileRef |= UNDT_DOCROOT;
	}
	if( m_Item.m_rtTimePhysical != pItem->m_rtTimePhysical )
	{
		m_dwUndetermined_TabFileRef |= UNDT_TIME_PHYSICAL;
	}
	if( m_Item.m_rtStartOffset != pItem->m_rtStartOffset )
	{
		m_dwUndetermined_TabFileRef |= UNDT_START_OFFSET;
	}
	if( m_Item.m_rtDuration != pItem->m_rtDuration )
	{
		m_dwUndetermined_TabFileRef |= UNDT_DURATION;
	}
	if( m_Item.m_fLockEndUI != pItem->m_fLockEndUI )
	{
		m_dwUndetermined_TabFileRef |= UNDT_LOCK_END;
	}
	if( m_Item.m_fLockLengthUI != pItem->m_fLockLengthUI )
	{
		m_dwUndetermined_TabFileRef |= UNDT_LOCK_LENGTH;
	}

	// TabLoop
	if( m_Item.m_fLoopedUI != pItem->m_fLoopedUI )
	{
		m_dwUndetermined_TabLoop |= UNDT_IS_LOOPED;
	}
	if( m_Item.m_dwLoopStartUI != pItem->m_dwLoopStartUI )
	{
		m_dwUndetermined_TabLoop |= UNDT_LOOP_START;
	}
	if( m_Item.m_dwLoopEndUI != pItem->m_dwLoopEndUI )
	{
		m_dwUndetermined_TabLoop |= UNDT_LOOP_END;
	}
	if( m_Item.m_fLockLoopLengthUI != pItem->m_fLockLoopLengthUI )
	{
		m_dwUndetermined_TabLoop |= UNDT_LOOP_LOCK_LENGTH;
	}

	// TabPerformance
	if( m_Item.m_rtTimeLogical != pItem->m_rtTimeLogical )
	{
		m_dwUndetermined_TabPerformance |= UNDT_TIME_LOGICAL;
	}
	if( (m_Item.m_dwFlagsDM & DMUS_WAVEF_NOINVALIDATE) != (pItem->m_dwFlagsDM & DMUS_WAVEF_NOINVALIDATE) )
	{
		m_dwUndetermined_TabPerformance |= UNDT_WAVEF_NOINVALIDATE ;
	}
	if( (m_Item.m_dwFlagsDM & DMUS_WAVEF_IGNORELOOPS) != (pItem->m_dwFlagsDM & DMUS_WAVEF_IGNORELOOPS) )
	{
		m_dwUndetermined_TabPerformance |= UNDT_WAVEF_IGNORELOOPS;
	}
	if( m_Item.m_lVolume != pItem->m_lVolume )
	{
		m_dwUndetermined_TabPerformance |= UNDT_VOLUME;
	}
	if( m_Item.m_lPitch != pItem->m_lPitch )
	{
		m_dwUndetermined_TabPerformance |= UNDT_PITCH;
	}

	// TabVariations
	for( int i = 0  ;  i < 32 ;  i++ )
	{
		if( (m_Item.m_dwVariations & (1 << i)) != (pItem->m_dwVariations & (1 << i)) )
		{
			m_dwUndetermined_TabVariations |= (1 << i);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WaveStripMgrDLL.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_FILEREF            101
#define IDR_WAVEMGR                     102
#define IDR_TRACKMGR                    103
#define IDS_DELETE                      104
#define IDS_PASTE                       105
#define IDS_INSERT                      106
#define IDD_PROPPAGE_WAVE_FILEREF_ORIG  107
#define IDS_TRACK_NAME                  108
#define IDS_PROPPAGE_GROUP_BITS         109
#define IDS_MULTIPLE_SELECT             110
#define IDS_UNDO_CHANGE                 111
#define IDS_UNDO_MOVE                   112
#define IDS_UNDO_TRACK_GROUP            113
#define IDS_STRIP_NAME                  114
#define IDS_DEFAULT_WAVE_TEXT           115
#define IDS_UNDO_DURATION               115
#define IDS_EMPTY_TEXT                  116
#define IDS_UNDO_TRACKEXTRAS            117
#define IDS_UNDO_PRODUCERONLY           118
#define IDS_FILE_OPEN_WAVE              119
#define IDS_FILE_OPEN_ANY_WAVE          120
#define IDS_UNDO_DELETE_WAVE            121
#define IDS_UNDO_REPLACE_WAVE           122
#define IDS_UNDO_CHANGE_WAVE_LINK       123
#define IDS_UNDO_CHANGE_WAVE_NAME       124
#define IDS_UNDO_FLAGS                  125
#define IDS_NONE_TEXT                   126
#define IDS_UNDO_START_OFFSET           127
#define IDS_WAVE_STATUS_TEXT            128
#define IDS_WAVE_NEG_STATUS_TEXT        129
#define IDS_EMPTY_PCHANNEL              132
#define IDS_USED_PCHANNEL               133
#define IDS_INVALID_PCHANNEL            134
#define IDS_UNDO_ADD_PART               135
#define IDS_UNDO_PART_PCHANNEL          136
#define IDS_UNDO_PART_VOLUME            137
#define IDS_UNDO_PART_LOCK_TO_PART      139
#define IDS_UNDO_PART_FLAGS             140
#define IDS_UNDO_PART_NAME              141
#define IDS_UNDO_DELETE_PART            142
#define IDS_UNDO_TRACK_FLAGS            143
#define IDS_UNDO_TRACK_VOLUME           144
#define IDS_UNDO_VARIATIONS             145
#define IDS_UNDO_STRIP_MINIMIZED        146
#define IDS_UNDO_STRIP_MAXIMIZED        147
#define IDS_UNDO_STRIP_RESIZE           148
#define IDS_FONT_NAME                   149
#define IDS_VARMODE_RANDOM              150
#define IDS_VARMODE_SEQUENTIAL          151
#define IDS_VARMODE_RANDOM_START        152
#define IDS_VARMODE_NO_REPEAT           153
#define IDS_VARMODE_RANDOM_ROW          154
#define IDS_CREATE_TEXT                 160
#define IDS_UNDO_ENABLE_VARCHOICES      161
#define IDS_UNDO_DISABLE_VARCHOICES     162
#define IDS_UNDO_SET_VARIATIONS         163
#define IDS_ERROR_VAR_MISMATCH          164
#define IDS_UNDO_VOLUME                 165
#define IDS_UNDO_PITCH                  166
#define IDS_DELETE_LAYER_PROMPT         167
#define IDS_UNDO_INSERT_LAYER           168
#define IDS_UNDO_DELETE_LAYERS          169
#define IDS_WAVE_FONTNAME               170
#define IDS_BEAT_TEXT                   171
#define IDS_SECOND_TEXT                 172
#define IDS_BAR_TEXT                    173
#define IDS_SET_GRID_TEXT               174
#define IDS_ERR_NBR_GRIDS_PER_SECOND    175
#define IDS_UNDO_NBR_GRIDS_PER_SECOND   176
#define IDS_ERROR_LAYER_MISMATCH        177
#define IDS_UNDO_LOOP                   178
#define IDS_BEAT_MENU_TEXT              179
#define IDS_BAR_MENU_TEXT               180
#define IDS_GRID_TEXT                   181
#define IDS_TICK_TEXT                   182
#define IDS_MIN_TEXT                    183
#define IDS_SEC_TEXT                    184
#define IDS_MS_TEXT                     185
#define IDS_UNDO_CHANGE_WAVE_DATA       186
#define IDS_UNDO_LOCK_LOOP_LENGTH       187
#define IDS_UNDO_LOCK_LENGTH            188
#define IDS_UNDO_LOCK_END               189
#define IDS_UNDO_MERGE_VARIATIONS       190
#define IDS_NBR_MS_PER_GRID_TEXT        191
#define IDS_UNDO_LOGICAL_TIME           192
#define IDS_WARNING_DELETE_PART         193
#define IDS_UNDO_PITCH_RANGE            194
#define IDS_UNDO_VOLUME_RANGE           195
#define IDD_PROPPAGE_WAVE_GROUP         200
#define IDR_EDIT_RMENU                  201
#define IDD_PROPPAGE_WAVE_PERFORMANCE   203
#define IDR_EDITMENU                    206
#define IDM_DRAG_RMENU                  207
#define IDM_VARBTNS_RMENU               208
#define IDC_COMBO_FILE                  209
#define IDM_LAYERBTNS_RMENU             209
#define IDD_NEW_PART                    210
#define IDM_SNAP_TO_MUSICTIME           210
#define IDM_SNAP_TO_CLOCKTIME           211
#define IDD_PROPPAGE_WAVE_VARIATIONS    216
#define IDC_EDIT_NAME                   226
#define IDC_EDIT_PCHANNELNAME           229
#define IDC_COMBO_GROUP_LIST            242
#define IDC_EDIT_PCHANNEL               247
#define IDC_SPIN_PCHANNEL               250
#define IDC_PCHANNEL_STATUS             283
#define IDC_PROMPT                      299
#define IDB_ZOOMOUT_UP                  300
#define IDC_SYNC                        301
#define IDB_VARBTN_UP                   302
#define IDC_PERSIST                     302
#define IDB_VARBTN_INACTIVE_DOWN        303
#define IDB_VARBTN_INACTIVE_UP          304
#define IDB_VARGUTTER_DOWN              305
#define IDC_PROMPT_BAR                  306
#define IDB_VARGUTTER_UP                307
#define IDB_ZOOMIN_DOWN                 308
#define IDB_ZOOMIN_UP                   309
#define IDB_ZOOMOUT_DOWN                310
#define IDB_VARBTN_DOWN                 311
#define IDM_ENABLE_VARBTNS              312
#define IDM_DISABLE_VARBTNS             313
#define IDC_PROMPT_BEAT                 314
#define IDC_PROMPT_GRID                 315
#define IDC_PROMPT_TICK                 316
#define IDC_CHECK_NOINVALIDATE          318
#define IDC_CHECK_IGNORE_LOOPING        319
#define IDC_STATIC_MS                   323
#define IDC_EDIT_START_BAR              324
#define IDC_SPIN_START_BAR              325
#define IDC_EDIT_START_BEAT             326
#define IDC_SPIN_START_BEAT             327
#define IDC_EDIT_START_GRID             328
#define IDC_SPIN_START_GRID             329
#define IDC_EDIT_START_TICK             330
#define IDC_SPIN_START_TICK             331
#define IDC_EDIT_END_BAR                332
#define IDC_SPIN_END_BAR                333
#define IDC_EDIT_END_BEAT               334
#define IDC_SPIN_END_BEAT               335
#define IDC_EDIT_END_GRID               336
#define IDC_SPIN_END_GRID               337
#define IDC_EDIT_END_TICK               338
#define IDC_SPIN_END_TICK               339
#define IDC_STATIC_SOURCE_END_BAR       340
#define IDC_STATIC_SOURCE_END_BEAT      341
#define IDC_STATIC_SOURCE_END_GRID      342
#define IDC_STATIC_SOURCE_END_TICK      343
#define IDC_EDIT_LENGTH_BAR             344
#define IDC_SPIN_LENGTH_BAR             345
#define IDC_EDIT_LENGTH_BEAT            346
#define IDC_SPIN_LENGTH_BEAT            347
#define IDC_EDIT_LENGTH_GRID            348
#define IDC_SPIN_LENGTH_GRID            349
#define IDC_EDIT_LENGTH_TICK            350
#define IDC_SPIN_LENGTH_TICK            351
#define IDC_EDIT_LENGTH_NBR_SAMPLES     352
#define IDC_SPIN_LENGTH_NBR_SAMPLES     353
#define IDC_STATIC_SOURCE_LENGTH_BAR    354
#define IDC_STATIC_SOURCE_LENGTH_BEAT   355
#define IDC_STATIC_SOURCE_LENGTH_GRID   356
#define IDC_STATIC_SOURCE_LENGTH_TICK   357
#define IDC_STATIC_SOURCE_LENGTH_NBR_SAMPLES 358
#define IDC_EDIT_OFFSET_BAR             359
#define IDC_STATIC_SOURCE_START_BAR     359
#define IDC_SPIN_OFFSET_BAR             360
#define IDC_STATIC_SOURCE_START_BEAT    360
#define IDC_EDIT_OFFSET_BEAT            361
#define IDC_STATIC_SOURCE_START_GRID    361
#define IDC_SPIN_OFFSET_BEAT            362
#define IDC_STATIC_SOURCE_START_TICK    362
#define IDC_EDIT_OFFSET_GRID            363
#define IDC_EDIT_START_SAMPLE           363
#define IDC_SPIN_OFFSET_GRID            364
#define IDC_STATIC_SOURCE_START_SAMPLE  364
#define IDC_EDIT_OFFSET_TICK            365
#define IDC_SPIN_START_SAMPLE           365
#define IDC_SPIN_OFFSET_TICK            366
#define IDC_EDIT_END_SAMPLE             366
#define IDC_EDIT_OFFSET_SAMPLES         367
#define IDC_STATIC_SOURCE_END_SAMPLE    367
#define IDC_SPIN_OFFSET_SAMPLES         368
#define IDC_SPIN_END_SAMPLE             368
#define IDC_FINE_TUNE                   369
#define IDC_DB_ATTENUATION              370
#define IDC_SEMI_TONES                  371
#define IDC_LOCK_END                    372
#define IDC_DB_ATTENUATION_RANGE        372
#define IDC_LOCK_LENGTH                 373
#define IDC_FINE_TUNE_RANGE             373
#define IDC_WAVE_NAME                   374
#define IDC_SEMI_TONES_RANGE            374
#define IDC_STATIC_SEMI_TONES           375
#define IDC_COMBO_VAR_LOCK              376
#define IDC_STATIC_SEMI_TONES_RANGE     376
#define IDC_STATIC_FINE_TUNE            377
#define IDC_NEWPART_EDIT_PCHANNEL       378
#define IDC_STATIC_FINE_TUNE_RANGE      378
#define IDC_NEWPART_SPIN_PCHANNEL       379
#define IDC_EDIT_PCHNAME                384
#define IDC_COMBO_VAR_MODE              385
#define IDM_SNAP_SET_GRID               398
#define IDM_SNAP_TO                     399
#define IDM_SNAP_NONE                   400
#define IDM_SNAP_GRID                   401
#define IDM_SNAP_BEAT                   402
#define IDM_SNAP_BAR                    403
#define IDM_SNAP_SECOND                 404
#define IDC_CHECK_VAR1                  410
#define IDC_CHECK_VAR2                  411
#define IDC_CHECK_VAR3                  412
#define IDC_CHECK_VAR4                  413
#define IDC_CHECK_VAR5                  414
#define IDC_CHECK_VAR6                  415
#define IDC_CHECK_VAR7                  416
#define IDC_CHECK_VAR8                  417
#define IDC_CHECK_VAR9                  418
#define IDC_CHECK_VAR10                 419
#define IDC_CHECK_VAR11                 420
#define IDC_CHECK_VAR12                 421
#define IDC_CHECK_VAR13                 422
#define IDC_CHECK_VAR14                 423
#define IDC_CHECK_VAR15                 424
#define IDC_CHECK_VAR16                 425
#define IDC_CHECK_VAR17                 426
#define IDC_CHECK_VAR18                 427
#define IDC_CHECK_VAR19                 428
#define IDC_CHECK_VAR20                 429
#define IDC_CHECK_VAR21                 430
#define IDC_CHECK_VAR22                 431
#define IDC_CHECK_VAR23                 432
#define IDC_CHECK_VAR24                 433
#define IDC_CHECK_VAR25                 434
#define IDC_CHECK_VAR26                 435
#define IDC_CHECK_VAR27                 436
#define IDC_CHECK_VAR28                 437
#define IDC_CHECK_VAR29                 438
#define IDC_CHECK_VAR30                 439
#define IDC_CHECK_VAR31                 440
#define IDC_CHECK_VAR32                 441
#define IDD_PROPPAGE_PART               450
#define IDD_PROPPAGE_TRACK              451
#define IDD_PROPPAGE_WAVE_FILEREF       452
#define IDD_PROPPAGE_WAVE_PERFORMANCE_ORIG 453
#define IDD_PROPPAGE_WAVE_LOOP          454
#define IDD_PROPPAGE_WAVE_LOOP1         455
#define IDD_GRIDS_PER_SECOND            456
#define IDB_LOCKED                      460
#define IDB_UNLOCKED                    461
#define IDC_EDIT_NBR_GRIDS              550
#define IDC_SPIN_NBR_GRIDS              551
#define IDC_RADIO_ACTIVE_PART           553
#define IDC_RADIO_ALL_PARTS             554
#define IDC_CHECK_LOOP                  555
#define IDC_STATIC_LENGTH_NBR_SAMPLES   560
#define IDC_STATIC_OFFSET_NBR_SAMPLES   561
#define IDC_NBR_MS                      562
#define IDC_EDIT_BELONGS_BAR            563
#define IDC_EDIT_BELONGS_BEAT           564
#define IDC_SPIN_BELONGS_BAR            565
#define IDC_SPIN_BELONGS_BEAT           566
#define IDC_ATTENUATION_RANGE_NAME      567
#define IDC_DB_ATTENUATION_RANGE_NAME   568
#define IDC_LAYER_SCROLLBAR             660
#define IDC_DB_ATTENUATION_SPIN         661
#define IDC_SEMI_TONES_SPIN             662
#define IDC_SEMI_TONES_SPIN_RANGE       663
#define IDC_DB_ATTENUATION_SPIN_RANGE   664
#define IDC_ATTENUATION                 1018
#define IDC_ATTENUATION_RANGE           1019
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_PASTE_OVERWRITE         32778
#define IDM_ADD_PART                    32779
#define IDM_DELETE_PART                 32780
#define IDM_ZOOM_IN                     32781
#define IDM_ZOOM_OUT                    32782
#define IDM_INSERT_LAYER                32783
#define IDM_DELETE_LAYERS               32784
#define IDM_MERGE_VARIATIONS            32786
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        462
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         569
#define _APS_NEXT_SYMED_VALUE           665
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\PropTrackItem.h ===
#ifndef __WAVE_PROPTRACKITEM_H_
#define __WAVE_PROPTRACKITEM_H_

// XBOX only, in lieue of appearing in dmusici.h for now..
#ifndef DMUS_WAVEF_IGNORELOOPS
#define DMUS_WAVEF_IGNORELOOPS      0x20       /* Ignore segment looping. */
#endif

/////////////////////////////////////////////////////////////////////////////
// m_dwBits
#define PROPF_MULTIPLESELECT		0x00000001


/////////////////////////////////////////////////////////////////////////////
// Flags for m_dwUndetermined_TabFileRef

#define UNDT_DOCROOT			(1 << 0)
#define UNDT_TIME_PHYSICAL		(1 << 1)
#define UNDT_START_OFFSET		(1 << 2)
#define UNDT_DURATION			(1 << 3)
#define UNDT_LOCK_END			(1 << 4)
#define UNDT_LOCK_LENGTH		(1 << 5)


/////////////////////////////////////////////////////////////////////////////
// Flags for m_dwChanged (TabFileRef)

#define CHGD_DOCROOT			(1 << 0)
#define CHGD_TIME_OR_DURATION	(1 << 1)
#define CHGD_START_OFFSET		(1 << 2)
#define CHGD_LOCK_END			(1 << 3)
#define CHGD_LOCK_LENGTH		(1 << 4)


/////////////////////////////////////////////////////////////////////////////
// Flags for m_dwUndetermined_TabLoop

#define UNDT_IS_LOOPED			(1 << 0)
#define UNDT_LOOP_START			(1 << 1)
#define UNDT_LOOP_END			(1 << 2)
#define UNDT_LOOP_LOCK_LENGTH	(1 << 3)


/////////////////////////////////////////////////////////////////////////////
// Flags for m_dwChanged (TabLoop)

#define CHGD_IS_LOOPED			(1 << 0)
#define CHGD_LOOP				(1 << 1)
#define CHGD_LOOP_LOCK_LENGTH	(1 << 2)


/////////////////////////////////////////////////////////////////////////////
// Flags for m_dwUndetermined_TabPerformance

#define UNDT_VOLUME				(1 << 0)
#define UNDT_PITCH				(1 << 1)
#define UNDT_TIME_LOGICAL		(1 << 2)
#define UNDT_WAVEF_NOINVALIDATE	(1 << 3)
#define UNDT_WAVEF_IGNORELOOPS  (1 << 4) 
#define UNDT_VOLUME_RANGE		(1 << 5)
#define UNDT_PITCH_RANGE		(1 << 6)


/////////////////////////////////////////////////////////////////////////////
// Flags for m_dwChanged (TabPerformance)

#define CHGD_VOLUME				(1 << 0)
#define CHGD_PITCH				(1 << 1)
#define CHGD_TIME_LOGICAL		(1 << 2)
#define CHGD_VOLUME_RANGE		(1 << 3)
#define CHGD_PITCH_RANGE 		(1 << 4)
#define CHGD_DM_FLAGS			(1 << 5)


/////////////////////////////////////////////////////////////////////////////
// Flags for m_dwChanged (TabLoop)
// m_dwUndetermined_TabVariations does not use this flag
// Each bit in m_dwUndetermined_TabVariations represents 1 of the 32 variations

#define CHGD_VARIATIONS			(1 << 0)


/////////////////////////////////////////////////////////////////
//	CPropTrackItem

class CPropTrackItem
{
public:
	CPropTrackItem();
	virtual ~CPropTrackItem();

	void Clear();
	void Copy( const CPropTrackItem* pPropItem );
	void CopyTrackItem( const CTrackItem* pItem );
	void MergeTrackItem( const CTrackItem* pItem );

public:
	CTrackItem		m_Item;

	short			m_nPropertyTab;	
	DWORD			m_dwChanged;	// Values are per tab

	DWORD			m_dwUndetermined_TabFileRef;
	DWORD			m_dwUndetermined_TabLoop;
	DWORD			m_dwUndetermined_TabPerformance;
	DWORD			m_dwUndetermined_TabVariations;
	DWORD			m_dwChangedVar_TabVariations;	// Bit signifies variation change on TabVariations

	DWORD			m_dwBits;
};

#endif // __WAVE_PROPTRACKITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabFileRef.h ===
#if !defined(AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

// TabFileRef.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CPropPageMgrItem;
class CPropTrackItem;
class CTabOnReturnEdit;


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef dialog

class CTabFileRef : public CPropertyPage
{
	friend CPropPageMgrItem;
	DECLARE_DYNCREATE(CTabFileRef)

// Construction
public:
	CTabFileRef();
	~CTabFileRef();

// Dialog Data
	//{{AFX_DATA(CTabFileRef)
	enum { IDD = IDD_PROPPAGE_WAVE_FILEREF };
	CButton	m_btnLockLength;
	CButton	m_btnLockEnd;
	CComboBox	m_comboFile;
	CStatic	m_staticPromptGrid;
	CStatic	m_staticPromptTick;
	CStatic	m_staticPromptBeat;
	CStatic	m_staticPromptBar;
	CEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartMeasure;
	CEdit	m_editEndTick;
	CEdit	m_editEndGrid;
	CEdit	m_editEndBeat;
	CEdit	m_editEndMeasure;
	CEdit	m_editLengthTick;
	CEdit	m_editLengthGrid;
	CEdit	m_editLengthBeat;
	CEdit	m_editLengthMeasure;
	CStatic	m_staticLengthNbrSamples;
	CEdit	m_editOffsetTick;
	CEdit	m_editOffsetGrid;
	CEdit	m_editOffsetBeat;
	CEdit	m_editOffsetMeasure;
	CStatic	m_staticOffsetNbrSamples;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartMeasure;
	CSpinButtonCtrl	m_spinEndTick;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndMeasure;
	CSpinButtonCtrl	m_spinLengthTick;
	CSpinButtonCtrl	m_spinLengthGrid;
	CSpinButtonCtrl	m_spinLengthBeat;
	CSpinButtonCtrl	m_spinLengthMeasure;
	CSpinButtonCtrl	m_spinOffsetTick;
	CSpinButtonCtrl	m_spinOffsetGrid;
	CSpinButtonCtrl	m_spinOffsetBeat;
	CSpinButtonCtrl	m_spinOffsetMeasure;
	CStatic	m_staticSourceEndTick;
	CStatic	m_staticSourceEndGrid;
	CStatic	m_staticSourceEndBeat;
	CStatic	m_staticSourceEndMeasure;
	CStatic	m_staticSourceLengthTick;
	CStatic	m_staticSourceLengthGrid;
	CStatic	m_staticSourceLengthBeat;
	CStatic	m_staticSourceLengthMeasure;
	CStatic	m_staticSourceLengthNbrSamples;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabFileRef)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTabFileRef)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSpinStartTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinOffsetTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinOffsetGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinOffsetBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinOffsetMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusStartTick();
	afx_msg void OnKillFocusStartGrid();
	afx_msg void OnKillFocusStartBeat();
	afx_msg void OnKillFocusStartMeasure();
	afx_msg void OnKillFocusEndTick();
	afx_msg void OnKillFocusEndGrid();
	afx_msg void OnKillFocusEndBeat();
	afx_msg void OnKillFocusEndMeasure();
	afx_msg void OnKillFocusLengthTick();
	afx_msg void OnKillFocusLengthGrid();
	afx_msg void OnKillFocusLengthBeat();
	afx_msg void OnKillFocusLengthMeasure();
	afx_msg void OnKillFocusOffsetTick();
	afx_msg void OnKillFocusOffsetGrid();
	afx_msg void OnKillFocusOffsetBeat();
	afx_msg void OnKillFocusOffsetMeasure();
	virtual void OnOK();
	afx_msg void OnDropDownComboFile();
	afx_msg void OnSelChangeComboFile();
	afx_msg void OnLockEnd();
	afx_msg void OnDoubleClickedLockEnd();
	afx_msg void OnLockLength();
	afx_msg void OnDoubleClickedLockLength();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetPropTrackItem( const CPropTrackItem* pPropItem );

protected:
	// File combo box methods
	void GetFileComboBoxText( const FileListInfo* pFileListInfo, CString& strText );
	void InsertFileInfoListInComboBox();
	void InsertFileInfo( FileListInfo* pFileListInfo );
	void BuildFileInfoList();
	void SetFileComboBoxSelection();

	void UpdateObject();
	void EnableControls( BOOL fEnable );
	bool HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );
	bool HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset );
	void SetEditControl( CEdit& edit, long lValue, int nOffset );
	void SetStaticControl( CStatic& stat, long lValue, int nOffset );

	void SetStart( REFERENCE_TIME rtTime );
	void SetEnd( REFERENCE_TIME rtNewEnd );
	void SetLength( REFERENCE_TIME rtNewLength );
	void SetOffset( REFERENCE_TIME rtNewOffset );

	REFERENCE_TIME StartToUnknownTime();
	REFERENCE_TIME EndToUnknownTime();
	REFERENCE_TIME LengthToUnknownTime();
	REFERENCE_TIME OffsetToRefTime();

	REFERENCE_TIME MinTimeToRefTime();
	REFERENCE_TIME MinTimeToUnknownTime();

	REFERENCE_TIME RemoveFineTune( REFERENCE_TIME rtTime );
	
	void RecomputeTimes();
	void ComputeMinSecGridMs();
	void ComputeBarBeatGridTick();
	
	void SetControlRanges();
	void SetMusicTimeRanges( DWORD dwGroupBits );
	void SetRefTimeRanges();

	CPropPageMgrItem*			m_pPropPageMgr;
	IDMUSProdWaveTimelineDraw*	m_pIWaveTimelineDraw;

	CPropTrackItem				m_PropItem;

	BOOL		m_fNeedToDetach;
	BOOL		m_fValidTrackItem;
	BOOL		m_fIgnoreSelChange;

	long		m_lStartMeasure;
	long		m_lStartBeat;
	long		m_lStartGrid;
	long		m_lStartTick;

	long		m_lEndMeasure;
	long		m_lEndBeat;
	long		m_lEndGrid;
	long		m_lEndTick;

	long		m_lLengthMeasure;
	long		m_lLengthBeat;
	long		m_lLengthGrid;
	long		m_lLengthTick;
	DWORD		m_dwLengthNbrSamples;

	long		m_lOffsetMeasure;
	long		m_lOffsetBeat;
	long		m_lOffsetGrid;
	long		m_lOffsetTick;
	DWORD		m_dwOffsetNbrSamples;

	long		m_lSourceEndMeasure;
	long		m_lSourceEndBeat;
	long		m_lSourceEndGrid;
	long		m_lSourceEndTick;

	long		m_lSourceLengthMeasure;
	long		m_lSourceLengthBeat;
	long		m_lSourceLengthGrid;
	long		m_lSourceLengthTick;

    CTypedPtrList<CPtrList, FileListInfo*> m_lstFileListInfo;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\tabfileref.cpp ===
// TabFileRef.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropTrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabFileRef.h"
#include "TabLoop.h"
#include "TabPerformance.h"
#include "TabVariations.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

// {D9D1D754-B61A-4216-991C-7571D5BEEC22}
static const GUID GUID_WaveItemPPGMgr = 
{ 0xd9d1d754, 0xb61a, 0x4216, { 0x99, 0x1c, 0x75, 0x71, 0xd5, 0xbe, 0xec, 0x22 } };

short CPropPageMgrItem::sm_nActiveTab = 0;

static const TCHAR g_pstrUnknown[11] = _T("----------");

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem constructor/destructor

CPropPageMgrItem::CPropPageMgrItem( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store Framework pointer
	ASSERT( pIFramework != NULL ); 
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	ASSERT( pTrackMgr != NULL ); 
	m_pTrackMgr = pTrackMgr;

	// Store GUID
	m_GUIDManager = GUID_WaveItemPPGMgr;

	// Initialize our pointers to NULL
	m_pTabFileRef = NULL;
	m_pTabLoop = NULL;
	m_pTabPerformance = NULL;
	m_pTabVariations = NULL;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

CPropPageMgrItem::~CPropPageMgrItem()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabFileRef )
	{
		delete m_pTabFileRef;
		m_pTabFileRef = NULL;
	}

	if( m_pTabLoop )
	{
		delete m_pTabLoop;
		m_pTabLoop = NULL;
	}

	if( m_pTabPerformance )
	{
		delete m_pTabPerformance;
		m_pTabPerformance = NULL;
	}

	if( m_pTabVariations )
	{
		delete m_pTabVariations;
		m_pTabVariations = NULL;
	}

	RELEASE( m_pIFramework );

	// Call the base class destructor
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	// Try and load the title
	CComBSTR comBSTR;
	if( comBSTR.LoadString( IDS_PROPPAGE_FILEREF ) )
	{
		// Succeeded - return the BSTR
		*pbstrTitle = comBSTR.Detach();
		return S_OK;
	}

	// Failed - return NULL
	*pbstrTitle = NULL;

	return E_FAIL;
};


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_POINTER;
	}

	// Save a copy of the IDMUSProdPropSheet pointer
	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	// Initialize the array and number of property sheets
	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Initialize the number of pages we've added
	short nNbrPages = 0;

	// Create FileRef tab
	if( m_pTabFileRef == NULL )
	{
		m_pTabFileRef = new CTabFileRef();
	}
	if( m_pTabFileRef )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabFileRef->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabFileRef->m_pPropPageMgr = this;
	}

	// Create Loop tab
	if( m_pTabLoop == NULL )
	{
		m_pTabLoop = new CTabLoop();
	}
	if( m_pTabLoop )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabLoop->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabLoop->m_pPropPageMgr = this;
	}

	// Create Performance tab
	if( m_pTabPerformance == NULL )
	{
		m_pTabPerformance = new CTabPerformance();
	}
	if( m_pTabPerformance )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabPerformance->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabPerformance->m_pPropPageMgr = this;
	}

	// Create Variations tab
	if( m_pTabVariations == NULL )
	{
		m_pTabVariations = new CTabVariations();
	}
	if( m_pTabVariations )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabVariations->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabVariations->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::RefreshData

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to a CTrackItem
	CPropTrackItem  PropTrackItem;
	CPropTrackItem* pPropItem = &PropTrackItem;

	if( m_pIPropPageObject == NULL )
	{
		// No property page object - set pointer to NULL
		pPropItem = NULL;
	}
	// Have a property page object - try and get a pointer from it
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pPropItem ) ) )
	{
		return E_FAIL;
	}

	// Update the property pages, if they exists
	if( m_pTabFileRef )
	{
		m_pTabFileRef->SetPropTrackItem( pPropItem );
	}
	if( m_pTabLoop )
	{
		m_pTabLoop->SetPropTrackItem( pPropItem );
	}
	if( m_pTabPerformance )
	{
		m_pTabPerformance->SetPropTrackItem( pPropItem );
	}
	if( m_pTabVariations )
	{
		m_pTabVariations->SetPropTrackItem( pPropItem );
	}

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef property page

IMPLEMENT_DYNCREATE(CTabFileRef, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef constructor/destructor

CTabFileRef::CTabFileRef(): CPropertyPage(CTabFileRef::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_PROPPAGE_FILEREF);
	//{{AFX_DATA_INIT(CTabFileRef)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pIWaveTimelineDraw = NULL;
	m_pPropPageMgr = NULL;

	// Initialize our class members to FALSE
	m_fValidTrackItem = FALSE;
	m_fNeedToDetach = FALSE;
	m_fIgnoreSelChange = FALSE;

	m_lStartMeasure = 0;
	m_lStartBeat = 0;
	m_lStartGrid = 0;
	m_lStartTick = 0;

	m_lEndMeasure = 0;
	m_lEndBeat = 0;
	m_lEndGrid = 0;
	m_lEndTick = 0;
	
	m_lLengthMeasure = 0;
	m_lLengthBeat = 0;
	m_lLengthGrid = 0;
	m_lLengthTick = 0;
	m_dwLengthNbrSamples = 0;
	
	m_lOffsetMeasure = 0;
	m_lOffsetBeat = 0;
	m_lOffsetGrid = 0;
	m_lOffsetTick = 0;
	m_dwOffsetNbrSamples = 0;

	m_lSourceEndMeasure = 0;
	m_lSourceEndBeat = 0;
	m_lSourceEndGrid = 0;
	m_lSourceEndTick = 0;
	
	m_lSourceLengthMeasure = 0;
	m_lSourceLengthBeat = 0;
	m_lSourceLengthGrid = 0;
	m_lSourceLengthTick = 0;
}

CTabFileRef::~CTabFileRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	FileListInfo* pFileListInfo;
	while( !m_lstFileListInfo.IsEmpty() )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
		delete pFileListInfo;
	}

	RELEASE( m_pIWaveTimelineDraw );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::DoDataExchange

void CTabFileRef::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CTabFileRef)
	DDX_Control(pDX, IDC_LOCK_LENGTH, m_btnLockLength);
	DDX_Control(pDX, IDC_LOCK_END, m_btnLockEnd);
	DDX_Control(pDX, IDC_COMBO_FILE, m_comboFile);
	DDX_Control(pDX, IDC_PROMPT_GRID, m_staticPromptGrid);
	DDX_Control(pDX, IDC_PROMPT_TICK, m_staticPromptTick);
	DDX_Control(pDX, IDC_PROMPT_BEAT, m_staticPromptBeat);
	DDX_Control(pDX, IDC_PROMPT_BAR, m_staticPromptBar);
	DDX_Control(pDX, IDC_EDIT_START_TICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_START_GRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_START_BEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_START_BAR, m_editStartMeasure);
	DDX_Control(pDX, IDC_EDIT_END_TICK, m_editEndTick);
	DDX_Control(pDX, IDC_EDIT_END_GRID, m_editEndGrid);
	DDX_Control(pDX, IDC_EDIT_END_BEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_EDIT_END_BAR, m_editEndMeasure);
	DDX_Control(pDX, IDC_EDIT_LENGTH_TICK, m_editLengthTick);
	DDX_Control(pDX, IDC_EDIT_LENGTH_GRID, m_editLengthGrid);
	DDX_Control(pDX, IDC_EDIT_LENGTH_BEAT, m_editLengthBeat);
	DDX_Control(pDX, IDC_EDIT_LENGTH_BAR, m_editLengthMeasure);
	DDX_Control(pDX, IDC_STATIC_LENGTH_NBR_SAMPLES, m_staticLengthNbrSamples);
	DDX_Control(pDX, IDC_EDIT_OFFSET_TICK, m_editOffsetTick);
	DDX_Control(pDX, IDC_EDIT_OFFSET_GRID, m_editOffsetGrid);
	DDX_Control(pDX, IDC_EDIT_OFFSET_BEAT, m_editOffsetBeat);
	DDX_Control(pDX, IDC_EDIT_OFFSET_BAR, m_editOffsetMeasure);
	DDX_Control(pDX, IDC_STATIC_OFFSET_NBR_SAMPLES, m_staticOffsetNbrSamples);
	DDX_Control(pDX, IDC_SPIN_START_TICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_START_GRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_START_BEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_START_BAR, m_spinStartMeasure);
	DDX_Control(pDX, IDC_SPIN_END_TICK, m_spinEndTick);
	DDX_Control(pDX, IDC_SPIN_END_GRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_SPIN_END_BEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_SPIN_END_BAR, m_spinEndMeasure);
	DDX_Control(pDX, IDC_SPIN_LENGTH_TICK, m_spinLengthTick);
	DDX_Control(pDX, IDC_SPIN_LENGTH_GRID, m_spinLengthGrid);
	DDX_Control(pDX, IDC_SPIN_LENGTH_BEAT, m_spinLengthBeat);
	DDX_Control(pDX, IDC_SPIN_LENGTH_BAR, m_spinLengthMeasure);
	DDX_Control(pDX, IDC_SPIN_OFFSET_TICK, m_spinOffsetTick);
	DDX_Control(pDX, IDC_SPIN_OFFSET_GRID, m_spinOffsetGrid);
	DDX_Control(pDX, IDC_SPIN_OFFSET_BEAT, m_spinOffsetBeat);
	DDX_Control(pDX, IDC_SPIN_OFFSET_BAR, m_spinOffsetMeasure);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_TICK, m_staticSourceEndTick);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_GRID, m_staticSourceEndGrid);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_BEAT, m_staticSourceEndBeat);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_BAR, m_staticSourceEndMeasure);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_TICK, m_staticSourceLengthTick);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_GRID, m_staticSourceLengthGrid);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_BEAT, m_staticSourceLengthBeat);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_BAR, m_staticSourceLengthMeasure);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_NBR_SAMPLES, m_staticSourceLengthNbrSamples);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabFileRef, CPropertyPage)
	//{{AFX_MSG_MAP(CTabFileRef)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_TICK, OnSpinStartTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_GRID, OnSpinStartGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_BEAT, OnSpinStartBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_BAR, OnSpinStartMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_TICK, OnSpinEndTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_GRID, OnSpinEndGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_BEAT, OnSpinEndBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_BAR, OnSpinEndMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_TICK, OnSpinLengthTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_GRID, OnSpinLengthGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_BEAT, OnSpinLengthBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_BAR, OnSpinLengthMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_OFFSET_TICK, OnSpinOffsetTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_OFFSET_GRID, OnSpinOffsetGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_OFFSET_BEAT, OnSpinOffsetBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_OFFSET_BAR, OnSpinOffsetMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_START_TICK, OnKillFocusStartTick)
	ON_EN_KILLFOCUS(IDC_EDIT_START_GRID, OnKillFocusStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_START_BEAT, OnKillFocusStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_START_BAR, OnKillFocusStartMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_END_TICK, OnKillFocusEndTick)
	ON_EN_KILLFOCUS(IDC_EDIT_END_GRID, OnKillFocusEndGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_END_BEAT, OnKillFocusEndBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_END_BAR, OnKillFocusEndMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_TICK, OnKillFocusLengthTick)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_GRID, OnKillFocusLengthGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_BEAT, OnKillFocusLengthBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_BAR, OnKillFocusLengthMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_OFFSET_TICK, OnKillFocusOffsetTick)
	ON_EN_KILLFOCUS(IDC_EDIT_OFFSET_GRID, OnKillFocusOffsetGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_OFFSET_BEAT, OnKillFocusOffsetBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_OFFSET_BAR, OnKillFocusOffsetMeasure)
	ON_CBN_DROPDOWN(IDC_COMBO_FILE, OnDropDownComboFile)
	ON_CBN_SELCHANGE(IDC_COMBO_FILE, OnSelChangeComboFile)
	ON_WM_KILLFOCUS()
	ON_BN_CLICKED(IDC_LOCK_END, OnLockEnd)
	ON_BN_DOUBLECLICKED(IDC_LOCK_END, OnDoubleClickedLockEnd)
	ON_BN_CLICKED(IDC_LOCK_LENGTH, OnLockLength)
	ON_BN_DOUBLECLICKED(IDC_LOCK_LENGTH, OnDoubleClickedLockLength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef custom functions

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetPropTrackItem

void CTabFileRef::SetPropTrackItem( const CPropTrackItem* pPropItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	if( pPropItem == NULL )
	{
		m_fValidTrackItem = FALSE;
		m_PropItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Store IDMUSProdWaveTimelineDraw interface pointer
	RELEASE( m_pIWaveTimelineDraw );
	if( pPropItem->m_Item.m_FileRef.pIDocRootNode )
	{
		if( FAILED ( pPropItem->m_Item.m_FileRef.pIDocRootNode->QueryInterface( IID_IDMUSProdWaveTimelineDraw, (void **)&m_pIWaveTimelineDraw ) ) )
		{
			// Cannot update properties without this interface
			m_fValidTrackItem = FALSE;
			m_PropItem.Clear();
			EnableControls( FALSE );
			return;
		}
	}

	// Flag that we have a valid item
	m_fValidTrackItem = TRUE;

	// Copy the information from the new item
	m_PropItem.Copy( pPropItem );
	m_PropItem.m_nPropertyTab = TAB_FILEREF;
	m_PropItem.m_dwChanged = 0;
	if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
	{
		REFERENCE_TIME rtActualEnd;
		REFERENCE_TIME rtTimePhysical;
		m_pPropPageMgr->m_pTrackMgr->UnknownTimeToRefTime( m_PropItem.m_Item.m_rtTimePhysical + m_PropItem.m_Item.m_rtDuration, &rtActualEnd );
		m_pPropPageMgr->m_pTrackMgr->UnknownTimeToRefTime( m_PropItem.m_Item.m_rtTimePhysical, &rtTimePhysical );

		REFERENCE_TIME rtDuration = rtActualEnd - rtTimePhysical;
		rtDuration -= m_PropItem.m_Item.PitchAdjustedStartOffset();

		REFERENCE_TIME rtMinTime = MinTimeToUnknownTime();
		m_pIWaveTimelineDraw->RefTimeToSample( max(rtMinTime, rtDuration), &m_dwLengthNbrSamples, m_PropItem.m_Item.m_lPitch );
	}

	// Compute values for controls displaying "time"
	// Determine measure, beat, grid, tick
	// OR
	// Determine minute, second, grid, millisecond
	RecomputeTimes();

	// Check if the edit control has a valid window handle.
	if( m_editStartBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Clear out the file combo box
	// this is necessary!
	{
		FileListInfo* pSLI;

		// Delete old FileInfo list
		while( !m_lstFileListInfo.IsEmpty() )
		{
			pSLI = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
			delete pSLI;
		}

		// Remove old list from combo box
		m_comboFile.ResetContent();
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if wave length is less than minimum loop length
	ASSERT( m_PropItem.m_Item.m_WaveInfo.dwWaveEnd >= (MIN_LOOP_LENGTH + 1) );
//	if( m_PropItem.m_Item.m_WaveInfo.dwWaveEnd < (MIN_LOOP_LENGTH + 1) )
//	{
//		// Just disable duration controls???????
//		EnableControls( FALSE );
//		return;
//	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the controls
	EnableControls( TRUE );

	// Set File combo box selection
	m_fIgnoreSelChange = TRUE;
	SetFileComboBoxSelection();
	m_fIgnoreSelChange = FALSE;

	// Check if multiple items are selected
	if( m_PropItem.m_dwBits & PROPF_MULTIPLESELECT )
	{
		// For now don't set value of other controls when multiple waves selected
		return;
	}

	// Set nMeasureBeatOffset
	int nMeasureBeatOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nMeasureBeatOffset = 0;
	}
	else
	{
		nMeasureBeatOffset = 1;
	}

	// Set GRID controls
	CWaveStrip* pWaveStrip = m_PropItem.m_Item.GetWaveStripForPropSheet();
	if( pWaveStrip
	&&  pWaveStrip->IsOneGrid() )
	{
		m_editStartGrid.SetWindowText( NULL );
		m_editStartGrid.EnableWindow( FALSE );
		m_editEndGrid.SetWindowText( NULL );
		m_editEndGrid.EnableWindow( FALSE );
		m_editLengthGrid.SetWindowText( NULL );
		m_editLengthGrid.EnableWindow( FALSE );
		m_editOffsetGrid.SetWindowText( NULL );
		m_editOffsetGrid.EnableWindow( FALSE );
	}
	else
	{
		SetEditControl( m_editStartGrid, m_lStartGrid, 1 );
		if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
		{
			SetEditControl( m_editEndGrid, m_lEndGrid, 1 );
			SetEditControl( m_editLengthGrid, m_lLengthGrid, 0 );
			SetEditControl( m_editOffsetGrid, m_lOffsetGrid, 0 );
		}
		else
		{
			m_editEndGrid.SetWindowText( NULL );
			m_editLengthGrid.SetWindowText( NULL );
			m_editOffsetGrid.SetWindowText( NULL );
		}
	}
	
	// Update SOURCE controls
	if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
	{
		// Set GRID controls
		if( pWaveStrip
		&&  pWaveStrip->IsOneGrid() )
		{
			m_staticSourceEndGrid.SetWindowText( NULL );
			m_staticSourceLengthGrid.SetWindowText( NULL );
		}
		else
		{
			SetStaticControl( m_staticSourceEndGrid, m_lSourceEndGrid, 1 );
			SetStaticControl( m_staticSourceLengthGrid, m_lSourceLengthGrid, 0 );
		}

		// Update END controls
		SetStaticControl( m_staticSourceEndMeasure, m_lSourceEndMeasure, nMeasureBeatOffset );
		SetStaticControl( m_staticSourceEndBeat, m_lSourceEndBeat, nMeasureBeatOffset );
		SetStaticControl( m_staticSourceEndTick, m_lSourceEndTick, 0 );

		// Update LENGTH controls
		SetStaticControl( m_staticSourceLengthMeasure, m_lSourceLengthMeasure, 0 );
		SetStaticControl( m_staticSourceLengthBeat, m_lSourceLengthBeat, 0 );
		SetStaticControl( m_staticSourceLengthTick, m_lSourceLengthTick, 0 );
		SetStaticControl( m_staticSourceLengthNbrSamples, (m_PropItem.m_Item.m_WaveInfo.dwWaveEnd + 1), 0 );
	}
	else
	{
		// Update END controls
		m_staticSourceEndMeasure.SetWindowText( NULL );
		m_staticSourceEndBeat.SetWindowText( NULL );
		m_staticSourceEndGrid.SetWindowText( NULL );
		m_staticSourceEndTick.SetWindowText( NULL );

		// Update LENGTH controls
		m_staticSourceLengthMeasure.SetWindowText( NULL );
		m_staticSourceLengthBeat.SetWindowText( NULL );
		m_staticSourceLengthGrid.SetWindowText( NULL );
		m_staticSourceLengthTick.SetWindowText( NULL );
		m_staticSourceLengthNbrSamples.SetWindowText( NULL );
	}

	// Update START controls
	SetEditControl( m_editStartMeasure, m_lStartMeasure, nMeasureBeatOffset );
	SetEditControl( m_editStartBeat, m_lStartBeat, nMeasureBeatOffset );
	SetEditControl( m_editStartTick, m_lStartTick, 0 );

	if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
	{
		// Update END controls
		SetEditControl( m_editEndMeasure, m_lEndMeasure, nMeasureBeatOffset );
		SetEditControl( m_editEndBeat, m_lEndBeat, nMeasureBeatOffset );
		SetEditControl( m_editEndTick, m_lEndTick, 0 );

		// Update LENGTH controls
		SetEditControl( m_editLengthMeasure, m_lLengthMeasure, 0 );
		SetEditControl( m_editLengthBeat, m_lLengthBeat, 0 );
		SetEditControl( m_editLengthTick, m_lLengthTick, 0 );
		SetStaticControl( m_staticLengthNbrSamples, m_dwLengthNbrSamples, 0 );

		// Update OFFSET controls
		SetEditControl( m_editOffsetMeasure, m_lOffsetMeasure, 0 );
		SetEditControl( m_editOffsetBeat, m_lOffsetBeat, 0 );
		SetEditControl( m_editOffsetTick, m_lOffsetTick, 0 );
		SetStaticControl( m_staticOffsetNbrSamples, m_dwOffsetNbrSamples, 0 );
	}
	else
	{
		// Update END controls
		m_editEndTick.SetWindowText( NULL );
		m_editEndBeat.SetWindowText( NULL );
		m_editEndMeasure.SetWindowText( NULL );

		// Update LENGTH controls
		m_editLengthTick.SetWindowText( NULL );
		m_editLengthBeat.SetWindowText( NULL );
		m_editLengthMeasure.SetWindowText( NULL );
		m_staticLengthNbrSamples.SetWindowText( NULL );

		// Update OFFSET controls
		m_editOffsetTick.SetWindowText( NULL );
		m_editOffsetBeat.SetWindowText( NULL );
		m_editOffsetMeasure.SetWindowText( NULL );
		m_staticOffsetNbrSamples.SetWindowText( NULL );

	}

	// Update LOCK END controls
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr )
	{
		CBitmap* pBitmap = m_pPropPageMgr->m_pTrackMgr->GetLockBitmap( m_PropItem.m_Item.m_fLockEndUI );
		if( pBitmap )
		{
			m_btnLockEnd.SetBitmap( (HBITMAP)pBitmap->GetSafeHandle() );
		}
	}
	if( m_PropItem.m_Item.m_fLockEndUI )
	{
		m_editEndMeasure.EnableWindow( FALSE );
		m_spinEndMeasure.EnableWindow( FALSE );
		m_editEndBeat.EnableWindow( FALSE );
		m_spinEndBeat.EnableWindow( FALSE );
		m_editEndGrid.EnableWindow( FALSE );
		m_spinEndGrid.EnableWindow( FALSE );
		m_editEndTick.EnableWindow( FALSE );
		m_spinEndTick.EnableWindow( FALSE );
	}

	// Update LOCK LENGTH controls
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr )
	{
		CBitmap* pBitmap = m_pPropPageMgr->m_pTrackMgr->GetLockBitmap( m_PropItem.m_Item.m_fLockLengthUI );
		if( pBitmap )
		{
			m_btnLockLength.SetBitmap( (HBITMAP)pBitmap->GetSafeHandle() );
		}
	}
	if( m_PropItem.m_Item.m_fLockLengthUI )
	{
		m_editLengthMeasure.EnableWindow( FALSE );
		m_spinLengthMeasure.EnableWindow( FALSE );
		m_editLengthBeat.EnableWindow( FALSE );
		m_spinLengthBeat.EnableWindow( FALSE );
		m_editLengthGrid.EnableWindow( FALSE );
		m_spinLengthGrid.EnableWindow( FALSE );
		m_editLengthTick.EnableWindow( FALSE );
		m_spinLengthTick.EnableWindow( FALSE );
	}

	// Set ranges of spin controls
	SetControlRanges();
}
	

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetEditControl

void CTabFileRef::SetEditControl( CEdit& edit, long lValue, int nOffset )
{
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	BOOL fTransSuccess;

	edit.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Convert from text to an integer
	long lCurValue = GetDlgItemInt( edit.GetDlgCtrlID(), &fTransSuccess, TRUE );

	// Check if the conversion failed, the text is empty, or if the values are different
	if( !fTransSuccess
	|| (tcstrTmp[0] == NULL)
	|| (lCurValue != lValue + nOffset) )
	{
		// Update the displayed number
		SetDlgItemInt( edit.GetDlgCtrlID(), lValue + nOffset );
	}
}
	

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetStaticControl

void CTabFileRef::SetStaticControl( CStatic& stat, long lValue, int nOffset )
{
	// Update the displayed number
	SetDlgItemInt( stat.GetDlgCtrlID(), lValue + nOffset );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetStart

void CTabFileRef::SetStart( REFERENCE_TIME rtNewStart ) 
{
	REFERENCE_TIME rtSegmentLength = m_pPropPageMgr->m_pTrackMgr->GetSegmentLength();
	REFERENCE_TIME rtMinTime = MinTimeToUnknownTime();
	REFERENCE_TIME rtCurEnd = EndToUnknownTime();
	REFERENCE_TIME rtCurLength = LengthToUnknownTime();

	REFERENCE_TIME rtPitchAdjustedStartOffset; 
	m_PropItem.m_Item.StartOffsetToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtPitchAdjustedStartOffset );
	REFERENCE_TIME rtMinLength = rtMinTime + rtPitchAdjustedStartOffset;

	REFERENCE_TIME rtActualLength;
	m_PropItem.m_Item.SourceWaveLengthToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtActualLength );

	REFERENCE_TIME rtMinStart;
//	m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( -MAX_TICK, &rtMinStart );
	m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( 0, &rtMinStart );

	rtNewStart = max( rtNewStart, rtMinStart );
	rtNewStart = min( rtNewStart, rtSegmentLength - rtMinTime );
	
	REFERENCE_TIME rtNewLength;
	if( m_PropItem.m_Item.m_fLockLengthUI )
	{
		rtNewLength = rtCurLength;
	}
	else if( m_PropItem.m_Item.m_fLockEndUI )
	{
		rtNewLength = rtCurEnd - rtNewStart;
		if( rtNewLength < rtMinLength )
		{
			rtNewLength = rtMinLength;
			rtNewStart = rtCurEnd - rtMinLength;
		}
        // No good reason to clamp this. It only causes trouble if there are pitch bends.
/*		if( m_PropItem.m_Item.m_fLoopedUI == FALSE )
		{
			if( rtNewLength > rtActualLength )
			{
				rtNewLength = rtActualLength;
				rtNewStart = rtCurEnd - rtActualLength;
			}
		}*/
	}
	else
	{
		rtNewLength = rtCurEnd - rtNewStart;
	}

	rtNewLength = max( rtNewLength, rtMinLength );
    // No good reason to clamp this. It only causes trouble if there are pitch bends.
/*	if( m_PropItem.m_Item.m_fLoopedUI == FALSE )
	{
		rtNewLength = min( rtNewLength, rtActualLength );
	}*/

	if( (m_PropItem.m_dwUndetermined_TabFileRef & UNDT_TIME_PHYSICAL)
	||  (m_PropItem.m_dwUndetermined_TabFileRef & UNDT_DURATION)
	||  (m_PropItem.m_Item.m_rtTimePhysical != rtNewStart)
	||  (m_PropItem.m_Item.m_rtDuration != rtNewLength) )
	{
		m_PropItem.m_Item.m_rtTimePhysical = rtNewStart;
		m_PropItem.m_Item.m_rtDuration = rtNewLength;

		// Now, update the object with the new value(s)
		m_PropItem.m_dwChanged = CHGD_TIME_OR_DURATION;
		UpdateObject();
	}
	else
	{
		// Display original values
		SetPropTrackItem( &m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetEnd

void CTabFileRef::SetEnd( REFERENCE_TIME rtNewEnd ) 
{
	ASSERT( m_PropItem.m_Item.m_fLockEndUI == FALSE );

	REFERENCE_TIME rtSegmentLength = m_pPropPageMgr->m_pTrackMgr->GetSegmentLength();
	REFERENCE_TIME rtMinTime = MinTimeToUnknownTime();
	REFERENCE_TIME rtCurStart = StartToUnknownTime();
	REFERENCE_TIME rtCurLength = LengthToUnknownTime();

	REFERENCE_TIME rtPitchAdjustedStartOffset; 
	m_PropItem.m_Item.StartOffsetToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtPitchAdjustedStartOffset );
	REFERENCE_TIME rtMinLength = rtMinTime + rtPitchAdjustedStartOffset;

	REFERENCE_TIME rtActualLength;
	m_PropItem.m_Item.SourceWaveLengthToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtActualLength );

	REFERENCE_TIME rtMinStart;
//	m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( -MAX_TICK, &rtMinStart );
	m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( 0, &rtMinStart );
	
	REFERENCE_TIME rtNewStart;
	REFERENCE_TIME rtNewLength;
	if( m_PropItem.m_Item.m_fLockLengthUI )
	{
		rtNewLength = rtCurLength;
		rtNewStart = rtNewEnd - rtCurLength;
		rtNewStart = max( rtNewStart, rtMinStart );
		rtNewStart = min( rtNewStart, rtSegmentLength - rtMinTime );
	}
	else
	{
		rtNewLength = rtNewEnd - rtCurStart;
		rtNewStart = rtCurStart;
	}

	rtNewLength = max( rtNewLength, rtMinLength );
    // No good reason to clamp this. It only causes trouble if there are pitch bends.
/*	if( m_PropItem.m_Item.m_fLoopedUI == FALSE )
	{
		rtNewLength = min( rtNewLength, rtActualLength );
	}*/

	if( (m_PropItem.m_dwUndetermined_TabFileRef & UNDT_TIME_PHYSICAL)
	||  (m_PropItem.m_dwUndetermined_TabFileRef & UNDT_DURATION)
	||  (m_PropItem.m_Item.m_rtTimePhysical != rtNewStart)
	||  (m_PropItem.m_Item.m_rtDuration != rtNewLength) )
	{
		m_PropItem.m_Item.m_rtTimePhysical = rtNewStart;
		m_PropItem.m_Item.m_rtDuration = rtNewLength;

		// Now, update the object with the new value(s)
		m_PropItem.m_dwChanged = CHGD_TIME_OR_DURATION;
		UpdateObject();
	}
	else
	{
		// Display original values
		SetPropTrackItem( &m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetLength

void CTabFileRef::SetLength( REFERENCE_TIME rtNewLength ) 
{
	ASSERT( m_PropItem.m_Item.m_fLockLengthUI == FALSE );

	REFERENCE_TIME rtSegmentLength = m_pPropPageMgr->m_pTrackMgr->GetSegmentLength();
	REFERENCE_TIME rtMinTime = MinTimeToUnknownTime();
	REFERENCE_TIME rtCurStart = StartToUnknownTime();
	REFERENCE_TIME rtCurEnd = EndToUnknownTime();

	REFERENCE_TIME rtPitchAdjustedStartOffset; 
	m_PropItem.m_Item.StartOffsetToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtPitchAdjustedStartOffset );
	REFERENCE_TIME rtMinLength = rtMinTime + rtPitchAdjustedStartOffset;

	REFERENCE_TIME rtActualLength;
	m_PropItem.m_Item.SourceWaveLengthToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtActualLength );

	REFERENCE_TIME rtMinStart;
//	m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( -MAX_TICK, &rtMinStart );
	m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( 0, &rtMinStart );
	
	REFERENCE_TIME rtNewStart;
	if( m_PropItem.m_Item.m_fLockEndUI )
	{
		if( rtNewLength < rtMinLength )
		{
			rtNewLength = rtMinLength;
		}
        // No good reason to clamp this. It only causes trouble if there are pitch bends.
/*		if( m_PropItem.m_Item.m_fLoopedUI == FALSE )
		{
			if( rtNewLength > rtActualLength )
			{
				rtNewLength = rtActualLength;
			}
		}*/
		rtNewStart = rtCurEnd - rtNewLength;

		if( rtNewStart < rtMinStart )
		{
			rtNewLength = rtNewLength - (rtMinStart - rtNewStart);
			rtNewStart = rtMinStart;
		}
		rtNewStart = min( rtNewStart, rtSegmentLength - rtMinTime );
	}
	else
	{
		rtNewStart = rtCurStart;
	}

	rtNewLength = max( rtNewLength, rtMinLength );
    // No good reason to clamp this. It only causes trouble if there are pitch bends.
/*	if( m_PropItem.m_Item.m_fLoopedUI == FALSE )
	{
		rtNewLength = min( rtNewLength, rtActualLength );
	}*/

	if( (m_PropItem.m_dwUndetermined_TabFileRef & UNDT_TIME_PHYSICAL)
	||  (m_PropItem.m_dwUndetermined_TabFileRef & UNDT_DURATION)
	||  (m_PropItem.m_Item.m_rtTimePhysical != rtNewStart)
	||  (m_PropItem.m_Item.m_rtDuration != rtNewLength) )
	{
		m_PropItem.m_Item.m_rtTimePhysical = rtNewStart;
		m_PropItem.m_Item.m_rtDuration = rtNewLength;

		// Now, update the object with the new value(s)
		m_PropItem.m_dwChanged = CHGD_TIME_OR_DURATION;
		UpdateObject();
	}
	else
	{
		// Display original values
		SetPropTrackItem( &m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::RemoveFineTune

REFERENCE_TIME CTabFileRef::RemoveFineTune( REFERENCE_TIME rtTime )
{
	if( rtTime
	&&  m_PropItem.m_Item.m_lPitch )
	{
		if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
		{
			IDMUSProdWaveTimelineDraw* pIWaveTimelineDraw;
			if( SUCCEEDED ( m_PropItem.m_Item.m_FileRef.pIDocRootNode->QueryInterface( IID_IDMUSProdWaveTimelineDraw, (void **)&pIWaveTimelineDraw ) ) )
			{
				REFERENCE_TIME rtAdjustedTime;
				DWORD dwSample;

				if( SUCCEEDED ( pIWaveTimelineDraw->RefTimeToSample( rtTime, &dwSample, m_PropItem.m_Item.m_lPitch ) )
				&&  SUCCEEDED ( pIWaveTimelineDraw->SampleToRefTime( dwSample, &rtAdjustedTime, 0 ) ) )
				{
					RELEASE( pIWaveTimelineDraw );
					return rtAdjustedTime;
				}

				RELEASE( pIWaveTimelineDraw );
			}
		}
	}

	return rtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetOffset

void CTabFileRef::SetOffset( REFERENCE_TIME rtNewOffset ) 
{
	// Determine minimum
	REFERENCE_TIME rtMinTime = MinTimeToRefTime();

	// Determine maximum - which is length of source wave without fine tune
	// (or duration without fine tune - whichever is less)
	REFERENCE_TIME rtLengthOfSourceWave;
	if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
	{
		ASSERT( m_pIWaveTimelineDraw != NULL );
		m_pIWaveTimelineDraw->SampleToRefTime( (m_PropItem.m_Item.m_WaveInfo.dwWaveEnd + 1), &rtLengthOfSourceWave, 0 );
	}
	else
	{
		ASSERT( 0 );	// Should not happen!
		rtLengthOfSourceWave = m_PropItem.m_Item.m_WaveInfo.rtWaveLength;
	}
	REFERENCE_TIME rtDuration;
	m_pPropPageMgr->m_pTrackMgr->UnknownTimeToRefTime( m_PropItem.m_Item.m_rtDuration, &rtDuration );
	REFERENCE_TIME rtMaxTime = min( rtLengthOfSourceWave, rtDuration );
	
	rtNewOffset = RemoveFineTune( rtNewOffset );
	rtNewOffset = max( rtNewOffset, 0 );
	rtNewOffset = min( rtNewOffset, rtMaxTime - rtMinTime );

	if( (m_PropItem.m_dwUndetermined_TabFileRef & UNDT_START_OFFSET)
	||  (m_PropItem.m_Item.m_rtStartOffset != rtNewOffset) )
	{
		m_PropItem.m_Item.m_rtStartOffset = rtNewOffset;

		// Now, update the object with the new value(s)
		m_PropItem.m_dwChanged = CHGD_START_OFFSET;
		UpdateObject();
	}
	else
	{
		// Display original values
		SetPropTrackItem( &m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::StartToUnknownTime

REFERENCE_TIME CTabFileRef::StartToUnknownTime( void )
{
	REFERENCE_TIME rtNewStart;

	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_lStartMeasure, m_lStartBeat, m_lStartGrid, m_lStartTick,
															&rtTime );
		m_pPropPageMgr->m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtNewStart );
	}
	else
	{
		MUSIC_TIME mtTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lStartMeasure, m_lStartBeat, m_lStartGrid, m_lStartTick, &mtTime );
		m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtNewStart );
	}

	return rtNewStart;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::EndToUnknownTime

REFERENCE_TIME CTabFileRef::EndToUnknownTime( void )
{
	REFERENCE_TIME rtNewEnd;

	REFERENCE_TIME rtPitchAdjustedStartOffset; 
	m_PropItem.m_Item.StartOffsetToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtPitchAdjustedStartOffset );

	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_lEndMeasure, m_lEndBeat, m_lEndGrid, m_lEndTick,
															&rtTime );
		rtTime += rtPitchAdjustedStartOffset;
		m_pPropPageMgr->m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtNewEnd );
	}
	else
	{
		MUSIC_TIME mtTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lEndMeasure, m_lEndBeat, m_lEndGrid, m_lEndTick, &mtTime );
		mtTime += (MUSIC_TIME)rtPitchAdjustedStartOffset;
		m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtNewEnd );
	}

	return rtNewEnd;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::LengthToUnknownTime

REFERENCE_TIME CTabFileRef::LengthToUnknownTime( void )
{
	REFERENCE_TIME rtNewLength;

	REFERENCE_TIME rtPitchAdjustedStartOffset; 
	m_PropItem.m_Item.StartOffsetToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtPitchAdjustedStartOffset );

	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_lLengthMeasure, m_lLengthBeat, m_lLengthGrid, m_lLengthTick,
															&rtTime );
		rtTime += rtPitchAdjustedStartOffset;
		m_pPropPageMgr->m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtNewLength );
	}
	else
	{
		MUSIC_TIME mtTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lLengthMeasure, m_lLengthBeat, m_lLengthGrid, m_lLengthTick, &mtTime );
		mtTime += (MUSIC_TIME)rtPitchAdjustedStartOffset;
		m_pPropPageMgr->m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtNewLength );
	}

	return rtNewLength;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OffsetToRefTime

REFERENCE_TIME CTabFileRef::OffsetToRefTime( void )
{
	REFERENCE_TIME rtNewOffset;

	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_lOffsetMeasure, m_lOffsetBeat, m_lOffsetGrid, m_lOffsetTick,
															&rtNewOffset );
	}
	else
	{
		REFERENCE_TIME rtTimePhysical;
		MUSIC_TIME mtTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lStartMeasure + m_lOffsetMeasure,
																  m_lStartBeat + m_lOffsetBeat,
																  m_lStartGrid + m_lOffsetGrid,
																  m_lStartTick + m_lOffsetTick,
																  &mtTime );
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtTime, &rtNewOffset );
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToRefTime( (MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical, &rtTimePhysical );
		rtNewOffset -= rtTimePhysical;
	}

	return rtNewOffset;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::MinTimeToUnknownTime

REFERENCE_TIME CTabFileRef::MinTimeToUnknownTime( void )
{
	REFERENCE_TIME rtMinTime;

	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															0, 0, 0, 1, &rtMinTime );
	}
	else
	{
		MUSIC_TIME mtMinTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( 0, 0, 0, 1, &mtMinTime );
		rtMinTime = mtMinTime;
	}

	return rtMinTime;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::MinTimeToRefTime

REFERENCE_TIME CTabFileRef::MinTimeToRefTime( void )
{
	REFERENCE_TIME rtMinTime;

	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															0, 0, 0, 1, &rtMinTime );
	}
	else
	{
		MUSIC_TIME mtMinTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( 0, 0, 0, 1, &mtMinTime );
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtMinTime, &rtMinTime );
	}

	return rtMinTime;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::RecomputeTimes

void CTabFileRef::RecomputeTimes( void )
{
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		ComputeMinSecGridMs();
	}
	else
	{
		ComputeBarBeatGridTick();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::ComputeMinSecGridMs

void CTabFileRef::ComputeMinSecGridMs( void )
{
	// START
	m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
														m_PropItem.m_Item.m_rtTimePhysical,
														&m_lStartMeasure, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );
	

	if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
	{
		ASSERT( m_pIWaveTimelineDraw != NULL );
		
		REFERENCE_TIME rtDuration;
		rtDuration = m_PropItem.m_Item.m_rtDuration - m_PropItem.m_Item.PitchAdjustedStartOffset();

		// END
		m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_PropItem.m_Item.m_rtTimePhysical + rtDuration,
															&m_lEndMeasure, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );
		

		// LENGTH
		m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															rtDuration,
															&m_lLengthMeasure, &m_lLengthBeat, &m_lLengthGrid, &m_lLengthTick );

		// OFFSET
		m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_PropItem.m_Item.PitchAdjustedStartOffset(),
															&m_lOffsetMeasure, &m_lOffsetBeat, &m_lOffsetGrid, &m_lOffsetTick );
		// m_PropItem.m_Item.m_rtStartOffset is not affected by m_PropItem.m_Item.m_lPitch
		m_pIWaveTimelineDraw->RefTimeToSample( max(0, m_PropItem.m_Item.m_rtStartOffset), &m_dwOffsetNbrSamples, 0 );
		

		// SOURCE END
		m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_PropItem.m_Item.m_rtTimePhysical + m_PropItem.m_Item.m_WaveInfo.rtWaveLength,
															&m_lSourceEndMeasure, &m_lSourceEndBeat, &m_lSourceEndGrid, &m_lSourceEndTick );
		

		// SOURCE LENGTH
		REFERENCE_TIME rtTime;
		m_pIWaveTimelineDraw->SampleToRefTime( (m_PropItem.m_Item.m_WaveInfo.dwWaveEnd + 1), &rtTime, m_PropItem.m_Item.m_lPitch );
		m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															rtTime,
															&m_lSourceLengthMeasure, &m_lSourceLengthBeat, &m_lSourceLengthGrid, &m_lSourceLengthTick );
	}
	else
	{
		m_lEndMeasure = 0;
		m_lEndBeat = 0;
		m_lEndGrid = 0;
		m_lEndTick = 0;

		m_lLengthMeasure = 0;
		m_lLengthBeat = 0;
		m_lLengthGrid = 0;
		m_lLengthTick = 0;
		m_dwLengthNbrSamples = 0;

		m_lOffsetMeasure = 0;
		m_lOffsetBeat = 0;
		m_lOffsetGrid = 0;
		m_lOffsetTick = 0;
		m_dwOffsetNbrSamples = 0;

		m_lSourceEndMeasure = 0;
		m_lSourceEndBeat = 0;
		m_lSourceEndGrid = 0;
		m_lSourceEndTick = 0;

		m_lSourceLengthMeasure = 0;
		m_lSourceLengthBeat = 0;
		m_lSourceLengthGrid = 0;
		m_lSourceLengthTick = 0;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::ComputeBarBeatGridTick

void CTabFileRef::ComputeBarBeatGridTick( void )
{
	// START
	m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical,
															 &m_lStartMeasure, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );

	if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
	{
		ASSERT( m_pIWaveTimelineDraw != NULL );

		REFERENCE_TIME rtTime;
		MUSIC_TIME mtTime;

		REFERENCE_TIME rtPitchAdjustedStartOffset; 
		m_PropItem.m_Item.StartOffsetToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtPitchAdjustedStartOffset );

		MUSIC_TIME mtDuration;
		mtDuration = (MUSIC_TIME)m_PropItem.m_Item.m_rtDuration - (MUSIC_TIME)rtPitchAdjustedStartOffset;

		// END
		m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical + mtDuration,
																  &m_lEndMeasure, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );

		// LENGTH
		m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( mtDuration,
																 &m_lLengthMeasure, &m_lLengthBeat, &m_lLengthGrid, &m_lLengthTick );

		// OFFSET
		{
			MUSIC_TIME mtTime;
			MUSIC_TIME mtOffsetTime = (MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical + (MUSIC_TIME)rtPitchAdjustedStartOffset;

			m_lOffsetMeasure = 0;
			m_lOffsetBeat = 0;
			m_lOffsetGrid = 0;
			m_lOffsetTick = 0;

			do
			{
				m_lOffsetMeasure++;
				m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lStartMeasure + m_lOffsetMeasure,
																		  m_lStartBeat,
																		  m_lStartGrid,
																		  m_lStartTick,
																		  &mtTime );
			}
			while( mtTime <= mtOffsetTime ); 
			m_lOffsetMeasure--;

			do
			{
				m_lOffsetBeat++;
				m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lStartMeasure + m_lOffsetMeasure,
																		  m_lStartBeat + m_lOffsetBeat,
																		  m_lStartGrid,
																		  m_lStartTick,
																		  &mtTime );
			}
			while( mtTime <= mtOffsetTime ); 
			m_lOffsetBeat--;

			do
			{
				m_lOffsetGrid++;
				m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lStartMeasure + m_lOffsetMeasure,
																		  m_lStartBeat + m_lOffsetBeat,
																		  m_lStartGrid + m_lOffsetGrid,
																		  m_lStartTick,
																		  &mtTime );
			}
			while( mtTime <= mtOffsetTime ); 
			m_lOffsetGrid--;

			m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lStartMeasure + m_lOffsetMeasure,
																	  m_lStartBeat + m_lOffsetBeat,
																	  m_lStartGrid + m_lOffsetGrid,
																	  m_lStartTick,
																	  &mtTime );
			m_lOffsetTick = mtOffsetTime - mtTime;
		}

		// m_PropItem.m_Item.m_rtStartOffset is not affected by m_PropItem.m_Item.m_lPitch
		m_pIWaveTimelineDraw->RefTimeToSample( max(0, m_PropItem.m_Item.m_rtStartOffset), &m_dwOffsetNbrSamples, 0 );

		// SOURCE END
		REFERENCE_TIME rtActualLength;
		m_PropItem.m_Item.SourceWaveLengthToUnknownTime( m_pPropPageMgr->m_pTrackMgr, &rtActualLength );
		m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical + (MUSIC_TIME)rtActualLength, 
																  &m_lSourceEndMeasure, &m_lSourceEndBeat, &m_lSourceEndGrid, &m_lSourceEndTick );

		// SOURCE LENGTH
		REFERENCE_TIME rtTimePhysical;
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToRefTime( (MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical, &rtTimePhysical );
		m_pIWaveTimelineDraw->SampleToRefTime( (m_PropItem.m_Item.m_WaveInfo.dwWaveEnd + 1), &rtTime, m_PropItem.m_Item.m_lPitch );
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->RefTimeToClocks( (rtTimePhysical + rtTime), &mtTime );
		m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTime - (MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical,
																  &m_lSourceLengthMeasure, &m_lSourceLengthBeat, &m_lSourceLengthGrid, &m_lSourceLengthTick );
	}
	else
	{
		m_lEndMeasure = 0;
		m_lEndBeat = 0;
		m_lEndGrid = 0;
		m_lEndTick = 0;

		m_lLengthMeasure = 0;
		m_lLengthBeat = 0;
		m_lLengthGrid = 0;
		m_lLengthTick = 0;
		m_dwLengthNbrSamples = 0;

		m_lOffsetMeasure = 0;
		m_lOffsetBeat = 0;
		m_lOffsetGrid = 0;
		m_lOffsetTick = 0;
		m_dwOffsetNbrSamples = 0;

		m_lSourceEndMeasure = 0;
		m_lSourceEndBeat = 0;
		m_lSourceEndGrid = 0;
		m_lSourceEndTick = 0;

		m_lSourceLengthMeasure = 0;
		m_lSourceLengthBeat = 0;
		m_lSourceLengthGrid = 0;
		m_lSourceLengthTick = 0;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetControlRanges

void CTabFileRef::SetControlRanges( void )
{
	// Get track group bits
	DWORD dwGroupBits = 0xFFFFFFFF;
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			VARIANT variant;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Set ranges for "time" controls
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		SetRefTimeRanges();
	}
	else
	{
		SetMusicTimeRanges( dwGroupBits );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetRefTimeRanges

void CTabFileRef::SetRefTimeRanges( void )
{
	// Limit the minute number to positive numbers
	m_spinStartMeasure.SetRange( 1, 32767 );
	m_editStartMeasure.LimitText( 5 );
	m_spinEndMeasure.SetRange( 1, 32767 );
	m_editEndMeasure.LimitText( 5 );
	m_spinLengthMeasure.SetRange( 0, 32767 );
	m_editLengthMeasure.LimitText( 5 );
	m_spinOffsetMeasure.SetRange( 0, 32767 );
	m_editOffsetMeasure.LimitText( 5 );

	// Limit the second number to 1-60
	m_spinStartBeat.SetRange( 1, 60 );
	m_editStartBeat.LimitText( 2 );
	m_spinEndBeat.SetRange( 1, 60 );
	m_editEndBeat.LimitText( 2 );
	m_spinLengthBeat.SetRange( 0, 60 );
	m_editLengthBeat.LimitText( 2 );
	m_spinOffsetBeat.SetRange( 0, 60 );
	m_editOffsetBeat.LimitText( 2 );

	// Limit the grid number to MIN_NBR_GRIDS_PER_SECOND - MAX_NBR_GRIDS_PER_SECOND
	m_spinStartGrid.SetRange( MIN_NBR_GRIDS_PER_SECOND, MAX_NBR_GRIDS_PER_SECOND );
	m_editStartGrid.LimitText( 3 );
	m_spinEndGrid.SetRange( MIN_NBR_GRIDS_PER_SECOND, MAX_NBR_GRIDS_PER_SECOND );
	m_editEndGrid.LimitText( 3 );
	m_spinLengthGrid.SetRange( (MIN_NBR_GRIDS_PER_SECOND - 1), MAX_NBR_GRIDS_PER_SECOND );
	m_editLengthGrid.LimitText( 3 );
	m_spinOffsetGrid.SetRange( (MIN_NBR_GRIDS_PER_SECOND - 1), MAX_NBR_GRIDS_PER_SECOND );
	m_editOffsetGrid.LimitText( 3 );

	// Limit the millisecond number to 1-1000
	m_spinStartTick.SetRange( 1, 1000 );
	m_editStartTick.LimitText( 4 );
	m_spinEndTick.SetRange( 1, 1000 );
	m_editEndTick.LimitText( 4 );
	m_spinLengthTick.SetRange( 1, 1000 );
	m_editLengthTick.LimitText( 4 );
	m_spinOffsetTick.SetRange( 1, 1000 );
	m_editOffsetTick.LimitText( 4 );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetMusicTimeRanges

void CTabFileRef::SetMusicTimeRanges( DWORD dwGroupBits )
{
	long lMaxMeasure, lMaxBeat, lMaxGrid;

	// Get the maximum measure value
	if( m_pPropPageMgr->m_pTrackMgr->m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
		lMaxGrid = 256;
	}
	else
	{
		lMaxGrid = 256;	// Fix this!!!

		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
																	   V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pPropPageMgr->m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
																			   V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		long lItemMeasure, lItemBeat, lItemGrid, lItemTick;
		m_pPropPageMgr->m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( m_PropItem.m_Item.m_rtTimePhysical,
												&lItemMeasure, &lItemBeat, &lItemGrid, &lItemTick );

		// If the item is not in the last measure
		if( lItemMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pPropPageMgr->m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lItemMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pPropPageMgr->m_pTrackMgr->m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the item is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Update the range for the measure spin control
	m_spinStartMeasure.SetRange( 1, lMaxMeasure );
	m_editStartMeasure.LimitText( 5 );
	m_spinEndMeasure.SetRange( 1, 32767 );
	m_editEndMeasure.LimitText( 5 );
	m_spinLengthMeasure.SetRange( 0, 32767 );
	m_editLengthMeasure.LimitText( 5 );
	m_spinOffsetMeasure.SetRange( 0, 32767 );
	m_editOffsetMeasure.LimitText( 5 );

	// Update the range for the beat spin control
	m_spinStartBeat.SetRange( 1, lMaxBeat );
	m_editStartBeat.LimitText( 3 );
	m_spinEndBeat.SetRange( 1, lMaxBeat );
	m_editEndBeat.LimitText( 3 );
	m_spinLengthBeat.SetRange( 0, lMaxBeat );
	m_editLengthBeat.LimitText( 3 );
	m_spinOffsetBeat.SetRange( 0, lMaxBeat );
	m_editOffsetBeat.LimitText( 3 );

	// Update the range for the grid spin control
	m_spinStartGrid.SetRange( 1, lMaxGrid );
	m_editStartGrid.LimitText( 3 );
	m_spinEndGrid.SetRange( 1, lMaxGrid );
	m_editEndGrid.LimitText( 3 );
	m_spinLengthGrid.SetRange( 0, lMaxGrid );
	m_editLengthGrid.LimitText( 3 );
	m_spinOffsetGrid.SetRange( 0, lMaxGrid );
	m_editOffsetGrid.LimitText( 3 );

	// Update the range for the tick spin control
	m_spinStartTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editStartTick.LimitText( 5 );
	m_spinEndTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editEndTick.LimitText( 5 );
	m_spinLengthTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editLengthTick.LimitText( 5 );
	m_spinOffsetTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editOffsetTick.LimitText( 5 );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetFileComboBoxSelection

void CTabFileRef::SetFileComboBoxSelection( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPropPageMgr->m_pIFramework != NULL );

	IDMUSProdProject* pIProject = NULL;
	CString strText;
	int nMatch;
	int nCount;
	int nCurPos;
	int nPos = -1;

	if( m_PropItem.m_dwUndetermined_TabFileRef & UNDT_DOCROOT )
	{
		goto LEAVE;
	}

	if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
	{
		// Create a FileListInfo struct for the current file
		DMUSProdListInfo ListInfo;
		FileListInfo* pFileListInfo;

		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		pFileListInfo = new FileListInfo;
		if( pFileListInfo == NULL )
		{
			goto LEAVE;
		}

		m_pPropPageMgr->m_pIFramework->GetNodeFileGUID ( m_PropItem.m_Item.m_FileRef.pIDocRootNode, &pFileListInfo->guidFile );

		if( SUCCEEDED ( m_PropItem.m_Item.m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
		{
			if( ListInfo.bstrName )
			{
				pFileListInfo->strName = ListInfo.bstrName;
				::SysFreeString( ListInfo.bstrName );
			}
			
			if( ListInfo.bstrDescriptor )
			{
				pFileListInfo->strDescriptor = ListInfo.bstrDescriptor;
				::SysFreeString( ListInfo.bstrDescriptor );
			}

			if( FAILED ( m_pPropPageMgr->m_pIFramework->FindProject( m_PropItem.m_Item.m_FileRef.pIDocRootNode, &pIProject ) ) )
			{
				delete pFileListInfo;
				goto LEAVE;
			}

			pFileListInfo->pIProject = pIProject;
//			pFileListInfo->pIProject->AddRef();	intentionally missing

			BSTR bstrProjectName;
			if( FAILED ( pIProject->GetName( &bstrProjectName ) ) )
			{
				delete pFileListInfo;
				goto LEAVE;
			}

			pFileListInfo->strProjectName = bstrProjectName;
			::SysFreeString( bstrProjectName );
		}
		else
		{
			delete pFileListInfo;
			goto LEAVE;
		}

		// Select the file in the combo box list
		nMatch = CB_ERR;
		nCount = m_comboFile.GetCount();
		for( nCurPos = 0 ;  nCurPos < nCount ;  nCurPos++ )
		{
			FileListInfo* pCurFileListInfo = (FileListInfo *)m_comboFile.GetItemDataPtr( nCurPos );
			if( pCurFileListInfo )
			{
				if( pCurFileListInfo != (FileListInfo *)-1 )
				{
					// See if GUIDs are equal
					if( ::IsEqualGUID( pCurFileListInfo->guidFile, pFileListInfo->guidFile ) )
					{
						nMatch = nCurPos;
						break;
					}
				}
			}
		}

		if( nMatch == CB_ERR )
		{
			FileListInfo* pSLI;

			// Delete old FileInfo list
			while( !m_lstFileListInfo.IsEmpty() )
			{
				pSLI = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
				delete pSLI;
			}

			// Remove old list from combo box
			m_comboFile.ResetContent();

			// Add this file to the combo box list
			nPos = 0;
			m_lstFileListInfo.AddTail( pFileListInfo );
			InsertFileInfoListInComboBox();
		}
		else
		{
			nPos = nMatch;
			delete pFileListInfo;
			pFileListInfo = NULL;
		}
	}

LEAVE:
	m_comboFile.SetCurSel( nPos );

	if( m_PropItem.m_dwUndetermined_TabFileRef & UNDT_DOCROOT )
	{
		m_comboFile.SetWindowText( g_pstrUnknown );
	}

	if( pIProject )
	{
		pIProject->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::GetFileComboBoxText

void CTabFileRef::GetFileComboBoxText( const FileListInfo* pFileListInfo, CString& strText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pFileListInfo->strProjectName.IsEmpty() )
	{
		strText.Format( "%s %s", pFileListInfo->strName, pFileListInfo->strDescriptor );
	}
	else
	{
		strText.Format( "%s: %s %s", pFileListInfo->strProjectName, pFileListInfo->strName, pFileListInfo->strDescriptor );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::InsertFileInfoListInComboBox

void CTabFileRef::InsertFileInfoListInComboBox( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strText;
	FileListInfo* pFileListInfo;
	int nPos;

	POSITION pos = m_lstFileListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.GetNext(pos) );
		if( pFileListInfo )
		{
			GetFileComboBoxText( pFileListInfo, strText );
			nPos = m_comboFile.AddString( strText );
			if( nPos >= 0 )
			{
				m_comboFile.SetItemDataPtr( nPos, pFileListInfo );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::InsertFileInfo

void CTabFileRef::InsertFileInfo( FileListInfo* pFileListInfo )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	FileListInfo* pListInfo;
	CString strListText;
	CString strFileText;
	POSITION posList;

	GetFileComboBoxText( pFileListInfo, strFileText );

	POSITION pos = m_lstFileListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		posList = pos;

		pListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.GetNext(pos) );
		if( pListInfo )
		{
			if( !pFileListInfo->strProjectName.IsEmpty()
			&&  pListInfo->strProjectName.IsEmpty() )
			{
				continue;
			}

			if( pFileListInfo->strProjectName.IsEmpty()
			&&  !pListInfo->strProjectName.IsEmpty() )
			{
				if( pos )
				{
					m_lstFileListInfo.InsertBefore( pos, pFileListInfo );
				}
				else
				{
					m_lstFileListInfo.AddTail( pFileListInfo );
				}
				return;
			}

			GetFileComboBoxText( pListInfo, strListText );

			if( strListText.CompareNoCase( strFileText ) > 0 )
			{
				m_lstFileListInfo.InsertBefore( posList, pFileListInfo );
				return;
			}
		}
	}

	m_lstFileListInfo.AddTail( pFileListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::BuildFileInfoList

void CTabFileRef::BuildFileInfoList( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdProject* pINextProject;
	IDMUSProdNode* pIFileNode;
	IDMUSProdNode* pINextFileNode;
	BSTR bstrProjectName;
	GUID guidProject;
	DMUSProdListInfo ListInfo;
	FileListInfo* pFileListInfo;

	HRESULT hr;

	hr = m_pPropPageMgr->m_pIFramework->FindDocTypeByNodeId( GUID_WaveNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		return;
	}

	// Get GUID for the DocRoot containing this Wave track (i.e. Segment's DocRoot node)
	IDMUSProdNode* pIMyDocRootNode;
	GUID guidMyDocRoot;
	hr = m_pPropPageMgr->m_pTrackMgr->GetParam( GUID_DocRootNode, 0, 0, &pIMyDocRootNode );
	if( FAILED ( hr ) )
	{
		ASSERT( 0 );
		return;
	}
	hr = m_pPropPageMgr->m_pIFramework->GetNodeFileGUID( pIMyDocRootNode, &guidMyDocRoot );
	if( FAILED ( hr ) )
	{
		ASSERT( 0 );
		return;
	}
	RELEASE( pIMyDocRootNode );

	// Build the list of files
	hr = m_pPropPageMgr->m_pIFramework->GetFirstProject( &pINextProject );

	while( SUCCEEDED( hr )  &&  pINextProject )
    {
		pIProject = pINextProject;

		HRESULT hr = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

		while( hr == S_OK )
		{
			pIFileNode = pINextFileNode;

			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{
				pFileListInfo = new FileListInfo;

				pFileListInfo->pIProject = pIProject;
//				pFileListInfo->pIProject->AddRef();	intentionally missing

				if( SUCCEEDED ( pIProject->GetGUID( &guidProject ) ) )
				{
					if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
					{
						pFileListInfo->strProjectName = bstrProjectName;
						::SysFreeString( bstrProjectName );
					}

				}

				if( ListInfo.bstrName )
				{
					pFileListInfo->strName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				
				if( ListInfo.bstrDescriptor )
				{
					pFileListInfo->strDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );
				}

				// Update DocRoot file GUID
				m_pPropPageMgr->m_pIFramework->GetNodeFileGUID ( pIFileNode, &pFileListInfo->guidFile );

				if( ::IsEqualGUID(pFileListInfo->guidFile, guidMyDocRoot) )
				{
					// Prevent circular references!
					// Do not include DocRoot containing this Wave Track in the file list
					delete pFileListInfo;
				}
				else
				{
					InsertFileInfo( pFileListInfo );
				}

				hr = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
				pIFileNode->Release();
			}
			else
			{
				hr = E_FAIL;
			}
		}
	
	    hr = m_pPropPageMgr->m_pIFramework->GetNextProject( pIProject, &pINextProject );
		pIProject->Release();
	}

	pIDocType->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnCreate

int CTabFileRef::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDestroy

void CTabFileRef::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnInitDialog

BOOL CTabFileRef::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	// Set lock button bitmaps
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr )
	{
		CBitmap* pBitmap = m_pPropPageMgr->m_pTrackMgr->GetLockBitmap( 0 );
		if( pBitmap )
		{
			m_btnLockEnd.SetBitmap( (HBITMAP)pBitmap->GetSafeHandle() );
			m_btnLockLength.SetBitmap( (HBITMAP)pBitmap->GetSafeHandle() );
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinStartTick

void CTabFileRef::OnSpinStartTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartTick ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinStartGrid

void CTabFileRef::OnSpinStartGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartGrid ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinStartBeat

void CTabFileRef::OnSpinStartBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartBeat ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinStartMeasure

void CTabFileRef::OnSpinStartMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartMeasure ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinEndTick

void CTabFileRef::OnSpinEndTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndTick ) )
	{
		SetEnd( EndToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinEndGrid

void CTabFileRef::OnSpinEndGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndGrid ) )
	{
		SetEnd( EndToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinEndBeat

void CTabFileRef::OnSpinEndBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndBeat ) )
	{
		SetEnd( EndToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinEndMeasure

void CTabFileRef::OnSpinEndMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndMeasure ) )
	{
		SetEnd( EndToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinLengthTick

void CTabFileRef::OnSpinLengthTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLengthTick ) )
	{
		SetLength( LengthToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinLengthGrid

void CTabFileRef::OnSpinLengthGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLengthGrid ) )
	{
		SetLength( LengthToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinLengthBeat

void CTabFileRef::OnSpinLengthBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLengthBeat ) )
	{
		SetLength( LengthToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinLengthMeasure

void CTabFileRef::OnSpinLengthMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLengthMeasure ) )
	{
		SetLength( LengthToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinOffsetTick

void CTabFileRef::OnSpinOffsetTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusOffsetTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lOffsetTick ) )
	{
		SetOffset( OffsetToRefTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinOffsetGrid

void CTabFileRef::OnSpinOffsetGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusOffsetGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lOffsetGrid ) )
	{
		SetOffset( OffsetToRefTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinOffsetBeat

void CTabFileRef::OnSpinOffsetBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusOffsetBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lOffsetBeat ) )
	{
		SetOffset( OffsetToRefTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSpinOffsetMeasure

void CTabFileRef::OnSpinOffsetMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusOffsetMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_lOffsetMeasure ) )
	{
		SetOffset( OffsetToRefTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CTabFileRef::HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		fChanged = true;
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusStartTick

void CTabFileRef::OnKillFocusStartTick() 
{
	if( HandleKillFocus( m_spinStartTick, m_lStartTick, 0 ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusStartGrid

void CTabFileRef::OnKillFocusStartGrid() 
{
	if( HandleKillFocus( m_spinStartGrid, m_lStartGrid, 1 ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusStartBeat

void CTabFileRef::OnKillFocusStartBeat() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinStartBeat, m_lStartBeat, nOffset ) )
	{
		SetStart( StartToUnknownTime() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusStartMeasure

void CTabFileRef::OnKillFocusStartMeasure() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinStartMeasure, m_lStartMeasure, nOffset ) )
	{
		SetStart( StartToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusEndTick

void CTabFileRef::OnKillFocusEndTick() 
{
	if( HandleKillFocus( m_spinEndTick, m_lEndTick, 0 ) )
	{
		SetEnd( EndToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusEndGrid

void CTabFileRef::OnKillFocusEndGrid() 
{
	if( HandleKillFocus( m_spinEndGrid, m_lEndGrid, 1 ) )
	{
		SetEnd( EndToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusEndBeat

void CTabFileRef::OnKillFocusEndBeat() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinEndBeat, m_lEndBeat, nOffset ) )
	{
		SetEnd( EndToUnknownTime() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusEndMeasure

void CTabFileRef::OnKillFocusEndMeasure() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinEndMeasure, m_lEndMeasure, nOffset ) )
	{
		SetEnd( EndToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusLengthTick

void CTabFileRef::OnKillFocusLengthTick() 
{
	if( HandleKillFocus( m_spinLengthTick, m_lLengthTick, 0 ) )
	{
		SetLength( LengthToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusLengthGrid

void CTabFileRef::OnKillFocusLengthGrid() 
{
	if( HandleKillFocus( m_spinLengthGrid, m_lLengthGrid, 0 ) )
	{
		SetLength( LengthToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusLengthBeat

void CTabFileRef::OnKillFocusLengthBeat() 
{
	if( HandleKillFocus( m_spinLengthBeat, m_lLengthBeat, 0 ) )
	{
		SetLength( LengthToUnknownTime() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusLengthMeasure

void CTabFileRef::OnKillFocusLengthMeasure() 
{
	if( HandleKillFocus( m_spinLengthMeasure, m_lLengthMeasure, 0 ) )
	{
		SetLength( LengthToUnknownTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusOffsetTick

void CTabFileRef::OnKillFocusOffsetTick() 
{
	if( HandleKillFocus( m_spinOffsetTick, m_lOffsetTick, 0 ) )
	{
		SetOffset( OffsetToRefTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusOffsetGrid

void CTabFileRef::OnKillFocusOffsetGrid() 
{
	if( HandleKillFocus( m_spinOffsetGrid, m_lOffsetGrid, 0 ) )
	{
		SetOffset( OffsetToRefTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusOffsetBeat

void CTabFileRef::OnKillFocusOffsetBeat() 
{
	if( HandleKillFocus( m_spinOffsetBeat, m_lOffsetBeat, 0 ) )
	{
		SetOffset( OffsetToRefTime() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillFocusOffsetMeasure

void CTabFileRef::OnKillFocusOffsetMeasure() 
{
	if( HandleKillFocus( m_spinOffsetMeasure, m_lOffsetMeasure, 0 ) )
	{
		SetOffset( OffsetToRefTime() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabFileRef::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( lUpdateVal != 0 )
		{
			// Update the item with the new value
			lUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lUpdateVal != (lNewValue - nOffset) )
			{
				// Update the item with the new value
				lUpdateVal = (lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::UpdateObject

void CTabFileRef::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *)&m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::EnableControls

void CTabFileRef::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if the Beat edit control exists
	if( m_editStartBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	BOOL fEnableFileCombo = fEnable;
	BOOL fEnableStartTime = fEnable;

	if( fEnable )
	{
		if( m_PropItem.m_dwBits & PROPF_MULTIPLESELECT )
		{
			fEnable = FALSE;
			fEnableStartTime = FALSE;
		}
		else if( m_PropItem.m_Item.m_FileRef.pIDocRootNode == NULL )
		{
			// No DocRoot, so disable remaining controls
			fEnable = FALSE;
		}
	}

	// Reference time or music time?
	CString strPrompt;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		strPrompt.LoadString( IDS_MIN_TEXT );
		m_staticPromptBar.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_SEC_TEXT );
		m_staticPromptBeat.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_GRID_TEXT );
		m_staticPromptGrid.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_MS_TEXT );
		m_staticPromptTick.SetWindowText( strPrompt );
	}
	else
	{
		strPrompt.LoadString( IDS_BAR_TEXT );
		m_staticPromptBar.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_BEAT_TEXT );
		m_staticPromptBeat.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_GRID_TEXT );
		m_staticPromptGrid.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_TICK_TEXT );
		m_staticPromptTick.SetWindowText( strPrompt );
	}

	// Update the controls with the new window state
	m_comboFile.EnableWindow( fEnableFileCombo );
	m_btnLockEnd.EnableWindow( fEnable );
	m_btnLockLength.EnableWindow( fEnable );

	m_spinStartTick.EnableWindow( fEnableStartTime );
	m_spinStartGrid.EnableWindow( fEnableStartTime );
	m_spinStartBeat.EnableWindow( fEnableStartTime );
	m_spinStartMeasure.EnableWindow( fEnableStartTime );
	m_editStartTick.EnableWindow( fEnableStartTime );
	m_editStartGrid.EnableWindow( fEnableStartTime );
	m_editStartBeat.EnableWindow( fEnableStartTime );
	m_editStartMeasure.EnableWindow( fEnableStartTime );

	m_spinEndTick.EnableWindow( fEnable );
	m_spinEndGrid.EnableWindow( fEnable );
	m_spinEndBeat.EnableWindow( fEnable );
	m_spinEndMeasure.EnableWindow( fEnable );
	m_editEndTick.EnableWindow( fEnable );
	m_editEndGrid.EnableWindow( fEnable );
	m_editEndBeat.EnableWindow( fEnable );
	m_editEndMeasure.EnableWindow( fEnable );

	m_spinLengthTick.EnableWindow( fEnable );
	m_spinLengthGrid.EnableWindow( fEnable );
	m_spinLengthBeat.EnableWindow( fEnable );
	m_spinLengthMeasure.EnableWindow( fEnable );
	m_editLengthTick.EnableWindow( fEnable );
	m_editLengthGrid.EnableWindow( fEnable );
	m_editLengthBeat.EnableWindow( fEnable );
	m_editLengthMeasure.EnableWindow( fEnable );

	m_spinOffsetTick.EnableWindow( fEnable );
	m_spinOffsetGrid.EnableWindow( fEnable );
	m_spinOffsetBeat.EnableWindow( fEnable );
	m_spinOffsetMeasure.EnableWindow( fEnable );
	m_editOffsetTick.EnableWindow( fEnable );
	m_editOffsetGrid.EnableWindow( fEnable );
	m_editOffsetBeat.EnableWindow( fEnable );
	m_editOffsetMeasure.EnableWindow( fEnable );

	if( m_PropItem.m_dwUndetermined_TabFileRef & UNDT_DOCROOT )
	{
		int nPos = m_comboFile.AddString( g_pstrUnknown );
		m_comboFile.SetCurSel( nPos );
	}

	// Clear the controls that we're disabling
	if( !fEnableStartTime )
	{
		m_editStartTick.SetWindowText( NULL );
		m_editStartGrid.SetWindowText( NULL );
		m_editStartBeat.SetWindowText( NULL );
		m_editStartMeasure.SetWindowText( NULL );
	}

	if( !fEnable )
	{
		m_comboFile.SetCurSel( -1 );

		m_editEndTick.SetWindowText( NULL );
		m_editEndGrid.SetWindowText( NULL );
		m_editEndBeat.SetWindowText( NULL );
		m_editEndMeasure.SetWindowText( NULL );

		m_editLengthTick.SetWindowText( NULL );
		m_editLengthGrid.SetWindowText( NULL );
		m_editLengthBeat.SetWindowText( NULL );
		m_editLengthMeasure.SetWindowText( NULL );
		m_staticLengthNbrSamples.SetWindowText( NULL );

		m_editOffsetTick.SetWindowText( NULL );
		m_editOffsetGrid.SetWindowText( NULL );
		m_editOffsetBeat.SetWindowText( NULL );
		m_editOffsetMeasure.SetWindowText( NULL );
		m_staticOffsetNbrSamples.SetWindowText( NULL );

		m_staticSourceEndTick.SetWindowText( NULL );
		m_staticSourceEndGrid.SetWindowText( NULL );
		m_staticSourceEndBeat.SetWindowText( NULL );
		m_staticSourceEndMeasure.SetWindowText( NULL );

		m_staticSourceLengthTick.SetWindowText( NULL );
		m_staticSourceLengthGrid.SetWindowText( NULL );
		m_staticSourceLengthBeat.SetWindowText( NULL );
		m_staticSourceLengthMeasure.SetWindowText( NULL );
		m_staticSourceLengthNbrSamples.SetWindowText( NULL );

		if( m_pPropPageMgr
		&&  m_pPropPageMgr->m_pTrackMgr )
		{
			CBitmap* pBitmap = m_pPropPageMgr->m_pTrackMgr->GetLockBitmap( 0 );
			if( pBitmap )
			{
				m_btnLockLength.SetBitmap( (HBITMAP)pBitmap->GetSafeHandle() );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void CTabFileRef::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDropDownComboFile

void CTabFileRef::OnDropDownComboFile() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Delete old FileInfo list
	FileListInfo* pFileListInfo;
	while( !m_lstFileListInfo.IsEmpty() )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
		delete pFileListInfo;
	}

	// Remove old list from combo box
	m_comboFile.ResetContent();

	// Rebuild the FileInfo list
	BuildFileInfoList();
	InsertFileInfoListInComboBox();

	// Select the current file
	SetFileComboBoxSelection();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSelChangeComboFile

void CTabFileRef::OnSelChangeComboFile() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPropPageMgr->m_pIFramework != NULL );

	if( m_fIgnoreSelChange )
	{
		return;
	}

	int nItem = m_comboFile.GetCurSel();
	if( nItem != CB_ERR )
	{
		FileListInfo* pFileListInfo = (FileListInfo *)m_comboFile.GetItemDataPtr( nItem );
		if( pFileListInfo != (FileListInfo *)-1 )
		{
			// fill in appropriate fields
			m_PropItem.m_Item.m_FileRef.li = *pFileListInfo;

			IDMUSProdNode* pIDocRootNode = NULL;
			
			// NOTE: Items must currently be selected to avoid killing
			// the property page while making this call
			if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindDocRootNodeByFileGUID( pFileListInfo->guidFile, &pIDocRootNode ) ) )
			{
				if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
				{
					m_PropItem.m_Item.m_FileRef.pIDocRootNode->Release();
					m_PropItem.m_Item.m_FileRef.pIDocRootNode = NULL;
				}
				
				m_PropItem.m_Item.m_FileRef.pIDocRootNode = pIDocRootNode;
				if( m_PropItem.m_Item.m_FileRef.pIDocRootNode )
				{
					m_PropItem.m_Item.m_FileRef.pIDocRootNode->AddRef();
				}

				m_PropItem.m_dwChanged = CHGD_DOCROOT;
				UpdateObject();

				pIDocRootNode->Release();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSetActive

BOOL CTabFileRef::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh the page
	if(	m_fValidTrackItem )
	{
		SetPropTrackItem( &m_PropItem );
	}
	else
	{
		SetPropTrackItem( NULL );
	}

	if( m_pPropPageMgr 
	&&  m_pPropPageMgr->m_pTrackMgr 
	&&  m_pPropPageMgr->m_pIPropSheet )
	{
		m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CPropPageMgrItem::sm_nActiveTab );
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnLockEnd

void CTabFileRef::OnLockEnd() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the Loop check box exists
	if( m_btnLockEnd.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the item with the new value
	m_PropItem.m_Item.m_fLockEndUI = !m_PropItem.m_Item.m_fLockEndUI;

	// Now, update the object with the new value
	m_PropItem.m_dwChanged = CHGD_LOCK_END;
	UpdateObject();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDoubleClickedLockEnd

void CTabFileRef::OnDoubleClickedLockEnd() 
{
	OnLockEnd();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnLockLength

void CTabFileRef::OnLockLength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the Loop check box exists
	if( m_btnLockLength.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the item with the new value
	m_PropItem.m_Item.m_fLockLengthUI = !m_PropItem.m_Item.m_fLockLengthUI;

	// Now, update the object with the new value
	m_PropItem.m_dwChanged = CHGD_LOCK_LENGTH;
	UpdateObject();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDoubleClickedLockLength

void CTabFileRef::OnDoubleClickedLockLength() 
{
	OnLockLength();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabLoop.h ===
#if !defined(AFX_TABLOOP_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_TABLOOP_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

// TabLoop.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CPropPageMgrItem;
class CPropTrackItem;
class CTabOnReturnEdit;


/////////////////////////////////////////////////////////////////////////////
// CTabLoop dialog

class CTabLoop : public CPropertyPage
{
	friend CPropPageMgrItem;
	DECLARE_DYNCREATE(CTabLoop)

// Construction
public:
	CTabLoop();
	~CTabLoop();

// Dialog Data
	//{{AFX_DATA(CTabLoop)
	enum { IDD = IDD_PROPPAGE_WAVE_LOOP };
	CButton	m_checkLoop;
	CButton	m_btnLockLength;
	CStatic	m_staticPromptGrid;
	CStatic	m_staticPromptTick;
	CStatic	m_staticPromptBeat;
	CStatic	m_staticPromptBar;
	CEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartMeasure;
	CEdit	m_editStartSample;
	CEdit	m_editEndTick;
	CEdit	m_editEndGrid;
	CEdit	m_editEndBeat;
	CEdit	m_editEndMeasure;
	CEdit	m_editEndSample;
	CEdit	m_editLengthTick;
	CEdit	m_editLengthGrid;
	CEdit	m_editLengthBeat;
	CEdit	m_editLengthMeasure;
	CEdit	m_editLengthNbrSamples;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartMeasure;
	CSpinButtonCtrl	m_spinStartSample;
	CSpinButtonCtrl	m_spinEndTick;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndMeasure;
	CSpinButtonCtrl	m_spinEndSample;
	CSpinButtonCtrl	m_spinLengthTick;
	CSpinButtonCtrl	m_spinLengthGrid;
	CSpinButtonCtrl	m_spinLengthBeat;
	CSpinButtonCtrl	m_spinLengthMeasure;
	CSpinButtonCtrl	m_spinLengthNbrSamples;
	CStatic	m_staticSourceStartTick;
	CStatic	m_staticSourceStartGrid;
	CStatic	m_staticSourceStartBeat;
	CStatic	m_staticSourceStartMeasure;
	CStatic	m_staticSourceStartSample;
	CStatic	m_staticSourceEndTick;
	CStatic	m_staticSourceEndGrid;
	CStatic	m_staticSourceEndBeat;
	CStatic	m_staticSourceEndMeasure;
	CStatic	m_staticSourceEndSample;
	CStatic	m_staticSourceLengthTick;
	CStatic	m_staticSourceLengthGrid;
	CStatic	m_staticSourceLengthBeat;
	CStatic	m_staticSourceLengthMeasure;
	CStatic	m_staticSourceLengthNbrSamples;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabLoop)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTabLoop)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSpinStartTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartSample(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndSample(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLengthNbrSamples(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusStartTick();
	afx_msg void OnKillFocusStartGrid();
	afx_msg void OnKillFocusStartBeat();
	afx_msg void OnKillFocusStartMeasure();
	afx_msg void OnKillFocusStartSample();
	afx_msg void OnKillFocusEndTick();
	afx_msg void OnKillFocusEndGrid();
	afx_msg void OnKillFocusEndBeat();
	afx_msg void OnKillFocusEndMeasure();
	afx_msg void OnKillFocusEndSample();
	afx_msg void OnKillFocusLengthTick();
	afx_msg void OnKillFocusLengthGrid();
	afx_msg void OnKillFocusLengthBeat();
	afx_msg void OnKillFocusLengthMeasure();
	afx_msg void OnKillFocusLengthNbrSamples();
	virtual void OnOK();
	afx_msg void OnCheckLoop();
	afx_msg void OnDoubleClickedCheckLoop();
	afx_msg void OnDoubleClickedLockLength();
	afx_msg void OnLockLength();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetPropTrackItem( const CPropTrackItem* pPropItem );

protected:
	void UpdateObject();
	void EnableControls( BOOL fEnable );
	bool HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );
	bool HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, DWORD& dwUpdateVal );
	bool HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset );
	bool HandleKillFocus( CEdit& edit, DWORD& dwUpdateVal, int nOffset );
	void SetEditControl( CEdit& edit, long lValue, int nOffset );
	void SetStaticControl( CStatic& stat, long lValue, int nOffset );

	void SetLoopStart( DWORD dwNewLoopStart );
	void SetLoopEnd( DWORD dwNewLoopEnd );
	void SetLoopLength( DWORD dwNewLoopLength );
	void EnforceLoopBoundaries( DWORD& dwNewLoopStart, DWORD& dwNewLoopEnd );

	DWORD StartTimeToSample();
	DWORD EndTimeToSample();
	DWORD LengthTimeToNbrSamples();
	
	void RecomputeLoopTimes();
	void SampleToRefTime();
	void SampleToMusicTime();
	
	void SetControlRanges();
	void SetMusicTimeRanges( DWORD dwGroupBits );
	void SetRefTimeRanges();

	IDMUSProdTimeline*			m_pTimeline;		// Weak timeline reference
	CPropPageMgrItem*			m_pPropPageMgr;
	IDMUSProdWaveTimelineDraw*	m_pIWaveTimelineDraw;

	CPropTrackItem				m_PropItem;

	BOOL		m_fNeedToDetach;
	BOOL		m_fValidTrackItem;

	long		m_lStartMeasure;
	long		m_lStartBeat;
	long		m_lStartGrid;
	long		m_lStartTick;

	long		m_lEndMeasure;
	long		m_lEndBeat;
	long		m_lEndGrid;
	long		m_lEndTick;

	long		m_lLengthMeasure;
	long		m_lLengthBeat;
	long		m_lLengthGrid;
	long		m_lLengthTick;
	DWORD		m_dwLengthNbrSamples;

	long		m_lSourceStartMeasure;
	long		m_lSourceStartBeat;
	long		m_lSourceStartGrid;
	long		m_lSourceStartTick;

	long		m_lSourceEndMeasure;
	long		m_lSourceEndBeat;
	long		m_lSourceEndGrid;
	long		m_lSourceEndTick;

	long		m_lSourceLengthMeasure;
	long		m_lSourceLengthBeat;
	long		m_lSourceLengthGrid;
	long		m_lSourceLengthTick;
	DWORD		m_dwSourceLengthNbrSamples;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABLOOP_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabPerformance.cpp ===
// TabPerformance.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropTrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabPerformance.h"
#include <dmusici.h>
#include <dmusicf.h>
#include <math.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15


static const TCHAR g_pstrUnknown[11] = _T("----------");


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance property page

IMPLEMENT_DYNCREATE(CTabPerformance, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CTabPerformance constructor/destructor

CTabPerformance::CTabPerformance():
	CPropertyPage(CTabPerformance::IDD), CSliderCollection(4),
	m_pmsAttenuation(NULL), m_pmsFineTune(NULL)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_PROPPAGE_WAVE_PERFORMANCE);
	//{{AFX_DATA_INIT(CTabPerformance)
	//}}AFX_DATA_INIT

    m_pmsAttenuationRange = NULL;
    m_lAttenuationRange = 0;
    m_pmsFineTuneRange = NULL;
    m_lFineTuneRange = 0;

    // Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidTrackItem = FALSE;
	m_fNeedToDetach = FALSE;

	m_lAttenuation = 0;
	m_lFineTune = 0;

	m_lLogicalMeasure = 0;
	m_lLogicalBeat = 0;

	CSliderCollection::Init(this);
}

CTabPerformance::~CTabPerformance()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::DoDataExchange

void CTabPerformance::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CTabPerformance)
	DDX_Control(pDX, IDC_DB_ATTENUATION_RANGE, m_dbAttenuationRange);
	DDX_Control(pDX, IDC_ATTENUATION_RANGE, m_AttenuationRange);
	DDX_Control(pDX, IDC_CHECK_IGNORE_LOOPING, m_checkIgnoreLooping);
	DDX_Control(pDX, IDC_EDIT_BELONGS_BEAT, m_editLogicalBeat);
	DDX_Control(pDX, IDC_SPIN_BELONGS_BEAT, m_spinLogicalBeat);
	DDX_Control(pDX, IDC_SPIN_BELONGS_BAR, m_spinLogicalMeasure);
	DDX_Control(pDX, IDC_EDIT_BELONGS_BAR, m_editLogicalMeasure);
	DDX_Control(pDX, IDC_CHECK_NOINVALIDATE, m_checkNoInvalidate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabPerformance, CPropertyPage)
	//{{AFX_MSG_MAP(CTabPerformance)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_HSCROLL()
	ON_BN_CLICKED(IDC_CHECK_NOINVALIDATE, OnCheckNoInvalidate)
	ON_BN_DOUBLECLICKED(IDC_CHECK_NOINVALIDATE, OnDoubleClickedCheckNoInvalidate)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_BAR, OnSpinLogicalMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_BEAT, OnSpinLogicalBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_BAR, OnKillFocusLogicalMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_BEAT, OnKillFocusLogicalBeat)
	ON_BN_CLICKED(IDC_CHECK_IGNORE_LOOPING, OnCheckIgnoreLooping)
	ON_BN_DOUBLECLICKED(IDC_CHECK_IGNORE_LOOPING, OnDoubleclickedCheckIgnoreLooping)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabPerformance custom functions

/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::SetPropTrackItem

void CTabPerformance::SetPropTrackItem( const CPropTrackItem* pPropItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	if( pPropItem == NULL
	||  pPropItem->m_Item.m_FileRef.pIDocRootNode == NULL )
	{
		m_fValidTrackItem = FALSE;
		m_PropItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pinter to our Property Page Object
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip mangaer for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid item
	m_fValidTrackItem = TRUE;

	// Copy the information from the new item
	m_PropItem.Copy( pPropItem );
	m_PropItem.m_nPropertyTab = TAB_PERFORMANCE;
	m_PropItem.m_dwChanged = 0;

	// Compute values for controls displaying "time"
	// Determine measure, beat
	m_lLogicalMeasure = 0;
	m_lLogicalBeat = 0;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() == false )
	{
		long lGrid, lTick;
		m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_PropItem.m_Item.m_rtTimeLogical,
																  &m_lLogicalMeasure, &m_lLogicalBeat, &lGrid, &lTick );
	}

	// Check to see if the controls have been created
	if( m_pmsAttenuation == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the controls
	EnableControls( TRUE );

	// Set volume control
	if( m_PropItem.m_dwUndetermined_TabPerformance & UNDT_VOLUME )
	{
		m_lAttenuation = 0;
		m_pmsAttenuation->SetUndetermined(this);
	}
	else
	{
		m_lAttenuation = (m_PropItem.m_Item.m_lVolume << 16) / 10;
		m_pmsAttenuation->SetValue(this, m_lAttenuation);
	}

	// Set fine tune control
	if( m_PropItem.m_dwUndetermined_TabPerformance & UNDT_PITCH )
	{
		m_lFineTune = 0;
		m_pmsFineTune->SetUndetermined(this);
	}
	else
	{
		m_lFineTune = (m_PropItem.m_Item.m_lPitch << 16);
		m_pmsFineTune->SetValue(this, m_lFineTune);
	}

    // Set volume control
	if( m_PropItem.m_dwUndetermined_TabPerformance & UNDT_VOLUME_RANGE )
	{
		m_lAttenuationRange = 0;
		m_pmsAttenuationRange->SetUndetermined(this);
	}
	else
	{
		m_lAttenuationRange = (m_PropItem.m_Item.m_lVolumeRange << 16) / 10;
		m_pmsAttenuationRange->SetValue(this, m_lAttenuationRange);
	}

	// Set fine tune control
	if( m_PropItem.m_dwUndetermined_TabPerformance & UNDT_PITCH_RANGE )
	{
		m_lFineTuneRange = 0;
		m_pmsFineTuneRange->SetUndetermined(this);
	}
	else
	{
		m_lFineTuneRange = (m_PropItem.m_Item.m_lPitchRange << 16) / 10;
		m_pmsFineTuneRange->SetValue(this, m_lFineTuneRange);
	}

    // Set DMUS_WAVEF_NOINVALIDATE 
	if( m_PropItem.m_dwUndetermined_TabPerformance & UNDT_WAVEF_NOINVALIDATE )
	{
		m_checkNoInvalidate.SetCheck( 2 );
	}
	else
	{
		m_checkNoInvalidate.SetCheck( (m_PropItem.m_Item.m_dwFlagsDM & DMUS_WAVEF_NOINVALIDATE) ? 1 : 0 );
	}

	// Set DMUS_WAVEF_IGNORELOOPS 
	if( m_PropItem.m_dwUndetermined_TabPerformance & UNDT_WAVEF_IGNORELOOPS )
	{
		m_checkIgnoreLooping.SetCheck( 2 );
	}
	else
	{
		m_checkIgnoreLooping.SetCheck( (m_PropItem.m_Item.m_dwFlagsDM & DMUS_WAVEF_IGNORELOOPS) ? 1 : 0 );
	}

    // Set BELONGS TO controls
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() == false )
	{
		if( m_PropItem.m_dwUndetermined_TabPerformance & UNDT_TIME_LOGICAL )
		{
			m_editLogicalMeasure.SetWindowText( g_pstrUnknown );
			m_editLogicalBeat.SetWindowText( g_pstrUnknown );
		}
		else
		{
			SetEditControl( m_editLogicalMeasure, m_lLogicalMeasure, 1 );
			SetEditControl( m_editLogicalBeat, m_lLogicalBeat, 1 );
		}
	}

	// Set ranges of spin controls
	SetControlRanges();
}
	

/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::SetEditControl

void CTabPerformance::SetEditControl( CEdit& edit, long lValue, int nOffset )
{
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	BOOL fTransSuccess;

	edit.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Convert from text to an integer
	long lCurValue = GetDlgItemInt( edit.GetDlgCtrlID(), &fTransSuccess, TRUE );

	// Check if the conversion failed, the text is empty, or if the values are different
	if( !fTransSuccess
	|| (tcstrTmp[0] == NULL)
	|| (lCurValue != lValue + nOffset) )
	{
		// Update the displayed number
		SetDlgItemInt( edit.GetDlgCtrlID(), lValue + nOffset );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::SetControlRanges

void CTabPerformance::SetControlRanges( void )
{
	// Get track group bits
	DWORD dwGroupBits = 0xFFFFFFFF;
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			VARIANT variant;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Set ranges for "time" controls
	SetMusicTimeRanges( dwGroupBits );
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::SetMusicTimeRanges

void CTabPerformance::SetMusicTimeRanges( DWORD dwGroupBits )
{
	long lMaxMeasure, lMaxBeat, lMaxGrid;

	// Get the maximum measure value
	if( m_pPropPageMgr->m_pTrackMgr->m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
		lMaxGrid = 256;
	}
	else
	{
		lMaxGrid = 256;	// Fix this!!!

		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
																	   V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pPropPageMgr->m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
																			   V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		long lItemMeasure, lItemBeat, lItemGrid, lItemTick;
		m_pPropPageMgr->m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( m_PropItem.m_Item.m_rtTimePhysical,
												&lItemMeasure, &lItemBeat, &lItemGrid, &lItemTick );

		// If the item is not in the last measure
		if( lItemMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pPropPageMgr->m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lItemMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pPropPageMgr->m_pTrackMgr->m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the item is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Update the range for the measure spin control
	m_spinLogicalMeasure.SetRange( 1, lMaxMeasure );
	m_editLogicalMeasure.LimitText( 5 );

	// Update the range for the beat spin control
	m_spinLogicalBeat.SetRange( 1, lMaxBeat );
	m_editLogicalBeat.LimitText( 3 );
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnCreate

int CTabPerformance::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnDestroy

void CTabPerformance::OnDestroy( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// free the sliders
	CSliderCollection::Free();
	m_pmsAttenuation = m_pmsFineTune = NULL;
    m_pmsAttenuationRange = m_pmsFineTuneRange = NULL;
	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnInitDialog

BOOL CTabPerformance::OnInitDialog( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	ASSERT(m_pmsAttenuation == NULL); // this should be first time, or after OnDestroy

	m_pmsAttenuation = Insert(
		IDC_ATTENUATION,		// slider
		IDC_DB_ATTENUATION,	// editbox
		IDC_DB_ATTENUATION_SPIN,
		MYSLIDER_VOLUME,
		0,
		0, // undo handled in UpdateObject
		&m_lAttenuation );

	m_pmsFineTune = Insert(
		IDC_FINE_TUNE,		// slider
		IDC_SEMI_TONES,		// editbox
		IDC_SEMI_TONES_SPIN,
		MYSLIDER_PITCHCENTS,
		0,
		0, // undo handled in UpdateObject
		&m_lFineTune );
	m_pmsAttenuationRange = Insert(
		IDC_ATTENUATION_RANGE,		// slider
		IDC_DB_ATTENUATION_RANGE,	// editbox
		IDC_DB_ATTENUATION_SPIN_RANGE,
		MYSLIDER_VOLUMECENTS,
		0,
		0, // undo handled in UpdateObject
		&m_lAttenuationRange );
	m_pmsFineTuneRange = Insert(
		IDC_FINE_TUNE_RANGE,		// slider
		IDC_SEMI_TONES_RANGE,		// editbox
		IDC_SEMI_TONES_SPIN_RANGE,
		MYSLIDER_VOLUMECENTS,
		0,
		0, // undo handled in UpdateObject
		&m_lFineTuneRange );
/*#ifndef DMP_XBOX
    GetDlgItem( IDC_ATTENUATION_RANGE_NAME )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_ATTENUATION_RANGE )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_DB_ATTENUATION_RANGE )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_DB_ATTENUATION_RANGE_NAME )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_DB_ATTENUATION_SPIN_RANGE )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_SEMI_TONES_SPIN_RANGE )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_STATIC_FINE_TUNE_RANGE )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_FINE_TUNE_RANGE )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_SEMI_TONES_RANGE )->ShowWindow(SW_HIDE );
    GetDlgItem( IDC_STATIC_SEMI_TONES_RANGE )->ShowWindow(SW_HIDE );

    m_checkIgnoreLooping.ShowWindow( SW_HIDE );
#endif*/

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::UpdateObject

void CTabPerformance::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *)&m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::EnableControls

void CTabPerformance::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure controls have been created
	if (m_pmsAttenuation == NULL)
	{
		return;
	}

	m_pmsAttenuation->EnableControl(this, fEnable != FALSE);
	m_pmsFineTune->EnableControl(this, fEnable != FALSE);
//#ifdef DMP_XBOX
	m_pmsAttenuationRange->EnableControl(this, fEnable != FALSE);
	m_pmsFineTuneRange->EnableControl(this, fEnable != FALSE);
//#endif
	m_checkNoInvalidate.EnableWindow( fEnable );
	m_checkIgnoreLooping.EnableWindow( fEnable );

	BOOL fEnableBelongsTo = FALSE;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() == false )
	{
		fEnableBelongsTo = fEnable;
	}

	m_spinLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_spinLogicalMeasure.EnableWindow( fEnableBelongsTo );
	m_editLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_editLogicalMeasure.EnableWindow( fEnableBelongsTo );

	if( fEnableBelongsTo == FALSE )
	{
		m_editLogicalMeasure.SetWindowText( NULL );
		m_editLogicalBeat.SetWindowText( NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void CTabPerformance::OnOK( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnSetActive

BOOL CTabPerformance::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh the page
	if(	m_fValidTrackItem )
	{
		SetPropTrackItem( &m_PropItem );
	}
	else
	{
		SetPropTrackItem( NULL );
	}

	if( m_pPropPageMgr 
	&&  m_pPropPageMgr->m_pTrackMgr 
	&&  m_pPropPageMgr->m_pIPropSheet )
	{
		m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CPropPageMgrItem::sm_nActiveTab );
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnHScroll

void CTabPerformance::OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
	CPropertyPage::OnHScroll(nSBCode, nPos, pScrollBar);
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnCheckNoInvalidate

void CTabPerformance::OnCheckNoInvalidate( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Make sure controls have been created
	if (m_pmsAttenuation == NULL)
	{
		return;
	}

	DWORD dwFlags = m_PropItem.m_Item.m_dwFlagsDM;

	switch( IsDlgButtonChecked( IDC_CHECK_NOINVALIDATE ) )
	{
		case 0:		// Currently unchecked
		case 2:		// Currently undetermined
			CheckDlgButton( IDC_CHECK_NOINVALIDATE, 1 );
			dwFlags |= DMUS_WAVEF_NOINVALIDATE;
			break;

		case 1:		// Currently checked
			CheckDlgButton( IDC_CHECK_NOINVALIDATE, 0 );
			dwFlags &= ~DMUS_WAVEF_NOINVALIDATE;
			break;
	}

	if( (m_PropItem.m_dwUndetermined_TabPerformance & UNDT_WAVEF_NOINVALIDATE)
	||  (m_PropItem.m_Item.m_dwFlagsDM != dwFlags) )
	{
		m_PropItem.m_Item.m_dwFlagsDM = dwFlags;
		m_PropItem.m_dwChanged = CHGD_DM_FLAGS;
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnDoubleClickedCheckNoInvalidate

void CTabPerformance::OnDoubleClickedCheckNoInvalidate( void ) 
{
	OnCheckNoInvalidate();
}

 

void CTabPerformance::OnCheckIgnoreLooping() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Make sure controls have been created
	if (m_pmsAttenuation == NULL)
	{
		return;
	}

	DWORD dwFlags = m_PropItem.m_Item.m_dwFlagsDM;

	switch( IsDlgButtonChecked( IDC_CHECK_IGNORE_LOOPING ) )
	{
		case 0:		// Currently unchecked
		case 2:		// Currently undetermined
			CheckDlgButton( IDC_CHECK_IGNORE_LOOPING, 1 );
			dwFlags |= DMUS_WAVEF_IGNORELOOPS;
			break;

		case 1:		// Currently checked
			CheckDlgButton( IDC_CHECK_IGNORE_LOOPING, 0 );
			dwFlags &= ~DMUS_WAVEF_IGNORELOOPS;
			break;
	}

	if( (m_PropItem.m_dwUndetermined_TabPerformance & UNDT_WAVEF_IGNORELOOPS)
	||  (m_PropItem.m_Item.m_dwFlagsDM != dwFlags) )
	{
		m_PropItem.m_Item.m_dwFlagsDM = dwFlags;
		m_PropItem.m_dwChanged = CHGD_DM_FLAGS;
		UpdateObject();
	}	
}

void CTabPerformance::OnDoubleclickedCheckIgnoreLooping() 
{
	OnCheckIgnoreLooping();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::SetLogicalTime

void CTabPerformance::SetLogicalTime( void ) 
{
	MUSIC_TIME mtTimeLogical;
	long lGrid, lTick;

	m_pPropPageMgr->m_pTrackMgr->ForceBoundaries( m_lLogicalMeasure, m_lLogicalBeat, &mtTimeLogical );
	m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lGrid, &lTick );
	m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, 0, &mtTimeLogical );

	if( (m_PropItem.m_dwUndetermined_TabPerformance & UNDT_TIME_LOGICAL)
	||  (m_PropItem.m_Item.m_rtTimeLogical != mtTimeLogical) )
	{
		m_PropItem.m_Item.m_rtTimeLogical = mtTimeLogical;

		// Now, update the object with the new value(s)
		m_PropItem.m_dwChanged = CHGD_TIME_LOGICAL;
		UpdateObject();
	}
	else
	{
		// Display original values
		SetPropTrackItem( &m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnSpinLogicalMeasure

void CTabPerformance::OnSpinLogicalMeasure( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLogicalMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLogicalMeasure ) )
	{
		SetLogicalTime();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnSpinLogicalBeat

void CTabPerformance::OnSpinLogicalBeat( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLogicalBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLogicalBeat ) )
	{
		SetLogicalTime();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CTabPerformance::HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		fChanged = true;
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnKillFocusLogicalMeasure

void CTabPerformance::OnKillFocusLogicalMeasure() 
{
	if( HandleKillFocus( m_spinLogicalMeasure, m_lLogicalMeasure, 1 ) )
	{
		SetLogicalTime();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::OnKillFocusLogicalBeat

void CTabPerformance::OnKillFocusLogicalBeat() 
{
	if( HandleKillFocus( m_spinLogicalBeat, m_lLogicalBeat, 1 ) )
	{
		SetLogicalTime();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabPerformance::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( lUpdateVal != 0 )
		{
			// Update the item with the new value
			lUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lUpdateVal != (lNewValue - nOffset) )
			{
				// Update the item with the new value
				lUpdateVal = (lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}

BOOL CTabPerformance::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CPropertyPage::OnCommand(wParam, lParam);
}

BOOL CTabPerformance::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

void CTabPerformance::UpdateAttenuation()
{
	if( (m_PropItem.m_dwUndetermined_TabPerformance & UNDT_VOLUME)
	||  (m_PropItem.m_Item.m_lVolume != (m_lAttenuation >> 16) * 10) )
	{
		m_PropItem.m_Item.m_lVolume = (m_lAttenuation >> 16) * 10;
		m_PropItem.m_dwChanged = CHGD_VOLUME;
		UpdateObject();
	}
}

void CTabPerformance::UpdateFineTune()
{
	if( (m_PropItem.m_dwUndetermined_TabPerformance & UNDT_PITCH)
	||  (m_PropItem.m_Item.m_lPitch != (m_lFineTune >> 16)) )
	{
		m_PropItem.m_Item.m_lPitch = (m_lFineTune >> 16);
		m_PropItem.m_dwChanged = CHGD_PITCH;
		UpdateObject();
	}
}

void CTabPerformance::UpdateAttenuationRange()
{
	if( (m_PropItem.m_dwUndetermined_TabPerformance & UNDT_VOLUME_RANGE)
	||  (m_PropItem.m_Item.m_lVolumeRange != (m_lAttenuationRange * 10) >> 16) )
	{
		m_PropItem.m_Item.m_lVolumeRange = (m_lAttenuationRange * 10) >> 16;
		m_PropItem.m_dwChanged = CHGD_VOLUME_RANGE;
		UpdateObject();
	}
}

void CTabPerformance::UpdateFineTuneRange()
{
	if( (m_PropItem.m_dwUndetermined_TabPerformance & UNDT_PITCH_RANGE)
	||  (m_PropItem.m_Item.m_lPitchRange != (m_lFineTuneRange >> 16) * 10) )
	{
		m_PropItem.m_Item.m_lPitchRange = (m_lFineTuneRange >> 16) * 10;
		m_PropItem.m_dwChanged = CHGD_PITCH_RANGE;
		UpdateObject();
	}
}

bool CTabPerformance::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			return true; // undo done at update end

		case dwmscupdfEnd:
			if (pms == m_pmsAttenuation)
				UpdateAttenuation();
			else if (pms == m_pmsAttenuationRange)
				UpdateAttenuationRange();
			else if (pms == m_pmsFineTuneRange)
				UpdateFineTuneRange();
			else
				{
				ASSERT(pms == m_pmsFineTune); // slider not implemented
				UpdateFineTune();
				}
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabLoop.cpp ===
// TabLoop.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropTrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabLoop.h"
#include "TabVariations.h"
#include "TabPerformance.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

/////////////////////////////////////////////////////////////////////////////
// CTabLoop property page

IMPLEMENT_DYNCREATE(CTabLoop, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CTabLoop constructor/destructor

CTabLoop::CTabLoop(): CPropertyPage(CTabLoop::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_PROPPAGE_WAVE_LOOP);
	//{{AFX_DATA_INIT(CTabLoop)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pIWaveTimelineDraw = NULL;
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidTrackItem = FALSE;
	m_fNeedToDetach = FALSE;

	m_lStartMeasure = 0;
	m_lStartBeat = 0;
	m_lStartGrid = 0;
	m_lStartTick = 0;

	m_lEndMeasure = 0;
	m_lEndBeat = 0;
	m_lEndGrid = 0;
	m_lEndTick = 0;
	
	m_lLengthMeasure = 0;
	m_lLengthBeat = 0;
	m_lLengthGrid = 0;
	m_lLengthTick = 0;
	m_dwLengthNbrSamples = 0;

	m_lSourceStartMeasure = 0;
	m_lSourceStartBeat = 0;
	m_lSourceStartGrid = 0;
	m_lSourceStartTick = 0;

	m_lSourceEndMeasure = 0;
	m_lSourceEndBeat = 0;
	m_lSourceEndGrid = 0;
	m_lSourceEndTick = 0;
	
	m_lSourceLengthMeasure = 0;
	m_lSourceLengthBeat = 0;
	m_lSourceLengthGrid = 0;
	m_lSourceLengthTick = 0;
	m_dwSourceLengthNbrSamples = 0;
}

CTabLoop::~CTabLoop()
{
	RELEASE( m_pIWaveTimelineDraw );
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::DoDataExchange

void CTabLoop::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CTabLoop)
	DDX_Control(pDX, IDC_CHECK_LOOP, m_checkLoop);
	DDX_Control(pDX, IDC_LOCK_LENGTH, m_btnLockLength);
	DDX_Control(pDX, IDC_PROMPT_GRID, m_staticPromptGrid);
	DDX_Control(pDX, IDC_PROMPT_TICK, m_staticPromptTick);
	DDX_Control(pDX, IDC_PROMPT_BEAT, m_staticPromptBeat);
	DDX_Control(pDX, IDC_PROMPT_BAR, m_staticPromptBar);
	DDX_Control(pDX, IDC_EDIT_START_TICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_START_GRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_START_BEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_START_BAR, m_editStartMeasure);
	DDX_Control(pDX, IDC_EDIT_START_SAMPLE, m_editStartSample);
	DDX_Control(pDX, IDC_EDIT_END_TICK, m_editEndTick);
	DDX_Control(pDX, IDC_EDIT_END_GRID, m_editEndGrid);
	DDX_Control(pDX, IDC_EDIT_END_BEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_EDIT_END_BAR, m_editEndMeasure);
	DDX_Control(pDX, IDC_EDIT_END_SAMPLE, m_editEndSample);
	DDX_Control(pDX, IDC_EDIT_LENGTH_TICK, m_editLengthTick);
	DDX_Control(pDX, IDC_EDIT_LENGTH_GRID, m_editLengthGrid);
	DDX_Control(pDX, IDC_EDIT_LENGTH_BEAT, m_editLengthBeat);
	DDX_Control(pDX, IDC_EDIT_LENGTH_BAR, m_editLengthMeasure);
	DDX_Control(pDX, IDC_EDIT_LENGTH_NBR_SAMPLES, m_editLengthNbrSamples);
	DDX_Control(pDX, IDC_SPIN_START_TICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_START_GRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_START_BEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_START_BAR, m_spinStartMeasure);
	DDX_Control(pDX, IDC_SPIN_START_SAMPLE, m_spinStartSample);
	DDX_Control(pDX, IDC_SPIN_END_TICK, m_spinEndTick);
	DDX_Control(pDX, IDC_SPIN_END_GRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_SPIN_END_BEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_SPIN_END_BAR, m_spinEndMeasure);
	DDX_Control(pDX, IDC_SPIN_END_SAMPLE, m_spinEndSample);
	DDX_Control(pDX, IDC_SPIN_LENGTH_TICK, m_spinLengthTick);
	DDX_Control(pDX, IDC_SPIN_LENGTH_GRID, m_spinLengthGrid);
	DDX_Control(pDX, IDC_SPIN_LENGTH_BEAT, m_spinLengthBeat);
	DDX_Control(pDX, IDC_SPIN_LENGTH_BAR, m_spinLengthMeasure);
	DDX_Control(pDX, IDC_SPIN_LENGTH_NBR_SAMPLES, m_spinLengthNbrSamples);
	DDX_Control(pDX, IDC_STATIC_SOURCE_START_TICK, m_staticSourceStartTick);
	DDX_Control(pDX, IDC_STATIC_SOURCE_START_GRID, m_staticSourceStartGrid);
	DDX_Control(pDX, IDC_STATIC_SOURCE_START_BEAT, m_staticSourceStartBeat);
	DDX_Control(pDX, IDC_STATIC_SOURCE_START_BAR, m_staticSourceStartMeasure);
	DDX_Control(pDX, IDC_STATIC_SOURCE_START_SAMPLE, m_staticSourceStartSample);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_TICK, m_staticSourceEndTick);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_GRID, m_staticSourceEndGrid);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_BEAT, m_staticSourceEndBeat);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_BAR, m_staticSourceEndMeasure);
	DDX_Control(pDX, IDC_STATIC_SOURCE_END_SAMPLE, m_staticSourceEndSample);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_TICK, m_staticSourceLengthTick);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_GRID, m_staticSourceLengthGrid);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_BEAT, m_staticSourceLengthBeat);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_BAR, m_staticSourceLengthMeasure);
	DDX_Control(pDX, IDC_STATIC_SOURCE_LENGTH_NBR_SAMPLES, m_staticSourceLengthNbrSamples);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabLoop, CPropertyPage)
	//{{AFX_MSG_MAP(CTabLoop)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_TICK, OnSpinStartTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_GRID, OnSpinStartGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_BEAT, OnSpinStartBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_BAR, OnSpinStartMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_START_SAMPLE, OnSpinStartSample)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_TICK, OnSpinEndTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_GRID, OnSpinEndGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_BEAT, OnSpinEndBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_BAR, OnSpinEndMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_END_SAMPLE, OnSpinEndSample)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_TICK, OnSpinLengthTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_GRID, OnSpinLengthGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_BEAT, OnSpinLengthBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_BAR, OnSpinLengthMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LENGTH_NBR_SAMPLES, OnSpinLengthNbrSamples)
	ON_EN_KILLFOCUS(IDC_EDIT_START_TICK, OnKillFocusStartTick)
	ON_EN_KILLFOCUS(IDC_EDIT_START_GRID, OnKillFocusStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_START_BEAT, OnKillFocusStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_START_BAR, OnKillFocusStartMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_START_SAMPLE, OnKillFocusStartSample)
	ON_EN_KILLFOCUS(IDC_EDIT_END_TICK, OnKillFocusEndTick)
	ON_EN_KILLFOCUS(IDC_EDIT_END_GRID, OnKillFocusEndGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_END_BEAT, OnKillFocusEndBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_END_BAR, OnKillFocusEndMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_END_SAMPLE, OnKillFocusEndSample)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_TICK, OnKillFocusLengthTick)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_GRID, OnKillFocusLengthGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_BEAT, OnKillFocusLengthBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_BAR, OnKillFocusLengthMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_LENGTH_NBR_SAMPLES, OnKillFocusLengthNbrSamples)
	ON_BN_CLICKED(IDC_CHECK_LOOP, OnCheckLoop)
	ON_BN_DOUBLECLICKED(IDC_CHECK_LOOP, OnDoubleClickedCheckLoop)
	ON_WM_KILLFOCUS()
	ON_BN_DOUBLECLICKED(IDC_LOCK_LENGTH, OnDoubleClickedLockLength)
	ON_BN_CLICKED(IDC_LOCK_LENGTH, OnLockLength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabLoop custom functions

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetPropTrackItem

void CTabLoop::SetPropTrackItem( const CPropTrackItem* pPropItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	// If pIDocRootNode is null, a wave has not been assigned to the item, so disable the property page
	if( pPropItem == NULL
	||  pPropItem->m_Item.m_FileRef.pIDocRootNode == NULL )
	{
		m_fValidTrackItem = FALSE;
		m_PropItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Store IDMUSProdWaveTimelineDraw interface pointer
	RELEASE( m_pIWaveTimelineDraw );
	if( FAILED ( pPropItem->m_Item.m_FileRef.pIDocRootNode->QueryInterface( IID_IDMUSProdWaveTimelineDraw, (void **)&m_pIWaveTimelineDraw ) ) )
	{
		// Cannot update properties without this interface
		m_fValidTrackItem = FALSE;
		m_PropItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Flag that we have a valid item
	m_fValidTrackItem = TRUE;

	// Copy the information from the new item
	m_PropItem.Copy( pPropItem );
	m_PropItem.m_nPropertyTab = TAB_LOOP;
	m_PropItem.m_dwChanged = 0;

	// Compute values for controls displaying "time"
	// Determine measure, beat, grid, tick
	// OR
	// Determine minute, second, grid, millisecond
	m_dwLengthNbrSamples = (m_PropItem.m_Item.m_dwLoopEndUI - m_PropItem.m_Item.m_dwLoopStartUI) + 1;
	RecomputeLoopTimes();

	// Check if the edit control has a valid window handle.
	if( m_editStartBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if wave length is less than minimum loop length
	if( m_dwLengthNbrSamples < (MIN_LOOP_LENGTH + 1) )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the controls
	EnableControls( TRUE );

	// Update Loop check box
	if( m_PropItem.m_dwUndetermined_TabLoop & UNDT_IS_LOOPED )
	{
		m_checkLoop.SetCheck( 2 );
	}
	else
	{
		m_checkLoop.SetCheck( m_PropItem.m_Item.m_fLoopedUI ? 1 : 0 );
	}

	if( m_PropItem.m_dwBits & PROPF_MULTIPLESELECT )
	{
		// For now don't set value of other controls when multiple waves selected
		return;
	}

	// Set nMeasureBeatOffset
	int nMeasureBeatOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nMeasureBeatOffset = 0;
	}
	else
	{
		nMeasureBeatOffset = 1;
	}

	// Set GRID controls
	CWaveStrip* pWaveStrip = m_PropItem.m_Item.GetWaveStripForPropSheet();
	if( pWaveStrip
	&&  pWaveStrip->IsOneGrid() )
	{
		m_editStartGrid.SetWindowText( NULL );
		m_editStartGrid.EnableWindow( FALSE );
		m_editEndGrid.SetWindowText( NULL );
		m_editEndGrid.EnableWindow( FALSE );
		m_editLengthGrid.SetWindowText( NULL );
		m_editLengthGrid.EnableWindow( FALSE );
	}
	else
	{
		SetEditControl( m_editStartGrid, m_lStartGrid, 1 );
		SetEditControl( m_editEndGrid, m_lEndGrid, 1 );
		SetEditControl( m_editLengthGrid, m_lLengthGrid, 0 );
	}
	
	// Update SOURCE controls
	if( m_PropItem.m_Item.m_WaveInfo.fIsLooped )
	{
		// Set GRID controls
		if( pWaveStrip
		&&  pWaveStrip->IsOneGrid() )
		{
			m_staticSourceStartGrid.SetWindowText( NULL );
			m_staticSourceEndGrid.SetWindowText( NULL );
			m_staticSourceLengthGrid.SetWindowText( NULL );
		}
		else
		{
			SetStaticControl( m_staticSourceStartGrid, m_lSourceStartGrid, 1 );
			SetStaticControl( m_staticSourceEndGrid, m_lSourceEndGrid, 1 );
			SetStaticControl( m_staticSourceLengthGrid, m_lSourceLengthGrid, 0 );
		}

		// Update START controls
		SetStaticControl( m_staticSourceStartMeasure, m_lSourceStartMeasure, nMeasureBeatOffset );
		SetStaticControl( m_staticSourceStartBeat, m_lSourceStartBeat, nMeasureBeatOffset );
		SetStaticControl( m_staticSourceStartTick, m_lSourceStartTick, 0 );
		SetStaticControl( m_staticSourceStartSample, m_PropItem.m_Item.m_WaveInfo.dwLoopStart, 0 );

		// Update END controls
		SetStaticControl( m_staticSourceEndMeasure, m_lSourceEndMeasure, nMeasureBeatOffset );
		SetStaticControl( m_staticSourceEndBeat, m_lSourceEndBeat, nMeasureBeatOffset );
		SetStaticControl( m_staticSourceEndTick, m_lSourceEndTick, 0 );
		SetStaticControl( m_staticSourceEndSample, m_PropItem.m_Item.m_WaveInfo.dwLoopEnd, 0 );

		// Update LENGTH controls
		SetStaticControl( m_staticSourceLengthMeasure, m_lSourceLengthMeasure, 0 );
		SetStaticControl( m_staticSourceLengthBeat, m_lSourceLengthBeat, 0 );
		SetStaticControl( m_staticSourceLengthTick, m_lSourceLengthTick, 0 );
		SetStaticControl( m_staticSourceLengthNbrSamples, ((m_PropItem.m_Item.m_WaveInfo.dwLoopEnd - m_PropItem.m_Item.m_WaveInfo.dwLoopStart) + 1), 0 );
	}
	else
	{
		// Update START controls
		m_staticSourceStartMeasure.SetWindowText( NULL );
		m_staticSourceStartBeat.SetWindowText( NULL );
		m_staticSourceStartGrid.SetWindowText( NULL );
		m_staticSourceStartTick.SetWindowText( NULL );
		m_staticSourceStartSample.SetWindowText( NULL );

		// Update END controls
		m_staticSourceEndMeasure.SetWindowText( NULL );
		m_staticSourceEndBeat.SetWindowText( NULL );
		m_staticSourceEndGrid.SetWindowText( NULL );
		m_staticSourceEndTick.SetWindowText( NULL );
		m_staticSourceEndSample.SetWindowText( NULL );

		// Update LENGTH controls
		m_staticSourceLengthMeasure.SetWindowText( NULL );
		m_staticSourceLengthBeat.SetWindowText( NULL );
		m_staticSourceLengthGrid.SetWindowText( NULL );
		m_staticSourceLengthTick.SetWindowText( NULL );
		m_staticSourceLengthNbrSamples.SetWindowText( NULL );
	}

	// Update START controls
	SetEditControl( m_editStartMeasure, m_lStartMeasure, nMeasureBeatOffset );
	SetEditControl( m_editStartBeat, m_lStartBeat, nMeasureBeatOffset );
	SetEditControl( m_editStartTick, m_lStartTick, 0 );
	SetEditControl( m_editStartSample, m_PropItem.m_Item.m_dwLoopStartUI, 0 );
	m_spinStartSample.SetPos( UD_MAXVAL >> 1 );

	// Update END controls
	SetEditControl( m_editEndMeasure, m_lEndMeasure, nMeasureBeatOffset );
	SetEditControl( m_editEndBeat, m_lEndBeat, nMeasureBeatOffset );
	SetEditControl( m_editEndTick, m_lEndTick, 0 );
	SetEditControl( m_editEndSample, m_PropItem.m_Item.m_dwLoopEndUI, 0 );
	m_spinEndSample.SetPos( UD_MAXVAL >> 1 );

	// Update LENGTH controls
	SetEditControl( m_editLengthMeasure, m_lLengthMeasure, 0 );
	SetEditControl( m_editLengthBeat, m_lLengthBeat, 0 );
	SetEditControl( m_editLengthTick, m_lLengthTick, 0 );
	SetEditControl( m_editLengthNbrSamples, m_dwLengthNbrSamples, 0 );
	m_spinLengthNbrSamples.SetPos( UD_MAXVAL >> 1 );

	// Update LOCK LENGTH controls
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr )
	{
		CBitmap* pBitmap = m_pPropPageMgr->m_pTrackMgr->GetLockBitmap( m_PropItem.m_Item.m_fLockLoopLengthUI );
		if( pBitmap )
		{
			m_btnLockLength.SetBitmap( (HBITMAP)pBitmap->GetSafeHandle() );
		}
	}
	if( m_PropItem.m_Item.m_fLockLoopLengthUI )
	{
		m_editLengthMeasure.EnableWindow( FALSE );
		m_spinLengthMeasure.EnableWindow( FALSE );
		m_editLengthBeat.EnableWindow( FALSE );
		m_spinLengthBeat.EnableWindow( FALSE );
		m_editLengthGrid.EnableWindow( FALSE );
		m_spinLengthGrid.EnableWindow( FALSE );
		m_editLengthTick.EnableWindow( FALSE );
		m_spinLengthTick.EnableWindow( FALSE );
		m_editLengthNbrSamples.EnableWindow( FALSE );
	}

	// Set ranges of spin controls
	SetControlRanges();
}
	

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetEditControl

void CTabLoop::SetEditControl( CEdit& edit, long lValue, int nOffset )
{
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	BOOL fTransSuccess;

	edit.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Convert from text to an integer
	long lCurValue = GetDlgItemInt( edit.GetDlgCtrlID(), &fTransSuccess, TRUE );

	// Check if the conversion failed, the text is empty, or if the values are different
	if( !fTransSuccess
	|| (tcstrTmp[0] == NULL)
	|| (lCurValue != lValue + nOffset) )
	{
		// Update the displayed number
		SetDlgItemInt( edit.GetDlgCtrlID(), lValue + nOffset );
	}
}
	

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetStaticControl

void CTabLoop::SetStaticControl( CStatic& stat, long lValue, int nOffset )
{
	// Update the displayed number
	SetDlgItemInt( stat.GetDlgCtrlID(), lValue + nOffset );
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetLoopStart

void CTabLoop::SetLoopStart( DWORD dwNewLoopStart ) 
{
	dwNewLoopStart = max( dwNewLoopStart, 0 );
	dwNewLoopStart = min( dwNewLoopStart, m_PropItem.m_Item.m_WaveInfo.dwWaveEnd - MIN_LOOP_LENGTH );
	
	DWORD dwNewLoopEnd;
	if( m_PropItem.m_Item.m_fLockLoopLengthUI )
	{
		dwNewLoopEnd = dwNewLoopStart + (m_dwLengthNbrSamples - 1);
	}
	else
	{
		dwNewLoopEnd = m_PropItem.m_Item.m_dwLoopEndUI;
	}
	if( (dwNewLoopEnd < dwNewLoopStart)
	||  (dwNewLoopEnd - dwNewLoopStart) < MIN_LOOP_LENGTH )
	{
		dwNewLoopEnd = dwNewLoopStart + MIN_LOOP_LENGTH;
	}
	if( (dwNewLoopEnd - dwNewLoopStart) > MAX_LOOP_LENGTH )
	{
		dwNewLoopEnd = dwNewLoopStart + MAX_LOOP_LENGTH;
	}

	EnforceLoopBoundaries( dwNewLoopStart, dwNewLoopEnd );

	if( (m_PropItem.m_dwUndetermined_TabLoop & UNDT_LOOP_START)
	||  (m_PropItem.m_dwUndetermined_TabLoop & UNDT_LOOP_END)
	||  (m_PropItem.m_Item.m_dwLoopStartUI != dwNewLoopStart)
	||  (m_PropItem.m_Item.m_dwLoopEndUI != dwNewLoopEnd) )
	{
		m_PropItem.m_Item.m_dwLoopStartUI = dwNewLoopStart;
		m_PropItem.m_Item.m_dwLoopEndUI = dwNewLoopEnd;

		// Now, update the object with the new value(s)
		m_PropItem.m_dwChanged = CHGD_LOOP;
		UpdateObject();
	}
	else
	{
		// Display original values
		SetPropTrackItem( &m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetLoopEnd

void CTabLoop::SetLoopEnd( DWORD dwNewLoopEnd ) 
{
	dwNewLoopEnd = max( dwNewLoopEnd, MIN_LOOP_LENGTH );
	dwNewLoopEnd = min( dwNewLoopEnd, m_PropItem.m_Item.m_WaveInfo.dwWaveEnd );
	
	DWORD dwNewLoopStart;
	if( m_PropItem.m_Item.m_fLockLoopLengthUI )
	{
		if( m_PropItem.m_Item.m_dwLoopStartUI > (dwNewLoopEnd - (m_dwLengthNbrSamples - 1)) )
		{
			dwNewLoopStart = dwNewLoopEnd - (m_dwLengthNbrSamples - 1);
		}
		else
		{
			dwNewLoopStart = 0;
			dwNewLoopEnd = m_PropItem.m_Item.m_dwLoopEndUI - m_PropItem.m_Item.m_dwLoopStartUI;
		}
	}
	else
	{
		dwNewLoopStart = m_PropItem.m_Item.m_dwLoopStartUI;
	}
	if( (dwNewLoopEnd < dwNewLoopStart)
	||  (dwNewLoopEnd - dwNewLoopStart) < MIN_LOOP_LENGTH )
	{
		dwNewLoopStart = dwNewLoopEnd - MIN_LOOP_LENGTH;
	}
	if( (dwNewLoopEnd - dwNewLoopStart) > MAX_LOOP_LENGTH )
	{
		dwNewLoopEnd = dwNewLoopStart + MAX_LOOP_LENGTH;
	}

	EnforceLoopBoundaries( dwNewLoopStart, dwNewLoopEnd );

	if( (m_PropItem.m_dwUndetermined_TabLoop & UNDT_LOOP_START)
	||  (m_PropItem.m_dwUndetermined_TabLoop & UNDT_LOOP_END)
	||  (m_PropItem.m_Item.m_dwLoopStartUI != dwNewLoopStart)
	||  (m_PropItem.m_Item.m_dwLoopEndUI != dwNewLoopEnd) )
	{
		m_PropItem.m_Item.m_dwLoopStartUI = dwNewLoopStart;
		m_PropItem.m_Item.m_dwLoopEndUI = dwNewLoopEnd;

		// Now, update the object with the new value(s)
		m_PropItem.m_dwChanged = CHGD_LOOP;
		UpdateObject();
	}
	else
	{
		// Display original values
		SetPropTrackItem( &m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetLoopLength

void CTabLoop::SetLoopLength( DWORD dwNewLoopLength ) 
{
	ASSERT( m_PropItem.m_Item.m_fLockLoopLengthUI == FALSE );

	DWORD dwMaxLoopLength = min( (m_PropItem.m_Item.m_WaveInfo.dwWaveEnd + 1), (MAX_LOOP_LENGTH + 1) );

	dwNewLoopLength = max( dwNewLoopLength, (MIN_LOOP_LENGTH + 1) );
	dwNewLoopLength = min( dwNewLoopLength, dwMaxLoopLength );

	DWORD dwNewLoopStart = m_PropItem.m_Item.m_dwLoopStartUI;
	DWORD dwNewLoopEnd = (m_PropItem.m_Item.m_dwLoopStartUI + dwNewLoopLength) - 1;

	EnforceLoopBoundaries( dwNewLoopStart, dwNewLoopEnd );

	if( (m_PropItem.m_dwUndetermined_TabLoop & UNDT_LOOP_START)
	||  (m_PropItem.m_dwUndetermined_TabLoop & UNDT_LOOP_END)
	||  (m_PropItem.m_Item.m_dwLoopStartUI != dwNewLoopStart)
	||  (m_PropItem.m_Item.m_dwLoopEndUI != dwNewLoopEnd) )
	{
		m_PropItem.m_Item.m_dwLoopStartUI = dwNewLoopStart;
		m_PropItem.m_Item.m_dwLoopEndUI = dwNewLoopEnd;

		// Now, update the object with the new value(s)
		m_PropItem.m_dwChanged = CHGD_LOOP;
		UpdateObject();
	}
	else
	{
		// Display original values
		SetPropTrackItem( &m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::EnforceLoopBoundaries

void CTabLoop::EnforceLoopBoundaries( DWORD& dwNewLoopStart, DWORD& dwNewLoopEnd ) 
{
	int nShift;

	if( dwNewLoopStart < 0 )
	{
		nShift = 0 - dwNewLoopStart;
		dwNewLoopEnd += nShift;
		dwNewLoopStart += nShift;
	}

	if( dwNewLoopEnd > m_PropItem.m_Item.m_WaveInfo.dwWaveEnd )
	{
		nShift = dwNewLoopEnd - m_PropItem.m_Item.m_WaveInfo.dwWaveEnd;
		dwNewLoopStart -= nShift;
		dwNewLoopEnd -= nShift;
	}

	ASSERT( dwNewLoopStart >= 0 );
	ASSERT( dwNewLoopEnd <= m_PropItem.m_Item.m_WaveInfo.dwWaveEnd );
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::StartTimeToSample

DWORD CTabLoop::StartTimeToSample( void )
{
	ASSERT( m_pIWaveTimelineDraw != NULL );

	// Get the reference time
	REFERENCE_TIME rtTime;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_lStartMeasure, m_lStartBeat, m_lStartGrid, m_lStartTick,
															&rtTime );
	}
	else
	{
		MUSIC_TIME mtTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lStartMeasure, m_lStartBeat, m_lStartGrid, m_lStartTick, &mtTime );
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtTime, &rtTime  );
	}

	// Subtract out start time
	REFERENCE_TIME rtTimePhysical;
	m_pPropPageMgr->m_pTrackMgr->UnknownTimeToRefTime( m_PropItem.m_Item.m_rtTimePhysical, &rtTimePhysical );
	rtTime -= rtTimePhysical;

	// Convert reference time to sample
	DWORD dwNewLoopStart;
	m_pIWaveTimelineDraw->RefTimeToSample( max(0, rtTime), &dwNewLoopStart, m_PropItem.m_Item.m_lPitch );

	return dwNewLoopStart;
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::EndTimeToSample

DWORD CTabLoop::EndTimeToSample( void )
{
	ASSERT( m_pIWaveTimelineDraw != NULL );

	// Get the reference time
	REFERENCE_TIME rtTime;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_lEndMeasure, m_lEndBeat, m_lEndGrid, m_lEndTick,
															&rtTime );
	}
	else
	{
		MUSIC_TIME mtTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lEndMeasure, m_lEndBeat, m_lEndGrid, m_lEndTick, &mtTime );
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtTime, &rtTime  );
	}

	// Subtract out start time
	REFERENCE_TIME rtTimePhysical;
	m_pPropPageMgr->m_pTrackMgr->UnknownTimeToRefTime( m_PropItem.m_Item.m_rtTimePhysical, &rtTimePhysical );
	rtTime -= rtTimePhysical;

	// Convert reference time to sample
	DWORD dwNewLoopEnd;
	m_pIWaveTimelineDraw->RefTimeToSample( max(0, rtTime), &dwNewLoopEnd, m_PropItem.m_Item.m_lPitch );

	return dwNewLoopEnd;
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::LengthTimeToNbrSamples

DWORD CTabLoop::LengthTimeToNbrSamples( void )
{
	ASSERT( m_pIWaveTimelineDraw != NULL );

	// Get the reference time
	REFERENCE_TIME rtTime;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		m_pPropPageMgr->m_pTrackMgr->MinSecGridMsToRefTime( m_PropItem.m_Item.GetWaveStripForPropSheet(),
															m_lLengthMeasure, m_lLengthBeat, m_lLengthGrid, m_lLengthTick,
															&rtTime );
	}
	else
	{
		REFERENCE_TIME rtTimePhysical;
		MUSIC_TIME mtTime;
		m_pPropPageMgr->m_pTrackMgr->MeasureBeatGridTickToClocks( m_lLengthMeasure, m_lLengthBeat, m_lLengthGrid, m_lLengthTick, &mtTime );
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToRefTime( (MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical, &rtTimePhysical  );
		m_pPropPageMgr->m_pTrackMgr->m_pTimeline->ClocksToRefTime( ((MUSIC_TIME)m_PropItem.m_Item.m_rtTimePhysical + mtTime), &rtTime  );
		rtTime -= rtTimePhysical;
	}

	// Convert reference time to sample
	DWORD dwNewLoopLength;
	m_pIWaveTimelineDraw->RefTimeToSample( max(0, rtTime), &dwNewLoopLength, m_PropItem.m_Item.m_lPitch );

	return dwNewLoopLength;
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::RecomputeLoopTimes

void CTabLoop::RecomputeLoopTimes( void )
{
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		SampleToRefTime();
	}
	else
	{
		SampleToMusicTime();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SampleToRefTime

void CTabLoop::SampleToRefTime( void )
{
	ASSERT( m_pIWaveTimelineDraw != NULL );

	REFERENCE_TIME rtTimePhysical;
	m_pPropPageMgr->m_pTrackMgr->UnknownTimeToRefTime( m_PropItem.m_Item.m_rtTimePhysical, &rtTimePhysical );

	REFERENCE_TIME rtTime;

	// START
	m_pIWaveTimelineDraw->SampleToRefTime( m_PropItem.m_Item.m_dwLoopStartUI, &rtTime, m_PropItem.m_Item.m_lPitch );
	rtTime += rtTimePhysical;
	m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
														rtTime,
														&m_lStartMeasure, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );
	

	// END
	m_pIWaveTimelineDraw->SampleToRefTime( m_PropItem.m_Item.m_dwLoopEndUI, &rtTime, m_PropItem.m_Item.m_lPitch );
	rtTime += rtTimePhysical;
	m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
														rtTime,
														&m_lEndMeasure, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );
	

	// LENGTH
	m_pIWaveTimelineDraw->SampleToRefTime( m_dwLengthNbrSamples, &rtTime, m_PropItem.m_Item.m_lPitch );
	m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
														rtTime,
														&m_lLengthMeasure, &m_lLengthBeat, &m_lLengthGrid, &m_lLengthTick );
	

	// SOURCE START
	m_pIWaveTimelineDraw->SampleToRefTime( m_PropItem.m_Item.m_WaveInfo.dwLoopStart, &rtTime, m_PropItem.m_Item.m_lPitch );
	rtTime += rtTimePhysical;
	m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
														rtTime,
														&m_lSourceStartMeasure, &m_lSourceStartBeat, &m_lSourceStartGrid, &m_lSourceStartTick );
	

	// SOURCE END
	m_pIWaveTimelineDraw->SampleToRefTime( m_PropItem.m_Item.m_WaveInfo.dwLoopEnd, &rtTime, m_PropItem.m_Item.m_lPitch );
	rtTime += rtTimePhysical;
	m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
														rtTime,
														&m_lSourceEndMeasure, &m_lSourceEndBeat, &m_lSourceEndGrid, &m_lSourceEndTick );
	

	// SOURCE LENGTH
	m_pIWaveTimelineDraw->SampleToRefTime( ((m_PropItem.m_Item.m_WaveInfo.dwLoopEnd - m_PropItem.m_Item.m_WaveInfo.dwLoopStart) + 1), &rtTime, m_PropItem.m_Item.m_lPitch );
	m_pPropPageMgr->m_pTrackMgr->RefTimeToMinSecGridMs( m_PropItem.m_Item.GetWaveStripForPropSheet(),
														rtTime,
														&m_lSourceLengthMeasure, &m_lSourceLengthBeat, &m_lSourceLengthGrid, &m_lSourceLengthTick );
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SampleToMusicTime

void CTabLoop::SampleToMusicTime( void )
{
	ASSERT( m_pIWaveTimelineDraw != NULL );

//	MUSIC_TIME mtTimePhysical;
//	m_pPropPageMgr->m_pTrackMgr->UnknownTimeToClocks( m_PropItem.m_Item.m_rtTimePhysical, &mtTimePhysical );

	REFERENCE_TIME rtTimePhysical;
	m_pPropPageMgr->m_pTrackMgr->UnknownTimeToRefTime( m_PropItem.m_Item.m_rtTimePhysical, &rtTimePhysical );

	REFERENCE_TIME rtTime;
//	MUSIC_TIME mtTime;
	MUSIC_TIME mtStart;
	MUSIC_TIME mtEnd;

	// START
	m_pIWaveTimelineDraw->SampleToRefTime( m_PropItem.m_Item.m_dwLoopStartUI, &rtTime, m_PropItem.m_Item.m_lPitch );
	m_pPropPageMgr->m_pTrackMgr->m_pTimeline->RefTimeToClocks( (rtTimePhysical + rtTime), &mtStart );
	m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( mtStart, &m_lStartMeasure, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );

	// END
	m_pIWaveTimelineDraw->SampleToRefTime( m_PropItem.m_Item.m_dwLoopEndUI, &rtTime, m_PropItem.m_Item.m_lPitch );
	m_pPropPageMgr->m_pTrackMgr->m_pTimeline->RefTimeToClocks( (rtTimePhysical + rtTime), &mtEnd );
	m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( mtEnd, &m_lEndMeasure, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );

	// LENGTH
	m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( (mtEnd - mtStart), &m_lLengthMeasure, &m_lLengthBeat, &m_lLengthGrid, &m_lLengthTick );

	// SOURCE START
	m_pIWaveTimelineDraw->SampleToRefTime( m_PropItem.m_Item.m_WaveInfo.dwLoopStart, &rtTime, m_PropItem.m_Item.m_lPitch );
	m_pPropPageMgr->m_pTrackMgr->m_pTimeline->RefTimeToClocks( (rtTimePhysical + rtTime), &mtStart );
	m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( mtStart, &m_lSourceStartMeasure, &m_lSourceStartBeat, &m_lSourceStartGrid, &m_lSourceStartTick );

	// SOURCE END
	m_pIWaveTimelineDraw->SampleToRefTime( m_PropItem.m_Item.m_WaveInfo.dwLoopEnd, &rtTime, m_PropItem.m_Item.m_lPitch );
	m_pPropPageMgr->m_pTrackMgr->m_pTimeline->RefTimeToClocks( (rtTimePhysical + rtTime), &mtEnd );
	m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( mtEnd, &m_lSourceEndMeasure, &m_lSourceEndBeat, &m_lSourceEndGrid, &m_lSourceEndTick );

	// SOURCE LENGTH
	m_pPropPageMgr->m_pTrackMgr->ClocksToMeasureBeatGridTick( (mtEnd - mtStart), &m_lSourceLengthMeasure, &m_lSourceLengthBeat, &m_lSourceLengthGrid, &m_lSourceLengthTick );
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetControlRanges

void CTabLoop::SetControlRanges( void )
{
	// Get track group bits
	DWORD dwGroupBits = 0xFFFFFFFF;
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip manager for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Set ranges for "time" controls
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		SetRefTimeRanges();
	}
	else
	{
		SetMusicTimeRanges( dwGroupBits );
	}

	// Limit samples 
	// Just using deltas from these controls
	// Boundary checks will happen in delta change handler
	m_spinStartSample.SetRange( 0, UD_MAXVAL );
	m_editStartSample.LimitText( 10 );
	m_spinEndSample.SetRange( 0, UD_MAXVAL );
	m_editEndSample.LimitText( 10 );
	m_spinLengthNbrSamples.SetRange( 0, UD_MAXVAL );
	m_editLengthNbrSamples.LimitText( 10 );
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetRefTimeRanges

void CTabLoop::SetRefTimeRanges( void )
{
	// Limit the minute number to positive numbers
	m_spinStartMeasure.SetRange( 1, 32767 );
	m_editStartMeasure.LimitText( 5 );
	m_spinEndMeasure.SetRange( 1, 32767 );
	m_editEndMeasure.LimitText( 5 );
	m_spinLengthMeasure.SetRange( 0, 32767 );
	m_editLengthMeasure.LimitText( 5 );

	// Limit the second number to 1-60
	m_spinStartBeat.SetRange( 1, 60 );
	m_editStartBeat.LimitText( 2 );
	m_spinEndBeat.SetRange( 1, 60 );
	m_editEndBeat.LimitText( 2 );
	m_spinLengthBeat.SetRange( 0, 60 );
	m_editLengthBeat.LimitText( 2 );

	// Limit the grid number to MIN_NBR_GRIDS_PER_SECOND - MAX_NBR_GRIDS_PER_SECOND
	m_spinStartGrid.SetRange( MIN_NBR_GRIDS_PER_SECOND, MAX_NBR_GRIDS_PER_SECOND );
	m_editStartGrid.LimitText( 3 );
	m_spinEndGrid.SetRange( MIN_NBR_GRIDS_PER_SECOND, MAX_NBR_GRIDS_PER_SECOND );
	m_editEndGrid.LimitText( 3 );
	m_spinLengthGrid.SetRange( (MIN_NBR_GRIDS_PER_SECOND - 1), MAX_NBR_GRIDS_PER_SECOND );
	m_editLengthGrid.LimitText( 3 );

	// Limit the millisecond number to 1-1000
	m_spinStartTick.SetRange( 1, 1000 );
	m_editStartTick.LimitText( 4 );
	m_spinEndTick.SetRange( 1, 1000 );
	m_editEndTick.LimitText( 4 );
	m_spinLengthTick.SetRange( 1, 1000 );
	m_editLengthTick.LimitText( 4 );
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::SetMusicTimeRanges

void CTabLoop::SetMusicTimeRanges( DWORD dwGroupBits )
{
	long lMaxMeasure, lMaxBeat, lMaxGrid;

	// Get the maximum measure value
	if( m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
		lMaxGrid = 256;
	}
	else
	{
		lMaxGrid = 256;	// Fix this!!!

		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
										  V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
												  V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		long lItemMeasure, lItemBeat, lItemGrid, lItemTick;
		m_pPropPageMgr->m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( m_PropItem.m_Item.m_rtTimePhysical,
												&lItemMeasure, &lItemBeat, &lItemGrid, &lItemTick );

		// If the item is not in the last measure
		if( lItemMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lItemMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the item is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Update the range for the measure spin control
	m_spinStartMeasure.SetRange( 1, lMaxMeasure );
	m_editStartMeasure.LimitText( 5 );
	m_spinEndMeasure.SetRange( 1, 32767 );
	m_editEndMeasure.LimitText( 5 );
	m_spinLengthMeasure.SetRange( 0, 32767 );
	m_editLengthMeasure.LimitText( 5 );

	// Update the range for the beat spin control
	m_spinStartBeat.SetRange( 1, lMaxBeat );
	m_editStartBeat.LimitText( 3 );
	m_spinEndBeat.SetRange( 1, lMaxBeat );
	m_editEndBeat.LimitText( 3 );
	m_spinLengthBeat.SetRange( 0, lMaxBeat );
	m_editLengthBeat.LimitText( 3 );

	// Update the range for the grid spin control
	m_spinStartGrid.SetRange( 1, lMaxGrid );
	m_editStartGrid.LimitText( 3 );
	m_spinEndGrid.SetRange( 1, lMaxGrid );
	m_editEndGrid.LimitText( 3 );
	m_spinLengthGrid.SetRange( 0, lMaxGrid );
	m_editLengthGrid.LimitText( 3 );

	// Update the range for the tick spin control
	m_spinStartTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editStartTick.LimitText( 5 );
	m_spinEndTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editEndTick.LimitText( 5 );
	m_spinLengthTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editLengthTick.LimitText( 5 );
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnCreate

int CTabLoop::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnDestroy

void CTabLoop::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnInitDialog

BOOL CTabLoop::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr )
	{
		CBitmap* pBitmap = m_pPropPageMgr->m_pTrackMgr->GetLockBitmap( 0 );
		if( pBitmap )
		{
			m_btnLockLength.SetBitmap( (HBITMAP)pBitmap->GetSafeHandle() );
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinStartTick

void CTabLoop::OnSpinStartTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartTick ) )
	{
		SetLoopStart( StartTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinStartGrid

void CTabLoop::OnSpinStartGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartGrid ) )
	{
		SetLoopStart( StartTimeToSample() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinStartBeat

void CTabLoop::OnSpinStartBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartBeat ) )
	{
		SetLoopStart( StartTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinStartMeasure

void CTabLoop::OnSpinStartMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartMeasure ) )
	{
		SetLoopStart( StartTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinStartSample

void CTabLoop::OnSpinStartSample(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartSample();

	DWORD dwNewLoopStart = m_PropItem.m_Item.m_dwLoopStartUI;
	if( HandleDeltaChange( pNMHDR, pResult, dwNewLoopStart ) )
	{
		SetLoopStart( dwNewLoopStart );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinEndTick

void CTabLoop::OnSpinEndTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndTick ) )
	{
		SetLoopEnd( EndTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinEndGrid

void CTabLoop::OnSpinEndGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndGrid ) )
	{
		SetLoopEnd( EndTimeToSample() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinEndBeat

void CTabLoop::OnSpinEndBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndBeat ) )
	{
		SetLoopEnd( EndTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinEndMeasure

void CTabLoop::OnSpinEndMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndMeasure ) )
	{
		SetLoopEnd( EndTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinEndSample

void CTabLoop::OnSpinEndSample(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndSample();

	DWORD dwNewLoopEnd = m_PropItem.m_Item.m_dwLoopEndUI;
	if( HandleDeltaChange( pNMHDR, pResult, dwNewLoopEnd ) )
	{
		SetLoopEnd( dwNewLoopEnd );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinLengthTick

void CTabLoop::OnSpinLengthTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLengthTick ) )
	{
		SetLoopLength( LengthTimeToNbrSamples() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinLengthGrid

void CTabLoop::OnSpinLengthGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLengthGrid ) )
	{
		SetLoopLength( LengthTimeToNbrSamples() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinLengthBeat

void CTabLoop::OnSpinLengthBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLengthBeat ) )
	{
		SetLoopLength( LengthTimeToNbrSamples() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinLengthMeasure

void CTabLoop::OnSpinLengthMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_lLengthMeasure ) )
	{
		SetLoopLength( LengthTimeToNbrSamples() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSpinLengthNbrSamples

void CTabLoop::OnSpinLengthNbrSamples(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusLengthNbrSamples();

	DWORD dwNewLoopLength = m_dwLengthNbrSamples;
	if( HandleDeltaChange( pNMHDR, pResult, dwNewLoopLength ) )
	{
		SetLoopLength( dwNewLoopLength );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CTabLoop::HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		fChanged = true;
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CTabLoop::HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, DWORD& dwUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		dwUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		fChanged = true;
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusStartTick

void CTabLoop::OnKillFocusStartTick() 
{
	if( HandleKillFocus( m_spinStartTick, m_lStartTick, 0 ) )
	{
		SetLoopStart( StartTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusStartGrid

void CTabLoop::OnKillFocusStartGrid() 
{
	if( HandleKillFocus( m_spinStartGrid, m_lStartGrid, 1 ) )
	{
		SetLoopStart( StartTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusStartBeat

void CTabLoop::OnKillFocusStartBeat() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinStartBeat, m_lStartBeat, nOffset ) )
	{
		SetLoopStart( StartTimeToSample() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusStartMeasure

void CTabLoop::OnKillFocusStartMeasure() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinStartMeasure, m_lStartMeasure, nOffset ) )
	{
		SetLoopStart( StartTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusStartSample

void CTabLoop::OnKillFocusStartSample() 
{
	DWORD dwNewLoopStart = m_PropItem.m_Item.m_dwLoopStartUI;

	if( HandleKillFocus( m_editStartSample, dwNewLoopStart, 0 ) )
	{
		SetLoopStart( dwNewLoopStart );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusEndTick

void CTabLoop::OnKillFocusEndTick() 
{
	if( HandleKillFocus( m_spinEndTick, m_lEndTick, 0 ) )
	{
		SetLoopEnd( EndTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusEndGrid

void CTabLoop::OnKillFocusEndGrid() 
{
	if( HandleKillFocus( m_spinEndGrid, m_lEndGrid, 1 ) )
	{
		SetLoopEnd( EndTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusEndBeat

void CTabLoop::OnKillFocusEndBeat() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinEndBeat, m_lEndBeat, nOffset ) )
	{
		SetLoopEnd( EndTimeToSample() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusEndMeasure

void CTabLoop::OnKillFocusEndMeasure() 
{
	int nOffset;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinEndMeasure, m_lEndMeasure, nOffset ) )
	{
		SetLoopEnd( EndTimeToSample() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusEndSample

void CTabLoop::OnKillFocusEndSample() 
{
	DWORD dwNewLoopEnd = m_PropItem.m_Item.m_dwLoopEndUI;

	if( HandleKillFocus( m_editEndSample, dwNewLoopEnd, 0 ) )
	{
		SetLoopEnd( dwNewLoopEnd );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusLengthTick

void CTabLoop::OnKillFocusLengthTick() 
{
	if( HandleKillFocus( m_spinLengthTick, m_lLengthTick, 0 ) )
	{
		SetLoopLength( LengthTimeToNbrSamples() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusLengthGrid

void CTabLoop::OnKillFocusLengthGrid() 
{
	if( HandleKillFocus( m_spinLengthGrid, m_lLengthGrid, 0 ) )
	{
		SetLoopLength( LengthTimeToNbrSamples() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusLengthBeat

void CTabLoop::OnKillFocusLengthBeat() 
{
	if( HandleKillFocus( m_spinLengthBeat, m_lLengthBeat, 0 ) )
	{
		SetLoopLength( LengthTimeToNbrSamples() );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusLengthMeasure

void CTabLoop::OnKillFocusLengthMeasure() 
{
	if( HandleKillFocus( m_spinLengthMeasure, m_lLengthMeasure, 0 ) )
	{
		SetLoopLength( LengthTimeToNbrSamples() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnKillFocusLengthNbrSamples

void CTabLoop::OnKillFocusLengthNbrSamples() 
{
	DWORD dwNewLoopLength = m_dwLengthNbrSamples;

	if( HandleKillFocus( m_editLengthNbrSamples, dwNewLoopLength, 0 ) )
	{
		SetLoopLength( dwNewLoopLength );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabLoop::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( lUpdateVal != 0 )
		{
			// Update the item with the new value
			lUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lUpdateVal != (lNewValue - nOffset) )
			{
				// Update the item with the new value
				lUpdateVal = (lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabLoop::HandleKillFocus( CEdit& edit, DWORD& dwUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return false;
	}

	// Check if the edit control is a valid window
	if (!::IsWindow(edit.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	CString strText;
	edit.GetWindowText( strText );
	strText.TrimRight();
	strText.TrimLeft();

	bool fChanged = false;

	// Handle empty text
	if( strText.IsEmpty() )
	{
		// Check if the value changed
		if( dwUpdateVal != 0 )
		{
			// Update the item with the new value
			dwUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Min/max enforced in EnforceLoopBoundaries()
		DWORD dwNewValue = (DWORD)_ttol( strText );

		// Check if the value changed
		if( dwUpdateVal != (dwNewValue - nOffset) )
		{
			// Update the item with the new value
			dwUpdateVal = (dwNewValue - nOffset);
			fChanged = true;
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::UpdateObject

void CTabLoop::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *)&m_PropItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::EnableControls

void CTabLoop::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if the Beat edit control exists
	if( m_editStartBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Cannot loop streaming waves
	/*if( m_PropItem.m_Item.m_WaveInfo.fIsStreaming )
	{
		fEnable = FALSE;
	}*/

	// Loop checked?
	BOOL fEnableLoopCheckBox = fEnable;
	if( fEnable
	&&  m_PropItem.m_Item.m_fLoopedUI == FALSE )
	{
		fEnable = FALSE;
	}

	// Check if multiple items are selected
	if( m_PropItem.m_dwBits & PROPF_MULTIPLESELECT )
	{
		// Yes - disable the rest of the controls
		fEnable = FALSE;
	}

	// Reference time or music time?
	CString strPrompt;
	if( m_pPropPageMgr->m_pTrackMgr->IsRefTimeTrack() )
	{
		strPrompt.LoadString( IDS_MIN_TEXT );
		m_staticPromptBar.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_SEC_TEXT );
		m_staticPromptBeat.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_GRID_TEXT );
		m_staticPromptGrid.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_MS_TEXT );
		m_staticPromptTick.SetWindowText( strPrompt );
	}
	else
	{
		strPrompt.LoadString( IDS_BAR_TEXT );
		m_staticPromptBar.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_BEAT_TEXT );
		m_staticPromptBeat.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_GRID_TEXT );
		m_staticPromptGrid.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_TICK_TEXT );
		m_staticPromptTick.SetWindowText( strPrompt );
	}

	// Update the controls with the new window state
	m_checkLoop.EnableWindow( fEnableLoopCheckBox );
	m_btnLockLength.EnableWindow( fEnable );
	
	m_spinStartTick.EnableWindow( fEnable );
	m_spinStartGrid.EnableWindow( fEnable );
	m_spinStartBeat.EnableWindow( fEnable );
	m_spinStartMeasure.EnableWindow( fEnable );
	m_spinStartSample.EnableWindow( fEnable );
	m_editStartTick.EnableWindow( fEnable );
	m_editStartGrid.EnableWindow( fEnable );
	m_editStartBeat.EnableWindow( fEnable );
	m_editStartMeasure.EnableWindow( fEnable );
	m_editStartSample.EnableWindow( fEnable );

	m_spinEndTick.EnableWindow( fEnable );
	m_spinEndGrid.EnableWindow( fEnable );
	m_spinEndBeat.EnableWindow( fEnable );
	m_spinEndMeasure.EnableWindow( fEnable );
	m_spinEndSample.EnableWindow( fEnable );
	m_editEndTick.EnableWindow( fEnable );
	m_editEndGrid.EnableWindow( fEnable );
	m_editEndBeat.EnableWindow( fEnable );
	m_editEndMeasure.EnableWindow( fEnable );
	m_editEndSample.EnableWindow( fEnable );

	m_spinLengthTick.EnableWindow( fEnable );
	m_spinLengthGrid.EnableWindow( fEnable );
	m_spinLengthBeat.EnableWindow( fEnable );
	m_spinLengthMeasure.EnableWindow( fEnable );
	m_spinLengthNbrSamples.EnableWindow( fEnable );
	m_editLengthTick.EnableWindow( fEnable );
	m_editLengthGrid.EnableWindow( fEnable );
	m_editLengthBeat.EnableWindow( fEnable );
	m_editLengthMeasure.EnableWindow( fEnable );
	m_editLengthNbrSamples.EnableWindow( fEnable );

	// Check if we're disabling
	if( !fEnable )
	{
		// Check if multiple items are selected
		if( m_PropItem.m_dwBits & PROPF_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
//				m_staticPromptMultiple.SetWindowText( strText );
//				return;
			}
		}
		else
		{
//			m_staticPromptMultiple.SetWindowText( _T("") );
		}

		// No items are selected, so clear the controls
		m_editStartTick.SetWindowText( NULL );
		m_editStartGrid.SetWindowText( NULL );
		m_editStartBeat.SetWindowText( NULL );
		m_editStartMeasure.SetWindowText( NULL );
		m_editStartSample.SetWindowText( NULL );

		m_editEndTick.SetWindowText( NULL );
		m_editEndGrid.SetWindowText( NULL );
		m_editEndBeat.SetWindowText( NULL );
		m_editEndMeasure.SetWindowText( NULL );
		m_editEndSample.SetWindowText( NULL );

		m_editLengthTick.SetWindowText( NULL );
		m_editLengthGrid.SetWindowText( NULL );
		m_editLengthBeat.SetWindowText( NULL );
		m_editLengthMeasure.SetWindowText( NULL );
		m_editLengthNbrSamples.SetWindowText( NULL );

		m_staticSourceStartTick.SetWindowText( NULL );
		m_staticSourceStartGrid.SetWindowText( NULL );
		m_staticSourceStartBeat.SetWindowText( NULL );
		m_staticSourceStartMeasure.SetWindowText( NULL );
		m_staticSourceStartSample.SetWindowText( NULL );

		m_staticSourceEndTick.SetWindowText( NULL );
		m_staticSourceEndGrid.SetWindowText( NULL );
		m_staticSourceEndBeat.SetWindowText( NULL );
		m_staticSourceEndMeasure.SetWindowText( NULL );
		m_staticSourceEndSample.SetWindowText( NULL );

		m_staticSourceLengthTick.SetWindowText( NULL );
		m_staticSourceLengthGrid.SetWindowText( NULL );
		m_staticSourceLengthBeat.SetWindowText( NULL );
		m_staticSourceLengthMeasure.SetWindowText( NULL );
		m_staticSourceLengthNbrSamples.SetWindowText( NULL );

		if( m_pPropPageMgr
		&&  m_pPropPageMgr->m_pTrackMgr )
		{
			CBitmap* pBitmap = m_pPropPageMgr->m_pTrackMgr->GetLockBitmap( 0 );
			if( pBitmap )
			{
				m_btnLockLength.SetBitmap( (HBITMAP)pBitmap->GetSafeHandle() );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnCheckLoop

void CTabLoop::OnCheckLoop( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the Loop check box exists
	if( m_checkLoop.GetSafeHwnd() == NULL )
	{
		return;
	}

	switch( IsDlgButtonChecked( IDC_CHECK_LOOP ) )
	{
		case 0:		// Currently unchecked
		case 2:		// Currently undetermined
			CheckDlgButton( IDC_CHECK_LOOP, 1 );
			m_PropItem.m_Item.m_fLoopedUI = TRUE;
			break;

		case 1:		// Currently checked
			CheckDlgButton( IDC_CHECK_LOOP, 0 );
			m_PropItem.m_Item.m_fLoopedUI = FALSE;
			break;
	}

	m_PropItem.m_dwChanged = CHGD_IS_LOOPED;
	UpdateObject();
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnDoubleClickedCheckLoop

void CTabLoop::OnDoubleClickedCheckLoop( void ) 
{
	OnCheckLoop();
}



/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void CTabLoop::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnSetActive

BOOL CTabLoop::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh the page
	if(	m_fValidTrackItem )
	{
		SetPropTrackItem( &m_PropItem );
	}
	else
	{
		SetPropTrackItem( NULL );
	}

	if( m_pPropPageMgr 
	&&  m_pPropPageMgr->m_pTrackMgr 
	&&  m_pPropPageMgr->m_pIPropSheet )
	{
		m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CPropPageMgrItem::sm_nActiveTab );
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnLockLength

void CTabLoop::OnLockLength() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the Loop check box exists
	if( m_checkLoop.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the item with the new value
	m_PropItem.m_Item.m_fLockLoopLengthUI = !m_PropItem.m_Item.m_fLockLoopLengthUI;

	// Now, update the object with the new value
	m_PropItem.m_dwChanged = CHGD_LOOP_LOCK_LENGTH;
	UpdateObject();
}


/////////////////////////////////////////////////////////////////////////////
// CTabLoop::OnDoubleClickedLockLength

void CTabLoop::OnDoubleClickedLockLength() 
{
	OnLockLength();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabVariations.cpp ===
// CTabVariations.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropTrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabVariations.h"
#include "LockoutNotification.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static const TCHAR g_pstrUnknown[11] = _T("----------");


/////////////////////////////////////////////////////////////////////////////
// CTabVariations property page

CTabVariations::CTabVariations() : CPropertyPage(CTabVariations::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//{{AFX_DATA_INIT(CTabVariations)
	//}}AFX_DATA_INIT

	m_pPropPageMgr = NULL;
	m_fValidTrackItem = FALSE;
	m_fNeedToDetach = FALSE;
	m_fAllDisabled = TRUE;
}

CTabVariations::~CTabVariations()
{
}

void CTabVariations::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabVariations)
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabVariations::EnableControls

void CTabVariations::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	CWnd* pWnd;
	
	for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
	{
		pWnd = GetDlgItem( i );
		if( pWnd )
		{
			if( fEnable == FALSE )
			{
				CheckDlgButton( i, 0 );
			}

			pWnd->EnableWindow( fEnable );
		}
	}

	pWnd = GetDlgItem( IDC_WAVE_NAME );
	if( pWnd )
	{
		pWnd->EnableWindow( fEnable );
	}

	pWnd = GetDlgItem( IDC_PROMPT );
	if( pWnd )
	{
		pWnd->EnableWindow( fEnable );
	}

	if( fEnable == FALSE )
	{
		pWnd = GetDlgItem( IDC_WAVE_NAME );
		if( pWnd )
		{
			pWnd->SetWindowText( NULL );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVariations::SetPropTrackItem

void CTabVariations::SetPropTrackItem( const CPropTrackItem* pPropItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	if( pPropItem == NULL )
	{
		m_fValidTrackItem = FALSE;
		m_PropItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Flag that we have a valid item
	m_fValidTrackItem = TRUE;

	// Copy the information from the new item
	m_PropItem.Copy( pPropItem );
	m_PropItem.m_nPropertyTab = TAB_VARIATIONS;
	m_PropItem.m_dwChanged = 0;

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the controls
	EnableControls( TRUE );

	// Set prompt
	CWnd* pWnd = GetDlgItem( IDC_WAVE_NAME );
	if( pWnd )
	{
		CString strWaveName;
		if( m_PropItem.m_dwBits & PROPF_MULTIPLESELECT )
		{
			strWaveName = g_pstrUnknown;
		}
		else
		{
			m_PropItem.m_Item.FormatUIText( strWaveName );
		}
		pWnd->SetWindowText( strWaveName );
	}

	// Set variation check boxes
	int nState;
	int j;

	for( int i = IDC_CHECK_VAR1 ;  i <= IDC_CHECK_VAR32 ;  i++ )
	{
		pWnd = GetDlgItem( i );
		if( pWnd )
		{
			j = i - IDC_CHECK_VAR1;

			if( m_PropItem.m_dwUndetermined_TabVariations & (1 << j) )
			{
				nState = 2;
			}
			else if( m_PropItem.m_Item.m_dwVariations & (1 << j) )
			{
				nState = 1;
			}
			else
			{
				nState = 0;
			}

			CheckDlgButton( i, nState );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVariations::UpdateObject

void CTabVariations::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *)&m_PropItem );
	}
}


BEGIN_MESSAGE_MAP(CTabVariations, CPropertyPage)
	//{{AFX_MSG_MAP(CTabVariations)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabVariations message handlers

BOOL CTabVariations::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh the page
	if(	m_fValidTrackItem )
	{
		SetPropTrackItem( &m_PropItem );
	}
	else
	{
		SetPropTrackItem( NULL );
	}

	if( m_pPropPageMgr 
	&&  m_pPropPageMgr->m_pTrackMgr 
	&&  m_pPropPageMgr->m_pIPropSheet )
	{
		m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CPropPageMgrItem::sm_nActiveTab );
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVariations::OnCreate

int CTabVariations::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVariations::OnDestroy

void CTabVariations::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVariations::OnCommand

BOOL CTabVariations::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nControlID = LOWORD( wParam );
	int nCommandID = HIWORD( wParam );

	if( nCommandID == BN_CLICKED
	||  nCommandID == BN_DOUBLECLICKED )
	{
		if( nControlID >= IDC_CHECK_VAR1
		&&  nControlID <= IDC_CHECK_VAR32 )
		{
			CWnd* pWnd = GetDlgItem( nControlID );
			if( pWnd )
			{
				int nVariation = nControlID - IDC_CHECK_VAR1;

				switch( IsDlgButtonChecked( nControlID ) )
				{
					case 0:		// Currently unchecked
					case 2:		// Currently undetermined
						CheckDlgButton( nControlID, 1 );
						m_PropItem.m_Item.m_dwVariations |= (1 << nVariation);
						break;

					case 1:		// Currently checked
						CheckDlgButton( nControlID, 0 );
						m_PropItem.m_Item.m_dwVariations &= ~(1 << nVariation);
						break;
				}

				m_PropItem.m_dwChanged = CHGD_VARIATIONS;
				m_PropItem.m_dwChangedVar_TabVariations = (1 << nVariation);
				UpdateData(FALSE);
				UpdateObject();
			}

			return TRUE;
		}
	}
	
	return CPropertyPage::OnCommand( wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabPerformance.h ===
#if !defined(AFX_TABPERFORMANCE_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_TABPERFORMANCE_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

// TabPerformance.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>
#include "MySlider.h"

class CPropPageMgrItem;
class CPropTrackItem;
class CTabOnReturnEdit;


/////////////////////////////////////////////////////////////////////////////
// CTabPerformance dialog

class CTabPerformance : public CPropertyPage, CSliderCollection
{
	friend CPropPageMgrItem;
	DECLARE_DYNCREATE(CTabPerformance)

// Construction
public:
	CTabPerformance();
	~CTabPerformance();

// Dialog Data
	//{{AFX_DATA(CTabPerformance)
	enum { IDD = IDD_PROPPAGE_WAVE_PERFORMANCE };
	CEdit	m_dbAttenuationRange;
	CSliderCtrl	m_AttenuationRange;
	CButton	m_checkIgnoreLooping;
	CEdit	m_editLogicalBeat;
	CSpinButtonCtrl	m_spinLogicalBeat;
	CSpinButtonCtrl	m_spinLogicalMeasure;
	CEdit	m_editLogicalMeasure;
	CButton	m_checkNoInvalidate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabPerformance)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTabPerformance)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnCheckNoInvalidate();
	afx_msg void OnDoubleClickedCheckNoInvalidate();
	afx_msg void OnSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusLogicalMeasure();
	afx_msg void OnKillFocusLogicalBeat();
	afx_msg void OnCheckIgnoreLooping();
	afx_msg void OnDoubleclickedCheckIgnoreLooping();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetPropTrackItem( const CPropTrackItem* pPropItem );

protected:
	void UpdateObject();
	void EnableControls( BOOL fEnable );
	bool HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );
	bool HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset );
	void SetEditControl( CEdit& edit, long lValue, int nOffset );

	void SetLogicalTime();

	void SetControlRanges();
	void SetMusicTimeRanges( DWORD dwGroupBits );
	void UpdateAttenuation();
	void UpdateFineTune();
	void UpdateAttenuationRange();
	void UpdateFineTuneRange();
	// CSliderCollection override
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);
	
	IDMUSProdTimeline*		m_pTimeline;		// Weak timeline reference
	CPropPageMgrItem*		m_pPropPageMgr;

	CPropTrackItem			m_PropItem;

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidTrackItem;

	MySlider*				m_pmsAttenuation;
	long					m_lAttenuation;

	MySlider*				m_pmsFineTune;
	long					m_lFineTune;

	MySlider*				m_pmsAttenuationRange;
	long					m_lAttenuationRange;

	MySlider*				m_pmsFineTuneRange;
	long					m_lFineTuneRange;

    long					m_lLogicalMeasure;
	long					m_lLogicalBeat;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABPERFORMANCE_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabWaveTrack.cpp ===
// TabWaveTrack.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TabWaveTrack.h"
#include "GroupBitsPPG.h"
#include "Timeline.h"
#include <dmusicf.h>
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTabWaveTrack property page

CTabWaveTrack::CTabWaveTrack() :
	CPropertyPage(CTabWaveTrack::IDD),
	CSliderCollection(1),
	m_pmsAttenuation(NULL)
{
	//{{AFX_DATA_INIT(CTabWaveTrack)
	//}}AFX_DATA_INIT

	m_pPPO = NULL;
	m_pPropPageMgr = NULL;
	m_pIPropSheet = NULL;

	m_PPGTrackParams.dwPageIndex = 2;
	m_PPGTrackParams.lVolume = 0;
	m_PPGTrackParams.dwTrackFlagsDM = 0;

	CSliderCollection::Init(this);
	m_lAttenuation = 0;

	m_fNeedToDetach = FALSE;
}

CTabWaveTrack::~CTabWaveTrack()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
}

void CTabWaveTrack::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabWaveTrack)
	DDX_Control(pDX, IDC_PERSIST, m_checkPersistVariationControl);
	DDX_Control(pDX, IDC_SYNC, m_checkSyncVariations);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabWaveTrack, CPropertyPage)
	//{{AFX_MSG_MAP(CTabWaveTrack)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_HSCROLL()
	ON_BN_CLICKED(IDC_SYNC, OnSync)
	ON_BN_DOUBLECLICKED(IDC_SYNC, OnDoubleClickedSync)
	ON_BN_CLICKED(IDC_PERSIST, OnPersist)
	ON_BN_DOUBLECLICKED(IDC_PERSIST, OnDoubleClickedPersist)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CTabWaveTrack::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CTabWaveTrack::EnableControls( BOOL fEnable )
{
	if (m_pmsAttenuation == NULL)
		return;

	m_pmsAttenuation->EnableControl(this, fEnable != 0);
	m_checkSyncVariations.EnableWindow( fEnable );
}

/////////////////////////////////////////////////////////////////////////////
// CTabWaveTrack message handlers

int CTabWaveTrack::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CTabWaveTrack::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// free the sliders
	CSliderCollection::Free();
	m_pmsAttenuation = NULL;

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CTabWaveTrack::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	ASSERT(m_pmsAttenuation == NULL);
	m_pmsAttenuation = Insert(
		IDC_ATTENUATION,
		IDC_DB_ATTENUATION,	
		IDC_DB_ATTENUATION_SPIN,
		MYSLIDER_VOLUME,
		0,
		0, // no undo
		&m_lAttenuation );


	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void CTabWaveTrack::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioWaveTrackPPG* pioWaveTrackPPG = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioWaveTrackPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Set volume control
	m_lAttenuation = (m_PPGTrackParams.lVolume << 16) / 10;
	m_pmsAttenuation->SetValue(this, m_lAttenuation);

	// Set flag controls
	m_checkSyncVariations.SetCheck( (m_PPGTrackParams.dwTrackFlagsDM & DMUS_WAVETRACKF_SYNC_VAR) ? 1 : 0 );
	m_checkPersistVariationControl.SetCheck( (m_PPGTrackParams.dwTrackFlagsDM & DMUS_WAVETRACKF_PERSIST_CONTROL) ? 0 : 1 );

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CTabWaveTrack::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	m_pIPropSheet->GetActivePage( &CGroupBitsPropPageMgr::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}

void CTabWaveTrack::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CTabWaveTrack::OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CTabWaveTrack::OnSync() 
{
	if( m_checkSyncVariations.GetCheck() )
	{
		m_PPGTrackParams.dwTrackFlagsDM |= DMUS_WAVETRACKF_SYNC_VAR;
	}
	else
	{
		m_PPGTrackParams.dwTrackFlagsDM &= ~DMUS_WAVETRACKF_SYNC_VAR;
	}

	UpdatePPO();
}

void CTabWaveTrack::OnDoubleClickedSync() 
{
	OnSync();
}

void CTabWaveTrack::OnPersist() 
{
	if( m_checkPersistVariationControl.GetCheck() )
	{
		m_PPGTrackParams.dwTrackFlagsDM &= ~DMUS_WAVETRACKF_PERSIST_CONTROL;
	}
	else
	{
		m_PPGTrackParams.dwTrackFlagsDM |= DMUS_WAVETRACKF_PERSIST_CONTROL;
	}

	UpdatePPO();
}

void CTabWaveTrack::OnDoubleClickedPersist() 
{
	OnPersist();
}

BOOL CTabWaveTrack::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CPropertyPage::OnCommand(wParam, lParam);
}

BOOL CTabWaveTrack::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

// CSliderCollection override
bool CTabWaveTrack::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			return true; // save state is done on End of updates

		case dwmscupdfEnd:
			ASSERT(pms == m_pmsAttenuation); // slider not handled
			m_PPGTrackParams.lVolume = (m_lAttenuation >> 16) * 10;
			UpdatePPO();
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabWavePart.h ===
#if !defined(AFX_TABWAVEPART_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_)
#define AFX_TABWAVEPART_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TabWavePart.h : header file
//
// Also defined in NewPartDlg.h
#define MIN_PCHANNEL	1
#define MAX_PCHANNEL	999

#include "resource.h"
#include "NewPartDlg.h"
#include "MySlider.h"

/////////////////////////////////////////////////////////////////////////////
// CTabWavePart dialog

interface IDMUSProdPropPageObject;
interface IDMUSProdPChannelName;
interface IDMUSProdPropSheet;

class CGroupBitsPropPageMgr;

struct ioWavePartPPG
{
	DWORD	dwPageIndex;
	DWORD	dwPChannel;
	long	lVolume;		
	DWORD	dwLockToPart;	
	DWORD	dwPartFlagsDM;
	CString strStripName;
	CString strPChannelName;
};

class CTabWavePart : public CPropertyPage, CSliderCollection
{
friend class CGroupBitsPropPageMgr;

// Construction
public:
	CTabWavePart();
	~CTabWavePart();

// Dialog Data
	//{{AFX_DATA(CTabWavePart)
	enum { IDD = IDD_PROPPAGE_PART };
	CComboBox	m_comboVarMode;
	CComboBox	m_comboVarLockID;
	CEdit	m_editPChannelName;
	CEdit	m_editName;
	CSpinButtonCtrl	m_spinPChannel;
	CNewPartEdit	m_editPChannel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabWavePart)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTabWavePart)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditPchannel();
	afx_msg void OnKillfocusEditPchannel();
	afx_msg void OnChangeEditPChannelName();
	afx_msg void OnChangeEditName();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSelChangeComboVarLock();
	afx_msg void OnSelChangeComboVarMode();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();
	void FillVarLockComboBox();
	HRESULT GetPChannelName( DWORD dwPChannel, CString& strPChannelName );

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	CGroupBitsPropPageMgr*		m_pPropPageMgr;
	IDMUSProdPropPageObject*	m_pPPO;
	ioWavePartPPG				m_PPGPartParams;
	BOOL						m_fNeedToDetach;

	MySlider*					m_pmsAttenuation;
	long						m_lAttenuation;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABWAVEPART_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabWaveTrack.h ===
#if !defined(AFX_TABWAVETRACK_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_)
#define AFX_TABWAVETRACK_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TabWaveTrack.h : header file
//

#include "resource.h"
#include <MySlider.h>

/////////////////////////////////////////////////////////////////////////////
// CTabWaveTrack dialog

interface IDMUSProdPropPageObject;
interface IDMUSProdPropSheet;

class CGroupBitsPropPageMgr;

struct ioWaveTrackPPG
{
	DWORD	dwPageIndex;
	long	lVolume;		
	DWORD	dwTrackFlagsDM;
};

class CTabWaveTrack : public CPropertyPage, CSliderCollection
{
friend class CGroupBitsPropPageMgr;

// Construction
public:
	CTabWaveTrack();
	~CTabWaveTrack();

// Dialog Data
	//{{AFX_DATA(CTabWaveTrack)
	enum { IDD = IDD_PROPPAGE_TRACK };
	CButton	m_checkPersistVariationControl;
	CButton	m_checkSyncVariations;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabWaveTrack)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTabWaveTrack)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSync();
	afx_msg void OnDoubleClickedSync();
	afx_msg void OnPersist();
	afx_msg void OnDoubleClickedPersist();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	CGroupBitsPropPageMgr*		m_pPropPageMgr;
	IDMUSProdPropPageObject*	m_pPPO;
	ioWaveTrackPPG				m_PPGTrackParams;
	BOOL						m_fNeedToDetach;

    MySlider*					m_pmsAttenuation;
	long						m_lAttenuation;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABWAVETRACK_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabWavePart.cpp ===
// TabWavePart.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TabWavePart.h"
#include "GroupBitsPPG.h"
#include "Timeline.h"
#include <dmusicf.h>
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define VARMODE_MASK	0x0000000F

/////////////////////////////////////////////////////////////////////////////
// CTabWavePart property page

CTabWavePart::CTabWavePart() :
	CPropertyPage(CTabWavePart::IDD),
	CSliderCollection(1),
	m_pmsAttenuation(NULL)
{
	//{{AFX_DATA_INIT(CTabWavePart)
	//}}AFX_DATA_INIT

	m_pPPO = NULL;
	m_pPropPageMgr = NULL;
	m_pIPropSheet = NULL;

	m_PPGPartParams.dwPageIndex = 3;
	m_PPGPartParams.dwPChannel = 0;
	m_PPGPartParams.lVolume = 0;
	m_PPGPartParams.dwLockToPart = 0;
	m_PPGPartParams.dwPartFlagsDM = 0;

	CSliderCollection::Init(this);
	m_lAttenuation = 0;

	m_fNeedToDetach = FALSE;
}

CTabWavePart::~CTabWavePart()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
}

void CTabWavePart::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabWavePart)
	DDX_Control(pDX, IDC_COMBO_VAR_MODE, m_comboVarMode);
	DDX_Control(pDX, IDC_COMBO_VAR_LOCK, m_comboVarLockID);
	DDX_Control(pDX, IDC_EDIT_PCHANNELNAME, m_editPChannelName);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL, m_editPChannel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabWavePart, CPropertyPage)
	//{{AFX_MSG_MAP(CTabWavePart)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_EDIT_PCHANNEL, OnChangeEditPchannel)
	ON_EN_KILLFOCUS(IDC_EDIT_PCHANNEL, OnKillfocusEditPchannel)
	ON_EN_CHANGE(IDC_EDIT_PCHANNELNAME, OnChangeEditPChannelName)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	ON_WM_HSCROLL()
	ON_CBN_SELCHANGE(IDC_COMBO_VAR_LOCK, OnSelChangeComboVarLock)
	ON_CBN_SELCHANGE(IDC_COMBO_VAR_MODE, OnSelChangeComboVarMode)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CTabWavePart::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CTabWavePart::EnableControls( BOOL fEnable )
{
	// Make sure controls have been created
	if (m_pmsAttenuation == NULL)
		return;

	m_editPChannel.EnableWindow( fEnable );
	m_spinPChannel.EnableWindow( fEnable );
	m_editName.EnableWindow( fEnable );
	m_editPChannelName.EnableWindow( fEnable );
	m_pmsAttenuation->EnableControl(this, fEnable != 0);
	m_comboVarMode.EnableWindow( fEnable );
	m_comboVarLockID.EnableWindow( fEnable );
}

/////////////////////////////////////////////////////////////////////////////
// CTabWavePart message handlers

int CTabWavePart::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CTabWavePart::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// free the sliders
	CSliderCollection::Free();
	m_pmsAttenuation = NULL;

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CTabWavePart::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	// Fill variation play mode combo box
	CString strVarMode;
	m_comboVarMode.ResetContent();
	for( int nID = IDS_VARMODE_RANDOM ;  nID <= IDS_VARMODE_RANDOM_ROW ;  nID++ )
	{
		if( strVarMode.LoadString( nID ) )
		{
			m_comboVarMode.AddString( strVarMode );
		}
	}
	
	m_editPChannel.SetLimitText( 3 ); // '999'
	m_spinPChannel.SetRange( MIN_PCHANNEL, MAX_PCHANNEL );

	// Limit PChannel names to DMUS_MAX_NAME - 1 characters
	m_editPChannelName.LimitText( DMUS_MAX_NAME - 1 );

	// Limit track names to DMUS_MAX_NAME - 1 characters
	m_editName.LimitText( DMUS_MAX_NAME - 1 );

	ASSERT(m_pmsAttenuation == NULL);
	m_pmsAttenuation = Insert(
		IDC_ATTENUATION,
		IDC_DB_ATTENUATION,	
		IDC_DB_ATTENUATION_SPIN,
		MYSLIDER_VOLUME,
		0,
		0, // no undo
		&m_lAttenuation );

	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void CTabWavePart::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioWavePartPPG* pioWavePartPPG = &m_PPGPartParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioWavePartPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Set PChannel
	m_spinPChannel.SetPos( m_PPGPartParams.dwPChannel + 1 );

	// Set strip name
	m_editName.SetWindowText( m_PPGPartParams.strStripName );

	// Set PChannel name
	m_editPChannelName.SetWindowText( m_PPGPartParams.strPChannelName );

	// Set volume control
	m_lAttenuation = (m_PPGPartParams.lVolume << 16) / 10;
	m_pmsAttenuation->SetValue(this, m_lAttenuation);

	// Set variation order
	int nVarMode = m_PPGPartParams.dwPartFlagsDM & VARMODE_MASK;
	switch( nVarMode )
	{
		case DMUS_VARIATIONT_RANDOM:
			m_comboVarMode.SetCurSel( 0 );
			break;

		case DMUS_VARIATIONT_SEQUENTIAL:
			m_comboVarMode.SetCurSel( 1 );
			break;
		
		case DMUS_VARIATIONT_RANDOM_START:
		case DMUS_VARIATIONT_NO_REPEAT:
		case DMUS_VARIATIONT_RANDOM_ROW:
			m_comboVarMode.SetCurSel( nVarMode );
			break;
		
		default:
			ASSERT(FALSE);
			m_comboVarMode.SetCurSel( 0 );
			break;
	}

	// Set variation lock ID
	FillVarLockComboBox();
	m_comboVarLockID.SetCurSel( m_PPGPartParams.dwLockToPart );

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CTabWavePart::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	m_pIPropSheet->GetActivePage( &CGroupBitsPropPageMgr::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}

void CTabWavePart::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGPartParams) ) );
	}
}

void CTabWavePart::OnChangeEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString strNewPChannel;
		m_editPChannel.GetWindowText( strNewPChannel );

		// Strip leading and trailing spaces
		strNewPChannel.TrimRight();
		strNewPChannel.TrimLeft();

		if ( !strNewPChannel.IsEmpty() )
		{
			BOOL fTransSucceeded;
			int nPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			if ( !fTransSucceeded || (nPChannel < MIN_PCHANNEL) )
			{
				nPChannel = MIN_PCHANNEL;
				m_spinPChannel.SetPos( nPChannel );
			}
			else if( nPChannel > MAX_PCHANNEL )
			{
				nPChannel = MAX_PCHANNEL;
				m_spinPChannel.SetPos( nPChannel );
			}

			m_editPChannelName.EnableWindow( TRUE );

			if( (unsigned)nPChannel != (m_PPGPartParams.dwPChannel + 1) )
			{
				m_PPGPartParams.dwPChannel = nPChannel - 1;
				GetPChannelName( m_PPGPartParams.dwPChannel, m_PPGPartParams.strPChannelName );
				UpdatePPO();

				// Changing a PChannel may cause this property sheet to be removed
				// so don't assume controls are still hanging around
				if( ::IsWindow(m_editPChannelName.m_hWnd) )
				{
					m_editPChannelName.SetWindowText( m_PPGPartParams.strPChannelName );
				}
			}
		}
	}
}

void CTabWavePart::OnKillfocusEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString strNewPChannel;
		m_editPChannel.GetWindowText( strNewPChannel );

		// Strip leading and trailing spaces
		strNewPChannel.TrimRight();
		strNewPChannel.TrimLeft();

		if ( strNewPChannel.IsEmpty() )
		{
			m_spinPChannel.SetPos( m_PPGPartParams.dwPChannel + 1 );
			m_editPChannelName.EnableWindow( TRUE );
		}
		else
		{
			// Convert from text to dword;
			BOOL fTransSucceeded;
			int nPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			ASSERT( fTransSucceeded );
			/*
			if ( !fTransSucceeded || (nPChannel < 1) )
			{
				m_dwPChannel = 0;
				m_strPChannelName = GetPChannelName( m_dwPChannel );
				UpdatePPO();

				// Changing a PChannel may cause this property sheet to be removed
				// so don't assume controls are still hanging around
				if( ::IsWindow(m_editPChannelName.m_hWnd) )
				{
					m_editPChannelName.SetWindowText( m_strPChannelName );
				}
			}
			else */ if( unsigned(nPChannel - 1) != m_PPGPartParams.dwPChannel )
			{
				m_PPGPartParams.dwPChannel = nPChannel - 1;
				GetPChannelName( m_PPGPartParams.dwPChannel, m_PPGPartParams.strPChannelName );
				UpdatePPO();

				// Changing a PChannel may cause this property sheet to be removed
				// so don't assume controls are still hanging around
				if( ::IsWindow(m_editPChannelName.m_hWnd) )
				{
					m_editPChannelName.SetWindowText( m_PPGPartParams.strPChannelName );
				}
			}
			m_editPChannelName.EnableWindow( TRUE );
		}
	}
}

void CTabWavePart::OnChangeEditPChannelName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	CString cstrNewName;

	m_editPChannelName.GetWindowText( cstrNewName );

	// Strip leading and trailing spaces
	cstrNewName.TrimRight();
	cstrNewName.TrimLeft();

	if( cstrNewName.Compare( m_PPGPartParams.strPChannelName ) != 0 )
	{
		m_PPGPartParams.strPChannelName = cstrNewName;
		UpdatePPO();
	}
}

void CTabWavePart::OnChangeEditName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	CString cstrNewStripName;

	m_editName.GetWindowText( cstrNewStripName );

	// Strip leading and trailing spaces
	cstrNewStripName.TrimRight();
	cstrNewStripName.TrimLeft();

	if( cstrNewStripName.Compare( m_PPGPartParams.strStripName ) != 0 )
	{
		m_PPGPartParams.strStripName = cstrNewStripName;
		UpdatePPO();
	}
}

BOOL CTabWavePart::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_PCHANNEL:
								// Set PChannel
								m_editPChannelName.EnableWindow( TRUE );
								m_spinPChannel.SetPos( m_PPGPartParams.dwPChannel + 1 );
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

HRESULT CTabWavePart::GetPChannelName( DWORD dwPChannel, CString& strPChannelName )
{
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr )
	{
		return m_pPropPageMgr->m_pTrackMgr->GetPChannelName( dwPChannel, strPChannelName ); 
	}

	// Should not happen!
	ASSERT( 0 );
	strPChannelName.Empty();
	return E_FAIL;
}

void CTabWavePart::OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CTabWavePart::OnSelChangeComboVarMode() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	// Get variation order from combo box
	int nNewVarOrder = m_comboVarMode.GetCurSel();
	if( nNewVarOrder == CB_ERR )
	{
		return;
	}

	switch( nNewVarOrder )
	{
		case 0:
			nNewVarOrder = DMUS_VARIATIONT_RANDOM;
			break;
		
		case 1:
			nNewVarOrder = DMUS_VARIATIONT_SEQUENTIAL;
			break;
		
		default:
			// Do nothing - the index is the same as the value for
			// 2 - DMUS_VARIATIONT_RANDOM_START:
			// 3 - DMUS_VARIATIONT_NO_REPEAT:
			// 4 - DMUS_VARIATIONT_RANDOM_ROW:
			break;
	}

	// Determine new value for m_PPGPartParams.dwPartFlagsDM
	DWORD dwNewPartFlagsDM = (m_PPGPartParams.dwPartFlagsDM & ~VARMODE_MASK);
	dwNewPartFlagsDM |= (nNewVarOrder & VARMODE_MASK);
		
	if( m_PPGPartParams.dwPartFlagsDM != dwNewPartFlagsDM )
	{
		m_PPGPartParams.dwPartFlagsDM = dwNewPartFlagsDM;
		UpdatePPO();
	}
}

void CTabWavePart::OnSelChangeComboVarLock() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	// Get variation lock ID from combo box
	int nNewVarLockID = m_comboVarLockID.GetCurSel();
	if( nNewVarLockID == CB_ERR )
	{
		return;
	}

	ASSERT( nNewVarLockID >= 0 );
	if( m_PPGPartParams.dwLockToPart != (DWORD)nNewVarLockID )
	{
		m_PPGPartParams.dwLockToPart = (DWORD)nNewVarLockID;
		UpdatePPO();
	}
}

void CTabWavePart::FillVarLockComboBox( void )
{
	// Don't redraw until we are finished building the list
	m_comboVarLockID.SetRedraw( FALSE );
	
	// Remove all items
	m_comboVarLockID.ResetContent();

	// Load strings
	CString strCreate; 
	CString strNone;
	strNone.LoadString( IDS_NONE_TEXT );
	strCreate.LoadString( IDS_CREATE_TEXT );

	// Insert '<None>'
	m_comboVarLockID.AddString( strNone );

	TCHAR achText[100];

	// Rebuild InversionId list
	for( int i = 1 ;  i < 256 ;  i++ )
	{
		_itot( i, achText, 10 );

		if( m_pPropPageMgr
		&&  m_pPropPageMgr->m_pTrackMgr )
		{
			if( m_pPropPageMgr->m_pTrackMgr->IsValidLockID( (DWORD)i ) == false )
			{
				_tcscat( achText, strCreate );
			}
		}

		m_comboVarLockID.AddString( achText );
	}

	// Redraw the new list
	m_comboVarLockID.SetRedraw( TRUE );
}

BOOL CTabWavePart::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CPropertyPage::OnCommand(wParam, lParam);
}

BOOL CTabWavePart::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

// CSliderCollection override
bool CTabWavePart::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			return true; // save state is done on End of updates

		case dwmscupdfEnd:
			ASSERT(pms == m_pmsAttenuation); // slider not handled
			m_PPGPartParams.lVolume = (m_lAttenuation >> 16) * 10;
			UpdatePPO();
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TabVariations.h ===
#if !defined(AFX_TABVARIATIONS_H__06A5F6C5_B758_11D1_89AF_00C04FD912C8__INCLUDED_)
#define AFX_TABVARIATIONS_H__06A5F6C5_B758_11D1_89AF_00C04FD912C8__INCLUDED_

// CTabVariations.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CPropPageMgrItem;
class CPropTrackItem;


/////////////////////////////////////////////////////////////////////////////
// CTabVariations dialog

class CTabVariations : public CPropertyPage
{
friend CPropPageMgrItem;

// Construction
public:
	CTabVariations();
	~CTabVariations();

// Dialog Data
	//{{AFX_DATA(CTabVariations)
	enum { IDD = IDD_PROPPAGE_WAVE_VARIATIONS };
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabVariations)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTabVariations)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetPropTrackItem( const CPropTrackItem* pPropItem );

protected:
	void UpdateObject();
	void EnableControls( BOOL fEnable );

protected:
	CPropPageMgrItem*		m_pPropPageMgr;

	CPropTrackItem			m_PropItem;

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidTrackItem;
	BOOL					m_fAllDisabled;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABVARIATIONS_H__06A5F6C5_B758_11D1_89AF_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TrackItem.cpp ===
#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "TrackMgr.h"
#include <dmusicf.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CTrackItem Constructors/Destructor

CTrackItem::CTrackItem( void )
{
	m_pTrackMgr = NULL;
	m_pWaveStrip = NULL;

	Clear();
}

CTrackItem::CTrackItem( CTrackMgr* pTrackMgr, CWaveStrip* pWaveStrip )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;

	ASSERT( pWaveStrip != NULL );
	m_pWaveStrip = pWaveStrip;

	Clear();
}

CTrackItem::CTrackItem( CTrackMgr* pTrackMgr, CWaveStrip* pWaveStrip, const CTrackItem& item )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;

	ASSERT( pWaveStrip != NULL );
	m_pWaveStrip = pWaveStrip;

	// Copy the passed-in item
	Copy( &item );
}

CTrackItem::~CTrackItem( void )
{
	if( m_pTrackMgr )
	{
		SetFileReference( NULL );
	}
	else
	{
		ClearListInfo();
		RELEASE( m_FileRef.pIDocRootNode );
	}
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Clear

void CTrackItem::Clear()
{
	m_rtTimeLogical = 0;
	m_rtTimePhysical = 0;
	m_rtStartOffset = 0;
	m_rtDuration = 0;

	m_dwVariations = 0xFFFFFFFF;
	m_dwFlagsDM = 0;
	m_lVolume = 0;
	m_lPitch = 0;
	m_lVolumeRange = 0;
	m_lPitchRange = 0;

	m_fLoopedUI = FALSE;
	m_dwLoopStartUI = 0;
	m_dwLoopEndUI = 0;
	m_fLockLoopLengthUI = FALSE;
	m_fLockEndUI = FALSE;
	m_fLockLengthUI = TRUE;

	m_dwBitsUI = 0;
	m_pLayer = NULL;
	m_fSelected = FALSE;
	m_fSyncDuration = TRUE;
	m_nPasteLayerIndex = 0;

	::SetRect( &m_rectWave, 0, 0, 0, 0 );
	::SetRect( &m_rectSelect, 0, 0, 0, 0 );

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );

	if( m_pTrackMgr )
	{
		SetFileReference( NULL );
	}
	else
	{
		ClearListInfo();
		RELEASE( m_FileRef.pIDocRootNode );
	}

	AfxSetResourceHandle( hInstance );
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::ClearListInfo

void CTrackItem::ClearListInfo()
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );

	m_FileRef.li.pIProject = NULL;

	m_FileRef.li.strProjectName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strDescriptor.LoadString( IDS_EMPTY_TEXT );

	memset( &m_FileRef.li.guidFile, 0, sizeof(GUID) );

	AfxSetResourceHandle( hInstance );
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Copy

void CTrackItem::Copy( const CTrackItem* pItem )
{
	ASSERT( pItem != NULL );
	if ( pItem == NULL )
	{
		return;
	}

	if( pItem == this )
	{
		return;
	}

	m_rtTimeLogical = pItem->m_rtTimeLogical;
	m_rtTimePhysical = pItem->m_rtTimePhysical;
	m_rtStartOffset = pItem->m_rtStartOffset;
	m_rtDuration = pItem->m_rtDuration;

	m_dwVariations = pItem->m_dwVariations;
	m_dwFlagsDM = pItem->m_dwFlagsDM;
	m_lVolume = pItem->m_lVolume;
	m_lPitch = pItem->m_lPitch;
	m_lVolumeRange = pItem->m_lVolumeRange;
	m_lPitchRange = pItem->m_lPitchRange;

	m_fLoopedUI = pItem->m_fLoopedUI;
	m_dwLoopStartUI = pItem->m_dwLoopStartUI;
	m_dwLoopEndUI = pItem->m_dwLoopEndUI;
	m_fLockLoopLengthUI = pItem->m_fLockLoopLengthUI;
	m_fLockEndUI = pItem->m_fLockEndUI;
	m_fLockLengthUI = pItem->m_fLockLengthUI;

	m_dwBitsUI = pItem->m_dwBitsUI;
	m_pLayer = pItem->m_pLayer;
	m_fSelected = pItem->m_fSelected;
	m_fSyncDuration = pItem->m_fSyncDuration;
	m_nPasteLayerIndex = pItem->m_nPasteLayerIndex;

	m_WaveInfo = pItem->m_WaveInfo;

	if( m_pTrackMgr )
	{
		SetFileReference( pItem->m_FileRef.pIDocRootNode );
	}
	else
	{
		m_FileRef.li.pIProject = pItem->m_FileRef.li.pIProject;
		m_FileRef.li.strProjectName = pItem->m_FileRef.li.strProjectName;
		m_FileRef.li.strName = pItem->m_FileRef.li.strName;
		m_FileRef.li.strDescriptor = pItem->m_FileRef.li.strDescriptor;
		memcpy( &m_FileRef.li.guidFile, &pItem->m_FileRef.li.guidFile, sizeof(GUID) );

		RELEASE( m_FileRef.pIDocRootNode );
		m_FileRef.pIDocRootNode = pItem->m_FileRef.pIDocRootNode;
		if( m_FileRef.pIDocRootNode )
		{
			m_FileRef.pIDocRootNode->AddRef();
		}
	}
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::After

BOOL CTrackItem::After( const CTrackItem& item )
{
	// Check if this item is after the one passed in.
	if( m_rtTimePhysical > item.m_rtTimePhysical )
	{
		// Our physical time is greater - we're after the item
		return TRUE;
	}

	// We're either before the item, or occur at the same time
	return FALSE;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Before

BOOL CTrackItem::Before( const CTrackItem& item )
{
	// Check if this item is before the one passed in.
	if( m_rtTimePhysical < item.m_rtTimePhysical )
	{
		// Our physical time is less - we're before the item
		return TRUE;
	}

	// We're either after the item, or occur at the same time
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::GetWaveInfo

HRESULT CTrackItem::GetWaveInfo( void )
{
	REFERENCE_TIME rtWaveLength = 0;

	// Prepare WaveInfoParams struct
	WaveInfoParams	wip;
	memset( &wip, 0, sizeof(WaveInfoParams) );
	wip.cbSize = sizeof(WaveInfoParams);

	HRESULT hr = S_OK;

	// Ask DLS Designer for info about the wave
	if( m_FileRef.pIDocRootNode )
	{
		IDMUSProdWaveTimelineDraw* pIWaveTimelineDraw;
		if( SUCCEEDED ( m_FileRef.pIDocRootNode->QueryInterface( IID_IDMUSProdWaveTimelineDraw, (void **)&pIWaveTimelineDraw ) ) )
		{
			if( FAILED ( pIWaveTimelineDraw->GetWaveInfo( &wip ) ) )
			{
				hr = E_FAIL;
			}

			if( FAILED ( pIWaveTimelineDraw->SampleToRefTime( wip.dwWaveDuration, &rtWaveLength, m_lPitch ) ) )
			{
				hr = E_FAIL;
			}

			RELEASE( pIWaveTimelineDraw );
		}
	}

	m_WaveInfo.rtWaveLength = rtWaveLength;	// REFERENCE_TIME
	m_WaveInfo.dwWaveEnd = wip.dwWaveDuration - 1;
	m_WaveInfo.fIsLooped = (wip.dwFlags & WAVE_LOOPED) ? TRUE : FALSE;
	m_WaveInfo.dwLoopType = wip.dwLoopType;
	m_WaveInfo.dwLoopStart = wip.dwLoopStart;
	m_WaveInfo.dwLoopEnd = wip.dwLoopEnd;
	m_WaveInfo.guidVersion = wip.guidVersion;
	m_WaveInfo.fIsStreaming = (wip.dwFlags & WAVE_STREAMING) ? TRUE : FALSE;

	// Cannot loop streaming waves
/*	if( m_WaveInfo.fIsStreaming )
	{
		m_fLoopedUI = FALSE;
		m_dwLoopStartUI = 0;
		m_dwLoopEndUI = 0;
	}*/

	// Convert WaveLength values to either MUSIC_TIME or REFERENCE_TIME
	if( m_pTrackMgr->m_pTimeline )
	{
		REFERENCE_TIME utWaveLength;
		SourceWaveLengthToUnknownTime( m_pTrackMgr, &utWaveLength );

		// Need to reset m_fSyncDuration in case this was a runtime file
		if( m_pTrackMgr->m_fWasRuntimeTrack
		&&  m_pTrackMgr->m_fInAllTracksAdded )
		{
			m_fSyncDuration = (m_rtDuration == utWaveLength) ? TRUE : FALSE;
		}

		// Sync duration
		if( m_rtDuration == 0 )
//		||  m_fSyncDuration )
		{
			m_rtDuration = utWaveLength;	// REFERENCE_TIME or MUSIC_TIME
		}

		// If item is not looped, then make sure item's duration is not longer than wave 
		if( m_fLoopedUI == FALSE )
		{
			if( m_rtDuration > utWaveLength )
			{
				m_rtDuration = utWaveLength;
				m_fSyncDuration = TRUE;
			}
		}
	}

	// If item not looped, then default to wave's loop points
	if( m_fLoopedUI == FALSE )
	{
		m_dwLoopStartUI = m_WaveInfo.dwLoopStart;
		m_dwLoopEndUI = m_WaveInfo.dwLoopEnd;
	}

	// Adjust loop end when applicable
	if( m_dwLoopEndUI == 0
	||  m_dwLoopEndUI > m_WaveInfo.dwWaveEnd )
	{
		m_dwLoopEndUI = m_WaveInfo.dwWaveEnd;
	}

	// Make sure loop is not longer than max loop 
	if( (m_dwLoopEndUI - m_dwLoopStartUI) > MAX_LOOP_LENGTH )
	{
		m_dwLoopEndUI = m_dwLoopStartUI + MAX_LOOP_LENGTH;
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetFileReference

HRESULT CTrackItem::SetFileReference( IDMUSProdNode* pINewDocRootNode )
{
	CWaitCursor wait;

	HRESULT hr = S_OK;

	ASSERT( m_pTrackMgr != NULL );
	if( m_pTrackMgr == NULL )
	{
		// Will be NULL when CTrackItem used for properties!
		// Must not set file references for properties!
		return E_FAIL;
	}

	// Get Framework pointer
	IDMUSProdFramework* pIFramework;
	VARIANT variant;
	hr = m_pTrackMgr->GetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, &variant );
	if( FAILED ( hr ) )
	{
		return hr;
	}
	hr = V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&pIFramework );
	V_UNKNOWN( &variant )->Release();
	if( FAILED ( hr ) )
	{
		return hr;
	}

	// Get DocRoot pointer (i.e. Segment's DocRoot node)
	IDMUSProdNode* pIDocRootNode;
	hr = m_pTrackMgr->GetParam( GUID_DocRootNode, 0, 0, &pIDocRootNode );
	if( FAILED ( hr ) )
	{
		RELEASE( pIFramework );
		return hr;
	}

	// Clean up old file reference
	if( m_FileRef.pIDocRootNode )
	{
		// Turn off notifications for this node
		if( m_FileRef.fRemoveNotify )
		{
			if( pIDocRootNode )
			{
				hr = pIFramework->RemoveFromNotifyList( m_FileRef.pIDocRootNode, pIDocRootNode );
			}
			m_FileRef.fRemoveNotify = FALSE;
		}

		// Unload the wave
		m_pTrackMgr->QueueWaveForUnload( this );
		GetWaveInfo();

		// Release reference 
		RELEASE( m_FileRef.pIDocRootNode );

		// Initialize pertinent fields
		ClearListInfo();
		m_dwBitsUI = 0;
	}

	// Set DocRoot of new file reference
	if( pINewDocRootNode )
	{
		// Turn on notifications
		ASSERT( m_FileRef.fRemoveNotify == FALSE );
		if( pIDocRootNode )
		{
			hr = pIFramework->AddToNotifyList( pINewDocRootNode, pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				m_FileRef.fRemoveNotify = TRUE;
			}
		}
		
		// Update file reference's DocRoot member variable
		m_FileRef.pIDocRootNode = pINewDocRootNode;
		m_FileRef.pIDocRootNode->AddRef();

		// Download the wave
		GetWaveInfo();
		m_pTrackMgr->QueueWaveForDownload( this );

		// Update file reference's list info
		SetListInfo( pIFramework );
	}

	RELEASE( pIFramework );
	RELEASE( pIDocRootNode );

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetListInfo

HRESULT CTrackItem::SetListInfo( IDMUSProdFramework* pIFramework )
{
	HRESULT hr = S_OK;

	ClearListInfo();

	if( m_FileRef.pIDocRootNode )
	{
		DMUSProdListInfo ListInfo;
		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		hr = m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo );
		if( SUCCEEDED ( hr ) )
		{
			IDMUSProdProject* pIProject;

			if( ListInfo.bstrName )
			{
				m_FileRef.li.strName = ListInfo.bstrName;
				::SysFreeString( ListInfo.bstrName );
			}
			if( ListInfo.bstrDescriptor )
			{
				m_FileRef.li.strDescriptor = ListInfo.bstrDescriptor;
				::SysFreeString( ListInfo.bstrDescriptor );
			}
			if( SUCCEEDED ( pIFramework->FindProject( m_FileRef.pIDocRootNode, &pIProject ) ) )
			{
				BSTR bstrProjectName;

				m_FileRef.li.pIProject = pIProject;
//				m_FileRef.li.pIProject->AddRef();		intentionally missing

				if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
				{
					m_FileRef.li.strProjectName = bstrProjectName;
					::SysFreeString( bstrProjectName );
				}

				pIProject->Release();
			}

		    pIFramework->GetNodeFileGUID( m_FileRef.pIDocRootNode, &m_FileRef.li.guidFile );
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::FormatUIText

void CTrackItem::FormatUIText( CString& strText )
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );

	// Wave name
	if( m_FileRef.pIDocRootNode )
	{
		strText = m_FileRef.li.strName;
	}
	else
	{
		strText.LoadString( IDS_EMPTY_TEXT );
	}

	AfxSetResourceHandle( hInstance );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::LoadListItem

HRESULT CTrackItem::LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent,
								  IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	DWORD			dwCurrentFilePos;
	IDMUSProdNode*	pIDocRootNode = NULL;
	CString			strObjectName;
	int				nLayerIndex = 0;
	HRESULT			hr = E_FAIL;

	if( pIRiffStream == NULL 
	||  pckParent == NULL 
	||  pIFramework == NULL 
	||  pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// TODO - Can remove pTrackMgr arg if this ASSERT never hits
	ASSERT( m_pTrackMgr != NULL );

	// LoadListItem does not expect to be called twice on the same object
	// Code assumes item consists of initial values
	ASSERT( m_FileRef.pIDocRootNode == NULL ); 
	ASSERT( m_rtTimePhysical == 0 );

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	dwCurrentFilePos = StreamTell( pIStream );

	// Load the track item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_WAVEITEM_CHUNK:
			{
				DMUS_IO_WAVE_ITEM_HEADER iItemHeader;
                iItemHeader.wPitchRange = 0;
                iItemHeader.wVolumeRange = 0;

				// Read in the item's header structure
				dwSize = min( sizeof( DMUS_IO_WAVE_ITEM_HEADER ), ck.cksize );
				hr = pIStream->Read( &iItemHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_lVolume = iItemHeader.lVolume;
				m_lPitch = iItemHeader.lPitch;
				m_lVolumeRange = iItemHeader.wVolumeRange;
				m_lPitchRange = iItemHeader.wPitchRange;
				m_dwVariations = iItemHeader.dwVariations;
				m_rtStartOffset = iItemHeader.rtStartOffset;
				m_rtDuration = iItemHeader.rtDuration;
				m_dwFlagsDM = iItemHeader.dwFlags;

				// Is wave looped?
				if( (iItemHeader.dwLoopEnd - iItemHeader.dwLoopStart) >= MIN_LOOP_LENGTH ) 
				{
					m_fLoopedUI = TRUE;
				}
				else
				{
					m_fLoopedUI = FALSE;
				}

				// Loop start/end will be overlayed by DMUS_FOURCC_WAVEITEM_UI_CHUNK when present
				m_dwLoopStartUI = iItemHeader.dwLoopStart;	
				m_dwLoopEndUI = iItemHeader.dwLoopEnd;

				m_rtTimePhysical = iItemHeader.rtTime;			// rtTime stores offset
				m_rtTimeLogical = iItemHeader.mtLogicalTime;	// mtLogicalTime stores beat difference
																// between physical and logical times
				break;
			}

			case DMUS_FOURCC_WAVEITEM_UI_CHUNK:
			{
				ioWaveItemUI iWaveItemUI;

				// Read in the item's header structure
				dwSize = min( sizeof( ioWaveItemUI ), ck.cksize );
				hr = pIStream->Read( &iWaveItemUI, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_pTrackMgr->m_fWasRuntimeTrack = false;

				nLayerIndex = iWaveItemUI.m_nLayerIndex;
				m_dwLoopStartUI = iWaveItemUI.m_dwLoopStartUI;	
				m_dwLoopEndUI = iWaveItemUI.m_dwLoopEndUI;
				m_fLockLoopLengthUI = iWaveItemUI.m_fLockLoopLengthUI;
				m_fLockEndUI = iWaveItemUI.m_fLockEndUI;
				m_fLockLengthUI = iWaveItemUI.m_fLockLengthUI;
				m_fSyncDuration = iWaveItemUI.m_fSyncDuration;
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				IDMUSProdFileRefChunk* pIFileRef;

				hr = pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				pIFileRef->LoadRefChunk( pIStream, &pIDocRootNode );
				pIFileRef->Release();
				break;
			}

			case FOURCC_LIST:
				if( ck.fccType == DMUS_FOURCC_REF_LIST )
				{
					MMCKINFO ckName;

					ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
					if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
					{
						// Store wave name
						ReadMBSfromWCS( pIStream, ckName.cksize, &strObjectName );
					}
				}
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	// Use m_nPasteLayerIndex to store original layer index
	// Will be converted to actual layer as part of paste (or drop)
	m_nPasteLayerIndex = nLayerIndex;

	if( pIDocRootNode == NULL )
	{
		// Do we have an object name?
		if( !strObjectName.IsEmpty() )
		{
			// Framework could not resolve wave file reference
			// so we will ask user to help
			pIDocRootNode = FindWaveFile( strObjectName, pIStream, pIFramework, pTrackMgr );
		}
	}

	if( pIDocRootNode )
	{
		hr = SetFileReference( pIDocRootNode );
		pIDocRootNode->Release();

		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SaveListItem

HRESULT CTrackItem::SaveListItem( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

	if( pIRiffStream == NULL 
	||  pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// TODO - Can remove pTrackMgr arg if this ASSERT never hits
	ASSERT( m_pTrackMgr != NULL );

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_WAVE_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_WAVE_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_WAVEITEM_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_WAVEITEM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_WAVE_ITEM_HEADER oItemHeader;
		ZeroMemory( &oItemHeader, sizeof(DMUS_IO_WAVE_ITEM_HEADER) );

		// Fill in the members of the DMUS_IO_WAVE_ITEM_HEADER structure
		oItemHeader.lVolume = m_lVolume;
		oItemHeader.lPitch = m_lPitch;
		oItemHeader.wVolumeRange = (WORD) m_lVolumeRange;
		oItemHeader.wPitchRange = (WORD) m_lPitchRange;
		oItemHeader.dwVariations = m_dwVariations;
		oItemHeader.rtTime = m_rtTimePhysical;
		oItemHeader.rtStartOffset = m_rtStartOffset;
		oItemHeader.rtReserved = 0;
		oItemHeader.rtDuration = m_rtDuration;
		oItemHeader.mtLogicalTime = (MUSIC_TIME)m_rtTimeLogical;	// m_rtTimeLogical stores beat difference
																	// between physical and logical times
		oItemHeader.dwFlags = m_dwFlagsDM;
		
		if( m_fLoopedUI )
		{
			ASSERT( (m_dwLoopEndUI - m_dwLoopStartUI) >= MIN_LOOP_LENGTH );
			oItemHeader.dwLoopStart = m_dwLoopStartUI;
			oItemHeader.dwLoopEnd = m_dwLoopEndUI;
		}
		else
		{
			oItemHeader.dwLoopStart = 0;
			oItemHeader.dwLoopEnd = 0;
		}

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oItemHeader, sizeof(DMUS_IO_WAVE_ITEM_HEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_WAVE_ITEM_HEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_WAVEITEM_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_WAVEITEM_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_WAVEITEM_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioWaveItemUI oWaveItemUI;
		ZeroMemory( &oWaveItemUI, sizeof(ioWaveItemUI) );

		// Fill in the members of the ioWaveItemUI structure
		oWaveItemUI.m_nLayerIndex = m_pWaveStrip->LayerToIndex( m_pLayer );
		oWaveItemUI.m_dwLoopStartUI = m_dwLoopStartUI;
		oWaveItemUI.m_dwLoopEndUI = m_dwLoopEndUI;
		oWaveItemUI.m_fLockLoopLengthUI = m_fLockLoopLengthUI;
		oWaveItemUI.m_fLockEndUI = m_fLockEndUI;
		oWaveItemUI.m_fLockLengthUI = m_fLockLengthUI;
		oWaveItemUI.m_fSyncDuration = m_fSyncDuration;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oWaveItemUI, sizeof(ioWaveItemUI), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(ioWaveItemUI) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_WAVEITEM_UI_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the wave file reference chunk(s)
	{
		if( m_FileRef.pIDocRootNode )
		{
			if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
			{
				SaveDMRef( pIRiffStream, pIFramework, m_FileRef.pIDocRootNode, WL_PRODUCER );
			}
			else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
			{
				SaveDMRef( pIRiffStream, pIFramework, m_FileRef.pIDocRootNode, WL_DIRECTMUSIC );
				if( ftFileType == FT_DESIGN )
				{
					SaveProducerRef( pIRiffStream, pIFramework, m_FileRef.pIDocRootNode );
				}
			}
		}
	}

	// Ascend out of the DMUS_FOURCC_WAVE_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::LoadTrackItem

HRESULT CTrackItem::LoadTrackItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent,
								   IDMUSProdFramework* pIFramework )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	DWORD			dwCurrentFilePos;
	IDMUSProdNode*	pIDocRootNode = NULL;
	CString			strObjectName;
	int				nLayerIndex = 0;
	HRESULT			hr = E_FAIL;

	// LoadListItem does not expect to be called twice on the same object
	// Code assumes item consists of initial values
	ASSERT( m_FileRef.pIDocRootNode == NULL ); 
	ASSERT( m_rtTimePhysical == 0 );

	if( pIRiffStream == NULL 
	||  pckParent == NULL 
	||  pIFramework == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	dwCurrentFilePos = StreamTell( pIStream );

	// Load the track item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_WAVEITEM_CHUNK:
			{
				DMUS_IO_WAVE_ITEM_HEADER iItemHeader;
                iItemHeader.wVolumeRange = 0;
                iItemHeader.wPitchRange = 0;

				// Read in the item's header structure
				dwSize = min( sizeof( DMUS_IO_WAVE_ITEM_HEADER ), ck.cksize );
				hr = pIStream->Read( &iItemHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_lVolume = iItemHeader.lVolume;
				m_lPitch = iItemHeader.lPitch;
				m_lVolumeRange = (long) iItemHeader.wVolumeRange;
				m_lPitchRange = (long) iItemHeader.wPitchRange;
				m_dwVariations = iItemHeader.dwVariations;
				m_rtTimePhysical = iItemHeader.rtTime;
				m_rtStartOffset = iItemHeader.rtStartOffset;
				m_rtDuration = iItemHeader.rtDuration;
				if( m_pTrackMgr->IsRefTimeTrack() )
				{
					// Convert Milliseconds to REFERENCE_TIME
					m_rtTimeLogical = iItemHeader.mtLogicalTime * REFCLOCKS_PER_MILLISECOND;
				}
				else
				{
					m_rtTimeLogical = iItemHeader.mtLogicalTime;
				}
				m_dwFlagsDM = iItemHeader.dwFlags;

				// Is wave looped?
				if( (iItemHeader.dwLoopEnd - iItemHeader.dwLoopStart) >= MIN_LOOP_LENGTH ) 
				{
					m_fLoopedUI = TRUE;
				}
				else
				{
					m_fLoopedUI = FALSE;
				}

				// Loop start/end will be overlayed by DMUS_FOURCC_WAVEITEM_UI_CHUNK when present
				m_dwLoopStartUI = iItemHeader.dwLoopStart;	
				m_dwLoopEndUI = iItemHeader.dwLoopEnd;
				break;
			}

			case DMUS_FOURCC_WAVEITEM_UI_CHUNK:
			{
				ioWaveItemUI iWaveItemUI;

				// Read in the item's header structure
				dwSize = min( sizeof( ioWaveItemUI ), ck.cksize );
				hr = pIStream->Read( &iWaveItemUI, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_pTrackMgr->m_fWasRuntimeTrack = false;

				nLayerIndex = iWaveItemUI.m_nLayerIndex;
				m_dwLoopStartUI = iWaveItemUI.m_dwLoopStartUI;	
				m_dwLoopEndUI = iWaveItemUI.m_dwLoopEndUI;
				m_fLockLoopLengthUI = iWaveItemUI.m_fLockLoopLengthUI;
				m_fLockEndUI = iWaveItemUI.m_fLockEndUI;
				m_fLockLengthUI = iWaveItemUI.m_fLockLengthUI;
				m_fSyncDuration = iWaveItemUI.m_fSyncDuration;
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				IDMUSProdFileRefChunk* pIFileRef;

				hr = pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				pIFileRef->LoadRefChunk( pIStream, &pIDocRootNode );
				pIFileRef->Release();
				break;
			}

			case FOURCC_LIST:
				if( ck.fccType == DMUS_FOURCC_REF_LIST )
				{
					MMCKINFO ckName;

					ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
					if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
					{
						// Store wave name
						ReadMBSfromWCS( pIStream, ckName.cksize, &strObjectName );
					}
				}
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	// Need to reset m_fSyncDuration in case this was a runtime file
	if( m_pTrackMgr->m_fWasRuntimeTrack )
	{
		// Will be set more intelligently in GetWaveinfo when editor is opened
		// Set here to catch the case where editor is never opened
		m_fSyncDuration = m_fLoopedUI ? FALSE : TRUE;
	}

	// Set the item's layer
	m_pLayer = m_pWaveStrip->CreateLayerForIndex( nLayerIndex );

	if( pIDocRootNode == NULL )
	{
		// Do we have an object name?
		if( !strObjectName.IsEmpty() )
		{
			// Framework could not resolve file reference
			// so we will ask user to help
			pIDocRootNode = FindWaveFile( strObjectName, pIStream, pIFramework, m_pTrackMgr );
		}
	}

	if( pIDocRootNode )
	{
		hr = SetFileReference( pIDocRootNode );
		pIDocRootNode->Release();

		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SaveTrackItem

HRESULT CTrackItem::SaveTrackItem( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdFramework* pIFramework )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

	if( pIRiffStream == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_WAVE_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_WAVE_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_WAVEITEM_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_WAVEITEM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_WAVE_ITEM_HEADER oItemHeader;
		ZeroMemory( &oItemHeader, sizeof(DMUS_IO_WAVE_ITEM_HEADER) );

		// Fill in the members of the DMUS_IO_WAVE_ITEM_HEADER structure
		oItemHeader.lVolume = m_lVolume;
		oItemHeader.lPitch = m_lPitch;
		oItemHeader.wVolumeRange = (WORD) m_lVolumeRange;
		oItemHeader.wPitchRange = (WORD) m_lPitchRange;
		oItemHeader.dwVariations = m_dwVariations;
		oItemHeader.rtTime = m_rtTimePhysical;
		oItemHeader.rtStartOffset = m_rtStartOffset;
		oItemHeader.rtReserved = 0;
		oItemHeader.rtDuration = m_rtDuration;
		if( m_pTrackMgr->IsRefTimeTrack() )
		{
			// Convert REFERENCE_TIME to milliseconds
			oItemHeader.mtLogicalTime = (MUSIC_TIME)(m_rtTimeLogical / REFCLOCKS_PER_MILLISECOND);
		}
		else
		{
			oItemHeader.mtLogicalTime = (MUSIC_TIME)m_rtTimeLogical;
		}
		oItemHeader.dwFlags = m_dwFlagsDM;
		
		if( m_fLoopedUI )
		{
			ASSERT( (m_dwLoopEndUI - m_dwLoopStartUI) >= MIN_LOOP_LENGTH );
			oItemHeader.dwLoopStart = m_dwLoopStartUI;
			oItemHeader.dwLoopEnd = m_dwLoopEndUI;
		}
		else
		{
			oItemHeader.dwLoopStart = 0;
			oItemHeader.dwLoopEnd = 0;
		}

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oItemHeader, sizeof(DMUS_IO_WAVE_ITEM_HEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_WAVE_ITEM_HEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_WAVEITEM_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_WAVEITEM_UI_CHUNK chunk
	if( ftFileType == FT_DESIGN )
	{
		ck.ckid = DMUS_FOURCC_WAVEITEM_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioWaveItemUI oWaveItemUI;
		ZeroMemory( &oWaveItemUI, sizeof(ioWaveItemUI) );

		// Fill in the members of the ioWaveItemUI structure
		oWaveItemUI.m_nLayerIndex = m_pWaveStrip->LayerToIndex( m_pLayer );
		oWaveItemUI.m_dwLoopStartUI = m_dwLoopStartUI;
		oWaveItemUI.m_dwLoopEndUI = m_dwLoopEndUI;
		oWaveItemUI.m_fLockLoopLengthUI = m_fLockLoopLengthUI;
		oWaveItemUI.m_fLockEndUI = m_fLockEndUI;
		oWaveItemUI.m_fLockLengthUI = m_fLockLengthUI;
		oWaveItemUI.m_fSyncDuration	= m_fSyncDuration;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oWaveItemUI, sizeof(ioWaveItemUI), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(ioWaveItemUI) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_WAVEITEM_UI_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the file reference chunk(s)
	{
		if( m_FileRef.pIDocRootNode )
		{
			if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
			{
				SaveDMRef( pIRiffStream, pIFramework, m_FileRef.pIDocRootNode, WL_PRODUCER );
			}
			else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
			{
				SaveDMRef( pIRiffStream, pIFramework, m_FileRef.pIDocRootNode, WL_DIRECTMUSIC );
				if( ftFileType == FT_DESIGN )
				{
					SaveProducerRef( pIRiffStream, pIFramework, m_FileRef.pIDocRootNode );
				}
			}
		}
	}

	// Ascend out of the DMUS_FOURCC_WAVE_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SaveDMRef

HRESULT CTrackItem::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdFramework* pIFramework,
							   IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( pIFramework != NULL );
	if( pIFramework == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( pIFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  CLSID_DirectSoundWave,
																  NULL,
																  whichLoader );
					break;

				case WL_DIRECTMUSIC:
				{
					hr = E_FAIL;

					// Get DocRoot of pIDocRootNode
					IDMUSProdDocType* pIDocType = NULL;
					if( SUCCEEDED ( pIFramework->FindDocTypeByNodeId( GUID_WaveNode, &pIDocType ) ) )
					{
						// Initialize the DMUS_OBJECTDESC structure
						DMUS_OBJECTDESC dmusObjectDesc;
						memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
						dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);

						// Get object descriptor for pIDocRootNode
						IDMUSProdDocType8* pIDocType8;
						if( SUCCEEDED ( pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 ) ) )
						{
							if( SUCCEEDED ( pIDocType8->GetObjectDescriptorFromNode( pIDocRootNode, &dmusObjectDesc ) ) )
							{
								hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																			  pIDocRootNode,
																			  CLSID_DirectSoundWave,
																			  &dmusObjectDesc,
																			  whichLoader );
							}

							RELEASE( pIDocType8 );
						}

						RELEASE( pIDocType );
					}
					break;
				}
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SaveProducerRef

HRESULT CTrackItem::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdFramework* pIFramework, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( pIFramework != NULL );
	if( pIFramework == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::FindWaveFile

IDMUSProdNode* CTrackItem::FindWaveFile( CString strWaveName, IStream* pIStream,
										 IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( pIFramework != NULL );
	ASSERT( pIStream != NULL );

	// Get DocType for DLS Collections
	hr = pIFramework->FindDocTypeByNodeId( GUID_WaveNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// If a target directory is not associated with the stream
	// use the strip's DocRoot node
	if( pITargetDirectoryNode == NULL )
	{
		pITargetDirectoryNode = pTrackMgr->GetDocRootNode();
	}

	// See if there is a wave named 'strWaveName' in this Project
	if( !strWaveName.IsEmpty() )
	{
		BSTR bstrWaveName = strWaveName.AllocSysString();

		if( FAILED ( pIFramework->GetBestGuessDocRootNode( pIDocType,
										 				   bstrWaveName,
														   pITargetDirectoryNode,
														   &pIDocRootNode ) ) )
		{
			pIDocRootNode = NULL;
		}
	}

	if( pIDocRootNode == NULL )
	{
		// Cannot find the Wave
		// If user cancelled previous search for this Wave, no need to ask again
		if( strWaveName.CompareNoCase( pTrackMgr->m_strLastWaveName ) == 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR; 
		}
		pTrackMgr->m_strLastWaveName = strWaveName;

		// Determine File Open dialog prompt
		CString	strOpenDlgTitle;
		if( strWaveName.IsEmpty() )
		{
			strOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_WAVE );
		}
		else
		{
			AfxFormatString1( strOpenDlgTitle, IDS_FILE_OPEN_WAVE, strWaveName );
		}
		BSTR bstrOpenDlgTitle = strOpenDlgTitle.AllocSysString();

		// Display File open dialog
		if( pIFramework->OpenFile(pIDocType, bstrOpenDlgTitle, pITargetDirectoryNode, &pIDocRootNode) != S_OK )
		{
			// Did not open a file, or opened file other than wave file
			// so we do not want this DocRoot
			if( pIDocRootNode )
			{
				pIDocRootNode->Release();
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		// Set dirty flag so that GUID_Segment_AllTracksAdded notification will call OnUpdate()
		pTrackMgr->SetDirtyFlag( TRUE );
	}

ON_ERROR:
	if( pIDocType )
	{
		pIDocType->Release();
	}

	return pIDocRootNode;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SwitchTimeBase

void CTrackItem::SwitchTimeBase( void )
{
	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtActualEnd;

		// Switching from MUSIC_TIME to REFERENCE_TIME
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( (MUSIC_TIME)m_rtTimePhysical + (MUSIC_TIME)m_rtDuration, &rtActualEnd );
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( (MUSIC_TIME)m_rtTimePhysical, &m_rtTimePhysical );
		m_rtDuration = rtActualEnd - m_rtTimePhysical;
		m_rtTimeLogical = m_rtTimePhysical;
	}
	else
	{
		MUSIC_TIME mtActualEnd;
		MUSIC_TIME mtTime;

		// Switching from REFERENCE_TIME to MUSIC_TIME
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( m_rtTimePhysical + m_rtDuration, &mtActualEnd );
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( m_rtTimePhysical, &mtTime );
		m_rtTimePhysical = mtTime;
		m_rtDuration = mtActualEnd - (MUSIC_TIME)m_rtTimePhysical;;
		SetTimePhysical( m_rtTimePhysical, STP_LOGICAL_SET_DEFAULT );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::DrawWave

HRESULT	CTrackItem::DrawWave( HDC hDC, LONG lXOffset, int nLayerIndex,
							  WaveDrawParams* pWDP, WaveTimelineInfoParams* pWTIP )
{
	// Get our clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Update WaveTimelineInfoParams struct 
	REFERENCE_TIME rtActualEnd = m_rtTimePhysical + (m_rtDuration + 1);
	m_pTrackMgr->UnknownTimeToRefTime( rtActualEnd, &rtActualEnd );
	m_pTrackMgr->UnknownTimeToRefTime( m_rtTimePhysical, &pWTIP->rtStart );
	pWTIP->rtDuration = rtActualEnd - pWTIP->rtStart;
	pWTIP->rtOffset = PitchAdjustedStartOffset();
	pWTIP->rtDuration -= pWTIP->rtOffset;
	pWTIP->lPitch = m_lPitch;
	if( m_fLoopedUI )
	{
		pWTIP->dwFlags = WAVE_LOOPED;
		pWTIP->dwLoopStart = m_dwLoopStartUI;
		pWTIP->dwLoopEnd = m_dwLoopEndUI;
	}
	else
	{
		pWTIP->dwFlags = 0;
		pWTIP->dwLoopStart = 0;
		pWTIP->dwLoopEnd = 0;
	}

	// Set m_rectWave.top
	// Set m_rectWave.bottom
	m_pWaveStrip->IndexToLayerYCoords( nLayerIndex, &m_rectWave );
	m_rectWave.top++;

	// Set m_rectWave.left
	long lPosition;
	m_pTrackMgr->m_pTimeline->RefTimeToPosition( pWTIP->rtStart, &lPosition );
	lPosition += -lXOffset + 1;
	m_rectWave.left = lPosition;

	// Set m_rectWave.right
	m_pTrackMgr->m_pTimeline->RefTimeToPosition( (rtActualEnd - pWTIP->rtOffset), &lPosition );
	lPosition += -lXOffset + 1;
	m_rectWave.right = lPosition;

	// Check if the left edge of the item is beyond the region we're displaying
	if( m_rectWave.left > rectClip.right )
	{
		// Wave not visible
		return S_FALSE;
	}

	// Check if the right edge of the item is before the region we're displaying
	if( m_rectWave.right <= rectClip.left )
	{
		// Wave not visible
		return S_FALSE;
	}

	if( m_rectWave.left == m_rectWave.right )
	{
		m_rectWave.right++;
	}
	ASSERT( m_rectWave.left < m_rectWave.right );

	// Draw the wave
	if( m_FileRef.pIDocRootNode )
	{
		if( m_rectWave.left < m_rectWave.right )
		{
			IDMUSProdWaveTimelineDraw* pIWaveTimelineDraw;
			if( SUCCEEDED ( m_FileRef.pIDocRootNode->QueryInterface( IID_IDMUSProdWaveTimelineDraw, (void **)&pIWaveTimelineDraw ) ) )
			{
				if( nLayerIndex >= 0 )
				{
					m_rectWave.top += 8;
				}
				pIWaveTimelineDraw->DrawWave( m_pTrackMgr->m_pTimeline, hDC, &m_rectWave, lXOffset, pWDP, pWTIP );
				if( nLayerIndex >= 0 )
				{
					m_rectWave.top -= 8;
				}

				RELEASE( pIWaveTimelineDraw );
			}
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SetTimePhysical

HRESULT CTrackItem::SetTimePhysical( REFERENCE_TIME rtTimePhysical, short nAction )
{
	// Set item's physical time
	REFERENCE_TIME rtOrigTimePhysical = m_rtTimePhysical;
	m_rtTimePhysical = rtTimePhysical;

	if( m_pTrackMgr 
	&&  m_pTrackMgr->IsRefTimeTrack() )
	{
		m_rtTimeLogical = max( 0, m_rtTimePhysical );
		return S_OK;
	}

	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		if( nAction == STP_LOGICAL_NO_ACTION )
		{
			return S_OK;
		}
		else
		{
			ASSERT( 0 );
			return E_UNEXPECTED;
		}
	}

	// Set logical time
	// RefTimeTrack handled above so we can assume we are dealing with clocks at this point
	long lMeasure, lBeat, lGrid, lTick;
	switch( nAction )
	{
		case STP_LOGICAL_NO_ACTION:
			// Nothing to do
			break;

		case STP_LOGICAL_SET_DEFAULT:
		{
			MUSIC_TIME mtTimePhysical;
			MUSIC_TIME mtTimeLogical;
			m_pTrackMgr->UnknownTimeToClocks( m_rtTimePhysical, &mtTimePhysical );
			m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTimePhysical, &lMeasure, &lBeat, &lGrid, &lTick );
			m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtTimeLogical );
			m_rtTimeLogical = mtTimeLogical;
			break;
		}

		case STP_LOGICAL_FROM_BEAT_OFFSET:
		{
			MUSIC_TIME mtTimePhysical;
			MUSIC_TIME mtTimeLogical;

			// Get track GroupBits
			DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();

			// Snap new physical time to number of beats
			long lPhysicalBeats;
			m_pTrackMgr->UnknownTimeToClocks( m_rtTimePhysical, &mtTimePhysical );
			m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTimePhysical, &lMeasure, &lBeat, &lGrid, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + (MUSIC_TIME)m_rtTimeLogical;	// m_rtTimeLogical stores beat offset
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pTrackMgr->ForceBoundaries( lMeasure, lBeat, &mtTimeLogical );
			m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTimeLogical, &lMeasure, &lBeat, &lGrid, &lTick );
			m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtTimeLogical );
			m_rtTimeLogical = mtTimeLogical;
			break;
		}

		case STP_LOGICAL_ADJUST:
		{
			MUSIC_TIME mtTimePhysical;
			MUSIC_TIME mtTimeLogical;

			// Get track GroupBits
			DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();

			// Snap original physical time to number of beats
			long lPhysicalBeats;
			m_pTrackMgr->UnknownTimeToClocks( rtOrigTimePhysical, &mtTimePhysical );
			m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTimePhysical, &lMeasure, &lBeat, &lGrid, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Convert logical time to number of beats
			long lLogicalBeats;
			m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_rtTimeLogical, &lMeasure, &lBeat, &lGrid, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Compute difference between original physical time and original logical time
			long lBeatDiff = lLogicalBeats - lPhysicalBeats;

			// Snap new physical time to number of beats
			m_pTrackMgr->UnknownTimeToClocks( m_rtTimePhysical, &mtTimePhysical );
			m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTimePhysical, &lMeasure, &lBeat, &lGrid, &lTick );
			MeasureBeatToBeats( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + lBeatDiff;
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pTrackMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pTrackMgr->ForceBoundaries( lMeasure, lBeat, &mtTimeLogical );
			m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTimeLogical, &lMeasure, &lBeat, &lGrid, &lTick );
			m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtTimeLogical );
			m_rtTimeLogical = mtTimeLogical;
			break;
		}

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	// Make sure item's logical time is not less than zero
	if( m_rtTimeLogical < 0 )
	{
		ASSERT( 0 );
		m_rtTimeLogical = 0;
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::SetTimeLogical
	
HRESULT CTrackItem::SetTimeLogical( REFERENCE_TIME rtTimeLogical )
{
	ASSERT( m_pTrackMgr != NULL );
	if( m_pTrackMgr == NULL )
	{
		// Will be NULL when CTrackItem used for properties!
		return E_FAIL;
	}

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		// Cannot edit logical time in REFERENCE_TIME tracks
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Make sure item's logical time is not less than zero
	if( rtTimeLogical < 0 )
	{
		ASSERT( 0 );
		rtTimeLogical = 0;
	}

	// Set item's logical time
	m_rtTimeLogical = rtTimeLogical;

	if( m_pTrackMgr == NULL 
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Set item's logical measure, beat
	MUSIC_TIME mtTimeLogical;
	long lMeasure, lBeat, lGrid, lTick;
	m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_rtTimeLogical, &lMeasure, &lBeat, &lGrid, &lTick );
	m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtTimeLogical );
	m_rtTimeLogical = mtTimeLogical;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SetWaveStripForPropSheet

HRESULT CTrackItem::SetWaveStripForPropSheet( CWaveStrip* pWaveStrip )
{
	m_pWaveStrip = pWaveStrip;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::GetWaveStripForPropSheet

CWaveStrip* CTrackItem::GetWaveStripForPropSheet( void ) const
{
	return m_pWaveStrip;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SetTrackMgr

HRESULT CTrackItem::SetTrackMgr( CTrackMgr* pTrackMgr )
{
	m_pTrackMgr = pTrackMgr;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::GetTrackMgr

CTrackMgr* CTrackItem::GetTrackMgr( void ) const
{
	return m_pTrackMgr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::PitchAdjustedStartOffset

REFERENCE_TIME CTrackItem::PitchAdjustedStartOffset( void )
{
	if( m_rtStartOffset
	&&  m_lPitch )
	{
		if( m_FileRef.pIDocRootNode )
		{
			IDMUSProdWaveTimelineDraw* pIWaveTimelineDraw;
			if( SUCCEEDED ( m_FileRef.pIDocRootNode->QueryInterface( IID_IDMUSProdWaveTimelineDraw, (void **)&pIWaveTimelineDraw ) ) )
			{
				REFERENCE_TIME rtAdjustedOffset;
				DWORD dwSample;

				if( SUCCEEDED ( pIWaveTimelineDraw->RefTimeToSample( m_rtStartOffset, &dwSample, 0 ) )
				&&  SUCCEEDED ( pIWaveTimelineDraw->SampleToRefTime( dwSample, &rtAdjustedOffset, m_lPitch ) ) )
				{
					RELEASE( pIWaveTimelineDraw );
					return rtAdjustedOffset;
				}

				RELEASE( pIWaveTimelineDraw );
			}
		}
	}

	return m_rtStartOffset;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::StartOffsetToUnknownTime

HRESULT CTrackItem::StartOffsetToUnknownTime( CTrackMgr* pTrackMgr, REFERENCE_TIME* prtStartOffset )
{
	if( prtStartOffset == NULL )
	{
		return E_POINTER;
	}
	*prtStartOffset = 0;

	// Must be passed a CTrackMgr* since properties m_Item correctly does not set m_pTrackMgr
	if( pTrackMgr == NULL 
	||  pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	REFERENCE_TIME rtPitchAdjustedStartOffset = PitchAdjustedStartOffset();

	REFERENCE_TIME utStartOffset;
	REFERENCE_TIME rtTimePhysical;
	if( SUCCEEDED ( pTrackMgr->UnknownTimeToRefTime( m_rtTimePhysical, &rtTimePhysical ) ) 
	&&  SUCCEEDED ( pTrackMgr->RefTimeToUnknownTime( rtTimePhysical + rtPitchAdjustedStartOffset, &utStartOffset ) ) )
	{
		*prtStartOffset = utStartOffset - m_rtTimePhysical;
		return S_OK;
	}

	ASSERT( 0 );
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SourceWaveLengthToUnknownTime

HRESULT CTrackItem::SourceWaveLengthToUnknownTime( CTrackMgr* pTrackMgr, REFERENCE_TIME* prtSourceWaveLength )
{
	if( prtSourceWaveLength == NULL )
	{
		return E_POINTER;
	}
	*prtSourceWaveLength = 0;

	// Must be passed a CTrackMgr* since properties m_Item correctly does not set m_pTrackMgr
	if( pTrackMgr == NULL 
	||  pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	REFERENCE_TIME utWaveActualEnd;
	REFERENCE_TIME rtTimePhysical;
	if( SUCCEEDED ( pTrackMgr->UnknownTimeToRefTime( m_rtTimePhysical, &rtTimePhysical ) ) 
	&&  SUCCEEDED ( pTrackMgr->RefTimeToUnknownTime( rtTimePhysical + m_WaveInfo.rtWaveLength, &utWaveActualEnd ) ) )
	{
		*prtSourceWaveLength = utWaveActualEnd - m_rtTimePhysical;
		return S_OK;
	}

	ASSERT( 0 );
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::RefreshWave

HRESULT CTrackItem::RefreshWave( void )
{
	if( m_FileRef.pIDocRootNode == NULL 
	||  m_pWaveStrip == NULL )
	{
		// Nothing to do
		return S_OK;
	}

	// Get the corresponding DirectSound Wave object
	IDirectSoundWave* pIDSWave;
	if( FAILED ( m_FileRef.pIDocRootNode->GetObject( CLSID_DirectSoundWave, IID_IDirectSoundWave, (void **)&pIDSWave ) ) )
	{
		return E_UNEXPECTED;
	}

	HRESULT hr = S_OK;

	IUnknown* pIUnknown = NULL;

	// Get pIUnknown for RefreshWave method
	IDirectMusicPerformance8* pIDMPerformance8;
	if( SUCCEEDED ( m_pTrackMgr->GetObject( CLSID_DirectMusicPerformance, IID_IDirectMusicPerformance8, (void **)&pIDMPerformance8 ) ) )
	{
		IDirectMusicAudioPath* pIDMAudioPath;
		if( SUCCEEDED ( pIDMPerformance8->GetDefaultAudioPath( &pIDMAudioPath ) ) )
		{
			if( FAILED ( pIDMAudioPath->QueryInterface( IID_IUnknown, (void **)&pIUnknown ) ) )
			{
				pIUnknown = NULL;
			}

			RELEASE( pIDMAudioPath );
		}
		else
		{
			if( FAILED ( pIDMPerformance8->QueryInterface( IID_IUnknown, (void **)&pIUnknown ) ) )
			{
				pIUnknown = NULL;
			}
		}

		RELEASE( pIDMPerformance8 );
	}
	ASSERT( pIUnknown != NULL );

	if( pIUnknown )
	{
		// Get the IPrivateWaveTrack interface
		IPrivateWaveTrack* pIPrivateWaveTrack;
		if( SUCCEEDED ( m_pTrackMgr->GetObject( CLSID_DirectMusicWaveTrack, IID_IPrivateWaveTrack, (void **)&pIPrivateWaveTrack ) ) )
		{
			// Refresh the Wave
			hr = pIPrivateWaveTrack->RefreshWave( pIDSWave, pIUnknown,
												  m_pWaveStrip->GetPChannel(), m_WaveInfo.guidVersion );
			RELEASE( pIPrivateWaveTrack );
		}

		RELEASE( pIUnknown );
	}

	RELEASE( pIDSWave );
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\WaveStripLayer.h ===
#ifndef __WAVE_STRIPLAYER_H_
#define __WAVE_STRIPLAYER_H_

class CWaveStrip;


class CWaveStripLayer
{
friend class CWaveStrip;

public:
	CWaveStripLayer( CWaveStrip* pWaveStrip );
	virtual ~CWaveStripLayer();

private:
	CWaveStrip*		m_pWaveStrip;
	BOOL			m_fSelected;
};

#endif // __WAVE_STRIPLAYER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\WaveStripLayer.cpp ===
#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "WaveStripLayer.h"
#include "TrackMgr.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CWaveStripLayer Constructors/Destructor

CWaveStripLayer::CWaveStripLayer( CWaveStrip* pWaveStrip )
{
	ASSERT( pWaveStrip != NULL );
	m_pWaveStrip = pWaveStrip;

	m_fSelected = FALSE;
}

CWaveStripLayer::~CWaveStripLayer( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TrackMgr.h ===
// TrackMgr.h : Declaration of the CTrackMgr

#ifndef __WAVE_TRACKMGR_H_
#define __WAVE_TRACKMGR_H_

#include "resource.h"		// main symbols
#include "WaveStripMgr.h"
#include "WaveStripLayer.h"
#include "TrackItem.h"
#include "PropTrackItem.h"
#include "LayerScrollBar.h"
#include "selectedregion.h"
#include "BaseMgr.h"
#include <AList.h>
#include <dsoundp.h>

interface IDirectMusicVoiceP;

// Private interface for wave track
DEFINE_GUID(IID_IPrivateWaveTrack, 0x492abe2a, 0x38c8, 0x48a3, 0x8f, 0x3c, 0x1e, 0x13, 0xba, 0x1, 0x78, 0x4e);
interface IPrivateWaveTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetVariation(
		IDirectMusicSegmentState* pSegState,
		DWORD dwVariationFlags,
		DWORD dwPChannel,
		DWORD dwIndex)=0;
    virtual HRESULT STDMETHODCALLTYPE ClearVariations(IDirectMusicSegmentState* pSegState)=0;
    virtual HRESULT STDMETHODCALLTYPE AddWave(
		IDirectSoundWave* pWave,
		REFERENCE_TIME rtTime,
		DWORD dwPChannel,
		DWORD dwIndex,
		REFERENCE_TIME* prtLength)=0;
    virtual HRESULT STDMETHODCALLTYPE DownloadWave(
		IDirectSoundWave* pWave,   // wave to download
		IUnknown* pUnk,            // performance or audio path
		REFGUID rguidVersion)=0;   // version of downloaded wave
    virtual HRESULT STDMETHODCALLTYPE UnloadWave(
		IDirectSoundWave* pWave,   // wave to unload
		IUnknown* pUnk)=0;         // performance or audio path
    virtual HRESULT STDMETHODCALLTYPE RefreshWave(
		IDirectSoundWave* pWave,   // wave to refresh
		IUnknown* pUnk,            // performance or audio path
		DWORD dwPChannel,          // new PChannel for the wave
		REFGUID rguidVersion)=0;;  // version of refreshed wave
    virtual HRESULT STDMETHODCALLTYPE FlushAllWaves()=0;
    virtual HRESULT STDMETHODCALLTYPE OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)=0;
};

// Private interface for wave track
DEFINE_GUID(IID_IPrivateWaveTrack9, 0x49095b17, 0xf46a, 0x4acb, 0xa2, 0xee, 0x1e, 0x5f, 0x58, 0xc8, 0x4e, 0x7c);
interface IPrivateWaveTrack9 : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetVariationMask(
		IDirectMusicSegmentState* pSegState,
		DWORD dwVariationFlags,
		DWORD dwPChannel,
		DWORD dwIndex)=0;
};

typedef struct CFProducerFile			// Used when working with CF_DMUSPROD_FILE clipboard data
{
    GUID	guidFile;
	CString strFileName;
} CFProducerFile;

#ifndef REFCLOCKS_PER_MINUTE
#define REFCLOCKS_PER_MINUTE 600000000
#endif

#ifndef REFCLOCKS_PER_SECOND
#define REFCLOCKS_PER_SECOND 10000000
#endif

#ifndef REFCLOCKS_PER_MILLISECOND
#define REFCLOCKS_PER_MILLISECOND 10000
#endif

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK )

class CTrackMgr;
class CWaveStrip;
class CTrackItem;
class CDllJazzDataObject;
interface IDirectMusicTrack;

void EmptyList( CTypedPtrList<CPtrList, CTrackItem*>& list );
void NormalizeList( CTrackMgr* pTrackMgr, CTypedPtrList<CPtrList, CTrackItem*>& list, REFERENCE_TIME rtOffset );

#define MAX_TICK (DMUS_PPQ << 1)
#define MINIMUM_ZOOM_LEVEL	(0.07)
#define MAX_WAVE_HEIGHT		100
#define MAX_NBR_LAYERS		99
#define HORIZ_LINE_HEIGHT	1

#define MIN_LOOP_LENGTH		5
#define MAX_LOOP_LENGTH		524286

#define MIN_NBR_GRIDS_PER_SECOND		1
#define MAX_NBR_GRIDS_PER_SECOND		100
#define DEFAULT_NBR_GRIDS_PER_SECOND	1

#define VARIATION_BUTTON_HEIGHT		15
#define VARIATION_BUTTONS_HEIGHT	(VARIATION_BUTTON_HEIGHT << 1)
#define VARIATION_BUTTON_WIDTH		17
#define VARIATION_BUTTONS_WIDTH		(VARIATION_BUTTON_WIDTH << 4)
#define VARIATION_GUTTER_HEIGHT		30
#define VARIATION_GUTTER_WIDTH		 8

#define STRIP_MINIMIZE_HEIGHT		20
#define STRIP_MIN_HEIGHT			VARIATION_BUTTONS_HEIGHT

// Timer defines
#define TIMER_ZOOM_1				150
#define TIMER_ZOOM_2				151
#define TIMER_VSCROLL_LAYER_1		160
#define TIMER_VSCROLL_LAYER_2		161

// Mouse modes
#define MM_VARBTNS					1
#define MM_ZOOMBTNS					2
#define MM_LAYERBTNS				3

// Variation actions
#define VA_NONE						0					
#define VA_ENABLING					1					
#define VA_DISABLING				2					

// Chunk ID used for wave track design data
#define DMUS_FOURCC_WAVEPART_UI_LIST        mmioFOURCC('w','p','l','u')
#define DMUS_FOURCC_WAVEPART_UI_CHUNK       mmioFOURCC('w','p','c','u')
#define DMUS_FOURCC_WAVEITEM_UI_CHUNK		mmioFOURCC('w','v','c','u')
#define DMUS_FOURCC_COPYPASTE_UI_CHUNK		mmioFOURCC('c','p','c','u')

// Part State flags
#define PARTUI_ACTIVESTRIP		0x00000001

struct ioWavePartUI
{
	ioWavePartUI()
	{
		m_dwVariationBtns = 0xFFFFFFFF;
		m_dwOldVariationBtns = m_dwVariationBtns;
		m_dblVerticalZoom = 0.4;
		m_lVerticalScrollYPos = 0;
		m_lStripHeight = VARIATION_BUTTONS_HEIGHT + (2 * long(MAX_WAVE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT));
		m_nStripView = SV_NORMAL;
		m_nSnapToRefTime = IDM_SNAP_GRID;
		m_nSnapToMusicTime = IDM_SNAP_GRID;
		m_dwFlagsUI = 0;
		m_fVarGutterDown = true;
		m_nNbrLayers = 1;
		m_nSnapToRefTime_GridsPerSecond = DEFAULT_NBR_GRIDS_PER_SECOND;
	}

	DWORD		m_dwVariationBtns;		// Which variations are viewed
	double		m_dblVerticalZoom;		// Vertical zoom factor
	long		m_lVerticalScrollYPos;	// Vertical scroll Y position
	long		m_lStripHeight;			// Height of strip
	int			m_nStripView;			// Minimized or maximized
	short		m_nSnapToRefTime;		// 'Snap To' increment when moving waves with mouse (DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
	short		m_nSnapToMusicTime;		// 'Snap To' increment when moving waves with mouse (!DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
	DWORD		m_dwFlagsUI;			// various state flags (see PARTUI_ prefix)
	DWORD		m_dwOldVariationBtns;	// Previous button state (used when soloing)
	bool		m_fVarGutterDown;		// State of variation gutter
	int			m_nNbrLayers;			// Numbers of layers
	short	    m_nSnapToRefTime_GridsPerSecond;
};

struct ioWaveItemUI
{
	ioWaveItemUI()
	{
		m_nLayerIndex = 0;
		m_dwLoopStartUI = 0;
		m_dwLoopEndUI = 0;
		m_fLockLoopLengthUI = FALSE;
		m_fLockEndUI = FALSE;
		m_fLockLengthUI = FALSE;
		m_fSyncDuration = TRUE;
	}

	int		m_nLayerIndex;				// Wave displays in this layer
    DWORD   m_dwLoopStartUI;			// Start point for a looping wave
    DWORD   m_dwLoopEndUI;				// End point for a looping wave
	BOOL	m_fLockLoopLengthUI;		// State of 'Lock Loop Length' button (Loop Tab)
	BOOL	m_fLockEndUI;				// State of 'Lock End' button (FileRef Tab)
	BOOL	m_fLockLengthUI;			// State of 'Lock Length' button (FileRef Tab)
	BOOL	m_fSyncDuration;			// Always sync duration to actual length of wave
};

struct ioCopyPasteUI
{
	ioCopyPasteUI()
	{
		m_rtPasteOverwriteRange = 0;	
		m_rtOffset = 0;
		m_rtStartTime = 0;
		m_lRefTimeSec = 0;
		m_lRefTimeGrid = 0;
		m_lRefTimeMs = 0;
		m_mtPasteOverwriteRange = 0;	
		m_mtOffset = 0;
		m_mtStartTime = 0;
		m_lMusicTimeBeat = 0;
		m_lMusicTimeGrid = 0;	
		m_lMusicTimeTick = 0;	
		m_nStartLayerIndex = 0;	
		m_nMinLayerIndex = 0;	
		m_nMaxLayerIndex = 0;
		m_fRefTimeTrack = false;
	}

	REFERENCE_TIME	m_rtPasteOverwriteRange;// Total clock time of list (REFERENCE_TIME)
	REFERENCE_TIME	m_rtOffset;				// Offset from start of wave (REFERENCE_TIME)
	REFERENCE_TIME  m_rtStartTime;			// Start time of first item in list (REFERENCE_TIME)
	long			m_lRefTimeSec;			// Beat offset of first item in list
	long			m_lRefTimeGrid;			// Grid offset of first item in list
	long			m_lRefTimeMs;			// Tick offset of first item in list
	MUSIC_TIME		m_mtPasteOverwriteRange;// Total clock time of list (MUSIC_TIME)
	MUSIC_TIME		m_mtOffset;				// Offset from start of wave (REFERENCE_TIME)
	MUSIC_TIME		m_mtStartTime;			// Start time of first item in list (MUSIC_TIME)
	long			m_lMusicTimeBeat;		// Beat offset of first item in list
	long			m_lMusicTimeGrid;		// Grid offset of first item in list
	long			m_lMusicTimeTick;		// Tick offset of first item in list
	int				m_nStartLayerIndex;		// Layer of first item in list
	int				m_nMinLayerIndex;		// First layer 
	int				m_nMaxLayerIndex;		// Last layer 
	bool			m_fRefTimeTrack;		// Time is REFERENCE_TIME
};


struct QueuedWave
{
	QueuedWave()
	{
		pIDSWave = NULL;
		lDownloadCount = 0;
		memset( &guidVersion, 0, sizeof(GUID) );
	}

	~QueuedWave()
	{
		RELEASE( pIDSWave );
	}

	IDirectSoundWave* pIDSWave;			// Wave object
	GUID			  guidVersion;		// Wave version
    long			  lDownloadCount;	// Unload if less than zero, download if greater than zero
};


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr class

class ATL_NO_VTABLE CTrackMgr : 
	public CBaseMgr,
	public CComCoClass<CTrackMgr, &CLSID_WaveMgr>,
	public IWaveMgr
{
friend CWaveStrip;

public:
	CTrackMgr();
	~CTrackMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_TRACKMGR)

BEGIN_COM_MAP(CTrackMgr)
	COM_INTERFACE_ENTRY_IID(IID_IWaveMgr,IWaveMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr overrides

// IWaveMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( long lMeasure, long lBeat );

// IDMUSProdStripMgr overrides
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersist overrides

// IPersistStream overrides
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );

// IDMUSProdPropPageObject overrides
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

protected:
	// Overrides of CBaseMgr
	bool	RecomputeTimes();			 // Returns true if anything changed
	HRESULT	SyncWithDirectMusic( void ); // Returns S_OK if succeeded, S_FALSE if no track, E_* if failed.
	
// Performs action on CTrackMgr
	void	InsertByAscendingPChannel( CWaveStrip *pWaveStrip );

// Performs action on all CWaveStrips
	void	AllStrips_Invalidate();
	void	AllStrips_ResetIndexes();
	void	AllStrips_AddToTimeline();
	void	AllStrips_RemoveFromTimeline();
	void	AllStrips_DeleteAllParts();
	void	AllStrips_DeleteSelectedParts();
	void	AllStrips_GetWaveInfo();
	void	AllStrips_SwitchTimeBase();
	BOOL	AllStrips_SetNbrGridsPerSecond( short nNbrGridsPerSecond );

// Performs action on one CWaveStrip
	HRESULT AddStripToTimeline( CWaveStrip* pWaveStrip, int nPosition );
	HRESULT RemoveStripFromTimeline( CWaveStrip* pWaveStrip );
	HRESULT OnNewPart();
	HRESULT DeletePart( CWaveStrip* pWaveStrip );
	HRESULT RepositionPart( CWaveStrip* pWaveStrip );

// Download/Unload waves
	QueuedWave* GetQueuedWave( IDirectSoundWave* pIDSWave, GUID guidVersion );
	void UnloadQueuedWaves();
	void DownloadQueuedWaves();
	void FlushAllWaves();

public:
// General helpers
	REFERENCE_TIME GetSegmentLength();	// MUSIC_TIME or REFERENCE_TIME
	HRESULT GetPChannelName( DWORD dwPChannel, CString& strPChannelName );
	HRESULT GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 
	bool    IsRefTimeTrack();
	bool	IsValidLockID( DWORD dwLockID );
	bool	StripExists( DWORD dwPChannel );
	DWORD	GetGreatestUsedPChannel();
	HRESULT SetAuditionVariations( bool fForceClear );
	CWaveStrip* GetActiveStripInThisTrack();
	CWaveStrip* GetWaveStrip( DWORD dwPChannel, DWORD dwIndex );
	CBitmap* GetLockBitmap( BOOL fLocked );
	void	UpdateStatusBarDisplay( void );

// Download/Unload waves
	HRESULT QueueWaveForDownload( CTrackItem* pItem );
	HRESULT QueueWaveForUnload( CTrackItem* pItem );

// Performs action on CTrackMgr
	void	SetDirtyFlag( bool fDirty );

// Performs action on one CWaveStrip
	HRESULT AddPart( DWORD dwPChannel );

	HRESULT	RefTimeToMinSecGridMs( CWaveStrip* pWaveStrip, REFERENCE_TIME rtTime, long* plMinute, long* plSecond, long* plGrid, long* plMillisecond );
	HRESULT	MinSecGridMsToRefTime( CWaveStrip* pWaveStrip, long lMinute, long lSecond, long lGrid, long lMillisecond, REFERENCE_TIME* prtTime );
	HRESULT	ClocksToMeasureBeatGridTick( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick );
	HRESULT	MeasureBeatGridTickToClocks( long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME* pmtTime );
	HRESULT ForceBoundaries( long lMeasure, long lBeat, MUSIC_TIME* pmtTime );
	DWORD	GetGroupBits();
	HRESULT SaveTrackHeader( IDMUSProdRIFFStream* pIRiffStream );

	HRESULT	UnknownTimeToMeasureBeatGridTick( REFERENCE_TIME rtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick );
	HRESULT	MeasureBeatGridTickToUnknownTime( long lMeasure, long lBeat, long lGrid, long lTick, REFERENCE_TIME* prtTime );
	HRESULT	SnapUnknownTimeToBeat( REFERENCE_TIME rtTime, REFERENCE_TIME* prtBeatTime );
	HRESULT ClocksToUnknownTime( MUSIC_TIME mtTime, REFERENCE_TIME* prtTime );
	HRESULT UnknownTimeToClocks( REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime );
	HRESULT RefTimeToUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime );
	HRESULT UnknownTimeToRefTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime );

public:
	CString		m_strLastWaveName;
	bool		m_fInAllTracksAdded;
	bool		m_fWasRuntimeTrack;

protected:
	IDirectMusicPerformance*	m_pIDMPerformance;
	IDirectMusicSegmentState*	m_pIDMSegmentState;
	CWaveStrip*					m_pWaveStripForPropSheet;
	HANDLE						m_hStatusBar;
	bool						m_fForceVariationBtnsClear;

	// Fields that are persisted (DirectMusic wave track data)
	long		m_lVolume;
	DWORD		m_dwTrackFlagsDM;		// Various flags pertaining to entire track	

	CTypedPtrList<CPtrList, CWaveStrip*> m_lstWaveStrips;
	CTypedPtrList<CPtrList, QueuedWave*> m_lstQueuedWaves;	// For download/unload
};


/////////////////////////////////////////////////////////////////////////////
// CWaveRectItem class

class CWaveRectItem : public AListItem
{
friend class CWaveStrip;

public:
	CWaveRectItem( RECT* pRect ){ m_rect = *pRect; }
	virtual ~CWaveRectItem() {}
	CWaveRectItem* GetNext() { return (CWaveRectItem*) AListItem::GetNext(); }

protected:
	CRect		m_rect;		// Wave rectangle
};


/////////////////////////////////////////////////////////////////////////////
// CWaveRectList class

class CWaveRectList : public AList
{
public:
	virtual ~CWaveRectList() { if(m_pHead != NULL) delete m_pHead; } 
    CWaveRectItem *GetHead() const { return (CWaveRectItem *)AList::GetHead(); };
    CWaveRectItem *RemoveHead() { return (CWaveRectItem *)AList::RemoveHead(); };
};


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip class

class CWaveStrip :
	public CBaseStrip
{
friend CTrackMgr;

public:
	CWaveStrip( CTrackMgr* pTrackMgr );
	~CWaveStrip();

public:
// IDMUSProdStrip overrides
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar overrides
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit overrides
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );

// IDropSource overrides

// IDropTarget overrides
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// General helper overrides
	HRESULT	PostRightClickMenu( POINT pt );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

protected:
	HRESULT	DrawMinimizedStrip( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT	DrawMaximizedStrip( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	void	DrawHorizontalLines( HDC hDC, const RECT &rectClip );
	void	DrawClockVerticalLines( HDC hDC, long lXOffset );
	void	DrawVariationButtonBar( HDC hDC );
	void	HighlightTimelineRange( HDC hDC, long lXOffset );
	void	InvalidateVariationBtns();
	void	InvalidateWaves();
	void	InvalidateFBar();
	void	UnselectGutterRange();
	HRESULT OnCreate();
	HRESULT OnDestroy();

// IDropTarget helpers 
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lXPos, bool bDropNotPaste, BOOL &fChanged );

// IDropSource helpers
	HRESULT CreateDataObject(IDataObject**, long lXPos, long lYPos );
	HRESULT	DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos, long lYPos );

// IDMUSProdPropPageObject helpers
	BOOL SetData_TabFileRef( CPropTrackItem* pPropItem, CTrackItem* pItem );
	BOOL SetData_TabLoop( CPropTrackItem* pPropItem, CTrackItem* pItem );
	BOOL SetData_TabPerformance( CPropTrackItem* pPropItem, CTrackItem* pItem );
	BOOL SetData_TabVariations( CPropTrackItem* pPropItem, CTrackItem* pItem );

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnLButtonUp( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnMouseMove( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnChar( WPARAM wParam );
	
	HRESULT OnLButtonDblClkVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnLButtonDownVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnLButtonUpVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnRButtonDownVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnRButtonUpVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnMouseMoveVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	
	HRESULT OnLButtonDownZoomBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnLButtonUpZoomBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);

	HRESULT OnLButtonDownLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnLButtonUpLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnRButtonDownLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnRButtonUpLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );
	HRESULT OnMouseMoveLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

	int	XYPosToVariation( long lXPos, long lYPos );

	CTrackItem* GetItemFromPoint( long lXPos, long lYPos );
	bool SelectItemsInSelectedRegions();
	void SelectRegionsFromSelectedItems();	
	BOOL RegisterClipboardFormats();

	CTrackItem* GetNextItemInLayer( POSITION pos, CWaveStripLayer* pLayer );
	CTrackItem* GetNextSelectedItemInLayer( POSITION pos, CWaveStripLayer* pLayer );
	CTrackItem* GetNextItem( POSITION pos );
	CTrackItem* GetNextSelectedItem( POSITION pos );
	CTrackItem* GetFirstSelectedItem();
	
	// Overrides of CBaseStrip
	bool	IsSelected();	// Returns true if any items are selected
	bool	IsEmpty();		// Returns false if there are any items
	bool	SelectSegment( MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime );

	// From CTrackMgr
	void	UnselectAll();
	void	InsertByAscendingTime( CTrackItem *pItem, BOOL fPaste );
	bool	DeleteBetweenMeasureBeats( long lmStart, long lbStart, long lmEnd, long lbEnd );
	HRESULT OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT	SaveSelectedItems( IStream* pIStream, REFERENCE_TIME rtOffset, CTrackItem* pItemAtDragPoint );
	HRESULT OnEnableVariations( WORD wID );
	void	MarkSelectedItems( DWORD flags );
	void	UnMarkItems( DWORD flags );
	void	DeleteMarked( DWORD flags );
	void	DeleteSelectedItems();

	// New methods
	void	CleanUp();
	HRESULT	GetWaveInfo();
	void	SwitchTimeBase();
	void	GetFBName( CString& strFBName );
	void	OnShowStripProperties();
	void	OnShowItemProperties();
	void	SetZoom( double dblVerticalZoom );
	void	TimelineToWavePartUI();
	void	WavePartUIToTimeline();
	void	MergeVariations();
	DWORD	MapVariations( DWORD dwOrigVariations, DWORD dwVariationMap[32] );
	REFERENCE_TIME CalculatePasteTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI );
	REFERENCE_TIME CalculateDropTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI );
	void	RefreshPropertyPage( void );
	void	UpdatePlayingVariation( bool fRefreshDisplayIfNecessary = true );
	void	KillVariationTimer( void );
	void	EnableVariationTimer( void );
	IDMUSProdNode *EnsureFileIsOpen( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT LoadCF_DMUSPROD_FILE( IStream* pIStream, CFProducerFile* pProducerFile );

	HRESULT LoadList( CTypedPtrList<CPtrList, CTrackItem*>& list, IStream* pIStream );
	HRESULT SaveList( CTypedPtrList<CPtrList, CTrackItem*>& list, IStream* pIStream );
	HRESULT LoadStrip( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT SaveStrip( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveStripDesignData( IDMUSProdRIFFStream* pIRiffStream );

protected:
	// Layers
	HRESULT	RefreshVerticalScrollBarUI();
	void SetVerticalScrollYPos( long lNewVertScrollYPos );
	CWaveStripLayer* YPosToLayer( long lYPos, bool fNewLayerIsValid );
	int YPosToLayerIndex( long lYPos );
	int GetNbrLayers();
	bool SelectLayer( CWaveStripLayer* pLayer );
	bool IsLayerEmpty( CWaveStripLayer* pLayer );
	BOOL SyncLayerSelectFlag( CWaveStripLayer* pLayer );
	HRESULT CanDeleteLayers();
	HRESULT DeleteSelectedLayers();
	HRESULT InsertTheLayer( int nLayerIndex );
	HRESULT InsertLayers( int nLayerIndex );

	// Snap To
	void DoGridsPerSecond();
	void SetSnapTo( WORD wID );
	HRESULT SnapXPosToUnknownTime( long lXPos, REFERENCE_TIME* prtSnapTime );
	HRESULT SnapUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtSnapTime );
	HRESULT	SnapUnknownTimeToDisplayPosition( REFERENCE_TIME rtTime, long* plPosition );
	HRESULT	SnapPositionToStartEndClocks( long lPosition, MUSIC_TIME* pmtStart, MUSIC_TIME* pmtEnd );
	HRESULT SnapUnknownToNextIncrement( REFERENCE_TIME rtTime, REFERENCE_TIME* prtSnapTime );

public:
	void OnVScrollFromScrollbar( UINT nSBCode, UINT nPos );
	CWaveStripLayer* CreateLayerForIndex( int nLayerIndex );
	CWaveStripLayer* IndexToLayer( int nLayerIndex );
	int LayerToIndex( CWaveStripLayer* pLayer );
	void IndexToLayerYCoords( int nLayerIndex, RECT* pRect );
	HRESULT InsertItem( CTrackItem* pItem );
	void OnVariationTimer( void );

	bool IsOneGrid();
	DWORD GetPChannel();
	void RefreshAllWaves();
    void GetReferencedNodes( DWORD *pdwIndex, DMUSProdReferencedNodes *pDMUSProdReferencedNodes );

// SelectedRegion list helpers
	void CListSelectedRegion_AddRegion( long lXPos );
	void CListSelectedRegion_AddRegion( CTrackItem* pItem );
	void CListSelectedRegion_ShiftAddRegion( long lXPos );
	void CListSelectedRegion_ToggleRegion( long lXPos );
	bool CListSelectedRegion_Contains( REFERENCE_TIME rtUnknownTime );

protected:
	// Fields used for UI 
	CTrackMgr*		 m_pTrackMgr;
	CTrackItem*		 m_pItemToToggle;
	CWaveStripLayer* m_pLayerForShiftClick;
	CLayerScrollBar	 m_VerticalScrollBar;
	UINT			 m_nVerticalScrollTimer;
	UINT			 m_cfWaveTrack;			// CF_WAVETRACK Clipboard format
	UINT			 m_cfWave;				// CF_DLS_WAVE clipboard format
	UINT			 m_cfDMUSProdFile;		// CF_DMUSPROD_FILE clipboard format
	long			 m_lYPos;
	bool			 m_fLeftMouseDown;
	WORD			 m_wMouseMode;			// MM_ flags
	DWORD			 m_dwSourceVariationBtns;
	DWORD			 m_dwScrollTick;

	// Reference counter for bitmaps
	static long		sm_lBitmapRefCount;

	// Lock buttons
	static CBitmap	sm_bmpLocked;
	static CBitmap	sm_bmpUnlocked;

	// Variation Button bar
	static CBitmap	sm_bmpVarBtnUp;
	static CBitmap	sm_bmpVarBtnDown;
	static CBitmap	sm_bmpVarInactiveBtnUp;
	static CBitmap	sm_bmpVarInactiveBtnDown;
	static CBitmap	sm_bmpVarGutterBtnUp;
	static CBitmap	sm_bmpVarGutterBtnDown;

	// State variables for the variation selection bar
	int				m_nVarAction;
	int				m_nLastVariation;
	int				m_nSoloVariation;
	bool			m_fVarSolo;
	DWORD			m_dwPlayingVariation;
	bool			m_fVariationsTimerActive;

	// Layer status variables
	static int		sm_nLayerBtnWidth;
	BOOL			m_fLayerSelected;

	// Zoom status variables
	static CBitmap	sm_bmpZoomInBtnUp;
	static CBitmap	sm_bmpZoomInBtnDown;
	static CBitmap	sm_bmpZoomOutBtnUp;
	static CBitmap	sm_bmpZoomOutBtnDown;
	static int		sm_nZoomBtnHeight;
	static int		sm_nZoomBtnWidth;
	int				m_nWaveHeight;			// Wave height based on vertical zoom
	bool			m_fZoomInDown;
	bool			m_fZoomOutDown;

	// Vertical scroll variables
	long			m_lVerticalScrollTopYPos;

	// Fields that are persisted (DirectMusic wave track data)
	DWORD			m_dwVariationsMask;		// Which variations are enabled
	DWORD			m_dwPChannel;			// PChannel number
	DWORD			m_dwIndex;				// Index for distinguishing multiple parts on same PChannel
	long			m_lVolume;				// Gain, in 1/100th of dB. Note: All gain values should be negative
	DWORD			m_dwLockToPart;			// Part ID to lock to
	DWORD			m_dwPartFlagsDM;		// Various flags pertaining to part (strip)

	CTypedPtrList<CPtrList, CTrackItem*> m_lstTrackItems;

	// Fields that are only persisted in design files
	CString			m_strStripName;			// Used by FBDraw()
	ioWavePartUI	m_StripUI;

	CTypedPtrList<CPtrList, CWaveStripLayer*> m_lstLayers;
};


#endif //__WAVE_TRACKMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TrackMgr.cpp ===
// TrackMgr.cpp : implementation file
//

/*----------------
@doc WAVESAMPLE
----------------*/

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "TabWaveTrack.h"
#include "TabWavePart.h"
#include "DLSDesigner.h"
#include "SegmentDesigner.h"
#include "SegmentIO.h"
#include "NewPartDlg.h"
#include <conductor.h>
#include <dmusicf.h>
#include <dmusici.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Set information about this strip manager
const CLSID CTrackMgr::m_clsid = CLSID_DirectMusicWaveTrack;
const DWORD CTrackMgr::m_ckid = NULL;
const DWORD CTrackMgr::m_fccType = DMUS_FOURCC_WAVETRACK_LIST;

const DWORD g_dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
const DWORD g_dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr constructor/destructor 

CTrackMgr::CTrackMgr() : CBaseMgr()
{
	// DirectMusic wave track data
	m_lVolume = 0;
	m_dwTrackFlagsDM = DMUS_WAVETRACKF_PERSIST_CONTROL;
	m_pWaveStripForPropSheet = NULL;
	m_pIDMPerformance = NULL;
	m_pIDMSegmentState = NULL;
	m_hStatusBar = NULL;
	m_fInAllTracksAdded = false;
	m_fWasRuntimeTrack = false;

	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;

	CWaveStrip* pWaveStrip = new CWaveStrip( this );
	ASSERT( pWaveStrip );
	if( pWaveStrip )
	{
		m_lstWaveStrips.AddTail( pWaveStrip );
	}
}

CTrackMgr::~CTrackMgr()
{
	// Remove pane from status bar
	if( m_hStatusBar )
	{
		m_pDMProdFramework->RestoreStatusBar( m_hStatusBar );
		m_hStatusBar = NULL;
	}

	// Release all the items in m_lstWaveStrips
	while( !m_lstWaveStrips.IsEmpty() )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.RemoveHead();
		RELEASE( pWaveStrip );
	}

	UnloadQueuedWaves();
	ASSERT( m_lstQueuedWaves.IsEmpty() );

	RELEASE( m_pIDMPerformance );
	RELEASE( m_pIDMSegmentState );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr ITrackMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsMeasureBeatOpen
// Returns S_OK if the specified measure and beat is empty.
// Returns S_FALSE if the specified measure and beat already has an item

HRESULT STDMETHODCALLTYPE CTrackMgr::IsMeasureBeatOpen( long lMeasure, long lBeat )
{
	UNREFERENCED_PARAMETER(lMeasure);
	UNREFERENCED_PARAMETER(lBeat);
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( 0 );
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetParam

HRESULT STDMETHODCALLTYPE CTrackMgr::GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	// Get the list of wave nodes we reference
	if( ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		DMUSProdReferencedNodes *pDMUSProdReferencedNodes = (DMUSProdReferencedNodes *)pData;

        // Iterate through the wave strips
		DWORD dwIndex = 0;
	    POSITION pos = m_lstWaveStrips.GetHeadPosition();
	    while( pos )
	    {
		    CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );
            pWaveStrip->GetReferencedNodes( &dwIndex, pDMUSProdReferencedNodes );
	    }

		HRESULT hr = pDMUSProdReferencedNodes->apIDMUSProdNode && (pDMUSProdReferencedNodes->dwArraySize < dwIndex) ? S_FALSE : S_OK;

		// Store the number of nodes we returned (or that we require)
		pDMUSProdReferencedNodes->dwArraySize = dwIndex;

		return hr;
	}

	return CBaseMgr::GetParam( guidType, mtTime, pmtNext, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetParam

HRESULT STDMETHODCALLTYPE CTrackMgr::SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);

	if( pData == NULL )
	{
		ASSERT( 0 );
		return E_POINTER;
	}

	// Get wave from wave track
	if( ::IsEqualGUID( guidType, GUID_WaveParam ) )
	{
		DMUSPROD_WAVE_PARAM* pWaveParam = (DMUSPROD_WAVE_PARAM *)pData;
		if( pWaveParam->pIWaveNode == NULL )
		{
			ASSERT( 0 );
			return E_INVALIDARG;
		}

		CWaveStrip* pWaveStrip = GetWaveStrip( pWaveParam->dwPChannel, pWaveParam->dwIndex );
		if( pWaveStrip )
		{
			CTrackItem* pItem = new CTrackItem( this, pWaveStrip );
			if( pItem )
			{
				pItem->m_rtTimeLogical = mtTime;
				pItem->SetTimePhysical( pWaveParam->rtTimePhysical, STP_LOGICAL_NO_ACTION );
				pItem->SetFileReference( pWaveParam->pIWaveNode );
				pItem->m_pLayer = pWaveStrip->CreateLayerForIndex( 0 );
				pWaveStrip->InsertItem( pItem );
				return S_OK;
			}

			delete pWaveStrip;
		}

		return E_FAIL;
	}

	// Get wave from wave track
	if( ::IsEqualGUID( guidType, GUID_WaveParam2 ) )
	{
		DMUSPROD_WAVE_PARAM2* pWaveParam = (DMUSPROD_WAVE_PARAM2 *)pData;
		if( pWaveParam->pIWaveNode == NULL )
		{
			ASSERT( 0 );
			return E_INVALIDARG;
		}

		CWaveStrip* pWaveStrip = GetWaveStrip( pWaveParam->dwPChannel, pWaveParam->dwIndex );
		if( pWaveStrip )
		{
			CTrackItem* pItem = new CTrackItem( this, pWaveStrip );
			if( pItem )
			{
				pItem->m_rtTimeLogical = mtTime;
				pItem->SetTimePhysical( pWaveParam->rtTimePhysical, STP_LOGICAL_NO_ACTION );
				pItem->SetFileReference( pWaveParam->pIWaveNode );
				pItem->m_pLayer = pWaveStrip->CreateLayerForIndex( 0 );

				pWaveStrip->InsertItem( pItem );

				// Must set the variation after insertion, as InsertItem() will override them
				pItem->m_dwVariations = pWaveParam->dwVariation;

				// Only enable the variations with waves in them
				pWaveStrip->m_dwVariationsMask = 0;
				POSITION pos = pWaveStrip->m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					pWaveStrip->m_dwVariationsMask |= pWaveStrip->m_lstTrackItems.GetNext(pos)->m_dwVariations;
				}

				// If no variations enabled, enable them all
				if( 0 == pWaveStrip->m_dwVariationsMask )
				{
					pWaveStrip->m_dwVariationsMask = 0xFFFFFFFF;
				}

				pWaveStrip->m_StripUI.m_dwVariationBtns = pWaveStrip->m_dwVariationsMask;
				return S_OK;
			}

			delete pWaveStrip;
		}

		return E_FAIL;
	}

	return CBaseMgr::SetParam( guidType, mtTime, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CTrackMgr::IsParamSupported( REFGUID guidType )
{
	// We support getting/setting waves in a wave track
    // We support getting the referenced nodes
	if( ::IsEqualGUID( guidType, GUID_WaveParam )
	||	::IsEqualGUID( guidType, GUID_WaveParam2 )
	||  ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		return S_OK;
	}

	return CBaseMgr::IsParamSupported( guidType );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CTrackMgr::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// GUID_TimeSignature
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Redraw all strips
		AllStrips_Invalidate();
		return S_OK;
	}

	// GUID_TempoParam
	if( ::IsEqualGUID( rguidType, GUID_TempoParam ) )
	{
		// Ask DLS Designer for info about all items
		AllStrips_GetWaveInfo();

		// Redraw all strips
		AllStrips_Invalidate();
		return S_OK;
	}

	// GUID_Segment_AllTracksAdded
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Make sure host has latest version of data
		// May have changed during load if user prompted to choose Wave from File Open dialog
		if( m_fDirty )
		{
			OnDataChanged();
			m_fDirty = FALSE;
		}

		// Ask DLS Designer for info about all items
		m_fInAllTracksAdded = true;
		AllStrips_GetWaveInfo();
		m_fInAllTracksAdded = false;
		m_fWasRuntimeTrack = false;	// Turn off both flags!

		// Redraw all strips
		AllStrips_Invalidate();
		return S_OK;
	}

	// GUID_Segment_Start
	if( ::IsEqualGUID( rguidType, GUID_Segment_Start ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}
		
		RELEASE( m_pIDMSegmentState );

		IDirectMusicSegmentState* pIDMSegmentState;
		if( SUCCEEDED( ((IUnknown *)pData)->QueryInterface( IID_IDirectMusicSegmentState, (void **) &pIDMSegmentState ) ) )
		{
			m_pIDMSegmentState = pIDMSegmentState;

			// Update the audition variations
			SetAuditionVariations( false );

			// Enable all the variation timers
			POSITION position = m_lstWaveStrips.GetHeadPosition();
			while (position != NULL)
			{
				CWaveStrip *pCWaveStrip = m_lstWaveStrips.GetNext(position);

				// Enable the variation timer.  This is a no-op if there is no
				// Timeline window
				// Also, update the currently playing variation.
				pCWaveStrip->EnableVariationTimer();
				pCWaveStrip->UpdatePlayingVariation();
			}
		}
		return S_OK;
	}

	// GUID_Segment_Stop
	if( ::IsEqualGUID( rguidType, GUID_Segment_Stop ) )
	{
		RELEASE( m_pIDMSegmentState );

		// Disable all the variation timers
		POSITION position = m_lstWaveStrips.GetHeadPosition();
		while (position != NULL)
		{
			CWaveStrip *pCWaveStrip = m_lstWaveStrips.GetNext(position);

			// Disable the variation timer and update the currently playing variation.
			pCWaveStrip->KillVariationTimer();
			pCWaveStrip->UpdatePlayingVariation();
		}

		return S_OK;
	}

	// GUID_Segment_WindowActive
	if( ::IsEqualGUID( rguidType, GUID_Segment_WindowActive ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}

		// Set audition variations
		BOOL fActivate = *((BOOL *)pData);
		if( fActivate )
		{
			SetAuditionVariations( false );
		}
		else
		{
			SetAuditionVariations( true );
		}
	}

	// GUID_Segment_DeletedTrack
	if( ::IsEqualGUID( rguidType, GUID_Segment_DeletedTrack ) )
	{
		AllStrips_DeleteAllParts();
		return S_OK;
	}

	// GUID_ConductorUnloadWaves
	if(::IsEqualGUID(rguidType, GUID_ConductorUnloadWaves))
	{
		POSITION pos = m_lstWaveStrips.GetHeadPosition();
		while( pos )
		{
			CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

			pWaveStrip->OnUpdate( rguidType, dwGroupBits, pData );
		}

		// Unload waves
		UnloadQueuedWaves();
		return S_OK;
	}

	// GUID_ConductorDownloadWaves
	if(::IsEqualGUID(rguidType, GUID_ConductorDownloadWaves))
	{
		POSITION pos = m_lstWaveStrips.GetHeadPosition();
		while( pos )
		{
			CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

			pWaveStrip->OnUpdate( rguidType, dwGroupBits, pData );
		}

		// Download waves
		DownloadQueuedWaves();
		return S_OK;
	}

	// GUID_ConductorFlushWaves
	if(::IsEqualGUID(rguidType, GUID_ConductorFlushWaves))
	{
		// Flush all waves
		FlushAllWaves();
		return S_OK;
	}

	// GUID_Segment_FrameworkMsg
	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		DMUSProdFrameworkMsg* pFrameworkMsg =  (DMUSProdFrameworkMsg *)pData;

		if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, WAVENODE_DataChange) )
		{
			if( m_pIDMSegmentState 
			&&  m_pIDMPerformance )
			{
				// Stop segments that are playing so that unload/download will not fail.
				// Hopefully this is only a temporary work around to a DMusic issue!
				m_pIDMPerformance->Stop( NULL, m_pIDMSegmentState, 0, 0 );
				Sleep( 300 );	// Yikes!  This is necessary to make sure unload/download does not fail.
			}
		}

		// Pass notification to all strips
		POSITION pos = m_lstWaveStrips.GetHeadPosition();
		while( pos )
		{
			CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

			pWaveStrip->OnUpdate( rguidType, dwGroupBits, pData );
		}
		return S_OK;
	}

	if( ::IsEqualGUID( rguidType, GUID_TimelineSetSnapTo )
	&&	(pData != NULL) )
	{
		// Convert from the Timeline SNAP_TO setting to our own SNAP_TO settings
		WORD wSnapVal;
		DMUSPROD_TIMELINE_SNAP_TO *ptlSnapTo = (DMUSPROD_TIMELINE_SNAP_TO *)pData;

		switch( *ptlSnapTo )
		{
		case DMUSPROD_TIMELINE_SNAP_NONE:
			wSnapVal = IDM_SNAP_NONE;
			break;
		case DMUSPROD_TIMELINE_SNAP_GRID:
			wSnapVal = IDM_SNAP_GRID;
			break;
		case DMUSPROD_TIMELINE_SNAP_BEAT:
			wSnapVal = IDM_SNAP_BEAT;
			break;
		case DMUSPROD_TIMELINE_SNAP_BAR:
			wSnapVal = IDM_SNAP_BAR;
			break;
		default:
			ASSERT(FALSE);
			wSnapVal = IDM_SNAP_GRID;
			break;
		}

		// Update all the strips with the new snap-to setting
		POSITION pos = m_lstWaveStrips.GetHeadPosition();
		while( pos )
		{
			CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

			pWaveStrip->m_StripUI.m_nSnapToMusicTime = wSnapVal;

			// If switching to none or grid, update the reftime snap-to setting also
			if( (wSnapVal == IDM_SNAP_NONE)
			||	(wSnapVal == IDM_SNAP_GRID) )
			{
				pWaveStrip->m_StripUI.m_nSnapToRefTime = wSnapVal;
			}
		}
	}

	// We don't handle whichever notification was passed to us
	return CBaseMgr::OnUpdate( rguidType, dwGroupBits, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTrackMgr::SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
		case SMP_ITIMELINECTL:
			// Check that the caller passed in an IUnknown pointer
			if( variant.vt != VT_UNKNOWN )
			{
				return E_INVALIDARG;
			}

			// If we were previously attached to a timeline
			if( m_pTimeline )
			{
				// Make sure our property page isn't displayed
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);

				// Release our reference on our property page manager
				RELEASE( m_pPropPageMgr );

				// Remove our strips from the Timeline
				AllStrips_RemoveFromTimeline();

				// Remove ourself from the Timeline's notification list
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_WindowActive, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetSnapTo, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_ConductorDownloadWaves, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_ConductorUnloadWaves, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_ConductorFlushWaves, m_dwOldGroupBits );

				// Release our reference on the Timeline
				RELEASE( m_pTimeline );
			}

			// If a non-NULL pointer was passed in
			if( V_UNKNOWN( &variant ) )
			{
				// Query the pointer for a Timeline interface
				if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
				{
					return E_FAIL;
				}
				else
				{
					// Add our strips to the timeline
					AllStrips_AddToTimeline();

					// Add ourself to the Timeline's notification list
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_WindowActive, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetSnapTo, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_ConductorDownloadWaves, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_ConductorUnloadWaves, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_ConductorFlushWaves, m_dwGroupBits );
				}
			}
			else
			{
				// Window is being closed
				SetAuditionVariations( true );
			}
			return S_OK;

		case SMP_DMUSIOTRACKEXTRASHEADER:
			if( variant.vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
				if( pioTrackExtrasHeader == NULL )
				{
					return E_POINTER;
				}

				m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
			}
			return S_OK;
	}

	// Let CBaseMgr handle
	return CBaseMgr::SetStripMgrProperty( stripMgrProperty, variant );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::Load

HRESULT CTrackMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	DWORD dwSize;
	DWORD dwByteCount;

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Release all the items in m_lstWaveStrips
	while( !m_lstWaveStrips.IsEmpty() )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.RemoveHead();
		
		long cRef = pWaveStrip->Release();
		ASSERT( cRef == 0 );
	}
	
	// Initialize fields
	m_strLastWaveName.Empty();
	m_fWasRuntimeTrack = true;

	// Variables used when loading the Wave track
	MMCKINFO ckTrack;
	MMCKINFO ckList;

	// Interate through every chunk in the stream
	while( pIRiffStream->Descend( &ckTrack, NULL, 0 ) == 0 )
	{
		switch( ckTrack.ckid )
		{
			case FOURCC_LIST:
				switch( ckTrack.fccType )
				{
					case DMUS_FOURCC_WAVETRACK_LIST:
						while( pIRiffStream->Descend( &ckList, &ckTrack, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_WAVETRACK_CHUNK:
								{
									DMUS_IO_WAVE_TRACK_HEADER iTrackHeader;

									// Read in the item's header structure
									dwSize = min( sizeof( DMUS_IO_WAVE_TRACK_HEADER ), ckList.cksize );
									hr = pIStream->Read( &iTrackHeader, dwSize, &dwByteCount );

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != dwSize )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									m_lVolume = iTrackHeader.lVolume;
									m_dwTrackFlagsDM = iTrackHeader.dwFlags;
									break;
								}

								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_WAVEPART_LIST:
										{
											CWaveStrip* pNewStrip = new CWaveStrip( this );
											if( pNewStrip == NULL )
											{
												hr = E_OUTOFMEMORY;
												goto ON_ERROR;
											}
											hr = pNewStrip->LoadStrip( pIRiffStream, &ckList );
											if( FAILED ( hr ) )
											{
												delete pNewStrip;
												goto ON_ERROR;
											}
											InsertByAscendingPChannel( pNewStrip );
											break;
										}
									}
									break;
							}

							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	SyncWithDirectMusic();

ON_ERROR:
	m_strLastWaveName.Empty();
	pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SaveTrackHeader

HRESULT CTrackMgr::SaveTrackHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Create the DMUS_FOURCC_WAVETRACK_CHUNK chunk
	ck.ckid = DMUS_FOURCC_WAVETRACK_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Clear out the structure (clears out the padding bytes as well).
	DMUS_IO_WAVE_TRACK_HEADER oTrackHeader;
	ZeroMemory( &oTrackHeader, sizeof(DMUS_IO_WAVE_TRACK_HEADER) );

	// Fill in the members of the DMUS_IO_WAVE_TRACK_HEADER structure
	oTrackHeader.lVolume = m_lVolume;		
	oTrackHeader.dwFlags = m_dwTrackFlagsDM;		

	// Write the structure out to the stream
	DWORD dwBytesWritten;
	hr = pIStream->Write( &oTrackHeader, sizeof(DMUS_IO_WAVE_TRACK_HEADER), &dwBytesWritten );
	if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_WAVE_TRACK_HEADER) )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Ascend out of the DMUS_FOURCC_WAVETRACK_CHUNK chunk
	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::Save

HRESULT CTrackMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic Wave track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )
	&&	!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Create a LIST chunk to store the track data
	MMCKINFO ckTrack;
 	ckTrack.fccType = DMUS_FOURCC_WAVETRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the LIST chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save the track data
	{
		// Save the track header
		hr = SaveTrackHeader( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		// Save the wave strips
		AllStrips_ResetIndexes();
		if( !m_lstWaveStrips.IsEmpty() )
		{

			// Iterate through the item list
			POSITION pos = m_lstWaveStrips.GetHeadPosition();
			while( pos )
			{
				// Get a pointer to each item
				CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

				// Save each strip
				hr = pWaveStrip->SaveStrip( pIRiffStream );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}
	}

	pIRiffStream->Ascend( &ckTrack, 0 );

	// If we're supposed to clear our dirty flag, do so now (since the save succeeded)
	if( fClearDirty )
	{
		m_fDirty = false;
	}

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetData

HRESULT STDMETHODCALLTYPE CTrackMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( (ppData == NULL)
	|| (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	if( m_pWaveStripForPropSheet == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
		// Group Bits tab
		case 0:
		{
			ioGroupBitsPPG *pioGroupBitsPPG = static_cast<ioGroupBitsPPG *>(*ppData);

			pioGroupBitsPPG->dwGroupBits = m_dwGroupBits;
			break;
		}

		// Track flags tab
		case 1:
		{
			PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
			pPPGTrackFlagsParams->dwTrackExtrasFlags = m_dwTrackExtrasFlags;
			pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
			pPPGTrackFlagsParams->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
			pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
			break;
		}

		// Wave Track tab
		case 2:
		{
			ioWaveTrackPPG *pioWaveTrackPPG = static_cast<ioWaveTrackPPG *>(*ppData);

			pioWaveTrackPPG->lVolume = m_lVolume;		
			pioWaveTrackPPG->dwTrackFlagsDM = m_dwTrackFlagsDM;
			break;
		}

		// Wave Part tab
		case 3:
		{
			ioWavePartPPG *pioWavePartPPG = static_cast<ioWavePartPPG *>(*ppData);

			pioWavePartPPG->dwPChannel = m_pWaveStripForPropSheet->m_dwPChannel;
			pioWavePartPPG->lVolume = m_pWaveStripForPropSheet->m_lVolume;		
			pioWavePartPPG->dwLockToPart = m_pWaveStripForPropSheet->m_dwLockToPart;	
			pioWavePartPPG->dwPartFlagsDM = m_pWaveStripForPropSheet->m_dwPartFlagsDM;
			pioWavePartPPG->strStripName = m_pWaveStripForPropSheet->m_strStripName;
			GetPChannelName( m_pWaveStripForPropSheet->m_dwPChannel, pioWavePartPPG->strPChannelName );
			break;
		}

		default:
			ASSERT(FALSE);
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetData

HRESULT STDMETHODCALLTYPE CTrackMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( m_pWaveStripForPropSheet == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}
	
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
		// Group bits
		case 0:
		{
			ioGroupBitsPPG *pioGroupBitsPPG = static_cast<ioGroupBitsPPG *>(pData);

			// m_dwGroupBits
			if( pioGroupBitsPPG->dwGroupBits != m_dwGroupBits )
			{
				m_nLastEdit = IDS_UNDO_TRACK_GROUP;
				m_dwGroupBits = pioGroupBitsPPG->dwGroupBits;
				OnUpdate( GUID_TimeSignature, m_dwGroupBits, NULL );
				OnDataChanged();
				m_dwOldGroupBits = pioGroupBitsPPG->dwGroupBits;
			}

			break;
		}

		// Track flags tab
		case 1:
		{
			PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

			// m_dwTrackExtrasFlags
			if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_dwTrackExtrasFlags )
			{
				m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
				bool fWasRefTimeTrack = IsRefTimeTrack();
				m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;
				bool fIsRefTimeTrack = IsRefTimeTrack();

				if( fWasRefTimeTrack != fIsRefTimeTrack )
				{
					AllStrips_SwitchTimeBase();
				}

				OnDataChanged();
				AllStrips_Invalidate();
			}

			// m_dwProducerOnlyFlags
			else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_dwProducerOnlyFlags )
			{
				m_nLastEdit = IDS_UNDO_PRODUCERONLY;
				m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;
				OnDataChanged();
			}

			break;
		}

		// Wave Track tab
		case 2:
		{
			ioWaveTrackPPG *pioWaveTrackPPG = static_cast<ioWaveTrackPPG *>(pData);

			// m_lVolume
			if( pioWaveTrackPPG->lVolume != m_lVolume )
			{
				m_nLastEdit = IDS_UNDO_TRACK_VOLUME;
				m_lVolume = pioWaveTrackPPG->lVolume;
				OnDataChanged();
			}

			// m_dwTrackFlagsDM
			else if( pioWaveTrackPPG->dwTrackFlagsDM != m_dwTrackFlagsDM )
			{
				m_nLastEdit = IDS_UNDO_TRACK_FLAGS;
				m_dwTrackFlagsDM = pioWaveTrackPPG->dwTrackFlagsDM;
				OnDataChanged();
			}

			break;
		}

		// Wave Part tab
		case 3:
		{
			ioWavePartPPG *pioWavePartPPG = static_cast<ioWavePartPPG *>(pData);

			// m_pWaveStripForPropSheet->m_dwPChannel
			if( pioWavePartPPG->dwPChannel != m_pWaveStripForPropSheet->m_dwPChannel )
			{
				CWaitCursor wait;

				m_nLastEdit = IDS_UNDO_PART_PCHANNEL;
				m_pWaveStripForPropSheet->m_dwPChannel = pioWavePartPPG->dwPChannel;
				RepositionPart( m_pWaveStripForPropSheet );
				m_pWaveStripForPropSheet->RefreshAllWaves();
				OnDataChanged();
				m_pTimeline->StripInvalidateRect( m_pWaveStripForPropSheet, NULL, FALSE );
			}

			// m_pWaveStripForPropSheet->m_lVolume
			else if( pioWavePartPPG->lVolume != m_pWaveStripForPropSheet->m_lVolume )
			{
				m_nLastEdit = IDS_UNDO_PART_VOLUME;
				m_pWaveStripForPropSheet->m_lVolume = pioWavePartPPG->lVolume;
				OnDataChanged();
			}

			// m_pWaveStripForPropSheet->m_dwLockToPart
			else if( pioWavePartPPG->dwLockToPart != m_pWaveStripForPropSheet->m_dwLockToPart )
			{
				m_nLastEdit = IDS_UNDO_PART_LOCK_TO_PART;
				m_pWaveStripForPropSheet->m_dwLockToPart = pioWavePartPPG->dwLockToPart;
				OnDataChanged();
				// Refresh the property page to update values in Lock ID combo box
				if( m_pPropPageMgr )
				{
					m_pPropPageMgr->RefreshData();
				}
			}

			// m_pWaveStripForPropSheet->m_dwPartFlagsDM
			else if( pioWavePartPPG->dwPartFlagsDM != m_pWaveStripForPropSheet->m_dwPartFlagsDM )
			{
				m_nLastEdit = IDS_UNDO_PART_FLAGS;
				m_pWaveStripForPropSheet->m_dwPartFlagsDM = pioWavePartPPG->dwPartFlagsDM;
				OnDataChanged();
			}

			// m_pWaveStripForPropSheet->m_strStripName
			else if( pioWavePartPPG->strStripName != m_pWaveStripForPropSheet->m_strStripName )
			{
				m_nLastEdit = IDS_UNDO_PART_NAME;
				m_pWaveStripForPropSheet->m_strStripName = pioWavePartPPG->strStripName;
				OnDataChanged();
				m_pTimeline->StripInvalidateRect( m_pWaveStripForPropSheet, NULL, FALSE );
			}

			// m_pWaveStripForPropSheet's PChannel name
			else if( m_pDMProdFramework )
			{
				IDMUSProdProject* pIProject;
				if( SUCCEEDED ( m_pDMProdFramework->FindProject( m_pIDocRootNode, &pIProject ) ) ) 
				{
					IDMUSProdPChannelName* pIPChannelName;
					if( SUCCEEDED( pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&pIPChannelName ) ) )
					{
						WCHAR wstrText[MAX_PATH];
						if( SUCCEEDED ( pIPChannelName->GetPChannelName( m_pWaveStripForPropSheet->m_dwPChannel, wstrText ) ) )
						{
							CString strPChName = wstrText;
							if( strPChName.Compare( pioWavePartPPG->strPChannelName ) != 0 )
							{
								MultiByteToWideChar( CP_ACP, 0, pioWavePartPPG->strPChannelName, -1, wstrText, MAX_PATH );
								pIPChannelName->SetPChannelName( m_pWaveStripForPropSheet->m_dwPChannel, wstrText );

								// This doesn't affect anything in the segment - just the PChannel names
								// in the Producer project file.
							}
						}
					
						RELEASE( pIPChannelName );
					}

					RELEASE( pIProject );
				}
			}

			break;
		}

		default:
			ASSERT(FALSE);
			break;
	}

	// Sync track with DirectMusic
	SyncWithDirectMusic();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CTrackMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate pointers
	if( m_pTimeline == NULL
	||  m_pDMProdFramework == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, refresh and exit
	if( pIPropSheet->IsEqualPageManagerObject( (IDMUSProdPropPageObject*)this ) == S_OK )
	{
		ASSERT( m_pPropPageMgr != NULL );
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
		pIPropSheet->Release();
		return S_OK;
	}

	// release our reference to the property sheet
	pIPropSheet->Release();

	// Check if our property page manager exists yet
	if( m_pPropPageMgr == NULL )
	{
		// Nope, need to create it
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr( m_pDMProdFramework, this );

		// Check if the creation succeeded.
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Set m_pPropPageMgr with a reference to the IDMUSProdPropPageManager interface
		HRESULT hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );

		// Release our original reference on the property page manager (added when it
		// was created).
		m_pPropPageMgr->Release();

		// If the QueryInterface failed, return.
		if( FAILED(hr) )
		{
			// Nothing to release, since no reference was added by the call to QueryInterface.
			return hr;
		}
	}

	// Store the last active tab
	short nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;

	// Set the property page to refer to the group bits property page.
	m_pTimeline->SetPropertyPage( m_pPropPageMgr, (IDMUSProdPropPageObject*)this );

	// Set the active tab
	if( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		CWnd* pWndHadFocus = CWnd::GetFocus();

		pIPropSheet->SetActivePage( nActiveTab ); 
		RELEASE( pIPropSheet );

		if( pWndHadFocus )
		{
			pWndHadFocus->SetFocus();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnRemoveFromPageManager

HRESULT CTrackMgr::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Clear our property page manager
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject( NULL );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SyncWithDirectMusic

HRESULT CTrackMgr::SyncWithDirectMusic( void )
{
	// If there is no DirectMusic Track, return S_FALSE
	if( m_pIDMTrack == NULL )
	{
		return S_FALSE;
	}

	// Unload waves
	UnloadQueuedWaves();

	// Hand DirectMusic new wave track
	HRESULT hr = CBaseMgr::SyncWithDirectMusic();
	if( SUCCEEDED ( hr ) )
	{
		// Set audition variations
		SetAuditionVariations( false );
	}

	// Download waves
	DownloadQueuedWaves();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RecomputeTimes

// Return true if anything changed
bool CTrackMgr::RecomputeTimes( void )
{
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetDirtyFlag

void CTrackMgr::SetDirtyFlag( bool fDirty )
{
	m_fDirty = fDirty;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::InsertByAscendingPChannel

void CTrackMgr::InsertByAscendingPChannel( CWaveStrip *pWaveStripToInsert )
{
	// Ensure the pWaveStripToInsert pointer is valid
	if ( pWaveStripToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CWaveStrip *pWaveStrip;
	POSITION posCurrent, posNext = m_lstWaveStrips.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pWaveStrip = m_lstWaveStrips.GetNext( posNext );

		if( pWaveStrip->m_dwPChannel > pWaveStripToInsert->m_dwPChannel )
		{
			// insert before posCurrent (which is the position of pWaveStrip)
			m_lstWaveStrips.InsertBefore( posCurrent, pWaveStripToInsert );
			return;
		}
	}

	// pWaveStripToInsert has higher PChannel than all items in the list
	// add it at the end of the list
	m_lstWaveStrips.AddTail( pWaveStripToInsert );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RefTimeToMinSecGridMs

HRESULT	CTrackMgr::RefTimeToMinSecGridMs( CWaveStrip* pWaveStrip,
										  REFERENCE_TIME rtTime,
										  long* plMinute, long* plSecond, long* plGrid, long* plMillisecond )
{
	ASSERT( pWaveStrip != NULL );
	ASSERT( plMinute != NULL );
	ASSERT( plSecond != NULL );
	ASSERT( plGrid != NULL );
	ASSERT( plMillisecond != NULL );

	REFERENCE_TIME rtRefClocksPerGrid = REFCLOCKS_PER_SECOND / pWaveStrip->m_StripUI.m_nSnapToRefTime_GridsPerSecond;

	*plMinute = (long)(rtTime / REFCLOCKS_PER_MINUTE);
	rtTime = rtTime % REFCLOCKS_PER_MINUTE;

	*plSecond = (long)(rtTime / REFCLOCKS_PER_SECOND);
	rtTime = rtTime % REFCLOCKS_PER_SECOND;

	*plGrid = (long)(rtTime / rtRefClocksPerGrid);
	rtTime = rtTime % rtRefClocksPerGrid;

	*plMillisecond = (long)(rtTime / REFCLOCKS_PER_MILLISECOND);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MinSecGridMsToRefTime

HRESULT	CTrackMgr::MinSecGridMsToRefTime( CWaveStrip* pWaveStrip,
										  long lMinute, long lSecond, long lGrid, long lMillisecond,
										  REFERENCE_TIME* prtTime )
{
	ASSERT( pWaveStrip != NULL );
	ASSERT( prtTime != NULL );

	REFERENCE_TIME rtRefClocksPerGrid = REFCLOCKS_PER_SECOND / pWaveStrip->m_StripUI.m_nSnapToRefTime_GridsPerSecond;

	*prtTime =  lMinute * REFCLOCKS_PER_MINUTE;
	*prtTime += lSecond * REFCLOCKS_PER_SECOND;
	*prtTime += lGrid * rtRefClocksPerGrid;
	*prtTime += lMillisecond * REFCLOCKS_PER_MILLISECOND;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ClocksToMeasureBeatGridTick

HRESULT	CTrackMgr::ClocksToMeasureBeatGridTick( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plGrid != NULL );
	ASSERT( plTick != NULL );
	
	long lMeasure = -1;
	long lBeat = -1;
	long lGrid = -1;
	long lTick = -1;
	long lGridsAndTicks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		if( mtTime < 0 )
		{
			lMeasure = 0;
			lBeat = 0;
			lGrid = 0;
			lTick = mtTime;
		}
		else
		{
			hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
			if( SUCCEEDED ( hr ) )
			{
				long lClocks;

				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				if( SUCCEEDED ( hr ) )
				{
					lGridsAndTicks = mtTime - lClocks;

					// Get the TimeSig for this measure/beat
					DMUS_TIMESIGNATURE ts;
					if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, lClocks, NULL, &ts ) ) )
					{
						// Compute the grid and tick
						long lClocksPerGrid = ((DMUS_PPQ << 2) / ts.bBeat) / ts.wGridsPerBeat;
						lGrid = lGridsAndTicks / lClocksPerGrid;
						lTick = lGridsAndTicks % lClocksPerGrid;

						// Try and preserve negative tick offsets
						if( lTick > 0 )
						{
							long lNewClocks = lClocks + lClocksPerGrid;

							if( lTick >= (lClocksPerGrid >> 1) )
							{
								// Get max clock
								VARIANT var;
								m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
								MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

								if( lNewClocks < mtMaxTimelineLength )
								{
									lGrid++;
									lTick -= lClocksPerGrid;
									if( lGrid >= ts.wGridsPerBeat )
									{
										lGrid = 0;
										mtTime += lClocksPerGrid;
										hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
									}
								}
							}
						}
					}
				}
			}
		}
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plGrid = lGrid;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToMeasureBeatGridTick

HRESULT	CTrackMgr::UnknownTimeToMeasureBeatGridTick( REFERENCE_TIME rtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}
	
	MUSIC_TIME mtTime;
	UnknownTimeToClocks( rtTime, &mtTime );

	return ClocksToMeasureBeatGridTick( mtTime, plMeasure, plBeat, plGrid, plTick );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MeasureBeatGridTickToUnknownTime

HRESULT	CTrackMgr::MeasureBeatGridTickToUnknownTime( long lMeasure, long lBeat, long lGrid, long lTick, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}
	
	MUSIC_TIME mtTime;
	HRESULT hr = MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );

	ClocksToUnknownTime( mtTime, prtTime );

	return hr; 
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SnapUnknownTimeToBeat

HRESULT	CTrackMgr::SnapUnknownTimeToBeat( REFERENCE_TIME rtTime, REFERENCE_TIME* prtBeatTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}

	MUSIC_TIME mtTime;
	UnknownTimeToClocks( rtTime, &mtTime );

	long lMeasure, lBeat, lGrid, lTick;
	ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick );
	MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtTime );

	ClocksToUnknownTime( mtTime, prtBeatTime );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ClocksToUnknownTime

HRESULT CTrackMgr::ClocksToUnknownTime( MUSIC_TIME mtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}
	
	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		hr = m_pTimeline->ClocksToRefTime( mtTime, prtTime );
	}
	else
	{
		*prtTime = mtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToClocks

HRESULT CTrackMgr::UnknownTimeToClocks( REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		hr = m_pTimeline->RefTimeToClocks( rtTime, pmtTime );
	}
	else
	{
		*pmtTime = (MUSIC_TIME)rtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RefTimeToUnknownTime

HRESULT CTrackMgr::RefTimeToUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		*prtTime = rtTime;
	}
	else
	{
		MUSIC_TIME mtTime;
		hr = m_pTimeline->RefTimeToClocks( rtTime, &mtTime );
		*prtTime = mtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToRefTime

HRESULT CTrackMgr::UnknownTimeToRefTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		*prtTime = rtTime;
	}
	else
	{
		hr = m_pTimeline->ClocksToRefTime( (MUSIC_TIME)rtTime, prtTime );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MeasureBeatGridTickToClocks

HRESULT	CTrackMgr::MeasureBeatGridTickToClocks( long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	MUSIC_TIME mtTime = -1;
	long lClocks;
	long lGridClocks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		if( SUCCEEDED ( hr ) )
		{
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, lClocks, NULL, &ts ) ) )
			{
				long lClocksPerGrid = ((DMUS_PPQ << 2) / ts.bBeat) / ts.wGridsPerBeat;
				lGridClocks = lGrid * lClocksPerGrid;

				mtTime = lClocks + lGridClocks + lTick;
			}
		}
	}

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnNewPart

HRESULT CTrackMgr::OnNewPart( void )
{
	// Have user select a PChannel
	CNewPartDlg newPartDlg;

	newPartDlg.SetTrack( 0 );
	newPartDlg.SetTrackMgr( this );

	// The dialog handles adding parts itself
	newPartDlg.DoModal();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AddPart

HRESULT CTrackMgr::AddPart( DWORD dwPChannel )
{
	// Get position of first wave strip in the timeline
	int nPosition = -1;
	if( m_lstWaveStrips.IsEmpty() == FALSE )
	{
		CWaveStrip* pFirstWaveStrip = m_lstWaveStrips.GetHead();

		VARIANT var;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)pFirstWaveStrip, STP_POSITION, &var) ) )
		{
			nPosition = V_I4(&var);
		}
	}
		
	// Create the new Wave strip
	CWaveStrip* pNewWaveStrip = new CWaveStrip( this );
	if( pNewWaveStrip == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Set the new strip's PChannel
	pNewWaveStrip->m_dwPChannel = dwPChannel;

	// Add the new strip to the list of wave strips
	InsertByAscendingPChannel( pNewWaveStrip );

	// Increment dwPosition
	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		if( pWaveStrip == pNewWaveStrip )
		{
			break;
		}

		nPosition++;
	}

	// Add the new strip to the timeline
	AddStripToTimeline( pNewWaveStrip, nPosition );

	// Activate strip
	VARIANT var;
	var.vt = VT_UNKNOWN;
	if( SUCCEEDED( pNewWaveStrip->QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&var)) ) ) )
	{
		m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
	}

	// Update Undo queue
	m_nLastEdit = IDS_UNDO_ADD_PART;
	OnDataChanged();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeletePart

HRESULT CTrackMgr::DeletePart( CWaveStrip* pWaveStrip )
{
	if( pWaveStrip == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	HRESULT hr = RemoveStripFromTimeline( pWaveStrip );

	// Remove from list of Wave strips
	POSITION pos = m_lstWaveStrips.Find( pWaveStrip );
	if( pos )
	{
		m_lstWaveStrips.RemoveAt( pos );

		pWaveStrip->CleanUp();
		RELEASE( pWaveStrip );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RepositionPart

HRESULT CTrackMgr::RepositionPart( CWaveStrip* pTheWaveStrip )
{
	// Get position of first wave strip in the timeline
	int nPosition = -1;
	if( m_lstWaveStrips.IsEmpty() == FALSE )
	{
		CWaveStrip* pFirstWaveStrip = m_lstWaveStrips.GetHead();

		VARIANT var;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)pFirstWaveStrip, STP_POSITION, &var) ) )
		{
			nPosition = V_I4(&var);
		}
	}

	// Reposition strip in m_lstWaveStrips
	POSITION pos = m_lstWaveStrips.Find( pTheWaveStrip );
	if( pos )
	{
		m_lstWaveStrips.RemoveAt( pos );
		InsertByAscendingPChannel( pTheWaveStrip );
	}

	// Determine new position of strip for timeline
	pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		if( pWaveStrip == pTheWaveStrip )
		{
			break;
		}

		nPosition++;
	}

	// Reposition strip in timeline
	if( SUCCEEDED ( m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pTheWaveStrip ) ) )
	{
		AddStripToTimeline( pTheWaveStrip, nPosition );

		// Activate strip
		VARIANT var;
		var.vt = VT_UNKNOWN;
		if( SUCCEEDED( pTheWaveStrip->QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&var)) ) ) )
		{
			m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetSegmentLength

REFERENCE_TIME CTrackMgr::GetSegmentLength( void )
{
	MUSIC_TIME mtSegmentLength = LONG_MAX;
	REFERENCE_TIME rtSegmentLength = _I64_MAX;

	if( m_pTimeline )
	{
		VARIANT varLength;
		if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
		{
			mtSegmentLength = V_I4(&varLength);
		}

		ClocksToUnknownTime( mtSegmentLength, &rtSegmentLength );
	}

	return rtSegmentLength;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetPChannelName

HRESULT CTrackMgr::GetPChannelName( DWORD dwPChannel, CString& strPChannelName )
{
	HRESULT hr = E_FAIL;

	strPChannelName.Empty();

	if( m_pDMProdFramework )
	{
		IDMUSProdProject* pIProject;
		if( SUCCEEDED ( m_pDMProdFramework->FindProject( m_pIDocRootNode, &pIProject ) ) ) 
		{
			IDMUSProdPChannelName* pIPChannelName;
			if( SUCCEEDED( pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&pIPChannelName ) ) )
			{
				WCHAR wstrText[MAX_PATH];
				if( SUCCEEDED ( pIPChannelName->GetPChannelName( dwPChannel, wstrText ) ) )
				{
					strPChannelName = wstrText;
					hr = S_OK;
				}
			
				RELEASE( pIPChannelName );
			}

			RELEASE( pIProject );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetObject

HRESULT CTrackMgr::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	// CLSID_DirectMusicWaveTrack
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicWaveTrack ) )
	{
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( riid, ppvObject );
		}
	}

	// CLSID_DirectMusicPerformance
	else if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicPerformance ) )
	{
		if( m_pIDMPerformance == NULL )
		{
			// Get IDirectMusicPerformance interface pointers 
			if( m_pDMProdFramework )
			{
				IDMUSProdComponent* pIComponent;
				if( SUCCEEDED ( m_pDMProdFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ) )
				{
					IDMUSProdConductor* pIConductor;
					if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIConductor ) ) )
					{
						if( FAILED ( pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
						{
							m_pIDMPerformance = NULL;
						}

						RELEASE( pIConductor );
					}

					RELEASE( pIComponent );
				}
			}
		}

		if( m_pIDMPerformance )
		{
			return m_pIDMPerformance->QueryInterface( riid, ppvObject );
		}
	}

	// CLSID_DirectMusicAudioPathConfig
	else if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicAudioPathConfig ) )
	{
		if( m_pIDMPerformance == NULL )
		{
			// Get IDirectMusicPerformance interface pointers 
			if( m_pDMProdFramework )
			{
				IDMUSProdComponent* pIComponent;
				if( SUCCEEDED ( m_pDMProdFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ) )
				{
					IDMUSProdConductor* pIConductor;
					if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIConductor ) ) )
					{
						if( FAILED ( pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
						{
							m_pIDMPerformance = NULL;
						}

						RELEASE( pIConductor );
					}

					RELEASE( pIComponent );
				}
			}
		}

		ASSERT( 0 );
		// Still have to implement code to get the AudioPath from the Performance
	}

    *ppvObject = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsValidLockID

bool CTrackMgr::IsValidLockID( DWORD dwLockID )
{
	ASSERT( dwLockID > 0 );

	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		if( pWaveStrip->m_dwLockToPart == dwLockID )
		{
			return true;
		}
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::StripExists

bool CTrackMgr::StripExists( DWORD dwPChannel )
{
	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		if( pWaveStrip->m_dwPChannel == dwPChannel )
		{
			return true;
		}
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetGreatestUsedPChannel

DWORD CTrackMgr::GetGreatestUsedPChannel( void )
{
	DWORD dwPChannel = 0;

	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		dwPChannel = max( dwPChannel, pWaveStrip->m_dwPChannel );
	}

	return dwPChannel;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetWaveStrip

CWaveStrip* CTrackMgr::GetWaveStrip( DWORD dwPChannel, DWORD dwIndex )
{
	CWaveStrip* pTheWaveStrip = NULL;

	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		if( pWaveStrip->m_dwPChannel > dwPChannel )
		{
			break;
		}

		if( pWaveStrip->m_dwPChannel == dwPChannel )
		{
			if( dwIndex == 0 )
			{
				pTheWaveStrip = pWaveStrip;
				break;
			}
			dwIndex--;
		}
	}

	return pTheWaveStrip;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_Invalidate

void CTrackMgr::AllStrips_Invalidate( void )
{
	if( m_pTimeline == NULL )
	{
		return;
	}

	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		// Refresh strip properties
		pWaveStrip->RefreshPropertyPage();

		// Redraw strip
		m_pTimeline->StripInvalidateRect( pWaveStrip, NULL, TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_ResetIndexes

void CTrackMgr::AllStrips_ResetIndexes( void )
{
	DWORD dwLastPChannel = 0;
	DWORD dwLastIndex = 0;

	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		if( pWaveStrip->m_dwPChannel != dwLastPChannel )
		{
			dwLastPChannel = pWaveStrip->m_dwPChannel;
			dwLastIndex = 0;
		}
		
		pWaveStrip->m_dwIndex = dwLastIndex++;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AddStripToTimeline

HRESULT CTrackMgr::AddStripToTimeline( CWaveStrip* pWaveStrip, int nPosition )
{
	if( pWaveStrip == NULL
	||	m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	HRESULT hr;

	// Place strip in timeline
	if( nPosition <= 0 )
	{
		hr = m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)pWaveStrip, m_clsid, m_dwGroupBits, 0 );
	}
	else
	{
		hr = m_pTimeline->InsertStripAtPos( (IDMUSProdStrip *)pWaveStrip, nPosition );
	}

	// Set strip state information
	pWaveStrip->WavePartUIToTimeline();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_AddToTimeline

void CTrackMgr::AllStrips_AddToTimeline( void )
{
	int nPosition = -1;

	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		AddStripToTimeline( pWaveStrip, nPosition );

		if( nPosition == -1 )
		{
			VARIANT var;
			if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)pWaveStrip, STP_POSITION, &var) ) )
			{
				nPosition = V_I4(&var);
				ASSERT( nPosition > 0 );
			}
		}

		nPosition++;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RemoveStripFromTimeline

HRESULT CTrackMgr::RemoveStripFromTimeline( CWaveStrip* pWaveStrip )
{
	if( pWaveStrip == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	if( m_pTimeline )
	{
		// Make sure we are storing the latest UI state information
		pWaveStrip->TimelineToWavePartUI();

		// Make sure our strip's property page isn't displayed
		if( pWaveStrip == m_pWaveStripForPropSheet )
		{
			m_pTimeline->RemovePropertyPageObject( (IDMUSProdPropPageObject*)this );
			RELEASE( m_pPropPageMgr );
		}
		m_pTimeline->RemovePropertyPageObject( (IDMUSProdPropPageObject*)pWaveStrip );
		RELEASE( pWaveStrip->m_pPropPageMgr );

		m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pWaveStrip );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_RemoveFromTimeline

void CTrackMgr::AllStrips_RemoveFromTimeline( void )
{
	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		RemoveStripFromTimeline( pWaveStrip );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_DeleteAllParts

void CTrackMgr::AllStrips_DeleteAllParts()
{
	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		DeletePart( pWaveStrip );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_DeleteSelectedParts

void CTrackMgr::AllStrips_DeleteSelectedParts()
{
	if( AfxMessageBox(IDS_WARNING_DELETE_PART, MB_OKCANCEL) != IDOK )
	{
		return;
	}

	IDMUSProdStrip* pIActiveStrip;
	VARIANT var;

	BOOL fStripWasDeleted = FALSE;

	// Delete all gutter selected strips
	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pWaveStrip, STP_GUTTER_SELECTED, &var ) ) )
		{
			if( V_BOOL(&var) == TRUE )
			{
				DeletePart( pWaveStrip );
				fStripWasDeleted = TRUE;
			}
		}
	}
	
	// If none of the wave strips were gutter selected, delete the active strip
	if( fStripWasDeleted == FALSE )
	{
		if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
		{
			if( V_UNKNOWN(&var) != NULL)
			{
				if( SUCCEEDED ( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdStrip, (void **) &pIActiveStrip ) ) )
				{
					pos = m_lstWaveStrips.GetHeadPosition();
					while( pos )
					{
						CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

						if( pWaveStrip == pIActiveStrip )
						{
							DeletePart( pWaveStrip );
						}
					}

					RELEASE( pIActiveStrip );
				}

				V_UNKNOWN(&var)->Release();
			}
		}
	}

	if( m_lstWaveStrips.IsEmpty() )
	{
		ASSERT( m_pIDocRootNode != NULL );
		if( m_pIDocRootNode )
		{
			IDMUSProdSegmentEdit8* pISegmentEdit8;

			if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdSegmentEdit8, (void **)&pISegmentEdit8 ) ) )
			{
				pISegmentEdit8->RemoveStripMgr( (IDMUSProdStripMgr *)this );
				RELEASE( pISegmentEdit8 );
				return;		// Call to RemoveStripMgr should have deleted us!
			}
		}
	}
	else
	{
		// Update Undo queue
		m_nLastEdit = IDS_UNDO_DELETE_PART;
		OnDataChanged();

		// Sync with DirectMusic
		SyncWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_GetWaveInfo

void CTrackMgr::AllStrips_GetWaveInfo( void )
{
	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		pWaveStrip->GetWaveInfo();
	}

	// Sync with DirectMusic to pick up latest wave durations
	SyncWithDirectMusic();
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_SwitchTimeBase

void CTrackMgr::AllStrips_SwitchTimeBase( void )
{
	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		pWaveStrip->SwitchTimeBase();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_SetNbrGridsPerSecond

BOOL CTrackMgr::AllStrips_SetNbrGridsPerSecond( short nNbrGridsPerSecond )
{
	BOOL fChanged = FALSE;

	POSITION pos = m_lstWaveStrips.GetHeadPosition();
	while( pos )
	{
		CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

		if( pWaveStrip->m_StripUI.m_nSnapToRefTime_GridsPerSecond != nNbrGridsPerSecond )
		{
			pWaveStrip->m_StripUI.m_nSnapToRefTime_GridsPerSecond = nNbrGridsPerSecond;
			fChanged = TRUE;
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetActiveStripInThisTrack

CWaveStrip* CTrackMgr::GetActiveStripInThisTrack( void )
{
	CWaveStrip* pActiveWaveStrip = NULL;

	if( m_pTimeline )
	{
		VARIANT var;
		if( SUCCEEDED ( m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
		{
			IUnknown* pIUnknown = V_UNKNOWN(&var);
			if( pIUnknown )
			{
				IDMUSProdStrip* pIActiveStrip;
				if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDMUSProdStrip, (void**)&pIActiveStrip ) ) )
				{
					POSITION pos = m_lstWaveStrips.GetHeadPosition();
					while( pos )
					{
						CWaveStrip* pWaveStrip = m_lstWaveStrips.GetNext( pos );

						if( pIActiveStrip == (IDMUSProdStrip *)pWaveStrip )
						{
							pActiveWaveStrip = pWaveStrip;
							break;
						}
					}

					RELEASE( pIActiveStrip );
				}
				
				RELEASE( pIUnknown );
			}
		}
	}

	return pActiveWaveStrip;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetLockBitmap

CBitmap* CTrackMgr::GetLockBitmap( BOOL fLocked )
{
	CWaveStrip* pWaveStrip;

	if( m_lstWaveStrips.IsEmpty() == FALSE )
	{
		pWaveStrip = m_lstWaveStrips.GetHead();

		switch( fLocked )
		{
			case FALSE:
				if( pWaveStrip->sm_bmpUnlocked.GetSafeHandle() )
				{
					return &m_pWaveStripForPropSheet->sm_bmpUnlocked;
				}
				break;

			case TRUE:
				if( pWaveStrip->sm_bmpLocked.GetSafeHandle() )
				{
					return &m_pWaveStripForPropSheet->sm_bmpLocked;
				}
				break;

			default:
				ASSERT( 0 );
				break;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetAuditionVariations

HRESULT CTrackMgr::SetAuditionVariations( bool fForceClear )
{
	if( m_pIDMTrack == NULL )
	{
		return S_FALSE;
	}

	HRESULT hr = E_FAIL;

	IPrivateWaveTrack* pIPrivateWaveTrack;
	IPrivateWaveTrack9* pIPrivateWaveTrack9;
	if( SUCCEEDED ( m_pIDMTrack->QueryInterface( IID_IPrivateWaveTrack9, (void **)&pIPrivateWaveTrack9 ) ) )
	{
		CWaveStrip* pWaveStrip = GetActiveStripInThisTrack();
		if( pWaveStrip
		&&  fForceClear == false )
		{
			DWORD dwVariations = pWaveStrip->m_StripUI.m_dwVariationBtns;

			// If no variations are selected, then fall back to the variation mask
			hr = pIPrivateWaveTrack9->SetVariationMask( m_pIDMSegmentState, dwVariations ? dwVariations : pWaveStrip->m_dwVariationsMask, pWaveStrip->m_dwPChannel, pWaveStrip->m_dwIndex );
		}
		else
		{
			// Clear the variation mask by setting this on an invalid PChannel
			hr = pIPrivateWaveTrack9->SetVariationMask( m_pIDMSegmentState, 0xFFFFFFFF, DMUS_PCHANNEL_BROADCAST_GROUPS - 1000, 0 );
		}

		RELEASE( pIPrivateWaveTrack9 );
	}
	else if( SUCCEEDED ( m_pIDMTrack->QueryInterface( IID_IPrivateWaveTrack, (void **)&pIPrivateWaveTrack ) ) )
	{
		CWaveStrip* pWaveStrip = GetActiveStripInThisTrack();
		if( pWaveStrip
		&&  fForceClear == false )
		{
			DWORD dwVariations = pWaveStrip->m_StripUI.m_dwVariationBtns;
			hr = pIPrivateWaveTrack->SetVariation( m_pIDMSegmentState, dwVariations, pWaveStrip->m_dwPChannel, pWaveStrip->m_dwIndex );
		}
		else
		{
			hr = pIPrivateWaveTrack->ClearVariations( m_pIDMSegmentState );
		}

		RELEASE( pIPrivateWaveTrack );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsRefTimeTrack

bool CTrackMgr::IsRefTimeTrack( void )
{
	return (m_dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetQueuedWave
	
QueuedWave* CTrackMgr::GetQueuedWave( IDirectSoundWave* pIDSWave, GUID guidVersion )
{
	QueuedWave* pTheQueuedWave = NULL;

	POSITION pos = m_lstQueuedWaves.GetHeadPosition();
	while( pos )
	{
		QueuedWave* pQueuedWave = m_lstQueuedWaves.GetNext( pos );

		if( pQueuedWave->pIDSWave == pIDSWave )
		{
			pTheQueuedWave = pQueuedWave;
		}
	}

	if( pTheQueuedWave == NULL )
	{
		pTheQueuedWave = new QueuedWave;
		if( pTheQueuedWave )
		{
			pTheQueuedWave->pIDSWave = pIDSWave;
			pTheQueuedWave->pIDSWave->AddRef();
			pTheQueuedWave->guidVersion = guidVersion;
	
			m_lstQueuedWaves.AddHead( pTheQueuedWave );
		}
	}

	return pTheQueuedWave;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::QueueWaveForDownload

HRESULT CTrackMgr::QueueWaveForDownload( CTrackItem* pItem )
{
	if( pItem->m_FileRef.pIDocRootNode == NULL ) 
	{
		// Nothing to do
		return S_OK;
	}

	// Get the corresponding DirectSound Wave object
	IDirectSoundWave* pIDSWave;
	if( FAILED ( pItem->m_FileRef.pIDocRootNode->GetObject( CLSID_DirectSoundWave, IID_IDirectSoundWave, (void **)&pIDSWave ) ) )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	QueuedWave* pQueuedWave = GetQueuedWave( pIDSWave, pItem->m_WaveInfo.guidVersion );

	RELEASE( pIDSWave );

	if( pQueuedWave )
	{
		pQueuedWave->lDownloadCount++;
		return S_OK;
	}

	return E_OUTOFMEMORY;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::QueueWaveForUnload
	
HRESULT CTrackMgr::QueueWaveForUnload( CTrackItem* pItem )
{
	if( pItem->m_FileRef.pIDocRootNode == NULL ) 
	{
		// Nothing to do
		return S_OK;
	}

	// Get the corresponding DirectSound Wave object
	IDirectSoundWave* pIDSWave;
	if( FAILED ( pItem->m_FileRef.pIDocRootNode->GetObject( CLSID_DirectSoundWave, IID_IDirectSoundWave, (void **)&pIDSWave ) ) )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	QueuedWave* pQueuedWave = GetQueuedWave( pIDSWave, pItem->m_WaveInfo.guidVersion );

	RELEASE( pIDSWave );

	if( pQueuedWave )
	{
		pQueuedWave->lDownloadCount--;
		return S_OK;
	}

	return E_OUTOFMEMORY;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnloadQueuedWaves

void CTrackMgr::UnloadQueuedWaves( void )
{
	CWaitCursor wait;

	IUnknown* pIUnknown = NULL;

	// Get pIUnknown for UnloadWave method
	IDirectMusicPerformance8* pIDMPerformance8;
	if( SUCCEEDED ( GetObject( CLSID_DirectMusicPerformance, IID_IDirectMusicPerformance8, (void **)&pIDMPerformance8 ) ) )
	{
		IDirectMusicAudioPath* pIDMAudioPath;
		if( SUCCEEDED ( pIDMPerformance8->GetDefaultAudioPath( &pIDMAudioPath ) ) )
		{
			if( FAILED ( pIDMAudioPath->QueryInterface( IID_IUnknown, (void **)&pIUnknown ) ) )
			{
				pIUnknown = NULL;
			}

			RELEASE( pIDMAudioPath );
		}
		else
		{
			if( FAILED ( pIDMPerformance8->QueryInterface( IID_IUnknown, (void **)&pIUnknown ) ) )
			{
				pIUnknown = NULL;
			}
		}

		RELEASE( pIDMPerformance8 );
	}
	ASSERT( pIUnknown != NULL );

	if( pIUnknown )
	{
		// Get the IPrivateWaveTrack interface
		IPrivateWaveTrack* pIPrivateWaveTrack;
		if( SUCCEEDED ( GetObject( CLSID_DirectMusicWaveTrack, IID_IPrivateWaveTrack, (void **)&pIPrivateWaveTrack ) ) )
		{
			POSITION pos = m_lstQueuedWaves.GetHeadPosition();
			POSITION posCur;
			while( pos )
			{
				posCur = pos;
				QueuedWave* pQueuedWave = m_lstQueuedWaves.GetNext( pos );

				if( pQueuedWave->lDownloadCount > 0 )
				{
					// Nothing to do, request is for download
					continue;
				}

				while( pQueuedWave->lDownloadCount < 0 )
				{
					// Unload the Wave
					HRESULT hr = pIPrivateWaveTrack->UnloadWave( pQueuedWave->pIDSWave, pIUnknown );
					ASSERT( SUCCEEDED ( hr ) );
					pQueuedWave->lDownloadCount++;
				}

				m_lstQueuedWaves.RemoveAt( posCur );
				delete pQueuedWave;
			}

			RELEASE( pIPrivateWaveTrack );
		}

		RELEASE( pIUnknown );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DownloadQueuedWaves

void CTrackMgr::DownloadQueuedWaves( void )
{
	CWaitCursor wait;

	IUnknown* pIUnknown = NULL;

	// Get pIUnknown for DownloadWave method
	IDirectMusicPerformance8* pIDMPerformance8;
	if( SUCCEEDED ( GetObject( CLSID_DirectMusicPerformance, IID_IDirectMusicPerformance8, (void **)&pIDMPerformance8 ) ) )
	{
		IDirectMusicAudioPath* pIDMAudioPath;
		if( SUCCEEDED ( pIDMPerformance8->GetDefaultAudioPath( &pIDMAudioPath ) ) )
		{
			if( FAILED ( pIDMAudioPath->QueryInterface( IID_IUnknown, (void **)&pIUnknown ) ) )
			{
				pIUnknown = NULL;
			}

			RELEASE( pIDMAudioPath );
		}
		else
		{
			if( FAILED ( pIDMPerformance8->QueryInterface( IID_IUnknown, (void **)&pIUnknown ) ) )
			{
				pIUnknown = NULL;
			}
		}

		RELEASE( pIDMPerformance8 );
	}
	ASSERT( pIUnknown != NULL );

	if( pIUnknown )
	{
		// Get the IPrivateWaveTrack interface
		IPrivateWaveTrack* pIPrivateWaveTrack;
		if( SUCCEEDED ( GetObject( CLSID_DirectMusicWaveTrack, IID_IPrivateWaveTrack, (void **)&pIPrivateWaveTrack ) ) )
		{
			POSITION pos = m_lstQueuedWaves.GetHeadPosition();
			POSITION posCur;
			while( pos )
			{
				posCur = pos;
				QueuedWave* pQueuedWave = m_lstQueuedWaves.GetNext( pos );

				if( pQueuedWave->lDownloadCount < 0 )
				{
					// Nothing to do, request is for unload
					continue;
				}

				while( pQueuedWave->lDownloadCount > 0 )
				{
					// Download the Wave
					HRESULT hr = pIPrivateWaveTrack->DownloadWave( pQueuedWave->pIDSWave, pIUnknown, pQueuedWave->guidVersion );
					ASSERT( SUCCEEDED ( hr ) );
					pQueuedWave->lDownloadCount--;
				}

				m_lstQueuedWaves.RemoveAt( posCur );
				delete pQueuedWave;
			}

			RELEASE( pIPrivateWaveTrack );
		}

		RELEASE( pIUnknown );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::FlushAllWaves

void CTrackMgr::FlushAllWaves( void )
{
	CWaitCursor wait;

	// Clear all items from m_lstQueuedWaves
	while( !m_lstQueuedWaves.IsEmpty() )
	{
		QueuedWave* pQueuedWave = m_lstQueuedWaves.RemoveHead();
		delete pQueuedWave;
	}

	// Get the IPrivateWaveTrack interface
	IPrivateWaveTrack* pIPrivateWaveTrack;
	if( SUCCEEDED ( GetObject( CLSID_DirectMusicWaveTrack, IID_IPrivateWaveTrack, (void **)&pIPrivateWaveTrack ) ) )
	{
		// Flush Waves
		HRESULT hr = pIPrivateWaveTrack->FlushAllWaves();
		ASSERT( SUCCEEDED ( hr ) );

		RELEASE( pIPrivateWaveTrack );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ForceBoundaries

HRESULT CTrackMgr::ForceBoundaries( long lMeasure, long lBeat, MUSIC_TIME* pmtTime )
{
	// Get length of segment
	MUSIC_TIME mtMaxTimelineLength;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	mtMaxTimelineLength = V_I4( &var );

	// Get maximum number of measures, beats
	long lMaxMeasure;
	long lMaxBeat;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtMaxTimelineLength - 1, &lMaxMeasure, &lMaxBeat );
	lMaxMeasure = max( 0, lMaxMeasure );
	lMaxBeat = max( 0, lMaxBeat );

	// Force boundaries 
	MUSIC_TIME mtTime;
	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );

	// Enforce measure boundary
	if( lMeasure > lMaxMeasure )
	{
		lMeasure = lMaxMeasure;
		lBeat = lMaxBeat;
	}

	// Enforce beat boundary (must catch incomplete last measures - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat > lMaxBeat )
	{
		lBeat = lMaxBeat;
	}

	// Make sure mtTime matches adjusted measure, tick
	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
	*pmtTime = mtTime;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetGroupBits

DWORD CTrackMgr::GetGroupBits( void )
{
	return m_dwGroupBits;
}

// Helper function for RealTime display

void RefTimeToString( REFERENCE_TIME rtTime, int nResourceID, int nNegativeResourceID, CString &cstrTime )
{
	bool fNegative = false;
	if( rtTime < 0 )
	{
		fNegative = true;
		rtTime = -rtTime;
	}

	int iMillisecond, iSecond, iMinute;//, iHour;
	// Convert to milliseconds
	iMillisecond = int(rtTime / 10000);
	iSecond = iMillisecond / 1000;
	iMillisecond %= 1000;
	iMinute = iSecond / 60;
	iSecond %= 60;
	//iHour = iMinute / 60;
	//iMinute %= 60;

	CString strFormat;
	if( strFormat.LoadString( fNegative ? nNegativeResourceID : nResourceID ) )
	{
		cstrTime.Format(strFormat, iMinute, iSecond, iMillisecond);
	}
	else
	{
		cstrTime.Format(fNegative ? "-%02d:%02d.%03d" : "%02d:%02d.%03d", iMinute, iSecond, iMillisecond);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UpdateStatusBarDisplay

void CTrackMgr::UpdateStatusBarDisplay( void )
{
	if( !m_pDMProdFramework )
	{
		return;
	}

	bool fShowStatusBar = false;
	CWaveStrip *pActiveWaveStrip = GetActiveStripInThisTrack();
	if( pActiveWaveStrip )
	{
		CTrackItem *pItem = pActiveWaveStrip->GetFirstSelectedItem();
		if( pItem )
		{
			fShowStatusBar = true;

			if( !m_hStatusBar
			&&	SUCCEEDED( m_pDMProdFramework->SetNbrStatusBarPanes( 1, SBLS_CONTROL, &m_hStatusBar ) ) )
			{
				m_pDMProdFramework->SetStatusBarPaneInfo( m_hStatusBar, 0, SBS_SUNKEN, 14 );
			}

			if( m_hStatusBar )
			{
				REFERENCE_TIME rtWave;
				if( SUCCEEDED( UnknownTimeToRefTime( pItem->m_rtTimePhysical, &rtWave ) ) )
				{
					CString strText;
					RefTimeToString( rtWave, IDS_WAVE_STATUS_TEXT, IDS_WAVE_NEG_STATUS_TEXT, strText );
					m_pDMProdFramework->SetStatusBarPaneText( m_hStatusBar, 0, strText.AllocSysString(), TRUE );
				}
			}
		}
	}


	if( !fShowStatusBar
	&&	m_hStatusBar )
	{
		m_pDMProdFramework->RestoreStatusBar( m_hStatusBar );
		m_hStatusBar = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\WaveStrip.cpp ===
// WaveStrip.cpp : Implementation of CWaveStrip
#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackItem.h"
#include "PropTrackItem.h"
#include "WaveStripMgr.h"
#include "TrackMgr.h"
#include "PropPageMgr_Item.h"
#include "GroupBitsPPG.h"
#include "GridsPerSecondDlg.h"
#include <BaseMgr.h>
#include <SegmentDesigner.h>
#include <SegmentIO.h>
#include <DLLJazzDataObject.h>
#include <dmusicf.h>
#include "GrayOutRect.h"
#include <dmusicp.h>

// TODO - eliminate this need (Needed by RefreshVerticalScrollBarUI())
#include "..\Timeline\TimelineDraw.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Bitmaps
int	 CWaveStrip::sm_nZoomBtnHeight = 0;
int	 CWaveStrip::sm_nZoomBtnWidth = 0;
int	 CWaveStrip::sm_nLayerBtnWidth = 0;
long CWaveStrip::sm_lBitmapRefCount = 0;
CBitmap	CWaveStrip::sm_bmpLocked;
CBitmap	CWaveStrip::sm_bmpUnlocked;
CBitmap	CWaveStrip::sm_bmpVarBtnUp;
CBitmap	CWaveStrip::sm_bmpVarBtnDown;
CBitmap	CWaveStrip::sm_bmpVarInactiveBtnUp;
CBitmap	CWaveStrip::sm_bmpVarInactiveBtnDown;
CBitmap	CWaveStrip::sm_bmpVarGutterBtnUp;
CBitmap	CWaveStrip::sm_bmpVarGutterBtnDown;
CBitmap	CWaveStrip::sm_bmpZoomInBtnUp;
CBitmap	CWaveStrip::sm_bmpZoomInBtnDown;
CBitmap	CWaveStrip::sm_bmpZoomOutBtnUp;
CBitmap	CWaveStrip::sm_bmpZoomOutBtnDown;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// EmptyList

void EmptyList( CTypedPtrList<CPtrList, CTrackItem*>& list )
{
	// Remove and delete all the CTrackItems from the given list
	while( !list.IsEmpty() )
	{
		delete list.RemoveHead();
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// NormalizeList

void NormalizeList( CTrackMgr* pTrackMgr, 
				    CTypedPtrList<CPtrList, CTrackItem*>& list, REFERENCE_TIME rtOffset )
{
	long lMeasure, lBeat, lGrid, lTick;

	DWORD dwGroupBits = pTrackMgr->GetGroupBits();

	// Iterate through the list of items
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CTrackItem* pItem = list.GetNext(pos);

		// This method only called for drag/drop and cut/copy/paste
		// so it is safe to mess with the values that are stored in time fields

		// Snap physical time to number of beats
		long lPhysicalBeats;
		MUSIC_TIME mtTimePhysical;
		pTrackMgr->UnknownTimeToClocks( pItem->m_rtTimePhysical, &mtTimePhysical );
		pTrackMgr->ClocksToMeasureBeatGridTick( mtTimePhysical, &lMeasure, &lBeat, &lGrid, &lTick );
		MeasureBeatToBeats( pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

		// Convert logical time to number of beats
		if( pTrackMgr->IsRefTimeTrack() )
		{
			// Use m_mtTimeLogical to store beat difference between physical time and logical time
			ASSERT( pItem->m_rtTimePhysical == pItem->m_rtTimeLogical );
			pItem->m_rtTimeLogical = 0;
		}
		else
		{
			long lLogicalBeats;
			pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)pItem->m_rtTimeLogical, &lMeasure, &lBeat, &lGrid, &lTick );
			MeasureBeatToBeats( pTrackMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Use m_mtTimeLogical to store beat difference between physical time and logical time
			pItem->m_rtTimeLogical = lLogicalBeats - lPhysicalBeats;
		}

		// Use m_rtTimePhysical to store an offset
		pItem->m_rtTimePhysical -= rtOffset;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip constructor/destructor

CWaveStrip::CWaveStrip( CTrackMgr* pTrackMgr ) : CBaseStrip( pTrackMgr )
{
	// Validate the pointer to our strip manager
	ASSERT( pTrackMgr );
	if ( pTrackMgr == NULL )
	{
		return;
	}

	// Set our pointer to our strip manager
	m_pTrackMgr = pTrackMgr;

	// Initialize our clipboard formats to 0
	m_cfWaveTrack = 0;
	m_cfWave = 0;
	m_cfDMUSProdFile = 0;

	// Initialize our state variables
	m_lYPos = -1;
	m_fLeftMouseDown = false;
	m_fZoomInDown = false;
	m_fZoomOutDown = false;
	m_nWaveHeight = 0;
	m_wMouseMode = 0;
	m_dwSourceVariationBtns = 0;

	m_nVarAction = VA_NONE;
	m_fVarSolo = false;
	m_nLastVariation = -1;
	m_nSoloVariation = -1;
	m_dwPlayingVariation = 0;
	m_fVariationsTimerActive = false;

	m_fLayerSelected = FALSE;
	m_nVerticalScrollTimer = 0;
	m_dwScrollTick = 0;

	// Initialize the item to toggle (when CTRL-clicking) to NULL
	m_pItemToToggle = NULL;
	m_pLayerForShiftClick = NULL;

	// Initialize fields that are persisted (DirectMusic wave track data)
	m_dwVariationsMask = 0xFFFFFFFF;
	m_dwPChannel = 0;
	m_dwIndex = 0;
	m_lVolume = 0;
	m_dwLockToPart = 0;
	m_dwPartFlagsDM = DMUS_VARIATIONT_RANDOM;
}

CWaveStrip::~CWaveStrip()
{
	CleanUp();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CleanUp

void CWaveStrip::CleanUp( void )
{
	// Clear our pointer to our strip manager
	if( m_pTrackMgr )
	{
		if( m_pTrackMgr->m_pWaveStripForPropSheet == this )
		{
			m_pTrackMgr->m_pWaveStripForPropSheet = NULL;
		}

		m_pTrackMgr = NULL;
	}

	// Delete all the items in m_lstTrackItems (all variations)
	EmptyList( m_lstTrackItems );

	// Delete all the items in m_lstLayers
	while( !m_lstLayers.IsEmpty() )
	{
		CWaveStripLayer* pLayer = m_lstLayers.RemoveHead();
		delete pLayer;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::InvalidateVariationBtns

void CWaveStrip::InvalidateVariationBtns( void )
{
	// Invalidate the variation selection bar
	long lLeftDisplay;
	m_pTrackMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pTrackMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

	RECT rect;
	rect.left = lLeftDisplay;
	rect.right = rect.left + VARIATION_GUTTER_WIDTH + VARIATION_BUTTONS_WIDTH;
	rect.top = m_StripUI.m_lVerticalScrollYPos;
	rect.bottom = rect.top + VARIATION_BUTTONS_HEIGHT;

	// Don't need to erase, since the variation selection bar will overwrite the area
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::InvalidateWaves

void CWaveStrip::InvalidateWaves( void )
{
	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, FALSE );
		return;
	}

	// Invalidate the wave portion of the track
	long lLeftDisplay;
	m_pTrackMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pTrackMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

	RECT rect;
	rect.left = lLeftDisplay;
	rect.top = m_StripUI.m_lVerticalScrollYPos + VARIATION_BUTTONS_HEIGHT;
	
	// Find the right and bottom boundaries of our strip					
	CDC cDC;
	VARIANT var;
	var.vt = VT_I4;
	if( FAILED ( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_GET_HDC, &var ) ) )
	{
		return;
	}

	CWnd* pWnd = NULL;
	if( cDC.Attach( (HDC)(V_I4(&var)) ) != 0 )
	{
		RECT	rtStrip;
		
		cDC.GetClipBox( &rtStrip );
		rect.right = lLeftDisplay + rtStrip.right + 1;
		pWnd = cDC.GetWindow();
		cDC.Detach();
	}
	if( pWnd )
	{
		::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(V_I4(&var)) );
	}
	else
	{
		::ReleaseDC( NULL, (HDC)(V_I4(&var)) );
	}

	rect.bottom = m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight;

	// Really invalidate the waves
	// Don't need to erase, since the horizontal bars will overwrite the area
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::InvalidateFBar

void CWaveStrip::InvalidateFBar( void )
{
	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, FALSE );
		return;
	}

	// Invalidate the function bar
	RECT rect;
	rect.right = 0;
	rect.top = m_StripUI.m_lVerticalScrollYPos;
	rect.bottom = m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight;
	VARIANT var;
	var.vt = VT_I4;
	if( FAILED ( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var ) ) )
	{
		return;
	}
	rect.left = -V_I4(&var);

	// Need to offset it if we're horizontally scrolled
	long lLeftDisplay;
	m_pTrackMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pTrackMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

	rect.left += lLeftDisplay;
	rect.right += lLeftDisplay;

	// Really invalidate the function bar
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DrawVariationButtonBar

void CWaveStrip::DrawVariationButtonBar( HDC hDC )
{
	if( hDC == NULL )
	{
		ASSERT( 0 );
		return;
	}

	// Set the currently playing variation
	UpdatePlayingVariation( false );

	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	if( rectClip.top > m_StripUI.m_lVerticalScrollYPos + VARIATION_BUTTONS_HEIGHT )		// 2 rows	
	{
		return;
	}

	if( rectClip.left > VARIATION_GUTTER_WIDTH + VARIATION_BUTTONS_WIDTH )	// 16 buttons per row
	{
		return;
	}

	// Figure out which variations have waves in them (all variations)
	DWORD dwVariationHasWaves = 0;
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		dwVariationHasWaves |= pItem->m_dwVariations;
	}

	// Draw variation gutter
	if( m_StripUI.m_fVarGutterDown )
	{
		::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( sm_bmpVarGutterBtnDown.GetSafeHandle() ), NULL, 0, m_StripUI.m_lVerticalScrollYPos,
					 VARIATION_GUTTER_WIDTH, VARIATION_GUTTER_HEIGHT, DST_BITMAP | DSS_NORMAL );
	}
	else
	{
		::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( sm_bmpVarGutterBtnUp.GetSafeHandle() ), NULL, 0, m_StripUI.m_lVerticalScrollYPos,
					 VARIATION_GUTTER_WIDTH, VARIATION_GUTTER_HEIGHT, DST_BITMAP | DSS_NORMAL );
	}

	// Create fonts for variation buttons
	LOGFONT lf;
	memset( &lf, 0 , sizeof(LOGFONT));
	lf.lfHeight = VARIATION_BUTTON_HEIGHT - 2;
	//lf.lfWidth = 0;
	//lf.lfEscapement = 0;
	//lf.lfOrientation = 0;
	lf.lfWeight = FW_HEAVY;
	//lf.lfItalic = FALSE;
	//lf.lfUnderline = FALSE;
	//lf.lfStrikeOut = FALSE;
	//lf.lfCharSet = ANSI_CHARSET;
	//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	//lf.lfQuality = DEFAULT_QUALITY;
	lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	//lf.lfFaceName = NULL;
	
	HFONT hfontBold, hfontNormal;
	hfontBold = ::CreateFontIndirect( &lf );
	if( hfontBold == NULL ) 
	{
		return;
	}
	lf.lfWeight = FW_MEDIUM;
	hfontNormal = ::CreateFontIndirect( &lf );
	if( hfontNormal == NULL )
	{
		::DeleteObject( hfontBold );
		return;
	}

	int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );

	COLORREF oldColor = ::GetTextColor( hDC );
	HFONT hfontOld= static_cast<HFONT> ( ::GetCurrentObject( hDC, OBJ_FONT ) );
	
	// Now draw the variation buttons
	TCHAR achText[10];
	int nXpos, nYpos;
	for( nYpos = 0; nYpos < 2; nYpos++ )
	{
		for( nXpos = 0; nXpos < 16; nXpos++ )
		{
			const int nVariation = nXpos + (nYpos << 4);
			const bool fPressed = m_StripUI.m_dwVariationBtns & (1 << nVariation) ? true : false;

			LPARAM lParam;
			if( m_dwVariationsMask & (1 << nVariation) )
			{
				if( fPressed )
				{
					lParam = reinterpret_cast<LPARAM>( sm_bmpVarBtnDown.GetSafeHandle() );
				}
				else
				{
					lParam = reinterpret_cast<LPARAM>( sm_bmpVarBtnUp.GetSafeHandle() );
				}
			}
			else
			{
				if( fPressed )
				{
					lParam = reinterpret_cast<LPARAM>( sm_bmpVarInactiveBtnDown.GetSafeHandle() );
				}
				else
				{
					lParam = reinterpret_cast<LPARAM>( sm_bmpVarInactiveBtnUp.GetSafeHandle() );
				}
			}
			::DrawState( hDC, NULL, NULL, lParam, NULL,
						 VARIATION_GUTTER_WIDTH + nXpos*VARIATION_BUTTON_WIDTH, m_StripUI.m_lVerticalScrollYPos + nYpos*VARIATION_BUTTON_HEIGHT,
						 VARIATION_BUTTON_WIDTH, VARIATION_BUTTON_HEIGHT, DST_BITMAP | DSS_NORMAL );
			
			RECT rect;
			rect.top = fPressed + m_StripUI.m_lVerticalScrollYPos + nYpos*VARIATION_BUTTON_HEIGHT + 3;
			rect.bottom = rect.top + VARIATION_BUTTON_HEIGHT - 6;
			rect.left = fPressed + VARIATION_GUTTER_WIDTH + nXpos*VARIATION_BUTTON_WIDTH + 2;
			rect.right = rect.left + VARIATION_BUTTON_WIDTH - 6;
		
			const bool fPlaying = m_dwPlayingVariation & (1 << nVariation) ? true : false;
			
			_itot( nXpos + nYpos * 16 + 1, achText, 10 );
			if( dwVariationHasWaves & (1 << nVariation) )
			{
				::SetTextColor( hDC, fPlaying ? RGB(255,0,0) : RGB(0, 0, 0) );
				::SelectObject( hDC, hfontBold );
			}
			else
			{
				::SetTextColor( hDC, fPlaying ? RGB(255,0,0) : RGB(255, 255, 255) );
				::SelectObject( hDC, hfontNormal );
			}
			::DrawText( hDC, achText, -1, &rect, DT_NOCLIP | DT_VCENTER | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX );
		}
	}

	if( hfontOld )
	{
		::SelectObject( hDC, hfontOld );
	}

	::SetTextColor( hDC, oldColor );
	::SetBkMode( hDC, nOldBkMode );
	::DeleteObject( hfontBold );
	::DeleteObject( hfontNormal );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// GetNextSelectedItem - helper method for Draw()

void GetNextSelectedItem( CTypedPtrList<CPtrList, CTrackItem*>& list, POSITION &posItem )
{
	// Note that if the item at posItem is selected, this method doesn't do anything useful.
	if( posItem )
	{
		// Save the current position
		POSITION posToSave = posItem;

		// Check if we have not run off the end of the list, and if the currently item is unselected
		while( posItem && !list.GetNext( posItem )->m_fSelected )
		{
			// Current item is unselected, save the position of the next item
			posToSave = posItem;
		}

		// Check if we found a selected item
		if( posToSave )
		{
			// Save the position of the selected item
			posItem = posToSave;

		}
		// Otherwise both posToSave and posItem are NULL
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetNextSelectedItem - helper method for Draw()

CTrackItem* CWaveStrip::GetNextSelectedItem( POSITION pos )
{
		// Get a pointer to the selected item
//	CTrackItem* pItem = m_lstTrackItems.GetAt( posItem );

	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		if( pItem->m_fSelected )
		{
			return pItem;
		}
	}

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetNextItem - helper method for Draw()

CTrackItem* CWaveStrip::GetNextItem( POSITION pos )
{
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		return pItem;
	}

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetNextItemInLayer - helper method for Draw()

CTrackItem* CWaveStrip::GetNextItemInLayer( POSITION pos, CWaveStripLayer* pLayer )
{
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// If this item is in a different layer, skip it
		if( pItem->m_pLayer != pLayer )
		{
			continue;
		}

		return pItem;
	}

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetNextSelectedItemInLayer - helper method for Draw()

CTrackItem* CWaveStrip::GetNextSelectedItemInLayer( POSITION pos, CWaveStripLayer* pLayer )
{
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// If this item is in a different layer, skip it
		if( pItem->m_pLayer != pLayer )
		{
			continue;
		}

		// If this item is not selected, skip it
		if( pItem->m_fSelected == FALSE )
		{
			continue;
		}

		return pItem;
	}

	return NULL;
}


#define COLOR_UNSELECTED_WAVE_NAME	RGB(0,0,0)
#define COLOR_SELECTED_WAVE_NAME	RGB(255,0,0)

#define COLOR_UNSELECTED_WAVE		RGB(10,10,255)
#define COLOR_SELECTED_WAVE			RGB(255,0,0)
#define COLOR_BG					RGB(255,255,255)
#define COLOR_START_MARKER			RGB(30, 160, 255)
#define COLOR_END_MARKER			RGB(255, 160, 35)
#define COLOR_CLIP_MARKER			RGB(30, 160, 35)

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DrawMinimizedStrip

HRESULT	CWaveStrip::DrawMinimizedStrip( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	// Verify that our timeline pointer is valid
	if( m_pTrackMgr == NULL
	||	m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Prepare WaveDrawParams struct
	WaveDrawParams	wdp;
	memset( &wdp, 0, sizeof(WaveDrawParams) );
	
	wdp.cbSize = sizeof(WaveDrawParams);
	wdp.bErase = FALSE;
	wdp.clrBackground = COLOR_BG;
	wdp.clrForeground = COLOR_UNSELECTED_WAVE;
	wdp.clrStartMarker = COLOR_START_MARKER;
	wdp.clrEndMarker = 0;
	wdp.clrClipMarker = 0;
	wdp.dwDrawOptions = WAVE_MARKSTART;	 // Can be WAVE_MARKBOTHENDS, WAVE_MARKSTART, WAVE_MARKEND

	// Prepare WaveTimelineInfoParams struct
	WaveTimelineInfoParams	wtip;
	memset( &wtip, 0, sizeof(WaveTimelineInfoParams) );

	wtip.cbSize = sizeof(WaveTimelineInfoParams);
	wtip.dwGroupBits = m_pTrackMgr->m_dwGroupBits;

	// Draw bar and beat lines
	m_pTrackMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pTrackMgr->m_dwGroupBits, 0, lXOffset );

	// Get our clipping rectange
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Highlight range selected in timeline
	HighlightTimelineRange( hDC, lXOffset );

	/////////////////////////////////////////////////////////////////////////
	// First, draw the unselected items 

	// Iterate through the list of items
	POSITION posItem = m_lstTrackItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( posItem );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// If this item is selected, skip it
		if( pItem->m_fSelected == TRUE )
		{
			continue;
		}

		pItem->DrawWave( hDC, lXOffset, -1, &wdp, &wtip );

		// Check if the left edge of the item is beyond the region we're displaying
		if( pItem->m_rectWave.left > rectClip.right )
		{
			// We've gone beyond the right edge of the clipping region - break out of the loop
			break;
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Now, draw the selected items

	// Iterate through the list of items
	wdp.clrForeground = COLOR_SELECTED_WAVE;
	posItem = m_lstTrackItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( posItem );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// If this item is unselected, skip it
		if( pItem->m_fSelected == FALSE )
		{
			continue;
		}

		pItem->DrawWave( hDC, lXOffset, -1, &wdp, &wtip );

		// Check if the left edge of the item is beyond the region we're displaying
		if( pItem->m_rectWave.left > rectClip.right )
		{
			// We've gone beyond the right edge of the clipping region - break out of the loop
			break;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DrawHorizontalLines

void CWaveStrip::DrawHorizontalLines( HDC hDC, const RECT &rectClip )
{
	HPEN hpen = ::CreatePen( PS_SOLID, 1, RGB(0, 0, 0) );
	if( hpen == NULL )
	{
		return;
	}

	HPEN hpenOld = static_cast<HPEN> ( ::SelectObject( hDC, hpen ) );

	// Get nbr of layers
	int nNbrLayers = GetNbrLayers();

	// Determine first layer
	int nCurLayer = m_StripUI.m_lVerticalScrollYPos / m_nWaveHeight;

	// Initialize rectangle
	RECT rectLayer;
	rectLayer.left = rectClip.left;
	rectLayer.right = rectClip.right;
	rectLayer.bottom = m_StripUI.m_lVerticalScrollYPos;

	// Now, draw all the lines
	for( ; nCurLayer <= nNbrLayers ;  nCurLayer++ )
	{
		rectLayer.top = rectLayer.bottom;
		rectLayer.bottom = rectLayer.top + m_nWaveHeight;
		if( rectLayer.top >= rectClip.bottom )
		{
			break;
		}

		::MoveToEx( hDC, rectLayer.left, rectLayer.top, NULL );
		::LineTo( hDC, rectLayer.right, rectLayer.top );
	}

	::SelectObject( hDC, hpenOld );
	::DeleteObject( hpen );
}


#define SECOND_LINE_PENSTYLE	PS_SOLID
#define SECOND_LINE_WIDTH		2
#define SECOND_LINE_COLOR		RGB(0,0,0)
#define GRID_LINE_PENSTYLE		PS_SOLID
#define GRID_LINE_WIDTH			1
#define GRID_LINE_COLOR			RGB(204,204,255)

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DrawClockVerticalLines

void CWaveStrip::DrawClockVerticalLines( HDC hDC, long lXOffset ) // const RECT &rectClip )
{
	// Create the "second" pen
	HPEN hpenSecond = ::CreatePen( SECOND_LINE_PENSTYLE, SECOND_LINE_WIDTH, SECOND_LINE_COLOR );
	if( hpenSecond == NULL )
	{
		return;
	}

	// Create the "grid" pen
	HPEN hpenGrid = ::CreatePen( GRID_LINE_PENSTYLE, GRID_LINE_WIDTH, GRID_LINE_COLOR );
	if( hpenGrid == NULL )
	{
		::DeleteObject( hpenSecond );
		return;
	}

	// Save the current pen and switch to the "second" pen
	HPEN hpenOld = static_cast<HPEN>( ::SelectObject( hDC, hpenSecond ) );

	// Set BkMode
	int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );

	// Get clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Determine end position
	VARIANT var;
	long lEndPosition;
	m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	m_pTrackMgr->m_pTimeline->ClocksToPosition( V_I4(&var), &lEndPosition );

	// Determine start time
	REFERENCE_TIME refTime, refSecond;
	REFERENCE_TIME refGrid = REFCLOCKS_PER_SECOND / m_StripUI.m_nSnapToRefTime_GridsPerSecond;
	m_pTrackMgr->m_pTimeline->PositionToRefTime( rectClip.left + lXOffset, &refTime );
	refSecond = refTime / REFCLOCKS_PER_SECOND;

	char achText[20];
	long lCurPosition;
	long lSecondPosition;

	do
	{
		refTime = refSecond * REFCLOCKS_PER_SECOND;
		m_pTrackMgr->m_pTimeline->RefTimeToPosition( refTime, &lCurPosition );

		if( lCurPosition < lEndPosition )
		{
			// Save position for "second" text
			lSecondPosition = lCurPosition - lXOffset;

			// Draw "second" line
			::SelectObject( hDC, hpenSecond );
			::MoveToEx( hDC, lSecondPosition, 0, NULL );
			::LineTo( hDC, lSecondPosition, m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight );
		
			// Draw "grid" lines
			for( int i = 0 ;  i < m_StripUI.m_nSnapToRefTime_GridsPerSecond ;  i++ )
			{
				refTime += refGrid;
				m_pTrackMgr->m_pTimeline->RefTimeToPosition( refTime, &lCurPosition );

				if( lCurPosition >= lEndPosition )
				{
					break;
				}

				::SelectObject( hDC, hpenGrid );
				::MoveToEx( hDC, lCurPosition - lXOffset, 0, NULL );
				::LineTo( hDC, lCurPosition - lXOffset, m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight );
			}

			// Draw "second" text
			if( refSecond < 60 )
			{
				_snprintf( achText, 10, "%02d", (int)refSecond );
			}
			else
			{
				_snprintf( achText, 10, "%d:%02d", (int)refSecond/60, (int)refSecond%60 );
			}
			::TextOut( hDC, lSecondPosition, m_StripUI.m_lVerticalScrollYPos, achText, strlen(achText) );
		}

		refSecond++;

	} while( lCurPosition <= rectClip.right + lXOffset );

	::SetBkMode( hDC, nOldBkMode);
	::SelectObject( hDC, hpenOld );
	::DeleteObject( hpenSecond );
	::DeleteObject( hpenGrid );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DrawMaximizedStrip

HRESULT	CWaveStrip::DrawMaximizedStrip( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	// Verify that our timeline pointer is valid
	if( m_pTrackMgr == NULL
	||	m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	CRect rect;
	CWaveRectItem* pWaveRect;
	CWaveRectList lstRects;

	// Prepare WaveDrawParams struct
	WaveDrawParams	wdp;
	memset( &wdp, 0, sizeof(WaveDrawParams) );
	
	wdp.cbSize = sizeof(WaveDrawParams);
	wdp.bErase = FALSE;
	wdp.clrBackground = COLOR_BG;
	wdp.clrForeground = COLOR_UNSELECTED_WAVE;
	wdp.clrStartMarker = COLOR_START_MARKER;
	wdp.clrEndMarker = 0;
	wdp.clrClipMarker = 0;
	wdp.dwDrawOptions = WAVE_MARKSTART;	 // Can be WAVE_MARKBOTHENDS, WAVE_MARKSTART, WAVE_MARKEND

	// Prepare WaveTimelineInfoParams struct
	WaveTimelineInfoParams	wtip;
	memset( &wtip, 0, sizeof(WaveTimelineInfoParams) );

	wtip.cbSize = sizeof(WaveTimelineInfoParams);
	wtip.dwGroupBits = m_pTrackMgr->m_dwGroupBits;

	// Save the DC
	int iSavedDC = ::SaveDC( hDC );

	// Exclude the variation bar from the clipping region
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );
	::ExcludeClipRect( hDC, rectClip.left, m_StripUI.m_lVerticalScrollYPos, rectClip.right, m_StripUI.m_lVerticalScrollYPos + VARIATION_BUTTONS_HEIGHT );

	// Exclude the area below the last layer from the clipping region
	::GetClipBox( hDC, &rectClip );
	int nNbrLayers = GetNbrLayers();
	int nBottom = (nNbrLayers * m_nWaveHeight) + 1;
	if( nBottom < rectClip.bottom )
	{
		::ExcludeClipRect( hDC, rectClip.left, nBottom + VARIATION_BUTTONS_HEIGHT, rectClip.right, rectClip.bottom );
	}

	// Offset the origin so it's below the variation selectionbar
	POINT pt;
	::GetWindowOrgEx( hDC, &pt );
	pt.y -= VARIATION_BUTTONS_HEIGHT;
	::SetWindowOrgEx( hDC, pt.x, pt.y, NULL );

	// Get the revised clipping rectange
	::GetClipBox( hDC, &rectClip );

	// Draw bar, beat, grid lines
	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		DrawClockVerticalLines( hDC, lXOffset );
	}
	else
	{
		m_pTrackMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT_GRID, m_pTrackMgr->m_dwGroupBits, 0, lXOffset );
	}

	// Draw horizontal lines
	DrawHorizontalLines( hDC, rectClip );

	// Highlight range selected in timeline
	HighlightTimelineRange( hDC, lXOffset );

	// Create overlapping Wave pen
	HPEN hPenOld = NULL;
	int nModeOld;
	HPEN hPenOverlappingLine = ::CreatePen( PS_DOT, 1, ::GetSysColor(COLOR_WINDOW) );
	if( hPenOverlappingLine )
	{
		hPenOld = (HPEN)::SelectObject( hDC, hPenOverlappingLine );
	}

	CString strText;
	CSize sizeText;
	RECT rectText;
	REFERENCE_TIME rtStart;

	/////////////////////////////////////////////////////////////////////////
	// Draw unselected items 
	wdp.clrForeground = COLOR_UNSELECTED_WAVE;
	::SetTextColor( hDC, COLOR_UNSELECTED_WAVE_NAME );
	if( m_pTrackMgr->IsRefTimeTrack() == false )
	{
		::SetBkMode( hDC, TRANSPARENT );
	}
	
	// Iterate through the list of items
	POSITION posItem = m_lstTrackItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( posItem );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// If this item is selected, skip it
		if( pItem->m_fSelected == TRUE )
		{
			continue;
		}

		pItem->DrawWave( hDC, lXOffset, LayerToIndex(pItem->m_pLayer), &wdp, &wtip );

		// Determine text
		pItem->FormatUIText( strText );
		::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

		// Adjust pItem->m_rectSelect to accomodate text
		::SetRect( &pItem->m_rectSelect, 
				   pItem->m_rectWave.left, pItem->m_rectWave.top, pItem->m_rectWave.right, pItem->m_rectWave.bottom );
		pItem->m_rectSelect.right = max( pItem->m_rectSelect.right, pItem->m_rectSelect.left + sizeText.cx );

		// Determine rectangle for drawing text
		::SetRect( &rectText, 
				   pItem->m_rectSelect.left, pItem->m_rectSelect.top, pItem->m_rectSelect.right, pItem->m_rectSelect.bottom );
		CTrackItem* pNextItem = GetNextItemInLayer( posItem, pItem->m_pLayer );
		if( pNextItem ) 
		{
			m_pTrackMgr->UnknownTimeToRefTime( pNextItem->m_rtTimePhysical, &rtStart );
			m_pTrackMgr->m_pTimeline->RefTimeToPosition( rtStart, &rectText.right );
			rectText.right -= lXOffset;
		}

		// Draw text
		::DrawText( hDC, strText, strText.GetLength(), &rectText, (DT_LEFT | DT_NOPREFIX) );

		// Offset m_rectSelect to account for horizontal scrolling
		::OffsetRect( &pItem->m_rectSelect, lXOffset, 0 );

		// Frame intersecting rectangles
		{
			pWaveRect = lstRects.GetHead(); 
			for( ;  pWaveRect ;  pWaveRect = pWaveRect->GetNext() )
			{
				// Compute intersection with other Waves
				rect.IntersectRect( &pWaveRect->m_rect, &pItem->m_rectSelect );
				rect.InflateRect( 0, -2 );
								
				// Draw it
				if( rect.left != rect.right
				||  rect.top != rect.bottom )
				{
					nModeOld = ::SetROP2( hDC, R2_XORPEN );
	
					rect.left -= lXOffset;
					rect.right -= lXOffset;
					::MoveToEx( hDC, rect.left, rect.bottom, NULL );
					::LineTo( hDC, rect.left, rect.top );
					::LineTo( hDC, rect.right, rect.top );
					::LineTo( hDC, rect.right, rect.bottom );
					::LineTo( hDC, rect.left, rect.bottom );

					::SetROP2( hDC, nModeOld );
				}
			}

			// Store this Wave's rectangle
			pWaveRect = new CWaveRectItem( &pItem->m_rectSelect );
			if( pWaveRect )
			{
				lstRects.AddHead( pWaveRect );
			}
		}

		// Check if the left edge of the item is beyond the region we're displaying
		if( pItem->m_rectWave.left > rectClip.right )
		{
			// We've gone beyond the right edge of the clipping region - break out of the loop
			break;
		}
	}

	/////////////////////////////////////////////////////////////////////////
	// Now, draw the selected items
	wdp.clrForeground = COLOR_SELECTED_WAVE;
	::SetTextColor( hDC, COLOR_SELECTED_WAVE_NAME );

	// Iterate through the list of items
	posItem = m_lstTrackItems.GetHeadPosition();
	while( posItem )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( posItem );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// If this item is not selected, skip it
		if( pItem->m_fSelected == FALSE )
		{
			continue;
		}

		pItem->DrawWave( hDC, lXOffset, LayerToIndex(pItem->m_pLayer), &wdp, &wtip );

		// Determine text
		pItem->FormatUIText( strText );
		::GetTextExtentPoint32( hDC, strText, strText.GetLength(), &sizeText );

		// Adjust pItem->m_rectSelect to accomodate text
		::SetRect( &pItem->m_rectSelect, 
				   pItem->m_rectWave.left, pItem->m_rectWave.top, pItem->m_rectWave.right, pItem->m_rectWave.bottom );
		pItem->m_rectSelect.right = max( pItem->m_rectSelect.right, pItem->m_rectSelect.left + sizeText.cx );

		// Determine rectangle for drawing text
		::SetRect( &rectText, 
				   pItem->m_rectSelect.left, pItem->m_rectSelect.top, pItem->m_rectSelect.right, pItem->m_rectSelect.bottom );
		CTrackItem* pNextItem = GetNextSelectedItemInLayer( posItem, pItem->m_pLayer );
		if( pNextItem ) 
		{
			m_pTrackMgr->UnknownTimeToRefTime( pNextItem->m_rtTimePhysical, &rtStart );
			m_pTrackMgr->m_pTimeline->RefTimeToPosition( rtStart, &rectText.right );
			rectText.right -= lXOffset;
		}

		// Draw text
		::DrawText( hDC, strText, strText.GetLength(), &rectText, (DT_LEFT | DT_NOPREFIX) );

		// Offset m_rectSelect to account for horizontal scrolling
		::OffsetRect( &pItem->m_rectSelect, lXOffset, 0 );

		// Frame intersecting rectangles
		{
			pWaveRect = lstRects.GetHead(); 
			for( ;  pWaveRect ;  pWaveRect = pWaveRect->GetNext() )
			{
				// Compute intersection with other Waves
				rect.IntersectRect( &pWaveRect->m_rect, &pItem->m_rectSelect );
				rect.InflateRect( 0, -2 );
				
				// Draw it
				if( rect.left != rect.right
				||  rect.top != rect.bottom )
				{
					nModeOld = ::SetROP2( hDC, R2_XORPEN );

					rect.left -= lXOffset;
					rect.right -= lXOffset;
					::MoveToEx( hDC, rect.left, rect.bottom, NULL );
					::LineTo( hDC, rect.left, rect.top );
					::LineTo( hDC, rect.right, rect.top );
					::LineTo( hDC, rect.right, rect.bottom );
					::LineTo( hDC, rect.left, rect.bottom );

					::SetROP2( hDC, nModeOld );
				}
			}

			// Store this Wave's rectangle
			pWaveRect = new CWaveRectItem( &pItem->m_rectSelect );
			if( pWaveRect )
			{
				lstRects.AddHead( pWaveRect );
			}
		}

		// Check if the left edge of the item is beyond the region we're displaying
		if( pItem->m_rectWave.left > rectClip.right )
		{
			// We've gone beyond the right edge of the clipping region - break out of the loop
			break;
		}
	}

	if( hPenOld )
	{
		::SelectObject( hDC, hPenOld );
		::DeleteObject( hPenOverlappingLine );
	}

	// Restore the DC
	::RestoreDC( hDC, iSavedDC );

	// Draw variation buttons
	DrawVariationButtonBar( hDC );

	// Cleanup
	while( lstRects.GetHead() )
	{
		pWaveRect = (CWaveRectItem *)lstRects.RemoveHead();
		delete pWaveRect;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::Draw

HRESULT	STDMETHODCALLTYPE CWaveStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that our timeline pointer is valid
	if( m_pTrackMgr == NULL
	||	m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_StripUI.m_nStripView == sv );
	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		DrawMinimizedStrip( hDC, sv, lXOffset );
	}
	else
	{
		DrawMaximizedStrip( hDC, sv, lXOffset );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::HighlightTimelineRange

void CWaveStrip::HighlightTimelineRange( HDC hDC, long lXOffset )
{
	// Highlight the selected range, if there is one.
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);
	if( fUseGutterSelectRange )
	{
		RECT rectClip;
		::GetClipBox( hDC, &rectClip );

		RECT rectHighlight;
		rectHighlight.top = m_StripUI.m_lVerticalScrollYPos + 0;
		rectHighlight.bottom = m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight;

		REFERENCE_TIME rtTime;
		MUSIC_TIME mtTime;

		// Convert the selection start point to a pixel position
		m_pTrackMgr->ClocksToUnknownTime( m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterEndSelect : m_lGutterBeginSelect, &rtTime );
		SnapUnknownTime( rtTime, &rtTime );
		m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtTime );
		m_pTrackMgr->m_pTimeline->ClocksToPosition( mtTime, &(rectHighlight.left) );

		// Offset the rectangle by the horizontal ofset
		rectHighlight.left -= lXOffset;

		// Check that the highlight rectange is visible
		if( rectHighlight.left < rectClip.right )
		{
			// Convert the selection end point to a pixel position
			m_pTrackMgr->ClocksToUnknownTime( m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterBeginSelect : m_lGutterEndSelect, &rtTime );
			SnapUnknownTime( rtTime, &rtTime );
			SnapUnknownToNextIncrement( rtTime, &rtTime );
			m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtTime );
			m_pTrackMgr->m_pTimeline->ClocksToPosition( mtTime, &(rectHighlight.right) );

			// Offset the rectangle by the horizontal ofset
			rectHighlight.right -= lXOffset;

			// Check that the highlight rectange is visible
			if( rectHighlight.right > rectClip.left )
			{
				// Invert the selected rectangle
				GrayOutRect( hDC, &rectHighlight );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetItemFromPoint

CTrackItem* CWaveStrip::GetItemFromPoint( long lXPos, long lYPos )
{
	CTrackItem* pTheItem = NULL;
	BOOL fOnTheWaveHandles = FALSE;

	BOOL fOnWaveHandles;

	CPoint point( lXPos, (lYPos - VARIATION_BUTTONS_HEIGHT) );

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}
		
		if( ::PtInRect( &pItem->m_rectSelect, point ) )
		{
			// Need to set fOnWaveHandles
			fOnWaveHandles = FALSE;
			if( pItem->m_fSelected )
			{
				// Convert the rect of the wave to window coordinates
				CRect selRect = pItem->m_rectSelect;
				VERIFY( SUCCEEDED ( m_pTrackMgr->m_pTimeline->StripToWindowPos( this, &selRect.TopLeft() ) ) );
				VERIFY( SUCCEEDED ( m_pTrackMgr->m_pTimeline->StripToWindowPos( this, &selRect.BottomRight() ) ) );

// TODO: USE THIS CODE!!!
				// Create a tracker
//				CWaveTracker waveTracker( &selRect );
//				UINT nHit = HitTest( waveTracker, lXPos, lYPos );
//			
//				switch( nHit )
//				{
//					case CRectTracker::hitTopLeft:
//					case CRectTracker::hitBottomRight:
//					case CRectTracker::hitTopRight:
//					case CRectTracker::hitBottomLeft:
//					case CRectTracker::hitTop:
//					case CRectTracker::hitBottom:
//					case CRectTracker::hitRight:
//					case CRectTracker::hitLeft:
//						// Cursor is over a RectTracker handle
//						fOnWaveHandles = TRUE;
//						break;
//				}
			}

			if( pTheItem == NULL )
			{
				pTheItem = pItem;
				fOnTheWaveHandles = fOnWaveHandles;
			}
			else
			{
				if( fOnTheWaveHandles == FALSE )
				{
					if( fOnWaveHandles == TRUE )
					{
						// Use the Wave whose handle is being hit
						pTheItem = pItem;
						fOnTheWaveHandles = TRUE;
					}
					else
					{
						// Use the Wave with the narrowest width
						if( (pItem->m_rectSelect.right - pItem->m_rectSelect.left) < (pTheItem->m_rectSelect.right - pTheItem->m_rectSelect.left) ) 
						{
							pTheItem = pItem;
						}
					}
				}
				else
				{
					if( fOnWaveHandles == TRUE )
					{
						// Use the Wave with the narrowest width
						if( (pItem->m_rectSelect.right - pItem->m_rectSelect.left) < (pTheItem->m_rectSelect.right - pTheItem->m_rectSelect.left) ) 
						{
							pTheItem = pItem;
						}
					}
				}
			}
		}
	}

	return pTheItem;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetFBName

void CWaveStrip::GetFBName( CString& strFBName )
{
	CString strTrackGroup, strPChannelName, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	strFBName.Empty();

	// Determine track group text
	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( m_pTrackMgr->m_dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strTrackGroup += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strTrackGroup += strTmp;
	}

	// Determine PChannel text
	m_pTrackMgr->GetPChannelName( m_dwPChannel, strPChannelName );

	// Put it all together
	if( strPChannelName.IsEmpty() )
	{
		strFBName.Format( "%s: %d: %s", strTrackGroup, (m_dwPChannel + 1), (m_dwPChannel + 1), m_strStripName );
	}
	else
	{
		strFBName.Format( "%s: %d (%s): %s", strTrackGroup, (m_dwPChannel + 1), strPChannelName, m_strStripName );
	}
	
	ASSERT( strFBName.IsEmpty() == FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CWaveStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
		case SP_NAME:
		{
			if( m_strStripName.IsEmpty() )
			{
				m_strStripName.LoadString( IDS_STRIP_NAME );
			}

			pvar->vt = VT_BSTR; 

			CString strFBName;
			GetFBName( strFBName );
			V_BSTR(pvar) = strFBName.AllocSysString();
			break;
		}

		case SP_RESIZEABLE:
			// We are resizable
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_MINMAXABLE:
			// We support Minimize/Maximize
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_MINIMIZE_HEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = STRIP_MINIMIZE_HEIGHT;
			break;

		case SP_MINHEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = STRIP_MIN_HEIGHT;
			break;

		case SP_MAXHEIGHT:
		{
			int nNbrLayers = GetNbrLayers();

			pvar->vt = VT_INT;
			V_INT(pvar) = VARIATION_BUTTONS_HEIGHT + (nNbrLayers * m_nWaveHeight);
			break;
		}

		case SP_DEFAULTHEIGHT:
		{
			int nNbrLayers = 2;

			if( m_nWaveHeight == 0 )
			{
				// Determine wave height (necessary when creating new strips)
				m_nWaveHeight = long( MAX_WAVE_HEIGHT * m_StripUI.m_dblVerticalZoom + HORIZ_LINE_HEIGHT );
			}

			pvar->vt = VT_INT;
			V_INT(pvar) = VARIATION_BUTTONS_HEIGHT + (nNbrLayers * m_nWaveHeight);
			break;
		}

		case SP_FUNCTIONBAR_EXCLUDE_WIDTH:
			pvar->vt = VT_I4;
			V_I4(pvar) = sm_nZoomBtnWidth;
			break;

		default:
			return CBaseStrip::GetStripProperty( sp, pvar );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CWaveStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate our timeline pointer
	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Initialize the return code to SUCCESS
	HRESULT hr = S_OK;

	if( nMsg == WM_KEYDOWN )
	{
		if( (wParam == VK_INSERT)
		||	(wParam == VK_DELETE) )
		{
			if( (0x8000 & GetKeyState( VK_CONTROL ))
			&&	(0x8000 & GetKeyState( VK_SHIFT )) )
			{
				if( wParam == VK_INSERT )
				{
					return m_pTrackMgr->OnNewPart();
				}
				else
				{
					m_pTrackMgr->AllStrips_DeleteSelectedParts();
					return S_OK;
				}
			}
		}
	}

	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		switch( nMsg )
		{
			case WM_LBUTTONDOWN:
			case WM_RBUTTONDOWN:
				// Change to the track group property page
				OnShowStripProperties();
				if( m_pTrackMgr->m_pPropPageMgr )
				{
					m_pTrackMgr->m_pPropPageMgr->RefreshData();
				}
				return S_OK;

			case WM_LBUTTONUP:
			case WM_MOUSEMOVE:
			case WM_KEYDOWN:
				// Do nothing if strip is minimized
				return S_OK;

			case WM_RBUTTONUP:
				// Only display right-click context menu if strip is minimized
				POINT pt;
				if( !GetCursorPos( &pt ) )
				{
					hr = E_UNEXPECTED;
					break;
				}
				m_fInFunctionBarMenu = true;
				hr = PostRightClickMenu( pt );
				m_fInFunctionBarMenu = false;
				return S_OK;
		}
	}

	// Adjust lXPos and lYPos for processing variation buttons
	long lLeftDisplay;
	m_pTrackMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	lLeftDisplay = max( 0, lLeftDisplay );
	m_pTrackMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );
	long lXPosVarBtns = (lXPos - lLeftDisplay);
	long lYPosVarBtns = (lYPos - m_StripUI.m_lVerticalScrollYPos);

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_fLeftMouseDown = true;
		m_pLayerForShiftClick = NULL;
		if( lYPosVarBtns < VARIATION_BUTTONS_HEIGHT )
		{
			m_wMouseMode = MM_VARBTNS;
			hr = OnLButtonDownVarBtns( wParam, lParam, lXPosVarBtns, lYPosVarBtns );
			m_lXPos = -1;
			m_lYPos = -1;
		}
		else
		{
			hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
			m_lXPos = lXPos;	// need to start drag drop from where selection started
			m_lYPos = lYPos;
		}
		break;

	case WM_LBUTTONDBLCLK:
		m_fLeftMouseDown = true;
		m_pLayerForShiftClick = NULL;
		if( lYPosVarBtns < VARIATION_BUTTONS_HEIGHT )
		{
			m_wMouseMode = MM_VARBTNS;
			hr = OnLButtonDblClkVarBtns( wParam, lParam, lXPosVarBtns, lYPosVarBtns );
			m_lXPos = -1;
			m_lYPos = -1;
		}
		else
		{
			// Use default message handler for WM_LBUTTONDBLCLK
			hr = CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			m_lYPos = lYPos;
		}
		break;

	case WM_RBUTTONDOWN:
		m_pLayerForShiftClick = NULL;
		if( lYPosVarBtns < VARIATION_BUTTONS_HEIGHT )
		{
			m_wMouseMode = MM_VARBTNS;
			hr = OnRButtonDownVarBtns( wParam, lParam, lXPosVarBtns, lYPosVarBtns );
		}
		else
		{
			hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		}
		m_lYPos = lYPos;
		break;

	case WM_MOUSEMOVE:
		if( m_wMouseMode == MM_VARBTNS )
		{
			hr = OnMouseMoveVarBtns( wParam, lParam, lXPosVarBtns, lYPosVarBtns );
		}
		else
		{
			hr = OnMouseMove( wParam, lParam, lXPos, lYPos );
		}
		break;

	case WM_LBUTTONUP:
		m_fLeftMouseDown = false;
		if( m_wMouseMode == MM_VARBTNS )
		{
			hr = OnLButtonUpVarBtns( wParam, lParam, lXPosVarBtns, lYPosVarBtns );
		}
		else
		{
			hr = OnLButtonUp( wParam, lParam, lXPos, lYPos );
			m_lXPos = lXPos;
			m_lYPos = lYPos;
		}
		m_wMouseMode = 0;
		break;

	case WM_RBUTTONUP:
		if( m_wMouseMode == MM_VARBTNS )
		{
			hr = OnRButtonUpVarBtns( wParam, lParam, lXPosVarBtns, lYPosVarBtns );
		}
		else
		{
			// Use default message handler for WM_RBUTTONUP
			hr = CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		}
		m_wMouseMode = 0;
		break;

	case WM_SETFOCUS:
	case WM_KILLFOCUS:
		m_pTrackMgr->SetAuditionVariations( false );
		m_pTrackMgr->UpdateStatusBarDisplay();
		break;

	case WM_CHAR:
		hr = OnChar( wParam );
		break;

	case WM_VSCROLL:
		hr = RefreshVerticalScrollBarUI();
		break;

	case WM_TIMER:
	{
		HWND hwnd = GetTimelineHWND();
		if( hwnd )
		{
			switch( wParam )
			{
				case TIMER_ZOOM_1:
					::KillTimer( hwnd, TIMER_ZOOM_1 );
					::SetTimer( hwnd, TIMER_ZOOM_2, 100, NULL );
					// Intentional fall-through to TIMER_ZOOM_2

				case TIMER_ZOOM_2:
					if( m_fZoomInDown )
					{
						SetZoom( m_StripUI.m_dblVerticalZoom + 0.01 );
					}
					else
					{
						if( m_StripUI.m_dblVerticalZoom > MINIMUM_ZOOM_LEVEL )
						{
							SetZoom( m_StripUI.m_dblVerticalZoom - 0.01 );
						}
					}
					break;

				case TIMER_VSCROLL_LAYER_1:
					::KillTimer( hwnd, TIMER_VSCROLL_LAYER_1 );
					::SetTimer( hwnd, TIMER_VSCROLL_LAYER_2, 100, NULL );
					m_nVerticalScrollTimer = TIMER_VSCROLL_LAYER_2;
					// Intentional fall-through to TIMER_VSCROLL_LAYER_2

				case TIMER_VSCROLL_LAYER_2:
				{
					POINT pt;
					::GetCursorPos( &pt );
					m_pTrackMgr->m_pTimeline->ScreenToStripPosition( (IDMUSProdStrip *)this, &pt );
					if( pt.y > (m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight) )
					{
						OnVScrollFromScrollbar( SB_LINEDOWN, (UINT)-1 );
						FBOnWMMessage( WM_MOUSEMOVE, 0, 0, pt.x, (m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight - 1) );
					}
					else
					{
						OnVScrollFromScrollbar( SB_LINEUP, (UINT)-1 );
						FBOnWMMessage( WM_MOUSEMOVE, 0, 0, pt.x, (m_StripUI.m_lVerticalScrollYPos + VARIATION_BUTTONS_HEIGHT + 1) );
					}
					break;
				}
			}
		}
		break;
	}

	case WM_MOVE:
		RefreshVerticalScrollBarUI();
		break;

	case WM_SIZE:
		if( wParam == SIZE_MAXIMIZED )
		{
			m_StripUI.m_nStripView = SV_NORMAL;
			m_pTrackMgr->m_nLastEdit = IDS_UNDO_STRIP_MAXIMIZED;
			m_pTrackMgr->OnDataChanged();
		}
		else if( wParam == SIZE_MINIMIZED )
		{
			m_StripUI.m_nStripView = SV_MINIMIZED;
			m_pTrackMgr->m_nLastEdit = IDS_UNDO_STRIP_MINIMIZED;
			m_pTrackMgr->OnDataChanged();
		}
		else
		{
			if( m_pTrackMgr->m_pTimeline )
			{
				VARIANT var;
				if( SUCCEEDED( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, &var) ) )
				{
					if( m_StripUI.m_lStripHeight != V_I4(&var) )
					{
						m_StripUI.m_lStripHeight = V_I4(&var);
						m_pTrackMgr->m_nLastEdit = IDS_UNDO_STRIP_RESIZE;
						m_pTrackMgr->OnDataChanged();
					}
				}
			}
		}
		RefreshVerticalScrollBarUI();
		break;

	case WM_COMMAND:
	{
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
			case IDM_SNAP_NONE:
			case IDM_SNAP_GRID:
			case IDM_SNAP_BEAT:
			case IDM_SNAP_BAR:
			case IDM_SNAP_SECOND:
				SetSnapTo( wID );
				break;

			case IDM_SNAP_SET_GRID:
				DoGridsPerSecond();
				break;

			case IDM_ZOOM_IN:
				SetZoom( m_StripUI.m_dblVerticalZoom + 0.01);
				break;

			case IDM_ZOOM_OUT:
				if( m_StripUI.m_dblVerticalZoom > MINIMUM_ZOOM_LEVEL )
				{
					SetZoom( m_StripUI.m_dblVerticalZoom - 0.01);
				}
				break;

			case IDM_ADD_PART:
				hr = m_pTrackMgr->OnNewPart();
				break;

			case IDM_DELETE_PART:
				m_pTrackMgr->AllStrips_DeleteSelectedParts();
				hr = S_OK;
				break;

			case IDM_MERGE_VARIATIONS:
				MergeVariations();
				hr = S_OK;
				break;
			
			case ID_VIEW_PROPERTIES:
				hr = ShowPropertySheet();
				if( SUCCEEDED ( hr ) )
				{
					if( m_fShowItemProps )
					{
						// Change to the item property page
						OnShowItemProperties();

						// Update the property page, if it exists
						RefreshPropertyPage();
					}
					else
					{
						// Change to the track group property page
						OnShowStripProperties();

						// Update the property page, if it exists
						if( m_pTrackMgr->m_pPropPageMgr )
						{
							m_pTrackMgr->m_pPropPageMgr->RefreshData();
						}
					}
				}
				break;

			case IDM_INSERT_LAYER:
			{
				int nLayerIndex = YPosToLayerIndex( m_lYPos );
				hr = InsertLayers( nLayerIndex );
				break;
			}

			case IDM_DELETE_LAYERS:
				hr = DeleteSelectedLayers();
				break;

			case IDM_ENABLE_VARBTNS:
			case IDM_DISABLE_VARBTNS:
				hr = OnEnableVariations( wID );
				break;

			default:
				// Try the default message handler
				CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			break;
		}
		break;
	}

	case WM_DESTROY:
		hr = OnDestroy();
		break;

	case WM_CREATE:
		hr = OnCreate();

		// Fall through to CBaseStrip's message handler, since we want it to also
		// handle the WM_CREATE message

	default:
		// Try the default message handler
		// This handles WM_COMMAND and WM_CREATE
		CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::FBDraw

HRESULT CWaveStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTrackMgr == NULL 
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	if( sv != SV_FUNCTIONBAR_NORMAL )
	{
		return S_OK;
	}

	RECT rectExcludeClip = { 0, 0, 0, 0 };
	
	int iSavedDC = ::SaveDC( hDC );
	
	// Get function bar rect
	CRect rectFBar;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_CLIENT_RECT, &var ) ) )
	{
		return E_FAIL;
	}

	// fix the clipping region
	{
		RECT rectClip;
		::GetClipBox( hDC, &rectClip );

		POINT point;
		::GetWindowOrgEx( hDC, &point );

		rectClip.left -= point.x;
		rectClip.right -= point.x;
		rectClip.top = -point.y;
		rectClip.bottom -= point.y;

		HRGN hRgn;
		hRgn = ::CreateRectRgnIndirect( &rectClip );
		if( !hRgn )
		{
			return E_FAIL;
		}
		::SelectClipRgn( hDC, hRgn );
		::DeleteObject( hRgn );
	}

	HFONT hfont = NULL;
	HFONT hfontOld = NULL;
	int nBkModeOld = 0;

	// Create font for Layer buttons
	{
		LOGFONT lf;
		memset( &lf, 0 , sizeof(LOGFONT));
		if( m_StripUI.m_dblVerticalZoom < .18 )
		{
			lf.lfHeight = long(MAX_WAVE_HEIGHT * .8 * m_StripUI.m_dblVerticalZoom);
		}
		else
		{
			lf.lfHeight = long(MAX_WAVE_HEIGHT * .8 * .18);
		}
		//lf.lfWidth = 0;
		//lf.lfEscapement = 0;
		//lf.lfOrientation = 0;
		lf.lfWeight = FW_NORMAL;
		//lf.lfItalic = FALSE;
		//lf.lfUnderline = FALSE;
		//lf.lfStrikeOut = FALSE;
		//lf.lfCharSet = ANSI_CHARSET;
		//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		//lf.lfQuality = DEFAULT_QUALITY;
		lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
		//lf.lfFaceName = NULL;

		hfont = ::CreateFontIndirect( &lf );
		if( hfont )
		{
			nBkModeOld = ::SetBkMode( hDC, TRANSPARENT );
			hfontOld = static_cast<HFONT>( ::SelectObject( hDC, hfont ) );
		}
	}

	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Draw Layer buttons
	{
		// Get nbr of layers
		int nNbrLayers = GetNbrLayers();

		// Determine first layer
		int nCurLayer = (m_StripUI.m_lVerticalScrollYPos / m_nWaveHeight) + 1;

		// Initialize rectangle
		RECT rectLayer;
		rectLayer.left = rectFBar.right - sm_nLayerBtnWidth - 3;
		rectLayer.right = rectLayer.left + sm_nLayerBtnWidth;
		rectLayer.bottom = m_StripUI.m_lVerticalScrollYPos + VARIATION_BUTTONS_HEIGHT;

		// Create a brush
		HBRUSH brush = ::CreateSolidBrush( GetSysColor(COLOR_BTNFACE) );

		// Now, draw all the buttons
		CString strText;
		int nFirst;
		int nSecond;
		POSITION pos;
		BOOL fSelected;
		for( ; nCurLayer <= nNbrLayers ;  nCurLayer++ )
		{
			rectLayer.top = rectLayer.bottom;
			rectLayer.bottom = rectLayer.top + m_nWaveHeight;
			if( rectLayer.top >= rectClip.bottom )
			{
				break;
			}

			fSelected = FALSE;
			pos = m_lstLayers.FindIndex( nCurLayer - 1 );
			if( pos )
			{
				CWaveStripLayer* pLayer = m_lstLayers.GetAt( pos );

				pLayer->m_fSelected = SyncLayerSelectFlag( pLayer );
				if( pLayer->m_fSelected )
				{
					fSelected = TRUE;
				}
	
				if( IsLayerEmpty( pLayer ) )
				{
					::SetTextColor( hDC, RGB(255,255,255) );
				}
				else
				{
					::SetTextColor( hDC, RGB(0,0,0) );
				}
			}

			::FillRect( hDC, &rectLayer, brush );

			// Determine layer button text
			strText.Empty();
			nFirst = (nCurLayer - 1) / 26;
			nSecond = (nCurLayer - 1) % 26;
			if( nFirst )
			{
				strText = (char)( _T('a' ) + nFirst - 1 );
			}
			strText += (char)( _T('a' ) + nSecond );

			if( nCurLayer == nNbrLayers )
			{
				// 'New' layer
				::FillRect( hDC, &rectLayer, brush );
				::DrawEdge( hDC, &rectLayer, EDGE_BUMP, BF_RECT );
			}
			else if( fSelected )
			{
				::DrawEdge( hDC, &rectLayer, EDGE_SUNKEN, BF_RECT );
				::InflateRect( &rectLayer, 0, -1 );
				::OffsetRect( &rectLayer, 1, 1 );
				::DrawText( hDC, strText, -1, &rectLayer, DT_NOCLIP | DT_VCENTER | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX );
				::OffsetRect( &rectLayer, -1, -1 );
				::InflateRect( &rectLayer, 0, 1 );
			}
			else
			{
				::DrawEdge( hDC, &rectLayer, EDGE_RAISED, BF_RECT );
				::InflateRect( &rectLayer, 0, -1 );
				::DrawText( hDC, strText, -1, &rectLayer, DT_NOCLIP | DT_VCENTER | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX );
				::InflateRect( &rectLayer, 0, 1 );
			}
		}

		// Delete the brush
		if( brush )
		{
			::DeleteObject( brush );
		}
	}

	// Cleanup font used for Layer buttons
	if( hfontOld )
	{
		::SelectObject( hDC, hfontOld );
		hfontOld = NULL;
	}
	if( hfont )
	{
		::SetBkMode( hDC, nBkModeOld );
		::DeleteObject( hfont );
		hfont = NULL;
	}

	// Draw Zoom buttons
	{
		if( m_fZoomInDown )
		{
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( sm_bmpZoomInBtnDown.GetSafeHandle() ), NULL,
				rectFBar.right - sm_nZoomBtnWidth - 3, m_StripUI.m_lVerticalScrollYPos,
				sm_nZoomBtnWidth, sm_nZoomBtnHeight, DST_BITMAP | DSS_NORMAL );
		}
		else
		{
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( sm_bmpZoomInBtnUp.GetSafeHandle() ), NULL,
				rectFBar.right - sm_nZoomBtnWidth - 3, m_StripUI.m_lVerticalScrollYPos,
				sm_nZoomBtnWidth, sm_nZoomBtnHeight, DST_BITMAP | DSS_NORMAL );
		}
		if( m_fZoomOutDown )
		{
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( sm_bmpZoomOutBtnDown.GetSafeHandle() ), NULL,
				rectFBar.right - sm_nZoomBtnWidth - 3, sm_nZoomBtnHeight + m_StripUI.m_lVerticalScrollYPos,
				sm_nZoomBtnWidth, sm_nZoomBtnHeight, DST_BITMAP | DSS_NORMAL );
		}
		else
		{
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( sm_bmpZoomOutBtnUp.GetSafeHandle() ), NULL,
				rectFBar.right - sm_nZoomBtnWidth - 3, sm_nZoomBtnHeight + m_StripUI.m_lVerticalScrollYPos,
				sm_nZoomBtnWidth, sm_nZoomBtnHeight, DST_BITMAP | DSS_NORMAL );
		}
	}

	// Set up the rect to exclude
	rectExcludeClip.right = rectFBar.right - 3;
	rectExcludeClip.left = rectExcludeClip.right - sm_nZoomBtnWidth;
	rectExcludeClip.top = m_StripUI.m_lVerticalScrollYPos;
	rectExcludeClip.bottom = m_StripUI.m_lVerticalScrollYPos + sm_nZoomBtnHeight + sm_nZoomBtnHeight;

	::RestoreDC( hDC, iSavedDC );

	// Exclude the zoom buttons
	::ExcludeClipRect( hDC, rectExcludeClip.left, rectExcludeClip.top, rectExcludeClip.right, rectExcludeClip.bottom );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::FBOnWMMessage

HRESULT CWaveStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		switch( nMsg )
		{
			case WM_LBUTTONDOWN:
			case WM_RBUTTONDOWN:
				// Change to the track group property page
				OnShowStripProperties();
				if( m_pTrackMgr->m_pPropPageMgr )
				{
					m_pTrackMgr->m_pPropPageMgr->RefreshData();
				}
				return S_OK;

			case WM_LBUTTONDBLCLK:
			case WM_KEYDOWN:
				// Not much to do if strip is minimized
				m_pLayerForShiftClick = NULL;
				return S_OK;
		}
	}

	// Process the window message
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	{
		ASSERT( m_wMouseMode == 0 );
		if( lYPos <= m_StripUI.m_lVerticalScrollYPos + sm_nZoomBtnHeight + sm_nZoomBtnHeight )
		{
			VARIANT varXS;
			if( SUCCEEDED( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
			{
				if( lXPos >= V_I4( &varXS ) - sm_nZoomBtnWidth - 3 )
				{
					m_wMouseMode = MM_ZOOMBTNS;
					hr = OnLButtonDownZoomBtns( wParam, lParam, lXPos, lYPos );
				}
			}
		}
		else
		{
			int nLayerIndex = YPosToLayerIndex( lYPos );
			if( nLayerIndex >= 0
			&&  nLayerIndex < m_lstLayers.GetCount() )
			{
				VARIANT varXS;
				if( SUCCEEDED( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
				{
					if( lXPos >= V_I4( &varXS ) - sm_nLayerBtnWidth - 3 )
					{
						m_wMouseMode = MM_LAYERBTNS;
						hr = OnLButtonDownLayerBtns( wParam, lParam, lXPos, lYPos );
					}
				}
			}
		}
		// Change the property page to the strip (group bits) property page
		if( m_wMouseMode != MM_ZOOMBTNS
		&&  m_wMouseMode != MM_LAYERBTNS )
		{
			OnShowStripProperties();
		}
		m_lXPos = -1;
		m_lYPos = -1;
		break;
	}

	case WM_LBUTTONUP:
		if( m_wMouseMode == MM_ZOOMBTNS )
		{
			hr = OnLButtonUpZoomBtns( wParam, lParam, lXPos, lYPos );
		}
		else if( m_wMouseMode == MM_LAYERBTNS )
		{
			hr = OnLButtonUpLayerBtns( wParam, lParam, lXPos, lYPos );
		}
		m_lXPos = -1;
		m_lYPos = -1;
		m_wMouseMode = 0;
		break;

	case WM_MOUSEMOVE:
		if( m_wMouseMode == MM_LAYERBTNS )
		{
			hr = OnMouseMoveLayerBtns( wParam, lParam, lXPos, lYPos );
		}
		else
		{
			// Use default message handler for WM_MOUSEMOVE
			hr = CBaseStrip::FBOnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		}
		break;

	case WM_RBUTTONDOWN:
	{
		m_pLayerForShiftClick = NULL;
		int nLayerIndex = YPosToLayerIndex( lYPos );
		if( nLayerIndex >= 0
		&&  nLayerIndex < m_lstLayers.GetCount() )
		{
			VARIANT varXS;
			if( SUCCEEDED( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
			{
				if( lXPos >= V_I4( &varXS ) - sm_nLayerBtnWidth - 3 )
				{
					hr = OnRButtonDownLayerBtns( wParam, lParam, lXPos, lYPos );
				}
			}
		}
		break;
	}

	case WM_RBUTTONUP:
	{
		int nLayerIndex = YPosToLayerIndex( lYPos );
		if( nLayerIndex >= 0
		&&  nLayerIndex < GetNbrLayers() )
		{
			VARIANT varXS;
			if( SUCCEEDED( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
			{
				if( lXPos >= V_I4( &varXS ) - sm_nLayerBtnWidth - 3 )
				{
					hr = OnRButtonUpLayerBtns( wParam, lParam, lXPos, lYPos );
					m_lXPos = -1;
					m_lYPos = lYPos;	// Used by InsertLayers()	
					break;
				}
			}
		}

		// Set the cursor position for the insert operation to -1
		m_lXPos = -1;
		m_lYPos = -1;

		// Get the cursor position (To put the menu there)
		POINT pt;
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		// Display a right-click context menu.
		m_fInFunctionBarMenu = true;
		hr = PostRightClickMenu( pt );
		m_fInFunctionBarMenu = false;
		break;
	}

	default:
		return CBaseStrip::FBOnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::Copy

HRESULT CWaveStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if there is anything to copy
	HRESULT hr = CanCopy();
	if( hr != S_OK )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Validate our pointer to the timeline
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Make sure the clipboard formats have been registered
	if( RegisterClipboardFormats() == FALSE )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	long lStartTime;
	long lEndTime;
	m_pSelectedRegions->GetSpan( lStartTime, lEndTime );

	// Compute the start offset
	REFERENCE_TIME rtStartOffset;
	long lMeasure;
	long lBeat;
	m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, lStartTime, &lMeasure, &lBeat );
	m_pTrackMgr->MeasureBeatGridTickToUnknownTime( lMeasure, lBeat, 0, 0, &rtStartOffset);
	CTrackItem* pFirstSelectedItem = GetFirstSelectedItem();
	if( pFirstSelectedItem )
	{
		rtStartOffset = pFirstSelectedItem->m_rtTimePhysical - rtStartOffset;
	}

	// Create an IStream to save the selected items in.
	IStream* pIStreamCopy;
	if( FAILED ( m_pTrackMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStreamCopy) ) )
	{
		return hr;
	}

	// Save the selected items into the stream
	if( FAILED( hr = SaveSelectedItems( pIStreamCopy, rtStartOffset, NULL ) ) )
	{
		pIStreamCopy->Release();
		return hr;
	}

	// The save succeeded - copy the stream to the clipboard
	hr = CopyDataToClipboard( pITimelineDataObject, pIStreamCopy, m_cfWaveTrack, m_pTrackMgr, this );

	pIStreamCopy->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::MergeVariations

void CWaveStrip::MergeVariations( void )
{
	bool fChanged = false;

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// For all items that are in the affected variations,
		// mask out all unaffected variations, and check if any of the affected
		// variations are unselected.
		if( pItem->m_dwVariations & m_StripUI.m_dwVariationBtns )
		{
			if( (pItem->m_dwVariations & m_StripUI.m_dwVariationBtns)^m_StripUI.m_dwVariationBtns )
			{
				fChanged = true;
				pItem->m_dwVariations |= m_StripUI.m_dwVariationBtns;
			}
		}
	}

	if( fChanged )
	{
		m_pTrackMgr->m_nLastEdit = IDS_UNDO_MERGE_VARIATIONS;
		m_pTrackMgr->OnDataChanged();

		if( m_pTrackMgr->m_pTimeline )
		{
			m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
		}

		// Update the property page
		RefreshPropertyPage();

		m_pTrackMgr->SyncWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::MapVariations

DWORD CWaveStrip::MapVariations( DWORD dwOrigVaritions, DWORD dwVariationMap[32] )
{
	// Initialize the variation bits to return to 0
	DWORD dwVarsToReturn = 0;

	// Iterate through all 32 variations
	for( int nClip = 0; nClip < 32; nClip++ )
	{
		// Check if the original variation bit nClip is set
		if( dwOrigVaritions & (1 << nClip) )
		{
			// Set the bit in dwVarsToReturn that matches original bit nClip
			dwVarsToReturn |= dwVariationMap[nClip];
		}
	}

	// Return the new variation flags
	return dwVarsToReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CalculateDropTime

REFERENCE_TIME CWaveStrip::CalculateDropTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI )
{
	REFERENCE_TIME rtDropTime;

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtTime, &rtTime );
		rtTime += pCopyPasteUI->m_rtOffset;

		long lMinute, lSec, lGrid, lMs;
		m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSec, &lGrid, &lMs );

		if( m_StripUI.m_nSnapToRefTime != IDM_SNAP_NONE )
		{
			if( lMs < 0 )
			{
				m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSec, (lGrid - 1), 0, &rtTime );
				m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSec, &lGrid, &lMs );
			}
		}

		switch( m_StripUI.m_nSnapToRefTime )
		{
			case IDM_SNAP_NONE:
				// Nothing to do
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MinSecGridMsToRefTime( this,
													lMinute,
												    lSec,
													lGrid,
													pCopyPasteUI->m_lRefTimeMs,
													&rtTime );
				break;
			
			case IDM_SNAP_SECOND:
				m_pTrackMgr->MinSecGridMsToRefTime( this,
													lMinute,
													lSec,
													pCopyPasteUI->m_lRefTimeGrid,
													pCopyPasteUI->m_lRefTimeMs,
													&rtTime );
				break;
		}

		m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtDropTime );
	}
	else
	{
		mtTime += pCopyPasteUI->m_mtOffset;

		long lMeasure, lBeat, lGrid, lTick;
		m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick );

		if( m_StripUI.m_nSnapToMusicTime != IDM_SNAP_NONE )
		{
			if( lTick < 0 )
			{
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, (lGrid - 1), 0, &mtTime );
				m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick );
			}
		}

		switch( m_StripUI.m_nSnapToMusicTime )
		{
			case IDM_SNAP_NONE:
				// Nothing to do
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  lBeat,
														  lGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
			
			case IDM_SNAP_BEAT:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  lBeat,
														  pCopyPasteUI->m_lMusicTimeGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
			
			case IDM_SNAP_BAR:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  pCopyPasteUI->m_lMusicTimeBeat,
														  pCopyPasteUI->m_lMusicTimeGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
		}

		m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtDropTime );
	}

	return rtDropTime;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CalculatePasteTime

REFERENCE_TIME CWaveStrip::CalculatePasteTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI )
{
	REFERENCE_TIME rtDropTime;

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtTime, &rtTime );

		long lMinute, lSec, lGrid, lMs;
		m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSec, &lGrid, &lMs );

		switch( m_StripUI.m_nSnapToRefTime )
		{
			case IDM_SNAP_NONE:
				// Nothing to do
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MinSecGridMsToRefTime( this,
													lMinute,
												    lSec,
													lGrid,
													pCopyPasteUI->m_lRefTimeMs,
													&rtTime );
				break;
			
			case IDM_SNAP_SECOND:
				m_pTrackMgr->MinSecGridMsToRefTime( this,
													lMinute,
													lSec,
													pCopyPasteUI->m_lRefTimeGrid,
													pCopyPasteUI->m_lRefTimeMs,
													&rtTime );
				break;
		}

		m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtDropTime );
	}
	else
	{
		long lMeasure, lBeat, lGrid, lTick;
		m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick );

		switch( m_StripUI.m_nSnapToMusicTime )
		{
			case IDM_SNAP_NONE:
				// Nothing to do
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  lBeat,
														  lGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
			
			case IDM_SNAP_BEAT:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  lBeat,
														  pCopyPasteUI->m_lMusicTimeGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
			
			case IDM_SNAP_BAR:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  pCopyPasteUI->m_lMusicTimeBeat,
														  pCopyPasteUI->m_lMusicTimeGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
		}

		m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtDropTime );
	}

	return rtDropTime;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::PasteAt

HRESULT CWaveStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lPasteTime, bool bDropNotPaste, BOOL &fChanged )
{
	HRESULT hr = E_FAIL;

	// Validate the data object pointer
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Calc rtSnapPasteTime 
	REFERENCE_TIME rtSnapPasteTime;
	if( FAILED( m_pTrackMgr->ClocksToUnknownTime( lPasteTime, &rtSnapPasteTime ) ) 
	||  FAILED( SnapUnknownTime( rtSnapPasteTime, &rtSnapPasteTime ) ) )
	{
		return E_UNEXPECTED;
	}

	// Handle CF_WAVETRACK
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfWaveTrack ) == S_OK )
	{
		// Try and read the stream that contains the items
		IStream* pIStream;
		if( SUCCEEDED ( pITimelineDataObject->AttemptRead( m_cfWaveTrack, &pIStream) ) )
		{
			// Read DMUS_FOURCC_COPYPASTE_UI_CHUNK
			IDMUSProdRIFFStream* pIRiffStream;
			MMCKINFO ck;
			DWORD dwByteCount;
			DWORD dwSize;

			ioCopyPasteUI iCopyPasteUI;
			ZeroMemory( &iCopyPasteUI, sizeof(ioCopyPasteUI) );

			hr = AllocRIFFStream( pIStream, &pIRiffStream );
			if( SUCCEEDED( hr ) )
			{
				DWORD dwPos = StreamTell( pIStream );

				ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
				if( pIRiffStream->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
				{
					dwSize = min( ck.cksize, sizeof(ioCopyPasteUI) );
					if( FAILED ( pIStream->Read( &iCopyPasteUI, dwSize, &dwByteCount ) )
					||  dwByteCount != dwSize )
					{
						hr = E_FAIL;
					}
				}
				RELEASE( pIRiffStream );

				StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
			}

			if( SUCCEEDED ( hr ) )
			{
				// If we're in a drag-drop operation 
				if( bDropNotPaste )
				{
					// And we are dropping in the same strip
					if( m_pITargetDataObject == m_pISourceDataObject )
					{
						// Make sure we are /dropping to a different location
						REFERENCE_TIME rtSnapTime;
						if( SUCCEEDED ( SnapXPosToUnknownTime( m_lStartDragPosition, &rtSnapTime ) ) )
						{
							if( rtSnapPasteTime == rtSnapTime )
							{
								ASSERT( m_lYPos > 0 );  // m_lYPos not being set!!!
								if( YPosToLayerIndex(m_lYPos) == iCopyPasteUI.m_nStartLayerIndex )
								{
									// Didn't move - exit early
									hr = E_FAIL;
									goto Leave_1;
								}
							}
						}
					}
				}

				// Load the stream into a list of items
				CTypedPtrList<CPtrList, CTrackItem*> list;
				hr = LoadList( list, pIStream );

				// Do we need to convert times?
				if( iCopyPasteUI.m_fRefTimeTrack != m_pTrackMgr->IsRefTimeTrack() )
				{
					REFERENCE_TIME rtOrigTimeLogical;
					POSITION pos = list.GetHeadPosition();
					while( pos )
					{
						CTrackItem* pItem = list.GetNext( pos );

						rtOrigTimeLogical = pItem->m_rtTimeLogical;
						pItem->SwitchTimeBase();
						pItem->m_rtTimeLogical = rtOrigTimeLogical;
					}
				}

				// Check if the load operation succeeded
				if ( SUCCEEDED( hr ) )
				{
					// Create a mapping of source variations to destination variations
					ASSERT( m_dwSourceVariationBtns != 0 );	
					DWORD dwVariationMap[32];
					ZeroMemory( dwVariationMap, sizeof(DWORD) * 32 );
					int nClip, nCur, nTmp;
					nCur = 0;
					for( nClip = 0 ;  nClip < 32 ;  nClip++ )
					{
						if( m_dwSourceVariationBtns & (1 << nClip) )
						{
							for( nTmp = nCur ;  nTmp < 32 ;  nTmp++ )
							{
								if( m_StripUI.m_dwVariationBtns & (1 << nTmp) )
								{
									dwVariationMap[nClip] = (1 << nTmp);
									nCur = nTmp + 1;
									break;
								}
							}
							if ( nTmp == 32 )
							{
								EmptyList( list );
								AfxMessageBox( IDS_ERROR_VAR_MISMATCH );
								hr = E_FAIL;
								goto Leave_1;
							}
						}
					}

					// Make sure we have enough layers
					int nNbrPasteLayers = (iCopyPasteUI.m_nMaxLayerIndex - iCopyPasteUI.m_nMinLayerIndex) + 1;
					if( nNbrPasteLayers > m_lstLayers.GetCount() )
					{
						// Not enough layers in target strip
						EmptyList( list );
						AfxMessageBox( IDS_ERROR_LAYER_MISMATCH );
						hr = E_FAIL;
						goto Leave_1;
					}

					// Determine offset for mapping source layers to destination layers
					int nLayerPasteOffset = 0;
					if( m_lYPos > 0 )
					{
						nLayerPasteOffset = YPosToLayerIndex( m_lYPos );
						if( nLayerPasteOffset == -1 )
						{
							// Not dropping on any layers
							EmptyList( list );
							hr = E_FAIL;
							goto Leave_1;
						}
						else
						{
							nLayerPasteOffset -= iCopyPasteUI.m_nStartLayerIndex;
						}
					}
					if( (iCopyPasteUI.m_nMaxLayerIndex + nLayerPasteOffset) > m_lstLayers.GetCount() )
					{
						nLayerPasteOffset -= (iCopyPasteUI.m_nMaxLayerIndex + nLayerPasteOffset) - m_lstLayers.GetCount();
					}
					if( (iCopyPasteUI.m_nMinLayerIndex + nLayerPasteOffset) < 0 )
					{
						nLayerPasteOffset += -(iCopyPasteUI.m_nMinLayerIndex + nLayerPasteOffset);
					}

					// Calc rtPasteTime 
					REFERENCE_TIME rtPasteTime;
					if( bDropNotPaste )
					{
						rtPasteTime = CalculateDropTime( lPasteTime, &iCopyPasteUI );
					}
					else
					{
						rtPasteTime = CalculatePasteTime( lPasteTime, &iCopyPasteUI );
					}

					if( m_pTrackMgr->m_pTimeline )
					{
						// The length of the segment, in beats, in music time
						MUSIC_TIME mtSegmentLength = LONG_MAX;
						REFERENCE_TIME rtSegmentLength;
						m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtSegmentLength, &rtSegmentLength ); 

						// Check if there are any items to paste
						if( !list.IsEmpty() )
						{
							long lMeasure, lBeat, lGrid, lTick;

							// Unselect all items so the only selected items are the dropped or pasted ones
							UnselectAll();

							// Make sure the last item lands in the last beat or sooner
							VARIANT varLength;
							if( SUCCEEDED( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
							{
								mtSegmentLength = V_I4(&varLength);
								m_pTrackMgr->ClocksToUnknownTime( mtSegmentLength, &rtSegmentLength );
	
								// Make sure the last item lands in the last beat or sooner
								REFERENCE_TIME rtTimeLastItem = list.GetTail()->m_rtTimePhysical + rtPasteTime;
								if( rtTimeLastItem >= rtSegmentLength )
								{
									m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( rtPasteTime - (rtTimeLastItem - rtSegmentLength),
																				  &lMeasure, &lBeat, &lGrid, &lTick );
									m_pTrackMgr->MeasureBeatGridTickToUnknownTime( lMeasure, lBeat, lGrid, lTick, 
																				  &rtPasteTime );
									SnapUnknownTime( rtPasteTime, &rtPasteTime );
								}
							}
	
							// Make sure the first item lands in the first beat or later
							REFERENCE_TIME rtTimeFirstItem = list.GetHead()->m_rtTimePhysical + rtPasteTime;
							if( rtTimeFirstItem < 0 )
							{
								m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( rtPasteTime + -rtTimeFirstItem,
																			  &lMeasure, &lBeat, &lGrid, &lTick );
								m_pTrackMgr->MeasureBeatGridTickToUnknownTime( lMeasure, lBeat, lGrid, lTick, 
																			  &rtPasteTime );
								SnapUnknownTime( rtPasteTime, &rtPasteTime );
							}
	
						}

						// Check if we're doing a paste
						if( bDropNotPaste == FALSE )
						{
							// We're doing a paste, so get the paste type
							TIMELINE_PASTE_TYPE tlPasteType;
							if( FAILED( m_pTrackMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
							{
								EmptyList( list );
								hr = E_FAIL;
								goto Leave_1;
							}
	
							// Check if we're doing a paste->overwrite
							if( tlPasteType == TL_PASTE_OVERWRITE )
							{
								REFERENCE_TIME rtTimeFirstItem = list.GetHead()->m_rtTimePhysical + rtPasteTime;
	
								long lMeasureStart, lMeasureEnd;
								long lBeatStart, lBeatEnd;
								long lGrid;
								long lTick;
								m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( rtTimeFirstItem,
																			  &lMeasureStart, &lBeatStart, &lGrid, &lTick );
								m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( rtTimeFirstItem + iCopyPasteUI.m_rtPasteOverwriteRange,
																			  &lMeasureEnd, &lBeatEnd, &lGrid, &lTick );

								// Now, delete any items that fall between the first and last beats we're pasting in
								fChanged = DeleteBetweenMeasureBeats( lMeasureStart, lBeatStart, lMeasureEnd, lBeatEnd );
							}
	
						}

						// Iterate throught the list of items we loaded
						while( !list.IsEmpty() )
						{
							// Remove the head of the list
							CTrackItem* pItem = list.RemoveHead();

							// Check if the item will land before the end of the segment
							pItem->m_rtTimePhysical += rtPasteTime;
							pItem->m_rtTimePhysical  = max( 0, pItem->m_rtTimePhysical);
							if( pItem->m_rtTimePhysical < rtSegmentLength )
							{
								// Set layer  (m_nPasteLayerIndex stores the orig layer index)
								pItem->m_pLayer = CreateLayerForIndex( pItem->m_nPasteLayerIndex + nLayerPasteOffset );
								if( pItem->m_pLayer == NULL )
								{
									delete pItem;
								}
								else
								{
									// Recalc m_mtTime fields
									pItem->SetTimePhysical( pItem->m_rtTimePhysical, STP_LOGICAL_FROM_BEAT_OFFSET );
					
									// When pasted or dropped, each item is selected
									pItem->m_fSelected = TRUE;

									pItem->m_dwVariations = MapVariations( pItem->m_dwVariations, dwVariationMap );
									InsertByAscendingTime( pItem, TRUE );

									// We changed
									fChanged = TRUE;
								}
							}
							else
							{
								// Item would be pasted beyond the end of the segment - delete it
								delete pItem;
							}
						}
					}
				}
			}
Leave_1:
			pIStream->Release();
		}
	}

	// Handle CF_DLS_WAVE and CF_DMUSPROD_FILE
	else if( (pITimelineDataObject->IsClipFormatAvailable( m_cfWave ) == S_OK)
		 ||	 (pITimelineDataObject->IsClipFormatAvailable( m_cfDMUSProdFile ) == S_OK) )
	{
		IDMUSProdNode* pIDocRootNode = NULL;
		if( pITimelineDataObject->IsClipFormatAvailable( m_cfWave ) == S_OK )
		{
			IDataObject* pIDataObject;
			hr = pITimelineDataObject->Export( &pIDataObject );
			if( SUCCEEDED ( hr ) )
			{
				hr = m_pTrackMgr->m_pDMProdFramework->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode );
				pIDataObject->Release();
			}
		}
		else if( pITimelineDataObject->IsClipFormatAvailable( m_cfDMUSProdFile ) == S_OK )
		{
			// Ensure the file is open
			pIDocRootNode = EnsureFileIsOpen( pITimelineDataObject );
		}

		if( pIDocRootNode )
		{
			// Unselect all existing items in this strip so the only selected items are the dropped
			// or pasted ones
			UnselectAll();

			GUID guidNodeId;
			if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
			{
				CTrackItem* pItem = new CTrackItem( m_pTrackMgr, this );
				if( pItem == NULL )
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					pItem->m_pLayer = YPosToLayer( m_lYPos, true );
					if( pItem->m_pLayer == NULL )
					{
						hr = E_OUTOFMEMORY;
					}
					else
					{
						hr = pItem->SetFileReference( pIDocRootNode );
						if( SUCCEEDED ( hr ) )
						{
							pItem->m_fLoopedUI = pItem->m_WaveInfo.fIsLooped;

							rtSnapPasteTime = max( rtSnapPasteTime, 0 );

							hr = pItem->SetTimePhysical( rtSnapPasteTime, STP_LOGICAL_SET_DEFAULT );
							if( SUCCEEDED ( hr ) )
							{
								// When pasted or dropped, each item is selected
								pItem->m_fSelected = TRUE;

								pItem->m_dwVariations = m_StripUI.m_dwVariationBtns;
								InsertByAscendingTime( pItem, TRUE );

								// We changed
								fChanged = TRUE;
							}
						}
					}
					if( FAILED ( hr ) )
					{
						delete pItem;
					}
				}
			}

			RELEASE( pIDocRootNode );
		}
	}

	if( m_nStripIsDragDropSource )
	{
		// Drag/drop Target and Source are the same strip
		m_nStripIsDragDropSource = 2;
	}

	if( CWaveStrip::m_pIDocRootOfDragDropSource
	&&  CWaveStrip::m_pIDocRootOfDragDropSource == m_pTrackMgr->m_pIDocRootNode )
	{
		// Drag/drop Target and Source are the same file (i.e. Segment)
		CWaveStrip::m_fDragDropIntoSameDocRoot = TRUE;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::Paste

HRESULT CWaveStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that there is something to paste
	HRESULT hr;
	hr = CanPaste( pITimelineDataObject );
	if( hr != S_OK )
	{
		// Nothing to paste - return an error
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Validate our TrackMgr and Timeline pointers
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get a TimelineDataObject, if we don't already have one
	hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Convert the paste position to clocks
	long lClocks;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lClocks) ) )
	{
		return E_UNEXPECTED;
	}

	// Do the paste
	BOOL fChanged = FALSE;
	hr = PasteAt(pITimelineDataObject, lClocks, false, fChanged);

	// Check if the paste succeeded AND if something was actually pasted
	if( SUCCEEDED(hr) && fChanged )
	{
		// Update the selection regions to only include the selected items
		SelectRegionsFromSelectedItems();

		// Notify the containing segment that we did a paste operation
		m_pTrackMgr->m_nLastEdit = IDS_PASTE;
		m_pTrackMgr->OnDataChanged();

		// Redraw our strip
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Ensure the track item property page is visible
		OnShowItemProperties();

		// Refresh the track item property page
		RefreshPropertyPage();

		// Sync with DirectMusic
		m_pTrackMgr->SyncWithDirectMusic();
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::InsertItem

HRESULT CWaveStrip::InsertItem( CTrackItem* pItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTrackMgr
	&&	m_pTrackMgr->m_pTimeline )
	{
		// Unselect all items in this strip 
		UnselectAll();

		// Unselect all items in other strips
		UnselectGutterRange();

		// By default, a newly selected item is selected
		pItem->m_fSelected = TRUE;
	}

	// Insert the item into our list of items
	pItem->m_dwVariations = m_StripUI.m_dwVariationBtns;
	InsertByAscendingTime( pItem, FALSE );

	if( m_pTrackMgr
	&&	m_pTrackMgr->m_pTimeline )
	{
		// If it's not already selected, add the beat the item was inserted on
		// to the list of selected regions
		if( !CListSelectedRegion_Contains( pItem->m_rtTimePhysical ) )
		{
			CListSelectedRegion_AddRegion( m_lXPos );
		}

		// Redraw our strip
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );

		// Show the property sheet
		ShowPropertySheet();
		
		// Switch to the track item's property page
		CPropPageMgrItem::sm_nActiveTab = 0;
		OnShowItemProperties();

		// Refresh the track item property page
		RefreshPropertyPage();

		// Notify the containing segment that an insert occurred
		m_pTrackMgr->m_nLastEdit = IDS_INSERT;
		m_pTrackMgr->OnDataChanged();
	}

	// Sync changes with DirectMusic
	m_pTrackMgr->SyncWithDirectMusic();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::Insert

HRESULT CWaveStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that our timeline pointer is valid
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	if( m_StripUI.m_nStripView == SV_MINIMIZED
	||  m_StripUI.m_dwVariationBtns == 0 
	||  m_lXPos < 0 )
	{
		return E_FAIL;
	}

	// Unselect all items in this strip 
	UnselectAll();

	// Unselect all items in other strips
	UnselectGutterRange();

	// Determine clocks for snapped XPos
	REFERENCE_TIME rtSnapTime;
	if( FAILED ( SnapXPosToUnknownTime( m_lXPos, &rtSnapTime ) ) )
	{
		return E_FAIL;
	}

	// Convert the insert position to a layer
	CWaveStripLayer* pLayer = YPosToLayer( m_lYPos, true );
	if( pLayer == NULL )
	{
		return E_OUTOFMEMORY;
	}

	CTrackItem* pItem = new CTrackItem( m_pTrackMgr, this );
	if( pItem == NULL )
	{
		delete pLayer;
		return E_OUTOFMEMORY;
	}

	// Set the measure and beat the item was inserted in
	if( FAILED( pItem->SetTimePhysical( rtSnapTime, STP_LOGICAL_SET_DEFAULT ) ) )
	{
		delete pLayer;
		delete pItem;
		return E_UNEXPECTED;
	}

	// Set the layer
	pItem->m_pLayer = pLayer;

	// By default, a newly selected item is selected
	pItem->m_fSelected = TRUE;

	// Insert the item into our list of items
	pItem->m_dwVariations = m_StripUI.m_dwVariationBtns;
	InsertByAscendingTime( pItem, FALSE );

	// If it's not already selected, add the beat the item was inserted on
	// to the list of selected regions
	if( !CListSelectedRegion_Contains( pItem->m_rtTimePhysical ) )
	{
		CListSelectedRegion_AddRegion( m_lXPos );
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

	// Show the property sheet
	ShowPropertySheet();

	// Switch to the track item's property page
	CPropPageMgrItem::sm_nActiveTab = 0;
	OnShowItemProperties();

	// Refresh the track item property page
	RefreshPropertyPage();

	// Notify the containing segment that an insert occurred
	m_pTrackMgr->m_nLastEdit = IDS_INSERT;
	m_pTrackMgr->OnDataChanged();

	// No need to sync with DirectMusic - the item starts out as empty

	// Return the success/failure code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::Delete

HRESULT CWaveStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Delete all selected items
	DeleteSelectedItems();

	// Clear all selection ranges
	m_pSelectedRegions->Clear();

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	// Refresh the track item property page, if it exists
	RefreshPropertyPage();

	// Notify the containing segment that a delete operation occurred
	m_pTrackMgr->m_nLastEdit = IDS_DELETE;
	m_pTrackMgr->OnDataChanged();

	// Sync with DirectMusic
	m_pTrackMgr->SyncWithDirectMusic();

	// Return that the delete succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SelectAll

HRESULT CWaveStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTrackMgr != NULL );
	if( m_pTrackMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTrackMgr->m_pTimeline != NULL );
	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Select everything
	m_pSelectedRegions->SelectAll();

	// Update the selection state of the items
	if( SelectItemsInSelectedRegions() )
	{
		// Redraw our strip
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Ensure the track item property page is visible
		OnShowItemProperties();

		// Refresh the track item property page
		RefreshPropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CanPaste

HRESULT CWaveStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Do nothing if strip is minimized
	// Do nothing if no variations are selected
	if( m_StripUI.m_nStripView == SV_MINIMIZED
	||  m_StripUI.m_dwVariationBtns == 0 )
	{
		return S_FALSE;
	}

	// Verify that we have a valid timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Make sure the clipboard formats have been registered
	if( RegisterClipboardFormats() == FALSE )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a TimelineDataObject, if we don't already have one
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard formats
	hr = S_FALSE;

	// CF_WAVETRACK
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfWaveTrack ) == S_OK )
	{
		// If we found our clipboard format, return S_OK
		hr = S_OK;
	}
	// CF_DLS_WAVE
	else if( pITimelineDataObject->IsClipFormatAvailable( m_cfWave ) == S_OK )
	{
		IDataObject* pIDataObject;
		if( SUCCEEDED ( pITimelineDataObject->Export( &pIDataObject ) ) )
		{
			IDMUSProdNode* pIDocRootNode;
			if( SUCCEEDED ( m_pTrackMgr->m_pDMProdFramework->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode ) ) )
			{
				// Cannot drop waves from DLS Collections
				// Existence of DocRoot means this is a wave file
				hr = S_OK;

				RELEASE( pIDocRootNode );
			}

			RELEASE( pIDataObject );
		}
	}
	// CF_DMUSPROD_FILE
	else if( pITimelineDataObject->IsClipFormatAvailable( m_cfDMUSProdFile ) == S_OK )
	{
		IStream *pStream;
		if( SUCCEEDED( pITimelineDataObject->AttemptRead( m_cfDMUSProdFile, &pStream ) ) )
		{
			CFProducerFile cfProducerFile;
			if( SUCCEEDED( LoadCF_DMUSPROD_FILE( pStream, &cfProducerFile ) ) )
			{
				int nDot = cfProducerFile.strFileName.ReverseFind( _T('.') );
				if( nDot >= 0 )
				{
					CString strExt = cfProducerFile.strFileName.Right( cfProducerFile.strFileName.GetLength() - nDot );
					if( 0 == strExt.CompareNoCase( _T(".wav") )
					||	0 == strExt.CompareNoCase( _T(".wvp") ) )
					{
						// Can drop .wav and .wvp files
						hr = S_OK;
					}
				}
			}
			pStream->Release();
		}
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CanInsert

HRESULT CWaveStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Do nothing if strip is minimized
	// Do nothing if no variations are selected
	if( m_StripUI.m_nStripView == SV_MINIMIZED
	||  m_StripUI.m_dwVariationBtns == 0 )
	{
		return S_FALSE;
	}

	// Verify that we have a valid Timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the position to paste at
	long lInsertTime;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertTime) ) )
	{
		return E_UNEXPECTED;
	}

	// Check if the insert position is invalid, or if the user clicked in the function bar
	if( m_fInFunctionBarMenu
	|| (lInsertTime < 0)
	|| (m_lYPos < 0) )
	{
		// It's invalid - we can't insert
		return S_FALSE;
	}

	// Convert from a time to a pixel position
	long lPosition;
	if( FAILED( m_pTrackMgr->m_pTimeline->ClocksToPosition( lInsertTime, &lPosition ) ) )
	{
		return E_UNEXPECTED;
	}

	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED( m_pTrackMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var) ) )
	{
		return E_UNEXPECTED;
	}

	// If the position to insert is beyond the end of the segment, return S_FALSE since we can't insert there
	if( lInsertTime >= V_I4(&var) )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DragEnter

HRESULT CWaveStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_dwScrollTick = 0;

	return CBaseStrip::DragEnter( pIDataObject, grfKeyState, pt, pdwEffect );
}

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DragOver

HRESULT CWaveStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int m_nScrollArea = min( (m_nWaveHeight >> 1), 12 ); 
	int nLayerIndex = YPosToLayerIndex( pt.y );

	if( nLayerIndex < m_lstLayers.GetCount() )
	{
		if( (pt.y - VARIATION_BUTTONS_HEIGHT) < (m_StripUI.m_lVerticalScrollYPos + m_nScrollArea)
		||   pt.y > ((m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight) - m_nScrollArea) )
		{
			if( m_dwScrollTick == 0 )
			{
				m_dwScrollTick = GetTickCount() + 500;
			}
			else if( m_dwScrollTick < GetTickCount() )
			{
				if( (pt.y - VARIATION_BUTTONS_HEIGHT) < (m_StripUI.m_lVerticalScrollYPos + m_nScrollArea) )
				{
					OnVScrollFromScrollbar( SB_LINEUP, (UINT)-1 );
				}
				else
				{
					OnVScrollFromScrollbar( SB_LINEDOWN, (UINT)-1 );
				}

				m_dwScrollTick += 300;
			}
		}
		else
		{
			m_dwScrollTick = 0;
		}
	}
	else
	{
		m_dwScrollTick = 0;
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( m_pITargetDataObject == NULL )
	{
		ASSERT( FALSE ); // Shouldn't happen - CanPasteFromData will return E_POINTER.
	}

	if( nLayerIndex >= 0
	&&  nLayerIndex <= m_lstLayers.GetCount() 
	&&  CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		BOOL fCopy = FALSE;

		// Does m_pITargetDataObject contain format CF_DLS_WAVE or CF_DMUSPROD_FILE
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject )
		{
			if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfWave ) )
			||	SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfDMUSProdFile ) ) )
			{
				fCopy = TRUE;
			}
			pDataObject->Release();
		}

		// Can only copy CF_DLS_WAVE data!
		if( fCopy )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else
		{
			if( grfKeyState & MK_RBUTTON )
			{
				dwEffect = *pdwEffect;
			}
			else
			{
				if( grfKeyState & MK_CONTROL )
				{
					dwEffect = DROPEFFECT_COPY;
				}
				else
				{
					if( *pdwEffect & DROPEFFECT_COPY
					&&  *pdwEffect & DROPEFFECT_MOVE )
					{
						dwEffect = DROPEFFECT_MOVE;
					}
					else
					{
						dwEffect = *pdwEffect;
					}
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DragLeave

HRESULT CWaveStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_dwScrollTick = 0;

	return CBaseStrip::DragLeave();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::Drop

HRESULT CWaveStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	// Verify that we're passed the data object we're expecting
	if( (m_pITargetDataObject == NULL)
	||	(m_pITargetDataObject != pIDataObject) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Set default values
	*pdwEffect = DROPEFFECT_NONE;

	// Do nothing if strip is minimized
	// Do nothing if no variations are selected
	if( m_StripUI.m_nStripView == SV_MINIMIZED
	||  m_StripUI.m_dwVariationBtns == 0 )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	HRESULT hr = S_OK;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		// Try and load the arrow cursor
		HCURSOR hCursor = ::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
		if( hCursor )
		{
			// The the mouse cursor to an arrow cursor
			HCURSOR hCursorOld = ::SetCursor( hCursor );
	
			// Prepare context menu
			HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
			if( hMenu )
			{
				// Initialize the drop effect to DROPEFFECT_NONE
				m_dwDragRMenuEffect = DROPEFFECT_NONE;

				// Track right context menu for drag-drop via TrackPopupMenu
				HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );

				// Init state of menu items
				if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
				{
					::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
				}

				// Get a window to attach menu to
				HWND hwnd = GetTimelineHWND();
				if( hwnd )
				{
					// Display and track menu
	 				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, hwnd, NULL );

					// Destroy the popup menu
					::DestroyMenu( hMenu );

					// Need to process WM_COMMAND from TrackPopupMenu
					MSG msg;
					while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
					{
						if( msg.message == WM_COMMAND )
						{
							OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
						}
						else
						{
							TranslateMessage( &msg );
							DispatchMessage( &msg );
						}
					}

					// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
					m_dwOverDragEffect = m_dwDragRMenuEffect;

					// Reset the RMenu's effect to DROPEFFECT_NONE
					m_dwDragRMenuEffect = DROPEFFECT_NONE;
				}
			}

			// Reset the cursor to its previous image
			::SetCursor( hCursorOld );

			// Don't destory the hCursor, since it is a shared cursor
		}
	}

	// Check that the user didn't cancel the drag-drop operation
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Allocate a Timleine DataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pTrackMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			// Import the DataObject that was dragged
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				// Compute the time to drop at
				long lPasteTime;
				m_pTrackMgr->m_pTimeline->PositionToClocks( pt.x, &lPasteTime );
				m_lXPos = pt.x;
				m_lYPos = pt.y;

				// Actually paste the data
				BOOL fChanged = FALSE;
				hr = PasteAt( pITimelineDataObject, lPasteTime, true, fChanged );

				// Check that the paste succeeded, and that something was actually pasted
				if( SUCCEEDED ( hr ) && fChanged )
				{
					*pdwEffect = m_dwOverDragEffect;

					// Check if the target strip is different from the source strip
					if( m_nStripIsDragDropSource != 2 )
					{
						// Update the list of selected regions to include only the selected items
						SelectRegionsFromSelectedItems();

						if( CWaveStrip::m_fDragDropIntoSameDocRoot == FALSE
						||  m_dwOverDragEffect != DROPEFFECT_MOVE )
						{
							// Either we are dropping into a different file,
							// or we are doing a "copy" and there will be no change to the source strip, so....
							// Notify the containing segment that a paste operation occurred
							m_pTrackMgr->m_nLastEdit = IDS_PASTE;
							m_pTrackMgr->OnDataChanged();
						}

						// Redraw our strip
						m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
						
						// If the property sheet is visible, make it display the track item's property page
						OnShowItemProperties();

						// Update the track item's property page, if it exists
						RefreshPropertyPage();

						// Sync with DirectMusic
						m_pTrackMgr->SyncWithDirectMusic();
					}
				}
			}

			// Release our reference to the Timeline DataObject we allocated
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	// Return the success/failure code
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetData

HRESULT CWaveStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the ppData pointer
	if( ppData == NULL )
	{
		return E_POINTER;
	}

	// Validate the pPropItem pointer
	CPropTrackItem* pPropItem = (CPropTrackItem *)*ppData;
	if( pPropItem == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize pPropItem
	pPropItem->Clear();

	// Initialize the pointer to the first selected item to NULL
	CTrackItem* pFirstSelectedTrackItem = NULL;

	// Start iterating through the item list
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			if( pFirstSelectedTrackItem == NULL )
			{
				// Save a pointer to first selected item in pFirstSelectedTrackItem
				pFirstSelectedTrackItem = pItem;

				// Copy values fom the selected item to CPropTrackItem
				pPropItem->m_dwBits &= ~PROPF_MULTIPLESELECT;
				pPropItem->CopyTrackItem( pFirstSelectedTrackItem );
			}
			else
			{
				// Merge values fom the selected item with existing values in CPropTrackItem
				pPropItem->m_dwBits |= PROPF_MULTIPLESELECT;
				pPropItem->MergeTrackItem( pItem );
			}
		}
	}

	// Were any items selected?
	if( pFirstSelectedTrackItem == NULL )
	{
		// Nothing selected, so clear the passed in pointer
		*ppData = NULL;
	}

	// Return a success code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SetData

HRESULT CWaveStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the pData pointer
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Convert the passed-in pointer to a CPropTrackItem*
	CPropTrackItem* pPropItem = static_cast<CPropTrackItem*>(pData);
// TODO - Put in this ASSERT!!!	ASSERT( m_PropItem.m_dwChanged != 0 );

	BOOL fChanged = FALSE;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Store original variations
			DWORD dwOrigVariations = pItem->m_dwVariations;

			// Get pointer to the item to be updated
			CTrackItem* pTheItem;
			if( pPropItem->m_nPropertyTab == TAB_VARIATIONS
			&&  pPropItem->m_dwChanged == CHGD_VARIATIONS )
			{
				// Variations have changed so do not split into two items
				pTheItem = pItem;
			}
			else if( pItem->m_dwVariations & ~m_StripUI.m_dwVariationBtns )
			{
				// Item belongs to other variations so split it into two items
				pTheItem = new CTrackItem( m_pTrackMgr, this );
				if( pTheItem == NULL )
				{
					return E_OUTOFMEMORY;
				}
				pTheItem->Copy( pItem );
				pItem->m_dwVariations &= ~m_StripUI.m_dwVariationBtns;
				pTheItem->m_dwVariations &= m_StripUI.m_dwVariationBtns;
				InsertByAscendingTime( pTheItem, FALSE );
			}
			else
			{
				pTheItem = pItem;
			}

			BOOL fItemChanged = FALSE;

			switch( pPropItem->m_nPropertyTab )
			{
				case TAB_FILEREF:
					fItemChanged = SetData_TabFileRef( pPropItem, pTheItem );
					break;
				
				case TAB_LOOP:
					fItemChanged = SetData_TabLoop( pPropItem, pTheItem );
					break;
				
				case TAB_PERFORMANCE:
					fItemChanged = SetData_TabPerformance( pPropItem, pTheItem );
					break;

				case TAB_VARIATIONS:
					fItemChanged = SetData_TabVariations( pPropItem, pTheItem );
					break;

				default:
					ASSERT( 0 );	// Should not happen!
					break;
			}

			// Item did not change, so...
			if( fItemChanged == FALSE )
			{
				// Restore variations
				pItem->m_dwVariations = dwOrigVariations;

				// Remove pTheItem from the list
				if( pTheItem != pItem )
				{
					CTrackItem* pItemTmp;
					POSITION pos2, pos1 = m_lstTrackItems.GetHeadPosition();
					while( pos1 )
					{
						pos2 = pos1;
						pItemTmp = m_lstTrackItems.GetNext( pos1 );
						if( pItemTmp == pTheItem )
						{
							m_lstTrackItems.RemoveAt( pos2 );
							break;
						}
					}
				}
			}

			fChanged |= fItemChanged;
		}
	}

	// Always refresh the property page
	RefreshPropertyPage();

	// Check to see if one of the items changed
	if( fChanged )
	{
		// Redraw the strip
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );

		// Let our hosting editor know about the changes
		m_pTrackMgr->OnDataChanged();

		// Sync track with DirectMusic
		m_pTrackMgr->SyncWithDirectMusic();

		return S_OK;
	}

	// Nothing changed
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SetData_TabFileRef

BOOL CWaveStrip::SetData_TabFileRef( CPropTrackItem* pPropItem, CTrackItem* pItem )
{
	BOOL fChanged = FALSE;

	switch( pPropItem->m_dwChanged )
	{
		case CHGD_DOCROOT:
			if( pPropItem->m_Item.m_FileRef.pIDocRootNode != pItem->m_FileRef.pIDocRootNode )
			{
				pItem->SetFileReference( pPropItem->m_Item.m_FileRef.pIDocRootNode );
				pItem->m_fLoopedUI = pItem->m_WaveInfo.fIsLooped;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_CHANGE;
				fChanged = TRUE;
			}
			break;

		case CHGD_TIME_OR_DURATION:
			ASSERT( !(pPropItem->m_dwBits & PROPF_MULTIPLESELECT) );	// Should not happen (yet)!
			if( pPropItem->m_Item.m_rtTimePhysical != pItem->m_rtTimePhysical )
			{
				// Update the item's time
				pItem->SetTimePhysical( pPropItem->m_Item.m_rtTimePhysical, STP_LOGICAL_ADJUST );
				pItem->m_rtDuration = pPropItem->m_Item.m_rtDuration;

				// Update m_fSyncDuration flag
				REFERENCE_TIME rtActualLength;
				pItem->SourceWaveLengthToUnknownTime( m_pTrackMgr, &rtActualLength );
				pItem->m_fSyncDuration = (pItem->m_rtDuration == rtActualLength) ? TRUE : FALSE;

				// We just moved the item
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_MOVE;

				// Remove the TrackItem from the list
				CTrackItem* pItemTmp;
				POSITION pos2, pos1 = m_lstTrackItems.GetHeadPosition();
				while( pos1 )
				{
					pos2 = pos1;
					pItemTmp = m_lstTrackItems.GetNext( pos1 );
					if( pItemTmp == pItem )
					{
						m_lstTrackItems.RemoveAt( pos2 );
						break;
					}
				}

				// Re-add the item at its new position - this will overwrite any existing
				// item at this position
				InsertByAscendingTime( pItem, FALSE );

				// Clear all selections
				m_pSelectedRegions->Clear();

				// Select just the changed time of item
				CListSelectedRegion_AddRegion( pItem );
				fChanged = TRUE;
			}
			else if( pPropItem->m_Item.m_rtDuration != pItem->m_rtDuration )
			{
				pItem->m_rtDuration = pPropItem->m_Item.m_rtDuration;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_DURATION;

				// Update m_fSyncDuration flag
				REFERENCE_TIME rtActualLength;
				pItem->SourceWaveLengthToUnknownTime( m_pTrackMgr, &rtActualLength );
				pItem->m_fSyncDuration = (pItem->m_rtDuration == rtActualLength) ? TRUE : FALSE;
				fChanged = TRUE;
			}
			break;

		case CHGD_START_OFFSET:
			ASSERT( !(pPropItem->m_dwBits & PROPF_MULTIPLESELECT) );	// Should not happen (yet)!
			if( pPropItem->m_Item.m_rtStartOffset != pItem->m_rtStartOffset )
			{
				pItem->m_rtStartOffset = pPropItem->m_Item.m_rtStartOffset;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_START_OFFSET;
				// We must unload/download wave start ofset changes
				m_pTrackMgr->QueueWaveForUnload( pItem );
				m_pTrackMgr->UnloadQueuedWaves();
				m_pTrackMgr->QueueWaveForDownload( pItem );
				fChanged = TRUE;
			}
			break;

		case CHGD_LOCK_END:
			ASSERT( !(pPropItem->m_dwBits & PROPF_MULTIPLESELECT) );	// Should not happen (yet)!
			if( pPropItem->m_Item.m_fLockEndUI != pItem->m_fLockEndUI ) 
			{
				pItem->m_fLockEndUI = pPropItem->m_Item.m_fLockEndUI;
				if( pItem->m_fLockEndUI )
				{
					pItem->m_fLockLengthUI = FALSE;
				}
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_LOCK_END;
				fChanged = TRUE;
			}
			break;

		case CHGD_LOCK_LENGTH:
			ASSERT( !(pPropItem->m_dwBits & PROPF_MULTIPLESELECT) );	// Should not happen (yet)!
			if( pPropItem->m_Item.m_fLockLengthUI != pItem->m_fLockLengthUI ) 
			{
				pItem->m_fLockLengthUI = pPropItem->m_Item.m_fLockLengthUI;
				if( pItem->m_fLockLengthUI )
				{
					pItem->m_fLockEndUI = FALSE;
				}
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_LOCK_LENGTH;
				fChanged = TRUE;
			}
			break;

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SetData_TabLoop

BOOL CWaveStrip::SetData_TabLoop( CPropTrackItem* pPropItem, CTrackItem* pItem )
{
	BOOL fChanged = FALSE;

	switch( pPropItem->m_dwChanged )
	{
		case CHGD_IS_LOOPED:
			if( pPropItem->m_Item.m_fLoopedUI != pItem->m_fLoopedUI )
			{
				if( pPropItem->m_Item.m_fLoopedUI == FALSE
				&&  pItem->m_fLoopedUI == TRUE )
				{
					// Turning off loop
					// Reset duration if it is longer than the wave
					REFERENCE_TIME rtActualLength;
					pItem->SourceWaveLengthToUnknownTime( m_pTrackMgr, &rtActualLength );
					if( pItem->m_rtDuration > rtActualLength )
					{
						pItem->m_rtDuration = rtActualLength;
						pItem->m_fSyncDuration = TRUE;
					}
				}
				pItem->m_fLoopedUI = pPropItem->m_Item.m_fLoopedUI;
				pItem->m_dwLoopStartUI = pPropItem->m_Item.m_dwLoopStartUI;
				pItem->m_dwLoopEndUI = pPropItem->m_Item.m_dwLoopEndUI;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_LOOP;
				fChanged = TRUE;
			}
			break;

		case CHGD_LOOP:
			ASSERT( !(pPropItem->m_dwBits & PROPF_MULTIPLESELECT) );	// Should not happen (yet)!
			if( pPropItem->m_Item.m_dwLoopStartUI != pItem->m_dwLoopStartUI 
			||  pPropItem->m_Item.m_dwLoopEndUI != pItem->m_dwLoopEndUI )
			{
				pItem->m_fLoopedUI = pPropItem->m_Item.m_fLoopedUI;
				pItem->m_dwLoopStartUI = pPropItem->m_Item.m_dwLoopStartUI;
				pItem->m_dwLoopEndUI = pPropItem->m_Item.m_dwLoopEndUI;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_LOOP;
				fChanged = TRUE;
			}
			break;

		case CHGD_LOOP_LOCK_LENGTH:
			ASSERT( !(pPropItem->m_dwBits & PROPF_MULTIPLESELECT) );	// Should not happen (yet)!
			if( pPropItem->m_Item.m_fLockLoopLengthUI != pItem->m_fLockLoopLengthUI ) 
			{
				pItem->m_fLockLoopLengthUI = pPropItem->m_Item.m_fLockLoopLengthUI;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_LOCK_LOOP_LENGTH;
				fChanged = TRUE;
			}
			break;

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SetData_TabPerformance

BOOL CWaveStrip::SetData_TabPerformance( CPropTrackItem* pPropItem, CTrackItem* pItem )
{
	BOOL fChanged = FALSE;

	switch( pPropItem->m_dwChanged )
	{
		case CHGD_VOLUME:
			if( pItem->m_lVolume != pPropItem->m_Item.m_lVolume )
			{
				pItem->m_lVolume = pPropItem->m_Item.m_lVolume;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_VOLUME;
				fChanged = TRUE;
			}
			break;
		
		case CHGD_PITCH:
			if( pItem->m_lPitch != pPropItem->m_Item.m_lPitch )
			{
				pItem->m_lPitch = pPropItem->m_Item.m_lPitch;
				// Changing fine tune will change durations
				// Call GetWaveInfo() to force recalc of durations
//				pItem->GetWaveInfo();	
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_PITCH;
				fChanged = TRUE;
			}
			break;
		case CHGD_VOLUME_RANGE:
			if( pItem->m_lVolumeRange != pPropItem->m_Item.m_lVolumeRange )
			{
				pItem->m_lVolumeRange = pPropItem->m_Item.m_lVolumeRange;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_VOLUME_RANGE;
				fChanged = TRUE;
			}
			break;
		
		case CHGD_PITCH_RANGE:
			if( pItem->m_lPitchRange != pPropItem->m_Item.m_lPitchRange )
			{
				pItem->m_lPitchRange = pPropItem->m_Item.m_lPitchRange;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_PITCH_RANGE;
				fChanged = TRUE;
			}
			break;

		case CHGD_DM_FLAGS:
			if( pItem->m_dwFlagsDM != pPropItem->m_Item.m_dwFlagsDM )
			{
				pItem->m_dwFlagsDM = pPropItem->m_Item.m_dwFlagsDM;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_FLAGS;
				fChanged = TRUE;
			}
			break;

		case CHGD_TIME_LOGICAL:
			if( pItem->m_rtTimeLogical != pPropItem->m_Item.m_rtTimeLogical )
			{
				pItem->SetTimeLogical( pPropItem->m_Item.m_rtTimeLogical );
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_LOGICAL_TIME;
				fChanged = TRUE;
			}
			break;

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SetData_TabVariations

BOOL CWaveStrip::SetData_TabVariations( CPropTrackItem* pPropItem, CTrackItem* pItem )
{
	BOOL fChanged = FALSE;

	switch( pPropItem->m_dwChanged )
	{
		case CHGD_VARIATIONS:
			if( pItem->m_dwVariations != pPropItem->m_dwChangedVar_TabVariations )
			{
				// Previous check ensures an item's last variation is not removed
				DWORD dwNewVariations = pItem->m_dwVariations & ~pPropItem->m_dwChangedVar_TabVariations;
				dwNewVariations |= pPropItem->m_Item.m_dwVariations & pPropItem->m_dwChangedVar_TabVariations;
				if( pItem->m_dwVariations != dwNewVariations )
				{
					pItem->m_dwVariations = dwNewVariations;
					m_pTrackMgr->m_nLastEdit = IDS_UNDO_VARIATIONS;
					fChanged = TRUE;
				}
			}
			break;

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnShowProperties

HRESULT STDMETHODCALLTYPE CWaveStrip::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL 
	||  m_pTrackMgr->m_pDMProdFramework == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	if( m_fShowItemProps == FALSE )
	{
		OnShowStripProperties();
		return S_OK;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	m_pTrackMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If item property page manager already in propsheet, refresh and exit
	if( pIPropSheet->IsEqualPageManagerObject( (IDMUSProdPropPageObject*)this ) == S_OK )
	{
		ASSERT( m_pPropPageMgr != NULL );
		RefreshPropertyPage();
		pIPropSheet->Release();
		return S_OK;
	}

	// release our reference to the property sheet
	pIPropSheet->Release();

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		// Create a new "item" property page manager
		CPropPageMgrItem* pPPM = new CPropPageMgrItem( m_pTrackMgr->m_pDMProdFramework, m_pTrackMgr );

		// Verify that we're not out of memory
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Get the IDMUSProdPropPageManager interface from the property page
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Release the reference created by the contructor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		// If we failed, return a failure code
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Store the last active tab
	short nActiveTab = CPropPageMgrItem::sm_nActiveTab;

	// Set the displayed property page to our property page
	m_pTrackMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Set the active tab
	if( SUCCEEDED ( m_pTrackMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		CWnd* pWndHadFocus = CWnd::GetFocus();

		pIPropSheet->SetActivePage( nActiveTab ); 
		RELEASE( pIPropSheet );

		if( pWndHadFocus )
		{
			pWndHadFocus->SetFocus();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CWaveStrip::OnRemoveFromPageManager( void )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CanPasteFromData

HRESULT CWaveStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	// Do nothing if strip is minimized
	// Do nothing if no variations are selected
	if( m_StripUI.m_nStripView == SV_MINIMIZED
	||  m_StripUI.m_dwVariationBtns == 0 )
	{
		return S_FALSE;
	}

	// Check that we're passed a valid IDataObject pointer
	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Get a Timeline DataObject that encapsulates the pIDataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject = NULL;
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline, pIDataObject );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard formats
	hr = S_FALSE;

	// CF_WAVETRACK
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfWaveTrack ) == S_OK )
	{
		// If we found our clipboard format, return S_OK
		hr = S_OK;
	}
	// CF_DLS_WAVE
	else if( pITimelineDataObject->IsClipFormatAvailable( m_cfWave ) == S_OK )
	{
		IDataObject* pIDataObject;
		if( SUCCEEDED ( pITimelineDataObject->Export( &pIDataObject ) ) )
		{
			IDMUSProdNode* pIDocRootNode;
			if( SUCCEEDED ( m_pTrackMgr->m_pDMProdFramework->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode ) ) )
			{
				// Cannot drop waves from DLS Collections
				// Existence of DocRoot means this is a wave file
				hr = S_OK;

				RELEASE( pIDocRootNode );
			}

			RELEASE( pIDataObject );
		}
	}
	// CF_DMUSPROD_FILE
	else if( pITimelineDataObject->IsClipFormatAvailable( m_cfDMUSProdFile ) == S_OK )
	{
		IStream *pStream;
		if( SUCCEEDED( pITimelineDataObject->AttemptRead( m_cfDMUSProdFile, &pStream ) ) )
		{
			CFProducerFile cfProducerFile;
			if( SUCCEEDED( LoadCF_DMUSPROD_FILE( pStream, &cfProducerFile ) ) )
			{
				int nDot = cfProducerFile.strFileName.ReverseFind( _T('.') );
				if( nDot >= 0 )
				{
					CString strExt = cfProducerFile.strFileName.Right( cfProducerFile.strFileName.GetLength() - nDot );
					if( 0 == strExt.CompareNoCase( _T(".wav") )
					||	0 == strExt.CompareNoCase( _T(".wvp") ) )
					{
						// Can drop .wav and .wvp files
						hr = S_OK;
					}
				}
			}
			pStream->Release();
		}
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::XYPosToVariation

int	CWaveStrip::XYPosToVariation( long lXPos, long lYPos )
{
	int nVariation = -1;

	lXPos -= VARIATION_GUTTER_WIDTH;

	if( lXPos > 0
	&&  lXPos < VARIATION_BUTTONS_WIDTH
	&&  lYPos > 0
	&&  lYPos < VARIATION_BUTTONS_HEIGHT )
	{
		nVariation = lXPos / VARIATION_BUTTON_WIDTH;

		if( (lYPos / VARIATION_BUTTON_HEIGHT) > 0 )
		{
			nVariation += 16;
		}

		if( nVariation < 0
		||  nVariation > 31 )
		{
			ASSERT( 0 );
			nVariation = -1;
		}
	}

	return nVariation;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonDblClkVarBtns

HRESULT CWaveStrip::OnLButtonDblClkVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);

	// Handle gutter
	if( lXPos <= VARIATION_GUTTER_WIDTH )
	{
		return OnLButtonDownVarBtns( wParam, lParam, lXPos, lYPos );
	}

	// Handle variation buttons
	else
	{
		int nVariation = XYPosToVariation( lXPos, lYPos );
		if( nVariation != -1 )
		{
			// Go through soloing logic
			if( m_fVarSolo )
			{
				m_fVarSolo = FALSE;
				m_StripUI.m_dwVariationBtns = m_StripUI.m_dwOldVariationBtns;
			}
			else
			{
				m_fVarSolo = TRUE;
				m_nSoloVariation = nVariation;
				m_StripUI.m_dwVariationBtns ^= 1 << m_nSoloVariation;
				m_StripUI.m_dwOldVariationBtns = m_StripUI.m_dwVariationBtns;
				m_StripUI.m_dwVariationBtns = 1 << m_nSoloVariation;
			}

			// See if we have to pop up the gutter
			if( (m_StripUI.m_dwVariationBtns & m_dwVariationsMask) == m_dwVariationsMask )
			{
				m_StripUI.m_fVarGutterDown = TRUE;
			}
			else
			{
				m_StripUI.m_fVarGutterDown = FALSE;
			}

			// Redraw our strip
			m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

			// Notify the containing segment that we changed
			m_pTrackMgr->m_nLastEdit = IDS_UNDO_SET_VARIATIONS;
			m_pTrackMgr->OnDataChanged();
			m_pTrackMgr->SetAuditionVariations( false );

			// Update the selection regions to include the selected items
			SelectRegionsFromSelectedItems();

			// If visible, switch the property sheet to the track item property page
			OnShowItemProperties();

			// If it exists, refresh the track item property page
			RefreshPropertyPage();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonDownVarBtns

HRESULT CWaveStrip::OnLButtonDownVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);

	// Handle gutter
	if( lXPos <= VARIATION_GUTTER_WIDTH )
	{
		m_StripUI.m_fVarGutterDown = !m_StripUI.m_fVarGutterDown;

		DWORD dwOrigVariations = m_StripUI.m_dwVariationBtns;
		if( m_StripUI.m_fVarGutterDown )
		{
			// Select all active variations
			m_StripUI.m_dwVariationBtns |= m_dwVariationsMask;
		}
		else
		{
			// Deselect all active variations
			m_StripUI.m_dwVariationBtns &= ~m_dwVariationsMask;
		}

		InvalidateVariationBtns();
		
		if( m_StripUI.m_dwVariationBtns != dwOrigVariations )
		{
			InvalidateWaves();

			// Notify the containing segment that we changed
			m_pTrackMgr->m_nLastEdit = IDS_UNDO_SET_VARIATIONS;
			m_pTrackMgr->OnDataChanged();
			m_pTrackMgr->SetAuditionVariations( false );

			// Update the selection regions to include the selected items
			SelectRegionsFromSelectedItems();

			// If visible, switch the property sheet to the track item property page
			OnShowItemProperties();

			// If it exists, refresh the track item property page
			RefreshPropertyPage();
		}
	}

	// Handle variation buttons
	else
	{
		int nVariation = XYPosToVariation( lXPos, lYPos );
		if( nVariation != -1 )
		{
			m_nLastVariation = nVariation;
			if( m_nLastVariation != m_nSoloVariation )
			{
				m_fVarSolo = FALSE;
			}

			// Toggle variation button
			m_StripUI.m_dwVariationBtns ^= (1 << m_nLastVariation);

			// If button is down we are enabling
			if( (1 << m_nLastVariation) & m_StripUI.m_dwVariationBtns )
			{
				m_nVarAction = VA_ENABLING;
			}
			else
			{
				m_nVarAction = VA_DISABLING;
			}

			// See if we need to pop up gutter
			if( (m_StripUI.m_dwVariationBtns & m_dwVariationsMask) == m_dwVariationsMask )
			{
				m_StripUI.m_fVarGutterDown = true;
			}
			else
			{
				m_StripUI.m_fVarGutterDown = false;
			}

			// Redraw our strip
			m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

			// Update the selection regions to include the selected items
			SelectRegionsFromSelectedItems();

			// If visible, switch the property sheet to the track item property page
			OnShowItemProperties();

			// If it exists, refresh the track item property page
			RefreshPropertyPage();

			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonDownZoomBtns

HRESULT CWaveStrip::OnLButtonDownZoomBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);

	// Capture the mouse
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Set the zoom timer
	HWND hwnd = GetTimelineHWND();
	if( hwnd )
	{
		::SetTimer( hwnd, TIMER_ZOOM_1, 400, NULL );
	}

	// Change the zoom factor
	if( lYPos <= m_StripUI.m_lVerticalScrollYPos + sm_nZoomBtnHeight )
	{
		m_fZoomInDown = true;
		InvalidateFBar();  
		SetZoom( m_StripUI.m_dblVerticalZoom + 0.01 );
	}
	else
	{
		m_fZoomOutDown = true;
		InvalidateFBar();  
		if( m_StripUI.m_dblVerticalZoom > MINIMUM_ZOOM_LEVEL )
		{
			SetZoom( m_StripUI.m_dblVerticalZoom - 0.01 );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonDownLayerBtns

HRESULT CWaveStrip::OnLButtonDownLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	// Capture the mouse
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	CWaveStripLayer* pLayer = YPosToLayer( lYPos, false );
	if( pLayer == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Check if the shift key is pressed
	if( wParam & MK_SHIFT )
	{
		UnselectAll();

		// Figure out range
		int nStartIndex;
		int nEndIndex;
		if( m_pLayerForShiftClick == NULL )
		{
			nStartIndex = 0;
		}
		else
		{
			nStartIndex = LayerToIndex( m_pLayerForShiftClick );
		}
		nEndIndex = LayerToIndex( pLayer );
		if( nStartIndex > nEndIndex )
		{
			int nTempIndex = nStartIndex;
			nStartIndex = nEndIndex;
			nEndIndex = nTempIndex;
		}

		// Select layers in range
		POSITION pos = m_lstLayers.FindIndex( nStartIndex );
		while( pos )
		{
			CWaveStripLayer* pLayerList = m_lstLayers.GetNext( pos );

			pLayerList->m_fSelected = TRUE;
			m_fLayerSelected = pLayerList->m_fSelected;

			// Select/unselect waves in this layer
			SelectLayer( pLayerList );

			if( ++nStartIndex > nEndIndex )
			{
				break;
			}
		}
	}
	else
	{
		// Check if the control key is down
		if( wParam & MK_CONTROL )
		{
			pLayer->m_fSelected = !pLayer->m_fSelected;
			m_fLayerSelected = pLayer->m_fSelected;

			// Select/unselect waves in this layer
			SelectLayer( pLayer );
		}
		// No control key (works same as control key path, however)
		else 
		{
			pLayer->m_fSelected = !pLayer->m_fSelected;
			m_fLayerSelected = pLayer->m_fSelected;

			// Select/unselect waves in this layer
			SelectLayer( pLayer );
		}

		// Set anchor for future shift-select operations
		m_pLayerForShiftClick = pLayer;
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Switch the property page to the track item's property page
	OnShowItemProperties();

	// Refresh the property page, if it exists
	RefreshPropertyPage();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonDown

HRESULT CWaveStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lParam);

	// Validate our timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Initialize the item to toggle to NULL
	m_pItemToToggle = NULL;
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Check if the shift key is pressed
	if( wParam & MK_SHIFT )
	{
		CListSelectedRegion_ShiftAddRegion( lXPos );
		SelectItemsInSelectedRegions();
	}
	else
	{
		// See if there is an item under the cursor.
		CTrackItem* pItem = GetItemFromPoint( lXPos, lYPos );
		if( pItem )
		{
			// Found an item under the cursor

			// Check if the control key is down
			if( wParam & MK_CONTROL )
			{
				// Check if the item is not yet selected
				if( pItem->m_fSelected )
				{
					// Set up to unselect this item later, either when we receive a
					// left-button up, or when the user completes a drag-drop operation
					// that does nothing.
					m_pItemToToggle = pItem;
				}
				else
				{
					// Mark the clicked on item as selected
					pItem->m_fSelected = TRUE;
					CListSelectedRegion_AddRegion( lXPos );
				}
			}
			// Check if the item is unselected (the shift key is up)
			else if( !pItem->m_fSelected )
			{
				// Mark the clicked on item as selected
				UnselectAll();
				pItem->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedItems();
			}
		}
		// Didn't find an item - check if the Ctrl key is down
		else if( wParam & MK_CONTROL )
		{
			// Toggle the selection state in the region under the cursor
			CListSelectedRegion_ToggleRegion( lXPos );
		}
		// The shift key is up
		else
		{
			// The user left-clicked on blank space without holding the shift or Ctrl keys down

			// Clear all selection regions
			m_pSelectedRegions->Clear();
			UnselectAll();

			// Select only the beat clicked on
			CListSelectedRegion_AddRegion( lXPos );
		}

		// Set anchor for future shift-select operations
		m_pSelectedRegions->SetShiftSelectAnchor( lXPos );
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Switch the property page to the track item's property page
	OnShowItemProperties();

	// Refresh the property page, if it exists
	RefreshPropertyPage();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonUpVarBtns

HRESULT CWaveStrip::OnLButtonUpVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Notify the containing segment that we changed
	if( m_nVarAction == VA_ENABLING
	||  m_nVarAction == VA_DISABLING )
	{
		m_pTrackMgr->m_nLastEdit = IDS_UNDO_SET_VARIATIONS;
		m_pTrackMgr->OnDataChanged();
		m_pTrackMgr->SetAuditionVariations( false );
	}

	// Reset flags
	m_nLastVariation = -1;
	m_nVarAction = VA_NONE;

	// Release mouse capture
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonUpZoomBtns

HRESULT CWaveStrip::OnLButtonUpZoomBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Notify the containing segment that we changed
// TODO - Do we need this?
//	m_pTrackMgr->m_nLastEdit = IDS_UNDO_SET_VARIATIONS;
//	m_pTrackMgr->OnDataChanged();

	// Release mouse capture
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Kill the zoom timer
	HWND hwnd = GetTimelineHWND();
	if( hwnd )
	{
		::KillTimer( hwnd, TIMER_ZOOM_1 );
		::KillTimer( hwnd, TIMER_ZOOM_2 );
	}

	// Reset button state flags
	m_fZoomInDown = false;
	m_fZoomOutDown = false;

	// Redraw function bar area
	InvalidateFBar();  

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonUpLayerBtns

HRESULT CWaveStrip::OnLButtonUpLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Release mouse capture
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Kill the vertical scroll timer
	HWND hwnd = GetTimelineHWND();
	if( hwnd )
	{
		::KillTimer( hwnd, TIMER_VSCROLL_LAYER_1 );
		::KillTimer( hwnd, TIMER_VSCROLL_LAYER_2 );
		m_nVerticalScrollTimer = 0;
	}

	// Redraw function bar area
	InvalidateFBar();  

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnLButtonUp

HRESULT CWaveStrip::OnLButtonUp( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lParam);

	// Check if the Ctrl key was pressed
	if( wParam & MK_CONTROL )
	{
		// Ctrl key pressed - toggle the selection state of the item that was clicked on
		if( m_pItemToToggle )
		{
			m_pItemToToggle->m_fSelected = !m_pItemToToggle->m_fSelected;
			m_pItemToToggle = NULL;

			// Update the selection regions to include just this selected item
			SelectRegionsFromSelectedItems();
		}
	}
	// Check if the Shift key was not pressed
	else if( !(wParam & MK_SHIFT) )
	{
		// Look for an item at the position clicked on
		CTrackItem* pItem = GetItemFromPoint( lXPos, lYPos );
		if(pItem)
		{
			// Found an item
			// Unselect all items
			UnselectAll();

			// Mark the clicked on item as selected
			pItem->m_fSelected = TRUE;

			// Update the selection regions to include just this selected item
			SelectRegionsFromSelectedItems();
		}
	}


	// Ensure all other strips are unselected
	UnselectGutterRange();

	// Redraw ourself
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Refresh the track item property page, if it exists
	RefreshPropertyPage();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnRButtonDownVarBtns

HRESULT CWaveStrip::OnRButtonDownVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnRButtonDownLayerBtns

HRESULT CWaveStrip::OnRButtonDownLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	CWaveStripLayer* pLayer = YPosToLayer( lYPos, false );
	if( pLayer == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Check if the item is unselected (the shift key is up)
	if( pLayer->m_fSelected == FALSE )
	{
		UnselectAll();

		pLayer->m_fSelected = TRUE;
		m_fLayerSelected = pLayer->m_fSelected;

		// Select/unselect waves in this layer
		SelectLayer( pLayer );

		// Redraw our strip
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

		// Switch the property page to the track item's property page
		OnShowItemProperties();

		// Refresh the property page, if it exists
		RefreshPropertyPage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnRButtonDown

HRESULT CWaveStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lParam);
	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	// Unselect all items in the other strips
	UnselectGutterRange();

	// Get the item at the mouse click.
	CTrackItem* pItem = GetItemFromPoint( lXPos, lYPos );

	if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		// Neither control or shift were pressed

		// Check if an item was clicked on
		if( pItem )
		{
			// Check if the item is selected
			if( pItem->m_fSelected == FALSE )
			{
				// Item is not selected, unselect all items
				UnselectAll();

				// Select just this item
				pItem->m_fSelected = TRUE;

				// Add just this beat to the list of selected regions
				CListSelectedRegion_AddRegion( lXPos );
			}
			// If the item was already selected, do nothing
		}
		else
		{
			// if region not selected, select it, otherwise do nothing

			// Convert the pixel position to a measure and beat
			REFERENCE_TIME rtSnapTime;
			if( SUCCEEDED ( SnapXPosToUnknownTime( lXPos, &rtSnapTime ) ) )
			{
				// Check if this beat is not already selected
				if( !CListSelectedRegion_Contains(rtSnapTime))
				{
					// This beat is not selected - unselect all beats
					UnselectAll();

					// Now, select just this beat
					CListSelectedRegion_AddRegion( lXPos );
				}
			}
		}
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Switch the property page to the track item's property page
	OnShowItemProperties();

	// Refresh the  property page, if it exists
	RefreshPropertyPage();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnRButtonUpVarBtns

HRESULT CWaveStrip::OnRButtonUpVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lYPos);

	// Validate our timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	if( (lXPos > VARIATION_GUTTER_WIDTH)
	&&  (lXPos < VARIATION_GUTTER_WIDTH + VARIATION_BUTTONS_WIDTH) )
	{
		// Get the cursor position (To put the menu there)
		POINT pt;
		BOOL bResult = GetCursorPos( &pt );
		ASSERT( bResult );
		if( bResult == FALSE )
		{
			return E_UNEXPECTED;
		}

		HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_VARBTNS_RMENU) );
		if( hMenu == NULL )
		{
			return E_UNEXPECTED;
		}

		HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
		if( hMenuPopup == NULL )
		{
			return E_UNEXPECTED;
		}

		m_pTrackMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );

		::DestroyMenu( hMenu );	// This will destroy the submenu as well.
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnRButtonUpLayerBtns

HRESULT CWaveStrip::OnRButtonUpLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Validate our timeline pointer
	if( (m_pTrackMgr == NULL)
	||	(m_pTrackMgr->m_pTimeline == NULL) )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Get the cursor position (To put the menu there)
	POINT pt;
	BOOL bResult = GetCursorPos( &pt );
	ASSERT( bResult );
	if( bResult == FALSE )
	{
		return E_UNEXPECTED;
	}

	HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_LAYERBTNS_RMENU) );
	if( hMenu == NULL )
	{
		return E_UNEXPECTED;
	}

	HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
	if( hMenuPopup == NULL )
	{
		return E_UNEXPECTED;
	}

	::EnableMenuItem( hMenuPopup, IDM_DELETE_LAYERS, ( CanDeleteLayers() == S_OK ) ? MF_ENABLED : MF_GRAYED );
	m_pTrackMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );

	::DestroyMenu( hMenu );	// This will destroy the submenu as well.

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnMouseMoveVarBtns

HRESULT CWaveStrip::OnMouseMoveVarBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);

	if( m_nVarAction == VA_ENABLING
	||  m_nVarAction == VA_DISABLING )
	{
		int nVariation = XYPosToVariation( lXPos, lYPos );
		if( nVariation != -1 )
		{
			m_nLastVariation = nVariation;
			if( m_nVarAction == VA_ENABLING )
			{
				m_StripUI.m_dwVariationBtns |= 1 << m_nLastVariation;
			}
			else
			{
				m_StripUI.m_dwVariationBtns &= ~(1 << m_nLastVariation);
			}

			if( (m_StripUI.m_dwVariationBtns & m_dwVariationsMask) == m_dwVariationsMask )
			{
				m_StripUI.m_fVarGutterDown = true;
			}
			else
			{
				m_StripUI.m_fVarGutterDown = false;
			}

			// Redraw our strip
			m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

			// Update the selection regions to include the selected items
			SelectRegionsFromSelectedItems();

			// If visible, switch the property sheet to the track item property page
			OnShowItemProperties();

			// If it exists, refresh the track item property page
			RefreshPropertyPage();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnMouseMoveLayerBtns

HRESULT CWaveStrip::OnMouseMoveLayerBtns( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);

	// Set the vertical scroll timer
	if( (lYPos - VARIATION_BUTTONS_HEIGHT) < m_StripUI.m_lVerticalScrollYPos 
	||  lYPos > (m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight) )
	{
		if( m_nVerticalScrollTimer == 0 )
		{
			HWND hwnd = GetTimelineHWND();
			if( hwnd )
			{
				::SetTimer( hwnd, TIMER_VSCROLL_LAYER_1, 400, NULL );
				m_nVerticalScrollTimer = TIMER_VSCROLL_LAYER_1;
			}
		}

		return S_OK;
	}

	// Kill the vertical scroll timer
	HWND hwnd = GetTimelineHWND();
	if( hwnd )
	{
		::KillTimer( hwnd, TIMER_VSCROLL_LAYER_1 );
		::KillTimer( hwnd, TIMER_VSCROLL_LAYER_2 );
		m_nVerticalScrollTimer = 0;
	}

	// Select the layer button
	CWaveStripLayer* pLayer = YPosToLayer( lYPos, false );
	if( pLayer )
	{
		if( pLayer->m_fSelected != m_fLayerSelected )
		{
			pLayer->m_fSelected = m_fLayerSelected;

			// Select/unselect waves in this layer
			if( SelectLayer(pLayer) )
			{
				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedItems();

				// Redraw our strip
				m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
			}
			else
			{
				// Redraw function bar area
				InvalidateFBar();  
			}
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnMouseMove

HRESULT CWaveStrip::OnMouseMove( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	HRESULT hr = S_OK;

	// Check if the left mouse button is down
	if( m_fLeftMouseDown )
	{
		// The user moved the mouse while the left mouse button was down -
		// do a drag-drop operation.
		hr = DoDragDrop( m_pTrackMgr->m_pTimeline, wParam, m_lXPos, m_lYPos );

		// The above method returns after a drop, or after the user
		// cancels the operation.  In either case, we don't want to do
		// a drag-drop operation again.
		m_fLeftMouseDown = false;

		// If the drag-drop operatoin didn't complete
		if( hr != S_OK || m_dwDropEffect == DROPEFFECT_NONE )
		{
			// Store the position that the drag started at, because drag drop eats mouse up
			m_lXPos = lXPos;
			m_lYPos = lYPos;

			// Check if the control key was down
			if( wParam & MK_CONTROL )
			{
				// Finish the toggle operation on the item that was clicked on
				// when the left mouse button was pressed.
				if( m_pItemToToggle )
				{
					m_pItemToToggle->m_fSelected = !m_pItemToToggle->m_fSelected;
					m_pItemToToggle = NULL;

					// Update the selection regions to include just this selected item
					SelectRegionsFromSelectedItems();
				}
			}
			// Check if the shift key was not down
			else if( !(wParam & MK_SHIFT) )
			{
				// If an item was clicked on
				if(GetItemFromPoint( lXPos, lYPos ))
				{
					// Update the selection regions to include only the selected items
					SelectRegionsFromSelectedItems();
				}
			}

			// Redraw the strip
			m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

			// Switch the property page to the track item property page
			OnShowItemProperties();
		}
		else
		{
			// successful drag drop--make sure that only the regions with
			// selected items are selected
			SelectRegionsFromSelectedItems();
		}

		// Refresh the track item property page, if it exists
		RefreshPropertyPage();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnChar

HRESULT CWaveStrip::OnChar( WPARAM wParam )
{
	if( m_StripUI.m_nStripView == SV_NORMAL )
	{
		if( (wParam == 'a')
		||  (wParam == 'A') )
		{
			SetZoom( m_StripUI.m_dblVerticalZoom + 0.01);
		}
		else if( (wParam == 'z')
			 ||  (wParam == 'Z') )
		{
			if( m_StripUI.m_dblVerticalZoom > MINIMUM_ZOOM_LEVEL )
			{
				SetZoom( m_StripUI.m_dblVerticalZoom - 0.01);
			}
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::PostRightClickMenu

HRESULT CWaveStrip::PostRightClickMenu( POINT pt )
{
	m_fInRightClickMenu = TRUE;

	// Load menu
	HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

	// Initialize menu
	::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
			MF_GRAYED | MF_BYPOSITION );
	::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( IsEmpty() ) ? MF_GRAYED :
			MF_ENABLED );
	::EnableMenuItem( hMenuPopup, IDM_MERGE_VARIATIONS,  m_StripUI.m_dwVariationBtns ? MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, IDM_ZOOM_IN, ( m_StripUI.m_nStripView == SV_NORMAL ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, IDM_ZOOM_OUT, ( m_StripUI.m_nStripView == SV_NORMAL ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );

	// Initialize 'Snap To' popup menu
	HMENU hMenuPopupSnapTo = ::GetSubMenu( hMenuPopup, 8 );	// 8 is index of 'Snap To' popup menu
	ASSERT( hMenuPopupSnapTo != NULL );
	if( hMenuPopupSnapTo )
	{
		CString strMenuText;
		if( m_pTrackMgr->IsRefTimeTrack() )
		{
			strMenuText.LoadString( IDS_SECOND_TEXT );
			::InsertMenu( hMenuPopupSnapTo, 2, MF_BYPOSITION | MF_STRING, IDM_SNAP_SECOND, strMenuText ); 
			::InsertMenu( hMenuPopupSnapTo, 3, MF_BYPOSITION | MF_SEPARATOR, 0, NULL ); 
			strMenuText.LoadString( IDS_SET_GRID_TEXT );
			::InsertMenu( hMenuPopupSnapTo, 4, MF_BYPOSITION | MF_STRING, IDM_SNAP_SET_GRID, strMenuText ); 

			::CheckMenuItem( hMenuPopupSnapTo, IDM_SNAP_NONE,
				(m_StripUI.m_nSnapToRefTime == IDM_SNAP_NONE) ? MF_CHECKED : MF_UNCHECKED );
			::CheckMenuItem( hMenuPopupSnapTo, IDM_SNAP_GRID,
				(m_StripUI.m_nSnapToRefTime == IDM_SNAP_GRID) ? MF_CHECKED : MF_UNCHECKED );
			::CheckMenuItem( hMenuPopupSnapTo, IDM_SNAP_SECOND,
				(m_StripUI.m_nSnapToRefTime == IDM_SNAP_SECOND) ? MF_CHECKED : MF_UNCHECKED );
		}
		else
		{
			strMenuText.LoadString( IDS_BEAT_MENU_TEXT );
			::InsertMenu( hMenuPopupSnapTo, 2, MF_BYPOSITION | MF_STRING, IDM_SNAP_BEAT, strMenuText ); 
			strMenuText.LoadString( IDS_BAR_MENU_TEXT );
			::InsertMenu( hMenuPopupSnapTo, 3, MF_BYPOSITION | MF_STRING, IDM_SNAP_BAR, strMenuText ); 

			::CheckMenuItem( hMenuPopupSnapTo, IDM_SNAP_NONE,
				(m_StripUI.m_nSnapToMusicTime == IDM_SNAP_NONE) ? MF_CHECKED : MF_UNCHECKED );
			::CheckMenuItem( hMenuPopupSnapTo, IDM_SNAP_GRID,
				(m_StripUI.m_nSnapToMusicTime == IDM_SNAP_GRID) ? MF_CHECKED : MF_UNCHECKED );
			::CheckMenuItem( hMenuPopupSnapTo, IDM_SNAP_BEAT,
				(m_StripUI.m_nSnapToMusicTime == IDM_SNAP_BEAT) ? MF_CHECKED : MF_UNCHECKED );
			::CheckMenuItem( hMenuPopupSnapTo, IDM_SNAP_BAR,
				(m_StripUI.m_nSnapToMusicTime == IDM_SNAP_BAR) ? MF_CHECKED : MF_UNCHECKED );
		}
	}

	m_pTrackMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
	::DestroyMenu( hMenu );

	m_fInRightClickMenu = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::UnselectGutterRange

void CWaveStrip::UnselectGutterRange( void )
{
	// Make sure everything on the timeline is deselected.

	// Flag that we're unselecting all other strips
	m_fSelecting = TRUE;

	// Set the begin and end selection time to 0
	m_pTrackMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pTrackMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );

	// Flags that we're no longer unselecting all other strips
	m_fSelecting = FALSE;
}


// IDropSource helpers

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CreateDataObject

HRESULT	CWaveStrip::CreateDataObject( IDataObject** ppIDataObject, long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we're passed a valid location to store the IDataObject pointer in
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the IDataObject pointer to NULL
	*ppIDataObject = NULL;

	// Allocate a Timleine DataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject;
	if( FAILED( m_pTrackMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
	{
		return E_OUTOFMEMORY;
	}

	// Save Selected items into stream
	HRESULT hr = E_FAIL;

	// Allocate a memory stream
	IStream* pIStream;
	if( SUCCEEDED ( m_pTrackMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		REFERENCE_TIME rtOffset = 0;

		// Get the item at the drag point
		CTrackItem* pItemAtDragPoint = GetItemFromPoint( lXPos, lYPos );
		if( pItemAtDragPoint == NULL )
		{
			// If no pItemAtDragPoint use the first selected item
			pItemAtDragPoint = GetFirstSelectedItem();
		}
		ASSERT( pItemAtDragPoint->m_fSelected );

		// Compute offset
//		MUSIC_TIME mtTimeXPos;
//		m_pTrackMgr->m_pTimeline->PositionToClocks( lXPos, &mtTimeXPos );
//		m_pTrackMgr->ClocksToUnknownTime( mtTimeXPos, &rtOffset );
//		rtOffset = pItemAtDragPoint->m_rtTimePhysical - rtOffset;
		rtOffset = 0;

		// mark the items as being dragged: this used later for deleting items in drag move
		MarkSelectedItems( UD_DRAGSELECT );

		// Save the selected items into a stream
		if( SUCCEEDED ( SaveSelectedItems( pIStream, rtOffset, pItemAtDragPoint ) ) )
		{
			// Add the stream to the Timeline DataObject
			if( SUCCEEDED ( pITimelineDataObject->AddExternalClipFormat( m_cfWaveTrack, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		// Releas the stream
		pIStream->Release();
	}

	// If we were successful, export the Timeline DataObject into an IDataObject
	if( SUCCEEDED ( hr ) )
	{
		pITimelineDataObject->Export( ppIDataObject );
	}

	// Release the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DoDragDrop

HRESULT CWaveStrip::DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos, long lYPos )
{
	// Do a drag'n'drop operation

	// Get the item at the point we're dragging from
	CTrackItem* pItem = GetItemFromPoint( lXPos, lYPos );

	// Check that we found a item, and that it is selected
	if(!pItem || !pItem->m_fSelected)
	{
		// Didn't find a selected item - return that nothing happened
		return S_FALSE;
	}

	// Initialize flag that determines when a successful drop occurs
	bool fDrop = false;

	// Initialize our result code
	HRESULT hr = S_FALSE;

	// Drag-drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Initialize the drop effect to 'none'
	m_dwDropEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	IDropSource*	pIDropSource;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Ensure m_pISourceDataObject is empty
		if( m_pISourceDataObject )
		{
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}

		// Create a data object from the selected items
		hr = CreateDataObject( &m_pISourceDataObject, lXPos, lYPos );

		// Check if we successfully created a data object
		if(SUCCEEDED(hr))
		{
			// We can always copy items.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;

			// Check if we can cut items
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the items as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.

			// Initialize our DragDropSource flag to 1 (means we are the source of a drag-drop)
			m_nStripIsDragDropSource = 1;

			// Initialize our DragDropSource DocRoot fields
			CWaveStrip::m_pIDocRootOfDragDropSource = m_pTrackMgr->m_pIDocRootNode;
			CWaveStrip::m_fDragDropIntoSameDocRoot = FALSE;

			// Save the state of the mouse buttons
			m_dwStartDragButton = (unsigned long)wParam;

			// Save the position the drag started at
			// (used in PasteAt to determine if we dropped in the same beat we dragged from)
			m_lStartDragPosition = lXPos;

			// Initialize the drop effect to 'none'
			DWORD dwEffect = DROPEFFECT_NONE;

			// Actually do the drag-drop operation
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			// Check what happened during the drag-drop operation
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// A drop occurred - save the effect
				m_dwDropEffect = dwEffect;

				// Check if we did a move
				if(dwEffect & DROPEFFECT_MOVE)
				{
					// We moved some items - delete the items we marked earlier
					DeleteMarked(UD_DRAGSELECT);
				}

				// If the effect wasn't 'None', set the drop flag to true
				if(dwEffect != DROPEFFECT_NONE)
				{
					fDrop = true;
				}
				break;
			default:
				// User cancelled the operation, or dropped the items somewhere they didn't belong
				m_dwDropEffect = DROPEFFECT_NONE;
				break;
			}

			// Check if we really did a drop
			if( fDrop )
			{
				// Check if we dropped in the same strip
				if( m_nStripIsDragDropSource == 2 )
				{
					// Source and target are the same strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move - use the 'Move' undo text
						m_pTrackMgr->m_nLastEdit = IDS_UNDO_MOVE;
					}
					else
					{
						// We did a copy - use the 'Insert' undo text
						m_pTrackMgr->m_nLastEdit = IDS_INSERT;
					}

					// Notify the containing segment that we changed
					m_pTrackMgr->OnDataChanged();

					// Update the selection regions to include the selected items
					SelectRegionsFromSelectedItems();

					// If visible, switch the property sheet to the track item property page
					OnShowItemProperties();

					// If it exists, refresh the track item property page
					RefreshPropertyPage();

					// Sync with DirectMusic
					m_pTrackMgr->SyncWithDirectMusic();
				}
				else
				{
					// Target strip is different from source strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// Check if we dropped in the same segment
						if( CWaveStrip::m_fDragDropIntoSameDocRoot == TRUE )
						{
							// We did a move operation to another strip in the same segment - use the 'Move' undo text
							m_pTrackMgr->m_nLastEdit = IDS_UNDO_MOVE;
						}
						else
						{
							// We did a move operation to another strip in a different - use the 'Delete' undo text
							m_pTrackMgr->m_nLastEdit = IDS_DELETE;
						}

						// Notify the Wave Designer that we changed
						m_pTrackMgr->OnDataChanged();

						// Sync with DirectMusic
						m_pTrackMgr->SyncWithDirectMusic();
					}
					else
					{
						// Unselect all items, since the user did a copy operation
						UnselectAll();
					}
				}

				// Refresh our strip display
				m_pTrackMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

				// Return that we actually did a drop
				hr = S_OK;
			}
		}

		// Release the IDropSource interface
		pIDropSource->Release();

		// Clear the DragSelect flag from all items
		UnMarkItems(UD_DRAGSELECT); 
	}
	else
	{
		// Couldn't query for IDropSource interface - return failure code
		hr = E_FAIL;
	}

	// Clear the DragDropSource fields
	m_nStripIsDragDropSource = 0;
	CWaveStrip::m_pIDocRootOfDragDropSource = NULL;
	CWaveStrip::m_fDragDropIntoSameDocRoot = FALSE;
	
	// Return a success or failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SelectItemsInSelectedRegions

bool CWaveStrip::SelectItemsInSelectedRegions()
{
	// Flag set to true if anything changes
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if this item is within a selection region
		if( CListSelectedRegion_Contains( pItem->m_rtTimePhysical ) )
		{
			// Check if the item is not selected
			if( !pItem->m_fSelected )
			{
				// Item isn't yet selected - select it and set fChanged to true
				pItem->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the item is selected
			if( pItem->m_fSelected )
			{
				// Item is selected - deselect it and set fChagned to true
				pItem->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	// return whether or not we changed the selection state of any items
	return fChanged;
}


////////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SelectRegionsFromSelectedItems

void CWaveStrip::SelectRegionsFromSelectedItems( void )
{
	// Clear the list of selected regions
	m_pSelectedRegions->Clear();

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Add the beat the item is in to the list of selected regions.
			CListSelectedRegion_AddRegion( pItem );
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
// CWaveStrip::RegisterClipboardFormats

BOOL CWaveStrip::RegisterClipboardFormats( void )
{
	// CF_WAVETRACK
	if( m_cfWaveTrack == 0 )
	{
		m_cfWaveTrack = RegisterClipboardFormat( CF_WAVETRACK );
	}
	
	// CF_DLS_WAVE
	if( m_cfWave == 0 )
	{
		m_cfWave = RegisterClipboardFormat( CF_DLS_WAVE );
	}

	// CF_DMUSPROD_FILE
	if( m_cfDMUSProdFile == 0 )
	{
		m_cfDMUSProdFile = RegisterClipboardFormat( CF_DMUSPROD_FILE );
	}

	if( m_cfWaveTrack == 0 
	||  m_cfWave == 0
	||	m_cfDMUSProdFile == 0 )
	{ 
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::LoadList

HRESULT CWaveStrip::LoadList( CTypedPtrList<CPtrList, CTrackItem*>& list, IStream* pIStream )
{
	IDMUSProdRIFFStream* pIRiffStream;
	MMCKINFO		ck;
	MMCKINFO		ckListTrack;
	MMCKINFO		ckListItem;
	DWORD			dwByteCount;
	DWORD			dwSize;
	CString			strObjectName;
	HRESULT			hr = E_FAIL;

	// Initialize field containing state of variation buttons at time this list was created
	m_dwSourceVariationBtns = 0;

	// LoadList does not expect to be called twice on the same object!

	if( pIStream == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Load the track item
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_WAVEPART_LIST:
						while( pIRiffStream->Descend( &ckListTrack, &ck, 0 ) == 0 )
						{
							switch( ckListTrack.ckid )
							{
								case DMUS_FOURCC_WAVEPART_CHUNK:
								{
									DMUS_IO_WAVE_PART_HEADER iPartHeader;

									// Read in the item's header structure
									dwSize = min( sizeof( DMUS_IO_WAVE_PART_HEADER ), ckListTrack.cksize );
									hr = pIStream->Read( &iPartHeader, dwSize, &dwByteCount );

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != dwSize )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									// This method called when pasting or dropping items
									// Do not overwrite strip parameters
									break;
								}

								case FOURCC_LIST:
									switch( ckListTrack.fccType )
									{
										case DMUS_FOURCC_WAVEPART_UI_LIST:
											while( pIRiffStream->Descend( &ckListItem, &ckListTrack, 0 ) == 0 )
											{
												switch( ckListItem.ckid )
												{
													case DMUS_FOURCC_WAVEPART_UI_CHUNK:
													{
														ioWavePartUI iWavePartUI;
														ZeroMemory( &iWavePartUI, sizeof(ioWavePartUI) );

														// Read in the item's header structure
														dwSize = min( sizeof( ioWavePartUI ), ck.cksize );
														hr = pIStream->Read( &iWavePartUI, dwSize, &dwByteCount );

														// Handle any I/O error by returning a failure code
														if( FAILED( hr )
														||  dwByteCount != dwSize )
														{
															hr = E_FAIL;
															goto ON_ERROR;
														}

														m_dwSourceVariationBtns = iWavePartUI.m_dwVariationBtns;
														break;
													}
												}

												pIRiffStream->Ascend( &ckListItem, 0 );
											}
											break;

										case DMUS_FOURCC_WAVEITEM_LIST:
											while( pIRiffStream->Descend( &ckListItem, &ckListTrack, 0 ) == 0 )
											{
												switch( ckListItem.ckid )
												{
													case FOURCC_LIST:
														switch( ckListItem.fccType )
														{
															case DMUS_FOURCC_WAVE_LIST:
															{
																CTrackItem* pNewItem = new CTrackItem( m_pTrackMgr, this );
																if( pNewItem == NULL )
																{
																	hr = E_OUTOFMEMORY;
																	goto ON_ERROR;
																}
																hr = pNewItem->LoadListItem( pIRiffStream, &ckListItem, m_pTrackMgr->m_pDMProdFramework, m_pTrackMgr );
																if( FAILED ( hr ) )
																{
																	delete pNewItem;
																	goto ON_ERROR;
																}
																list.AddTail( pNewItem );
																break;
															}
														}
														break;
												}

												pIRiffStream->Ascend( &ckListItem, 0 );
											}
											break;
									}
									break;
							}

							pIRiffStream->Ascend( &ckListTrack, 0 );
						}
						break;
				}
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	RELEASE( pIRiffStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SaveList

HRESULT CWaveStrip::SaveList( CTypedPtrList<CPtrList, CTrackItem*>& list, IStream* pIStream )
{
	IDMUSProdRIFFStream* pIRiffStream;
	MMCKINFO ckPart;
	MMCKINFO ck;
	HRESULT hr;

	if( pIStream == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_WAVEPART_LIST list chunk
	ckPart.fccType = DMUS_FOURCC_WAVEPART_LIST;
	if( pIRiffStream->CreateChunk( &ckPart, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_WAVEPART_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_WAVEPART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_WAVE_PART_HEADER oPartHeader;
		ZeroMemory( &oPartHeader, sizeof(DMUS_IO_WAVE_PART_HEADER) );

		// Fill in the members of the DMUS_IO_WAVE_PART_HEADER structure
		oPartHeader.dwPChannel = m_dwPChannel;
		oPartHeader.dwIndex = m_dwIndex;
		oPartHeader.dwVariations = m_dwVariationsMask;

		oPartHeader.lVolume = m_lVolume;
		oPartHeader.dwLockToPart = m_dwLockToPart;
		oPartHeader.dwFlags = m_dwPartFlagsDM;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oPartHeader, sizeof(DMUS_IO_WAVE_PART_HEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_WAVE_PART_HEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_WAVEPART_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save the strip's design data
	hr = SaveStripDesignData( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save the track items in this PChannel
	if( !list.IsEmpty() )
	{

		// Create a LIST chunk to store the list of items 
		MMCKINFO ckItemList;
		ckItemList.fccType = DMUS_FOURCC_WAVEITEM_LIST;
		if( pIRiffStream->CreateChunk( &ckItemList, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the item list
		POSITION pos = list.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CTrackItem* pItem = list.GetNext( pos );

			// Save each item
			hr = pItem->SaveListItem( pIRiffStream, m_pTrackMgr->m_pDMProdFramework, m_pTrackMgr );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
		
		pIRiffStream->Ascend( &ckItemList, 0 );
	}

	// Ascend out of the DMUS_FOURCC_WAVEPART_LIST list chunk
	if( pIRiffStream->Ascend(&ckPart, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIRiffStream );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::LoadStrip

HRESULT CWaveStrip::LoadStrip( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
	MMCKINFO		ck;
	MMCKINFO		ckList;
	DWORD			dwByteCount;
	DWORD			dwSize;
	CString			strObjectName;
	HRESULT			hr = E_FAIL;

	// LoadPChannel does not expect to be called twice on the same object!

	if( pIRiffStream == NULL 
	||  pckParent == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Load the PChannel
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_WAVEPART_CHUNK:
			{
				DMUS_IO_WAVE_PART_HEADER iPartHeader;

				// Read in the item's header structure
				dwSize = min( sizeof( DMUS_IO_WAVE_PART_HEADER ), ck.cksize );
				hr = pIStream->Read( &iPartHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwPChannel = iPartHeader.dwPChannel;
				m_dwIndex = iPartHeader.dwIndex;
				m_dwVariationsMask = iPartHeader.dwVariations;

				m_lVolume = iPartHeader.lVolume;
				m_dwLockToPart = iPartHeader.dwLockToPart;
				m_dwPartFlagsDM = iPartHeader.dwFlags;
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_WAVEPART_UI_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_WAVEPART_UI_CHUNK:
								{
									ioWavePartUI iWavePartUI;
									ZeroMemory( &iWavePartUI, sizeof(ioWavePartUI) );

									// Read in the item's header structure
									dwSize = min( sizeof( ioWavePartUI ), ck.cksize );
									hr = pIStream->Read( &iWavePartUI, dwSize, &dwByteCount );

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != dwSize )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									m_StripUI.m_dwVariationBtns = iWavePartUI.m_dwVariationBtns;
									m_StripUI.m_dblVerticalZoom = iWavePartUI.m_dblVerticalZoom;
									m_StripUI.m_lVerticalScrollYPos = iWavePartUI.m_lVerticalScrollYPos;
									m_StripUI.m_lStripHeight = iWavePartUI.m_lStripHeight;
									m_StripUI.m_nStripView = iWavePartUI.m_nStripView;
									m_StripUI.m_nSnapToRefTime = iWavePartUI.m_nSnapToRefTime;
									m_StripUI.m_nSnapToMusicTime = iWavePartUI.m_nSnapToMusicTime;
									m_StripUI.m_dwFlagsUI = iWavePartUI.m_dwFlagsUI;
									m_StripUI.m_dwOldVariationBtns = iWavePartUI.m_dwOldVariationBtns;
									m_StripUI.m_fVarGutterDown = iWavePartUI.m_fVarGutterDown;
									m_StripUI.m_nNbrLayers = iWavePartUI.m_nNbrLayers;
									m_StripUI.m_nSnapToRefTime_GridsPerSecond = iWavePartUI.m_nSnapToRefTime_GridsPerSecond;

									if( m_StripUI.m_nSnapToRefTime == 0 )
									{
										m_StripUI.m_nSnapToRefTime = IDM_SNAP_GRID;
									}
									if( m_StripUI.m_nSnapToMusicTime == 0 )
									{
										m_StripUI.m_nSnapToMusicTime = IDM_SNAP_GRID;
									}
									if( m_StripUI.m_nSnapToRefTime_GridsPerSecond == 0 )
									{
										m_StripUI.m_nSnapToRefTime_GridsPerSecond = DEFAULT_NBR_GRIDS_PER_SECOND;
									}
									break;
								}
								
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strStripName );
									break;
							}

							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_WAVEITEM_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_WAVE_LIST:
										{
											CTrackItem* pNewItem = new CTrackItem( m_pTrackMgr, this );
											if( pNewItem == NULL )
											{
												hr = E_OUTOFMEMORY;
												goto ON_ERROR;
											}
											hr = pNewItem->LoadTrackItem( pIRiffStream, &ckList, m_pTrackMgr->m_pDMProdFramework );
											if( FAILED ( hr ) )
											{
												delete pNewItem;
												goto ON_ERROR;
											}
											InsertByAscendingTime( pNewItem, FALSE );
											break;
										}
									}
							}

							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SaveStrip

HRESULT CWaveStrip::SaveStrip( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ckPart;
	MMCKINFO ck;
	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;
	bool fSavingFile = false;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;
		if( SUCCEEDED ( pPersistInfo->GetFileName( &bstrFileName ) ) )
		{
			::SysFreeString( bstrFileName );
			fSavingFile = true;
		}
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_WAVEPART_LIST list chunk
	ckPart.fccType = DMUS_FOURCC_WAVEPART_LIST;
	if( pIRiffStream->CreateChunk( &ckPart, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_WAVEPART_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_WAVEPART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_WAVE_PART_HEADER oPartHeader;
		ZeroMemory( &oPartHeader, sizeof(DMUS_IO_WAVE_PART_HEADER) );

		// Fill in the members of the DMUS_IO_WAVE_PART_HEADER structure
		oPartHeader.dwPChannel = m_dwPChannel;
		oPartHeader.dwIndex = m_dwIndex;
		oPartHeader.dwVariations = m_dwVariationsMask;

		oPartHeader.lVolume = m_lVolume;
		oPartHeader.dwLockToPart = m_dwLockToPart;
		oPartHeader.dwFlags = m_dwPartFlagsDM;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oPartHeader, sizeof(DMUS_IO_WAVE_PART_HEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_WAVE_PART_HEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_WAVEPART_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save the strip's design data
	if( ftFileType == FT_DESIGN )
	{
		hr = SaveStripDesignData( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save the track items in this PChannel
	if( !m_lstTrackItems.IsEmpty() )
	{
		REFERENCE_TIME rtSegmentLength = _I64_MAX;

		if( fSavingFile )
		{
			// Get the segment's length
			rtSegmentLength = m_pTrackMgr->GetSegmentLength();
		}

		// Create a LIST chunk to store the list of items 
		MMCKINFO ckItemList;
		ckItemList.fccType = DMUS_FOURCC_WAVEITEM_LIST;
		if( pIRiffStream->CreateChunk( &ckItemList, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the item list (all variations)
		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

			// When saving a file,
			// Only save item's that fall within the segment
			if( pItem->m_rtTimeLogical < rtSegmentLength
			&&  pItem->m_rtTimePhysical < rtSegmentLength )
			{
				// Save each item (all variations)
				hr = pItem->SaveTrackItem( pIRiffStream, m_pTrackMgr->m_pDMProdFramework );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}
		
		pIRiffStream->Ascend( &ckItemList, 0 );
	}

	// Ascend out of the DMUS_FOURCC_WAVEPART_LIST list chunk
	if( pIRiffStream->Ascend(&ckPart, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SaveStripDesignData

HRESULT CWaveStrip::SaveStripDesignData( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ckMain;
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Create the DMUS_FOURCC_WAVEPART_UI_LIST list chunk
	ckMain.fccType = DMUS_FOURCC_WAVEPART_UI_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_WAVEPART_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_WAVEPART_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Make sure we are saving the latest information
		if( m_pTrackMgr
		&&  m_pTrackMgr->m_pTimeline )
		{
			TimelineToWavePartUI();
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioWavePartUI oWavePartUI;
		ZeroMemory( &oWavePartUI, sizeof(ioWavePartUI) );

		// Fill in the members of the ioWavePartUI structure
		oWavePartUI.m_dwVariationBtns = m_StripUI.m_dwVariationBtns;
		oWavePartUI.m_dblVerticalZoom = m_StripUI.m_dblVerticalZoom;
		oWavePartUI.m_lVerticalScrollYPos = m_StripUI.m_lVerticalScrollYPos;
		oWavePartUI.m_lStripHeight = m_StripUI.m_lStripHeight;
		oWavePartUI.m_nStripView = m_StripUI.m_nStripView;
		oWavePartUI.m_nSnapToRefTime = m_StripUI.m_nSnapToRefTime;
		oWavePartUI.m_nSnapToMusicTime = m_StripUI.m_nSnapToMusicTime;
		oWavePartUI.m_dwFlagsUI = m_StripUI.m_dwFlagsUI;
		oWavePartUI.m_dwOldVariationBtns = m_StripUI.m_dwOldVariationBtns;
		oWavePartUI.m_fVarGutterDown = m_StripUI.m_fVarGutterDown;
		oWavePartUI.m_nNbrLayers = m_StripUI.m_nNbrLayers;
		oWavePartUI.m_nSnapToRefTime_GridsPerSecond = m_StripUI.m_nSnapToRefTime_GridsPerSecond;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oWavePartUI, sizeof(ioWavePartUI), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(ioWavePartUI) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_WAVEPART_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save the strip's name
	if( !m_strStripName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strStripName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the DMUS_FOURCC_WAVEPART_LIST list chunk
	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetWaveInfo

HRESULT CWaveStrip::GetWaveInfo( void )
{
	HRESULT hr = S_OK;

	// Ask DLS Designer for info about waves (all variations)
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Get WaveInfo
		if( FAILED ( pItem->GetWaveInfo() ) )
		{
			hr = E_FAIL;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SwitchTimeBase

void CWaveStrip::SwitchTimeBase( void )
{
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		pItem->SwitchTimeBase();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnShowStripProperties

void CWaveStrip::OnShowStripProperties()
{
	m_fShowItemProps = false;

	if( m_pTrackMgr )
	{
		m_pTrackMgr->m_pWaveStripForPropSheet = this;
		m_pTrackMgr->OnShowProperties();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnShowItemProperties

void CWaveStrip::OnShowItemProperties()
{
	if( IsSelected() == FALSE )
	{
		// Switch the property page to the strip's property page
		OnShowStripProperties();
		return;
	}

	m_fShowItemProps = true;

	OnShowProperties();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SetZoom

void CWaveStrip::SetZoom( double dblNewVerticalZoom )
{
	ASSERT( m_pTrackMgr != NULL );
	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	int nNewWaveHeight = long( MAX_WAVE_HEIGHT * dblNewVerticalZoom + HORIZ_LINE_HEIGHT );

	if( m_StripUI.m_dblVerticalZoom != dblNewVerticalZoom  
	||  m_nWaveHeight != nNewWaveHeight ) 
	{
		UINT nCurScrollBarPos = m_StripUI.m_lVerticalScrollYPos / m_nWaveHeight;
		m_StripUI.m_dblVerticalZoom = dblNewVerticalZoom;
		m_nWaveHeight = nNewWaveHeight;
		long lNewVerticalScrollYPos = nCurScrollBarPos * m_nWaveHeight;

		SetVerticalScrollYPos( lNewVerticalScrollYPos );

		RefreshVerticalScrollBarUI();
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::IsSelected

bool CWaveStrip::IsSelected()
{
	// If anything is selected in displayed variations, return true
	
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Item is selected - return true
			return true;
		}
	}

	// No items selected - return false
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::IsEmpty

bool CWaveStrip::IsEmpty()
{
	return m_lstTrackItems.IsEmpty() ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SelectSegment

// Return true if anything changed
bool CWaveStrip::SelectSegment( MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime )
{
	// Verify that we have a pointer to the Timeline
	if( m_pTrackMgr == NULL 
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return false;
	}

	REFERENCE_TIME rtTime;

	// Snap the start point
	m_pTrackMgr->ClocksToUnknownTime( mtBeginTime, &rtTime );
	SnapUnknownTime( rtTime, &rtTime );
	m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtBeginTime );

	// Snap the end point
	m_pTrackMgr->ClocksToUnknownTime( mtEndTime, &rtTime );
	SnapUnknownTime( rtTime, &rtTime );
	SnapUnknownToNextIncrement( rtTime, &rtTime );
	m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtEndTime );
	mtEndTime--;

	// Convert the passed in times to a generic time class
	CMusicTimeConverter cmtBeg(mtBeginTime);
	CMusicTimeConverter cmtEnd(mtEndTime);

	// Create a region that contains the selected time
	CSelectedRegion region( cmtBeg, cmtEnd );

	// Add the region to the list of selected regions
	m_pSelectedRegions->AddRegion( region );

	// Select all items in the list of selected regions
	// This will return true if the selection state of any item changed
	return SelectItemsInSelectedRegions();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::UnselectAll

void CWaveStrip::UnselectAll()
{
	// Unselect all layers
	POSITION pos = m_lstLayers.GetHeadPosition();
	while( pos )
	{
		CWaveStripLayer* pLayer = m_lstLayers.GetNext( pos );

		pLayer->m_fSelected = FALSE;
	}

	// Unselect all items ( all variations)
	pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each item 
		m_lstTrackItems.GetNext( pos )->m_fSelected = FALSE;
	}

	// Clear the list of selected regions
	m_pSelectedRegions->Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DeleteBetweenMeasureBeats

bool CWaveStrip::DeleteBetweenMeasureBeats( long lmStart, long lbStart, long lmEnd, long lbEnd )
{
	long lItemMeasure, lItemBeat, lItemGrid, lItemTick;

	// Initially, nothing changed
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while(pos)
	{
		// Save current position
		POSITION posTemp = pos;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( pItem->m_rtTimePhysical,
													   &lItemMeasure, &lItemBeat, &lItemGrid, &lItemTick );

		// Check if the item's measure value is before the start measure
		if( lItemMeasure < lmStart )
		{
			// Too early - keep looking
			continue;
		}

		// Check if the item's measure value is after the end measure
		if( lItemMeasure > lmEnd )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure, check if it is before the start beat
		if( ( lItemMeasure == lmStart )
		&&	( lItemBeat < lbStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( lItemMeasure == lmEnd)
		&&	( lItemBeat > lbEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// Within the given range, delete the item from the selected variations
		pItem->m_dwVariations &= ~m_StripUI.m_dwVariationBtns;
		if( pItem->m_dwVariations == 0 )
		{
			m_lstTrackItems.RemoveAt(posTemp);
			delete pItem;
		}

		fChanged = true;
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::InsertByAscendingTime

void CWaveStrip::InsertByAscendingTime( CTrackItem* pItemToInsert, BOOL fPaste )
{
	UNREFERENCED_PARAMETER(fPaste);

	// Ensure the pItemToInsert pointer is valid
	if ( pItemToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Make sure we have variations!
	ASSERT( pItemToInsert->m_dwVariations != 0 );

	// Make sure time is greater than zero!
	ASSERT( pItemToInsert->m_rtTimePhysical >= 0 );

	// Make sure item has been assigned to a layer!
	ASSERT( pItemToInsert->m_pLayer != NULL );

	// Make sure item's layer is in m_lstLayers
	ASSERT( m_lstLayers.Find(pItemToInsert->m_pLayer) );

	// Get wave information from DLS designer
	pItemToInsert->GetWaveInfo();

	CTrackItem* pItem;
	POSITION posCurrent, posNext = m_lstTrackItems.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pItem = m_lstTrackItems.GetNext( posNext );

		if( pItem->m_rtTimePhysical > pItemToInsert->m_rtTimePhysical )
		{
			// insert before posCurrent (which is the position of pItem)
			m_lstTrackItems.InsertBefore( posCurrent, pItemToInsert );
			return;
		}
	}

	// pItemToInsert is later than all items in the list, add it at the end of the list
	m_lstTrackItems.AddTail( pItemToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnUpdate

HRESULT CWaveStrip::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	HRESULT hr = E_INVALIDARG;

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_pTrackMgr->m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// Framework message
	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		DMUSProdFrameworkMsg* pFrameworkMsg =  (DMUSProdFrameworkMsg *)pData;
		ASSERT( pFrameworkMsg != NULL );

		IDMUSProdNode* pINode = NULL;

		if( pFrameworkMsg->punkIDMUSProdNode )
		{
			if( FAILED ( pFrameworkMsg->punkIDMUSProdNode->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
			{
				pINode = NULL;
			}
		}

		if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted)  
		||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileClosed) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them (all variations)
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This file was removed from the Project Tree
						pItem->SetFileReference( NULL );

						// Set undo text resource id
						if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted) )
						{
							m_pTrackMgr->m_nLastEdit = IDS_UNDO_DELETE_WAVE;
							hr = S_OK;
						}
						else
						{
							hr = S_FALSE;
						}
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileReplaced) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them (all variations)
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This file was replaced in the Project Tree, re-establish the link
						pItem->SetFileReference( (IDMUSProdNode *)pFrameworkMsg->pData );

						m_pTrackMgr->m_nLastEdit = IDS_UNDO_REPLACE_WAVE;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, DOCROOT_GuidChange) 
			 ||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileNameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them (all variations)
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// Set undo text resource id
						m_pTrackMgr->m_nLastEdit = IDS_UNDO_CHANGE_WAVE_LINK;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, WAVENODE_NameChange) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them (all variations)
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This file was renamed so update the file's list info fields
						hr = pItem->SetListInfo( m_pTrackMgr->m_pDMProdFramework );

						// Set undo text resource id
						m_pTrackMgr->m_nLastEdit = IDS_UNDO_CHANGE_WAVE_NAME;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, WAVENODE_DataChange) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them (all variations)
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					// Get wave information from DLS designer
					pItem->GetWaveInfo();
					m_pTrackMgr->QueueWaveForDownload( pItem );

					// Set undo text resource id
					m_pTrackMgr->m_nLastEdit = IDS_UNDO_CHANGE_WAVE_DATA;
					hr = S_OK;
				}
			}
		}

		RELEASE( pINode );

		if( SUCCEEDED ( hr ) )
		{
			// Let our hosting editor know about the changes
			if( hr == S_OK )
			{
				m_pTrackMgr->OnDataChanged();
			}

			if( m_pTrackMgr->m_pTimeline )
			{
				m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
			}

			// Update the property page
			RefreshPropertyPage();

			m_pTrackMgr->SyncWithDirectMusic();
		}
	}

	// GUID_ConductorUnloadWaves
	else if(::IsEqualGUID(rguidType, GUID_ConductorUnloadWaves))
	{
		// Unload all waves
		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

			m_pTrackMgr->QueueWaveForUnload( pItem );
		}
		hr = S_OK;
	}

	// GUID_ConductorDownloadWaves
	else if(::IsEqualGUID(rguidType, GUID_ConductorDownloadWaves))
	{
		// Download all waves
		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

			m_pTrackMgr->QueueWaveForDownload( pItem );
		}
		hr = S_OK;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SaveSelectedItems

HRESULT CWaveStrip::SaveSelectedItems( IStream* pIStream, REFERENCE_TIME rtOffset, CTrackItem* pItemAtDragPoint )
{
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	CWaveStripLayer* pLastLayer = NULL;
	MUSIC_TIME mtPasteOverwriteRange = -1;
	int		 nLayerIndex;
	int		 nMinLayerIndex = -1;
	int		 nMaxLayerIndex = -1;
	MMCKINFO ck;
	DWORD	 dwBytesWritten;

	// Verify that the pIStream pointer is valid
	if( pIStream == NULL )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Create a list to store the items to save in
	CTypedPtrList<CPtrList, CTrackItem*> lstItemsToSave;

	// Iterate throught the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext(pos);

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Add the item to the list of items to save
			CTrackItem* pNewItem = new CTrackItem( m_pTrackMgr, this, *pItem );
			if( pNewItem )
			{
				// TODO!!!   Put back
//				mtPasteOverwriteRange = max( mtPasteOverwriteRange, );

				if( pNewItem->m_pLayer != pLastLayer )
				{
					pLastLayer = pNewItem->m_pLayer;
					nLayerIndex = LayerToIndex( pLastLayer );
					if( nMinLayerIndex == -1 )
					{
						nMinLayerIndex = nLayerIndex;
						nMaxLayerIndex = nLayerIndex;
					}
					else
					{
						nMinLayerIndex = min( nMinLayerIndex, nLayerIndex );
						nMaxLayerIndex = max( nMaxLayerIndex, nLayerIndex );
					}
				}

				pNewItem->m_dwVariations &= m_StripUI.m_dwVariationBtns;
				lstItemsToSave.AddTail( pNewItem );
			}
		}
	}

	// Get item for DMUS_FOURCC_COPYPASTE_UI_CHUNK
	CTrackItem* pCopyPasteItem = pItemAtDragPoint;
	if( pCopyPasteItem == NULL )
	{
		if( lstItemsToSave.IsEmpty() == FALSE )
		{
			pCopyPasteItem = lstItemsToSave.GetHead();
		}
	}

	// Try and allocate a RIFF stream
	HRESULT hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	// Create DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// If range selected via timeline, use it
		// TODO!!!   Put back
//		if( m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect) )
		{
			long lStartTime;
			long lEndTime;
			m_pSelectedRegions->GetSpan( lStartTime, lEndTime );

			// Compute the start offset
			MUSIC_TIME mtStartOffset;
			long lMeasure;
			long lBeat;
			m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, lStartTime, &lMeasure, &lBeat );
			m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtStartOffset );

			// Compute the end offset
			MUSIC_TIME mtEndOffset;
			m_pTrackMgr->m_pTimeline->ClocksToMeasureBeat( m_pTrackMgr->m_dwGroupBits, 0, lEndTime, &lMeasure, &lBeat );
			m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, (lBeat + 1), 0, 0, &mtEndOffset );

			mtPasteOverwriteRange = mtEndOffset - mtStartOffset;
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioCopyPasteUI oCopyPasteUI;
		ZeroMemory( &oCopyPasteUI, sizeof(ioCopyPasteUI) );

		// Fill in the members of the ioCopyPasteUI structure
		if( pCopyPasteItem )
		{
			long lMinute, lMeasure;

			m_pTrackMgr->UnknownTimeToRefTime( rtOffset, &oCopyPasteUI.m_rtOffset );
			m_pTrackMgr->UnknownTimeToRefTime( pCopyPasteItem->m_rtTimePhysical, &oCopyPasteUI.m_rtStartTime );
			m_pTrackMgr->RefTimeToMinSecGridMs( this, oCopyPasteUI.m_rtStartTime, &lMinute, &oCopyPasteUI.m_lRefTimeSec,
											   &oCopyPasteUI.m_lRefTimeGrid, &oCopyPasteUI.m_lRefTimeMs );

			m_pTrackMgr->UnknownTimeToClocks( rtOffset, &oCopyPasteUI.m_mtOffset );
			m_pTrackMgr->UnknownTimeToClocks( pCopyPasteItem->m_rtTimePhysical, &oCopyPasteUI.m_mtStartTime );
			m_pTrackMgr->ClocksToMeasureBeatGridTick( oCopyPasteUI.m_mtStartTime, &lMeasure, &oCopyPasteUI.m_lMusicTimeBeat,
													 &oCopyPasteUI.m_lMusicTimeGrid, &oCopyPasteUI.m_lMusicTimeTick );

		}
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtPasteOverwriteRange, &oCopyPasteUI.m_rtPasteOverwriteRange );
		oCopyPasteUI.m_mtPasteOverwriteRange = mtPasteOverwriteRange;
		oCopyPasteUI.m_nStartLayerIndex = pCopyPasteItem ? LayerToIndex(pCopyPasteItem->m_pLayer) : 0;
		oCopyPasteUI.m_nMinLayerIndex = nMinLayerIndex;
		oCopyPasteUI.m_nMaxLayerIndex = nMaxLayerIndex;
		oCopyPasteUI.m_fRefTimeTrack = m_pTrackMgr->IsRefTimeTrack();

		// Write the structure out to the stream
		hr = pIStream->Write( &oCopyPasteUI, sizeof(ioCopyPasteUI), &dwBytesWritten );
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioCopyPasteUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	//check that anything is selected
	if( lstItemsToSave.IsEmpty() )
	{
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// For each item in lstItemsToSave, subtract rtOffset from m_rtTimePhysical
	REFERENCE_TIME rtNormalizeOffset;
	if( pCopyPasteItem == NULL )
	{
		ASSERT( 0 );
		rtNormalizeOffset = 0;
	}
	else
	{
		rtNormalizeOffset = pCopyPasteItem->m_rtTimePhysical;
	}
	NormalizeList( m_pTrackMgr, lstItemsToSave, rtNormalizeOffset );

	// Save the list of items into pIStream
	hr = SaveList( lstItemsToSave, pIStream );

	// Empty the temporary list of items
	EmptyList( lstItemsToSave );

ON_ERROR:
	RELEASE( pIRiffStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnEnableVariations

HRESULT CWaveStrip::OnEnableVariations( WORD wID )
{
	DWORD dwOldVariationsMask = m_dwVariationsMask;
	int i;

	switch( wID )
	{
		case IDM_ENABLE_VARBTNS:
			// Enable all selected variations that are disabled
			for( i = 0 ;   i < 32 ;   i++ )
			{
				// if variation is selected and disabled
				if( (m_StripUI.m_dwVariationBtns & (1 << i)) & ~m_dwVariationsMask )
				{
					m_dwVariationsMask ^= (1 << i);
				}
			}
			break;

		case IDM_DISABLE_VARBTNS:
			// Disable all selected variations that are enabled
			for( i = 0 ;  i < 32 ;  i++ )
			{
				// if variation is selected and enabled
				if( (m_StripUI.m_dwVariationBtns & (1 << i)) & m_dwVariationsMask )
				{
					m_dwVariationsMask ^= 1 << i;
				}
			}
			// if everything is disabled, re-enable the first selected variation
			if( m_dwVariationsMask == 0 )
			{
				for( i = 0 ;  i < 32 ;  i++ )
				{
					// If variation is selected, re-enable it
					if( m_StripUI.m_dwVariationBtns & (1 << i) )
					{
						m_dwVariationsMask ^= 1 << i;
						break;
					}
				}
			}
			m_StripUI.m_dwVariationBtns &= m_dwVariationsMask;
			break;
	}

	// Always redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	if( m_dwVariationsMask != dwOldVariationsMask )
	{
		// Notify the containing segment that we changed
		if( wID == IDM_ENABLE_VARBTNS )
		{
			m_pTrackMgr->m_nLastEdit = IDS_UNDO_ENABLE_VARCHOICES;
		}
		else
		{
			m_pTrackMgr->m_nLastEdit = IDS_UNDO_DISABLE_VARCHOICES;
		}
		m_pTrackMgr->OnDataChanged();

		// Update the selection regions to include the selected items
		SelectRegionsFromSelectedItems();

		// If visible, switch the property sheet to the track item property page
		OnShowItemProperties();

		// If it exists, refresh the track item property page
		RefreshPropertyPage();

		// Sync with DirectMusic
		m_pTrackMgr->SyncWithDirectMusic();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::MarkSelectedItems

// ORs dwFlags with the m_dwBits of each selected item
void CWaveStrip::MarkSelectedItems( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// It's selected - update m_dwBits
			pItem->m_dwBitsUI |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DeleteMarked

// deletes items marked by given flag
void CWaveStrip::DeleteMarked( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos1 = m_lstTrackItems.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos1 );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if any of the specified dwFlags are set in this item
		if( pItem->m_dwBitsUI & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the item from the selected variations
			pItem->m_dwVariations &= ~m_StripUI.m_dwVariationBtns;
			if( pItem->m_dwVariations == 0 )
			{
				m_lstTrackItems.RemoveAt(pos2);
				delete pItem;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DeleteSelectedItems

void CWaveStrip::DeleteSelectedItems()
{
	// Start iterating through the list of items
	POSITION pos1 = m_lstTrackItems.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos1 );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if the current item is selected
		if( pItem->m_fSelected )
		{
			// This item is selected, remove it from the selected variations
			pItem->m_dwVariations &= ~m_StripUI.m_dwVariationBtns;
			if( pItem->m_dwVariations == 0 )
			{
				m_lstTrackItems.RemoveAt(pos2);
				delete pItem;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetFirstSelectedItem

CTrackItem* CWaveStrip::GetFirstSelectedItem()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Item is selected, return a pointer to it
			return pItem;
		}
	}

	// No items are selected, return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::UnMarkItems

// unmarks flag m_dwUndermined field CTrackItems in list
void CWaveStrip::UnMarkItems( DWORD dwFlags )
{
	// Iterate through the list of items (all variations)
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each item
		m_lstTrackItems.GetNext( pos )->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::TimelineToWavePartUI

void CWaveStrip::TimelineToWavePartUI( void )
{
	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return;
	}

	VARIANT var;

	// m_StripUI.m_nStripView handled by WM_SIZE 
	// m_StripUI.m_lStripHeight handled by WM_SIZE 

	// Initialize state flags
	m_StripUI.m_dwFlagsUI = 0;

	// Get nbr layers
	m_StripUI.m_nNbrLayers = m_lstLayers.GetCount();
		
	// Active strip?
	if( SUCCEEDED ( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
	{
		IUnknown* pIUnknown = V_UNKNOWN(&var);
		if( pIUnknown )
		{
			IDMUSProdStrip* pIActiveStrip;
			if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDMUSProdStrip, (void**)&pIActiveStrip ) ) )
			{
				if( pIActiveStrip == (IDMUSProdStrip *)this )
				{
					m_StripUI.m_dwFlagsUI |= PARTUI_ACTIVESTRIP;
				}

				RELEASE( pIActiveStrip );
			}
			
			RELEASE( pIUnknown );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::WavePartUIToTimeline

void CWaveStrip::WavePartUIToTimeline( void )
{
	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return;
	}

	VARIANT var;

	// Set strip view
	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		var.vt = VT_I4;
		V_I4(&var) = m_StripUI.m_nStripView;
		m_pTrackMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIPVIEW, var );
	}

	// Set strip height
	if( m_StripUI.m_nStripView != SV_MINIMIZED )
	{
		var.vt = VT_I4;
		V_I4(&var) = m_StripUI.m_lStripHeight;
		m_pTrackMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, var );
	}

	// Determine wave height
	m_nWaveHeight = long( MAX_WAVE_HEIGHT * m_StripUI.m_dblVerticalZoom + HORIZ_LINE_HEIGHT );

	// Set the scrollbar
	long lOrigVerticalScrollPos = m_StripUI.m_lVerticalScrollYPos;
	m_StripUI.m_lVerticalScrollYPos = -1;	// Force change
	SetVerticalScrollYPos( lOrigVerticalScrollPos );
	RefreshVerticalScrollBarUI();

	// Set nbr of layers
	if( m_StripUI.m_nNbrLayers <= 0 )
	{
		m_StripUI.m_nNbrLayers = 1;
	}
	CreateLayerForIndex( m_StripUI.m_nNbrLayers - 1 );

	// Set active strip
	// Other strips do not reset the active strip
//	if( m_StripUI.m_dwFlagsUI & PARTUI_ACTIVESTRIP )
//	{
//		var.vt = VT_UNKNOWN;
//		if( SUCCEEDED( QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&var)) ) ) )
//		{
//			m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
//		}
//	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::RefreshVerticalScrollBarUI

HRESULT	CWaveStrip::RefreshVerticalScrollBarUI( void )
{
	// Reposition and resize vertical scrollbar
	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// SV_MINIMIZED
	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		m_VerticalScrollBar.ShowWindow( FALSE );
		return S_OK;
	}

	// SV_NORMAL
	VARIANT var;
	RECT rectFBar;
	RECT rectEntireStrip;

	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED (m_pTrackMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_FBAR_RECT, &var ) ) )
	{
		return E_FAIL;
	}

	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectEntireStrip;
	if( FAILED (m_pTrackMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_ENTIRE_STRIP_RECT, &var ) ) )
	{
		return E_FAIL;
	}

	// Store the original position
	CRect rectScrollBarOrig;
	m_VerticalScrollBar.GetClientRect( &rectScrollBarOrig );

	// Figure out the new position
	CRect rectScrollBar;
	rectScrollBar.left = rectFBar.right - sm_nZoomBtnWidth - BORDER_HORIZ_WIDTH - rectScrollBarOrig.right;
	rectScrollBar.right = rectFBar.right - sm_nZoomBtnWidth - BORDER_HORIZ_WIDTH;
	rectScrollBar.bottom = rectFBar.bottom;
	rectScrollBar.top = rectFBar.top;

	// Move the scroll bar
	if( rectScrollBar != rectScrollBarOrig )
	{
		m_VerticalScrollBar.MoveWindow( &rectScrollBar, TRUE );
	}

	// Get the strip's height
	int nStripHeight = m_StripUI.m_lStripHeight - VARIATION_BUTTONS_HEIGHT;
	nStripHeight = max( 0, nStripHeight );

	if( nStripHeight >= GetNbrLayers() * m_nWaveHeight )
	{
		// If we can view all layers, disable the scrollbar
		SetVerticalScrollYPos( 0 );
		m_VerticalScrollBar.EnableScrollBar( ESB_DISABLE_BOTH );
	}
	else
	{
		// Enable the scrollbar
		m_VerticalScrollBar.EnableScrollBar( ESB_ENABLE_BOTH );

		// Set the new page size, min, max
		SCROLLINFO si;
		si.cbSize = sizeof( SCROLLINFO );
		si.fMask = SIF_PAGE | SIF_RANGE;
		si.nMin = 0;
		si.nMax = m_lstLayers.GetCount();
		si.nPage = nStripHeight / m_nWaveHeight;
		m_VerticalScrollBar.SetScrollInfo( &si, TRUE );

		// Display as many layers as possible
		int nCurPos = m_StripUI.m_lVerticalScrollYPos / m_nWaveHeight;
		if( (si.nMax - (UINT)nCurPos) < si.nPage )
		{
			SetVerticalScrollYPos( ((si.nMax - si.nPage) + 1) * m_nWaveHeight );
		}
	}

	m_VerticalScrollBar.ShowWindow( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnCreate

HRESULT CWaveStrip::OnCreate( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Register our clipboard formats
	RegisterClipboardFormats();

	// Create the vertical scrollbar
	if( m_VerticalScrollBar.GetSafeHwnd() == NULL )
	{
		HWND hwnd = GetTimelineHWND();
		if( hwnd )
		{
			CWnd wnd;
			wnd.Attach( hwnd );

			CRect rectScrollBar = CRect(0, 0, 40, 100);
			m_VerticalScrollBar.Create( SBS_RIGHTALIGN | SBS_VERT | WS_CHILD | WS_CLIPSIBLINGS,
										rectScrollBar, &wnd, IDC_LAYER_SCROLLBAR );
			m_VerticalScrollBar.SetWaveStrip( this );

			wnd.Detach();
		}
	}

	// Load button bitmaps
	if( InterlockedIncrement( &sm_lBitmapRefCount ) == 1 )
	{
		if( sm_bmpLocked.GetSafeHandle() == NULL )
		{
			sm_bmpLocked.LoadBitmap( IDB_LOCKED );
		}
		if( sm_bmpUnlocked.GetSafeHandle() == NULL )
		{
			sm_bmpUnlocked.LoadBitmap( IDB_UNLOCKED );
		}
		if( sm_bmpVarBtnUp.GetSafeHandle() == NULL )
		{
			sm_bmpVarBtnUp.LoadBitmap( IDB_VARBTN_UP );
		}
		if( sm_bmpVarBtnDown.GetSafeHandle() == NULL )
		{
			sm_bmpVarBtnDown.LoadBitmap( IDB_VARBTN_DOWN );
		}
		if( sm_bmpVarInactiveBtnUp.GetSafeHandle() == NULL )
		{
			sm_bmpVarInactiveBtnUp.LoadBitmap( IDB_VARBTN_INACTIVE_UP );
		}
		if( sm_bmpVarInactiveBtnDown.GetSafeHandle() == NULL )
		{
			sm_bmpVarInactiveBtnDown.LoadBitmap( IDB_VARBTN_INACTIVE_DOWN );
		}
		if( sm_bmpVarGutterBtnUp.GetSafeHandle() == NULL )
		{
			sm_bmpVarGutterBtnUp.LoadBitmap( IDB_VARGUTTER_UP );
		}
		if( sm_bmpVarGutterBtnDown.GetSafeHandle() == NULL )
		{
			sm_bmpVarGutterBtnDown.LoadBitmap( IDB_VARGUTTER_DOWN );
		}

		BITMAP bmParam;
		if( sm_bmpZoomInBtnUp.GetSafeHandle() == NULL )
		{
			sm_bmpZoomInBtnUp.LoadBitmap( IDB_ZOOMIN_UP );
			sm_bmpZoomInBtnUp.GetBitmap( &bmParam );
			sm_nZoomBtnHeight = bmParam.bmHeight;
			sm_nZoomBtnWidth = bmParam.bmWidth;
			sm_nLayerBtnWidth = bmParam.bmWidth;
		}
		if( sm_bmpZoomInBtnDown.GetSafeHandle() == NULL )
		{
			sm_bmpZoomInBtnDown.LoadBitmap( IDB_ZOOMIN_DOWN );
		}
		if( sm_bmpZoomOutBtnUp.GetSafeHandle() == NULL )
		{
			sm_bmpZoomOutBtnUp.LoadBitmap( IDB_ZOOMOUT_UP );
		}
		if( sm_bmpZoomOutBtnDown.GetSafeHandle() == NULL )
		{
			sm_bmpZoomOutBtnDown.LoadBitmap( IDB_ZOOMOUT_DOWN );
		}
	}
	
	// If we're currently playing, enable the variation timer.
	if( m_pTrackMgr->m_pIDMSegmentState )
	{
		EnableVariationTimer();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnDestroy

HRESULT CWaveStrip::OnDestroy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Delete the Bitmap buttons
	if( InterlockedDecrement( &sm_lBitmapRefCount ) == 0 )
	{
		if( sm_bmpLocked.GetSafeHandle() != NULL )
		{
			sm_bmpLocked.DeleteObject();
		}
		if( sm_bmpUnlocked.GetSafeHandle() != NULL )
		{
			sm_bmpUnlocked.DeleteObject();
		}
		if( sm_bmpVarBtnUp.GetSafeHandle() != NULL )
		{
			sm_bmpVarBtnUp.DeleteObject();
		}
		if( sm_bmpVarBtnDown.GetSafeHandle() != NULL )
		{
			sm_bmpVarBtnDown.DeleteObject();
		}
		if( sm_bmpVarInactiveBtnUp.GetSafeHandle() != NULL )
		{
			sm_bmpVarInactiveBtnUp.DeleteObject();
		}
		if( sm_bmpVarInactiveBtnDown.GetSafeHandle() != NULL )
		{
			sm_bmpVarInactiveBtnDown.DeleteObject();
		}
		if( sm_bmpVarGutterBtnUp.GetSafeHandle() != NULL )
		{
			sm_bmpVarGutterBtnUp.DeleteObject();
		}
		if( sm_bmpVarGutterBtnDown.GetSafeHandle() != NULL )
		{
			sm_bmpVarGutterBtnDown.DeleteObject();
		}
		if( sm_bmpZoomInBtnUp.GetSafeHandle() != NULL )
		{
			sm_bmpZoomInBtnUp.DeleteObject();
		}
		if( sm_bmpZoomInBtnDown.GetSafeHandle() != NULL )
		{
			sm_bmpZoomInBtnDown.DeleteObject();
		}
		if( sm_bmpZoomOutBtnUp.GetSafeHandle() != NULL )
		{
			sm_bmpZoomOutBtnUp.DeleteObject();
		}
		if( sm_bmpZoomOutBtnDown.GetSafeHandle() != NULL )
		{
			sm_bmpZoomOutBtnDown.DeleteObject();
		}
	}

	if( m_VerticalScrollBar.GetSafeHwnd() )
	{
		m_VerticalScrollBar.ShowWindow( FALSE );
		m_VerticalScrollBar.DestroyWindow();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SetVerticalScrollYPos

void CWaveStrip::SetVerticalScrollYPos( long lNewVertScrollYPos )
{
	// Make sure lNewVertScrollYPos is multiple of m_nWaveHeight
	lNewVertScrollYPos = lNewVertScrollYPos / m_nWaveHeight;
	lNewVertScrollYPos = lNewVertScrollYPos * m_nWaveHeight;

	// Enforce min/max values
	lNewVertScrollYPos = max( lNewVertScrollYPos, 0 );
	lNewVertScrollYPos = min( lNewVertScrollYPos, m_lstLayers.GetCount() * m_nWaveHeight );
	
	if( lNewVertScrollYPos != m_StripUI.m_lVerticalScrollYPos )
	{
		// Pospone drawing operations - this avoids flickering
		// in the strip's title and maximize/minimize button
		HWND hwnd = GetTimelineHWND();
		if( hwnd )
		{
			::LockWindowUpdate( hwnd );
		}

		// Store the new YPos
		m_StripUI.m_lVerticalScrollYPos = lNewVertScrollYPos;
		
		// Update the timeline
		VARIANT var;
		var.vt = VT_I4;
		V_I4(&var) = m_StripUI.m_lVerticalScrollYPos;
		m_pTrackMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, var );

		// Restore drawing operations (and redraw the strip)
		if( hwnd )
		{
			::LockWindowUpdate( NULL );
		}

		// Update the scrollbar position
		if( m_VerticalScrollBar.GetSafeHwnd() )
		{
			m_VerticalScrollBar.SetScrollPos( m_StripUI.m_lVerticalScrollYPos / m_nWaveHeight );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnVScrollFromScrollbar

void CWaveStrip::OnVScrollFromScrollbar( UINT nSBCode, UINT nPos )
{
	int nStripHeight = m_StripUI.m_lStripHeight - VARIATION_BUTTONS_HEIGHT;
	nStripHeight = max( 0, nStripHeight );

	UINT nCurPos = m_StripUI.m_lVerticalScrollYPos / m_nWaveHeight;
	int nNewPos;

	switch( nSBCode )
	{
		case SB_TOP:
			nNewPos = 0;
			break;
		
		case SB_LINEDOWN:
			nNewPos = nCurPos + 1;
			break;
		
		case SB_LINEUP:
			nNewPos = nCurPos - 1;
			break;
		
		case SB_PAGEDOWN:
			nNewPos = nCurPos + (nStripHeight / m_nWaveHeight);
			break;
		
		case SB_PAGEUP:
			nNewPos = nCurPos - (nStripHeight / m_nWaveHeight);
			break;
		
		case SB_THUMBPOSITION:
		case SB_THUMBTRACK:
			nNewPos = nPos;
			break;
		
		case SB_BOTTOM:
			nNewPos = GetNbrLayers();
			break;

		case SB_ENDSCROLL:
		default:
			return;
	}

	nNewPos = max( nNewPos, 0 );
	nNewPos = min( nNewPos, GetNbrLayers() );

	long lNewVerticalScrollYPos = nNewPos * m_nWaveHeight;

	if( lNewVerticalScrollYPos != m_StripUI.m_lVerticalScrollYPos )
	{
		SetVerticalScrollYPos( lNewVerticalScrollYPos );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CreateLayerForIndex

CWaveStripLayer* CWaveStrip::CreateLayerForIndex( int nLayerIndex )
{
	if( nLayerIndex < 0 )
	{
		return NULL;
	}

	CWaveStripLayer* pTheLayer = NULL;

	int nNbrLayers = m_lstLayers.GetCount();

	if( nLayerIndex < nNbrLayers )
	{
		// Layer already in list
		POSITION pos = m_lstLayers.FindIndex( nLayerIndex );
		if( pos )
		{
			pTheLayer = m_lstLayers.GetAt( pos );
		}
	}
	else
	{
		// Layer not in list so it needs to be created
		for( ; ; )
		{
			CWaveStripLayer* pLayer = new CWaveStripLayer( this );
			if( pLayer == NULL )
			{
				break;
			}

			m_lstLayers.AddTail( pLayer );
			if( nNbrLayers == nLayerIndex )
			{
				pTheLayer = pLayer;
				break;
			}

			nNbrLayers++;
		}

		RefreshVerticalScrollBarUI();
	}

	return pTheLayer;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::IndexToLayer

CWaveStripLayer* CWaveStrip::IndexToLayer( int nLayerIndex )
{
	if( nLayerIndex < 0 )
	{
		return NULL;
	}

	CWaveStripLayer* pTheLayer = NULL;

	int nNbrLayers = m_lstLayers.GetCount();

	if( nLayerIndex < nNbrLayers )
	{
		// Layer already in list
		POSITION pos = m_lstLayers.FindIndex( nLayerIndex );
		if( pos )
		{
			pTheLayer = m_lstLayers.GetAt( pos );
		}
	}

	return pTheLayer;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::LayerToIndex

int CWaveStrip::LayerToIndex( CWaveStripLayer* pLayer )
{
	int nTheIndex = 0;

	if( pLayer )
	{
		int nIndex = 0;

		POSITION pos = m_lstLayers.GetHeadPosition();
		while( pos )
		{
			CWaveStripLayer* pLayerList = m_lstLayers.GetNext( pos );

			if( pLayerList == pLayer )
			{
				nTheIndex = nIndex;
				break;
			}

			nIndex++;
		}

	}

	return nTheIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::YPosToLayer

CWaveStripLayer* CWaveStrip::YPosToLayer( long lYPos, bool fNewLayerIsValid )
{
	CWaveStripLayer* pTheLayer = NULL;

	int nLayerIndex = YPosToLayerIndex( lYPos );

	if( nLayerIndex >= 0 )
	{
		if( nLayerIndex < m_lstLayers.GetCount() )
		{
			pTheLayer = IndexToLayer( nLayerIndex );
		}
		else if( nLayerIndex == m_lstLayers.GetCount() )
		{
			if( fNewLayerIsValid )
			{
				pTheLayer = CreateLayerForIndex( nLayerIndex );
			}
		}
	}

	return pTheLayer;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::YPosToLayerIndex

int CWaveStrip::YPosToLayerIndex( long lYPos )
{
	int nLayerIndex = -1;

	lYPos -= VARIATION_BUTTONS_HEIGHT;

	if( lYPos >= m_StripUI.m_lVerticalScrollYPos )
	{
		int nIndex = lYPos / m_nWaveHeight;

		if( nIndex >= 0
		&&  nIndex < GetNbrLayers() )
		{
			nLayerIndex = nIndex;
		}
	}

	return nLayerIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetNbrLayers

int CWaveStrip::GetNbrLayers( void )
{
	// make sure there is at least one layer in the list
	if( m_lstLayers.IsEmpty() )
	{
		CreateLayerForIndex( 0 );
	}

	return m_lstLayers.GetCount() + 1;	// Add 1 for 'New' layer
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SelectLayer

bool CWaveStrip::SelectLayer( CWaveStripLayer* pLayer )
{
	bool fChanged = false;

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		if( pItem->m_pLayer == pLayer )
		{
			if( pItem->m_fSelected != pLayer->m_fSelected )
			{
				pItem->m_fSelected = pLayer->m_fSelected;
				fChanged = true;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::IsLayerEmpty

bool CWaveStrip::IsLayerEmpty( CWaveStripLayer* pLayer )
{
	bool fEmpty = true;

	// Do any items exist in this layer?  (all variations)
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_pLayer == pLayer )
		{
			fEmpty = false;
		}
	}

	return fEmpty;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SyncLayerSelectFlag

BOOL CWaveStrip::SyncLayerSelectFlag( CWaveStripLayer* pLayer )
{
	BOOL fNewSelectFlag = pLayer->m_fSelected;
	BOOL fFirstTime = TRUE;

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// If this item's variations are not displaying, skip it
		if( !(pItem->m_dwVariations & m_StripUI.m_dwVariationBtns) )
		{
			continue;
		}

		if( pItem->m_pLayer == pLayer )
		{
			if( fFirstTime )
			{
				fFirstTime = FALSE;
				fNewSelectFlag = pItem->m_fSelected;
			}

			if( pItem->m_fSelected != fNewSelectFlag )
			{
				fNewSelectFlag = FALSE;
				break;
			}
		}
	}

	return fNewSelectFlag;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CanDeleteLayers

HRESULT CWaveStrip::CanDeleteLayers( void )
{
	POSITION pos = m_lstLayers.GetHeadPosition();
	while( pos )
	{
		CWaveStripLayer* pLayer = m_lstLayers.GetNext( pos );

		if( pLayer->m_fSelected )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DeleteSelectedLayers

HRESULT CWaveStrip::DeleteSelectedLayers( void )
{
	// Display delete prompt when deleting layer will cause
	// items in non-visible variations to be deleted
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		ASSERT( pItem->m_pLayer != NULL );
		if( pItem->m_pLayer 
		&&  pItem->m_pLayer->m_fSelected )
		{
			if( pItem->m_dwVariations & ~m_StripUI.m_dwVariationBtns )
			{
				// Item belongs to variations not displaying
				if( AfxMessageBox( IDS_DELETE_LAYER_PROMPT, MB_OKCANCEL ) == IDCANCEL )
				{
					return S_FALSE;
				}
				break;
			}
		}
	}

	bool fSyncWithDirectMusic = false;

	// Delete items in selected layers (all variations)
	pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		POSITION posCurrent = pos;
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_pLayer 
		&&  pItem->m_pLayer->m_fSelected )
		{
			m_lstTrackItems.RemoveAt( posCurrent );
			delete pItem;

			fSyncWithDirectMusic = true;
		}
	}

	// Delete selected layers
	pos = m_lstLayers.GetHeadPosition();
	while( pos )
	{
		POSITION posCurrent = pos;
		CWaveStripLayer* pLayer = m_lstLayers.GetNext( pos );

		if( pLayer->m_fSelected )
		{
			m_lstLayers.RemoveAt( posCurrent );
			delete pLayer;
		}
	}

	// Update the selection regions to include just this selected item
	SelectRegionsFromSelectedItems();

	// Notify the containing segment that we did a paste operation
	m_pTrackMgr->m_nLastEdit = IDS_UNDO_DELETE_LAYERS;
	m_pTrackMgr->OnDataChanged();

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Adjust vertical scroll bar
	if( (m_StripUI.m_lVerticalScrollYPos / m_nWaveHeight) >= m_lstLayers.GetCount() )
	{
		// Get the strip's height
		int nStripHeight = m_StripUI.m_lStripHeight - VARIATION_BUTTONS_HEIGHT;
		nStripHeight = max( 0, nStripHeight );

		// Display last page
		int nPage = nStripHeight / m_nWaveHeight;
		SetVerticalScrollYPos( max(0, (m_lstLayers.GetCount() - nPage) * m_nWaveHeight) );
	}
	RefreshVerticalScrollBarUI();

	// Ensure the track item property page is visible
	OnShowItemProperties();

	// Refresh the track item property page
	RefreshPropertyPage();

	// Sync with DirectMusic
	if( fSyncWithDirectMusic )
	{
		m_pTrackMgr->SyncWithDirectMusic();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::InsertTheLayer

HRESULT CWaveStrip::InsertTheLayer( int nLayerIndex )
{
	if( nLayerIndex < 0
	||  nLayerIndex > m_lstLayers.GetCount() )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Create new layer
	CWaveStripLayer* pLayer = new CWaveStripLayer( this );
	if( pLayer == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Place in m_lstLayers
	POSITION pos = m_lstLayers.FindIndex( nLayerIndex );
	if( pos )
	{
		m_lstLayers.InsertBefore( pos, pLayer );
	}
	else
	{
		m_lstLayers.AddTail( pLayer );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::InsertLayers

HRESULT CWaveStrip::InsertLayers( int nLayerIndex )
{
	if( nLayerIndex < 0
	||  nLayerIndex > m_lstLayers.GetCount() )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Create the new layer(s)
	HRESULT hr = InsertTheLayer( nLayerIndex );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	// Notify the containing segment that we inserted layer(s)
	m_pTrackMgr->m_nLastEdit = IDS_UNDO_INSERT_LAYER;
	m_pTrackMgr->OnDataChanged();
	
	// Compute page size
	int nStripHeight = m_StripUI.m_lStripHeight - VARIATION_BUTTONS_HEIGHT;
	nStripHeight = max( 0, nStripHeight );
	int nPageSize = nStripHeight / m_nWaveHeight;

	// Determine the current scroll position
	int nCurPos = m_StripUI.m_lVerticalScrollYPos / m_nWaveHeight;

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	RefreshVerticalScrollBarUI();

	// Set new vertical scroll position
	if( nCurPos == nLayerIndex )	// top of page
	{
		if( nCurPos > 0 )
		{
			SetVerticalScrollYPos( (nCurPos - 1) * m_nWaveHeight );
		}
	}
	else if( (nCurPos + nPageSize) == nLayerIndex )	// bottom of page
	{
		SetVerticalScrollYPos( (nCurPos + 1) * m_nWaveHeight );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::IndexToLayerYCoords

void CWaveStrip::IndexToLayerYCoords( int nLayerIndex, RECT* pRect )
{
	if( nLayerIndex >= 0 )
	{
		pRect->top = nLayerIndex * m_nWaveHeight;
		pRect->bottom = pRect->top + m_nWaveHeight;
	}
	else
	{
		pRect->top = 1;
		pRect->bottom = STRIP_MINIMIZE_HEIGHT -1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::DoGridsPerSecond

void CWaveStrip::DoGridsPerSecond( void )
{
	CGridsPerSecondDlg dlgGridsPerSecond;

	dlgGridsPerSecond.m_nSnapToRefTime_GridsPerSecond = m_StripUI.m_nSnapToRefTime_GridsPerSecond;

	if( dlgGridsPerSecond.DoModal() == IDOK )
	{
		if( dlgGridsPerSecond.m_fAllParts )
		{
			if( m_pTrackMgr->AllStrips_SetNbrGridsPerSecond(dlgGridsPerSecond.m_nSnapToRefTime_GridsPerSecond) )
			{
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_NBR_GRIDS_PER_SECOND;
				m_pTrackMgr->OnDataChanged();
				m_pTrackMgr->AllStrips_Invalidate();
			}
		}
		else
		{
			if( m_StripUI.m_nSnapToRefTime_GridsPerSecond != dlgGridsPerSecond.m_nSnapToRefTime_GridsPerSecond )
			{
				m_StripUI.m_nSnapToRefTime_GridsPerSecond = dlgGridsPerSecond.m_nSnapToRefTime_GridsPerSecond;
				m_pTrackMgr->m_nLastEdit = IDS_UNDO_NBR_GRIDS_PER_SECOND;
				m_pTrackMgr->OnDataChanged();
				m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
			}
		}

		// Update the property page
		RefreshPropertyPage();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SetSnapTo

void CWaveStrip::SetSnapTo( WORD wID )
{
	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		m_StripUI.m_nSnapToRefTime = wID;

		// Update the Timeline with the snap-to setting (if possible)
		if( (wID == IDM_SNAP_NONE)
		||	(wID == IDM_SNAP_GRID) )
		{
			// Create a variant to store the timeline snap-to setting in
			VARIANT var;
			var.vt = VT_I4;

			switch( wID )
			{
			case IDM_SNAP_NONE:
				V_I4(&var) = DMUSPROD_TIMELINE_SNAP_NONE;
				break;
			case IDM_SNAP_GRID:
				V_I4(&var) = DMUSPROD_TIMELINE_SNAP_GRID;
				break;
			}

			// Now, set the TP_SNAP_TO property
			m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_SNAP_TO, var );
		}
	}
	else
	{
		m_StripUI.m_nSnapToMusicTime = wID;

		// Update the Timeline with the snap-to setting

		// Convert from the our own SNAP_TO setting to the timeline's SNAP_TO setting
		DMUSPROD_TIMELINE_SNAP_TO tlSnapTo;

		switch( wID )
		{
		case IDM_SNAP_NONE:
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_NONE;
			break;
		case IDM_SNAP_GRID:
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
			break;
		case IDM_SNAP_BEAT:
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_BEAT;
			break;
		case IDM_SNAP_BAR:
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_BAR;
			break;
		default:
			ASSERT(FALSE);
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
			break;
		}

		// Now, set the TP_SNAP_TO property
		VARIANT var;
		var.vt = VT_I4;
		V_I4(&var) = tlSnapTo;
		m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_SNAP_TO, var );
	}

	// Redraw our strip
	m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SnapXPosToUnknownTime

HRESULT CWaveStrip::SnapXPosToUnknownTime( long lXPos, REFERENCE_TIME* prtSnapTime )
{
	if( prtSnapTime == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}
	*prtSnapTime = 0;

	if( lXPos < 0 )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	MUSIC_TIME mtTime;
	if( FAILED ( m_pTrackMgr->m_pTimeline->PositionToClocks( lXPos, &mtTime ) ) )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	REFERENCE_TIME rtTime;
	if( FAILED ( m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtTime ) ) )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	return SnapUnknownTime( rtTime, prtSnapTime );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SnapUnknownTime

HRESULT CWaveStrip::SnapUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtSnapTime )
{
	if( prtSnapTime == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}
	*prtSnapTime = 0;

	if( rtTime < 0 )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		long lMinute;
		long lSec;
		long lGrid;
		long lMs;
		m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSec, &lGrid, &lMs );

		if( m_StripUI.m_nSnapToRefTime != IDM_SNAP_NONE )
		{
			if( lMs < 0 )
			{
				m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSec, (lGrid - 1), 0, &rtTime );
				m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSec, &lGrid, &lMs );
			}
		}

		switch( m_StripUI.m_nSnapToRefTime )
		{
			case IDM_SNAP_NONE:
				// Nothing to do
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSec, lGrid, 0, &rtTime );
				break;
			
			case IDM_SNAP_SECOND:
				m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSec, 0, 0, &rtTime );
				break;
		}
	}
	else
	{
		long lMeasure;
		long lBeat;
		long lGrid;
		long lTick;
		m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)rtTime, &lMeasure, &lBeat, &lGrid, &lTick );

		MUSIC_TIME mtTime;
		if( m_StripUI.m_nSnapToMusicTime != IDM_SNAP_NONE )
		{
			if( lTick < 0 )
			{
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, (lGrid - 1), 0, &mtTime );
				m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick );
			}
		}

		switch( m_StripUI.m_nSnapToMusicTime )
		{
			case IDM_SNAP_NONE:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, 0, &mtTime );
				break;
			
			case IDM_SNAP_BEAT:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtTime );
				break;
			
			case IDM_SNAP_BAR:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, 0, 0, 0, &mtTime );
				break;

			default:
				ASSERT( 0 );	// Should not happen!
				mtTime = 0;
		}

		rtTime = mtTime;
	}

	*prtSnapTime = rtTime;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SnapUnknownTimeToDisplayPosition

HRESULT	CWaveStrip::SnapUnknownTimeToDisplayPosition( REFERENCE_TIME rtTime, long* plPosition )
{
	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	SnapUnknownTime( rtTime, &rtTime );

	if( m_pTrackMgr->IsRefTimeTrack() == false )
	{
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( (MUSIC_TIME)rtTime, &rtTime );
	}

	m_pTrackMgr->m_pTimeline->RefTimeToPosition( rtTime, plPosition );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SnapPositionToStartEndClocks

HRESULT CWaveStrip::SnapPositionToStartEndClocks( long lXPos, MUSIC_TIME* pmtStart, MUSIC_TIME* pmtEnd )
{
	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Determine start time
	REFERENCE_TIME rtStartTime;
	SnapXPosToUnknownTime( lXPos, &rtStartTime );

	// Determine end time
	REFERENCE_TIME rtEndTime;
	SnapUnknownToNextIncrement( rtStartTime, &rtEndTime );

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtStartTime, pmtStart );
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtEndTime, pmtEnd );
	}
	else
	{
		*pmtStart = (MUSIC_TIME)rtStartTime;
		*pmtEnd = (MUSIC_TIME)rtEndTime;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::SnapUnknownToNextIncrement

HRESULT CWaveStrip::SnapUnknownToNextIncrement( REFERENCE_TIME rtTime, REFERENCE_TIME* prtSnapTime )
{
	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	SnapUnknownTime( rtTime, &rtTime );

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		long lMinute, lSecond, lGrid, lMs;
	
		m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSecond, &lGrid, &lMs );
		switch( m_StripUI.m_nSnapToRefTime )
		{
			case IDM_SNAP_NONE:
				lMs++;
				break;

			case IDM_SNAP_GRID:
				lGrid++;
				break;
			
			case IDM_SNAP_SECOND:
				lSecond++;
				break;
		}
		m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSecond, lGrid, lMs, &rtTime );
	}
	else
	{
		long lMeasure, lBeat, lGrid, lTick;
		MUSIC_TIME mtTime;

		m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)rtTime, &lMeasure, &lBeat, &lGrid, &lTick );
		switch( m_StripUI.m_nSnapToMusicTime )
		{
			case IDM_SNAP_NONE:
				lTick++;
				break;

			case IDM_SNAP_GRID:
				lGrid++;
				break;
			
			case IDM_SNAP_BEAT:
				lBeat++;
				break;
			
			case IDM_SNAP_BAR:
				lMeasure++;
				break;
		}
		m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );
		rtTime = mtTime;
	}

	*prtSnapTime = rtTime;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::IsOneGrid

bool CWaveStrip::IsOneGrid( void )
{
	if( m_pTrackMgr
	&& 	m_pTrackMgr->IsRefTimeTrack() )
	{
		if( m_StripUI.m_nSnapToRefTime_GridsPerSecond == 1 )
		{
			return true;
		}
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetPChannel

DWORD CWaveStrip::GetPChannel( void )
{
	return m_dwPChannel;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::RefreshAllWaves

void CWaveStrip::RefreshAllWaves()
{
	CWaitCursor wait;

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		pItem->RefreshWave();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::GetReferencedNodes

void CWaveStrip::GetReferencedNodes( DWORD *pdwIndex, DMUSProdReferencedNodes *pDMUSProdReferencedNodes )
{
	// Iterate through all wave items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_FileRef.pIDocRootNode )
		{
			if( pDMUSProdReferencedNodes->apIDMUSProdNode
			&&	pDMUSProdReferencedNodes->dwArraySize > *pdwIndex )
			{
				pDMUSProdReferencedNodes->apIDMUSProdNode[*pdwIndex] = pItem->m_FileRef.pIDocRootNode;
				pDMUSProdReferencedNodes->apIDMUSProdNode[*pdwIndex]->AddRef();
			}

			// Increment the number of nodes we've found
			(*pdwIndex)++;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::RefreshPropertyPage

void CWaveStrip::RefreshPropertyPage( void )
{
	// Update the property page, if it exists
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}

	// Always update the status bar whenever the property page is refreshed
	if( m_pTrackMgr )
	{
		m_pTrackMgr->UpdateStatusBarDisplay();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CListSelectedRegion_AddRegion

void CWaveStrip::CListSelectedRegion_AddRegion( long lXPos )
{
	ASSERT( m_pTrackMgr != NULL );

	MUSIC_TIME mtBeg;
	MUSIC_TIME mtEnd;

	// Snap XPos to measure/beat (or minute/second) boundary
	CMusicTimeConverter cmtBegX;
	CMusicTimeConverter cmtEndX;
	SnapPositionToStartEndClocks( lXPos, &mtBeg, &mtEnd );
	cmtBegX = mtBeg;
	cmtEndX = mtEnd;

	CSelectedRegion* psr = new CSelectedRegion( cmtBegX, cmtEndX );
	m_pSelectedRegions->AddHead( psr );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CListSelectedRegion_AddRegion

void CWaveStrip::CListSelectedRegion_AddRegion( CTrackItem* pItem )
{
	CMusicTimeConverter cmtBeg;
	CMusicTimeConverter cmtEnd;

	MUSIC_TIME mtTime;
	REFERENCE_TIME rtTime;

	ASSERT( m_pTrackMgr != NULL );
	ASSERT( m_pTrackMgr->m_pTimeline != NULL );

	long lMeasure, lBeat, lGrid, lTick;

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		// Determine start time
		m_pTrackMgr->RefTimeToMinSecGridMs( this, pItem->m_rtTimePhysical, &lMeasure, &lBeat, &lGrid, &lTick );
		m_pTrackMgr->MinSecGridMsToRefTime( this, lMeasure, lBeat, 0, 0, &rtTime );
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtTime, &mtTime );
		cmtBeg = mtTime;

		// Determine end time
		m_pTrackMgr->MinSecGridMsToRefTime( this, lMeasure, (lBeat + 1), 0, 0, &rtTime );
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( rtTime, &mtTime );
		cmtEnd = mtTime;
	}
	else
	{
		// Determine start time
		m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)pItem->m_rtTimePhysical, &lMeasure, &lBeat, &lGrid, &lTick );
		m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtTime );
		cmtBeg = mtTime;

		// Determine end time
		m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, (lBeat + 1), 0, 0, &mtTime );
		cmtEnd = mtTime;
	}

	CSelectedRegion* psr = new CSelectedRegion( cmtBeg, cmtEnd );
	m_pSelectedRegions->AddHead( psr );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CListSelectedRegion_ToggleRegion

void CWaveStrip::CListSelectedRegion_ToggleRegion( long lXPos )
{
	ASSERT( m_pTrackMgr != NULL );

	MUSIC_TIME mtBeg;
	MUSIC_TIME mtEnd;

	// Snap XPos to measure/beat (or minute/second) boundary
	CMusicTimeConverter cmtBeg;
	CMusicTimeConverter cmtEnd;
	SnapPositionToStartEndClocks( lXPos, &mtBeg, &mtEnd );
	cmtBeg = mtBeg;
	cmtEnd = mtEnd;

	bool fToggled = false;

	// Get a pointer to the first item in the list
	POSITION posCur;
	POSITION pos = m_pSelectedRegions->GetHeadPosition();
	while( pos )
	{
		posCur = pos;
		CSelectedRegion* psr = m_pSelectedRegions->GetNext( pos );

		if( cmtBeg >= psr->Beg()
		&&  cmtBeg < psr->End() )
		{
			if( (psr->Beg() == cmtBeg) 
			&&  (psr->End() == cmtEnd) )
			{
				// Only this beat (or second) is in the selected regions, delete it
				m_pSelectedRegions->RemoveAt( posCur );
				delete psr;
			}
			else if( psr->Beg() == cmtBeg )
			{
				// The region to toggle is at the start of psr - shorten psr
				psr->Beg() = cmtEnd;

				// Check if this region is empty.  If so, delete it
				if( psr->Beg() == psr->End() )
				{
					m_pSelectedRegions->RemoveAt( posCur );
					delete psr;
				}
			}
			else
			{
				// Create a new CSelectedRegion for the first half
				CSelectedRegion *psrNew = new CSelectedRegion( psr->Beg(), cmtBeg );
				m_pSelectedRegions->InsertBefore( posCur, psrNew );

				// Modify the existing CSelectedRegion to display the second half
				psr->Beg() = cmtEnd;
			}
			fToggled = true;
			break;
		}
	}

	if( fToggled == false )
	{
		CListSelectedRegion_AddRegion( lXPos );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CListSelectedRegion_ShiftAddRegion

void CWaveStrip::CListSelectedRegion_ShiftAddRegion( long lXPos )
{
	MUSIC_TIME mtBeg;
	MUSIC_TIME mtEnd;

	// Snap XPos to measure/beat (or minute/second) boundary
	CMusicTimeConverter cmtBegX;
	CMusicTimeConverter cmtEndX;
	SnapPositionToStartEndClocks( lXPos, &mtBeg, &mtEnd );
	cmtBegX = mtBeg;
	cmtEndX = mtEnd;

	// Get the shift-select anchor position
	if( m_pSelectedRegions->IsEmpty() )
	{
		m_pSelectedRegions->SetShiftSelectAnchor( 0 );
	}
	long lShiftSelectAnchorPosition = m_pSelectedRegions->GetShiftSelectAnchor();

	// Snap anchor to measure/beat (or minute/second) boundary
	CMusicTimeConverter cmtBegAnchor;
	CMusicTimeConverter cmtEndAnchor;
	SnapPositionToStartEndClocks( lShiftSelectAnchorPosition, &mtBeg, &mtEnd );
	cmtBegAnchor = mtBeg;
	cmtEndAnchor = mtEnd;

	// Determine shift-select range
	if( cmtBegAnchor > cmtBegX )
	{
		cmtBegAnchor = cmtBegX;
	}
	if( cmtEndAnchor < cmtEndX )
	{
		cmtEndAnchor = cmtEndX;
	}

	// Delete all items in the selected region list
	while( !m_pSelectedRegions->IsEmpty() )
	{
		CSelectedRegion* psr = m_pSelectedRegions->RemoveHead();
		delete psr;
	}

	// Create a selected region and add to list
	CSelectedRegion* psr = new CSelectedRegion( cmtBegAnchor, cmtEndAnchor );
	m_pSelectedRegions->AddTail( psr );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::CListSelectedRegion_Contains

bool CWaveStrip::CListSelectedRegion_Contains( REFERENCE_TIME rtTime )
{
	MUSIC_TIME mtTime;
	m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtTime );

	if( m_pSelectedRegions->Contains( mtTime ) )
	{
		return true;
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::KillVariationTimer

void CWaveStrip::KillVariationTimer( void )
{
	if( m_fVariationsTimerActive )
	{
		::KillTimer( m_VerticalScrollBar.GetSafeHwnd(), 1 );
		m_fVariationsTimerActive = false;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::EnableVariationTimer

void CWaveStrip::EnableVariationTimer( void )
{
	if( !m_fVariationsTimerActive )
	{
		HWND hwnd = GetTimelineHWND();
		if( hwnd )
		{
			// If the scroll bar exists
			if( m_VerticalScrollBar.GetSafeHwnd() )
			{
				// Update the variations every 400ms
				if( ::SetTimer( m_VerticalScrollBar.GetSafeHwnd(), 1, 400, NULL ) )
				{
					m_fVariationsTimerActive = true;
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::UpdatePlayingVariation

void CWaveStrip::UpdatePlayingVariation( bool fRefreshDisplayIfNecessary )
{
	const DWORD dwCurPlayingVariation = m_dwPlayingVariation;

	m_dwPlayingVariation = 0;

	if( m_pTrackMgr->m_pIDMSegmentState
	&&	m_pTrackMgr->m_pIDMPerformance
	&&	m_pTrackMgr->m_pIDMTrack )
	{
		MUSIC_TIME mtNow;
		if( SUCCEEDED( m_pTrackMgr->m_pIDMPerformance->GetTime( NULL, &mtNow ) ) )
		{
			// Retrieve the track state parameter for our track
			DMUS_TRACK_STATE_PARAM trackStateParam;
			trackStateParam.pSegState = m_pTrackMgr->m_pIDMSegmentState;
			trackStateParam.pTrack = m_pTrackMgr->m_pIDMTrack;
			trackStateParam.pTrackState = NULL;
			if( SUCCEEDED( m_pTrackMgr->m_pIDMPerformance->GetParam(GUID_TrackState, 0xFFFFFFFF, 0,  mtNow, NULL, &trackStateParam) ) )
			{
				// Retrieve the currently playing variation for this track
				DMUS_CURRENT_VARIATION_PARAM curVarParam;
				curVarParam.dwPChannel = m_dwPChannel;
				curVarParam.dwVariation = 0;

				// Compute the index of this part
				curVarParam.dwIndex = 0;
				POSITION pos = m_pTrackMgr->m_lstWaveStrips.GetHeadPosition();
				while( pos )
				{
					// Get a pointer to the part ref
					CWaveStrip *pCWaveStrip = m_pTrackMgr->m_lstWaveStrips.GetNext( pos );

					// If we found ourself, exit the loop
					if( pCWaveStrip == this )
					{
						break;
					}

					// If this part ref is on the same PChannel, increment the index value
					if( pCWaveStrip->m_dwPChannel == m_dwPChannel )
					{
						curVarParam.dwIndex++;
					}
				}

				// Finally, try and retrieve the currently playing variation
				IDirectMusicTrack8 *pTrack8;
				if( SUCCEEDED( m_pTrackMgr->m_pIDMTrack->QueryInterface( IID_IDirectMusicTrack8, (void **)&pTrack8 ) ) )
				{
					if( SUCCEEDED( pTrack8->GetParamEx(GUID_CurrentVariation, 0, NULL, &curVarParam, trackStateParam.pTrackState, 0) ) )
					{
						m_dwPlayingVariation = curVarParam.dwVariation;
					}
					pTrack8->Release();
				}
			}
		}
	}

	if( fRefreshDisplayIfNecessary
	&&	(dwCurPlayingVariation != m_dwPlayingVariation) )
	{
		InvalidateVariationBtns();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::OnVariationTimer

void CWaveStrip::OnVariationTimer( void )
{
	UpdatePlayingVariation();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::EnsureFileIsOpen

IDMUSProdNode *CWaveStrip::EnsureFileIsOpen( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	IDMUSProdNode *pIDMUSProdNode = NULL;

	IStream *pStream;
	if( SUCCEEDED( pITimelineDataObject->AttemptRead( m_cfDMUSProdFile, &pStream ) ) )
	{
		CFProducerFile cfProducerFile;
		if( SUCCEEDED( LoadCF_DMUSPROD_FILE( pStream, &cfProducerFile ) ) )
		{
			m_pTrackMgr->m_pDMProdFramework->FindDocRootNodeByFileGUID( cfProducerFile.guidFile, &pIDMUSProdNode );
		}
	}

	return pIDMUSProdNode;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveStrip::LoadCF_DMUSPROD_FILE

HRESULT CWaveStrip::LoadCF_DMUSPROD_FILE( IStream* pIStream, CFProducerFile* pProducerFile )
{
	HRESULT hr = E_FAIL;
    IDMUSProdRIFFStream* pIRiffStream = NULL;
	CString strFileName;
    MMCKINFO ck;
	DWORD dwSize;
    WORD wStructSize;
	ioCFProducerFile iCFProducerFile;
	
	if( pIStream == NULL
	||  pProducerFile == NULL )
	{
		return E_INVALIDARG;
	}

    // Create RIFF stream
	hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	// Find the FOURCC_CF_DMUSPROD_FILE chunk header
	ck.ckid = FOURCC_CF_DMUSPROD_FILE;
    if( pIRiffStream->Descend( &ck, NULL, MMIO_FINDCHUNK ) != 0 )
    {
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Read size of ioCFProducerFile structure
    dwSize = ck.cksize;
    pIStream->Read( &wStructSize, sizeof( wStructSize ), NULL );
    dwSize -= sizeof( wStructSize );

	// Initialize ioCFProducerFile structure
	memset( &iCFProducerFile, 0, sizeof(ioCFProducerFile) );

	// Read ioCFProducerFile structure
    if( wStructSize > sizeof(ioCFProducerFile) )
    {
        pIStream->Read( &iCFProducerFile, sizeof(ioCFProducerFile), NULL );
        StreamSeek( pIStream, wStructSize - sizeof(ioCFProducerFile), STREAM_SEEK_CUR );
    }
    else
    {
        pIStream->Read( &iCFProducerFile, wStructSize, NULL );
    }
    dwSize -= wStructSize;

	// Read filename (unicode format)
	if( dwSize > 0 )
	{
		ReadMBSfromWCS( pIStream, dwSize, &strFileName );
	}

	pProducerFile->guidFile = iCFProducerFile.guidFile;
	pProducerFile->strFileName = strFileName;
	hr = S_OK;

ON_ERROR:
	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\TrackItem.h ===
#ifndef __WAVE_TRACKITEM_H_
#define __WAVE_TRACKITEM_H_

#include "WaveStripLayer.h"
#include <DMUSProd.h>
#include <dmusici.h>
#include <DLSDesigner.h>
#include <WaveTimelineDraw.h>

#pragma pack(2)

typedef struct FileListInfo
{
	FileListInfo()
	{
		pIProject = NULL;
		memset( &guidFile, 0, sizeof(GUID) );
	}

	IDMUSProdProject*	pIProject;
	CString				strProjectName;
	CString				strName;
	CString				strDescriptor;
	GUID				guidFile;
} FileListInfo;

typedef struct FileRef
{
	FileRef()
	{
		pIDocRootNode = NULL;
		fRemoveNotify = FALSE;
	}

	IDMUSProdNode*		pIDocRootNode;		// Pointer to referenced file's DocRoot node
	BOOL				fRemoveNotify;
	FileListInfo		li;
} FileRef;

typedef struct WaveInfo
{
	WaveInfo()
	{
		rtWaveLength = 0;
		dwWaveEnd = 0;
		fIsLooped = FALSE;
		dwLoopType = 0;
		dwLoopStart = 0;
		dwLoopEnd = 0;
		memset( &guidVersion, 0, sizeof(GUID) );
		fIsStreaming= FALSE;
	}

	REFERENCE_TIME	rtWaveLength;		// Length of the wave (in reference time)
	DWORD			dwWaveEnd;			// The end sample for the wave
	BOOL			fIsLooped;			// Is the wave looped?
	DWORD			dwLoopType;			// The type for this loop
	DWORD			dwLoopStart;		// The start sample for the loop
	DWORD			dwLoopEnd;			// The end sample for the loop
	GUID			guidVersion;		// Updated everytime wave changes
										// Used by download mechanosm
	BOOL			fIsStreaming;		// Is the wave streaming?
} WaveInfo;

#pragma pack()


class CTrackMgr;

// m_dwBitsUI
#define UD_DRAGSELECT		0x00000001


// Flags for SetTimePhysical()
#define STP_LOGICAL_NO_ACTION				1
#define STP_LOGICAL_SET_DEFAULT				2
#define STP_LOGICAL_ADJUST					3
#define STP_LOGICAL_FROM_BEAT_OFFSET		4


class CTrackItem
{
public:
	CTrackItem();
	CTrackItem( CTrackMgr* pTrackMgr, CWaveStrip* pWaveStrip );
	CTrackItem( CTrackMgr* pTrackMgr, CWaveStrip* pWaveStrip, const CTrackItem& );
	virtual ~CTrackItem();

	void Clear();
	void ClearListInfo();
	void Copy( const CTrackItem* pItem );

	BOOL After( const CTrackItem& item );
	BOOL Before( const CTrackItem& item );

	HRESULT SetFileReference( IDMUSProdNode* pINewDocRootNode );
	HRESULT SetListInfo( IDMUSProdFramework* pIFramework );
	HRESULT GetWaveInfo();
	void	FormatUIText( CString& strText );
	void	SwitchTimeBase();
	HRESULT	DrawWave( HDC hDC, LONG lXOffset, int nLayerIndex, WaveDrawParams* pWDP, WaveTimelineInfoParams* pWTIP );

	HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	HRESULT LoadTrackItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, IDMUSProdFramework* pIFramework );
	HRESULT SaveTrackItem( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdFramework* pIFramework );
	
	HRESULT SetTimePhysical( REFERENCE_TIME rtTimePhysical, short nAction );
	HRESULT SetTimeLogical( REFERENCE_TIME rtTimeLogical );
	HRESULT SetWaveStripForPropSheet( CWaveStrip* pWaveStrip );
	CWaveStrip* GetWaveStripForPropSheet() const;
	HRESULT SetTrackMgr( CTrackMgr* pTrackMgr );
	CTrackMgr* GetTrackMgr() const;
	REFERENCE_TIME PitchAdjustedStartOffset();
	HRESULT StartOffsetToUnknownTime( CTrackMgr* pTrackMgr, REFERENCE_TIME* prtStartOffset );
	HRESULT SourceWaveLengthToUnknownTime( CTrackMgr* pTrackMgr, REFERENCE_TIME* prtSourceWaveLength );

	HRESULT RefreshWave();

protected:	
	IDMUSProdNode* FindWaveFile( CString strWaveName, IStream* pIStream, IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	HRESULT SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdFramework* pIFramework, IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader );
	HRESULT SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdFramework* pIFramework, IDMUSProdNode* pIDocRootNode );

public:
	// Fields that are persisted
	REFERENCE_TIME	 m_rtTimeLogical;		// Belongs To 
	REFERENCE_TIME	 m_rtTimePhysical;		// Time of measure/beat/tick (REFERENCE_TIME or MUSIC_TIME)
	REFERENCE_TIME	 m_rtStartOffset;		// Distance into source wave to start playback (REFERENCE_TIME)
											// m_rtStartOffset is not adjusted for m_lPitch
	REFERENCE_TIME	 m_rtDuration;			// Duration (REFERENCE_TIME or MUSIC_TIME) 
	DWORD			 m_dwVariations;		// What variations this item belongs to
	DWORD			 m_dwFlagsDM;			// DirectMusic flags
	long			 m_lVolume;				// Gain, in 1/100th of dB. Note: All gain values should be negative
	long			 m_lPitch;				// Pitch offset in 1/100th of a semitone
	long			 m_lVolumeRange;		// Gain range, in 1/100th of dB. Note: All gain values should be negative
	long			 m_lPitchRange;         // Pitch range in 1/100th of a semitone
	FileRef			 m_FileRef;				// Info pertaining to referenced file

	// Loop fields
	BOOL			 m_fLoopedUI;			// This item is looped
    DWORD            m_dwLoopStartUI;		// Start point for a looping wave
    DWORD            m_dwLoopEndUI;			// End point for a looping wave
	BOOL			 m_fLockLoopLengthUI;	// State of 'Lock Loop Length' button (Loop Tab)
	BOOL			 m_fLockEndUI;			// State of 'Lock End' button (FileRef Tab)
	BOOL			 m_fLockLengthUI;		// State of 'Lock Length' button (FileRef Tab)

	// Work fields
	CWaveStripLayer* m_pLayer;				// Layer containing this wave
	WaveInfo		 m_WaveInfo;			// Info about wave retrieved from DLS Designer
	DWORD			 m_dwBitsUI;			// Various bits
	BOOL			 m_fSelected;			// This item is currently selected
	BOOL			 m_fSyncDuration;		// Always sync duration to actual length of wave
	int				 m_nPasteLayerIndex;	// Used in drop and paste operations

	// Drawing data
	RECT			 m_rectWave;			// Coords of drawn wave
	RECT			 m_rectSelect;			// Coords used for selection (includes text)

private:
	CTrackMgr*		 m_pTrackMgr;			// Will be NULL when CTrackItem used for properties
	CWaveStrip*		 m_pWaveStrip;			// Will be NULL when CTrackItem used for properties
};

#endif // __WAVE_TRACKITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\WaveStripMgr\WaveStripMgrDLL.cpp ===
// WaveStripMgrDLL.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "RiffStrm.h"
#include "resource.h"
#include "WaveStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include "TrackMgr.h"
#include <dmusici.h>
#include <dsoundp.h>
#include <dmusicp.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// ATL Stuff follows
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_WaveMgr, CTrackMgr)
END_OBJECT_MAP()

class CWaveStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CWaveStripMgrApp theApp;

BOOL CWaveStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CWaveStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusicProducer strip managers

static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Convert the Wave Strip Manager's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_WaveMgr, &psz) ) )
	{
		// Convert from an OLE string to a multi-byte string
		char szEditorCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorCLSID, sizeof(szEditorCLSID), NULL, NULL );

		// Free the memory used by the OLE string
		CoTaskMemFree( psz );

		// Convert the Wave Track's CLSID into an OLE string
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicWaveTrack, &psz) ) )
		{
			// Convert from an OLE string to a multi-byte string
			char szTrackCLSID[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );

			// Free the memory used by the OLE string
			CoTaskMemFree( psz );

			// Load the name of the track from the resource file
			CString strTrackName;
			strTrackName.LoadString( IDS_TRACK_NAME );

			// Build the path to the item in the registry to set
			TCHAR szRegPath[256];
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
			_tcscat( szRegPath, szTrackCLSID );

			// Set the default value to the track's name
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}

			// Set the CLSID of the Strip Manager editor to use to edit this track
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("StripManager"), szEditorCLSID)) )
			{
				return FALSE;
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes entries from the system registry for DirectMusicProducer strip managers

static BOOL UnregisterComponents( void )
{
	// Convert the Wave Track's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicWaveTrack, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Creates the DirectMusic Producer-specific registry entries
	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_WAVESTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	// unregisters object
	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Removes the DirectMusic Producer-specific registry entries
	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\Audiopath.cpp ===
// Audiopath.cpp : implementation file
//

#include "stdafx.h"
#include "Audiopath.h"
#include "XboxAddin.h"
#include "XboxAddinComponent.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <Xbox-dmusici.h>
#pragma warning ( pop )

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DWORD CAudiopath::m_sdwNextIndex = 0;

CAudiopath::CAudiopath( IDMUSProdNode *pDMUSProdNode, DWORD dwType ) : CFileItem(pDMUSProdNode)
{
	m_dwIndex = ++m_sdwNextIndex; // Must be one or greater
	m_fDefault = false;
	m_dwStandardType = dwType;
	m_dwStandardPChannels = 128;

	switch( dwType )
	{
	case DMUS_APATH_SHARED_STEREOPLUSREVERB:
		m_strDisplayName.LoadString( IDS_APATH_SHARED_STEREOPLUSREVERB );
		break;
	case DMUS_APATH_DYNAMIC_3D:
		m_strDisplayName.LoadString( IDS_APATH_DYNAMIC_3D );
		break;
	case DMUS_APATH_DYNAMIC_MONO:
		m_strDisplayName.LoadString( IDS_APATH_DYNAMIC_MONO );
		break;
	case DMUS_APATH_SHARED_STEREO:
		m_strDisplayName.LoadString( IDS_APATH_SHARED_STEREO );
		break;
	case DMUS_APATH_MIXBIN_QUAD:
		m_strDisplayName.LoadString( IDS_APATH_MIXBIN_QUAD );
		break;
	case DMUS_APATH_MIXBIN_QUAD_ENV:
		m_strDisplayName.LoadString( IDS_APATH_MIXBIN_QUAD_ENV );
		break;
	case DMUS_APATH_MIXBIN_QUAD_MUSIC:
		m_strDisplayName.LoadString( IDS_APATH_MIXBIN_QUAD_MUSIC );
		break;
	case DMUS_APATH_MIXBIN_5DOT1:
		m_strDisplayName.LoadString( IDS_APATH_MIXBIN_5DOT1 );
		break;
	case DMUS_APATH_MIXBIN_5DOT1_ENV:
		m_strDisplayName.LoadString( IDS_APATH_MIXBIN_5DOT1_ENV );
		break;
	case DMUS_APATH_MIXBIN_5DOT1_MUSIC:
		m_strDisplayName.LoadString( IDS_APATH_MIXBIN_5DOT1_MUSIC );
		break;
	case DMUS_APATH_MIXBIN_STEREO_EFFECTS:
		m_strDisplayName.LoadString( IDS_APATH_MIXBIN_STEREO_EFFECTS );
		break;
	}

	if( dwType )
	{
		m_strFileName = m_strDisplayName;
	}
}

HRESULT CAudiopath::CopyToXbox( void )
{
	HRESULT hr = S_OK;

	// Handle to the framework's progress bar
	HANDLE hProgressBar = NULL;

	// Check if this is a standard audiopath
	if( m_dwStandardType ) 
	{
		CString strRemoteCmd;
		char    szResp[MAX_PATH];
		DWORD   cchResp = MAX_PATH;

		strRemoteCmd.Format( TEXT(CMD_PREFIX "!createStandardAudiopath %d %d %d"), m_dwIndex, m_dwStandardType, m_dwStandardPChannels );

		// Send the command to the Xbox
		DmSendCommand(theApp.m_pdmConnection, strRemoteCmd, szResp, &cchResp);
	}
	else
	{
		hr = CFileItem::CopyToXbox();

		if( FAILED(hr) )
		{
			return hr;
		}

		// Initialize the progress bar
		CString strProgressText;
		strProgressText.FormatMessage( IDS_PROGRESS_CREATE, m_strDisplayName );
		theApp.m_pXboxAddinComponent->m_pIFramework->StartProgressBar( 0, 1, strProgressText.AllocSysString(), &hProgressBar );

		CString strTargetFile = theApp.m_strXboxDestination + TEXT("\\") + m_strFileName;
		CString strRemoteCmd;
		char    szResp[MAX_PATH];
		DWORD   cchResp = MAX_PATH;

		strRemoteCmd.Format( TEXT(CMD_PREFIX "!createAudiopath %d \"%s\""), m_dwIndex, strTargetFile );

		// Send the command to the Xbox
		DmSendCommand(theApp.m_pdmConnection, strRemoteCmd, szResp, &cchResp);
	}

	// Wait for the command to be processed
	Notification_Struct *pNotification_Struct = NULL;
	theApp.WaitForNotification( NOTIFICATION_CREATE_RESULT, &pNotification_Struct );
	if( !pNotification_Struct )
	{
		CString strLoadFailed;
    	strLoadFailed.FormatMessage( IDS_ERR_CREATE_TIMEOUT, GetName() );

    	while( IDRETRY == XboxAddinMessageBox( NULL, strLoadFailed, MB_ICONERROR | MB_RETRYCANCEL ) )
		{
			theApp.WaitForNotification( NOTIFICATION_CREATE_RESULT, &pNotification_Struct );
			if( pNotification_Struct )
			{
				break;
			}
		}

		if( !pNotification_Struct )
		{
			hr = E_FAIL;
		}
	}

	if( pNotification_Struct )
	{
		hr = pNotification_Struct->dwData1;
		if( FAILED( hr ) )
		{
			CString strLoadFailed;
    		strLoadFailed.FormatMessage( IDS_ERR_CREATE, GetName() );

    		XboxAddinMessageBox( NULL, strLoadFailed, MB_ICONERROR | MB_OK );
		}
		delete pNotification_Struct;
	}

	// Remove the progress bar
	if( hProgressBar )
	{
		theApp.m_pXboxAddinComponent->m_pIFramework->EndProgressBar( hProgressBar );
	}

	return hr;
}

HRESULT CAudiopath::Release( void )
{
	// Release the audiopath
	CString strRemoteCmd;
	char    szResp[MAX_PATH];
	DWORD   cchResp = MAX_PATH;

	strRemoteCmd.Format( TEXT(CMD_PREFIX "!releaseAudiopath %d "), m_dwIndex );

	// Send the command to the Xbox
	DmSendCommand(theApp.m_pdmConnection, strRemoteCmd, szResp, &cchResp);

	// Wait for the command to be processed
	Notification_Struct *pNotification_Struct = NULL;
	theApp.WaitForNotification( NOTIFICATION_RELEASE_RESULT, &pNotification_Struct );

	HRESULT hr = E_FAIL;

	if( pNotification_Struct )
	{
		hr = pNotification_Struct->dwData1;
		delete pNotification_Struct;
	}

	return hr;
}

HRESULT CAudiopath::SetDefault( bool fDefault )
{
	HRESULT hr = E_FAIL;

	// Update m_strDisplayName
	SetAppendValue( m_nAppendValue );

	if( fDefault )
	{
		// Send the command to the Xbox
		CString strRemoteCmd;
		char    szResp[MAX_PATH];
		DWORD   cchResp = MAX_PATH;
		strRemoteCmd.Format( TEXT(CMD_PREFIX "!setDefaultAudiopath %d "), m_dwIndex );
		DmSendCommand(theApp.m_pdmConnection, strRemoteCmd, szResp, &cchResp);

		// Wait for the command to be processed
		Notification_Struct *pNotification_Struct = NULL;
		theApp.WaitForNotification( NOTIFICATION_SETDEFAULT_RESULT, &pNotification_Struct );

		if( pNotification_Struct )
		{
			hr = pNotification_Struct->dwData1;
			if( FAILED( hr ) )
			{
				CString strLoadFailed;
    			strLoadFailed.FormatMessage( IDS_ERR_SETDEFAULT, GetName() );

    			XboxAddinMessageBox( NULL, strLoadFailed, MB_ICONERROR | MB_OK );
			}
			delete pNotification_Struct;
		}

		if( SUCCEEDED(hr) )
		{
			m_fDefault = true;

			// Update the display name
			CString strCurrentName = m_strDisplayName;
			m_strDisplayName.FormatMessage( IDS_DEFAULT_AUDIOPATH, strCurrentName );
		}
	}
	else if( m_fDefault )
	{
		m_fDefault = false;
		// Leave m_strDisplayName alone
		hr = S_OK;
	}

	return hr;
}

HRESULT CAudiopath::RemoveFromXbox( void )
{
	// If audiopath is based on a file, remove it
	if( m_pFileNode )
	{
		return CFileItem::RemoveFromXbox();
	}

	// Otherwise, return S_OK
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\Audiopath.h ===
#if !defined(AFX_AUDIOPATH_H__45DF9671_11A3_4073_9CE0_6F8456E61502__INCLUDED_)
#define AFX_AUDIOPATH_H__45DF9671_11A3_4073_9CE0_6F8456E61502__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Audiopath.h : header file
//

#include "FileItem.h"

/////////////////////////////////////////////////////////////////////////////
// CAudiopath class

class CAudiopath : public CFileItem
{
public:
	CAudiopath( IDMUSProdNode *pDMUSProdNode, DWORD dwType );
	HRESULT CopyToXbox( void );
	HRESULT Release( void );
	HRESULT SetDefault( bool fDefault );
	inline bool IsDefault( void ) const { return m_fDefault; }
	virtual HRESULT RemoveFromXbox( void );

	DWORD			m_dwIndex;
	DWORD			m_dwStandardType;
	DWORD			m_dwStandardPChannels;

protected:
	bool			m_fDefault;
	static DWORD	m_sdwNextIndex;
};


#endif // !defined(AFX_AUDIOPATH_H__45DF9671_11A3_4073_9CE0_6F8456E61502__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\AudiopathListBox.cpp ===
// AudiopathListBox.cpp : implementation file
//

#include "stdafx.h"
#include "xboxaddin.h"
#include "AudiopathListBox.h"
#include "Audiopath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAudiopathListBox

CAudiopathListBox::CAudiopathListBox()
{
}

CAudiopathListBox::~CAudiopathListBox()
{
}


BEGIN_MESSAGE_MAP(CAudiopathListBox, CFileListBox)
	//{{AFX_MSG_MAP(CAudiopathListBox)
	ON_WM_DRAWITEM_REFLECT()
	ON_WM_RBUTTONUP()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAudiopathListBox message handlers

void CAudiopathListBox::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// Get the Audiopath
	CAudiopath *pAudiopath = reinterpret_cast<CAudiopath *>(lpDrawItemStruct->itemData);
	if( !pAudiopath )
	{
		return;
	}

	// if we're drawing a real item and the item is to be completely
	// draw or drawn as if it is selected, then ...

	if (((LONG)(lpDrawItemStruct->itemID) >= 0) &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
	{
		// set up the text color and the background color
		COLORREF oldTextColor, oldBkColor;
		if ( (lpDrawItemStruct->itemState & ODS_SELECTED) != 0 )
		{
			oldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
			oldBkColor = ::SetBkColor( lpDrawItemStruct->hDC, ::GetFocus() == m_hWnd ? ::GetSysColor(COLOR_HIGHLIGHT) : ::GetSysColor(COLOR_INACTIVECAPTION) );
		}
		else
		{
			oldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_WINDOWTEXT) );
			oldBkColor = ::SetBkColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_WINDOW) );
		}

		// Draw the (un)selected background
		::ExtTextOut( lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &lpDrawItemStruct->rcItem, NULL, 0, NULL);

		// File Name
		::DrawText( lpDrawItemStruct->hDC, pAudiopath->GetName(), -1, &lpDrawItemStruct->rcItem, DT_SINGLELINE | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );

		// restore the old objects in the DC
		::SetTextColor( lpDrawItemStruct->hDC, oldTextColor );
		::SetBkColor( lpDrawItemStruct->hDC, oldBkColor);
	}

	// if the item is focused, draw the focus rectangle
	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
	{
		::DrawFocusRect( lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem) );
	}
}

void CAudiopathListBox::OnRButtonUp(UINT nFlags, CPoint point) 
{
	BOOL bOutside = TRUE;
	int nIndex = ItemFromPoint( point, bOutside );

	CAudiopath *pAudiopath = NULL;
	if( !bOutside )
	{
		pAudiopath = reinterpret_cast<CAudiopath *>(GetItemDataPtr( nIndex ));
	}

	HMENU hMenuMain = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_AUDIOPATH_MENU) );
	if( hMenuMain )
	{
		HMENU hSubMenu = ::GetSubMenu( hMenuMain, 0 );
		if( hSubMenu )
		{
			if( !pAudiopath )
			{
				::EnableMenuItem( hSubMenu, ID_SET_DEFAULT, MF_GRAYED | MF_BYCOMMAND );
				::EnableMenuItem( hSubMenu, ID_DELETE_AUDIOPATH, MF_GRAYED | MF_BYCOMMAND );
			}
			else if( pAudiopath->IsDefault() )
			{
				// Already default item
				::EnableMenuItem( hSubMenu, ID_SET_DEFAULT, MF_GRAYED | MF_BYCOMMAND );
			}


			POINT pt;
			::GetCursorPos( &pt );
			int nChosenCommand = ::TrackPopupMenu( hSubMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON, pt.x, pt.y, 0, GetSafeHwnd(), NULL );

			if( nChosenCommand )
			{
				::SendMessage( ::GetParent( GetSafeHwnd() ), WM_APP, (WPARAM)nChosenCommand, (LPARAM)pAudiopath );
			}
		}
	}
	else
	{
		CFileListBox::OnRButtonUp(nFlags, point);
	}
}

void CAudiopathListBox::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if( VK_DELETE == nChar )
	{
		// Delete the currently selected item
		int nIndex = GetCurSel();
		if( nIndex != LB_ERR )
		{
			CAudiopath *pAudiopath = reinterpret_cast<CAudiopath *>(GetItemDataPtr( nIndex ));
			if( pAudiopath )
			{
				::SendMessage( ::GetParent( GetSafeHwnd() ), WM_APP, ID_DELETE_AUDIOPATH, (LPARAM)pAudiopath );
			}
		}
	}
	
	CFileListBox::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\AudiopathListBox.h ===
#if !defined(AFX_AUDIOPATHLISTBOX_H__6FBD1C60_49BE_459B_9B81_0B0065D6169B__INCLUDED_)
#define AFX_AUDIOPATHLISTBOX_H__6FBD1C60_49BE_459B_9B81_0B0065D6169B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "FileListBox.h"

// AudiopathListBox.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAudiopathListBox window

class CAudiopathListBox : public CFileListBox
{
// Construction
public:
	CAudiopathListBox();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAudiopathListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAudiopathListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CAudiopathListBox)
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUDIOPATHLISTBOX_H__6FBD1C60_49BE_459B_9B81_0B0065D6169B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\Droptarget.cpp ===
// DropTarget.cpp : implementation file
// For OLE Drag and Drop between tree controls
// Designed and developed by Vinayak Tadas
// vinayakt@aditi.com
// Modified for use in DirectMusic Producer by James Dooley
// jdooley@microsoft.com
// 

#include "stdafx.h"
#include "Droptarget.h"
#include "XboxAddin.h"

#define RECT_BORDER 10

/////////////////////////////////////////////////////////////////////////////
// CDropTarget

CDropTarget::CDropTarget()
{
	m_pITargetDataObject = NULL;
	m_pDropControl = NULL;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_cRef = 0;
	AddRef();
}

HRESULT CDropTarget::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualIID(riid, IID_IDropTarget)
	||	::IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IDropTarget *)this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CDropTarget::AddRef( void )
{
	return InterlockedIncrement( &m_cRef );
}

ULONG CDropTarget::Release( void )
{
	const long lRes = InterlockedDecrement( &m_cRef );
	if( lRes == 0 )
	{
		delete this;
	}

	return lRes;
}

/********************************************************************
OnDragEnter()
	Called when the user drags the object in control.
********************************************************************/
HRESULT CDropTarget::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL point, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Release the target data object, if we haven't already done so (we should have)
	RELEASE( m_pITargetDataObject );

	// Validate the pointer to the IDataObject
	if( pIDataObject )
	{
		// Store IDataObject associated with current drag-drop operation
		m_pITargetDataObject = pIDataObject;
		m_pITargetDataObject->AddRef();

		// Determine effect of drop
		return DragOver( grfKeyState, point, pdwEffect );
	}
	else
	{
		return E_POINTER;
	}
}

/********************************************************************
OnDragOver()
	Called when the user drags the object over control.
********************************************************************/
		
HRESULT CDropTarget::DragOver( DWORD grfKeyState, POINTL pointl, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate our pointers
	if( (m_pDropControl == NULL)
	||	(m_pITargetDataObject == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	*pdwEffect = DROPEFFECT_NONE;

	m_pDropControl->InternalDragOver( grfKeyState, pointl, m_pITargetDataObject, pdwEffect );

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = *pdwEffect;
	}

	return S_OK;
}


/********************************************************************
OnDragLeave()
	Called when the user drags the object out of control.
********************************************************************/
HRESULT CDropTarget::DragLeave( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate our pointer
	if( m_pDropControl == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Release our pointer to the object being dragged
	RELEASE( m_pITargetDataObject );

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	// Remove Highlighting
	m_pDropControl->InternalDragLeave();

	return S_OK;
}


/********************************************************************
OnDrop()
	Called when the user drops the object in the control.
********************************************************************/
HRESULT CDropTarget::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL point, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(grfKeyState);

	if( (pdwEffect == NULL)
	||	(pIDataObject == NULL) )
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	// Validate our pointer
	if( m_pDropControl == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	m_pDropControl->InternalDrop( pIDataObject, point, m_dwOverDragEffect );

	*pdwEffect = m_dwOverDragEffect;

	// Release the target data object, if we haven't already done so (we should have)
	RELEASE( m_pITargetDataObject );

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\Droptarget.h ===
#if !defined(AFX_DROPTARGET_H__345241C3_897C_11D3_A59E_00A02411D21E__INCLUDED_)
#define AFX_DROPTARGET_H__345241C3_897C_11D3_A59E_00A02411D21E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DropTarget.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDropTarget

class CDropControl
{
public:
	virtual void InternalDragOver( DWORD grfKeyState, POINTL ptScreen, IDataObject* pIDataObject, DWORD* pdwEffect ) = 0;
	virtual void InternalDrop( IDataObject* pIDataObject, POINTL ptScreen, DWORD dwEffect) = 0;
	virtual void InternalDragLeave( void ) = 0;
};

class CDropTarget :public IDropTarget	
{
public:
	CDropTarget();

	// IUnknown functions
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL point, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL point, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL point, DWORD* pdwEffect);

// Members
public:
	CDropControl	*m_pDropControl;

private:
	IDataObject 	*m_pITargetDataObject;
	DWORD			m_dwOverDragButton;
	DWORD			m_dwOverDragEffect;
	long			m_cRef;

};
/////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_DROPTARGET_H__345241C3_897C_11D3_A59E_00A02411D21E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\FileItem.h ===
#if !defined(AFX_FILEITEM_H__52ED9541_11B3_4073_9CE0_6F8456E61502__INCLUDED_)
#define AFX_FILEITEM_H__52ED9541_11B3_4073_9CE0_6F8456E61502__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FileItem.h : header file
//

interface IDMUSProdNode;

/////////////////////////////////////////////////////////////////////////////
// CFileItem class

class CFileItem
{
public:
	CFileItem( IDMUSProdNode *pDMUSProdNode );
	~CFileItem();
	CString GetFileName( void ) const
	{
		return m_strFileName;
	}
	CString GetName( void ) const
	{
		return m_strDisplayName;
	}
	virtual HRESULT CopyToXbox( void );
	virtual HRESULT RemoveFromXbox( void );
	virtual bool UsesFile( const CFileItem *pFileItem );
	bool ContainsNode( const IDMUSProdNode *pNode );
	void SetAppendValue( int nNewAppendValue );

	IDMUSProdNode	*m_pFileNode;
	int				m_nAppendValue;

protected:
	static HRESULT CreateUniqueTempFile(CString sPrefix, CString sExtension, CString& sTempFileName);
	static IDMUSProdNode *FindChildNode( IDMUSProdNode *pDMUSProdNode, REFGUID rguidNodeId );
	static void GetRefsFromStyleBands( IDMUSProdNode *pDMUSProdNode, DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode, DWORD dwErrorLength, WCHAR *wcstrErrorText );
	static void GetContainerNodes( bool fRefNodes, IDMUSProdNode *pDMUSProdNode, DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode );
	HRESULT CopyNodeReferences( IDMUSProdNode *pDMUSProdNode, bool &fDisplayMessageBoxOnError );

	CString 		m_strFileName;
	CString			m_strDisplayName;
	CString			m_strSourcePath;
	CTypedPtrList<CPtrList, IDMUSProdNode *> m_lstReferencedNodes;
	CTypedPtrList<CPtrList, IDMUSProdNode *> m_lstEmbeddedNodes;
};


#endif // !defined(AFX_FILEITEM_H__52ED9541_11B3_4073_9CE0_6F8456E61502__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\FileListBox.cpp ===
// FileListBox.cpp : implementation file
//

#include "stdafx.h"
#include "xboxaddin.h"
#include "FileListBox.h"
#include "FileItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileListBox

CFileListBox::CFileListBox()
{
}

CFileListBox::~CFileListBox()
{
}


BEGIN_MESSAGE_MAP(CFileListBox, CListBox)
	//{{AFX_MSG_MAP(CFileListBox)
	ON_WM_RBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileListBox message handlers

int CFileListBox::CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct) 
{
	// Get the File Items
	CFileItem *pFileItem1 = reinterpret_cast<CFileItem *>(lpCompareItemStruct->itemData1);
	CFileItem *pFileItem2 = reinterpret_cast<CFileItem *>(lpCompareItemStruct->itemData2);
	if( !pFileItem1 || !pFileItem2 )
	{
		return 0;
	}

    return pFileItem1->GetName().CompareNoCase( pFileItem2->GetName() );
}

int CFileListBox::IndexFromFile( void *pVoid )
{
	for( int nIndex = GetCount() - 1; nIndex >= 0; nIndex-- )
	{
		if( GetItemDataPtr( nIndex ) == pVoid )
		{
			return nIndex;
		}
	}

	return LB_ERR;
}

void CFileListBox::OnRButtonDown(UINT nFlags, CPoint point) 
{
	BOOL bOutside = TRUE;
	int nIndex = ItemFromPoint( point, bOutside );

	if( !bOutside )
	{
		SetCurSel( nIndex );
	}

	CListBox::OnRButtonDown(nFlags, point);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\FileItem.cpp ===
// FileItem.cpp : implementation file
//

#include "stdafx.h"
#include "FileItem.h"
#include "dmusprod.h"
#include "XboxAddin.h"
#include "XboxAddinComponent.h"
#include "DMPPrivate.h"
#include "GetNodesErrorDlg.h"
#include "DllJazzDataObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HRESULT CFileItem::CreateUniqueTempFile(CString sPrefix, CString sExtension, CString& sTempFileName)
{
	if(sExtension.IsEmpty())
	{
		sExtension = "tmp";
	}

	CString sFileExt = "." + sExtension;

	char szTempPath[MAX_PATH];
	DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
	CString sTempPath = szTempPath;	

	GUID guidFileName;
	if(dwSuccess && SUCCEEDED(::CoCreateGuid(&guidFileName)))
	{
		LPOLESTR psz;
		if( SUCCEEDED( ::StringFromIID(guidFileName, &psz) ) )
		{
			TCHAR szGuid[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );
			
			sTempFileName = sTempPath + sPrefix + szGuid + sFileExt;

			CFile tempFile;
			try
			{
				tempFile.Open(sTempFileName, CFile::modeCreate);
				tempFile.Close();
			}
			catch(CFileException e)
			{
				return E_FAIL;
			}

			return S_OK;
		}
	}

	return E_FAIL;
}

IDMUSProdNode *CFileItem::FindChildNode( IDMUSProdNode *pDMUSProdNode, REFGUID rguidNodeId )
{
	// Get the first child node
	IDMUSProdNode *pChildNode;
	HRESULT hr = pDMUSProdNode->GetFirstChild( &pChildNode );

	while( SUCCEEDED(hr) && pChildNode )
	{
		GUID guidNode;

		// Get the node's ID
		hr = pChildNode->GetNodeId( &guidNode );

		if( SUCCEEDED(hr) )
		{
			// Is this the one?
			if( guidNode == rguidNodeId )
			{
				return pChildNode;
			}
		}

		// Check if any of the child node's children match this guid
		IDMUSProdNode *pNextChildNode = FindChildNode( pChildNode, rguidNodeId );

		// Yes
		if( pNextChildNode )
		{
			// Release pChildNode and return pNextChildNOde
			pChildNode->Release();
			return pNextChildNode;
		}

		// No - get the next child node
		hr = pDMUSProdNode->GetNextChild( pChildNode, &pNextChildNode );

		// Release the current node
		pChildNode->Release();

		// If we found a next node, make it the current node
		if( SUCCEEDED(hr) )
		{
			pChildNode = pNextChildNode;
		}
	}

	// Didn't find the node
	return NULL;
}

void CFileItem::GetRefsFromStyleBands( IDMUSProdNode *pDMUSProdNode, DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode, DWORD dwErrorLength, WCHAR *wcstrErrorText )
{
	// Find the style's band folder
	IDMUSProdNode *pBandFolderNode = FindChildNode( pDMUSProdNode, GUID_StyleBandFolderNode );

	HRESULT hr = E_FAIL;

	// Get the first band
	IDMUSProdNode *pChildNode = NULL;
	if( pBandFolderNode )
	{
		hr = pBandFolderNode->GetFirstChild( &pChildNode );
	}

	// Index into ppIDMUSProdNode to start writing the nodes at
	// Doubles as the count of nodes that we've written into the array
	DWORD dwIndex = 0;

	while( SUCCEEDED(hr) && pChildNode )
	{
		// QI for the IDMUSProdGetReferencedNodes interface
		IDMUSProdGetReferencedNodes *pIDMUSProdGetReferencedNodes;
		hr = pChildNode->QueryInterface( IID_IDMUSProdGetReferencedNodes, (void **)&pIDMUSProdGetReferencedNodes );

		// Get the referenced nodes from this band
		if( SUCCEEDED(hr) )
		{
			// If we have an array of nodes, and we haven't filled it yet
			if( ppIDMUSProdNode
			&&	*pdwArraySize > dwIndex )
			{
				// Calculate the size left in the array
				DWORD dwSize = (*pdwArraySize) - dwIndex;

				// Ask the band node to fill in the array
				HRESULT hr = pIDMUSProdGetReferencedNodes->GetReferencedNodes( &dwSize, &(ppIDMUSProdNode[dwIndex]), dwErrorLength, wcstrErrorText );

				// If successful, increment dwIndex
				if( SUCCEEDED(hr) )
				{
					dwIndex += dwSize;
				}
			}
			else
			{
				// Ask the band node how many array items it requires
				DWORD dwSize = 0;
				HRESULT hr = pIDMUSProdGetReferencedNodes->GetReferencedNodes( &dwSize, NULL, dwErrorLength, wcstrErrorText );

				// If successful, increment dwIndex
				if( SUCCEEDED(hr) )
				{
					dwIndex += dwSize;
				}
			}
			pIDMUSProdGetReferencedNodes->Release();
		}

		// Get the next child node
		IDMUSProdNode *pNextChildNode;
		hr = pBandFolderNode->GetNextChild( pChildNode, &pNextChildNode );

		// Release the current node
		pChildNode->Release();

		// If we found a next node, make it the current node
		if( SUCCEEDED(hr) )
		{
			pChildNode = pNextChildNode;
		}
	}

	// Release the band folder node
	if( pBandFolderNode )
	{
		pBandFolderNode->Release();
	}

	// Store the number of nodes we returned (or that we require)
	*pdwArraySize = dwIndex;
}

void CFileItem::GetContainerNodes( bool fRefNodes, IDMUSProdNode *pDMUSProdNode, DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode )
{
	// Find the container's folder
	IDMUSProdNode *pFolderNode;
	if( fRefNodes )
	{
		pFolderNode = FindChildNode( pDMUSProdNode, GUID_ContainerRefFolderNode );
	}
	else
	{
		pFolderNode = FindChildNode( pDMUSProdNode, GUID_ContainerEmbedFolderNode );
	}

	HRESULT hr = E_FAIL;

	// Get the first node
	IDMUSProdNode *pChildNode = NULL;
	if( pFolderNode )
	{
		hr = pFolderNode->GetFirstChild( &pChildNode );
	}

	// Index into ppIDMUSProdNode to start writing the nodes at
	// Doubles as the count of nodes that we've written into the array
	DWORD dwIndex = 0;

	while( SUCCEEDED(hr) && pChildNode)
	{
		// Get the node this reference points to
		IDataObject *pIDataObject;
		hr = pChildNode->CreateDataObject( &pIDataObject );

		if( SUCCEEDED(hr) )
		{
			IDMUSProdNode *pTargetNode;
			hr = theApp.m_pXboxAddinComponent->m_pIFramework->GetDocRootNodeFromData( pIDataObject, &pTargetNode );
			if( SUCCEEDED(hr) )
			{
				// If we have an array of nodes, and we haven't filled it yet
				if( ppIDMUSProdNode
				&&	*pdwArraySize > dwIndex )
				{
					// Add the node to the array
					ppIDMUSProdNode[dwIndex] = pTargetNode;
					ppIDMUSProdNode[dwIndex]->AddRef();
				}

				// Always increment dwIndex
				dwIndex++;

				pTargetNode->Release();
			}
			pIDataObject->Release();
		}

		// Get the next child node
		IDMUSProdNode *pNextChildNode;
		hr = pFolderNode->GetNextChild( pChildNode, &pNextChildNode );

		// Release the current node
		pChildNode->Release();

		// If we found a next node, make it the current node
		if( SUCCEEDED(hr) )
		{
			pChildNode = pNextChildNode;
		}
	}

	// Release the reference folder node
	if( pFolderNode )
	{
		pFolderNode->Release();
	}

	// Store the number of nodes we returned (or that we require)
	*pdwArraySize = dwIndex;
}

CFileItem::CFileItem( IDMUSProdNode *pDMUSProdNode )
{
	m_nAppendValue = 0;
	m_pFileNode = pDMUSProdNode;
	if( pDMUSProdNode )
	{
		pDMUSProdNode->AddRef();

		HRESULT hr;
		BSTR bstrTemp;
		hr = theApp.m_pXboxAddinComponent->m_pIFramework->GetNodeFileName( pDMUSProdNode, &bstrTemp );

		CString strFileName;
		GUID guidNode = GUID_NULL;
		if( SUCCEEDED(hr) )
		{
			strFileName = bstrTemp;

			// Only use the part after the last backslash
			int nBackSlash = strFileName.ReverseFind( _T('\\') );
			if( nBackSlash > 0 )
			{
				strFileName = strFileName.Right( strFileName.GetLength() - nBackSlash - 1 );
			}

			// Free the BSTR
			::SysFreeString( bstrTemp );

			hr = pDMUSProdNode->GetNodeId( &guidNode );
		}

		IDMUSProdDocType *pIDMUSProdDocType = NULL;
		if( SUCCEEDED(hr) )
		{
			hr = theApp.m_pXboxAddinComponent->m_pIFramework->FindDocTypeByNodeId( guidNode, &pIDMUSProdDocType );
		}

		IDMUSProdDocType8 *pIDMUSProdDocType8 = NULL;
		if( SUCCEEDED(hr) )
		{
			hr = pIDMUSProdDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDMUSProdDocType8 );
		}

		if( SUCCEEDED(hr) )
		{
			hr = pIDMUSProdDocType8->GetObjectExt( guidNode, FT_RUNTIME, &bstrTemp );
		}

		if( SUCCEEDED(hr) )
		{
			CString strExtension = bstrTemp;

			// Free the BSTR
			::SysFreeString( bstrTemp );

			// Strip off the extension (including the period)
			int nPeriod = strFileName.ReverseFind( _T('.') );
			if( nPeriod > 0 )
			{
				strFileName = strFileName.Left( nPeriod );
			}

			// Add on the runtime extension
			strFileName = strFileName + strExtension;
		}

		if( !strFileName.IsEmpty() )
		{
			// If we have a filename, store it
			m_strDisplayName = m_strFileName = strFileName;
		}

		if( pIDMUSProdDocType8 )
		{
			pIDMUSProdDocType8->Release();
		}

		if( pIDMUSProdDocType )
		{
			pIDMUSProdDocType->Release();
		}
	}
}

CFileItem::~CFileItem()
{
	RELEASE( m_pFileNode );

	while( !m_lstReferencedNodes.IsEmpty() )
	{
		m_lstReferencedNodes.RemoveHead()->Release();
	}

	while( !m_lstEmbeddedNodes.IsEmpty() )
	{
		m_lstEmbeddedNodes.RemoveHead()->Release();
	}
}

HRESULT CFileItem::CopyToXbox( void )
{
	HRESULT hr = S_OK;

	// Flag if this function displays an error message box (so that we don't display
	// another one below).
	bool fDisplayMessageBoxOnError = true;

	// Ensure all our embedded and referenced nodes are available
	hr = CopyNodeReferences( m_pFileNode, fDisplayMessageBoxOnError );

	// QI for the IPersistStream interface
	IPersistStream *pIPersistStream = NULL;
	if( SUCCEEDED(hr) )
	{
		hr = m_pFileNode->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
	}

	// Create a temporary file name
	CString strTempFileName;
	if( SUCCEEDED(hr) )
	{
		hr = CreateUniqueTempFile( TEXT("Xbox"), TEXT(""), strTempFileName );
	}

	// Create a file stream for the temporary file
	IStream *pIStream = NULL;
	if( SUCCEEDED(hr) )
	{
		hr = theApp.m_pXboxAddinComponent->m_pIFramework->AllocFileStream(
			strTempFileName.AllocSysString(),
			GENERIC_WRITE,
			FT_RUNTIME,
			GUID_CurrentVersion,
			NULL,
			&pIStream);
	}

	// Handle to the framework's progress bar
	HANDLE hProgressBar = NULL;

	if( SUCCEEDED(hr) )
	{
		// Initialize the progress bar
		CString strProgressText;
		strProgressText.FormatMessage( IDS_PROGRESS_FILE, m_strDisplayName );
		theApp.m_pXboxAddinComponent->m_pIFramework->StartProgressBar( 0, 2, strProgressText.AllocSysString(), &hProgressBar );

		// Save the file to the temporary file
		hr = pIPersistStream->Save( pIStream, FALSE );
	}

	// Release the stream
	RELEASE( pIStream );

	if( SUCCEEDED(hr) )
	{
		// Update the progress bar
		if( hProgressBar )
		{
			theApp.m_pXboxAddinComponent->m_pIFramework->SetProgressBarPos( hProgressBar, 1 );
		}

		// Copy the temporary file to the Xbox
		CString strTargetFile = theApp.m_strXboxDestination + TEXT("\\") + m_strFileName;
		hr = DmSendFile( strTempFileName, strTargetFile );

		// Update the progress bar
		if( hProgressBar )
		{
			theApp.m_pXboxAddinComponent->m_pIFramework->SetProgressBarPos( hProgressBar, 2 );
		}
	}

	// Delete the temporary file
	if( !strTempFileName.IsEmpty() )
	{
		// Delete the created temp file
		DeleteFile(strTempFileName);
	}

	// Release the IPersistStream interface
	if( pIPersistStream )
	{
		pIPersistStream->Release();
	}

	// Remove the progress bar
	if( hProgressBar )
	{
		theApp.m_pXboxAddinComponent->m_pIFramework->EndProgressBar( hProgressBar );
	}

	if( FAILED(hr) && fDisplayMessageBoxOnError )
	{
		CString strErrorText;
		strErrorText.FormatMessage( IDS_ERR_COPY, m_strFileName );
		XboxAddinMessageBox( NULL, strErrorText, MB_ICONERROR | MB_OK );
	}

	return hr;
}

HRESULT CFileItem::RemoveFromXbox( void )
{
	CString strRemoteCmd;
	char    szResp[MAX_PATH];
	DWORD   cchResp = MAX_PATH;

	// Clear the cache
	DmSendCommand(theApp.m_pdmConnection, TEXT(CMD_PREFIX "!clearCache"), szResp, &cchResp);

	// Wait for the command to be processed
	theApp.WaitForNotification( NOTIFICATION_CLEARCACHE_RESULT );

	// Delete the file from the Xbox
	CString strTargetFile = theApp.m_strXboxDestination + TEXT("\\") + m_strFileName;

	HRESULT hr = DmDeleteFile( strTargetFile, FALSE );

	// Ignore 'file not found' error
	if( hr == XBDM_NOSUCHFILE )
	{
		hr = XBDM_NOERR;
	}
	return hr;
}

bool CFileItem::UsesFile( const CFileItem *pFileItem )
{
	POSITION pos = m_lstReferencedNodes.GetHeadPosition();
	while( pos )
	{
		if( pFileItem->m_pFileNode == m_lstReferencedNodes.GetNext( pos ) )
		{
			return true;
		}
	}

	return false;
}

bool CFileItem::ContainsNode( const IDMUSProdNode *pNode )
{
	if( pNode == m_pFileNode )
	{
		return true;
	}

	POSITION pos = m_lstEmbeddedNodes.GetHeadPosition();
	while( pos )
	{
		if( pNode == m_lstEmbeddedNodes.GetNext( pos ) )
		{
			return true;
		}
	}

	return false;
}

HRESULT CFileItem::CopyNodeReferences( IDMUSProdNode *pDMUSProdNode, bool &fDisplayMessageBoxOnError )
{
	HRESULT hr = S_OK;

	// QI for the IDMUSProdGetReferencedNodes interface
	IDMUSProdGetReferencedNodes *pIDMUSProdGetReferencedNodes = NULL;
	pDMUSProdNode->QueryInterface( IID_IDMUSProdGetReferencedNodes, (void **)&pIDMUSProdGetReferencedNodes );

	WCHAR wcstrErrorText[8192];
	ZeroMemory( wcstrErrorText, sizeof(WCHAR) * 8192 );

	// Ask for size of the array of referenced nodes
	DWORD dwArraySize = 0;
	DWORD dwReferencedNodesSize = 0;
	if( pIDMUSProdGetReferencedNodes )
	{
		pIDMUSProdGetReferencedNodes->GetReferencedNodes( &dwReferencedNodesSize, NULL, 8191, wcstrErrorText );
		dwArraySize = dwReferencedNodesSize;
	}

	// Get the referenced nodes from a style
	DWORD dwStyleSize = 0;
	GetRefsFromStyleBands( pDMUSProdNode, &dwStyleSize, NULL, 8191, wcstrErrorText );
	dwArraySize += dwStyleSize;

	// Get the referenced nodes from a container in a segment, script, or song
	DWORD dwFullArraySize = 0;
	GetContainerNodes( true, pDMUSProdNode, &dwFullArraySize, NULL );
	dwFullArraySize += dwArraySize;

	// Get the embedded nodes from a container in a segment, script, or song
	DWORD dwEmbedArraySize = 0;
	GetContainerNodes( false, pDMUSProdNode, &dwEmbedArraySize, NULL );

	// Create the array and get the list of referenced nodes
	IDMUSProdNode **apIDMUSProdNode = NULL;
	if( dwFullArraySize )
	{
		apIDMUSProdNode = new IDMUSProdNode *[dwFullArraySize];
	}

	// Fill in the array
	if( apIDMUSProdNode )
	{
		if( pIDMUSProdGetReferencedNodes )
		{
			pIDMUSProdGetReferencedNodes->GetReferencedNodes( &dwFullArraySize, apIDMUSProdNode, 0, NULL );
		}

		// Get the referenced nodes from a style
		dwArraySize = dwFullArraySize - dwReferencedNodesSize;
		GetRefsFromStyleBands( pDMUSProdNode, &dwArraySize, &(apIDMUSProdNode[dwReferencedNodesSize]), 0, NULL );

		// Get the referenced nodes from a container in a segment, script, or song
		dwArraySize = dwFullArraySize - dwReferencedNodesSize - dwStyleSize;
		GetContainerNodes( true, pDMUSProdNode, &dwArraySize, &(apIDMUSProdNode[dwReferencedNodesSize + dwStyleSize]) );
	}

	// Create the array and get the list of embedded nodes
	IDMUSProdNode **apIDMUSProdNodeEmbedded = NULL;
	if( dwEmbedArraySize )
	{
		apIDMUSProdNodeEmbedded = new IDMUSProdNode *[dwEmbedArraySize];
	}

	// Fill in the array
	if( apIDMUSProdNodeEmbedded )
	{
		// Get the embedded nodes from a container in a segment, script, or song
		GetContainerNodes( false, pDMUSProdNode, &dwEmbedArraySize, apIDMUSProdNodeEmbedded );
	}

	// If there is an error message, display it
	if( wcstrErrorText[0] )
	{
		CGetNodesErrorDlg getNodesErrorDlg;
		getNodesErrorDlg.m_strErrorText = wcstrErrorText;
		getNodesErrorDlg.DoModal();

		hr = E_FAIL;

		// Set to false, since we already displayed an error message
		fDisplayMessageBoxOnError = false;
	}

	// Now, ensure each of these nodes are in our lists
	if( SUCCEEDED(hr) )
	{
		if( apIDMUSProdNodeEmbedded )
		{
			// First, add the node to our list
			for( DWORD i=0; i < dwEmbedArraySize; i++ )
			{
				m_lstEmbeddedNodes.AddHead( apIDMUSProdNodeEmbedded[i] );

				// AddRef it
				apIDMUSProdNodeEmbedded[i]->AddRef();
			}

			// Then ensure that all their references are copied
			for( i=0; i < dwEmbedArraySize && SUCCEEDED(hr); i++ )
			{
				hr = CopyNodeReferences( apIDMUSProdNodeEmbedded[i], fDisplayMessageBoxOnError );
			}
		}

		if( apIDMUSProdNode )
		{
			for( DWORD i=0; i < dwFullArraySize && SUCCEEDED(hr); i++ )
			{
				hr = theApp.m_pXboxAddinComponent->EnsureNodeIsCopied( apIDMUSProdNode[i] );

				// Add the node to our list
				m_lstReferencedNodes.AddHead( apIDMUSProdNode[i] );

				// AddRef it
				apIDMUSProdNode[i]->AddRef();
			}
		}
	}

	// Now, delete the array and release all of the nodes
	if( apIDMUSProdNode )
	{
		// Release the nodes
		for( DWORD i=0; i < dwFullArraySize; i++ )
		{
			if( apIDMUSProdNode[i] )
			{
				apIDMUSProdNode[i]->Release();
			}
		}
		delete[] apIDMUSProdNode;
		apIDMUSProdNode = NULL;
	}

	// Now, delete the array and release all of the nodes
	if( apIDMUSProdNodeEmbedded )
	{
		// Release the nodes
		for( DWORD i=0; i < dwEmbedArraySize; i++ )
		{
			if( apIDMUSProdNodeEmbedded[i] )
			{
				apIDMUSProdNodeEmbedded[i]->Release();
			}
		}
		delete[] apIDMUSProdNodeEmbedded;
		apIDMUSProdNodeEmbedded = NULL;
	}

	// Release the interface
	RELEASE( pIDMUSProdGetReferencedNodes );

	return hr;
}

void CFileItem::SetAppendValue( int nNewAppendValue )
{
	m_nAppendValue = nNewAppendValue;

	// Set the file's display name
	
	// Set the base name
	m_strDisplayName = m_strFileName;

	// Append a (#) if necessary
	if( m_nAppendValue )
	{
		CString strAppend;
		strAppend.Format( TEXT(" (%d)"), m_nAppendValue );
		m_strDisplayName += strAppend;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\FileListBox.h ===
#if !defined(AFX_FILELISTBOX_H__C9DE6DD0_DAD1_4B19_848C_F23B44BA860F__INCLUDED_)
#define AFX_FILELISTBOX_H__C9DE6DD0_DAD1_4B19_848C_F23B44BA860F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FileListBox.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFileListBox window

class CFileListBox : public CListBox
{
// Construction
public:
	CFileListBox();

// Attributes
public:

// Operations
public:
	int IndexFromFile( void *pVoid );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileListBox)
	public:
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFileListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFileListBox)
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILELISTBOX_H__C9DE6DD0_DAD1_4B19_848C_F23B44BA860F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\GetNodesErrorDlg.cpp ===
// GetNodesErrorDlg.cpp : implementation file
//

#include "stdafx.h"
#include "xboxaddin.h"
#include "GetNodesErrorDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGetNodesErrorDlg dialog


CGetNodesErrorDlg::CGetNodesErrorDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGetNodesErrorDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGetNodesErrorDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


BEGIN_MESSAGE_MAP(CGetNodesErrorDlg, CDialog)
	//{{AFX_MSG_MAP(CGetNodesErrorDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetNodesErrorDlg message handlers

BOOL CGetNodesErrorDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	SetDlgItemText( IDC_EDIT_REFERENCES, m_strErrorText );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\HSplitter.h ===
#ifndef __HSPLITTER_H__
#define __HSPLITTER_H__

// HSplitter.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHSplitter class

#define DEFAULTSPLITTERHEIGHT (6)
#define MINSPLITTERYPOS (30)

class CEndTrack : public CDialog
{
public:
	CEndTrack(UINT nIDTemplate,CWnd* pParentWnd ) : CDialog( nIDTemplate, pParentWnd ) {}
    virtual void EndTrack( long lNewPos ) = 0;
};


class CHSplitter : public CWnd
{
protected:
   CRect	m_rcFirstPane;
   CRect	m_rcSecondPane;

   CWnd		*m_pFirstPane;
   CWnd		*m_pSecondPane;

   CRect	m_rcTrack;
   BOOL		m_fTracking;
   BOOL		m_fVisible;
   CEndTrack		*m_pParent;
   int		m_nHeight;
   long     m_lHeightOffset;

public:
   CHSplitter();
   BOOL Create(CEndTrack *pParent, RECT *rect = NULL);
   RECT	GetFirstPaneRect();
   RECT	GetSecondPaneRect();
   void SetFirstPane( CWnd *pPane );
   void SetSecondPane( CWnd *pPane );
   void SetTracker(RECT& rect)
   {
	   m_rcTrack = rect;
   }
   void SetHeightOffset(long lOffset)
   {
       m_lHeightOffset = lOffset;
       m_rcFirstPane.top = lOffset;
   }

protected:
   void OnEndCapture();
   void InvertTracker();

   //{{AFX_VIRTUAL(CHSplitter)
   //}}AFX_VIRTUAL

public:
   virtual ~CHSplitter();

protected:
   //{{AFX_MSG(CHSplitter)
   afx_msg void OnPaint();
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnCancelMode();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
   afx_msg void OnCaptureChanged(CWnd *pWnd);
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __HSPLITTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\HSplitter.cpp ===
// HSplitter.cpp : implementation file
//

#include "stdafx.h"
#include "HSplitter.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//*****************************************************************************
//***** CHSplitter
//*****************************************************************************

BEGIN_MESSAGE_MAP(CHSplitter, CWnd)
	//{{AFX_MSG_MAP(CHSplitter)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_SETCURSOR()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_WM_CAPTURECHANGED()
END_MESSAGE_MAP()

//*****************************************************************************
CHSplitter::CHSplitter() :
	m_rcTrack(0, 0, 0, 0),
	m_fTracking(FALSE),
	m_fVisible(FALSE),
	m_pParent(NULL),
	m_nHeight(0),
	m_rcFirstPane(0, 0, 0, 0),
	m_rcSecondPane(0, 0, 0, 0),
	m_pFirstPane(NULL),
	m_pSecondPane(NULL),
    m_lHeightOffset(0)
{
}

//*****************************************************************************
CHSplitter::~CHSplitter()
{
}

//*****************************************************************************
BOOL CHSplitter::Create( CEndTrack *pParent, RECT *rect )
{
	// Save our parent
	m_pParent = pParent;

	if( rect )
	{
		RECT tempRect;
		m_pParent->GetWindowRect( &tempRect );
				
		m_rcTrack = *rect;
		m_rcSecondPane = m_rcFirstPane = m_rcTrack;

		m_rcFirstPane.top = m_lHeightOffset;
		m_rcFirstPane.bottom = m_rcTrack.top-1;
		m_rcSecondPane.top = m_rcTrack.bottom+1;
		m_rcSecondPane.bottom = tempRect.bottom;

		m_nHeight = rect->bottom - rect->top;
		ASSERT( m_nHeight > 0 );
	}

	// Create our splitter class
	WNDCLASS wc;

	ZeroMemory( &wc, sizeof(wc) );
	wc.lpszClassName = "DittoHSplitterClass";
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = ::DefWindowProc;
	wc.hInstance     = AfxGetInstanceHandle();
	wc.hCursor       = LoadCursor( NULL, IDC_SIZENS );
	wc.hbrBackground = (HBRUSH)( COLOR_BTNFACE + 1 );

	// Register our splitter class
	AfxRegisterClass( &wc );

	// Create our splitter
	return CWnd::Create( wc.lpszClassName, "", WS_VISIBLE | WS_CHILD, 
						 m_rcTrack, pParent, IDC_HSPLITTER );
}

//*****************************************************************************
void CHSplitter::OnPaint()
{
	RECT rc;

	// Make sure Splitter bar and panes are updated when
	// the parent resizes.
	m_pParent->GetClientRect( &rc );
	m_rcTrack.right = rc.right;

	MoveWindow( &m_rcTrack, FALSE );

	// Resize First Pane
	m_rcFirstPane.bottom = m_rcTrack.top;
	m_rcFirstPane.right = m_rcTrack.right;

	// Resize Second Pane
	m_rcSecondPane.top = m_rcTrack.bottom;
	m_rcSecondPane.right = m_rcTrack.right;
	m_rcSecondPane.bottom = rc.bottom;

	// Resize First Pane
	m_pFirstPane->MoveWindow( &m_rcFirstPane );

	// Resize Second Pane Window
	m_pSecondPane->MoveWindow( &m_rcSecondPane );

	// Paint Scroll Bar
	CPaintDC dc( this );
	GetClientRect( &rc );
	dc.Draw3dRect( &rc, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW));
}

//*****************************************************************************
void CHSplitter::OnLButtonDown( UINT /*nFlags*/, CPoint /*point*/ )
{
	ASSERT( m_pParent != NULL );

	// Capture the mouse
	SetCapture();

	// Set our initial splitter position in our main frame's client coordinates
	GetWindowRect( &m_rcTrack );
	m_pParent->ScreenToClient( &m_rcTrack );
	//m_rcTrack.top++; m_rcTrack.bottom--; m_rcTrack.right--;

	// Set our tracking flag
	m_fTracking = TRUE;

	// Draw our initial tracker
	InvertTracker();
}

//*****************************************************************************
void CHSplitter::OnLButtonUp(UINT /*nFlags*/, CPoint /*point*/)
{
	ASSERT( m_pParent != NULL );
	BOOL fWasTracking = m_fTracking;

	OnEndCapture();
	
	if(fWasTracking)
	{
		RECT rect;
		m_pParent->GetClientRect( &rect );
		m_pParent->EndTrack( m_rcTrack.bottom - m_lHeightOffset );

		MoveWindow(	&m_rcTrack );
		OnPaint();

		m_pFirstPane->InvalidateRect( NULL );
		m_pSecondPane->InvalidateRect( NULL );
	}
}

//*****************************************************************************
void CHSplitter::OnMouseMove( UINT /*nFlags*/, CPoint point )
{
	if( m_fTracking )
	{
		// Convert our point to client coordinates of our frame
		ClientToScreen( &point );
		m_pParent->ScreenToClient( &point );

		// Get the client are of our frame
		CRect rcClient;
		m_pParent->GetClientRect( &rcClient );

		// Force the point to be in our client area
		if( (point.y + 34) > rcClient.bottom)
		{
			point.y = rcClient.bottom - 34;
		}
		if( (point.y - m_lHeightOffset) < rcClient.top )
		{
			point.y = rcClient.top + m_lHeightOffset;
		}

		// If the point has changed since the last mouse move, then update change
		if( m_rcTrack.top != (point.y - 1) )
		{
			InvertTracker();
//			if(point.y < CPersonalityCtrl::MinSplitterYPos)
//			{
//				point.y = CPersonalityCtrl::MinSplitterYPos;
//			}
			m_rcTrack.top  = point.y - (m_nHeight>>1);
			m_rcTrack.bottom = point.y + (m_nHeight>>1);
			m_rcTrack.right = rcClient.right;
			InvertTracker();
		}
	}
}

//*****************************************************************************
void CHSplitter::OnCancelMode()
{
	OnEndCapture();
	CWnd::OnCancelMode();
}

//*****************************************************************************
void CHSplitter::OnCaptureChanged( CWnd *pWnd )
{
	OnEndCapture();
	CWnd::OnCaptureChanged( pWnd );
}

//*****************************************************************************
void CHSplitter::OnEndCapture()
{
	if( m_fVisible )
	{
		InvertTracker();
	}

	if( m_fTracking )
	{
		ReleaseCapture();
		m_fTracking = FALSE;
	}
}

//*****************************************************************************
void CHSplitter::InvertTracker()
{
	ASSERT( m_pParent );

	// Get the DC of our main frame
	CDC *pDC = m_pParent->GetDC();

	ASSERT( pDC );

	CRgn rgnNew, rgnOrig;
	rgnOrig.CreateRectRgn( 0, 0, 1, 1 );
	RECT rect;
	m_pParent->GetClientRect( &rect );
	rgnNew.CreateRectRgn( rect.left, rect.top, rect.right, rect.bottom );
	::GetClipRgn( pDC->GetSafeHdc(), rgnOrig );
	pDC->SelectClipRgn( &rgnNew, RGN_COPY );

	pDC->GetClipBox( &rect );

	// Create our inverted brush pattern (looks just like frame window sizing)
	CBrush *pBrush = CDC::GetHalftoneBrush();

	// Select the brush into our DC  
	HBRUSH hBrushStock = NULL;
	if( pBrush != NULL )
	{
		hBrushStock = (HBRUSH)SelectObject( pDC->m_hDC, pBrush->m_hObject );
	}

	// Draw our tracking line
	pDC->PatBlt( m_rcTrack.left, m_rcTrack.top, m_rcTrack.Width(), m_rcTrack.Height(), PATINVERT );

	// Free our brush and DC
	if (hBrushStock != NULL)
	{
		SelectObject( pDC->m_hDC, hBrushStock );
	}
	pDC->SelectClipRgn( &rgnOrig );
	ReleaseDC( pDC );

	// Toggle visible flag
	m_fVisible = !m_fVisible;

	rgnNew.DeleteObject();
	rgnOrig.DeleteObject();
}

BOOL CHSplitter::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	return (pWnd == this)?CWnd::OnSetCursor(pWnd, nHitTest, message):FALSE;
}

RECT CHSplitter::GetFirstPaneRect()
{	
	return m_rcFirstPane;
}

RECT CHSplitter::GetSecondPaneRect()
{
	return m_rcSecondPane;
}

void CHSplitter::SetFirstPane( CWnd *pPane )
{
	m_pFirstPane = pPane;
}

void CHSplitter::SetSecondPane( CWnd *pPane )
{
	m_pSecondPane = pPane;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\GetNodesErrorDlg.h ===
#if !defined(AFX_GETNODESERRORDLG_H__80154D9B_4DD7_4CFE_9BE0_75C6FB18F2E4__INCLUDED_)
#define AFX_GETNODESERRORDLG_H__80154D9B_4DD7_4CFE_9BE0_75C6FB18F2E4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GetNodesErrorDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGetNodesErrorDlg dialog

class CGetNodesErrorDlg : public CDialog
{
// Construction
public:
	CGetNodesErrorDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGetNodesErrorDlg)
	enum { IDD = IDD_GETNODES_ERROR };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	CString m_strErrorText;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetNodesErrorDlg)
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGetNodesErrorDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GETNODESERRORDLG_H__80154D9B_4DD7_4CFE_9BE0_75C6FB18F2E4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\LeftPaneDlg.cpp ===
// LeftPaneDlg.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "XboxAddinComponent.h"
#include "XboxAddinDlg.h"
#include "LeftPaneDlg.h"
#include "Audiopath.h"
#include "PrimaryDlg.h"
#include "SecondaryDlg.h"
#include "dmpprivate.h"
#include "DllJazzDataObject.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <Xbox-dmusici.h>
#pragma warning ( pop )
#include "Segment.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLeftPaneDlg dialog


CLeftPaneDlg::CLeftPaneDlg(CWnd* pParent /*=NULL*/)
: CEndTrack(CLeftPaneDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLeftPaneDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_wSplitterPos = 0;
    m_pPrimaryDlg = NULL;
    m_pSecondaryDlg = NULL;
	m_plstAudiopaths = &theApp.m_pXboxAddinComponent->m_lstAudiopaths;
	m_cfFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfAudiopath = ::RegisterClipboardFormat( CF_AUDIOPATH );
}

CLeftPaneDlg::~CLeftPaneDlg()
{
    while( !m_lstAudiopathsToSynchronize.IsEmpty() )
    {
        delete m_lstAudiopathsToSynchronize.RemoveHead();
    }
	if( m_pPrimaryDlg )
	{
		delete m_pPrimaryDlg;
		m_pPrimaryDlg = NULL;
	}
	if( m_pSecondaryDlg )
	{
		delete m_pSecondaryDlg;
		m_pSecondaryDlg = NULL;
	}
}

void CLeftPaneDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLeftPaneDlg)
	DDX_Control(pDX, IDC_STATIC_AUDIOPATH, m_staticAudiopath);
	DDX_Control(pDX, IDC_LIST_AUDIOPATH, m_listAudiopath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLeftPaneDlg, CDialog)
	//{{AFX_MSG_MAP(CLeftPaneDlg)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_MESSAGE(WM_APP,OnApp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLeftPaneDlg message handlers

BOOL CLeftPaneDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // Resize the panes
    /*
    RECT rectClient;
    GetClientRect( &rectClient );
    OnSize( SIZE_RESTORED, rectClient.right, rectClient.bottom );
    */

	ASSERT( m_plstAudiopaths );

    POSITION pos = m_plstAudiopaths->GetHeadPosition();
    while( pos )
    {
        m_listAudiopath.AddString( (LPCTSTR) m_plstAudiopaths->GetNext( pos ) );
    }

	m_DropTarget.m_pDropControl = this;
	::RegisterDragDrop( m_listAudiopath.GetSafeHwnd(), &m_DropTarget );
	
    UpdateListBoxPositions();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

int CLeftPaneDlg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// Create the Splitter and position it in the Editor
	// (temporary values added until coords are saved to design-time file)
	RECT rect;
	rect.left = lpCreateStruct->x;
    rect.right = lpCreateStruct->cx;
    rect.top = lpCreateStruct->y;
	rect.bottom = rect.top + DEFAULTSPLITTERHEIGHT;

	m_wndHSplitter.Create( this, &rect );

	// Create the Secondary segment dialog and position it in the First Splitter Pane
	m_pSecondaryDlg = new CSecondaryDlg;
	if( m_pSecondaryDlg == NULL )
	{
		return -1;
	}

	// Point the Secondary segment dialog back to us and at the AudioPath object
	m_pSecondaryDlg->Create( IDD_SEGMENT, this );
	m_pSecondaryDlg->ShowWindow( SW_SHOW );
	m_wndHSplitter.SetFirstPane( m_pSecondaryDlg );

	// Create the Primary segment and position it in the Second Splitter Pane
	m_pPrimaryDlg = new CPrimaryDlg;
	if( m_pPrimaryDlg == NULL )
	{
		return -1;
	}

	// Point the EffectList dialog back to us and at the AudioPath object
	//m_pEffectListDlg->m_pAudioPath = m_pAudioPath;
	//m_pEffectListDlg->m_pAudioPathCtrl = this;
	m_pPrimaryDlg->Create( IDD_SEGMENT, this );
	m_pPrimaryDlg->ShowWindow( SW_SHOW );
	m_wndHSplitter.SetSecondPane( m_pPrimaryDlg );
	
	return 0;
}

void CLeftPaneDlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);

    UpdateListBoxPositions();
}

void CLeftPaneDlg::UpdateListBoxPositions( void )
{
    if( m_staticAudiopath.GetSafeHwnd() == NULL )
    {
        return;
    }

    RECT rectClient;
    GetClientRect( &rectClient );

    // Update width of audiopath boxes
    RECT rect;
    m_staticAudiopath.GetClientRect( &rect );
    rect.right = rectClient.right;
    rect.bottom += 2 * ::GetSystemMetrics(SM_CYBORDER);
    m_staticAudiopath.MoveWindow( &rect );

    RECT rectList;
    m_listAudiopath.GetClientRect( &rectList );
    rect.top = rect.bottom;
    rect.bottom += rectList.bottom + 2 * ::GetSystemMetrics(SM_CYEDGE);
    m_listAudiopath.MoveWindow( &rect );

    // Save height offset
    long lHeightOffset = rect.bottom;
    m_wndHSplitter.SetHeightOffset( lHeightOffset );

    // get splitter position from audio path
	WORD pos = m_wSplitterPos;

	// calculate where splitter should be
	if(pos == 0)
	{
		// put it right in the middle
		pos = WORD(min( USHRT_MAX, (rectClient.bottom - DEFAULTSPLITTERHEIGHT)/2 ));

		// save it
        m_wSplitterPos = pos;
	}

    // Update splitter position, if it's non-zero
	if( pos != 0 )
	{
		// splitter is right side of chord dialog and left side
		// of signpost dialog
		rect.bottom = lHeightOffset + max( DEFAULTSPLITTERHEIGHT, pos );
		rect.top = rect.bottom - DEFAULTSPLITTERHEIGHT;
		m_wndHSplitter.SetTracker(rect);
		m_wndHSplitter.MoveWindow( &rect, TRUE );
		m_pSecondaryDlg->MoveWindow(0, lHeightOffset, rect.right, rect.top);
		m_pPrimaryDlg->MoveWindow(0, rect.bottom, rect.right, rectClient.bottom - rect.bottom);
	}
}

void CLeftPaneDlg::EndTrack( long lNewPos )
{
    m_wSplitterPos = (WORD)lNewPos;
}

void CLeftPaneDlg::OnConnectionStateChanged( void )
{
	ASSERT( m_plstAudiopaths );
	if( theApp.m_fConnected
	&&	0 == m_plstAudiopaths->GetCount() )
	{
		AddStandard( DMUS_APATH_SHARED_STEREOPLUSREVERB );
	}

	m_staticAudiopath.EnableWindow( theApp.m_fConnected );
	m_listAudiopath.EnableWindow( theApp.m_fConnected );

	m_pSecondaryDlg->OnConnectionStateChanged();
	m_pPrimaryDlg->OnConnectionStateChanged();
}

bool CLeftPaneDlg::IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode )
{
	return m_pPrimaryDlg->IsNodeDisplayed( pIDMUSProdNode ) || m_pSecondaryDlg->IsNodeDisplayed( pIDMUSProdNode );
}

HRESULT CLeftPaneDlg::AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode )
{
	return m_pPrimaryDlg->AddNodeToDisplay( pIDMUSProdNode );
}

void CLeftPaneDlg::HandleNotification( NOTIFICATION_TYPE notificationType, DWORD dwSegmentID, DWORD dwData1 )
{
	m_pSecondaryDlg->HandleNotification( notificationType, dwSegmentID, dwData1 );
	m_pPrimaryDlg->HandleNotification( notificationType, dwSegmentID, dwData1 );
}

void CLeftPaneDlg::OnPanic( void )
{
	m_pSecondaryDlg->OnPanic();
	m_pPrimaryDlg->OnPanic();
}

bool CLeftPaneDlg::IsFileInUse( CFileItem *pFileItem )
{
	return m_pPrimaryDlg->IsFileInUse( pFileItem ) || m_pSecondaryDlg->IsFileInUse( pFileItem );
}

void CLeftPaneDlg::UnloadAll( void )
{
	m_pSecondaryDlg->UnloadAll();
	m_pPrimaryDlg->UnloadAll();
}

void CLeftPaneDlg::DeleteAll( void )
{
	ASSERT( m_plstAudiopaths );

	// Copy the audiopaths to a temporary list and delete them from the Xbox
	while( !m_plstAudiopaths->IsEmpty() )
	{
		CAudiopath *pAudiopath = m_plstAudiopaths->RemoveHead();
		m_lstAudiopathsToSynchronize.AddHead( pAudiopath );
        pAudiopath->Release();
		pAudiopath->RemoveFromXbox();
	}

	m_pSecondaryDlg->DeleteAll();
	m_pPrimaryDlg->DeleteAll();

	// Now, clean up the display
	theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->CleanUpDisplay();
}

void CLeftPaneDlg::ReCopyAll( void )
{
	// Clear the display
    m_listAudiopath.ResetContent();

	// Re-add the audiopaths
	IDMUSProdProject *pIDMUSProdProject;
	while( !m_lstAudiopathsToSynchronize.IsEmpty() )
	{
		// Remove the audiopath from our temporary list
		CAudiopath *pAudiopath = m_lstAudiopathsToSynchronize.RemoveHead();

		// Check if this is a standard audiopath, or if the node still exists
		pIDMUSProdProject = NULL;
		if( pAudiopath->m_dwStandardType
        ||  (SUCCEEDED( theApp.m_pXboxAddinComponent->m_pIFramework->FindProject( pAudiopath->m_pFileNode, &pIDMUSProdProject ) )
			 && pIDMUSProdProject) )
		{
			// Yes - add the audiopath to the display
            AddAudiopathToList( new CAudiopath( pAudiopath->m_pFileNode, pAudiopath->m_dwStandardType ) );
			if( pIDMUSProdProject )
			{
				pIDMUSProdProject->Release();
			}
		}

		// Delete the temporary audiopath
		delete pAudiopath;
	}

    m_pSecondaryDlg->ReCopyAll();
	m_pPrimaryDlg->ReCopyAll();
}

void CLeftPaneDlg::InternalDragOver( DWORD grfKeyState, POINTL ptScreen, IDataObject* pIDataObject, DWORD* pdwEffect )
{
	UNREFERENCED_PARAMETER( grfKeyState );
	UNREFERENCED_PARAMETER( ptScreen );
	if( !theApp.m_fConnected )
	{
		*pdwEffect = DROPEFFECT_NONE;
		return;
	}

	/*
	// Highlight the item under the mouse 
	CMultiTree *pDestTreeCtrl = &(m_pAudioPathDlg->m_tcTree);
	POINT point = {pointl.x, pointl.y};
	pDestTreeCtrl->ScreenToClient( &point );

	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	pDestTreeCtrl->GetItemBufferEffectUnderPoint( point, &pItemInfo, &pBufferOptions, NULL );
	*/

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject )
	{
		/*
		if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_cfAudiopath ) ) )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else*/ if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_cfFile ) ) )
		{
			IDMUSProdNode *pIDMUSProdNode = NULL;
			if( theApp.m_pXboxAddinComponent
			&&	theApp.m_pXboxAddinComponent->m_pIFramework
			&&	SUCCEEDED( theApp.m_pXboxAddinComponent->m_pIFramework->GetDocRootNodeFromData( pIDataObject, &pIDMUSProdNode ) ) )
			{
				GUID guidNode = GUID_NULL;
				if( SUCCEEDED( pIDMUSProdNode->GetNodeId( &guidNode ) )
				&&	guidNode == GUID_AudioPathNode)
				{
					dwEffect = DROPEFFECT_COPY;
				}
				pIDMUSProdNode->Release();
			}
		}

		delete pDataObject;
	}

	*pdwEffect = dwEffect;
}

void CLeftPaneDlg::InternalDrop( IDataObject* pIDataObject, POINTL ptScreen, DWORD dwEffect)
{
	UNREFERENCED_PARAMETER( ptScreen );

	if( dwEffect != DROPEFFECT_COPY )
	{
		return;
	}

	// Display a wait cursor - this may take a while
	CWaitCursor waitCursor;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject )
	{
		IDMUSProdNode *pIDMUSProdNode = NULL;
		/*
		if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_cfAudiopath ) ) )
		{
		}
		else*/ if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_cfFile ) ) )
		{
			if( theApp.m_pXboxAddinComponent
			&&	theApp.m_pXboxAddinComponent->m_pIFramework
			&&	SUCCEEDED( theApp.m_pXboxAddinComponent->m_pIFramework->GetDocRootNodeFromData( pIDataObject, &pIDMUSProdNode ) ) )
			{
				GUID guidNode = GUID_NULL;
				if( SUCCEEDED( pIDMUSProdNode->GetNodeId( &guidNode ) )
				&&	guidNode == GUID_AudioPathNode)
				{
					// Add it to our internal list and the display
					AddAudiopathToDisplay( ptScreen, pIDMUSProdNode );
				}
				pIDMUSProdNode->Release();
			}
		}
		delete pDataObject;
	}

	/*
	//Remove highlighting
	//m_pAudioPathDlg->m_tcTree.SendMessage(TVM_SELECTITEM, TVGN_DROPHILITE,0);

	POINT ptShort = {point.x, point.y};
	m_pAudioPathDlg->m_tcTree.ScreenToClient( &ptShort );

	HRESULT hr = m_pAudioPathDlg->DropOnTree( pIDataObject, m_dwOverDragEffect, ptShort );
	*/
}

void CLeftPaneDlg::InternalDragLeave( void )
{
	if( theApp.m_fConnected )
	{
		//m_pAudioPathDlg->m_tcTree.SendMessage(TVM_SELECTITEM, TVGN_DROPHILITE,0);
	}
}

void CLeftPaneDlg::AddAudiopathToDisplay( POINTL ptScreen, IDMUSProdNode *pIDMUSProdNode )
{
	ASSERT( m_plstAudiopaths );
	if( m_plstAudiopaths->GetCount() < MAX_NUM_AUDIOPATHS )
	{
		// Create the audiopath item and add it to our list
		AddAudiopathToList( new CAudiopath( pIDMUSProdNode, 0 ) );
	}
}

void CLeftPaneDlg::SetDefault( CAudiopath *pAudiopath )
{
	ASSERT( m_plstAudiopaths );
	if( SUCCEEDED( pAudiopath->SetDefault( true ) ) )
	{
		POSITION pos = m_plstAudiopaths->GetHeadPosition();
		while( pos )
		{
			CAudiopath *pTemp = m_plstAudiopaths->GetNext( pos );
			if( pTemp != pAudiopath )
			{
				pTemp->SetDefault( false );
			}
		}

		m_listAudiopath.Invalidate( TRUE );
	}
}

void CLeftPaneDlg::AddStandard( DWORD dwType )
{
	ASSERT( m_plstAudiopaths );
	if( m_plstAudiopaths->GetCount() < MAX_NUM_AUDIOPATHS )
	{
		// Create the audiopath item and add it to our list
		AddAudiopathToList( new CAudiopath( NULL, dwType ) );
	}
}

void CLeftPaneDlg::DeleteAudiopath( CAudiopath *pAudiopath )
{
	// Release it on the Xbox
	if( FAILED( pAudiopath->Release() ) )
	{
		CString strErrorText;
		strErrorText.FormatMessage( IDS_ERR_RELEASE_AUDIOPATH, pAudiopath->GetName() );
		XboxAddinMessageBox( this, strErrorText, MB_ICONERROR | MB_OK );
		return;
	}

	// Remove it from the Xbox
	if( FAILED( pAudiopath->RemoveFromXbox() ) )
	{
		CString strErrorText;
		strErrorText.FormatMessage( IDS_ERR_REMOVE_AUDIOPATH, pAudiopath->GetName() );
		XboxAddinMessageBox( this, strErrorText, MB_ICONERROR | MB_OK );
		return;
	}

	// Remove it from our list
	ASSERT( m_plstAudiopaths );
	POSITION pos = m_plstAudiopaths->Find( pAudiopath, NULL );
	if( pos )
	{
		m_plstAudiopaths->RemoveAt( pos );
	}

	// Remove it from the display
	if( m_listAudiopath.GetSafeHwnd() )
	{
		int nIndex = m_listAudiopath.IndexFromFile( pAudiopath );
		if( nIndex != LB_ERR )
		{
			m_listAudiopath.DeleteString( nIndex );
		}
	}

	// Remove it from any segments that were referencing it
	pos = theApp.m_pXboxAddinComponent->m_lstPrimarySegments.GetHeadPosition();
	while( pos )
	{
		CSegment *pSegment = theApp.m_pXboxAddinComponent->m_lstPrimarySegments.GetNext( pos );
		if( pSegment->m_pAudiopath == pAudiopath )
		{
			pSegment->m_pAudiopath = NULL;
		}
	}

	// If it was the default audiopath, set another audiopath to be the default one
	if( pAudiopath->IsDefault()
	&&	m_plstAudiopaths->GetCount() )
	{
		if( m_listAudiopath.GetSafeHwnd() )
		{
			CAudiopath *pTmpAudiopath = (CAudiopath *)m_listAudiopath.GetItemDataPtr( 0 );
			if( pTmpAudiopath)
			{
				pTmpAudiopath->SetDefault( true );
				m_listAudiopath.Invalidate( TRUE );
			}
		}
		else
		{
			m_plstAudiopaths->GetHead()->SetDefault( true );
		}
	}

	// Delete it
	delete pAudiopath;
}

LRESULT CLeftPaneDlg::OnApp(WPARAM wParam, LPARAM lParam)
{
	// Command from list box right-click dialog
	switch( wParam )
	{
	case ID_SET_DEFAULT:
		SetDefault( (CAudiopath *)lParam );
		break;
	case ID_DELETE_AUDIOPATH:
		DeleteAudiopath( (CAudiopath *) lParam );
		break;
	case ID_CREATE_STANDARD3D:
		AddStandard( DMUS_APATH_DYNAMIC_3D );
		break;
	case ID_CREATE_STANDARDMIXBINQUAD:
		AddStandard( DMUS_APATH_MIXBIN_QUAD );
		break;
	case ID_CREATE_STANDARDMIXBINQUADMUSIC:
		AddStandard( DMUS_APATH_MIXBIN_QUAD_MUSIC );
		break;
	case ID_CREATE_STANDARDMIXBINQUADENV:
		AddStandard( DMUS_APATH_MIXBIN_QUAD_ENV );
		break;
	case ID_CREATE_STANDARDMIXBIN51:
		AddStandard( DMUS_APATH_MIXBIN_5DOT1 );
		break;
	case ID_CREATE_STANDARDMIXBIN51MUSIC:
		AddStandard( DMUS_APATH_MIXBIN_5DOT1_MUSIC );
		break;
	case ID_CREATE_STANDARDMIXBIN51ENV:
		AddStandard( DMUS_APATH_MIXBIN_5DOT1_ENV );
		break;
	case ID_CREATE_STANDARDSTEREOEFFECTS:
		AddStandard( DMUS_APATH_MIXBIN_STEREO_EFFECTS );
		break;
	case ID_CREATE_STANDARDSTEREO:
		AddStandard( DMUS_APATH_DYNAMIC_STEREO );
		break;
	case ID_CREATE_STANDARDSHAREDSTEREO:
		AddStandard( DMUS_APATH_SHARED_STEREO );
		break;
	case ID_CREATE_STANDARDMONO:
		AddStandard( DMUS_APATH_DYNAMIC_MONO );
		break;
	case ID_CREATE_STANDARDSTEREOREVERB:
		AddStandard( DMUS_APATH_SHARED_STEREOPLUSREVERB );
		break;
	}

	return 0;
}

void CLeftPaneDlg::AddAudiopathToList( CAudiopath *pAudiopath )
{
	// Check if audiopath name is already used
	int nAppendValue = 0;
	bool fFound = true;
	CString strAudiopathName = pAudiopath->GetFileName();
	while( fFound )
	{
		fFound = false;
		POSITION pos = m_plstAudiopaths->GetHeadPosition();
		while( pos )
		{
			CAudiopath *pTemp = m_plstAudiopaths->GetNext( pos );
			if( strAudiopathName == pTemp->GetFileName()
			&&	nAppendValue == pTemp->m_nAppendValue )
			{
				fFound = true;
				nAppendValue++;
				break;
			}
		}
	}

	// Set the audiopath's append value
	pAudiopath->SetAppendValue( nAppendValue );

	// Copy to Xbox
	HRESULT hr = pAudiopath->CopyToXbox( );

	if( SUCCEEDED(hr) )
	{
		// Add it to our list
		m_plstAudiopaths->AddHead( pAudiopath );

		// Add it to the display
		if( m_listAudiopath.GetSafeHwnd() )
		{
			m_listAudiopath.AddString( (LPCTSTR) pAudiopath );
		}

		// Check if this is the only audiopath
		if( m_plstAudiopaths->GetCount() == 1 )
		{
			// Set it as the default audiopath
			hr = pAudiopath->SetDefault( true );
		}
	}
	else
	{
		delete pAudiopath;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\LeftPaneDlg.h ===
#if !defined(AFX_LEFTPANEDLG_H__FC797C3D_3DFB_45F7_8235_C30AF74C8BDF__INCLUDED_)
#define AFX_LEFTPANEDLG_H__FC797C3D_3DFB_45F7_8235_C30AF74C8BDF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "hsplitter.h"
#include "AudiopathListBox.h"
#include "DropTarget.h"

class CAudiopath;
class CFileItem;
class CPrimaryDlg;
class CSecondaryDlg;
interface IDMUSProdNode;

#define MAX_NUM_AUDIOPATHS (3)

// LeftPaneDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLeftPaneDlg dialog

class CLeftPaneDlg : public CEndTrack, public CDropControl
{
// Construction
public:
	CLeftPaneDlg(CWnd* pParent = NULL);   // standard constructor
	~CLeftPaneDlg();

    void EndTrack( long lNewPos );
	void OnConnectionStateChanged( void );
	bool IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode );
	bool IsFileInUse( CFileItem *pFileItem );
	HRESULT AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode );
	void HandleNotification( NOTIFICATION_TYPE notificationType, DWORD dwSegmentID, DWORD dwData1 );
	void OnPanic( void );
	void UnloadAll( void );
	void DeleteAll( void );
	void ReCopyAll( void );

// Dialog Data
	//{{AFX_DATA(CLeftPaneDlg)
	enum { IDD = IDD_LEFT_PANE };
	CStatic	m_staticAudiopath;
	CAudiopathListBox	m_listAudiopath;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLeftPaneDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// CDropControl implementation
	virtual void InternalDragOver( DWORD grfKeyState, POINTL ptScreen, IDataObject* pIDataObject, DWORD* pdwEffect );
	virtual void InternalDrop( IDataObject* pIDataObject, POINTL ptScreen, DWORD dwEffect);
	virtual void InternalDragLeave( void );

// Implementation
protected:
	CHSplitter			m_wndHSplitter;
    CPrimaryDlg         *m_pPrimaryDlg;
    CSecondaryDlg       *m_pSecondaryDlg;

    WORD                m_wSplitterPos;
	CTypedPtrList< CPtrList, CAudiopath *> *m_plstAudiopaths;
    CTypedPtrList< CPtrList, CAudiopath *> m_lstAudiopathsToSynchronize;
	CDropTarget			m_DropTarget;
	UINT				m_cfAudiopath;
	UINT				m_cfFile;

    void UpdateListBoxPositions( void );
	void AddAudiopathToDisplay( POINTL ptScreen, IDMUSProdNode *pIDMUSProdNode );
	void SetDefault( CAudiopath *pAudiopath );
	void AddStandard( DWORD dwType );
	void DeleteAudiopath( CAudiopath *pAudiopath );
	void AddAudiopathToList( CAudiopath *pAudiopath );

	// Generated message map functions
	//{{AFX_MSG(CLeftPaneDlg)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	afx_msg LRESULT OnApp(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LEFTPANEDLG_H__FC797C3D_3DFB_45F7_8235_C30AF74C8BDF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\OtherFile.cpp ===
// OtherFile.cpp : implementation file
//

#include "stdafx.h"
#include "OtherFile.h"
#include "dmusprod.h"
#include "dmpprivate.h"
#include "XboxAddin.h"
#include "XboxAddinComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


COtherFile::COtherFile( IDMUSProdNode *pDMUSProdNode ) : CFileItem(pDMUSProdNode)
{
	GUID guidNode;
	HRESULT hr = pDMUSProdNode->GetNodeId( &guidNode );

	IDMUSProdDocType *pIDMUSProdDocType = NULL;
	if( SUCCEEDED(hr) )
	{
		hr = theApp.m_pXboxAddinComponent->m_pIFramework->FindDocTypeByNodeId( guidNode, &pIDMUSProdDocType );
	}

	HINSTANCE hInstance = NULL;
	UINT nResourceId = 0;
	if( SUCCEEDED(hr) )
	{
		hr = pIDMUSProdDocType->GetResourceId( &hInstance, &nResourceId );
	}

	if( SUCCEEDED(hr) )
	{
		m_hIcon = ::LoadIcon( hInstance, MAKEINTRESOURCE (nResourceId) );
	}
	else
	{
		m_hIcon = NULL;
	}

	if( pIDMUSProdDocType )
	{
		pIDMUSProdDocType->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\OtherFile.h ===
#if !defined(AFX_OTHER_FILES_H__22EF9571_12A3_5073_9CE0_6F8456E61502__INCLUDED_)
#define AFX_OTHER_FILES_H__22EF9571_12A3_5073_9CE0_6F8456E61502__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OtherFile.h : header file
//

#include "FileItem.h"

/////////////////////////////////////////////////////////////////////////////
// COtherFile class

class COtherFile : public CFileItem
{
public:
	COtherFile( IDMUSProdNode *pDMUSProdNode );
	HICON GetIcon( void )
	{
		return m_hIcon;
	}

protected:
    HICON	m_hIcon;
};


#endif // !defined(AFX_OTHER_FILES_H__22EF9571_12A3_5073_9CE0_6F8456E61502__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\OtherFilesListBox.cpp ===
// OtherFilesListBox.cpp : implementation file
//

#include "stdafx.h"
#include "xboxaddin.h"
#include "OtherFilesListBox.h"
#include "OtherFile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define PLAY_ICON_HEIGHT (16)
#define PLAY_ICON_WIDTH (16)
#define PLAY_BUTTON_WIDTH (16);

/////////////////////////////////////////////////////////////////////////////
// COtherFilesListBox

COtherFilesListBox::COtherFilesListBox()
{
}

COtherFilesListBox::~COtherFilesListBox()
{
}


BEGIN_MESSAGE_MAP(COtherFilesListBox, CFileListBox)
	//{{AFX_MSG_MAP(COtherFilesListBox)
	ON_WM_DRAWITEM_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COtherFilesListBox message handlers

void COtherFilesListBox::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// Get the OtherFile
	COtherFile *pOtherFile = reinterpret_cast<COtherFile *>(lpDrawItemStruct->itemData);
	if( !pOtherFile )
	{
		return;
	}

	// if we're drawing a real item and the item is to be completely
	// draw or drawn as if it is selected, then ...

	if (((LONG)(lpDrawItemStruct->itemID) >= 0) &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
	{
		// set up the text color and the background color
		COLORREF oldTextColor, oldBkColor;
		if ( (lpDrawItemStruct->itemState & ODS_SELECTED) != 0 )
		{
			oldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
			oldBkColor = ::SetBkColor( lpDrawItemStruct->hDC, ::GetFocus() == m_hWnd ? ::GetSysColor(COLOR_HIGHLIGHT) : ::GetSysColor(COLOR_INACTIVECAPTION) );
		}
		else
		{
			oldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_WINDOWTEXT) );
			oldBkColor = ::SetBkColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_WINDOW) );
		}

		// Draw the (un)selected background
		::ExtTextOut( lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &lpDrawItemStruct->rcItem, NULL, 0, NULL);

        // Play button
        RECT rect;
        rect = lpDrawItemStruct->rcItem;

        //DFCS_PUSHED
        rect.right = PLAY_BUTTON_WIDTH;
        //::DrawFrameControl( lpDrawItemStruct->hDC, &rect, DFC_BUTTON, DFCS_BUTTONPUSH );

        int nYPos = ((rect.bottom + rect.top) / 2) - (PLAY_ICON_HEIGHT / 2);
        ::DrawIconEx( lpDrawItemStruct->hDC, rect.left, nYPos, pOtherFile->GetIcon(), PLAY_ICON_WIDTH, PLAY_ICON_HEIGHT, 0, NULL, DI_NORMAL );

        // Set up the text rectangle
        rect.left = PLAY_BUTTON_WIDTH;
        rect.right = lpDrawItemStruct->rcItem.right;

		// File Name
		::DrawText( lpDrawItemStruct->hDC, pOtherFile->GetName(), -1, &rect, DT_SINGLELINE | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );

		// restore the old objects in the DC
		::SetTextColor( lpDrawItemStruct->hDC, oldTextColor );
		::SetBkColor( lpDrawItemStruct->hDC, oldBkColor);
	}

	// if the item is focused, draw the focus rectangle
	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
	{
		::DrawFocusRect( lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem) );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\PrimaryDlg.cpp ===
// PrimaryDlg.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "PrimaryDlg.h"
#include "Segment.h"
#include "XboxAddinComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrimaryDlg dialog

CPrimaryDlg::CPrimaryDlg(CWnd* pParent /*=NULL*/)
	: CSegmentDlg(pParent)
{
	//{{AFX_DATA_INIT(CPrimaryDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_plstSegments = &theApp.m_pXboxAddinComponent->m_lstPrimarySegments;
}


void CPrimaryDlg::DoDataExchange(CDataExchange* pDX)
{
	CSegmentDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPrimaryDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrimaryDlg, CSegmentDlg)
	//{{AFX_MSG_MAP(CPrimaryDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrimaryDlg message handlers

BOOL CPrimaryDlg::OnInitDialog() 
{
	CSegmentDlg::OnInitDialog();

    m_staticSegment.SetWindowText( TEXT("Primary Segments") );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPrimaryDlg::HandleSegmentNotification( CSegment *pSegment, DWORD dwNotification )
{
	CSegmentDlg::HandleSegmentNotification( pSegment, dwNotification );
	
	// TODO: Do more work to handle transition buttons
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\OtherFilesDlg.h ===
#if !defined(AFX_OTHERFILESDLG_H__131CA465_3D4E_4550_A14D_3FE531767B80__INCLUDED_)
#define AFX_OTHERFILESDLG_H__131CA465_3D4E_4550_A14D_3FE531767B80__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "OtherFilesListBox.h"

// OtherFilesDlg.h : header file
//

class CFileItem;
class COtherFile;
interface IDMUSProdNode;

/////////////////////////////////////////////////////////////////////////////
// COtherFilesDlg dialog

class COtherFilesDlg : public CDialog
{
// Construction
public:
	COtherFilesDlg(CWnd* pParent = NULL);   // standard constructor
    ~COtherFilesDlg();

	void OnConnectionStateChanged( void );
	bool IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode );
	bool IsFileInUse( CFileItem *pFileItem );
	HRESULT AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode );
	void CleanUpDisplay( void );
	void DeleteAll( void );

// Dialog Data
	//{{AFX_DATA(COtherFilesDlg)
	enum { IDD = IDD_OTHER_FILES };
	CStatic	m_staticOtherFiles;
	COtherFilesListBox	m_listFiles;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COtherFilesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CTypedPtrList< CPtrList, COtherFile *> *m_plstOtherFiles;

	HRESULT AddFileToList( COtherFile *pOtherFile );
	bool RemoveFile( CFileItem *pFileItem );

	// Generated message map functions
	//{{AFX_MSG(COtherFilesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OTHERFILESDLG_H__131CA465_3D4E_4550_A14D_3FE531767B80__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\OtherFilesDlg.cpp ===
// OtherFilesDlg.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "OtherFilesDlg.h"
#include "OtherFile.h"
#include "XboxAddinComponent.h"
#include "XboxAddinDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COtherFilesDlg dialog


COtherFilesDlg::COtherFilesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(COtherFilesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(COtherFilesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_plstOtherFiles = &theApp.m_pXboxAddinComponent->m_lstOtherFiles;
}

COtherFilesDlg::~COtherFilesDlg()
{
}

void COtherFilesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COtherFilesDlg)
	DDX_Control(pDX, IDC_STATIC_OTHER_FILES, m_staticOtherFiles);
	DDX_Control(pDX, IDC_LIST_OTHER_FILES, m_listFiles);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COtherFilesDlg, CDialog)
	//{{AFX_MSG_MAP(COtherFilesDlg)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COtherFilesDlg message handlers

void COtherFilesDlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);

    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow( m_listFiles.GetSafeHwnd() ) )
	{
		return;
	}

	RECT rectWindow;
	GetClientRect( &rectWindow );

    RECT rect;
    m_staticOtherFiles.GetClientRect( &rect );
    rect.right = rectWindow.right;
    rect.bottom += 2 * ::GetSystemMetrics(SM_CYBORDER);
    m_staticOtherFiles.MoveWindow( &rect );

    rect.top = rect.bottom;
    rect.bottom = rectWindow.bottom;
    m_listFiles.MoveWindow( &rect );
	m_listFiles.Invalidate( TRUE );
}

BOOL COtherFilesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	ASSERT( m_plstOtherFiles );
    POSITION pos = m_plstOtherFiles->GetHeadPosition();
    while( pos )
    {
        COtherFile *pOtherFile = m_plstOtherFiles->GetNext( pos );
        m_listFiles.AddString( (LPCTSTR) pOtherFile );
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void COtherFilesDlg::OnConnectionStateChanged( void )
{
	m_listFiles.EnableWindow( theApp.m_fConnected );
	m_staticOtherFiles.EnableWindow( theApp.m_fConnected );
}

bool COtherFilesDlg::IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode )
{
	ASSERT( m_plstOtherFiles );
	POSITION pos = m_plstOtherFiles->GetHeadPosition();
	while( pos )
	{
		COtherFile *pOtherFile = m_plstOtherFiles->GetNext( pos );
		if( pOtherFile->ContainsNode( pIDMUSProdNode ) )
		{
			return true;
		}
	}
	return false;
}

HRESULT COtherFilesDlg::AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode )
{
	// Add it to our internal list
	return AddFileToList( new COtherFile(pIDMUSProdNode) );
}

HRESULT COtherFilesDlg::AddFileToList( COtherFile *pOtherFile )
{
	if( pOtherFile == NULL )
	{
		return E_POINTER;
	}

	ASSERT( m_plstOtherFiles );

	// Add to our list
	m_plstOtherFiles->AddHead( pOtherFile );

	// Copy to Xbox
	HRESULT hr = pOtherFile->CopyToXbox( );

	if( SUCCEEDED(hr) )
	{
		// Add it to the display
		if( m_listFiles.GetSafeHwnd() )
		{
			m_listFiles.AddString( (LPCTSTR) pOtherFile );
		}
	}
	else
	{
		// Remove it from our list
		POSITION pos = m_plstOtherFiles->Find( pOtherFile );
		if( pos )
		{
			m_plstOtherFiles->RemoveAt( pos );
		}

		// Delete it
		delete pOtherFile;

		// Now, clean up the display
		theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->CleanUpDisplay();
	}

	return hr;
}

void COtherFilesDlg::CleanUpDisplay( void )
{
	bool fChanged = true;

	ASSERT( m_plstOtherFiles );

	while( fChanged )
	{
		fChanged = false;

		POSITION pos = m_plstOtherFiles->GetHeadPosition();
		while( pos )
		{
			CFileItem *pFileItem= m_plstOtherFiles->GetNext( pos );

			if( !theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->IsFileInUse( pFileItem ) )
			{
				if( RemoveFile( pFileItem ) )
				{
					fChanged = true;
				}
			}
		}
	}
}

bool COtherFilesDlg::RemoveFile( CFileItem *pFileItem )
{
	// Remove it from the Xbox
	if( FAILED( pFileItem->RemoveFromXbox() ) )
	{
		CString strErrorText;
		strErrorText.FormatMessage( IDS_ERR_REMOVE, pFileItem->GetName() );
		if( IDRETRY == XboxAddinMessageBox( this, strErrorText, MB_ICONERROR | MB_RETRYCANCEL ) )
		{
			return true;
		}
		return false;
	}

	// Remove it from the display
	int nIndex = m_listFiles.IndexFromFile( pFileItem );
	if( nIndex != LB_ERR )
	{
		m_listFiles.DeleteString( nIndex );
	}

	// Remove it from the list
	ASSERT( m_plstOtherFiles );
	POSITION posFile = m_plstOtherFiles->Find( pFileItem );
	if( posFile )
	{
		m_plstOtherFiles->RemoveAt( posFile );
	}

	// Finally, delete it
	delete pFileItem;

	// Don't do this, since we can only be called from CleanUpDisplay
	// Now, clean up the display
	//theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->CleanUpDisplay();

	return true;
}

bool COtherFilesDlg::IsFileInUse( CFileItem *pFileItem )
{
	ASSERT( m_plstOtherFiles );
	POSITION pos = m_plstOtherFiles->GetHeadPosition();
	while( pos )
	{
		CFileItem *pTemp = m_plstOtherFiles->GetNext( pos );
		if( pTemp != pFileItem )
		{
			if( pTemp->UsesFile( pFileItem ) )
			{
				return true;
			}
		}
	}

	return false;
}

void COtherFilesDlg::DeleteAll( void )
{
	// This should be empty
	ASSERT( m_plstOtherFiles );
	ASSERT( m_plstOtherFiles->IsEmpty() );

	// But in case it's not...
	POSITION pos = m_plstOtherFiles->GetHeadPosition();
	while( pos )
	{
		CFileItem *pTemp = m_plstOtherFiles->GetNext( pos );
		pTemp->RemoveFromXbox();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\OtherFilesListBox.h ===
#if !defined(AFX_OTHERFILESLISTBOX_H__281511A2_871B_4722_A588_D7BA09DFA652__INCLUDED_)
#define AFX_OTHERFILESLISTBOX_H__281511A2_871B_4722_A588_D7BA09DFA652__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "FileListBox.h"

// OtherFilesListBox.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COtherFilesListBox window

class COtherFilesListBox : public CFileListBox
{
// Construction
public:
	COtherFilesListBox();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COtherFilesListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~COtherFilesListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(COtherFilesListBox)
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OTHERFILESLISTBOX_H__281511A2_871B_4722_A588_D7BA09DFA652__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\PrimaryDlg.h ===
#if !defined(AFX_PRIMARYDLG_H__DEBBFE12_5D20_423D_9587_0A65D02038D3__INCLUDED_)
#define AFX_PRIMARYDLG_H__DEBBFE12_5D20_423D_9587_0A65D02038D3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SegmentDlg.h"

// PrimaryDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPrimaryDlg dialog

class CPrimaryDlg : public CSegmentDlg
{
// Construction
public:
	CPrimaryDlg(CWnd* pParent = NULL);   // standard constructor

	void HandleSegmentNotification( CSegment *pSegment, DWORD dwNotification );

// Dialog Data
	//{{AFX_DATA(CPrimaryDlg)
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPrimaryDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPrimaryDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRIMARYDLG_H__DEBBFE12_5D20_423D_9587_0A65D02038D3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XboxAddin.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_XBOXADDIN_DIALOG            102
#define IDC_HSPLITTER                   102
#define IDS_XBOXADDIN_COMPONENT_NAME    102
#define IDC_VSPLITTER                   103
#define IDS_ERR_INVALIDARG              103
#define IDS_ERR_ADD_MENUITEM            104
#define IDS_EXPERIMENTER_WINDOW_MENU_TEXT 105
#define IDS_EXPERIMENTER_WINDOW_MENU_HELP_TEXT 106
#define IDS_ERR_MISSING_CONDUCTOR       107
#define IDS_ERR_LOAD                    108
#define IDS_ERR_PLAY                    109
#define IDS_ERR_COPY                    110
#define IDS_ERR_REMOVE                  111
#define IDS_ERR_UNLOAD                  112
#define IDS_ERR_REMOVE_SEGMENT          113
#define IDS_ERR_PLAY_TIMEOUT            114
#define IDS_ERR_LOAD_TIMEOUT            115
#define IDS_PROGRESS_FILE               116
#define IDS_PROGRESS_DOWNLOAD           117
#define IDS_PROGRESS_CREATE             118
#define IDS_ERR_CREATE                  119
#define IDS_ERR_CREATE_TIMEOUT          120
#define IDS_ERR_SETDEFAULT              121
#define IDS_APATH_SHARED_STEREOPLUSREVERB 122
#define IDS_APATH_DYNAMIC_3D            123
#define IDS_APATH_DYNAMIC_MONO          124
#define IDS_APATH_DYNAMIC_STEREO        125
#define IDS_APATH_MIXBIN_QUAD_ENV       125
#define IDS_DEFAULT_AUDIOPATH           126
#define IDS_ERR_RELEASE_AUDIOPATH       127
#define IDR_MAINFRAME                   128
#define IDS_ERR_REMOVE_AUDIOPATH        128
#define IDS_ERR_PATH_EMPTY              129
#define IDD_AUDIOPATH                   130
#define IDS_ERR_PATH_NOEXIST            130
#define IDS_ERR_PATH_FILEEXIST          131
#define IDS_ERR_CANT_CONNECT_DMCONSOLE  132
#define IDD_SEGMENT                     133
#define IDS_ERR_CANT_CONNECT            133
#define IDS_ERR_CANT_SET_NAME           134
#define IDI_PLAY                        135
#define IDS_ERR_NAME_EMPTY              135
#define IDS_ERR_SETXBOXSYNTH            136
#define IDS_XBOX_ADDIN_VERSION          137
#define IDS_ERR_XBSYNTH_AUDCONSOLE_VERSION 138
#define IDD_BOUNDARY                    139
#define IDS_ERR_AUDCONSOLE_VERSION      139
#define IDD_OTHER_FILES                 140
#define IDS_XBOX_SYNTH_MENU_TEXT        140
#define IDD_LEFT_PANE                   141
#define IDS_XBOX_SYNTH_MENU_HELP_TEXT   141
#define IDS_ERR_NO_XBOX_SYNTH           142
#define IDR_SEGMENT_MENU                143
#define IDS_ERR_NO_AUDIOPATH            143
#define IDR_XBOXADDIN_MENU              144
#define IDS_APATH_SHARED_STEREO         144
#define IDS_XBOX_SYNTH_TITLE            145
#define IDS_ERR_PATH_CANTCREATE         146
#define IDS_APATH_MIXBIN_5DOT1_MUSIC    147
#define IDS_APATH_MIXBIN_QUAD_MUSIC     148
#define IDS_APATH_MIXBIN_5DOT1_ENV      149
#define IDS_APATH_MIXBIN_STEREO_EFFECTS 150
#define IDI_WAVE                        151
#define IDS_APATH_MIXBIN_QUAD           151
#define IDI_CHORDMAP                    152
#define IDS_APATH_MIXBIN_5DOT1          152
#define IDI_SCRIPT                      153
#define IDI_STYLE                       154
#define IDI_COLLECTION                  155
#define IDI_CONTAINER                   156
#define IDI_TRANSITION                  159
#define IDI_STOP                        160
#define IDD_TARGET_DIRECTORY            161
#define IDD_GETNODES_ERROR              162
#define IDR_AUDIOPATH_MENU              163
#define IDD_XBOX_SYNTH_CONFIG           164
#define IDD_XBOX_CONNECTING             166
#define IDC_BTN_EMBED_ADD               204
#define IDC_CUSTOM_ID_SPIN              241
#define IDC_CUSTOM_ID                   248
#define IDC_CHECK_AUDIOPATH             303
#define IDC_CHECK_EXTEND_TIMESIG        304
#define IDC_CHECK_AUDIOPATH2            305
#define IDC_CHECK_EXTEND_TIMESIG2       306
#define IDC_CHECK_EXTEND_TIMESIG3       307
#define IDD_DLG_ADD_SEGMENTS            309
#define IDD_DLG_ADD_FILES               310
#define IDD_RIGHT_PANE                  311
#define IDD_SCRIPTS                     312
#define IDD_TARGET_XBOX                 313
#define IDC_CHECK_NOINVALIDATE          500
#define IDC_CHECK_NOINVALIDATE2         501
#define IDC_RADIO_SORT_NAME             501
#define IDC_RADIO_SORT_TYPE             502
#define IDC_CHECK_NOINVALIDATE3         503
#define IDC_RADIO_SORT_SIZE             505
#define IDC_RADIO_TIMING_QUICK          510
#define IDC_RADIO_TIMING_AFTERPREPARETIME 511
#define IDC_RADIO_TIMING_QUICK2         512
#define IDC_RADIO_TIMING_AFTERPREPARETIME2 513
#define IDC_LIST_AVAILABLE              523
#define IDC_BTN_EMBED_REMOVE            527
#define IDC_BTN_RESET                   528
#define IDC_LIST_EMBED                  529
#define IDC_LIST_AUDIOPATH              1000
#define IDC_STATIC_AUDIOPATH            1002
#define IDC_STATIC_SEGMENT              1003
#define IDC_LIST_SEGMENT                1004
#define IDC_RADIO1                      1007
#define IDC_RADIO2                      1008
#define IDC_RADIO3                      1009
#define IDC_RADIO4                      1010
#define IDC_RADIO5                      1011
#define IDC_RADIO6                      1013
#define IDC_CHECK1                      1017
#define IDC_CHECK2                      1018
#define IDC_CHECK4                      1020
#define IDC_CHECK5                      1021
#define IDC_STATIC_OTHER_FILES          1022
#define IDC_LIST_OTHER_FILES            1023
#define IDC_STATIC_SCRIPTS              1024
#define IDC_LIST_SCRIPTS                1025
#define IDC_EDIT_DIRECTORY              1026
#define IDC_SYNCHRONIZE                 1028
#define IDC_EDIT_REFERENCES             1029
#define IDC_EDIT_XBOX_NAME              1030
#define IDC_CHECK_XBOX_SYNTH            1031
#define IDC_CHECK_PC_SYNTH              1032
#define IDC_FILE_VERSION                1033
#define IDC_CHECK_DEFAULT               1034
#define IDC_COMBO_BOUNDARY              1081
#define IDC_COMBO_PATTERN               1082
#define IDC_CHECK_LONG                  1083
#define IDC_CHECK_MODULATE              1084
#define IDC_COMBO_BOUNDARY2             1085
#define IDC_COMBO_BOUNDARY3             1086
#define IDC_CONTROL                     1093
#define IDC_RADIO_ENTIRE_PATTERN        1171
#define IDC_RADIO_ONE_BAR_PATTERN       1172
#define IDC_RADIO_ENTIRE_ADDITIONAL     1173
#define IDC_RADIO_ONE_BAR_ADDITIONAL    1174
#define IDC_CUSTOM_PROMPT               1175
#define IDC_RADIO_SWITCH_ANY_TIME       1177
#define IDC_RADIO_SWITCH_ANY_GRID       1178
#define IDC_RADIO_SWITCH_ANY_BEAT       1179
#define IDC_RADIO_SWITCH_ANY_BAR        1180
#define IDC_ALIGN_OPTIONS_PROMPT        1181
#define IDC_CHECK_BOUNDARY              1182
#define IDC_STATIC_NO_MARKERS           1183
#define IDC_CHECK_BOUNDARY2             1184
#define IDC_STATIC_NO_MARKERS2          1185
#define IDC_ALIGN_OPTIONS_PROMPT2       1186
#define IDC_RADIO_SWITCH_ANY_TIME2      1187
#define IDC_COMBO_TRANS_SEGMENT         1188
#define IDC_RADIO_SWITCH_ANY_GRID2      1189
#define IDC_RADIO_SWITCH_ANY_BEAT2      1190
#define IDC_RADIO_SWITCH_ANY_BAR2       1191
#define IDC_CHECK_BOUNDARY3             1192
#define IDC_STATIC_NO_MARKERS3          1193
#define IDC_RADIO_QUICK_RESPONSE        1197
#define IDC_RADIO_AFTER_PREPARE         1198
#define IDC_CHECK_TRANS_NOTHING         1206
#define ID_BOUNDARY_SETTINGS            32771
#define ID__USEAUDIOPATH_AUDIOPATH1     32773
#define ID__USEAUDIOPATH_AUDIOPATH2     32774
#define ID__USEAUDIOPATH_STANDARDSTEREO 32775
#define ID__USEAUDIOPATH_STANDARD3DDRY  32776
#define ID__USEAUDIOPATH_STANDARDMONO   32777
#define ID__USEAUDIOPATH_STANDARDSTEREOREVERB 32778
#define ID__USEAUDIOPATH_AUDIOPATH3     32779
#define ID_SYNCHRONIZE_ALL              32784
#define ID_SYNCHRONIZE_AUTO             32785
#define ID_INSERT_SEGMENTS              32786
#define ID_SET_TARGET_DIRECTORY         32787
#define ID__USEAUDIOPATH_STANDARD3DWET  32788
#define ID_CONNECT                      32789
#define ID_DISCONNECT                   32790
#define ID_XBOX_PANIC                   32791
#define ID_DELETE_SEGMENT               32792
#define ID_DELETE_AUDIOPATH             32793
#define ID_SET_DEFAULT                  32794
#define ID_CREATE_STANDARD3DDRY         32795
#define ID_CREATE_STANDARD3D            32795
#define ID_CREATE_STANDARD3DWET         32796
#define ID_CREATE_STANDARDMONO          32797
#define ID_CREATE_STANDARDSTEREO        32798
#define ID_CREATE_STANDARDSTEREOREVERB  32799
#define ID_SET_XBOX_NAME                32800
#define ID_XBOX_SYNTH_CONFIG            32801
#define ID_CREATE_STANDARDSHAREDSTEREO  32802
#define ID__USEAUDIOPATH_STANDARDSHAREDSTEREO 32803
#define ID_CREATE_STANDARDMIXBINQUADMUSIC 32804
#define ID_CREATE_STANDARDMIXBINQUADENV 32805
#define ID_CREATE_STANDARDMIXBIN51MUSIC 32806
#define ID_CREATE_STANDARDMIXBIN51ENV   32807
#define ID_CREATE_STANDARDSTEREOEFFECTS 32808
#define ID__USEAUDIOPATH_STANDARDQUADMUSIC 32809
#define ID__USEAUDIOPATH_STANDARDQUADENV 32810
#define ID__USEAUDIOPATH_STANDARD51MUSIC 32811
#define ID__USEAUDIOPATH_STANDARD51ENV  32812
#define ID__USEAUDIOPATH_STANDARDSTEREOEFFECT 32813
#define ID__USEAUDIOPATH_STANDARDQUAD   32814
#define ID__USEAUDIOPATH_STANDARD51     32815
#define ID_CREATE_STANDARDMIXBINQUAD    32816
#define ID_CREATE_STANDARDMIXBIN51      32817

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        167
#define _APS_NEXT_COMMAND_VALUE         32818
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\RightPaneDlg.cpp ===
// RightPaneDlg.cpp : implementation file
//

#include "stdafx.h"
#include "xboxaddin.h"
#include "RightPaneDlg.h"
#include "OtherFilesDlg.h"
//#include "ScriptsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRightPaneDlg dialog


CRightPaneDlg::CRightPaneDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRightPaneDlg::IDD, pParent) //: CEndTrack(CRightPaneDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRightPaneDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    //m_wSplitterPos = 0;
    m_pOtherFilesDlg = NULL;
    //m_pScriptsDlg = NULL;
}

CRightPaneDlg::~CRightPaneDlg()
{
	if( m_pOtherFilesDlg )
	{
		delete m_pOtherFilesDlg;
		m_pOtherFilesDlg = NULL;
	}
	/*
	if( m_pScriptsDlg )
	{
		delete m_pScriptsDlg;
		m_pScriptsDlg = NULL;
	}
	*/
}


void CRightPaneDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRightPaneDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRightPaneDlg, CDialog)
	//{{AFX_MSG_MAP(CRightPaneDlg)
	ON_WM_CREATE()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRightPaneDlg message handlers

BOOL CRightPaneDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // Resize the panes
    /*
    RECT rectClient;
    GetClientRect( &rectClient );
    OnSize( SIZE_RESTORED, rectClient.right, rectClient.bottom );
    */

    UpdateListBoxPositions();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

int CRightPaneDlg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	/*
	// Create the Splitter and position it in the Editor
	// (temporary values added until coords are saved to design-time file)
	RECT rect;
	rect.left = lpCreateStruct->x;
    rect.right = lpCreateStruct->cx;
    rect.top = lpCreateStruct->y;
	rect.bottom = rect.top + DEFAULTSPLITTERHEIGHT;

	m_wndHSplitter.Create( this, &rect );
	*/

	// Create the OtherFiles dialog and position it in the First Splitter Pane
	m_pOtherFilesDlg = new COtherFilesDlg;
	if( m_pOtherFilesDlg == NULL )
	{
		return -1;
	}

	// Point the Secondary segment dialog back to us and at the AudioPath object
	m_pOtherFilesDlg->Create( IDD_OTHER_FILES, this );
	m_pOtherFilesDlg->ShowWindow( SW_SHOW );
	//m_wndHSplitter.SetFirstPane( m_pOtherFilesDlg );

	// Create the scripts dialog and position it in the Second Splitter Pane
	/*
	m_pScriptsDlg = new CScriptsDlg;
	if( m_pScriptsDlg == NULL )
	{
		return -1;
	}

	// Point the EffectList dialog back to us and at the AudioPath object
	m_pScriptsDlg->Create( IDD_SCRIPTS, this );
	m_pScriptsDlg->ShowWindow( SW_SHOW );
	m_wndHSplitter.SetSecondPane( m_pScriptsDlg );
	*/
	
	return 0;
}

void CRightPaneDlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);

    UpdateListBoxPositions();
}

void CRightPaneDlg::UpdateListBoxPositions( void )
{
    if( GetSafeHwnd() == NULL )
    {
        return;
    }

    RECT rectClient;
    GetClientRect( &rectClient );

	/*
    // get splitter position
	WORD pos = m_wSplitterPos;

	// calculate where splitter should be
	if(pos == 0)
	{
		// put it right in the middle
		pos = WORD(min( USHRT_MAX, (rectClient.bottom - DEFAULTSPLITTERHEIGHT)/2 ));

		// save it
		m_wSplitterPos = pos;
	}

    // Update splitter position, if it's non-zero
	if( pos != 0 )
	{
		RECT rect = rectClient;
		rect.bottom = max( DEFAULTSPLITTERHEIGHT, pos );
		rect.top = rect.bottom - DEFAULTSPLITTERHEIGHT;
		m_wndHSplitter.SetTracker(rect);
		m_wndHSplitter.MoveWindow( &rect, TRUE );
		m_pOtherFilesDlg->MoveWindow(0, 0, rect.right, rect.top);
		m_pScriptsDlg->MoveWindow(0, rect.bottom, rect.right, rectClient.bottom - rect.bottom);
	}
	*/

	// Make the OtherFiles window fill the dialog
	m_pOtherFilesDlg->MoveWindow(0, 0, rectClient.right, rectClient.bottom);
}

/*
void CRightPaneDlg::EndTrack( long lNewPos )
{
    m_wSplitterPos = (WORD)lNewPos;
}
*/

void CRightPaneDlg::OnConnectionStateChanged( void )
{
	m_pOtherFilesDlg->OnConnectionStateChanged();
	//m_pScriptsDlg->OnConnectionStateChanged();
}

bool CRightPaneDlg::IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode )
{
	return m_pOtherFilesDlg->IsNodeDisplayed( pIDMUSProdNode );
	//|| m_pScriptsDlg->IsNodeDisplayed( pIDMUSProdNode );
}

HRESULT CRightPaneDlg::AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode )
{
	// TODO: Add scrips to the scripts dialog
	return m_pOtherFilesDlg->AddNodeToDisplay( pIDMUSProdNode );
}

void CRightPaneDlg::CleanUpDisplay( void )
{
	m_pOtherFilesDlg->CleanUpDisplay();
	// No need to clean up scripts dialog
}

bool CRightPaneDlg::IsFileInUse( CFileItem *pFileItem )
{
	return m_pOtherFilesDlg->IsFileInUse( pFileItem );
	//|| m_pScriptsDlg->IsFileInUse( pFileItem );
}

void CRightPaneDlg::DeleteAll( void )
{
	m_pOtherFilesDlg->DeleteAll();
	//m_pScriptsDlg->DeleteAll();
}

/*
void CRightPaneDlg::ReCopyAll( void )
{
	// Only copy scripts
	m_pScriptsDlg->ReCopyAll();
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\ScriptsDlg.cpp ===
// ScriptsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "xboxaddin.h"
#include "ScriptsDlg.h"
#include "OtherFile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScriptsDlg dialog


CScriptsDlg::CScriptsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CScriptsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CScriptsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CScriptsDlg::~CScriptsDlg()
{
    while( !m_lstOtherFiles.IsEmpty() )
    {
        delete m_lstOtherFiles.RemoveHead();
    }
}


void CScriptsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScriptsDlg)
	DDX_Control(pDX, IDC_STATIC_SCRIPTS, m_staticScripts);
	DDX_Control(pDX, IDC_LIST_SCRIPTS, m_listScripts);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScriptsDlg, CDialog)
	//{{AFX_MSG_MAP(CScriptsDlg)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScriptsDlg message handlers

void CScriptsDlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);

    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow( m_listScripts.GetSafeHwnd() ) )
	{
		return;
	}

	RECT rectWindow;
	GetClientRect( &rectWindow );

    RECT rect;
    m_staticScripts.GetClientRect( &rect );
    rect.right = rectWindow.right;
    rect.bottom += 2 * ::GetSystemMetrics(SM_CYBORDER);
    m_staticScripts.MoveWindow( &rect );

    rect.top = rect.bottom;
    rect.bottom = rectWindow.bottom;
    m_listScripts.MoveWindow( &rect );
}

BOOL CScriptsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

    POSITION pos = m_lstOtherFiles.GetHeadPosition();
    while( pos )
    {
        COtherFile *pOtherFile = m_lstOtherFiles.GetNext( pos );
        int nIndex = m_listScripts.InsertString( 0, TEXT("") );
        m_listScripts.SetItemDataPtr( nIndex, pOtherFile );
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CScriptsDlg::OnConnectionStateChanged( void )
{
	m_listScripts.EnableWindow( false );
	m_staticScripts.EnableWindow( false );
	/*
	m_listScripts.EnableWindow( theApp.m_fConnected );
	m_staticScripts.EnableWindow( theApp.m_fConnected );
	*/
}

bool CScriptsDlg::IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode )
{
	UNREFERENCED_PARAMETER(pIDMUSProdNode);
	return false;
	/* TODO:
	POSITION pos = m_lstSegments.GetHeadPosition();
	while( pos )
	{
		CSegment *pSegment = m_lstSegments.GetNext( pos );
		if( pIDMUSProdNode == pSegment->m_pFileNode )
		{
			return true;
		}
	}
	return false;
	*/
}

/* TODO:
void CScriptsDlg::AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode )
{
	// Add it to our internal list
	AddSegmentToList( new CSegment(pIDMUSProdNode) );
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\ScriptsDlg.h ===
#if !defined(AFX_SCRIPTSDLG_H__3D7391FE_C78D_4270_A011_36835091915D__INCLUDED_)
#define AFX_SCRIPTSDLG_H__3D7391FE_C78D_4270_A011_36835091915D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "OtherFilesListBox.h"

// ScriptsDlg.h : header file
//

class COtherFile;
interface IDMUSProdNode;

/////////////////////////////////////////////////////////////////////////////
// CScriptsDlg dialog

class CScriptsDlg : public CDialog
{
// Construction
public:
	CScriptsDlg(CWnd* pParent = NULL);   // standard constructor
    ~CScriptsDlg();

	void OnConnectionStateChanged( void );
	bool IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode );
	void AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode );

// Dialog Data
	//{{AFX_DATA(CScriptsDlg)
	enum { IDD = IDD_SCRIPTS };
	CStatic	m_staticScripts;
	COtherFilesListBox	m_listScripts;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScriptsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CTypedPtrList< CPtrList, COtherFile *> m_lstOtherFiles;

	// Generated message map functions
	//{{AFX_MSG(CScriptsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCRIPTSDLG_H__3D7391FE_C78D_4270_A011_36835091915D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\RightPaneDlg.h ===
#if !defined(AFX_RIGHTPANEDLG_H__EE744E37_B3CB_4336_8069_D050BA0AF9C6__INCLUDED_)
#define AFX_RIGHTPANEDLG_H__EE744E37_B3CB_4336_8069_D050BA0AF9C6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#include "hsplitter.h"

class CFileItem;
class COtherFilesDlg;
//class CScriptsDlg;
interface IDMUSProdNode;

// RightPaneDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRightPaneDlg dialog

class CRightPaneDlg : public CDialog //: public CEndTrack
{
// Construction
public:
	CRightPaneDlg(CWnd* pParent = NULL);   // standard constructor
	~CRightPaneDlg();

    //void EndTrack( long lNewPos );
	void OnConnectionStateChanged( void );
	bool IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode );
	bool IsFileInUse( CFileItem *pFileItem );
	HRESULT AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode );
	void CleanUpDisplay( void );
	void DeleteAll( void );
	//void ReCopyAll( void );

// Dialog Data
	//{{AFX_DATA(CRightPaneDlg)
	enum { IDD = IDD_RIGHT_PANE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRightPaneDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//CHSplitter			m_wndHSplitter;
    COtherFilesDlg      *m_pOtherFilesDlg;
    //CScriptsDlg         *m_pScriptsDlg;

    //WORD                m_wSplitterPos;

    void UpdateListBoxPositions( void );

	// Generated message map functions
	//{{AFX_MSG(CRightPaneDlg)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RIGHTPANEDLG_H__EE744E37_B3CB_4336_8069_D050BA0AF9C6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\SecondaryDlg.cpp ===
// SecondaryDlg.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "SecondaryDlg.h"
#include "Segment.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <Xbox-dmusici.h>
#pragma warning ( pop )
#include "XboxAddinComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSecondaryDlg dialog

CSecondaryDlg::CSecondaryDlg(CWnd* pParent /*=NULL*/)
	: CSegmentDlg(pParent)
{
	//{{AFX_DATA_INIT(CSecondaryDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_plstSegments = &theApp.m_pXboxAddinComponent->m_lstSecondarySegments;
}


void CSecondaryDlg::DoDataExchange(CDataExchange* pDX)
{
	CSegmentDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSecondaryDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSecondaryDlg, CSegmentDlg)
	//{{AFX_MSG_MAP(CSecondaryDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSecondaryDlg message handlers

BOOL CSecondaryDlg::OnInitDialog() 
{
	CSegmentDlg::OnInitDialog();

    m_staticSegment.SetWindowText( TEXT("Secondary Segments") );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CSecondaryDlg::AddSegmentToList( CSegment *pSegment )
{
	if( pSegment )
	{
		pSegment->m_dwPlayFlags |= DMUS_SEGF_SECONDARY;
	}

	return CSegmentDlg::AddSegmentToList( pSegment );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\SecondaryDlg.h ===
#if !defined(AFX_SECONDARYDLG_H__3152BA5B_668B_4803_8C70_3B3BC055A112__INCLUDED_)
#define AFX_SECONDARYDLG_H__3152BA5B_668B_4803_8C70_3B3BC055A112__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SegmentDlg.h"

// SecondaryDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSecondaryDlg dialog

class CSecondaryDlg : public CSegmentDlg
{
// Construction
public:
	CSecondaryDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSecondaryDlg)
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSecondaryDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual HRESULT AddSegmentToList( CSegment *pSegment );

	// Generated message map functions
	//{{AFX_MSG(CSecondaryDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECONDARYDLG_H__3152BA5B_668B_4803_8C70_3B3BC055A112__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\Segment.cpp ===
// Segment.cpp : implementation file
//

#include "stdafx.h"
#include "Segment.h"
#include "XboxAddin.h"
#include "XboxAddinComponent.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <Xbox-dmusici.h>
#pragma warning ( pop )
#include "Audiopath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DWORD CSegment::m_sdwNextIndex = 0;

CSegment::CSegment( IDMUSProdNode *pDMUSProdNode ) : CFileItem(pDMUSProdNode)
{
	m_fPlaying = false;
	m_fPressed = false;
	m_dwPlayFlags = DMUS_SEGF_DEFAULT;
	m_pAudiopath = NULL;
	m_dwStandardAudiopath = 0;

	m_dwIndex = ++m_sdwNextIndex;
}

void CSegment::ButtonClicked( void )
{
	CString strRemoteCmd;
    char    szResp[MAX_PATH];
    DWORD   cchResp = MAX_PATH;
    HRESULT hr;

	if( m_fPlaying )
	{
		strRemoteCmd.Format( TEXT(CMD_PREFIX "!stop %d %d"), m_dwIndex, m_dwPlayFlags );
	}
	else
	{
		DWORD dwAudiopathIndex = 0;
		if( m_pAudiopath )
		{
			dwAudiopathIndex = m_pAudiopath->m_dwIndex;
		}
		strRemoteCmd.Format( TEXT(CMD_PREFIX "!play %d %d %d %d"), m_dwIndex, m_dwPlayFlags, dwAudiopathIndex, m_dwStandardAudiopath );
	}


	// Send the command to the Xbox
	hr = DmSendCommand(theApp.m_pdmConnection, strRemoteCmd, szResp, &cchResp);

	// If we're not playing
	if( !m_fPlaying )
	{
		// Wait for the command to be processed
		Notification_Struct *pNotification_Struct = NULL;
		theApp.WaitForNotification( NOTIFICATION_PLAY_RESULT, &pNotification_Struct );
		if( !pNotification_Struct )
		{
			CString strPlayFailed;
			strPlayFailed.FormatMessage( IDS_ERR_PLAY_TIMEOUT, GetName() );
			XboxAddinMessageBox( NULL, strPlayFailed, MB_ICONERROR | MB_OK );
		}
		else
		{
			if( FAILED( pNotification_Struct->dwData1 ) )
			{
				CString strPlayFailed;
				strPlayFailed.FormatMessage( IDS_ERR_PLAY, GetName() );
				XboxAddinMessageBox( NULL, strPlayFailed, MB_ICONERROR | MB_OK );
			}
			else
			{
				m_fPlaying = true;
			}
			delete pNotification_Struct;
		}
	}

	// OnSegEnd sets m_fPlaying to false when the segment stops
}

HRESULT CSegment::CopyToXbox( void )
{
	HRESULT hr = CFileItem::CopyToXbox();

	if( FAILED(hr) )
	{
		return hr;
	}

	// Handle to the framework's progress bar
	HANDLE hProgressBar = NULL;

	// Initialize the progress bar
	CString strProgressText;
	strProgressText.FormatMessage( IDS_PROGRESS_DOWNLOAD, m_strDisplayName );
	theApp.m_pXboxAddinComponent->m_pIFramework->StartProgressBar( 0, 1, strProgressText.AllocSysString(), &hProgressBar );

	CString strTargetFile = theApp.m_strXboxDestination + TEXT("\\") + m_strFileName;
	CString strRemoteCmd;
	char    szResp[MAX_PATH];
	DWORD   cchResp = MAX_PATH;

	strRemoteCmd.Format( TEXT(CMD_PREFIX "!load %d \"%s\""), m_dwIndex, strTargetFile );

	// Send the command to the Xbox
	DmSendCommand(theApp.m_pdmConnection, strRemoteCmd, szResp, &cchResp);

	// Wait for the command to be processed
	Notification_Struct *pNotification_Struct = NULL;
	theApp.WaitForNotification( NOTIFICATION_LOAD_RESULT, &pNotification_Struct );
	if( !pNotification_Struct )
	{
		CString strLoadFailed;
    	strLoadFailed.FormatMessage( IDS_ERR_LOAD_TIMEOUT, GetName() );

    	while( IDRETRY == XboxAddinMessageBox( NULL, strLoadFailed, MB_ICONERROR | MB_RETRYCANCEL ) )
		{
			theApp.WaitForNotification( NOTIFICATION_LOAD_RESULT, &pNotification_Struct );
			if( pNotification_Struct )
			{
				break;
			}
		}

		if( !pNotification_Struct )
		{
			hr = E_FAIL;
		}
	}

	if( pNotification_Struct )
	{
		hr = pNotification_Struct->dwData1;
		if( FAILED( hr ) )
		{
			CString strLoadFailed;
    		strLoadFailed.FormatMessage( IDS_ERR_LOAD, GetName() );

    		XboxAddinMessageBox( NULL, strLoadFailed, MB_ICONERROR | MB_OK );
		}
		delete pNotification_Struct;
	}

	// Remove the progress bar
	if( hProgressBar )
	{
		theApp.m_pXboxAddinComponent->m_pIFramework->EndProgressBar( hProgressBar );
	}

	return hr;
}

void CSegment::OnSegEnd( void )
{
	ASSERT( m_fPlaying );
	m_fPlaying = false;
}

HRESULT CSegment::Unload( void )
{
	// Stop the segment by faking a click on the Stop button
	if( m_fPlaying )
	{
		ButtonClicked();
	}

	// Unload the segment
	CString strRemoteCmd;
	char    szResp[MAX_PATH];
	DWORD   cchResp = MAX_PATH;

	strRemoteCmd.Format( TEXT(CMD_PREFIX "!unload %d "), m_dwIndex );

	// Send the command to the Xbox
	DmSendCommand(theApp.m_pdmConnection, strRemoteCmd, szResp, &cchResp);

	// Wait for the command to be processed
	Notification_Struct *pNotification_Struct = NULL;
	theApp.WaitForNotification( NOTIFICATION_UNLOAD_RESULT, &pNotification_Struct );

	HRESULT hr = E_FAIL;

	if( pNotification_Struct )
	{
		hr = pNotification_Struct->dwData1;
		delete pNotification_Struct;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\Segment.h ===
#if !defined(AFX_SEGMENT_H__52EF9671_11A3_4073_9CE0_6F8456E61502__INCLUDED_)
#define AFX_SEGMENT_H__52EF9671_11A3_4073_9CE0_6F8456E61502__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Segment.h : header file
//

#include "FileItem.h"

class CAudiopath;

/////////////////////////////////////////////////////////////////////////////
// CSegment class

class CSegment : public CFileItem
{
public:
	CSegment( IDMUSProdNode *pDMUSProdNode );
	void ButtonClicked( void );
	virtual HRESULT CopyToXbox( void );
	HRESULT Unload( void );
	virtual void OnSegEnd( void );

	bool			m_fPlaying;
	bool			m_fPressed;
	DWORD			m_dwPlayFlags;
	DWORD			m_dwIndex;
	CAudiopath		*m_pAudiopath;
	DWORD			m_dwStandardAudiopath;

protected:
	static DWORD	m_sdwNextIndex;
};


#endif // !defined(AFX_SEGMENT_H__52EF9671_11A3_4073_9CE0_6F8456E61502__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\SegmentListBox.cpp ===
// SegmentListBox.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "SegmentListBox.h"
#include "Segment.h"
#include "XboxAddinComponent.h"
#include "XboxAddinDlg.h"
#include "LeftPaneDlg.h"
#include "Audiopath.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <Xbox-dmusici.h>
#pragma warning ( pop )

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define PLAY_ICON_HEIGHT (16)
#define PLAY_ICON_WIDTH (16)
#define PLAY_BUTTON_WIDTH (16);

/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox

CSegmentListBox::CSegmentListBox()
{
    m_hPlayIcon = AfxGetApp()->LoadIcon(IDI_PLAY);
	m_hStopIcon = AfxGetApp()->LoadIcon(IDI_STOP);
	m_hTransitionIcon = AfxGetApp()->LoadIcon(IDI_TRANSITION);
	m_pClickedSegment = NULL;
	ZeroMemory( &m_rectClicked, sizeof(m_rectClicked) );
}

CSegmentListBox::~CSegmentListBox()
{
}


BEGIN_MESSAGE_MAP(CSegmentListBox, CFileListBox)
	//{{AFX_MSG_MAP(CSegmentListBox)
	ON_WM_DRAWITEM_REFLECT()
	ON_WM_RBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox message handlers

void CSegmentListBox::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// Get the Segment
	CSegment *pSegment = reinterpret_cast<CSegment *>(lpDrawItemStruct->itemData);
	if( !pSegment )
	{
		return;
	}

	// if we're drawing a real item and the item is to be completely
	// draw or drawn as if it is selected, then ...

	if (((LONG)(lpDrawItemStruct->itemID) >= 0) &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
	{
		// set up the text color and the background color
		COLORREF oldTextColor, oldBkColor;
		if ( (lpDrawItemStruct->itemState & ODS_SELECTED) != 0 )
		{
			oldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
			oldBkColor = ::SetBkColor( lpDrawItemStruct->hDC, ::GetFocus() == m_hWnd ? ::GetSysColor(COLOR_HIGHLIGHT) : ::GetSysColor(COLOR_INACTIVECAPTION) );
		}
		else
		{
			oldTextColor = ::SetTextColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_WINDOWTEXT) );
			oldBkColor = ::SetBkColor( lpDrawItemStruct->hDC, ::GetSysColor(COLOR_WINDOW) );
		}

		// Draw the (un)selected background
		::ExtTextOut( lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &lpDrawItemStruct->rcItem, NULL, 0, NULL);

        // Play button
        RECT rect;
        rect = lpDrawItemStruct->rcItem;

		// Set the correct button style (pushed/unpushed)
		const DWORD dwFrameStyle = pSegment->m_fPressed ? DFCS_BUTTONPUSH | DFCS_CHECKED : DFCS_BUTTONPUSH;
        rect.right = PLAY_BUTTON_WIDTH;
        ::DrawFrameControl( lpDrawItemStruct->hDC, &rect, DFC_BUTTON, dwFrameStyle );

		// Choose the correct icon to display
		HICON hIconToUse;
		if( pSegment->m_fPlaying )
		{
			hIconToUse = m_hStopIcon;
		}
		else
		{
			hIconToUse = m_hPlayIcon;
		}

        int nYPos = ((rect.bottom + rect.top) / 2) - (PLAY_ICON_HEIGHT / 2);
        ::DrawIconEx( lpDrawItemStruct->hDC, rect.left, nYPos, hIconToUse, PLAY_ICON_WIDTH, PLAY_ICON_HEIGHT, 0, NULL, DI_NORMAL );

        // Set up the text rectangle
        rect.left = PLAY_BUTTON_WIDTH;
        rect.right = lpDrawItemStruct->rcItem.right;

		// Segment Name
		//if( LB_ERR != m_listSegment.GetItemRect( lpDrawItemStruct->itemID, &rect ) )
		{
			::DrawText( lpDrawItemStruct->hDC, pSegment->GetName(), -1, &rect, DT_SINGLELINE | DT_NOPREFIX | DT_LEFT | DT_END_ELLIPSIS );
		}

		// restore the old objects in the DC
		::SetTextColor( lpDrawItemStruct->hDC, oldTextColor );
		::SetBkColor( lpDrawItemStruct->hDC, oldBkColor);
	}

	// if the item is focused, draw the focus rectangle
	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
	{
		::DrawFocusRect( lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem) );
	}
}

void InsertAudiopathItem( HMENU hAudiopathMenu, int nMenuID, int nAudiopathIndex, const CSegment *pSegment )
{
	MENUITEMINFO menuItemInfo;
	ZeroMemory( &menuItemInfo, sizeof(MENUITEMINFO) );
	menuItemInfo.cbSize = sizeof(MENUITEMINFO);

	menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
	menuItemInfo.fType = MFT_STRING;

	const CAudiopath *pAudiopath = reinterpret_cast<CAudiopath *>(theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->m_pLeftPaneDlg->m_listAudiopath.GetItemDataPtr( nAudiopathIndex ));

	// Add an extra & to any &s in the string, to ensure they display properly
	CString strName = pAudiopath->GetName();
	int nIndex = 0;
	while( nIndex != -1 )
	{
		nIndex = strName.Find( '&', nIndex );
		if( nIndex != -1 )
		{
			strName.Insert( nIndex, '&' );
			nIndex+=2;
		}
	}

	menuItemInfo.dwTypeData = strName.GetBuffer( strName.GetLength() );
	if( (pSegment->m_pAudiopath == NULL)
	&&	(pSegment->m_dwStandardAudiopath == 0)
	&&	pAudiopath->IsDefault() )
	{
		menuItemInfo.fState = MFS_CHECKED;
	}
	else
	{
		menuItemInfo.fState = (pSegment->m_pAudiopath == pAudiopath) ? MFS_CHECKED : 0;
	}
	menuItemInfo.wID = nMenuID;
	::InsertMenuItem( hAudiopathMenu, 0, true, &menuItemInfo );
}

void CSegmentListBox::OnRButtonUp(UINT nFlags, CPoint point) 
{
	UNREFERENCED_PARAMETER(nFlags);

	BOOL bOutside = TRUE;
	int nIndex = ItemFromPoint( point, bOutside );

	if( !bOutside )
	{
		CSegment *pSegment = reinterpret_cast<CSegment *>(GetItemDataPtr( nIndex ));

		HMENU hMenuMain = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_SEGMENT_MENU) );
		if( hMenuMain )
		{
			HMENU hSubMenu = ::GetSubMenu( hMenuMain, 0 );
			if( hSubMenu )
			{
				HMENU hAudiopathMenu = ::GetSubMenu( hSubMenu, 1 );
				if( hAudiopathMenu )
				{
					if( theApp.m_pXboxAddinComponent->m_lstAudiopaths.GetCount() > 2 )
					{
						InsertAudiopathItem( hAudiopathMenu, ID__USEAUDIOPATH_AUDIOPATH3, 2, pSegment );
					}

					if( theApp.m_pXboxAddinComponent->m_lstAudiopaths.GetCount() > 1 )
					{
						InsertAudiopathItem( hAudiopathMenu, ID__USEAUDIOPATH_AUDIOPATH2, 1, pSegment );
					}

					if( theApp.m_pXboxAddinComponent->m_lstAudiopaths.GetCount() > 0 )
					{
						InsertAudiopathItem( hAudiopathMenu, ID__USEAUDIOPATH_AUDIOPATH1, 0, pSegment );
					}

					// If set to use a standard audiopath
					int nItemID = 0;
					switch( pSegment->m_dwStandardAudiopath )
					{
					case DMUS_APATH_SHARED_STEREOPLUSREVERB:
						nItemID = ID__USEAUDIOPATH_STANDARDSTEREOREVERB;
						break;
					case DMUS_APATH_DYNAMIC_3D:
						nItemID = ID__USEAUDIOPATH_STANDARD3DDRY;
						break;
					case DMUS_APATH_DYNAMIC_MONO:
						nItemID = ID__USEAUDIOPATH_STANDARDMONO;
						break;
                    case DMUS_APATH_MIXBIN_QUAD_MUSIC:
                        nItemID = ID__USEAUDIOPATH_STANDARDQUADMUSIC;
                        break;
                    case DMUS_APATH_MIXBIN_QUAD_ENV:
                        nItemID = ID__USEAUDIOPATH_STANDARDQUADENV;
                        break;
                    case DMUS_APATH_MIXBIN_5DOT1_MUSIC:
                        nItemID = ID__USEAUDIOPATH_STANDARD51MUSIC;
                        break;
                    case DMUS_APATH_MIXBIN_5DOT1_ENV:
                        nItemID = ID__USEAUDIOPATH_STANDARD51ENV;
                        break;
                    case DMUS_APATH_MIXBIN_STEREO_EFFECTS:
                        nItemID = ID__USEAUDIOPATH_STANDARDSTEREOEFFECT;
                        break;
					case DMUS_APATH_SHARED_STEREO:
						nItemID = ID__USEAUDIOPATH_STANDARDSHAREDSTEREO;
						break;
					}
					if( nItemID)
					{
						::CheckMenuItem( hAudiopathMenu, nItemID, MF_BYCOMMAND | MF_CHECKED );
					}

					if( pSegment->m_fPlaying )
					{
						// Disable the audiopath items if the segment is playing
						for( int i=::GetMenuItemCount(hAudiopathMenu)-1; i >= 0 ; i-- )
						{
							::EnableMenuItem( hAudiopathMenu, i, MF_BYPOSITION | MF_GRAYED );
						}
					}

					theApp.m_pXboxAddinComponent->m_lstAudiopaths;
				}

				POINT point;
				::GetCursorPos( &point );
				int nChosenCommand = ::TrackPopupMenu( hSubMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON, point.x, point.y, 0, GetSafeHwnd(), NULL );

				if( nChosenCommand )
				{
					::SendMessage( ::GetParent( GetSafeHwnd() ), WM_APP, (WPARAM)nChosenCommand, (LPARAM)pSegment );
				}
			}
		}
	}
	else
	{
		CFileListBox::OnRButtonUp(nFlags, point);
	}
}

void CSegmentListBox::OnLButtonDown(UINT nFlags, CPoint point) 
{
	if( point.x < 16 )
	{
		BOOL bOutside = TRUE;
		int nIndex = ItemFromPoint( point, bOutside );

		if( !bOutside )
		{
			m_pClickedSegment = reinterpret_cast<CSegment *>(GetItemDataPtr( nIndex ));
			m_pClickedSegment->m_fPressed = true;

			// Redraw the button
			if( LB_ERR != GetItemRect( nIndex, &m_rectClicked ) )
			{
				m_rectClicked.right = 16;
				InvalidateRect( &m_rectClicked, FALSE );
			}
		}
	}
	
	CFileListBox::OnLButtonDown(nFlags, point);
}

void CSegmentListBox::OnLButtonUp(UINT nFlags, CPoint point) 
{
	if( point.x < 16 )
	{
		BOOL bOutside = TRUE;
		int nIndex = ItemFromPoint( point, bOutside );

		if( !bOutside )
		{
			CSegment *pSegment = reinterpret_cast<CSegment *>(GetItemDataPtr( nIndex ));
			if( pSegment == m_pClickedSegment )
			{
				pSegment->ButtonClicked();
			}
		}
	}

	if( m_pClickedSegment )
	{
		m_pClickedSegment->m_fPressed = false;
		m_pClickedSegment = NULL;
	}

	// Redraw the button
	if( m_rectClicked.right > 0 )
	{
		InvalidateRect( &m_rectClicked, FALSE );
		m_rectClicked.right = 0;
	}
	
	CFileListBox::OnLButtonUp(nFlags, point);
}

void CSegmentListBox::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if( VK_DELETE == nChar )
	{
		// Delete the currently selected item
		int nIndex = GetCurSel();
		if( nIndex != LB_ERR )
		{
			CSegment *pSegment = reinterpret_cast<CSegment *>(GetItemDataPtr( nIndex ));
			if( pSegment )
			{
				::SendMessage( ::GetParent( GetSafeHwnd() ), WM_APP, ID_DELETE_SEGMENT, (LPARAM)pSegment );
			}
		}
	}
	
	CFileListBox::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\SegmentDlg.cpp ===
// SegmentDlg.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "SegmentDlg.h"
#include "Segment.h"
#include "DllJazzDataObject.h"
#include "dmpprivate.h"
#include "dmusprod.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <Xbox-dmusici.h>
#pragma warning ( pop )
#include "XboxAddinComponent.h"
#include "SegmentListBox.h"
#include "XboxAddinDlg.h"
#include "LeftPaneDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg dialog


CSegmentDlg::CSegmentDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSegmentDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSegmentDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_cfFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfSegment = ::RegisterClipboardFormat( CF_SEGMENT );
	m_plstSegments = NULL;
}

CSegmentDlg::~CSegmentDlg()
{
	while( !m_lstSegmentsToSynchronize.IsEmpty() )
	{
		delete m_lstSegmentsToSynchronize.RemoveHead();
	}
}

void CSegmentDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSegmentDlg)
	DDX_Control(pDX, IDC_STATIC_SEGMENT, m_staticSegment);
	DDX_Control(pDX, IDC_LIST_SEGMENT, m_listSegment);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSegmentDlg, CDialog)
	//{{AFX_MSG_MAP(CSegmentDlg)
	ON_WM_SIZE()
	ON_MESSAGE(WM_APP,OnApp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg message handlers

void CSegmentDlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);

	if( nType == SIZE_MINIMIZED )
	{
		return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow( m_listSegment.GetSafeHwnd() ) )
	{
		return;
	}

	RECT rectWindow;
	GetClientRect( &rectWindow );

	RECT rect;
	m_staticSegment.GetClientRect( &rect );
	rect.right = rectWindow.right;
	rect.bottom += 2 * ::GetSystemMetrics(SM_CYBORDER);
	m_staticSegment.MoveWindow( &rect );

	rect.top = rect.bottom;
	rect.bottom = rectWindow.bottom;
	m_listSegment.MoveWindow( &rect );
}

BOOL CSegmentDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	ASSERT( m_plstSegments );

	POSITION pos = m_plstSegments->GetHeadPosition();
	while( pos )
	{
		CSegment *pSegment = m_plstSegments->GetNext( pos );
		m_listSegment.AddString( (LPCTSTR) pSegment );
	}

	m_DropTarget.m_pDropControl = this;
	::RegisterDragDrop( m_listSegment.GetSafeHwnd(), &m_DropTarget );

	return TRUE;  // return TRUE unless you set the focus to a control
				  // EXCEPTION: OCX Property Pages should return FALSE
}

void CSegmentDlg::OnOK() 
{
	// Do nothing
}

LRESULT CSegmentDlg::OnApp(WPARAM wParam, LPARAM lParam)
{
	bool fSetAudiopath = true;
	CAudiopath *pAudiopath = NULL;
	DWORD dwStandardAudiopath = 0;
	switch( wParam )
	{
	case ID_DELETE_SEGMENT:
		DeleteSegment( (CSegment *) lParam, false );
	default:
		fSetAudiopath = false;
		break;
	case ID__USEAUDIOPATH_AUDIOPATH1:
		pAudiopath = reinterpret_cast<CAudiopath *>(theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->m_pLeftPaneDlg->m_listAudiopath.GetItemDataPtr( 0 ));
		break;
	case ID__USEAUDIOPATH_AUDIOPATH2:
		pAudiopath = reinterpret_cast<CAudiopath *>(theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->m_pLeftPaneDlg->m_listAudiopath.GetItemDataPtr( 1 ));
		break;
	case ID__USEAUDIOPATH_AUDIOPATH3:
		pAudiopath = reinterpret_cast<CAudiopath *>(theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->m_pLeftPaneDlg->m_listAudiopath.GetItemDataPtr( 2 ));
		break;
	case ID__USEAUDIOPATH_STANDARDSTEREOREVERB:
		dwStandardAudiopath = DMUS_APATH_SHARED_STEREOPLUSREVERB;
		break;
	case ID__USEAUDIOPATH_STANDARD3DDRY:
		dwStandardAudiopath = DMUS_APATH_DYNAMIC_3D;
		break;
	case ID__USEAUDIOPATH_STANDARDMONO:
		dwStandardAudiopath = DMUS_APATH_DYNAMIC_MONO;
		break;
	case ID__USEAUDIOPATH_STANDARDSHAREDSTEREO:
		dwStandardAudiopath = DMUS_APATH_SHARED_STEREO;
		break;
	case ID__USEAUDIOPATH_STANDARDQUAD:
		dwStandardAudiopath = DMUS_APATH_MIXBIN_QUAD;
		break;
	case ID__USEAUDIOPATH_STANDARDQUADMUSIC:
		dwStandardAudiopath = DMUS_APATH_MIXBIN_QUAD_MUSIC;
		break;
	case ID__USEAUDIOPATH_STANDARDQUADENV:
		dwStandardAudiopath = DMUS_APATH_MIXBIN_QUAD_ENV;
		break;
	case ID__USEAUDIOPATH_STANDARD51:
		dwStandardAudiopath = DMUS_APATH_MIXBIN_5DOT1;
		break;
	case ID__USEAUDIOPATH_STANDARD51MUSIC:
		dwStandardAudiopath = DMUS_APATH_MIXBIN_5DOT1_MUSIC;
		break;
	case ID__USEAUDIOPATH_STANDARD51ENV:
		dwStandardAudiopath = DMUS_APATH_MIXBIN_5DOT1_ENV;
		break;
	case ID__USEAUDIOPATH_STANDARDSTEREOEFFECT:
		dwStandardAudiopath = DMUS_APATH_MIXBIN_STEREO_EFFECTS;
		break;
	}

	if( fSetAudiopath )
	{
		CSegment *pSegment = (CSegment *) lParam;
		pSegment->m_pAudiopath = pAudiopath;
		pSegment->m_dwStandardAudiopath = dwStandardAudiopath;
	}

	return 0;
}

void CSegmentDlg::InternalDragOver( DWORD grfKeyState, POINTL ptScreen, IDataObject* pIDataObject, DWORD* pdwEffect )
{
	UNREFERENCED_PARAMETER( grfKeyState );
	UNREFERENCED_PARAMETER( ptScreen );
	if( !theApp.m_fConnected )
	{
		*pdwEffect = DROPEFFECT_NONE;
		return;
	}

	/*
	// Highlight the item under the mouse and 
	CMultiTree *pDestTreeCtrl = &(m_pAudioPathDlg->m_tcTree);
	POINT point = {pointl.x, pointl.y};
	pDestTreeCtrl->ScreenToClient( &point );

	ItemInfo *pItemInfo;
	BufferOptions *pBufferOptions;
	pDestTreeCtrl->GetItemBufferEffectUnderPoint( point, &pItemInfo, &pBufferOptions, NULL );
	
	// Scroll Tree control depending on mouse position
	CRect rectClient;
	pDestTreeCtrl->GetClientRect(&rectClient);
	pDestTreeCtrl->ClientToScreen(rectClient);
	pDestTreeCtrl->ClientToScreen(&point);
	int nScrollDir = -1;
	if ( point.y >= rectClient.bottom - RECT_BORDER)
		nScrollDir = SB_LINEDOWN;
	else
	if ( (point.y <= rectClient.top + RECT_BORDER) )
		nScrollDir = SB_LINEUP;

	
	if ( nScrollDir != -1 ) 
	{
		int nScrollPos = pDestTreeCtrl->GetScrollPos(SB_VERT);
		WPARAM wParam = MAKELONG(nScrollDir, nScrollPos);
		pDestTreeCtrl->SendMessage(WM_VSCROLL, wParam);
	}
	
	nScrollDir = -1;
	if ( point.x <= rectClient.left + RECT_BORDER )
		nScrollDir = SB_LINELEFT;
	else
	if ( point.x >= rectClient.right - RECT_BORDER)
		nScrollDir = SB_LINERIGHT;
	
	if ( nScrollDir != -1 ) 
	{
		int nScrollPos = pDestTreeCtrl->GetScrollPos(SB_VERT);
		WPARAM wParam = MAKELONG(nScrollDir, nScrollPos);
		pDestTreeCtrl->SendMessage(WM_HSCROLL, wParam);
	}
	*/

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject )
	{
		if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_cfSegment ) ) )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_cfFile ) ) )
		{
			IDMUSProdNode *pIDMUSProdNode = NULL;
			if( theApp.m_pXboxAddinComponent
			&&	theApp.m_pXboxAddinComponent->m_pIFramework
			&&	SUCCEEDED( theApp.m_pXboxAddinComponent->m_pIFramework->GetDocRootNodeFromData( pIDataObject, &pIDMUSProdNode ) ) )
			{
				GUID guidNode = GUID_NULL;
				if( SUCCEEDED( pIDMUSProdNode->GetNodeId( &guidNode ) )
				&&	guidNode == GUID_SegmentNode)
				{
					dwEffect = DROPEFFECT_COPY;
				}
				pIDMUSProdNode->Release();
			}
		}

		delete pDataObject;
	}

	*pdwEffect = dwEffect;
}

void CSegmentDlg::InternalDrop( IDataObject* pIDataObject, POINTL ptScreen, DWORD dwEffect)
{
	UNREFERENCED_PARAMETER( ptScreen );

	if( dwEffect != DROPEFFECT_COPY )
	{
		return;
	}

	// Display a wait cursor - this may take a while
	CWaitCursor waitCursor;

	IDMUSProdNode *pIDMUSProdNode = NULL;
	if( theApp.m_pXboxAddinComponent
	&&	theApp.m_pXboxAddinComponent->m_pIFramework
	&&	SUCCEEDED( theApp.m_pXboxAddinComponent->m_pIFramework->GetDocRootNodeFromData( pIDataObject, &pIDMUSProdNode ) ) )
	{
		GUID guidNode = GUID_NULL;
		if( SUCCEEDED( pIDMUSProdNode->GetNodeId( &guidNode ) )
		&&	guidNode == GUID_SegmentNode)
		{
			// Add it to our internal list and the display
			AddNodeToDisplay( pIDMUSProdNode );
		}
		pIDMUSProdNode->Release();
	}
	/*
	//Remove highlighting
	//m_pAudioPathDlg->m_tcTree.SendMessage(TVM_SELECTITEM, TVGN_DROPHILITE,0);

	POINT ptShort = {point.x, point.y};
	m_pAudioPathDlg->m_tcTree.ScreenToClient( &ptShort );

	HRESULT hr = m_pAudioPathDlg->DropOnTree( pIDataObject, m_dwOverDragEffect, ptShort );
	*/
}

void CSegmentDlg::InternalDragLeave( void )
{
	if( theApp.m_fConnected )
	{
		//m_pAudioPathDlg->m_tcTree.SendMessage(TVM_SELECTITEM, TVGN_DROPHILITE,0);
	}
}

HRESULT CSegmentDlg::AddSegmentToList( CSegment *pSegment )
{
	if( pSegment == NULL )
	{
		return E_POINTER;
	}

	ASSERT( m_plstSegments );

	// Check if segment name is already used
	int nAppendValue = 0;
	bool fFound = true;
	CString strSegmentName = pSegment->GetFileName();
	while( fFound )
	{
		fFound = false;
		POSITION pos = m_plstSegments->GetHeadPosition();
		while( pos )
		{
			CSegment *pTemp = m_plstSegments->GetNext( pos );
			if( strSegmentName == pTemp->GetFileName()
			&&	nAppendValue == pTemp->m_nAppendValue )
			{
				fFound = true;
				nAppendValue++;
				break;
			}
		}
	}

	// Set the segment's append value
	pSegment->SetAppendValue( nAppendValue );

	// Add to our list
	m_plstSegments->AddHead( pSegment );

	// Copy to Xbox
	HRESULT hr = pSegment->CopyToXbox( );

	if( SUCCEEDED(hr) )
	{
		// Add it to the display
		if( m_listSegment.GetSafeHwnd() )
		{
			m_listSegment.AddString( (LPCTSTR) pSegment );
		}
	}
	else
	{
		// Remove it from our list
		POSITION pos = m_plstSegments->Find( pSegment );
		if( pos )
		{
			m_plstSegments->RemoveAt( pos );
		}

		// Delete it
		delete pSegment;

		// Now, clean up the display
		theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->CleanUpDisplay();
	}

	return hr;
}

void CSegmentDlg::OnConnectionStateChanged( void )
{
	m_listSegment.EnableWindow( theApp.m_fConnected );
	m_staticSegment.EnableWindow( theApp.m_fConnected );
}

bool CSegmentDlg::IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode )
{
	ASSERT( m_plstSegments );

	POSITION pos = m_plstSegments->GetHeadPosition();
	while( pos )
	{
		CSegment *pSegment = m_plstSegments->GetNext( pos );
		if( pSegment->ContainsNode( pIDMUSProdNode ) )
		{
			return true;
		}
	}
	return false;
}

HRESULT CSegmentDlg::AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode )
{
	// Add it to our internal list
	return AddSegmentToList( new CSegment(pIDMUSProdNode) );
}

void CSegmentDlg::HandleNotification( NOTIFICATION_TYPE notificationType, DWORD dwSegmentID, DWORD dwData1 )
{
	// Find the segment from the given ID
	CSegment *pSegment = SegmentFromID( dwSegmentID );

	switch( notificationType )
	{
	case NOTIFICATION_SEGMENT:
		HandleSegmentNotification( pSegment, dwData1 );
		break;
	default:
		break;
	}
}

void CSegmentDlg::HandleSegmentNotification( CSegment *pSegment, DWORD dwNotification )
{
	// Only handle SEGEND and SEGABORT notifications
	if( (dwNotification != DMUS_NOTIFICATION_SEGEND)
	&&	(dwNotification != DMUS_NOTIFICATION_SEGABORT) )
	{
		return;
	}

	// If we found the segment that stopped
	if( pSegment )
	{
		// Tell it that it stopped
		pSegment->OnSegEnd();

		// Search for it in the listbox
		for( int nIndex = m_listSegment.GetCount() - 1; nIndex >= 0; nIndex-- )
		{
			if( m_listSegment.GetItemDataPtr( nIndex ) == pSegment )
			{
				// Redraw it
				RECT rectItem;
				m_listSegment.GetItemRect( nIndex, &rectItem );
				m_listSegment.InvalidateRect( &rectItem, TRUE );
				break;
			}
		}
	}
}

void CSegmentDlg::OnPanic( void )
{
	// Mark all segments as not playing
	ASSERT( m_plstSegments );
	POSITION pos = m_plstSegments->GetHeadPosition();
	while( pos )
	{
		CSegment *pSegment = m_plstSegments->GetNext( pos );
		pSegment->m_fPlaying = false;
	}

	// Redraw the listbox
	m_listSegment.Invalidate( TRUE );
}

CSegment *CSegmentDlg::SegmentFromID( DWORD dwID )
{
	ASSERT( m_plstSegments );

	POSITION pos = m_plstSegments->GetHeadPosition();
	while( pos )
	{
		CSegment *pSegment = m_plstSegments->GetNext( pos );
		if( pSegment->m_dwIndex == dwID )
		{
			return pSegment;
		}
	}

	return NULL;
}

void CSegmentDlg::DeleteSegment( CSegment *pSegment, bool fForceDeletion )
{
	// Block deletion if the segment is referenced by another file
	if( !fForceDeletion )
	{
		if( theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->IsFileInUse( pSegment ) )
		{
			return;
		}
	}

	// Unload it from the Xbox
	if( FAILED( pSegment->Unload() ) )
	{
		CString strErrorText;
		strErrorText.FormatMessage( IDS_ERR_UNLOAD, pSegment->GetName() );
		XboxAddinMessageBox( this, strErrorText, MB_ICONERROR | MB_OK );
		return;
	}

	// Remove it from the Xbox
	if( FAILED( pSegment->RemoveFromXbox() ) )
	{
		CString strErrorText;
		strErrorText.FormatMessage( IDS_ERR_REMOVE_SEGMENT, pSegment->GetName() );
		XboxAddinMessageBox( this, strErrorText, MB_ICONERROR | MB_OK );
		return;
	}

	// Remove it from the display
	int nIndex = m_listSegment.IndexFromFile( pSegment );
	if( nIndex != LB_ERR )
	{
		m_listSegment.DeleteString( nIndex );
	}

	// Remove it from the list
	ASSERT( m_plstSegments );
	POSITION posSegment = m_plstSegments->Find( pSegment );
	if( posSegment )
	{
		m_plstSegments->RemoveAt( posSegment );
	}

	// Finally, delete it
	delete pSegment;

	// Now, clean up the display
	theApp.m_pXboxAddinComponent->m_pXboxAddinDlg->CleanUpDisplay();
}

bool CSegmentDlg::IsFileInUse( CFileItem *pFileItem )
{
	ASSERT( m_plstSegments );

	POSITION pos = m_plstSegments->GetHeadPosition();
	while( pos )
	{
		CSegment *pSegment = m_plstSegments->GetNext( pos );
		if( (CFileItem *)pSegment != pFileItem )
		{
			if( pSegment->UsesFile( pFileItem ) )
			{
				return true;
			}
		}
	}

	return false;
}

void CSegmentDlg::UnloadAll( void )
{
	ASSERT( m_plstSegments );

	POSITION pos = m_plstSegments->GetHeadPosition();
	while( pos )
	{
		CSegment *pSegment = m_plstSegments->GetNext( pos );
		pSegment->Unload();
	}
}

void CSegmentDlg::DeleteAll( void )
{
	ASSERT( m_plstSegments );

	// Copy the segments to a temporary list and delete them from the Xbox
	while( !m_plstSegments->IsEmpty() )
	{
		CSegment *pSegment = m_plstSegments->RemoveHead();
		m_lstSegmentsToSynchronize.AddHead( pSegment );
		pSegment->RemoveFromXbox();
	}
}

void CSegmentDlg::ReCopyAll( void )
{
	// Clear the display
	m_listSegment.ResetContent();

	// Re-add the segments
	IDMUSProdProject *pIDMUSProdProject;
	while( !m_lstSegmentsToSynchronize.IsEmpty() )
	{
		// Remove the segment from our temporary list
		CSegment *pSegment = m_lstSegmentsToSynchronize.RemoveHead();

		// Check if the node still exists
		pIDMUSProdProject = NULL;
		if( SUCCEEDED( theApp.m_pXboxAddinComponent->m_pIFramework->FindProject( pSegment->m_pFileNode, &pIDMUSProdProject ) )
		&&	pIDMUSProdProject )
		{
			// Yes - add the segment to the display
			AddNodeToDisplay( pSegment->m_pFileNode );
			pIDMUSProdProject->Release();
		}

		// Delete the temporary segment
		delete pSegment;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	XboxAddin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F4BE70F5_2CE8_42DE_B21C_9244F968F42D__INCLUDED_)
#define AFX_STDAFX_H__F4BE70F5_2CE8_42DE_B21C_9244F968F42D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F4BE70F5_2CE8_42DE_B21C_9244F968F42D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\SegmentListBox.h ===
#if !defined(AFX_SEGMENTLISTBOX_H__12C270B9_4438_4283_908C_CB5BFADD59CB__INCLUDED_)
#define AFX_SEGMENTLISTBOX_H__12C270B9_4438_4283_908C_CB5BFADD59CB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "FileListBox.h"

// SegmentListBox.h : header file
//

class CSegment;

/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox window

class CSegmentListBox : public CFileListBox
{
// Construction
public:
	CSegmentListBox();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSegmentListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSegmentListBox();

protected:
    HICON m_hPlayIcon;
    HICON m_hStopIcon;
    HICON m_hTransitionIcon;

	CSegment	*m_pClickedSegment;
	RECT		m_rectClicked;

	// Generated message map functions
protected:
	//{{AFX_MSG(CSegmentListBox)
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEGMENTLISTBOX_H__12C270B9_4438_4283_908C_CB5BFADD59CB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\SegmentDlg.h ===
#if !defined(AFX_SEGMENTDLG_H__B682037D_5EFD_4DF2_8B8E_5A5D7C86B386__INCLUDED_)
#define AFX_SEGMENTDLG_H__B682037D_5EFD_4DF2_8B8E_5A5D7C86B386__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SegmentListBox.h"
#include "DropTarget.h"

// SegmentDlg.h : header file
//

class CFileItem;
class CSegment;
interface IDMUSProdFramework;
interface IDMUSProdNode;

/////////////////////////////////////////////////////////////////////////////
// CSegmentDlg dialog

class CSegmentDlg : public CDialog, public CDropControl
{
// Construction
public:
	CSegmentDlg(CWnd* pParent = NULL);   // standard constructor
    ~CSegmentDlg();

	void OnConnectionStateChanged( void );
	bool IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode );
	bool IsFileInUse( CFileItem *pFileItem );
	HRESULT AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode );
	virtual void HandleNotification( NOTIFICATION_TYPE notificationType, DWORD dwSegmentID, DWORD dwData1 );
	virtual void HandleSegmentNotification( CSegment *pSegment, DWORD dwNotification );
	virtual void OnPanic( void );
	virtual void DeleteSegment( CSegment *pSegment, bool fForceDeletion );
	virtual void UnloadAll( void );
	virtual void DeleteAll( void );
	virtual void ReCopyAll( void );

// Dialog Data
	//{{AFX_DATA(CSegmentDlg)
	enum { IDD = IDD_SEGMENT };
	CStatic	m_staticSegment;
	CSegmentListBox	m_listSegment;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSegmentDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// CDropControl implementation
	virtual void InternalDragOver( DWORD grfKeyState, POINTL ptScreen, IDataObject* pIDataObject, DWORD* pdwEffect );
	virtual void InternalDrop( IDataObject* pIDataObject, POINTL ptScreen, DWORD dwEffect);
	virtual void InternalDragLeave( void );

// Implementation
protected:
	CTypedPtrList< CPtrList, CSegment *> *m_plstSegments;
	CTypedPtrList< CPtrList, CSegment *> m_lstSegmentsToSynchronize;
	CDropTarget	m_DropTarget;
	UINT		m_cfSegment;
	UINT		m_cfFile;

	virtual HRESULT AddSegmentToList( CSegment *pSegment );
	CSegment *SegmentFromID( DWORD dwID );

	// Generated message map functions
	//{{AFX_MSG(CSegmentDlg)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnApp(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEGMENTDLG_H__B682037D_5EFD_4DF2_8B8E_5A5D7C86B386__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\TargetDirectoryDlg.h ===
#if !defined(AFX_TARGETDIRECTORYDLG_H__37BC6E2C_A711_4D78_BD08_2E7B086AE2EB__INCLUDED_)
#define AFX_TARGETDIRECTORYDLG_H__37BC6E2C_A711_4D78_BD08_2E7B086AE2EB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TargetDirectoryDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTargetDirectoryDlg dialog

class CTargetDirectoryDlg : public CDialog
{
// Construction
public:
	CTargetDirectoryDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTargetDirectoryDlg)
	enum { IDD = IDD_TARGET_DIRECTORY };
	CButton	m_btnSynchronize;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTargetDirectoryDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTargetDirectoryDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSynchronize();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TARGETDIRECTORYDLG_H__37BC6E2C_A711_4D78_BD08_2E7B086AE2EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\TargetDirectoryDlg.cpp ===
// TargetDirectoryDlg.cpp : implementation file
//

#include "stdafx.h"
#include "xboxaddin.h"
#include "TargetDirectoryDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTargetDirectoryDlg dialog


CTargetDirectoryDlg::CTargetDirectoryDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTargetDirectoryDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTargetDirectoryDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CTargetDirectoryDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTargetDirectoryDlg)
	DDX_Control(pDX, IDC_SYNCHRONIZE, m_btnSynchronize);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTargetDirectoryDlg, CDialog)
	//{{AFX_MSG_MAP(CTargetDirectoryDlg)
	ON_BN_CLICKED(IDC_SYNCHRONIZE, OnSynchronize)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTargetDirectoryDlg message handlers

BOOL CTargetDirectoryDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	int nBackSlashIndex = theApp.m_strXboxDestination.Find('\\');

	// Shouldn't happen
	ASSERT( nBackSlashIndex != -1 );

	// Strip off everything before the first \, including the backslash
	CString strDestination = theApp.m_strXboxDestination.Right( theApp.m_strXboxDestination.GetLength() - nBackSlashIndex - 1 );

	SetDlgItemText( IDC_EDIT_DIRECTORY, strDestination );

	m_btnSynchronize.EnableWindow( theApp.m_fConnected );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTargetDirectoryDlg::OnOK() 
{
	CString strDestination;
	GetDlgItemText( IDC_EDIT_DIRECTORY, strDestination );

	// Remove trailing backslashes
	while( !strDestination.IsEmpty()
	&&	_T('\\') == strDestination.GetAt( strDestination.GetLength() - 1 ) )
	{
		strDestination = strDestination.Left(strDestination.GetLength() - 1);
	}

	// Remove leading backslashes
	while( !strDestination.IsEmpty()
	&&	_T('\\') == strDestination.GetAt( 0 ) )
	{
		strDestination = strDestination.Right(strDestination.GetLength() - 1);
	}

	// Add T:\ to the front of the directory name
	strDestination = _T("T:\\") + strDestination;
	
	if( strDestination.IsEmpty() )
	{
		// Can't have an empty directory
		CString strMessage;
		strMessage.LoadString( IDS_ERR_PATH_EMPTY );
		XboxAddinMessageBox( this, strMessage, MB_ICONERROR | MB_OK );
		return;
	}

	bool fContinue = true;

	if( theApp.m_fConnected )
	{
		DM_FILE_ATTRIBUTES dmFileAttributes;
		HRESULT hr = DmGetFileAttributes( strDestination, &dmFileAttributes );
		if( FAILED(hr) )
		{
			// Directory does not exist
			CString strMessage;
			strMessage.FormatMessage( IDS_ERR_PATH_NOEXIST, strDestination );
			if( IDOK == XboxAddinMessageBox( this, strMessage, MB_ICONERROR | MB_OKCANCEL ) )
			{
				if( FAILED( DmMkdir( strDestination ) ) )
				{
					strMessage.FormatMessage( IDS_ERR_PATH_CANTCREATE, strDestination );
					XboxAddinMessageBox( this, strMessage, MB_ICONERROR | MB_OK );
					fContinue = false;
				}
			}
			else
			{
				fContinue = false;
			}
		}
		else if( !(dmFileAttributes.Attributes & FILE_ATTRIBUTE_DIRECTORY) )
		{
			// File with same name exists
			CString strMessage;
			strMessage.LoadString( IDS_ERR_PATH_FILEEXIST );
			XboxAddinMessageBox( this, strMessage, MB_ICONERROR | MB_OK );
			fContinue = false;
		}
	}

	if( fContinue )
	{
		theApp.m_strXboxDestination = strDestination;
		SetUserRegString( _T("XboxPath"), theApp.m_strXboxDestination );
		theApp.UpdateTargetDirectory();
		CDialog::OnOK();
	}
}

void CTargetDirectoryDlg::OnSynchronize() 
{
	OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\TargetXboxDlg.cpp ===
// TargetXboxDlg.cpp : implementation file
//

#include "stdafx.h"
#include "xboxaddin.h"
#include "TargetXboxDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTargetXboxDlg dialog


CTargetXboxDlg::CTargetXboxDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTargetXboxDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTargetXboxDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CTargetXboxDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTargetXboxDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTargetXboxDlg, CDialog)
	//{{AFX_MSG_MAP(CTargetXboxDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTargetXboxDlg message handlers

void CTargetXboxDlg::OnOK() 
{
	CString strXboxName;
	GetDlgItemText( IDC_EDIT_XBOX_NAME, strXboxName );

	if( strXboxName.IsEmpty() )
	{
		// Can't have an empty name
		CString strMessage;
		strMessage.LoadString( IDS_ERR_NAME_EMPTY );
		XboxAddinMessageBox( this, strMessage, MB_ICONERROR | MB_OK );
		return;
	}

	theApp.m_strXboxName = strXboxName;
	SetUserRegString( _T("XboxName"), strXboxName );

    DWORD dwDefaultChecked = IsDlgButtonChecked( IDC_CHECK_DEFAULT );
    SetUserRegDWORD( _T("XboxNameSetDefault"), &dwDefaultChecked );

    if( dwDefaultChecked )
    {
        DmSetXboxName( strXboxName );
    }

	CDialog::OnOK();
}

BOOL CTargetXboxDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	SetDlgItemText( IDC_EDIT_XBOX_NAME, theApp.m_strXboxName );

    DWORD dwDefaultChecked = TRUE;
    GetUserRegDWORD( _T("XboxNameSetDefault"), &dwDefaultChecked );
    CheckDlgButton( IDC_CHECK_DEFAULT, dwDefaultChecked );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\VSplitter.cpp ===
// VSplitter.cpp : implementation file
//

#include "stdafx.h"
#include "VSplitter.h"
#include "resource.h"
#include "XboxAddinDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//*****************************************************************************
//***** CVSplitter
//*****************************************************************************

BEGIN_MESSAGE_MAP(CVSplitter, CWnd)
	//{{AFX_MSG_MAP(CVSplitter)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_SETCURSOR()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_WM_CAPTURECHANGED()
END_MESSAGE_MAP()

//*****************************************************************************
CVSplitter::CVSplitter() :
	m_rcTrack(0, 0, 0, 0),
	m_fTracking(FALSE),
	m_fVisible(FALSE),
	m_pParent(NULL),
	m_nWidth(0),
	m_rcFirstPane(0, 0, 0, 0),
	m_rcSecondPane(0, 0, 0, 0),
	m_pFirstPane(NULL),
	m_pSecondPane(NULL)
{
}

//*****************************************************************************
CVSplitter::~CVSplitter()
{
}

//*****************************************************************************
BOOL CVSplitter::Create( CWnd *pParent, RECT *rect )
{
	// Save our parent
	m_pParent = pParent;

	if( rect )
	{
		RECT tempRect;
		m_pParent->GetWindowRect( &tempRect );
				
		m_rcTrack = *rect;
		m_rcSecondPane = m_rcFirstPane = m_rcTrack;

		m_rcFirstPane.left = 0;
		m_rcFirstPane.right = m_rcTrack.left-1;
		m_rcSecondPane.left = m_rcTrack.right+1;
		m_rcSecondPane.right = tempRect.right;

		m_rcFirstPane.top = 0;
		m_rcSecondPane.top = 0;

		m_nWidth = rect->right-rect->left;
		ASSERT( m_nWidth > 0 );
	}

	// Create our splitter class
	WNDCLASS wc;

	ZeroMemory( &wc, sizeof(wc) );
	wc.lpszClassName = "DittoVSplitterClass";
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = ::DefWindowProc;
	wc.hInstance     = AfxGetInstanceHandle();
	wc.hCursor       = LoadCursor( NULL, IDC_SIZEWE );
	wc.hbrBackground = (HBRUSH)( COLOR_BTNFACE + 1 );

	// Register our splitter class
	AfxRegisterClass( &wc );

	// Create our splitter
	return CWnd::Create( wc.lpszClassName, "", WS_VISIBLE | WS_CHILD, 
						 m_rcTrack, pParent, IDC_VSPLITTER );
}

//*****************************************************************************
void CVSplitter::OnPaint()
{
	RECT rc;

	// Make sure Splitter bar and panes are updated when
	// the parent resizes.
	m_pParent->GetClientRect( &rc );
	m_rcTrack.bottom = rc.bottom;

	MoveWindow( &m_rcTrack, FALSE );

	// Resize First Pane
	m_rcFirstPane.right = m_rcTrack.left;
	m_rcFirstPane.bottom = m_rcTrack.bottom;

	// Resize Second Pane
	m_rcSecondPane.left = m_rcTrack.right;
	m_rcSecondPane.right = rc.right;
	m_rcSecondPane.bottom = m_rcTrack.bottom;

	// Resize First Pane
	m_pFirstPane->MoveWindow( &m_rcFirstPane );

	// Resize Second Pane Window
	m_pSecondPane->MoveWindow( &m_rcSecondPane );

	// Paint Scroll Bar
	CPaintDC dc( this );
	GetClientRect( &rc );
	dc.Draw3dRect( &rc, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW));
}

//*****************************************************************************
void CVSplitter::OnLButtonDown( UINT /*nFlags*/, CPoint /*point*/ )
{
	ASSERT( m_pParent != NULL );

	// Capture the mouse
	SetCapture();

	// Set our initial splitter position in our main frame's client coordinates
	GetWindowRect( &m_rcTrack );
	m_pParent->ScreenToClient( &m_rcTrack );
	//m_rcTrack.top++; m_rcTrack.bottom--; m_rcTrack.right--;

	// Set our tracking flag
	m_fTracking = TRUE;

	// Draw our initial tracker
	InvertTracker();
}

//*****************************************************************************
void CVSplitter::OnLButtonUp(UINT /*nFlags*/, CPoint /*point*/)
{
	ASSERT( m_pParent != NULL );
	BOOL fWasTracking = m_fTracking;

	OnEndCapture();
	
	if(fWasTracking)
	{
		RECT rect;
		m_pParent->GetClientRect( &rect );
		static_cast<CXboxAddinDlg*>(m_pParent)->EndTrack( m_rcTrack.right );

		MoveWindow(	&m_rcTrack );
		OnPaint();

		m_pFirstPane->InvalidateRect( NULL );
		m_pSecondPane->InvalidateRect( NULL );
	}
}

//*****************************************************************************
void CVSplitter::OnMouseMove( UINT /*nFlags*/, CPoint point )
{
	if( m_fTracking )
	{
		// Convert our point to client coordinates of our frame
		ClientToScreen( &point );
		m_pParent->ScreenToClient( &point );

		// Get the client are of our frame
		CRect rcClient;
		m_pParent->GetClientRect( &rcClient );

		// Force the point to be in our client area
		if( (point.x + 34) > rcClient.right )
		{
			point.x = rcClient.right - 34;
		}
		if( (point.x - 31) < rcClient.left )
		{
			point.x = rcClient.left + 31;
		}

		// If the point has changed since the last mouse move, then update change
		if( m_rcTrack.left != (point.x - 1) )
		{
			InvertTracker();
//			if(point.x < CPersonalityCtrl::MinSplitterXPos)
//			{
//				point.x = CPersonalityCtrl::MinSplitterXPos;
//			}
			m_rcTrack.left  = point.x - (m_nWidth>>1);
			m_rcTrack.right = point.x + (m_nWidth>>1);
			m_rcTrack.bottom = rcClient.bottom;
			InvertTracker();
		}
	}
}

//*****************************************************************************
void CVSplitter::OnCancelMode()
{
	OnEndCapture();
	CWnd::OnCancelMode();
}

//*****************************************************************************
void CVSplitter::OnCaptureChanged( CWnd *pWnd )
{
	OnEndCapture();
	CWnd::OnCaptureChanged( pWnd );
}

//*****************************************************************************
void CVSplitter::OnEndCapture()
{
	if( m_fVisible )
	{
		InvertTracker();
	}

	if( m_fTracking )
	{
		ReleaseCapture();
		m_fTracking = FALSE;
	}
}

//*****************************************************************************
void CVSplitter::InvertTracker()
{
	ASSERT( m_pParent );

	// Get the DC of our main frame
	CDC *pDC = m_pParent->GetDC();

	ASSERT( pDC );

	CRgn rgnNew, rgnOrig;
	rgnOrig.CreateRectRgn( 0, 0, 1, 1 );
	RECT rect;
	m_pParent->GetClientRect( &rect );
	rgnNew.CreateRectRgn( rect.left, rect.top, rect.right, rect.bottom );
	::GetClipRgn( pDC->GetSafeHdc(), rgnOrig );
	pDC->SelectClipRgn( &rgnNew, RGN_COPY );

	pDC->GetClipBox( &rect );

	// Create our inverted brush pattern (looks just like frame window sizing)
	CBrush *pBrush = CDC::GetHalftoneBrush();

	// Select the brush into our DC  
	HBRUSH hBrushStock = NULL;
	if( pBrush != NULL )
	{
		hBrushStock = (HBRUSH)SelectObject( pDC->m_hDC, pBrush->m_hObject );
	}

	// Draw our tracking line
	pDC->PatBlt( m_rcTrack.left, m_rcTrack.top, m_rcTrack.Width(), m_rcTrack.Height(), PATINVERT );

	// Free our brush and DC
	if (hBrushStock != NULL)
	{
		SelectObject( pDC->m_hDC, hBrushStock );
	}
	pDC->SelectClipRgn( &rgnOrig );
	ReleaseDC( pDC );

	// Toggle visible flag
	m_fVisible = !m_fVisible;

	rgnNew.DeleteObject();
	rgnOrig.DeleteObject();
}

BOOL CVSplitter::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	return (pWnd == this)?CWnd::OnSetCursor(pWnd, nHitTest, message):FALSE;
}

RECT CVSplitter::GetFirstPaneRect()
{	
	return m_rcFirstPane;
}

RECT CVSplitter::GetSecondPaneRect()
{
	return m_rcSecondPane;
}

void CVSplitter::SetFirstPane( CWnd *pPane )
{
	m_pFirstPane = pPane;
}

void CVSplitter::SetSecondPane( CWnd *pPane )
{
	m_pSecondPane = pPane;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\TargetXboxDlg.h ===
#if !defined(AFX_TARGETXBOXDLG_H__65DE46FD_90D2_4BF8_B7C8_70E989AE1A7C__INCLUDED_)
#define AFX_TARGETXBOXDLG_H__65DE46FD_90D2_4BF8_B7C8_70E989AE1A7C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TargetXboxDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTargetXboxDlg dialog

class CTargetXboxDlg : public CDialog
{
// Construction
public:
	CTargetXboxDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTargetXboxDlg)
	enum { IDD = IDD_TARGET_XBOX };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTargetXboxDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTargetXboxDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TARGETXBOXDLG_H__65DE46FD_90D2_4BF8_B7C8_70E989AE1A7C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxAddin.h ===
// XboxAddin.h : main header file for the XBOXADDIN application
//

#if !defined(AFX_XBOXADDIN_H__9B6CC530_E352_4D98_9CBA_CAA4A82C67B7__INCLUDED_)
#define AFX_XBOXADDIN_H__9B6CC530_E352_4D98_9CBA_CAA4A82C67B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include <xboxdbg.h>


#define RELEASE(x) if( (x) ) {(x)->Release(); (x) = 0;};
#define CMD_PREFIX      "XAUD"

class CXboxAddinComponent;

BOOL GetRegString( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPTSTR lpszString, LPDWORD lpdwSize );
BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPCTSTR lpszString );
BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite );
BOOL GetRegDWORD( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPDWORD lpDWORD );

int XboxAddinMessageBox( CWnd *pWnd, LPCTSTR lpszText, UINT nType, LPCTSTR lpszCaption = NULL ); 

typedef enum
{
	NOTIFICATION_UNKNOWN,
    NOTIFICATION_SEGMENT,
    NOTIFICATION_LOAD_RESULT,
    NOTIFICATION_UNLOAD_RESULT,
    NOTIFICATION_PLAY_RESULT,
    NOTIFICATION_CLEARCACHE_RESULT,
	NOTIFICATION_PANIC_RESULT,
	NOTIFICATION_CREATE_RESULT,
	NOTIFICATION_SETDEFAULT_RESULT,
	NOTIFICATION_RELEASE_RESULT,
} NOTIFICATION_TYPE;

typedef struct
{
	NOTIFICATION_TYPE notificationType;
	DWORD			  dwSegmentID;
	DWORD			  dwData1;
} Notification_Struct;

/////////////////////////////////////////////////////////////////////////////
// GetUserRegString - Gets a string from the user's registry key

inline BOOL GetUserRegString( LPCTSTR lpValueName, LPTSTR lpszString, LPDWORD lpdwSize )
{
	return GetRegString( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\XboxAddin\\"),
		lpValueName, lpszString, lpdwSize );
}

/////////////////////////////////////////////////////////////////////////////
// SetUserRegString - Sets a string in the new PortConfig registry key

inline BOOL SetUserRegString( LPCTSTR lpValueName, LPCTSTR lpszString )
{
	return SetRegString( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\XboxAddin\\"),
		lpValueName, lpszString );
}

/////////////////////////////////////////////////////////////////////////////
// GetUserRegDWORD - Gets a string from the user's registry key

inline BOOL GetUserRegDWORD( LPCTSTR lpValueName, LPDWORD lpdwValue )
{
	return GetRegDWORD( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\XboxAddin\\"),
		lpValueName, lpdwValue );
}

/////////////////////////////////////////////////////////////////////////////
// SetUserRegDWORD - Sets a string in the new PortConfig registry key

inline BOOL SetUserRegDWORD( LPCTSTR lpValueName, LPDWORD lpdwValue )
{
	return SetRegDWORD( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\XboxAddin\\"),
		lpValueName, lpdwValue, TRUE );
}

/////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp:
// See XboxAddin.cpp for the implementation of this class
//

class CXboxAddinApp : public COleControlModule
{
public:
	CXboxAddinApp();

public:
	BOOL InitInstance();
	int ExitInstance();
	void ConnectToXbox();
	void DisconnectFromXbox();
    void UpdateTargetDirectory();
    void HandleNotification( NOTIFICATION_TYPE notificationType, TCHAR *astrTokens[10], int nParams );
	Notification_Struct *GetNotification( NOTIFICATION_TYPE notificationType );
	void WaitForNotification( NOTIFICATION_TYPE notificationType, Notification_Struct **ppNotification_Struct = NULL );

public:
	CXboxAddinComponent*			m_pXboxAddinComponent;
	CString 						m_strXboxDestination;
	CString							m_strXboxName;

	bool							m_fConnected;	// Connected to Xbox?
	bool							m_fECPConnected; // Connected to ECP in application?
	bool							m_fDebugMonitor; // Display debug output?

	PDMN_SESSION					m_pdmnSession; 	// Debug Monitor Session
	PDM_CONNECTION					m_pdmConnection;	// Debug Monitor Connection

	// Notification list
	CRITICAL_SECTION				m_csNotificationList;
	CTypedPtrList< CPtrList, Notification_Struct *> m_lstNotifications;
};

extern CXboxAddinApp theApp;


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XBOXADDIN_H__9B6CC530_E352_4D98_9CBA_CAA4A82C67B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\VSplitter.h ===
#ifndef __VSPLITTER_H__
#define __VSPLITTER_H__

// VSplitter.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CVSplitter class

#define DEFAULTSPLITTERWIDTH (6)
#define MINSPLITTERXPOS (30)

class CVSplitter : public CWnd
{
protected:
   CRect	m_rcFirstPane;
   CRect	m_rcSecondPane;

   CWnd		*m_pFirstPane;
   CWnd		*m_pSecondPane;

   CRect	m_rcTrack;
   BOOL		m_fTracking;
   BOOL		m_fVisible;
   CWnd		*m_pParent;
   int		m_nWidth;

public:
   CVSplitter();
   BOOL Create(CWnd *pParent, RECT *rect = NULL);
   RECT	GetFirstPaneRect();
   RECT	GetSecondPaneRect();
   void SetFirstPane( CWnd *pPane );
   void SetSecondPane( CWnd *pPane );
   void SetTracker(RECT& rect)
   {
	   m_rcTrack = rect;
   }

protected:
   void OnEndCapture();
   void InvertTracker();

   //{{AFX_VIRTUAL(CVSplitter)
   //}}AFX_VIRTUAL

public:
   virtual ~CVSplitter();

protected:
   //{{AFX_MSG(CVSplitter)
   afx_msg void OnPaint();
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnCancelMode();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
   afx_msg void OnCaptureChanged(CWnd *pWnd);
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __VSPLITTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxAddinComponent.cpp ===
// XboxAddinComponent.cpp : implementation file
//

#include "stdafx.h"

#include "XboxAddin.h"
#include "XboxAddinDlg.h"
#include <initguid.h>
#include "XboxAddinComponent.h"
#include <dmpprivate.h>
#include "Segment.h"
#include "Audiopath.h"
#include "OtherFile.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <dmusici.h>
#pragma warning ( pop )
#include <dmksctrl.h>
#include "XboxSynthMenu.h"


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent constructor/destructor 

CXboxAddinComponent::CXboxAddinComponent()
{
    m_dwRef = 0;
	m_pIFramework = NULL;
	m_pIConductor = NULL;
	m_pIDMPerformance = NULL;
	m_fMenuWasAdded = FALSE;
	m_fSynthMenuWasAdded = FALSE;
	m_pXboxAddinDlg = NULL;
	m_pXboxAddinDlgWP = NULL;
	m_pXboxSynthMenu = NULL;
}

CXboxAddinComponent::~CXboxAddinComponent()
{
	if( m_pXboxAddinDlgWP )
	{
		delete m_pXboxAddinDlgWP;
		m_pXboxAddinDlgWP = NULL;
	}

	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent::ReleaseAll

void CXboxAddinComponent::ReleaseAll( void )
{
	RELEASE( m_pIDMPerformance );
	RELEASE( m_pIConductor );
	RELEASE( m_pIFramework );

	CleanUp();
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IUnknown implementation

HRESULT CXboxAddinComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdComponent *)this;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdMenu) )
    {
        *ppvObj = (IDMUSProdMenu *)this;
    }
	else
	{
	    *ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CXboxAddinComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CXboxAddinComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdComponent::Initialize

HRESULT CXboxAddinComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	CString strErrMsg;

	ASSERT( pIFramework != NULL );
	ASSERT( pbstrErrMsg != NULL );

	if( pbstrErrMsg == NULL )
	{
		return E_POINTER;
	}

	if( pIFramework == NULL )
	{
		strErrMsg.LoadString( IDS_ERR_INVALIDARG );
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_POINTER;
	}

	IDMUSProdComponent* pIComponent = NULL;
	IUnknown* punkPerformance = NULL;

	// Get IConductor and IDirectMusicPerformance interface pointers 
	if( !SUCCEEDED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  !SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdConductor8, (void**)&m_pIConductor ) )
	||  !SUCCEEDED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&punkPerformance ) )
	||	!SUCCEEDED ( punkPerformance->QueryInterface( IID_IDirectMusicPerformance8, (void**)&m_pIDMPerformance ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			pIComponent->Release();
		}
		if( punkPerformance )
		{
			punkPerformance->Release();
		}
		strErrMsg.LoadString( IDS_ERR_MISSING_CONDUCTOR );
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	RELEASE( pIComponent );
	RELEASE( punkPerformance );

	pIFramework->QueryInterface( IID_IDMUSProdFramework8, (void **)&m_pIFramework );

	theApp.m_pXboxAddinComponent = this;
//	theApp.m_pXboxAddinComponent->AddRef();	intentionally missing

	// Add "Message Window" item to Add-Ins menu 
	if( FAILED ( pIFramework->AddMenuItem( (IDMUSProdMenu *)this ) ) )
	{
		ReleaseAll();
		strErrMsg.LoadString( IDS_ERR_ADD_MENUITEM );
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	else
	{
		m_fMenuWasAdded = TRUE;
	}

	ASSERT( !m_pXboxSynthMenu );
	m_pXboxSynthMenu = new CXboxSynthMenu;
	if( m_pXboxSynthMenu )
	{
		if( SUCCEEDED( pIFramework->AddMenuItem( (IDMUSProdMenu *)m_pXboxSynthMenu ) ) )
		{
			m_fSynthMenuWasAdded = TRUE;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdComponent::CleanUp

HRESULT CXboxAddinComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Close "Experimenter Window"
	if( m_pXboxAddinDlg )
	{
		m_pXboxAddinDlg->DestroyWindow();
		delete m_pXboxAddinDlg;
		m_pXboxAddinDlg = NULL;
	}

	// Delete items from the lists
	while( !m_lstPrimarySegments.IsEmpty() )
	{
		delete m_lstPrimarySegments.RemoveHead();
	}
	while( !m_lstSecondarySegments.IsEmpty() )
	{
		delete m_lstSecondarySegments.RemoveHead();
	}
	while( !m_lstOtherFiles.IsEmpty() )
	{
		delete m_lstOtherFiles.RemoveHead();
	}
	while( !m_lstAudiopaths.IsEmpty() )
	{
		delete m_lstAudiopaths.RemoveHead();
	}


	// Remove "Experimenter Window" menu item
	if( m_fMenuWasAdded )
	{
		m_pIFramework->RemoveMenuItem( (IDMUSProdMenu *)this );
		m_fMenuWasAdded = FALSE;
	}

	if( m_fSynthMenuWasAdded )
	{
		m_pIFramework->RemoveMenuItem( (IDMUSProdMenu *)m_pXboxSynthMenu );
		m_fSynthMenuWasAdded = FALSE;
	}

	RELEASE(m_pXboxSynthMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdComponent::GetName

HRESULT CXboxAddinComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	if( strName.LoadString( IDS_XBOXADDIN_COMPONENT_NAME ) )
	{
	    *pbstrName = strName.AllocSysString();
		return S_OK;
	}
	
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent::IDMUSProdComponent::AllocReferenceNode

HRESULT CXboxAddinComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(guidRefNodeId);
	UNREFERENCED_PARAMETER(ppIRefNode);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdComponent::OnActivateApp

HRESULT CXboxAddinComponent::OnActivateApp( BOOL fActivate )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdMenu implementation

/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdMenu::GetMenuText

HRESULT CXboxAddinComponent::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	if( strName.LoadString( IDS_EXPERIMENTER_WINDOW_MENU_TEXT ) )
	{
	    *pbstrText = strName.AllocSysString();
		return S_OK;
	}
	
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdMenu::GetMenuHelpText

HRESULT CXboxAddinComponent::GetMenuHelpText( BSTR* pbstrHelpText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	if( strName.LoadString( IDS_EXPERIMENTER_WINDOW_MENU_HELP_TEXT ) )
	{
	    *pbstrHelpText = strName.AllocSysString();
		return S_OK;
	}
	
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdMenu::OnMenuInit

HRESULT CXboxAddinComponent::OnMenuInit( HMENU hMenu, UINT nMenuID )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::EnableMenuItem( hMenu, nMenuID, MF_ENABLED );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent IDMUSProdMenu::OnMenuSelect

HRESULT CXboxAddinComponent::OnMenuSelect()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pXboxAddinDlg )
	{
		// Window is already open
		if( m_pXboxAddinDlg->IsIconic() ) 
		{
			m_pXboxAddinDlg->ShowWindow( SW_RESTORE );     // If iconic, restore the main window
		}
		m_pXboxAddinDlg->SetForegroundWindow();
		return S_OK;
	}

	// Create "Experimenter Window"
	m_pXboxAddinDlg = new CXboxAddinDlg;
	if( m_pXboxAddinDlg == NULL )
	{
		return E_OUTOFMEMORY;
	}

	CString strWindowTitle;
	strWindowTitle.LoadString( IDS_EXPERIMENTER_WINDOW_MENU_TEXT );
	if( m_pXboxAddinDlg->CreateEx( WS_EX_TOPMOST, AfxRegisterWndClass(0), strWindowTitle,
							   (WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN),
							   0, 0,
							   200, 400,
							   NULL	/*pParentWnd*/,
							   NULL,
							   NULL ) )
	{
		HICON hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_MAINFRAME) );
		if( hIcon )
		{
			m_pXboxAddinDlg->SetIcon( hIcon, TRUE );
		}
		if( m_pXboxAddinDlgWP )
		{
			m_pXboxAddinDlg->SetWindowPlacement( m_pXboxAddinDlgWP );
		}
		m_pXboxAddinDlg->OnInitDialog();
		return S_OK;
	}

	delete m_pXboxAddinDlg;
	m_pXboxAddinDlg = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinComponent additional functions

HRESULT CXboxAddinComponent::EnsureNodeIsCopied( IDMUSProdNode *pIDMUSProdNode )
{
	if( pIDMUSProdNode == NULL )
	{
		return E_POINTER;
	}

	if( m_pXboxAddinDlg->IsNodeDisplayed( pIDMUSProdNode ) )
	{
		return S_OK;
	}

	return m_pXboxAddinDlg->AddNodeToDisplay( pIDMUSProdNode );
}

HRESULT CXboxAddinComponent::DoXboxSynthState( bool fSet, BOOL *pbXboxEnabled, BOOL *pbPCEnabled )
{
    if( fSet && (!pbXboxEnabled || !pbPCEnabled) )
    {
        return E_POINTER;
    }

	BOOL bXboxEnabled, bPCEnabled;
	if( !pbXboxEnabled )
	{
		pbXboxEnabled = &bXboxEnabled;
	}
	if( !pbPCEnabled )
	{
		pbPCEnabled = &bPCEnabled;
	}

	IDirectMusicAudioPath *pIDirectMusicAudioPath = NULL;
	HRESULT hr = m_pIDMPerformance->GetDefaultAudioPath( &pIDirectMusicAudioPath );

	IKsControl *pIKsControl = NULL;
	if( SUCCEEDED(hr) )
	{
		hr = pIDirectMusicAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, CLSID_XboxSynth, 0, IID_IKsControl, (void **)&pIKsControl );
	}

	if( SUCCEEDED(hr) )
	{
		KSPROPERTY ksProperty;
		ksProperty.Set = GUID_Xbox_PROP_XboxSynth;
        ksProperty.Flags = fSet ? KSPROPERTY_TYPE_SET : KSPROPERTY_TYPE_GET;
		ksProperty.Id = 0;
		DWORD dwDataSize = 0;
		hr = pIKsControl->KsProperty( &ksProperty, sizeof(KSPROPERTY), pbXboxEnabled, sizeof(BOOL), &dwDataSize ); 
	}

	if( SUCCEEDED(hr) )
	{
		KSPROPERTY ksProperty;
		ksProperty.Set = GUID_Xbox_PROP_PCSynth;
		ksProperty.Flags = fSet ? KSPROPERTY_TYPE_SET : KSPROPERTY_TYPE_GET;
		ksProperty.Id = 0;
		DWORD dwDataSize = 0;
		hr = pIKsControl->KsProperty( &ksProperty, sizeof(KSPROPERTY), pbPCEnabled, sizeof(BOOL), &dwDataSize ); 
	}
	
	if( pIKsControl )
	{
		pIKsControl->Release();
	}

	if( pIDirectMusicAudioPath )
	{
		pIDirectMusicAudioPath->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxAddinComponent.h ===
#ifndef __XBOXADDINCOMPONENT_H__
#define __XBOXADDINCOMPONENT_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "conductor.h"

// XboxAddinComponent.h : header file
//

class CXboxAddinDlg;
class CSegment;
class COtherFile;
class CAudiopath;
class CXboxSynthMenu;
interface IDirectMusicPerformance8;

////////////////////////////////////////////////////////////////////////////////
class CXboxAddinComponent : public IDMUSProdComponent, public IDMUSProdMenu
{
public:
    CXboxAddinComponent();
	~CXboxAddinComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivate );

    // IDMUSProdMenu functions
    HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
    HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
    HRESULT STDMETHODCALLTYPE OnMenuInit( HMENU hMenu, UINT nMenuID );
    HRESULT STDMETHODCALLTYPE OnMenuSelect();

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists();
	BOOL RegisterClipboardFormats();
	void ReleaseAll();

public:
    HRESULT STDMETHODCALLTYPE GetXboxAddinImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetXboxAddinRefImageIndex( short* pnNbrFirstImage );
	BOOL StartMessageTextThread();
	BOOL EndMessageTextThread();
	HRESULT EnsureNodeIsCopied( IDMUSProdNode *pIDMUSProdNode );
	HRESULT DoXboxSynthState( bool fSet, BOOL *pbXboxEnabled, BOOL *pbPCEnabled );

public:
	IDMUSProdFramework8*		m_pIFramework;
	IDMUSProdConductor8*		m_pIConductor;
	IDirectMusicPerformance8*	m_pIDMPerformance;

	CXboxAddinDlg*				m_pXboxAddinDlg;	// Experimenter Window
	WINDOWPLACEMENT*			m_pXboxAddinDlgWP;	// Message Window placement
	CXboxSynthMenu*				m_pXboxSynthMenu;	// Xbox Synth menu item

	CTypedPtrList< CPtrList, CSegment *> m_lstPrimarySegments;
	CTypedPtrList< CPtrList, CSegment *> m_lstSecondarySegments;
	CTypedPtrList< CPtrList, COtherFile *> m_lstOtherFiles;
	CTypedPtrList< CPtrList, CAudiopath *> m_lstAudiopaths;

private:
    DWORD						m_dwRef;
	BOOL						m_fMenuWasAdded;
	BOOL						m_fSynthMenuWasAdded;
};

#endif // __XBOXADDINCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\cclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

//  clock.h
#ifndef __CCLOCK_H__
#define __CCLOCK_H__

class CDSLink;

class CClock : public IReferenceClock
{
public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
        /* [out] */ REFERENCE_TIME __RPC_FAR *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
        /* [in] */ DWORD dwAdviseCookie);
                CClock();
    void        Init(CDSLink *pDSLink);
    void        Stop();         // Call store current time as offset.
    void        Start();        // Call to reinstate running.
private:
    BOOL        m_fStopped;     // Currently changing configuration.
    CDSLink *	m_pDSLink;      // Pointer to parent DSLink structure.
};

#endif //__CCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxAddin.cpp ===
// XboxAddin.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "XboxAddinDlg.h"
#include "XboxAddinComponent.h"
#include "TargetDirectoryDlg.h"
#include "TargetXboxDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256

// command prefix
static const TCHAR g_szCmd[] = _T(CMD_PREFIX);
static const TCHAR g_szNotificationDelimiters[] = _T(" \n");

// command structure
struct NotificationParseStruct {
	const TCHAR *pszString;
	NOTIFICATION_TYPE notificationType;
};

NotificationParseStruct g_csNotifications[] = 
{	{_T("Segment"), NOTIFICATION_SEGMENT },
	{_T("LoadResult"), NOTIFICATION_LOAD_RESULT },
	{_T("UnloadResult"), NOTIFICATION_UNLOAD_RESULT },
	{_T("PlayResult"), NOTIFICATION_PLAY_RESULT },
	{_T("ClearCacheResult"), NOTIFICATION_CLEARCACHE_RESULT },
	{_T("PanicResult"), NOTIFICATION_PANIC_RESULT },
	{_T("CreateResult"), NOTIFICATION_CREATE_RESULT },
	{_T("SetDefaultResult"), NOTIFICATION_SETDEFAULT_RESULT },
	{_T("ReleaseResult"), NOTIFICATION_RELEASE_RESULT },
};


//-----------------------------------------------------------------------------
// Name: ExtNotifyFunc
// Desc: Notifier function registered via DmRegisterNotificationProcessor 
//          below.  This is called to return output from the remote ECP
//-----------------------------------------------------------------------------
DWORD __stdcall ExtNotifyFunc(LPCSTR szNotification)
{
    // skip over prefix
    TCHAR szCmd[MAX_PATH];
    _tcsncpy( szCmd, szNotification + _tcslen(g_szCmd) + 1, MAX_PATH );

    // Parse up to ten tokens
    TCHAR *astrTokens[10];

    // Get the command from szCmd
    TCHAR *strToken = _tcstok( szCmd, g_szNotificationDelimiters );
	int nTokens=0;
    while( strToken && nTokens < 10 )
    {
        astrTokens[nTokens] = strToken;

		nTokens++;

        strToken = _tcstok( NULL, g_szNotificationDelimiters );
    }

	NOTIFICATION_TYPE notificationType = NOTIFICATION_UNKNOWN;

	for( int i=0; i<sizeof(g_csNotifications) / sizeof(g_csNotifications[0]); i++ )
	{
		if(0 == _tcsncmp(g_csNotifications[i].pszString, astrTokens[0], _tcslen(g_csNotifications[i].pszString)))
		{
			notificationType = g_csNotifications[i].notificationType;
			break;
		}
	}

    if( notificationType == NOTIFICATION_UNKNOWN )
    {
        TRACE("Unknown Xbox notification: %s\n", szNotification);
    }
	else
	{
		// Handle the notification
		theApp.HandleNotification( notificationType, astrTokens, nTokens );
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: HandleDebugString
// Desc: Prints debug output to the output window, if desired
//-----------------------------------------------------------------------------
DWORD __stdcall HandleDebugString( ULONG dwNotification, DWORD dwParam )
{
    if( (DM_DEBUGSTR == dwNotification)
    &&  theApp.m_fDebugMonitor )
    {
        PDMN_DEBUGSTR p = (PDMN_DEBUGSTR)dwParam;

		// Copy the string in order to NULL-terminate it
		char *strText = new char[p->Length+1];
		if( strText )
		{
			memcpy( strText, p->String, sizeof(char) * p->Length );

			// NULL-terminate it
			strText[ p->Length ] = 0;

			// Output the debug string
	        TRACE("Xbox Dbg: %s\n", p->String );

			// Delete the temporary array
			delete []strText;
		}
    }
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CXboxAddinApp object

CXboxAddinApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp


/////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp construction

CXboxAddinApp::CXboxAddinApp()
{
	// Place all significant initialization in InitInstance
	m_pXboxAddinComponent = NULL;
	m_fConnected = false;
	m_fECPConnected = false;
	m_fDebugMonitor = true;

	m_pdmnSession = NULL;
	m_pdmConnection = NULL;

	InitializeCriticalSection( &m_csNotificationList );
}

/////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp initialization

BOOL CXboxAddinApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();
	}

	TCHAR tcstrXboxPath[MAX_PATH];
	ZeroMemory( tcstrXboxPath, sizeof(TCHAR) * MAX_PATH );
	DWORD dwCbData = sizeof(TCHAR) * MAX_PATH;
	if( GetUserRegString( _T("XboxPath"), tcstrXboxPath, &dwCbData ) )
	{
		// Copy the path to m_strXboxDestination
		m_strXboxDestination = tcstrXboxPath;
	}

	if( m_strXboxDestination.IsEmpty() )
	{
		// Use a default path
		m_strXboxDestination = _T("T:\\Temp");
	}
	else
	{
		// Ensure the path starts with T:\ 
		if( m_strXboxDestination.Left(3).CompareNoCase( _T("T:\\") ) != 0 )
		{
			// Strip off everything before the first \ and prepend T:
			int nBackSlashIndex = m_strXboxDestination.Find('\\');
			if( nBackSlashIndex!= -1 )
			{
				// Found a backslash, just prepend T:
				m_strXboxDestination = _T("T:") + m_strXboxDestination.Right(m_strXboxDestination.GetLength() - nBackSlashIndex );
			}
			else
			{
				// No backslash found, prepend T:\ 
				m_strXboxDestination = _T("T:\\") + m_strXboxDestination;
			}
		}
	}

	// Update the string in the registry
	SetUserRegString( _T("XboxPath"), m_strXboxDestination );

	ZeroMemory( tcstrXboxPath, sizeof(TCHAR) * MAX_PATH );
	dwCbData = sizeof(TCHAR) * MAX_PATH;
	if( GetUserRegString( _T("XboxName"), tcstrXboxPath, &dwCbData ) )
	{
		// Copy the Xbox name to m_strXboxName
		m_strXboxName = tcstrXboxPath;
	}

	if( m_strXboxName.IsEmpty() )
	{
		// Get the default destination
		char cstrXboxName[MAX_PATH];
		ZeroMemory( tcstrXboxPath, sizeof(char) * MAX_PATH );
		dwCbData = sizeof(char) * MAX_PATH;
		if( SUCCEEDED( DmGetXboxName( cstrXboxName, &dwCbData ) ) )
		{
			m_strXboxName = cstrXboxName;
		}
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp::ExitInstance - DLL termination

int CXboxAddinApp::ExitInstance()
{
	DisconnectFromXbox();

	DeleteCriticalSection( &m_csNotificationList );

	while( !m_lstNotifications.IsEmpty() )
	{
		delete m_lstNotifications.RemoveHead();
	}

	return COleControlModule::ExitInstance();
}


////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp::ConnectToXbox

void CXboxAddinApp::ConnectToXbox()
{
	HRESULT hr = S_OK;
	CString strErrorString;

	// Set the xbox machine name to connect to, if specified
	if( m_strXboxName.IsEmpty() )
	{
		// Must set Xbox machine name to connect to
		CTargetXboxDlg targetXboxDlg;
		if( IDOK != targetXboxDlg.DoModal() )
		{
			// If use canceled, abort connection
			hr = E_FAIL;
		}
	}

	// Try and set the Xbox name
	if( SUCCEEDED( hr ) )
	{
		hr = DmSetXboxNameNoRegister( m_strXboxName );

		if( FAILED( hr ) )
		{
			strErrorString.FormatMessage( IDS_ERR_CANT_SET_NAME, m_strXboxName );
		}
	}

	// Open our connection
	if( SUCCEEDED( hr ) )
	{
		hr = DmOpenConnection(&m_pdmConnection);
		if( FAILED( hr ) )
		{
			strErrorString.FormatMessage( IDS_ERR_CANT_CONNECT, m_strXboxName );
		}
	}

	if( SUCCEEDED( hr ) )
	{
		m_fConnected = true;

		// Make sure we'll be able to receive notifications
		hr = DmOpenNotificationSession( DM_PERSISTENT, &m_pdmnSession );
		if( FAILED( hr ) )
		{
			strErrorString.FormatMessage( IDS_ERR_CANT_CONNECT, m_strXboxName );
		}
	}

	if( SUCCEEDED( hr ) )
	{
		hr = DmNotify(m_pdmnSession, DM_DEBUGSTR, HandleDebugString);
		if( FAILED( hr ) )
		{
			strErrorString.FormatMessage( IDS_ERR_CANT_CONNECT, m_strXboxName );
		}
	}

	if( SUCCEEDED( hr ) )
	{
		hr = DmRegisterNotificationProcessor(m_pdmnSession, g_szCmd, ExtNotifyFunc);
		if( FAILED( hr ) )
		{
			strErrorString.FormatMessage( IDS_ERR_CANT_CONNECT, m_strXboxName );
		}
	}

	// send initial connect command to ECP so it knows we're here
	if( SUCCEEDED( hr ) )
	{
		DWORD cchResp = MAX_PATH;
		char szResp[MAX_PATH];

		hr = DmSendCommand(m_pdmConnection, TEXT(CMD_PREFIX "!__connect__"), szResp, &cchResp);

		if(FAILED(hr))
		{
			strErrorString.FormatMessage( IDS_ERR_CANT_CONNECT_DMCONSOLE, m_strXboxName );
		}
		/*
		else if( strcmp(szResp, "200- Version 0.1 Connected.") )
		{
			// Wrong version
			hr = E_FAIL;
			strErrorString.FormatMessage( IDS_ERR_AUDCONSOLE_VERSION, m_strXboxName );
		}
		*/
		else
		{
			/*
			strErrorString.Format( _T("Connected with response:\n%s"), szResp );
			XboxAddinMessageBox( NULL, strErrorString, MB_ICONINFORMATION | MB_OK );
			strErrorString.Empty();
			*/

			// Initialize the AudConsole app
			DmSendCommand(m_pdmConnection, TEXT(CMD_PREFIX "!initialize"), szResp, &cchResp);

			m_fECPConnected = true;

			// Verify destination directory
			bool fContinue = true;
			DM_FILE_ATTRIBUTES dmFileAttributes;
			HRESULT hr = DmGetFileAttributes( theApp.m_strXboxDestination, &dmFileAttributes );
			if( FAILED(hr) )
			{
				// Directory does not exist
				CString strXboxDirectory = CString(_T("X")) + theApp.m_strXboxDestination;
				CString strMessage;
				strMessage.FormatMessage( IDS_ERR_PATH_NOEXIST, strXboxDirectory );
				if( IDOK == XboxAddinMessageBox( NULL, strMessage, MB_ICONERROR | MB_OKCANCEL ) )
				{
					if( FAILED( DmMkdir( theApp.m_strXboxDestination ) ) )
					{
						fContinue = false;
					}
				}
				else
				{
					fContinue = false;
				}
			}
			else if( !(dmFileAttributes.Attributes & FILE_ATTRIBUTE_DIRECTORY) )
			{
				// File with same name exists
				CString strXboxDirectory = CString(_T("X")) + theApp.m_strXboxDestination;
				CString strMessage;
				strMessage.FormatMessage( IDS_ERR_PATH_FILEEXIST, strXboxDirectory );
				XboxAddinMessageBox( NULL, strMessage, MB_ICONERROR | MB_OK );
				fContinue = false;
			}

			// If verification failed, prompt user to set the destination directory
			if( !fContinue )
			{
				CTargetDirectoryDlg targetDirectoryDlg;
				int nResult = targetDirectoryDlg.DoModal();
				if( nResult != IDC_SYNCHRONIZE
				&&	nResult != IDOK )
				{
					hr = E_FAIL;
				}
			}
		}
	}

	// If successfull, set our search directory
	if( SUCCEEDED( hr ) )
	{
		UpdateTargetDirectory();
	}

	if( FAILED( hr ) )
	{
		if( !strErrorString.IsEmpty() )
		{
			XboxAddinMessageBox( NULL, strErrorString, MB_ICONERROR | MB_OK );
		}

		// Disconnect
		DisconnectFromXbox();
	}
}


////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp::DisconnectFromXbox

void CXboxAddinApp::DisconnectFromXbox()
{
	if(m_fConnected)
	{
		//RtfPrintf(CLR_INVALID, "Closing connection\n");

		// Uninitialize the AudConsole app
		DWORD cchResp = MAX_PATH;
		char szResp[MAX_PATH];
		DmSendCommand(m_pdmConnection, TEXT(CMD_PREFIX "!uninitialize"), szResp, &cchResp);

		DmNotify(m_pdmnSession, DM_NONE, NULL);
		DmCloseNotificationSession( m_pdmnSession );
		DmCloseConnection(m_pdmConnection);
		m_fConnected = m_fECPConnected = false;
	}
	//return true;
}


////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp::UpdateTargetDirectory

void CXboxAddinApp::UpdateTargetDirectory()
{
	if(m_fConnected)
	{
		CString strRemoteCmd;
		char    szResp[MAX_PATH];
		DWORD   cchResp = MAX_PATH;
		HRESULT hr;

		// Clear the cache
		hr = DmSendCommand(theApp.m_pdmConnection, TEXT(CMD_PREFIX "!clearCache"), szResp, &cchResp);

		// Set the search directory
		strRemoteCmd.Format( TEXT(CMD_PREFIX "!searchDirectory \"%s\""), theApp.m_strXboxDestination );
		hr = DmSendCommand(theApp.m_pdmConnection, strRemoteCmd, szResp, &cchResp);
	}
}


////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp::HandleNotification

void CXboxAddinApp::HandleNotification( NOTIFICATION_TYPE notificationType, TCHAR *astrTokens[10], int nParams )
{
	if( nParams < 2 )
	{
		TRACE("Too few arguments to HandleNotification\n");
		return;
	}

	DWORD dwSegmentID = _ttoi( astrTokens[1] );

	DWORD dwData1 = 0;
	if( nParams > 2 )
	{
		dwData1 = _ttoi( astrTokens[2] );
	}

	if( m_pXboxAddinComponent
	&&	m_pXboxAddinComponent->m_pXboxAddinDlg )
	{
		Notification_Struct *pNotification_Struct = new Notification_Struct;
		if( pNotification_Struct )
		{
			pNotification_Struct->notificationType = notificationType;
			pNotification_Struct->dwSegmentID = dwSegmentID;
			pNotification_Struct->dwData1 = dwData1;

			EnterCriticalSection( &m_csNotificationList );
			m_lstNotifications.AddTail( pNotification_Struct );
			LeaveCriticalSection( &m_csNotificationList );

			// Signal the dialog if this is a segment notification
			if( notificationType == NOTIFICATION_SEGMENT )
			{
				::PostMessage( m_pXboxAddinComponent->m_pXboxAddinDlg->GetSafeHwnd(), WM_APP, 0, 0 );
			}
		}
	}
}


////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp::GetNotification

Notification_Struct *CXboxAddinApp::GetNotification( NOTIFICATION_TYPE notificationType )
{
	Notification_Struct *pNotification_Struct = NULL;

	// Find a segment notification
	EnterCriticalSection( &theApp.m_csNotificationList );
	POSITION pos = theApp.m_lstNotifications.GetHeadPosition();
	while( pos )
	{
		POSITION posHere = pos;
		Notification_Struct *pTempNotification = theApp.m_lstNotifications.GetNext( pos );
		if( pTempNotification->notificationType == notificationType )
		{
			theApp.m_lstNotifications.RemoveAt( posHere );
			pNotification_Struct = pTempNotification;
			break;
		}
	}
	LeaveCriticalSection( &theApp.m_csNotificationList );

	return pNotification_Struct;
}


////////////////////////////////////////////////////////////////////////////
// CXboxAddinApp::WaitForNotification

void CXboxAddinApp::WaitForNotification( NOTIFICATION_TYPE notificationType, Notification_Struct **ppNotification_Struct )
{
	// Wait for the command to be processed
	DWORD dwTimeOut = 50;
	while( true )
	{
		// Find a notification
		Notification_Struct *pNotification_Struct = GetNotification( notificationType );

		// If we found a notification
		if( pNotification_Struct )
		{
			// Return or delete it
			if( ppNotification_Struct )
			{
				*ppNotification_Struct = pNotification_Struct;
			}
			else
			{
				delete pNotification_Struct;
			}
			break;
		}

		// Make sure we time out after one second
		if( dwTimeOut == 0 )
		{
			break;
		}
		dwTimeOut--;

		// Wait
		Sleep(20);
	}
}


/////////////////////////////////////////////////////////////////////////////
// GetRegString - Gets a string from the system registry 

BOOL GetRegString( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPTSTR lpszString, LPDWORD lpdwSize )
{
	HKEY  hKeyOpen;
	LONG  lResult;
	BOOL  fSuccess = FALSE;
	DWORD dwType;

	lResult = ::RegOpenKeyEx( hKey, lpSubKey, 0, KEY_READ, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, 0, &dwType, (BYTE *)lpszString, lpdwSize );

		if( (dwType == REG_SZ) && (lResult == ERROR_SUCCESS) )
		{
			fSuccess = TRUE;
		}

		::RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// GetRegDWORD - Gets a DWORD from the system registry 

BOOL GetRegDWORD( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPDWORD lpDWORD )
{
	HKEY  hKeyOpen;
	LONG  lResult;
	BOOL  fSuccess = FALSE;
	DWORD dwType;

	lResult = ::RegOpenKeyEx( hKey, lpSubKey, 0, KEY_READ, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
        DWORD dwDataSize = sizeof(DWORD);
		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, 0, &dwType, (BYTE *)lpDWORD, &dwDataSize );

		if( (dwType == REG_DWORD) && (lResult == ERROR_SUCCESS) && (dwDataSize == sizeof(DWORD)) )
		{
			fSuccess = TRUE;
		}

		::RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||	(dwType != REG_DWORD)
		||	(fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds registry entries for DMUS Producer components

static BOOL RegisterComponents( void )
{
	LPOLESTR psz1;
	TCHAR	 szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szInProcServer32[SMALL_BUFFER];
	TCHAR	 szThreadingModel[SMALL_BUFFER];
	TCHAR	 szApartment[SMALL_BUFFER];
	TCHAR	 szOCXPath[MAX_BUFFER];
	TCHAR	 szOCXLongPath[MAX_BUFFER];
	TCHAR	 szGuid1[MID_BUFFER];
	CString  strName;
	TCHAR	 szComponentPath[MAX_BUFFER];
	TCHAR	 szSkip[SMALL_BUFFER];
	DWORD	 dwSkip = 0;
	
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );

// Register Xbox addin Component
	if( SUCCEEDED( StringFromIID(CLSID_XboxAddinComponent, &psz1) ) )
	{
		WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
		CoTaskMemFree( psz1 );
		strName.LoadString( IDS_XBOXADDIN_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||	!(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||	!(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes registry entries for DMUS Producer components

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR	 szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szGuid[MID_BUFFER];
	TCHAR	 szComponentPath[MAX_BUFFER];
	TCHAR	 szContainerPath[MAX_BUFFER];
	TCHAR	 szRefNode[SMALL_BUFFER];
	
	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	_tcscpy( szRefNode, _T("RefNode") );
	
// Unregister Xbox Addin Component
	if( SUCCEEDED( StringFromIID(CLSID_XboxAddinComponent, &psz) ) )
	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
	REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
	ULONG	m_dwRef;		 // interface reference count
public:
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
	{
		if (IsEqualIID(riid, IID_IUnknown) ||
			IsEqualIID(riid, IID_IClassFactory))
		{
			*ppv = (LPVOID) this;
			AddRef();
			return NOERROR;
		}
		else
		{
			*ppv = NULL;
			return E_NOINTERFACE;
		}
	}
	STDMETHODIMP_(ULONG) AddRef()
	{
		return ++m_dwRef;
	}
	STDMETHODIMP_(ULONG) Release()
	{
		if (--m_dwRef == 0L)
		{
			delete this;
			return 0;
		}
		else
			return m_dwRef;
	}

///// IClassFactory implementation
protected:
	CreateInstanceFunc *m_pfunc;	// function that creates an object instance
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
	{
		return (*m_pfunc)(punkOuter, riid, ppv);
	}
	STDMETHODIMP LockServer(BOOL fLock)
	{
		if( fLock )
		{
			AfxOleLockApp(); 
		}
		else
		{
			AfxOleUnlockApp(); 
		}

		return NOERROR;
	}

///// Construction
	CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
	HRESULT   hrReturn; \
	cls* pthis; \
	pthis = new cls; \
	if( pthis == NULL ) \
	{ \
		return E_OUTOFMEMORY; \
	} \
	hrReturn = pthis->QueryInterface( riid, ppv ); \
	if( FAILED( hrReturn ) ) \
	{ \
		delete pthis; \
		*ppv = NULL; \
	} \
	return hrReturn; \
}

CREATE_INSTANCE( CXboxAddinComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

	// this DLL can only create class factory objects that support
	// IUnknown and IClassFactory
	if( !IsEqualIID(riid, IID_IUnknown)
	&&	!IsEqualIID(riid, IID_IClassFactory) )
	{
		return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
	CreateInstanceFunc *pfunc;

	if( IsEqualCLSID(rclsid, CLSID_XboxAddinComponent) )
	{
		pfunc = CXboxAddinComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
		static_cast<IUnknown*>( *ppv )->AddRef();
	}
	else
	{
		return E_FAIL;
	}

	return NOERROR;
}

int XboxAddinMessageBox( CWnd *pWnd, LPCTSTR lpszText, UINT nType, LPCTSTR lpszCaption )
{
	UNREFERENCED_PARAMETER(pWnd);
	CString strCaption;
	if( lpszCaption)
	{
		strCaption = lpszCaption;
	}
	else
	{
		strCaption.LoadString( IDS_XBOXADDIN_COMPONENT_NAME );
	}

	return MessageBox( NULL, lpszText, strCaption, nType | MB_TASKMODAL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\clist.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      clist.cpp
//
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include "clist.h"
#endif

LONG CListItem::GetCount(void) const
{
    LONG l;
    const CListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

BOOL CListItem::IsMember(CListItem *pItem)

{
    CListItem *li = this;
    for (;li != NULL; li=li->m_pNext)
    {
        if (li == pItem) return (TRUE);
    }
    return (FALSE);
}

CListItem* CListItem::Cat(CListItem *pItem)
{
    CListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

CListItem* CListItem::Remove(CListItem *pItem)
{
    CListItem *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

CListItem* CListItem::GetPrev(CListItem *pItem) const
{
    const CListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (CListItem*)prev;
}

CListItem * CListItem::GetItem(LONG index)

{
	CListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
	return (scan);
}

void CList::InsertBefore(CListItem *pItem,CListItem *pInsert)

{
	CListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxSynthConfigDlg.cpp ===
// XboxSynthConfigDlg.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "XboxSynthConfigDlg.h"
#include "XboxAddinComponent.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <Xbox-dmusici.h>
#pragma warning ( pop )
#include <dmksctrl.h>
#include <dmpprivate.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CXboxSynthConfigDlg dialog


CXboxSynthConfigDlg::CXboxSynthConfigDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CXboxSynthConfigDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CXboxSynthConfigDlg)
	m_bPCSynth = FALSE;
	m_bXboxSynth = FALSE;
	//}}AFX_DATA_INIT
}


void CXboxSynthConfigDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CXboxSynthConfigDlg)
	DDX_Check(pDX, IDC_CHECK_PC_SYNTH, m_bPCSynth);
	DDX_Check(pDX, IDC_CHECK_XBOX_SYNTH, m_bXboxSynth);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CXboxSynthConfigDlg, CDialog)
	//{{AFX_MSG_MAP(CXboxSynthConfigDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXboxSynthConfigDlg message handlers

void CXboxSynthConfigDlg::OnOK() 
{
    if( !UpdateData(TRUE) )
    {
        return;
    }

    BOOL bOldXboxSynth, bOldPCSynth;

	if( SUCCEEDED( theApp.m_pXboxAddinComponent->DoXboxSynthState( false, &bOldXboxSynth, &bOldPCSynth ) ) )
	{
        CDialog dlgConnecting;
        dlgConnecting.Create( IDD_XBOX_CONNECTING, this );
        dlgConnecting.ShowWindow( SW_SHOW );

        HRESULT hr = theApp.m_pXboxAddinComponent->DoXboxSynthState( true, &m_bXboxSynth, &m_bPCSynth );
        dlgConnecting.DestroyWindow();
        if( FAILED(hr) )
        {
            CString strError;
            if( hr == XBDM_CANNOTCONNECT )
            {
                strError.FormatMessage( IDS_ERR_CANT_CONNECT, theApp.m_strXboxName );
            }
			else if( hr == XBDM_CANNOTACCESS )
			{
				strError.FormatMessage( IDS_ERR_XBSYNTH_AUDCONSOLE_VERSION, theApp.m_strXboxName );
			}
            else
            {
                strError.LoadString( IDS_ERR_SETXBOXSYNTH );
            }
			XboxAddinMessageBox( NULL, strError, MB_ICONERROR | MB_OK );

            theApp.m_pXboxAddinComponent->DoXboxSynthState( true, &bOldXboxSynth, &bOldPCSynth );
            m_bXboxSynth = bOldXboxSynth;
            m_bPCSynth = bOldPCSynth;
            return;
        }

        DWORD dwValue = m_bPCSynth;
        SetUserRegDWORD( TEXT("EnablePCSynth"), &dwValue );
        dwValue = m_bXboxSynth;
        SetUserRegDWORD( TEXT("EnableXboxSynth"), &dwValue );

		// If we just enabled the Xbox synth
		if( !bOldXboxSynth && m_bXboxSynth )
		{
			// Re-download everything
			IDMUSProdConductorPrivate *pIDMUSProdConductorPrivate;
			if( SUCCEEDED( theApp.m_pXboxAddinComponent->m_pIConductor->QueryInterface( IID_IDMUSProdConductorPrivate, (void**)&pIDMUSProdConductorPrivate ) ) )
			{
				pIDMUSProdConductorPrivate->PleaseRedownload();
				pIDMUSProdConductorPrivate->Release();
			}
		}
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxAddinDlg.h ===
// XboxAddinDlg.h : header file
//

#if !defined(AFX_XBOXADDINDLG_H__E04930FE_9CAB_489E_875F_CFCB21E9E933__INCLUDED_)
#define AFX_XBOXADDINDLG_H__E04930FE_9CAB_489E_875F_CFCB21E9E933__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vsplitter.h"
#include "XboxAddin.h"

class CFileItem;
class CLeftPaneDlg;
class CRightPaneDlg;
interface IDMUSProdNode;

/////////////////////////////////////////////////////////////////////////////
// CXboxAddinDlg dialog

class CXboxAddinDlg : public CDialog
{
// Construction
public:
	CXboxAddinDlg(CWnd* pParent = NULL);	// standard constructor
	~CXboxAddinDlg();

    void EndTrack( long lNewPos );
	bool IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode );
	HRESULT AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode );
	void HandleNotification( NOTIFICATION_TYPE notificationType, DWORD dwSegmentID, DWORD dwData1 );
	void CleanUpDisplay( void );
	bool IsFileInUse( CFileItem *pFileItem );
	virtual BOOL OnInitDialog();

// Dialog Data
	//{{AFX_DATA(CXboxAddinDlg)
	enum { IDD = IDD_XBOXADDIN_DIALOG };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CXboxAddinDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
public:
	CLeftPaneDlg		*m_pLeftPaneDlg;
    CRightPaneDlg       *m_pRightPaneDlg;

protected:
	HICON m_hIcon;
	CVSplitter			m_wndVSplitter;

    WORD                m_wSplitterPos;

    void UpdateListBoxPositions( void );
	void OnConnectionStateChanged( void );

	// Generated message map functions
	//{{AFX_MSG(CXboxAddinDlg)
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	virtual void OnOK();
	afx_msg void OnFileClose();
	afx_msg void OnSetTargetDirectory();
	afx_msg void OnConnect();
	afx_msg void OnDisconnect();
	afx_msg void OnSynchronizeAll();
	afx_msg void OnSynchronizeAuto();
	afx_msg void OnAppAbout();
	afx_msg void OnXboxPanic();
	afx_msg void OnSetXboxName();
	//}}AFX_MSG
	afx_msg void OnMenuSelect( UINT nItemID, UINT nFlags, HMENU hSysMenu );
	LRESULT OnApp( WPARAM wParam, LPARAM lParam );
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XBOXADDINDLG_H__E04930FE_9CAB_489E_875F_CFCB21E9E933__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxSynthConfigDlg.h ===
#if !defined(AFX_XBOXSYNTHCONFIGDLG_H__B389E33A_2E8F_42F7_99D3_74BC2D153FFF__INCLUDED_)
#define AFX_XBOXSYNTHCONFIGDLG_H__B389E33A_2E8F_42F7_99D3_74BC2D153FFF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// XboxSynthConfigDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CXboxSynthConfigDlg dialog

class CXboxSynthConfigDlg : public CDialog
{
// Construction
public:
	CXboxSynthConfigDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CXboxSynthConfigDlg)
	enum { IDD = IDD_XBOX_SYNTH_CONFIG };
	BOOL	m_bPCSynth;
	BOOL	m_bXboxSynth;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CXboxSynthConfigDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CXboxSynthConfigDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XBOXSYNTHCONFIGDLG_H__B389E33A_2E8F_42F7_99D3_74BC2D153FFF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxAddinDlg.cpp ===
// XboxAddinDlg.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "XboxAddinDlg.h"
#include "SecondaryDlg.h"
#include "PrimaryDlg.h"
#include "Audiopath.h"
#include "RightPaneDlg.h"
#include "LeftPaneDlg.h"
#include "XboxAddinComponent.h"
#include "TargetDirectoryDlg.h"
#include "TargetXboxDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
    BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXboxAddinDlg dialog

CXboxAddinDlg::CXboxAddinDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CXboxAddinDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CXboxAddinDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_wSplitterPos = 0;
	m_pLeftPaneDlg = NULL;
	m_pRightPaneDlg = NULL;
}

CXboxAddinDlg::~CXboxAddinDlg()
{
	if( m_pLeftPaneDlg )
	{
		delete m_pLeftPaneDlg;
		m_pLeftPaneDlg = NULL;
	}
	if( m_pRightPaneDlg )
	{
		delete m_pRightPaneDlg;
		m_pRightPaneDlg = NULL;
	}
}

void CXboxAddinDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CXboxAddinDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CXboxAddinDlg, CDialog)
	//{{AFX_MSG_MAP(CXboxAddinDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
	ON_COMMAND(ID_SET_TARGET_DIRECTORY, OnSetTargetDirectory)
	ON_COMMAND(ID_CONNECT, OnConnect)
	ON_COMMAND(ID_DISCONNECT, OnDisconnect)
	ON_COMMAND(ID_SYNCHRONIZE_ALL, OnSynchronizeAll)
	ON_COMMAND(ID_SYNCHRONIZE_AUTO, OnSynchronizeAuto)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_XBOX_PANIC, OnXboxPanic)
	ON_COMMAND(ID_SET_XBOX_NAME, OnSetXboxName)
	ON_WM_MENUSELECT()
	ON_MESSAGE(WM_APP, OnApp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXboxAddinDlg message handlers

BOOL CXboxAddinDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
    // Resize the panes
    UpdateListBoxPositions();

	// Disable all the dialogs, unless we're already connected
	OnConnectionStateChanged();

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CXboxAddinDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	switch( nID & 0xFFF0 )
	{
	case IDM_ABOUTBOX:
		OnAppAbout();
		break;
	case SC_CLOSE:
		DestroyWindow();
		break;
	default:
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CXboxAddinDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CXboxAddinDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

int CXboxAddinDlg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Create the Splitter and position it in the Editor
	// (temporary values added until coords are saved to design-time file)
	RECT rect;
	rect.left = lpCreateStruct->x;
    rect.right = rect.left + DEFAULTSPLITTERWIDTH;
    rect.top = lpCreateStruct->y;
	rect.bottom = lpCreateStruct->cy;

	m_wndVSplitter.Create( this, &rect );

	// Create the left pane dialog and position it in the First Splitter Pane
	m_pLeftPaneDlg = new CLeftPaneDlg;
	if( m_pLeftPaneDlg == NULL )
	{
		return -1;
	}

	// Point the left pane dialog back to us and at the AudioPath object
	m_pLeftPaneDlg->Create( IDD_LEFT_PANE, this );
	m_pLeftPaneDlg->ShowWindow( SW_SHOW );
	m_wndVSplitter.SetFirstPane( m_pLeftPaneDlg );

	// Create the other files dialog and position it in the Second Splitter Pane
	m_pRightPaneDlg = new CRightPaneDlg;
	if( m_pRightPaneDlg == NULL )
	{
		return -1;
	}

	// Point the other files dialog back to us and at the AudioPath object
	m_pRightPaneDlg->Create( IDD_RIGHT_PANE, this );
	m_pRightPaneDlg->ShowWindow( SW_SHOW );
	m_wndVSplitter.SetSecondPane( m_pRightPaneDlg );

	// Attach the menu 
	HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_XBOXADDIN_MENU) );
	::SetMenu( GetSafeHwnd(), hMenu );
	
	return 0;
}

void CXboxAddinDlg::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);

    UpdateListBoxPositions();
}

void CXboxAddinDlg::UpdateListBoxPositions( void )
{
    if( m_wndVSplitter.GetSafeHwnd() == NULL )
    {
        return;
    }

    RECT rectClient;
    GetClientRect( &rectClient );

    // get splitter position from audio path
	WORD pos = m_wSplitterPos;

	// calculate where splitter should be
	if(pos == 0)
	{
		// put it right in the middle
		pos = WORD(min( USHRT_MAX, (rectClient.right - DEFAULTSPLITTERWIDTH)/2 ));

		// save where it is
        m_wSplitterPos = pos;
	}

    // Update splitter position, if it's non-zero
	if( pos != 0 )
	{
		// splitter is right side of chord dialog and left side
		// of signpost dialog
		RECT rect = rectClient;
		rect.right = max( DEFAULTSPLITTERWIDTH, pos );
		rect.left = rect.right - DEFAULTSPLITTERWIDTH;
		m_wndVSplitter.SetTracker(rect);
		m_wndVSplitter.MoveWindow( &rect, TRUE );
		m_pLeftPaneDlg->MoveWindow(0, 0, rect.left, rectClient.bottom);
		m_pRightPaneDlg->MoveWindow(rect.right, 0, rectClient.right - rect.right, rectClient.bottom);
	}
}

void CXboxAddinDlg::EndTrack( long lNewPos )
{
    m_wSplitterPos = (WORD)lNewPos;
}

void CXboxAddinDlg::OnDestroy() 
{
	// Save window placement
	ASSERT( theApp.m_pXboxAddinComponent->m_pXboxAddinDlg != NULL );
	if( theApp.m_pXboxAddinComponent->m_pXboxAddinDlgWP == NULL )
	{
		theApp.m_pXboxAddinComponent->m_pXboxAddinDlgWP = new WINDOWPLACEMENT;
	}
	if( theApp.m_pXboxAddinComponent->m_pXboxAddinDlgWP )
	{
		theApp.m_pXboxAddinComponent->m_pXboxAddinDlgWP->length = sizeof(WINDOWPLACEMENT);
		if( GetWindowPlacement( theApp.m_pXboxAddinComponent->m_pXboxAddinDlgWP ) == 0 )
		{
			delete theApp.m_pXboxAddinComponent->m_pXboxAddinDlgWP;
			theApp.m_pXboxAddinComponent->m_pXboxAddinDlgWP = NULL;
		}
	}

	CDialog::OnDestroy();
}

void CXboxAddinDlg::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

void CXboxAddinDlg::PostNcDestroy() 
{
	// Free resources
	ASSERT( theApp.m_pXboxAddinComponent->m_pXboxAddinDlg != NULL );
	if( theApp.m_pXboxAddinComponent->m_pXboxAddinDlg )
	{
		delete theApp.m_pXboxAddinComponent->m_pXboxAddinDlg;
		theApp.m_pXboxAddinComponent->m_pXboxAddinDlg = NULL;
	}

	CDialog::PostNcDestroy();
}

void CXboxAddinDlg::OnFileClose() 
{
	DestroyWindow();
}

void CXboxAddinDlg::OnSetTargetDirectory() 
{
	CTargetDirectoryDlg targetDirectoryDlg;
	if( IDC_SYNCHRONIZE == targetDirectoryDlg.DoModal() )
	{
		OnSynchronizeAll();
	}
}

void CXboxAddinDlg::OnConnect() 
{
	theApp.ConnectToXbox();

	OnConnectionStateChanged();

	OnSynchronizeAll();
}

void CXboxAddinDlg::OnDisconnect() 
{
	theApp.DisconnectFromXbox();

	OnConnectionStateChanged();
}

void CXboxAddinDlg::OnSynchronizeAll() 
{
	// Display a wait cursor - this may take a while
	CWaitCursor waitCursor;

	// Stop everything
	OnXboxPanic();

	// Unload everything
	m_pLeftPaneDlg->UnloadAll();
	// Can't load non-segment files, so don't need to unload them
	//m_pRightPaneDlg->UnloadAll();

	// Delete everything
	m_pLeftPaneDlg->DeleteAll();
	m_pRightPaneDlg->DeleteAll();

	// Re-copy and download everything
	m_pLeftPaneDlg->ReCopyAll();
	// Don't specifically copy files in the right pane until scripts are enabled
	//m_pRightPaneDlg->ReCopyAll();
}

void CXboxAddinDlg::OnSynchronizeAuto() 
{
	// TODO: Add your command handler code here
}

void CXboxAddinDlg::OnMenuSelect( UINT nItemID, UINT nFlags, HMENU hSysMenu )
{
	if( (0xFFFF != nFlags) && (nFlags & MF_POPUP) )
	{
		HMENU hSubMenu = ::GetSubMenu( hSysMenu, nItemID );
		switch( nItemID )
		{
		case 0: // File menu
			break;
		case 1: // Synchronize menu
			::EnableMenuItem( hSubMenu, ID_SYNCHRONIZE_ALL, theApp.m_fConnected ? MF_BYCOMMAND | MF_ENABLED : MF_BYCOMMAND | MF_GRAYED );
			//::EnableMenuItem( hSubMenu, ID_SYNCHRONIZE_AUTO, theApp.m_fConnected ? MF_BYCOMMAND | MF_ENABLED : MF_BYCOMMAND | MF_GRAYED );
			break;
		case 2: // Xbox menu
			::EnableMenuItem( hSubMenu, ID_CONNECT, theApp.m_fConnected ? MF_BYCOMMAND | MF_GRAYED : MF_BYCOMMAND | MF_ENABLED );
			::EnableMenuItem( hSubMenu, ID_DISCONNECT, theApp.m_fConnected ? MF_BYCOMMAND | MF_ENABLED : MF_BYCOMMAND | MF_GRAYED );
			::EnableMenuItem( hSubMenu, ID_XBOX_PANIC, theApp.m_fConnected ? MF_BYCOMMAND | MF_ENABLED : MF_BYCOMMAND | MF_GRAYED );
			break;
		case 3: // Help menu
			break;
		default:
			ASSERT(FALSE);
			break;
		}
	}
}

void CXboxAddinDlg::OnAppAbout() 
{
	CAboutDlg dlgAbout;
	dlgAbout.DoModal();
}

void CXboxAddinDlg::OnConnectionStateChanged( void )
{
	m_pLeftPaneDlg->OnConnectionStateChanged();
	m_pRightPaneDlg->OnConnectionStateChanged();
}

bool CXboxAddinDlg::IsNodeDisplayed( const IDMUSProdNode *pIDMUSProdNode )
{
	return m_pLeftPaneDlg->IsNodeDisplayed( pIDMUSProdNode ) || m_pRightPaneDlg->IsNodeDisplayed( pIDMUSProdNode );
}

HRESULT CXboxAddinDlg::AddNodeToDisplay( IDMUSProdNode *pIDMUSProdNode )
{
	// Get Node's GUID
	GUID guidID;
	HRESULT hr = pIDMUSProdNode->GetNodeId( &guidID );

	if( SUCCEEDED(hr) )
	{
		if( GUID_SegmentNode == guidID )
		{
			return m_pLeftPaneDlg->AddNodeToDisplay( pIDMUSProdNode );
		}
		else
		{
			return m_pRightPaneDlg->AddNodeToDisplay( pIDMUSProdNode );
		}
	}
	return hr;
}

void CXboxAddinDlg::OnXboxPanic() 
{
    char    szResp[MAX_PATH];
    DWORD   cchResp = MAX_PATH;
	DmSendCommand(theApp.m_pdmConnection, TEXT(CMD_PREFIX "!panic"), szResp, &cchResp);

	// Wait for the panic command to process
	theApp.WaitForNotification(	NOTIFICATION_PANIC_RESULT );

	m_pLeftPaneDlg->OnPanic();
}

void CXboxAddinDlg::HandleNotification( NOTIFICATION_TYPE notificationType, DWORD dwSegmentID, DWORD dwData1 )
{
	m_pLeftPaneDlg->HandleNotification( notificationType, dwSegmentID, dwData1 );
	//m_pRightPaneDlg->HandleNotification( notificationType, dwSegmentID, dwData1 );
}

LRESULT CXboxAddinDlg::OnApp( WPARAM wParam, LPARAM lParam )
{
	if( wParam == 0 && lParam == 0 )
	{
		Notification_Struct *pNotification_Struct;
		
		do
		{
			// Find a segment notification
			pNotification_Struct = theApp.GetNotification( NOTIFICATION_SEGMENT );

			// If we found a segment notification
			if( pNotification_Struct )
			{
				HandleNotification( pNotification_Struct->notificationType, pNotification_Struct->dwSegmentID, pNotification_Struct->dwData1 );
				delete pNotification_Struct;
			}
		}
		while( pNotification_Struct );
	}

	return 0;
}

void CXboxAddinDlg::CleanUpDisplay( void )
{
	m_pRightPaneDlg->CleanUpDisplay();
}

bool CXboxAddinDlg::IsFileInUse( CFileItem *pFileItem )
{
	return m_pLeftPaneDlg->IsFileInUse( pFileItem ) || m_pRightPaneDlg->IsFileInUse( pFileItem );
}

void CXboxAddinDlg::OnSetXboxName() 
{
	CTargetXboxDlg targetXboxDlg;
	if( IDOK == targetXboxDlg.DoModal()
	&&	theApp.m_fConnected )
	{
		// Disconnect and reconnect
		theApp.DisconnectFromXbox();
		theApp.ConnectToXbox();
	}
}

BOOL CAboutDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achJazzExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[FILENAME_MAX];

	if( GetModuleFileName ( theApp.m_hInstance, achJazzExeName, FILENAME_MAX ) )
	{
		if( GetFileVersion( achJazzExeName, achFileVersion, FILENAME_MAX ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_XBOX_ADDIN_VERSION, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAboutDlg::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxSynthMenu.h ===
#ifndef __XBOXSYNTHMENU_H__
#define __XBOXSYNTHMENU_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "dmusprod.h"

// XboxSynthMenu.h : header file
//

////////////////////////////////////////////////////////////////////////////////
class CXboxSynthMenu : public IDMUSProdMenu
{
public:
	CXboxSynthMenu();
	~CXboxSynthMenu();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdMenu functions
    HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
    HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
    HRESULT STDMETHODCALLTYPE OnMenuInit( HMENU hMenu, UINT nMenuID );
    HRESULT STDMETHODCALLTYPE OnMenuSelect();

private:
    DWORD						m_dwRef;
};


#endif // __XBOXSYNTHMENU_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\common.h ===
// Copyright (c) 1998 Microsoft Corporation
#ifndef _COMMON_H_
#define _COMMON_H_


#if (DBG)
#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_VERBOSE
#endif
#endif

#include <winerror.h>


#include "portcls.h"
#include "ksdebug.h"
#include <dmusicks.h>       // Ks defines
#include <dmerror.h>        // Error codes
#include <dmdls.h>          // DLS definitions

#include "kernhelp.h"
#include "CSynth.h"
#include "synth.h"
#include "float.h"
#include "muldiv32.h"
#include "SysLink.h"

#endif  //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxAddin\XboxSynthMenu.cpp ===
// XboxAddinComponent.cpp : implementation file
//

#include "stdafx.h"
#include "XboxAddin.h"
#include "XboxAddinComponent.h"
#include "XboxSynthMenu.h"
#include "XboxSynthConfigDlg.h"
#pragma warning ( push )
#pragma warning ( disable : 4201 )
#include <dmusici.h>
#pragma warning ( pop )


/////////////////////////////////////////////////////////////////////////////
// CXboxSynthMenu constructor/destructor 

CXboxSynthMenu::CXboxSynthMenu()
{
    m_dwRef = 0;
	AddRef();
}

CXboxSynthMenu::~CXboxSynthMenu()
{
}


/////////////////////////////////////////////////////////////////////////////
// CXboxSynthMenu IUnknown implementation

HRESULT CXboxSynthMenu::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    if( ::IsEqualIID(riid, IID_IDMUSProdMenu)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdMenu *)this;
    }
	else
	{
	    *ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CXboxSynthMenu::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CXboxSynthMenu::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxSynthMenu IDMUSProdMenu implementation

/////////////////////////////////////////////////////////////////////////////
// CXboxSynthMenu IDMUSProdMenu::GetMenuText

HRESULT CXboxSynthMenu::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	if( strName.LoadString( IDS_XBOX_SYNTH_MENU_TEXT ) )
	{
	    *pbstrText = strName.AllocSysString();
		return S_OK;
	}
	
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxSynthMenu IDMUSProdMenu::GetMenuHelpText

HRESULT CXboxSynthMenu::GetMenuHelpText( BSTR* pbstrHelpText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	if( strName.LoadString( IDS_XBOX_SYNTH_MENU_HELP_TEXT ) )
	{
	    *pbstrHelpText = strName.AllocSysString();
		return S_OK;
	}
	
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxSynthMenu IDMUSProdMenu::OnMenuInit

HRESULT CXboxSynthMenu::OnMenuInit( HMENU hMenu, UINT nMenuID )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::EnableMenuItem( hMenu, nMenuID, MF_ENABLED );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CXboxSynthMenu IDMUSProdMenu::OnMenuSelect

HRESULT CXboxSynthMenu::OnMenuSelect()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CXboxSynthConfigDlg xboxSynthConfigDlg;
	if( SUCCEEDED( theApp.m_pXboxAddinComponent->DoXboxSynthState( false, &xboxSynthConfigDlg.m_bXboxSynth, &xboxSynthConfigDlg.m_bPCSynth ) ) )
	{
		xboxSynthConfigDlg.DoModal();
	}
	else
	{
		// Check if we even have an audiopath
		IDirectMusicAudioPath *pIDirectMusicAudioPath = NULL;
		theApp.m_pXboxAddinComponent->m_pIDMPerformance->GetDefaultAudioPath( &pIDirectMusicAudioPath );

		CString strErrorMsg;
		if( pIDirectMusicAudioPath )
		{
			pIDirectMusicAudioPath->Release();
			strErrorMsg.LoadString( IDS_ERR_NO_XBOX_SYNTH );
		}
		else
		{
			strErrorMsg.LoadString( IDS_ERR_NO_AUDIOPATH );
		}

		CString strWindowTitle;
		strWindowTitle.LoadString( IDS_XBOX_SYNTH_TITLE );
		XboxAddinMessageBox( NULL, strErrorMsg, MB_ICONERROR | MB_OK, strWindowTitle );
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\clib.c ===
/* Copyright (c) 1998 Microsoft Corporation */
#include <windows.h>
#include <stdio.h>

#ifdef _DEBUG
void __cdecl _assert ( void *expr, void *filename, unsigned lineno )
{
    DebugBreak();
}
#endif
#ifdef _DEBUG
#if 0 // These are intrinsics and cause an error in the NT build
int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
        {
        extern void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );
        }
#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

        return(ret);
}

void * __cdecl memset (
        void *dst,
        int val,
        size_t count
        )
{
        void *start = dst;

#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
        {
        extern void RtlFillMemory( void *, size_t count, char );

        RtlFillMemory( dst, count, (char)val );
        }
#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
        while (count--) {
                *(char *)dst = (char)val;
                dst = (char *)dst + 1;
        }
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

        return(start);
}
#endif
#endif
void __cdecl _purecall(
        void
        )
{
}

static long holdrand = 1L;

void __cdecl srand (
        unsigned int seed
        )
{
        holdrand = (long)seed;
}

int __cdecl rand (
        void
        )
{
        return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\clist.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      clist.h
//

#ifndef __CLIST_H__
#define __CLIST_H__

class CListItem
{
public:
    CListItem() { m_pNext=NULL; };
    CListItem *GetNext() const {return m_pNext;};
    void SetNext(CListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    BOOL IsMember(CListItem *pItem);
    CListItem* Cat(CListItem* pItem);
    CListItem* AddTail(CListItem* pItem) {pItem->SetNext(NULL); return Cat(pItem);};
    CListItem* Remove(CListItem* pItem);
    CListItem* GetPrev(CListItem *pItem) const;
    CListItem* GetItem(LONG index);

private:
    CListItem *m_pNext;
};

class CList
{
public:
    CList() {m_pHead=NULL;};
    CListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    CListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(CListItem *pItem,CListItem *pInsert);
    void Cat(CListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(CList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(CListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(CListItem *pItem)
    {
    	if (m_pHead == NULL)
    	{
    		AddHead(pItem);
    	}
    	else
    	{
    		m_pHead=m_pHead->AddTail(pItem);
    	}
    };
    void Remove(CListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    CListItem *GetPrev(CListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    CListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(CListItem *pItem) {return (m_pHead->IsMember(pItem));};
    CListItem *RemoveHead(void)
        {
            CListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
            if (li)
                li->SetNext(NULL);
            return li;
        }

protected:
    CListItem *m_pHead;
};

#endif // __CLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\csynth.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      CSynth.h
//

#ifndef __CSYNTH_H__
#define __CSYNTH_H__

#include "synth.h"

#define MAX_CHANNEL_GROUPS	1000
#define MAX_VOICES			1000

// Forward declarations
struct IDirectSoundSynthSink;

class CSynth : public CListItem
{
friend class CControlLogic;
public:	
					CSynth();
					~CSynth();
    CSynth *		GetNext() {return(CSynth *)CListItem::GetNext();};
    HRESULT			SetStereoMode(DWORD dwBufferFlags);
    HRESULT			SetSampleRate(DWORD dwSampleRate);
	HRESULT			Activate(DWORD dwSampleRate, DWORD dwBufferFlags);
	HRESULT			Deactivate();
	HRESULT			Download(LPHANDLE phDownload, void *pdwData, LPBOOL bpFree);
	HRESULT			Unload(HANDLE hDownload,HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),HANDLE hUserData);
	HRESULT			PlayBuffer(IDirectMusicSynthSink *pSynthSink, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable);
	HRESULT			SetNumChannelGroups(DWORD dwCableCount);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT			Open(DWORD dwCableCount, DWORD dwVoices, BOOL fReverb);
	HRESULT			Close();
    void			ResetPerformanceStats();
    HRESULT			AllNotesOff();
    HRESULT			SetMaxVoices(short nMaxVoices,short nTempVoices);
    HRESULT			GetMaxVoices(short *pnMaxVoices,short *pnTempVoices);
    HRESULT			GetPerformanceStats(PerfStats *pStats);
	void			Mix(short **ppvBuffer, DWORD *pdwIDs, DWORD *pdwFuncIDs, long *plPitchBends, DWORD dwBufferCount, DWORD dwBufferFlags, DWORD dwLength, LONGLONG llPosition);
    HRESULT         SetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,LPDWORD pdwPriority);
	HRESULT			SetReverb(DMUS_WAVES_REVERB_PARAMS *pParams);
    void            GetReverb(DMUS_WAVES_REVERB_PARAMS *pParams);
    void            SetReverbActive(BOOL fReverb);
    BOOL            IsReverbActive();

	/* DirectX8 methods */
	HRESULT			PlayBuffer(STIME stTime, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable);
	HRESULT			PlayBuffer(IDirectSoundSynthSink *pSynthSink, REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable);
	HRESULT			PlayVoice(IDirectSoundSynthSink *pSynthSink, REFERENCE_TIME rt, DWORD dwVoiceId, DWORD dwChannelGroup, DWORD dwChannel, DWORD dwDLId, VREL vrVolume, PREL prPitch, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd);
    HRESULT			StopVoice(IDirectSoundSynthSink *pSynthSink, REFERENCE_TIME rt, DWORD dwVoiceId);
    HRESULT			GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[]);
    HRESULT			Refresh(DWORD dwDownloadID, DWORD dwFlags);
	HRESULT			AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBusses, DWORD cBusses);
public:
    bool            BusIDToFunctionID(DWORD dwBusID, DWORD *pdwFunctionID, long *plPitchBends, DWORD *pdwIndex);   // Converts the passed bus id into the equivalent function id and position in buffer array. 
private:
    void			StealNotes(STIME stTime);
    void			StartMix(short *pBuffer,DWORD dwlength,BOOL bInterleaved);
    void			FinishMix(short *pBuffer,DWORD dwlength,BOOL bInterleaved);
	short			ChangeVoiceCount(CVoiceList *pList,short nOld,short nCount);

private:
    DWORD *         m_pdwBusIDs;        // Temp pointer to array of bus ids. This is valid only during a mix.
    DWORD *         m_pdwFuncIDs;       // Temp pointer to array of corresponding functional ids. This is also only valid during a mix.
    long *          m_plPitchBends;     // Temp pointer to array of corresponding pitch offsets.
    DWORD           m_dwBufferCount;    // Size of two preceding arrays.
    CVoice *        OldestVoice();
    void            QueueVoice(CVoice *pVoice);
    CVoice *        StealVoice(DWORD dwPriority);
    STIME           m_stLastTime;       // Sample time of last mix.
    CVoiceList      m_VoicesFree;       // List of available voices.
    CVoiceList      m_VoicesExtra;      // Extra voices for temporary overload.
    CVoiceList      m_VoicesInUse;      // List of voices currently in use.
    short           m_nMaxVoices;       // Number of allowed voices.
    short           m_nExtraVoices;      // Number of voices over the limit that can be used in a pinch.
    STIME           m_stLastStats;      // Last perfstats refresh.
    PerfStats       m_BuildStats;       // Performance info accumulator.
    PerfStats       m_CopyStats;        // Performance information for display.

    BOOL            m_fReverbActive;    // Whether reverb is currently on or off.
    long *          m_pStates;          // State storage for reverb.
    void *          m_pCoefs;           // Coeeficient storage for reverb.
    DMUS_WAVES_REVERB_PARAMS	m_ReverbParams; // Reverb settings.

public:	
    VREL            m_vrGainAdjust;     // Final output gain adjust
	// DLS-1 compatibility parameters: set these off to emulate hardware
	// which can't vary volume/pan during playing of a note.
    BOOL            m_fAllowPanWhilePlayingNote;
    BOOL            m_fAllowVolumeChangeWhilePlayingNote;

    STIME           m_stMinSpan;        // Minimum time allowed for mix time span.
    STIME           m_stMaxSpan;        // Maximum time allowed for mix time span.
	DWORD           m_dwSampleRate;		// Sample rate 
    DWORD           m_dwStereo;			// Is the output stereo 
    CInstManager    m_Instruments;      // Instrument manager.
	CControlLogic **m_ppControl;		// Array of open ControlLogics.
	DWORD			m_dwControlCount;	// # of open CLs.
    
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;
	BOOL			m_sfMMXEnabled;		// Is MMX enabled 
};

#endif// __CSYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\control.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      CControlLogic.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include "misc.h"
#include "csynth.h"
#include "debug.h"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Manage the global critical section. #pragma's disable the warning about
// not compiling with -GX when using exception handling, which we don't
// care about.
//
//
// The critical section must be global because it protects global
// data in the CMIDIRecorder class. These functions are called from 
// DllMain().
//

CRITICAL_SECTION CControlLogic::s_CriticalSection;
BOOL CControlLogic::s_fCSInitialized = FALSE;

#pragma warning(push)
#pragma warning(disable:4530)

/* static */ BOOL CControlLogic::InitCriticalSection()
{
    s_fCSInitialized = FALSE;
    try
    {
        ::InitializeCriticalSection(&s_CriticalSection);
    } catch(...)
    {
        return FALSE;
    }

    s_fCSInitialized = TRUE;
    return TRUE;
}

#pragma warning(pop)

/* static */ void CControlLogic::KillCriticalSection()
{
    if (s_fCSInitialized)
    {
        ::DeleteCriticalSection(&s_CriticalSection);
        s_fCSInitialized = FALSE;
    }
}

CControlLogic::CControlLogic()

{
    m_pSynth = NULL;
    m_pInstruments = NULL;
    DWORD nIndex;
    GMReset();
    m_fGSActive = FALSE;
    m_fXGActive = FALSE;
    for (nIndex = 0;nIndex < 16;nIndex++)
    {
        m_fSustain[nIndex] = FALSE;
        m_dwProgram[nIndex] = 0;
    }
    m_fEmpty = TRUE;
}

CControlLogic::~CControlLogic()

{
}

void CControlLogic::GMReset()

{
    static int nPartToChannel[16] = { 
        9,0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 
    };
    int nX;
    for (nX = 0; nX < 16; nX++)
    {
        int nY;
        m_nData[nX] = 0;
        m_prFineTune[nX] = 0;
        m_bDrums[nX] = 0;
        for (nY = 0; nY < 12; nY++)
        {
            m_prScaleTune[nX][nY] = 0;
        }
        m_nCurrentRPN[nX] = (short) 0x3FFF;
        m_prCoarseTune[nX] = 0; 
        m_bPartToChannel[nX] = (BYTE)nPartToChannel[nX];
        m_fMono[nX] = FALSE;
        m_dwPriority[nX] = DAUD_STANDARD_VOICE_PRIORITY + 
            ((16 - nX) * DAUD_CHAN15_VOICE_PRIORITY_OFFSET);
        m_bBankH[nX] = 0;
        m_bBankL[nX] = 0;
    }
    m_bDrums[0] = 1;
    m_vrMasterVolume = 0;
    m_fGSActive = FALSE;
    m_fXGActive = FALSE;
}

HRESULT CControlLogic::Init(CInstManager *pInstruments, CSynth *pSynth)

{
    m_pSynth = pSynth;
    m_pInstruments = pInstruments;
    m_vrGainAdjust = 0;
    CVoice::Init();
    return S_OK;
}

void CControlLogic::ClearAll()

{
    int nIndex;
    ::EnterCriticalSection(&s_CriticalSection);
    m_Notes.ClearMIDI(0x7FFFFFFF);
    for (nIndex = 0; nIndex < 16; nIndex++) {
        m_ModWheel[nIndex].ClearMIDI(0x7FFFFFFF);
        m_Volume[nIndex].ClearMIDI(0x7FFFFFFF);
        m_Pan[nIndex].ClearMIDI(0x7FFFFFFF);
        m_Expression[nIndex].ClearMIDI(0x7FFFFFFF);
        m_PitchBend[nIndex].ClearMIDI(0x7FFFFFFF);
        m_Pressure[nIndex].ClearMIDI(0x7FFFFFFF);
        m_ReverbSends[nIndex].ClearMIDI(0x7FFFFFFF);
        m_ChorusSends[nIndex].ClearMIDI(0x7FFFFFFF);
        m_CutOffFreqCC[nIndex].ClearMIDI(0x7FFFFFFF);
    }
    for (nIndex = 0; nIndex < 16; nIndex++) {
        m_ModWheel[nIndex].RecordMIDI(0, 0);
        m_Volume[nIndex].RecordMIDI(0, 100);
        m_Pan[nIndex].RecordMIDI(0, 64);
        m_Expression[nIndex].RecordMIDI(0, 127);
        m_PitchBend[nIndex].RecordMIDI(0, 0x2000);
        m_Pressure[nIndex].RecordMIDI(0, 0);
        m_ReverbSends[nIndex].RecordMIDI(0, 40);
        m_ChorusSends[nIndex].RecordMIDI(0, 0);
        m_CutOffFreqCC[nIndex].RecordMIDI(0, 64);
        m_Notes.RecordEvent(0, nIndex, NOTE_SUSTAIN, 0);
    }
    m_fEmpty = TRUE;
    ::LeaveCriticalSection(&s_CriticalSection);
}

void CControlLogic::ClearMIDI(STIME stEndTime)
{
    DWORD dwIndex;
    ::EnterCriticalSection(&s_CriticalSection);
    if (!m_fEmpty)
    {        
        m_fEmpty = TRUE;
        for (dwIndex = 0;dwIndex < 16; dwIndex++)
        {
            m_fEmpty = m_ModWheel[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_PitchBend[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_Volume[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_Expression[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_Pan[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_Pressure[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_ReverbSends[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_ChorusSends[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
            m_fEmpty = m_CutOffFreqCC[dwIndex].ClearMIDI(stEndTime) && m_fEmpty;
        }
    }
    ::LeaveCriticalSection(&s_CriticalSection);
}

void CControlLogic::SetGainAdjust(VREL vrGainAdjust)
{
    m_vrGainAdjust = vrGainAdjust;
}

void CControlLogic::QueueNotes(STIME stStartTime, STIME stEndTime)
{
    CNote note;

    ::EnterCriticalSection(&s_CriticalSection);
    
    while (m_Notes.GetNote(stEndTime,&note))
    {
        if (note.m_stTime < stStartTime)
        {
            TraceI(2, "Note started %d samples late!\n", (long)(stStartTime - note.m_stTime));

            note.m_stTime = stStartTime;
        }

        if (note.m_bKey > 0x7F) // Special command events.
        {
            long lTemp;
            DWORD dwPart = note.m_bPart;
            DWORD dwCommand = note.m_bKey;
            BYTE bData = note.m_bVelocity;
            switch (dwCommand)
            {
            case NOTE_PROGRAMCHANGE:
                m_dwProgram[dwPart] = bData |
                    (m_bBankH[dwPart] << 16) | 
                    (m_bBankL[dwPart] << 8);
                break;
            case NOTE_CC_BANKSELECTH:
                m_bBankH[dwPart] = bData;
                break;
            case NOTE_CC_BANKSELECTL:
                m_bBankL[dwPart] = bData;
                break;
            case NOTE_CC_POLYMODE:
                m_fMono[dwPart] = FALSE;
                break;
            case NOTE_CC_MONOMODE:
                m_fMono[dwPart] = TRUE;
                break;
            case NOTE_CC_RPN_MSB:
                m_nCurrentRPN[dwPart] = (m_nCurrentRPN[dwPart] & 0x7f) + (bData << 7);
                break;
            case NOTE_CC_RPN_LSB:
                m_nCurrentRPN[dwPart] = (m_nCurrentRPN[dwPart] & 0x3f80) + bData;
                break;
            case NOTE_CC_NRPN:
                m_nCurrentRPN[dwPart] = 0x3FFF;
                break;
            case NOTE_CC_DATAENTRYLSB:
                m_nData[dwPart] &= ~0x7F;
                m_nData[dwPart] |= bData;
                switch (m_nCurrentRPN[dwPart])
                {
                case RPN_PITCHBEND: // Don't do anything, Roland ignores lsb
                    break;
                case RPN_FINETUNE:
                    lTemp = m_nData[dwPart];
                    lTemp -= 8192;
                    lTemp *= 100;
                    lTemp /= 8192;
                    m_prFineTune[dwPart] = lTemp;
                    break;
                case RPN_COARSETUNE: // Ignore lsb
                    break;            
                }
                break;
            case NOTE_CC_DATAENTRYMSB:
                m_nData[dwPart] &= ~(0x7F << 7);
                m_nData[dwPart] |= bData << 7;
                switch (m_nCurrentRPN[dwPart])
                {
                case RPN_PITCHBEND:
                    m_PitchBend[dwPart].m_prRange = bData * 100;
                    break;
                case RPN_FINETUNE:
                    lTemp = m_nData[dwPart];
                    lTemp -= 8192;
                    lTemp *= 100;
                    lTemp /= 8192;
                    m_prFineTune[dwPart] = lTemp;
                    break;
                case RPN_COARSETUNE:
                    m_prCoarseTune[dwPart] = 100 * (bData - 64);
                    break;        
                }
                break;
            case NOTE_SUSTAIN: // special sustain marker
                m_fSustain[dwPart] = (BOOL) bData;
                if (bData == FALSE)
                {
                    CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    for (;pVoice != NULL;pVoice = pVoice->GetNext())
                    {
                        if (pVoice->m_fSustainOn &&
                            (pVoice->m_nPart == dwPart) &&
                            (pVoice->m_pControl == this))
                        {
                            pVoice->StopVoice(note.m_stTime);
                        }
                    }
                } 
                break;
            case NOTE_ALLOFF:
                {
                    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    for (;pVoice != NULL; pVoice = pVoice->GetNext())
                    {
                        if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
                            (pVoice->m_nPart == dwPart) &&
                            (pVoice->m_pControl == this))
                        {
                            if (m_fSustain[dwPart])
                            {
                                pVoice->m_fSustainOn = TRUE;
                            }
                            else
                            {
                                pVoice->StopVoice(note.m_stTime);
                            }
                        }
                    }
                }
                break;
            case NOTE_SOUNDSOFF:
                {
                    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    for (;pVoice != NULL; pVoice = pVoice->GetNext())
                    {
                        if ((pVoice->m_nPart == dwPart) &&
                            (pVoice->m_pControl == this))
                        {
                            pVoice->QuickStopVoice(note.m_stTime);
                        }
                    }
                }
                break;
            case NOTE_ASSIGNRECEIVE:
                m_bPartToChannel[dwPart] = (BYTE) bData;
                break;
            case NOTE_MASTERVOLUME:
                m_vrMasterVolume = CMIDIRecorder::VelocityToVolume(bData);
                break;
            }
        }
        else if (note.m_bVelocity == 0)  // Note Off.
        {
            CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
            WORD nPart = note.m_bPart;
            DWORD dwNoteID = 0; // Use to track multiple voices on one note.
            for (;pVoice != NULL;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
                    (pVoice->m_nKey == (WORD) note.m_bKey) &&
                    (pVoice->m_nPart == nPart) &&
                    (pVoice->m_pControl == this)) 
                {
                    if (!dwNoteID || (dwNoteID == pVoice->m_dwNoteID))
                    {
                        dwNoteID = pVoice->m_dwNoteID;
                        if (m_fSustain[nPart])
                        {
                            pVoice->m_fSustainOn = TRUE;
                        }
                        else
                        {
                            pVoice->StopVoice(note.m_stTime);
                        }
                    }
                }
            }
        }
        else   // Note On.
        {
            DWORD dwProgram = m_dwProgram[note.m_bPart];
            if (m_bDrums[note.m_bPart])
            {
                dwProgram |= F_INSTRUMENT_DRUMS;
            }
            if (m_fMono[note.m_bPart])
            {
                CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
                WORD nPart = note.m_bPart;
                for (;pVoice != NULL;pVoice = pVoice->GetNext())
                {
                    if (pVoice->m_fNoteOn && (pVoice->m_nPart == nPart) &&
                        (pVoice->m_pControl == this)) 
                    {
                        pVoice->StopVoice(note.m_stTime);
                    }
                }
            }
            // While we are working with the instrument, including copying
            // the data over from the region, we have to make sure it
            // can not be removed from the instrument list.
            EnterCriticalSection(&m_pInstruments->m_CriticalSection);
            CInstrument * pInstrument = 
                m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
            if (!pInstrument) 
            {
                if (dwProgram & F_INSTRUMENT_DRUMS)
                {
                    dwProgram = F_INSTRUMENT_DRUMS;
                    pInstrument = 
                        m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
                }
                else if (m_fXGActive)
                {
                    if ((dwProgram & 0x7F0000) == 0x7F0000) // Drum?
                    {
                        dwProgram &= 0x7F007F;              // Enforce 0 LSB
                        pInstrument = 
                            m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
                        if (!pInstrument)
                        {
                            dwProgram = 0x7F0000;
                            pInstrument = 
                                m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
                        }
                    }
                    else
                    {
                        dwProgram &= 0x7F;  // Fall back to GM set.
                        pInstrument = 
                            m_pInstruments->GetInstrument(dwProgram,note.m_bKey,note.m_bVelocity);
                    }
                }
            }
            if (pInstrument != NULL)
            {
                DWORD dwNotesLost = 1;  // Assume note will be lost, will be decremented if played 
                CSourceRegion * pRegion = NULL;
                static DWORD sdwNoteID = 0; // Generate a unique id that will be placed in all voices that play this note.
                sdwNoteID++;                // This will be used to keep the voices associated so we can stop them all at once later.
                while ( pRegion = pInstrument->ScanForRegion(note.m_bKey, note.m_bVelocity, pRegion) ) 
                {
                    WORD nPart = note.m_bPart;
                    CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    if (!pRegion->m_bAllowOverlap)
                    {
                        for (;pVoice != NULL; pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_nPart == nPart) &&
                                (pVoice->m_nKey == note.m_bKey) &&
                                (pVoice->m_pControl == this) && 
                                (pVoice->m_pRegion  == pRegion))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }    
                    }

                    if (pRegion->m_bGroup != 0)
                    {
                        pVoice = m_pSynth->m_VoicesInUse.GetHead();
                        for (;pVoice != NULL;pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_dwGroup == pRegion->m_bGroup) &&
                                (pVoice->m_nPart == nPart) &&
                                (pVoice->m_dwProgram == dwProgram) &&
                                (pVoice->m_pControl == this))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }
                    }
                
                    pVoice = m_pSynth->m_VoicesFree.RemoveHead();
                    if (pVoice == NULL)
                    {
                        pVoice = m_pSynth->m_VoicesExtra.RemoveHead();
                    }

                    if (pVoice == NULL)
                    {
                        pVoice = m_pSynth->StealVoice(m_dwPriority[nPart]);
                        
                        // The voice IDs are used by the VoiceServiceThread in DMusic
                        // to refill the streaming wave buffers....
                        // Since the voice is stolen this voice could really belong to
                        // a streaming wave in which case preserving the voice ID will 
                        // break the refill code. (NOTE!! This is different from stealing
                        // voices for waves. Waves will ultimately preserve the voice ID as 
                        // they pass it to StartWave where it gets assigned to the voice's 
                        // m_dwVoiceId member).

                        if(pVoice)
                        {
                            // Set the voice ID to something unacceptable
                            pVoice->m_dwVoiceId = 0xffffffff;
                        }
                    }

                    if (pVoice != NULL)
                    {
                        PREL prPitch = m_prFineTune[nPart] + m_prScaleTune[nPart][note.m_bKey % 12];
                        if (!m_bDrums[nPart]) 
                        {
                            if (m_fXGActive)
                            {
                                if ((dwProgram & 0x7F0000) != 0x7F0000)
                                {
                                    prPitch += m_prCoarseTune[nPart];
                                }
                            }
                            else
                            {
                                prPitch += m_prCoarseTune[nPart];
                            }
                        }

                        pVoice->m_nKey = note.m_bKey;
                        pVoice->m_nPart = nPart;
                        pVoice->m_dwProgram = dwProgram;
                        pVoice->m_dwPriority = m_dwPriority[nPart];
                        pVoice->m_pControl = this;
                        pVoice->m_pRegion = pRegion;
                        pVoice->m_dwNoteID = sdwNoteID;

                        if (pVoice->StartVoice(m_pSynth,
                            pRegion, note.m_stTime, 
                            &m_ModWheel[nPart],
                            &m_PitchBend[nPart],
                            &m_Expression[nPart],
                            &m_Volume[nPart],
                            &m_Pan[nPart],
                            &m_Pressure[nPart],
                            &m_ReverbSends[nPart],
                            &m_ChorusSends[nPart],
                            &m_CutOffFreqCC[nPart],
                            &m_BusIds[nPart],
                            (WORD)note.m_bKey,
                            (WORD)note.m_bVelocity,
                            m_vrMasterVolume, 
                            prPitch))
                        {
                            pVoice->m_fInUse = TRUE;
                            m_pSynth->QueueVoice(pVoice);
                            dwNotesLost = 0;    // Note played remove notelost assumpstion 
                        }
                        else
                        {
                            m_pSynth->m_VoicesFree.AddHead(pVoice);
                        }
                    } 
                } 
                m_pSynth->m_BuildStats.dwNotesLost += dwNotesLost;
            } 
            else 
            {
                Trace(1,"Error: No instrument/region was found for patch # %lx, note %ld\n",
                    dwProgram, (long) note.m_bKey);
            }
            LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
        }
    }

    ::LeaveCriticalSection(&s_CriticalSection);
}

void CControlLogic::Flush(STIME stTime)

{
    DWORD dwIndex;
    ::EnterCriticalSection(&s_CriticalSection);
    if (!m_fEmpty)
    {        
        m_fEmpty = TRUE;
        for (dwIndex = 0;dwIndex < 16; dwIndex++)
        {
            m_fEmpty = m_ModWheel[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_PitchBend[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_Volume[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_Expression[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_Pan[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_Pressure[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_ReverbSends[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_ChorusSends[dwIndex].FlushMIDI(stTime) && m_fEmpty;
            m_fEmpty = m_CutOffFreqCC[dwIndex].FlushMIDI(stTime) && m_fEmpty;
        }
        m_Notes.FlushMIDI(stTime);
    }
    ::LeaveCriticalSection(&s_CriticalSection);
}

BOOL CControlLogic::RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2)

{
    WORD nPreChannel = bStatus & 0xF; 
    CNote note;
    bStatus = bStatus & 0xF0;
    BOOL bReturn = TRUE;
    WORD nPart;

    ::EnterCriticalSection(&s_CriticalSection);

    for (nPart = 0;nPart < 16; nPart++)
    {
        if (nPreChannel == m_bPartToChannel[nPart])
        {
            switch (bStatus)
            {
            case MIDI_NOTEOFF :
                bData2 = 0;
            case MIDI_NOTEON :
                note.m_bPart = (BYTE) nPart;
                note.m_bKey = bData1;
                note.m_bVelocity = bData2;
                bReturn = m_Notes.RecordNote(stTime,&note);
                break;
            case MIDI_CCHANGE :
                switch (bData1)
                {
                case CC_BANKSELECTH :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_BANKSELECTH, bData2);
                    break;
                case CC_MODWHEEL :
                    m_fEmpty = FALSE;
                    bReturn = m_ModWheel[nPart].RecordMIDI(stTime,(long) bData2);
                    break;
                case CC_VOLUME :
                    m_fEmpty = FALSE;
                    bReturn = m_Volume[nPart].RecordMIDI(stTime,(long) bData2);
                    break;
                case CC_PAN :
                    m_fEmpty = FALSE;
                    bReturn = m_Pan[nPart].RecordMIDI(stTime,(long) bData2);
                    break;
                case CC_EXPRESSION :
                    m_fEmpty = FALSE;
                    bReturn = m_Expression[nPart].RecordMIDI(stTime,(long)bData2);
                    break;
                case CC_BANKSELECTL :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_BANKSELECTL, bData2);
                    break;
                case CC_RESETALL:
                    m_fEmpty = FALSE;
                    if (bData2)
                    {
                        bReturn = bReturn && m_Volume[nPart].RecordMIDI(stTime, 100);
                        bReturn = bReturn && m_Pan[nPart].RecordMIDI(stTime, 64);
                    }
                    bReturn = bReturn && m_Expression[nPart].RecordMIDI(stTime, 127);
                    bReturn = bReturn && m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
                    bReturn = bReturn && m_ModWheel[nPart].RecordMIDI(stTime, 0);   
                    bReturn = bReturn && m_Pressure[nPart].RecordMIDI(stTime, 0);
                    bReturn = bReturn && m_ReverbSends[nPart].RecordMIDI(stTime, 40);
                    bReturn = bReturn && m_ChorusSends[nPart].RecordMIDI(stTime, 0);
                    bReturn = bReturn && m_CutOffFreqCC[nPart].RecordMIDI(stTime, 64);
                    bData2 = 0;
                    // fall through into Sustain Off case....
        
                case CC_SUSTAIN :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SUSTAIN, bData2);
                    break;
                case CC_ALLSOUNDSOFF:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
                    break;
                case CC_ALLNOTESOFF:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_ALLOFF, 0);
                    break;
                case CC_DATAENTRYMSB:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_DATAENTRYMSB, bData2);
                    break;
                case CC_DATAENTRYLSB:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_DATAENTRYLSB, bData2);
                    break;
                case CC_NRPN_LSB :
                case CC_NRPN_MSB :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_NRPN, bData2);
                    break;
                case CC_RPN_LSB:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_RPN_LSB, bData2);
                    break; 
                case CC_RPN_MSB:
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_RPN_MSB, bData2);
                    break;
                case CC_MONOMODE :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_MONOMODE, bData2);
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
                    break;
                case CC_POLYMODE :
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_POLYMODE, bData2);
                    bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
                    break;
                case CC_REVERB :
                    m_fEmpty = FALSE;
                    bReturn = m_ReverbSends[nPart].RecordMIDI(stTime,(long)bData2);
                    break;
                case CC_CHORUS :
                    m_fEmpty = FALSE;
                    bReturn = m_ChorusSends[nPart].RecordMIDI(stTime,(long)bData2);
                    break;
                case CC_CUTOFFFREQ:
                    m_fEmpty = FALSE;
                    bReturn = m_CutOffFreqCC[nPart].RecordMIDI(stTime,(long)bData2);
                    break;
                default:
                    break;
                }
                break;

            case MIDI_PCHANGE :
                bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_PROGRAMCHANGE, bData1);
                break;
        
            case MIDI_PBEND :
                m_fEmpty = FALSE;
                {
                    WORD nBend;
                    nBend = bData2 << 7;
                    nBend |= bData1;
                    bReturn = m_PitchBend[nPart].RecordMIDI(stTime,(long)nBend);
                }
                break;

            case MIDI_MTOUCH:
                m_fEmpty = FALSE;
                bReturn = m_Pressure[nPart].RecordMIDI(stTime,(long)bData1);
                break;
            }
        }
    }
    ::LeaveCriticalSection(&s_CriticalSection);

    return bReturn;
}

HRESULT CControlLogic::RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime)

{
    HRESULT hSuccess = S_OK;
    int nPart;
    int nTune;
    DWORD dwAddress;
    BOOL fClearAll = FALSE;
    BOOL fResetPatches = FALSE;
    if (dwSysExLength < 6) 
    {
        Trace(4,"Warning: Unknown sysex message sent to synth.\n");
        return E_FAIL;
    }

    EnterCriticalSection(&s_CriticalSection);

    switch (pSysExData[1])  // ID number
    {
    case 0x7E : // General purpose ID
        if (pSysExData[3] == 0x09) 
        {
            GMReset();
            fClearAll = TRUE;
            fResetPatches = TRUE;
        }
        break;
    case 0x7F : // Real time ID
        if (pSysExData[3] == 0x04)
        {
            if (pSysExData[4] == 1) // Master Volume
            {
                m_Notes.RecordEvent(stTime, 0, NOTE_MASTERVOLUME, pSysExData[6]);
            }
        }
        break;
    case 0x41 : // Roland
        if (dwSysExLength < 11) 
        {
            Trace(4,"Warning: Unknown sysex message sent to synth.\n");
            LeaveCriticalSection(&s_CriticalSection);
            return E_FAIL;
        }
        if (pSysExData[3] != 0x42) break;
        if (pSysExData[4] != 0x12) break;
        nPart = pSysExData[6] & 0xF;
        dwAddress = (pSysExData[5] << 16) |
            ((pSysExData[6] & 0xF0) << 8) | pSysExData[7];
        switch (dwAddress)
        {
        case 0x40007F :     // GS Reset.
            GMReset();
            m_fXGActive = FALSE;
            fClearAll = TRUE;
            m_fGSActive = TRUE;
            fResetPatches = TRUE;
            break;
        case 0x401002 :     // Set Receive Channel.
            if (m_fGSActive)
            {
                if (pSysExData[8])
                {
                    m_Notes.RecordEvent(stTime, nPart, NOTE_ASSIGNRECEIVE, pSysExData[8] - 1);
                }
            }
            break;
        case 0x401015 :     // Use for Rhythm.
            if (m_fGSActive)
            {
                m_bDrums[nPart] = pSysExData[8];
                fClearAll = TRUE;
            }
            break;
        case 0x401040 :     // Scale Tuning.
            if (m_fGSActive)
            {
                for (nTune = 0;nTune < 12; nTune++)
                {
                    if (pSysExData[9 + nTune] & 0x80) break;
                    m_prScaleTune[nPart][nTune] = 
                        (PREL) pSysExData[8 + nTune] - (PREL) 64;
                }
            }
            break;
        }
        break;
    case 0x43 : // Yamaha
        if ((pSysExData[3] == 0x4C) &&
            (pSysExData[4] == 0) &&
            (pSysExData[5] == 0) &&
            (pSysExData[6] == 0x7E) &&
            (pSysExData[7] == 0))
        {   // XG System On
            m_fXGActive = TRUE;
            m_fGSActive = FALSE;
            GMReset();
            m_fXGActive = TRUE;
            m_bDrums[0] = 0;
            m_bBankH[0] = 127;
            fClearAll = TRUE;
            fResetPatches = TRUE;
        }
        break;
    }
    if (fClearAll)
    {
        Flush(0);
        for (nPart = 0;nPart < 16;nPart++)
        {        
            m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
            m_Notes.RecordEvent(stTime, nPart, NOTE_SUSTAIN, 0);
            m_Volume[nPart].RecordMIDI(stTime, 100);
            m_Pan[nPart].RecordMIDI(stTime, 64);
            m_Expression[nPart].RecordMIDI(stTime, 127);
            m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
            m_ModWheel[nPart].RecordMIDI(stTime, 0);
            m_Pressure[nPart].RecordMIDI(stTime, 0);
            m_ReverbSends[nPart].RecordMIDI(stTime, 40);
            m_ChorusSends[nPart].RecordMIDI(stTime, 0);
            m_CutOffFreqCC[nPart].RecordMIDI(stTime, 64);
        }
    }
    if (fResetPatches)
    {
        for (nPart = 0;nPart < 16;nPart++)
        {     
            if ((nPart == 0) && (m_fXGActive))
            {
                m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTH, 127);
            }
            else
            {
                m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTH, 0);
            }
            m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTL, 0);
            m_Notes.RecordEvent(stTime, nPart, NOTE_PROGRAMCHANGE, 0);
        }
    }

    LeaveCriticalSection(&s_CriticalSection);
    return hSuccess;
}

HRESULT CControlLogic::SetChannelPriority(DWORD dwChannel,DWORD dwPriority)

{
    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_bPartToChannel[dwPart] == dwChannel)
        {
            m_dwPriority[dwPart] = dwPriority;
        }
    }
    return S_OK;
}

HRESULT CControlLogic::GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority)

{
    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_bPartToChannel[dwPart] == dwChannel)
        {
            *pdwPriority = m_dwPriority[dwPart];
            break;
        }
    }
    return S_OK;
}

//////////////////////////////////////////////////////////
// Directx8 Methods 

BOOL CControlLogic::RecordWaveEvent(
    STIME stTime, BYTE bChannel, DWORD dwVoiceId, VREL vrVolume, PREL prPitch, 
    SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd,
    CWaveArt* pWaveArt)

{
    WORD nPreChannel = bChannel;
    CWaveEvent wave;
    BOOL bReturn = TRUE;
    WORD nPart;

    ::EnterCriticalSection(&s_CriticalSection);

    for (nPart = 0;nPart < 16; nPart++)
    {
        if (nPreChannel == m_bPartToChannel[nPart])
        {
            wave.m_bPart        = (BYTE)nPart;
            wave.m_dwVoiceId    = dwVoiceId;
            wave.m_vrVolume     = vrVolume;
            wave.m_prPitch      = prPitch;
            wave.m_pWaveArt     = pWaveArt;
            wave.m_stVoiceStart = stVoiceStart;
            wave.m_stLoopStart  = stLoopStart;
            wave.m_stLoopEnd    = stLoopEnd;
            wave.m_pWaveArt->AddRef();

            bReturn = m_Waves.RecordWave(stTime,&wave);
        }
    }

    ::LeaveCriticalSection(&s_CriticalSection);

    return bReturn;
}

void CControlLogic::QueueWaves(STIME stEndTime)
{
    CWaveEvent wave;
    BOOL fGotAWave = TRUE;

    while (fGotAWave)
    {
        EnterCriticalSection(&m_pInstruments->m_CriticalSection);
        fGotAWave = m_Waves.GetWave(stEndTime,&wave);
        if (!fGotAWave)
        {
            LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
            break;
        }

        WORD nPart = wave.m_bPart;

        CVoice * pVoice = m_pSynth->m_VoicesFree.RemoveHead();

        if (pVoice == NULL)
        {
            pVoice = m_pSynth->m_VoicesExtra.RemoveHead();
        }

        if (pVoice == NULL)
        {
            pVoice = m_pSynth->StealVoice(m_dwPriority[nPart]);
        }

        if (pVoice != NULL)
        {
            PREL prPitch = wave.m_prPitch;
            prPitch += m_prFineTune[nPart]; 
            prPitch += m_prCoarseTune[nPart];

            pVoice->m_nKey = 0xffff;                // set to unused values 
            pVoice->m_dwProgram = 0xffffffff;       // set to unused values 
            pVoice->m_nPart = nPart;
            pVoice->m_dwPriority = m_dwPriority[nPart];
            pVoice->m_pControl = this;
            pVoice->m_pRegion  = NULL;

            if (pVoice->StartWave(m_pSynth,
                wave.m_pWaveArt,
                wave.m_dwVoiceId, 
                wave.m_stTime, 
                &m_PitchBend[nPart],
                &m_Expression[nPart],
                &m_Volume[nPart],
                &m_Pan[nPart],
                &m_ReverbSends[nPart],
                &m_ChorusSends[nPart],
                &m_CutOffFreqCC[nPart],
                &m_BusIds[nPart],
                wave.m_vrVolume,    
                prPitch,
                wave.m_stVoiceStart,
                wave.m_stLoopStart,
                wave.m_stLoopEnd
                ))
            {
                pVoice->m_fInUse = TRUE;
                m_pSynth->QueueVoice(pVoice);
            }
            else
            {
                m_pSynth->m_VoicesFree.AddHead(pVoice);
            }
        } 
        else 
        {
            Trace(1,"Error: No voice avaible for voice id #%lx\n", wave.m_dwVoiceId);
        }
        if (wave.m_pWaveArt) wave.m_pWaveArt->Release(); // no longer need to hold this ref count
        LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
    }
}

void CControlLogic::FlushWaveByStopTime(DWORD dwID, STIME stStopTime)
{
    EnterCriticalSection(&m_pInstruments->m_CriticalSection);
    m_Waves.RemoveWaveByStopTime(dwID, stStopTime);
    LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
}

HRESULT CControlLogic::AssignChannelToBuses(DWORD dwChannel, LPDWORD pdwBusIds, DWORD dwBusCount)
{
    HRESULT hr = S_OK;

    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_bPartToChannel[dwPart] == dwChannel)
        {
            //
            // Assign new bus ids to this channel 
            //
            if ( pdwBusIds && dwBusCount > 0 )
            {
                hr = m_BusIds[dwPart].AssignBuses(pdwBusIds, dwBusCount);
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
CWaveDataList    CWaveIn::m_sFreeList;
DWORD            CWaveIn::m_sUsageCount = 0;


CWaveData::CWaveData() 
{
    m_stTime = 0;
}

CWaveIn::CWaveIn()
{
    m_sUsageCount++;
    m_stCurrentTime = 0;
}

CWaveIn::~CWaveIn()

{
    ClearWave(0x7FFFFFFF);
    m_sUsageCount--;
    // If there are no instances of CMIDIRecorder left, get rid of the free pool.
    if (!m_sUsageCount)
    {
        CWaveData *pWD;
        while (pWD = m_sFreeList.RemoveHead())
        {
            delete pWD;
        }
    }
}

/*void CWaveIn::Init()
{
    int nIndex;
    static BOOL fAlreadyDone = FALSE;
    if (!fAlreadyDone)
    {
        m_sFreeList.RemoveAll();
        for (nIndex = 0; nIndex < MAX_MIDI_EVENTS; nIndex++)
        {
            m_sFreeList.AddHead(&m_sEventBuffer[nIndex]);
        }
        fAlreadyDone = TRUE;
    }
}*/

/*
BOOL CWaveIn::FlushWave(STIME stTime)

{
    CWaveData *pWD;
    CWaveData *pLast = NULL;

    for (pWD = m_EventList.GetHead();pWD != NULL;pWD = pWD->GetNext())
    {
        if (pWD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                pLast->SetNext(NULL);
            }
            m_sFreeList.Cat(pWD);
            break;
        }
        pLast = pWD;
    }
    return m_EventList.IsEmpty();
}
*/

BOOL CWaveIn::ClearWave(STIME stTime)

{
    CWaveData *pWD;

    for (;pWD = m_EventList.GetHead();)
    {
        if (pWD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pWD->m_stTime;
            m_lCurrentData  = pWD->m_WaveEventData;
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
            
        }
        else break;
    }
    return m_EventList.IsEmpty();
}

BOOL CWaveIn::RemoveWave(DWORD dwID)

{
    CWaveData *pWD = m_EventList.GetHead();
    CWaveData *pWDNext = NULL;

    for (; pWD; pWD = pWDNext)
    {
        pWDNext = pWD->GetNext();
        if (pWD->m_WaveEventData.m_dwVoiceId == dwID)
        {
            m_EventList.Remove(pWD);
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
        }
    }
    return m_EventList.IsEmpty();
}

BOOL CWaveIn::RemoveWaveByStopTime(DWORD dwID, STIME stStopTime)

{
    CWaveData *pWD = m_EventList.GetHead();
    CWaveData *pWDNext = NULL;

    for (; pWD; pWD = pWDNext)
    {
        pWDNext = pWD->GetNext();
        if (pWD->m_WaveEventData.m_dwVoiceId == dwID && pWD->m_stTime >= stStopTime)
        {
            m_EventList.Remove(pWD);
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
        }
    }
    return m_EventList.IsEmpty();
}

BOOL CWaveIn::RecordWave(STIME stTime, CWaveEvent* pWave)

{
    CWaveData *pWD = m_sFreeList.RemoveHead();
    if (!pWD)
    {
        pWD = new CWaveData;
    }    

    CWaveData *pScan = m_EventList.GetHead();
    CWaveData *pNext;

    if (pWD)
    {
        pWD->m_stTime        = stTime;
        pWD->m_WaveEventData = *pWave;
        pWD->m_WaveEventData.m_stTime = stTime;
        if (pScan == NULL)
        {
            m_EventList.AddHead(pWD);
        }
        else
        {
            if (pScan->m_stTime > stTime)
            {
                m_EventList.AddHead(pWD);
            }
            else
            {
                for (;pScan != NULL; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (pNext == NULL)
                    {
                        pScan->SetNext(pWD);
                    }
                    else
                    {
                        if (pNext->m_stTime > stTime)
                        {
                            pWD->SetNext(pNext);
                            pScan->SetNext(pWD);
                            break;
                        }
                    }
                }
            }
        }
        return (TRUE);
    }
    Trace(1,"Error: Wave Event pool empty.\n");

    return (FALSE);
}

BOOL CWaveIn::GetWave(STIME stTime, CWaveEvent *pWave)

{
    CWaveData *pWD = m_EventList.GetHead();

    if (pWD != NULL)
    {
        if (pWD->m_stTime <= stTime)
        {
            *pWave =  pWD->m_WaveEventData;
            m_EventList.RemoveHead();
            m_sFreeList.AddHead(pWD);
            return (TRUE);
        }
    }
    return (FALSE);
}

/////////////////////////////////////////////////////////////////
CBusIds::CBusIds()
{
    m_dwBusIds[0] = DSBUSID_LEFT;
    m_dwBusIds[1] = DSBUSID_RIGHT;
    m_dwBusIds[2] = DSBUSID_REVERB_SEND;
    m_dwBusIds[3] = DSBUSID_CHORUS_SEND;
    m_dwBusCount = NUM_DEFAULT_BUSES;
}

CBusIds::~CBusIds()
{
}

HRESULT CBusIds::Initialize()
{
    HRESULT hr = S_OK;

    m_dwBusIds[0] = DSBUSID_LEFT;
    m_dwBusIds[1] = DSBUSID_RIGHT;
    m_dwBusIds[2] = DSBUSID_REVERB_SEND;
    m_dwBusIds[3] = DSBUSID_CHORUS_SEND;
    m_dwBusCount = NUM_DEFAULT_BUSES;

    return hr;
}

HRESULT CBusIds::AssignBuses(LPDWORD pdwBusIds, DWORD dwBusCount)
{
    HRESULT hr = S_OK;

    if ( pdwBusIds && dwBusCount > 0 )
    {
        if ( dwBusCount > MAX_DAUD_CHAN )
            dwBusCount = MAX_DAUD_CHAN;

        memcpy(m_dwBusIds,pdwBusIds,sizeof(DWORD)*dwBusCount);
        m_dwBusCount = dwBusCount;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\debug.cpp ===
//      Copyright (c) 1996-2001 Microsoft Corporation
//
// Debug.CPP
//
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "XBOXSYNTH"

// Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// The current debug level. 
static int giDebugLevel;

// Do asserts break?
static BOOL gfAssertBreak;

// Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// Send a debug trace out.
//
// Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // The debug level of this message
    LPSTR pstrFormat,       // A printf style format string
    ...)                    // | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }

    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XboxSynth\csynth.cpp ===
//
// Copyright (c) 1996-2001 Microsoft Corporation
// CSynth.cpp
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else

#include "simple.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include "CSynth.h"
#ifdef REVERB_ENABLED
#include "sverb.h"
#endif
#include "debug.h"
#endif

#include "dsoundp.h"    // For IDirectSoundSynthSink

#ifdef _X86_
#define MMX_ENABLED 1
#endif

#ifdef MMX_ENABLED
BOOL MultiMediaInstructionsSupported();
#endif


CSynth::CSynth()

{
    DWORD nIndex;
    CVoice *pVoice;

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;

    for (nIndex = 0;nIndex < MAX_NUM_VOICES;nIndex++)
    {
        pVoice = new CVoice;
        if (pVoice != NULL)
        {
            m_VoicesFree.AddHead(pVoice);
        }
    }
    for (nIndex = 0;nIndex < NUM_EXTRA_VOICES;nIndex++)
    {
        pVoice = new CVoice;
        if (pVoice != NULL)
        {
            m_VoicesExtra.AddHead(pVoice);
        }
    }
    m_fRe