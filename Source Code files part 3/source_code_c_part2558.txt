param.band.outlineCache;

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
		{
			  return TRASHED_OUTLINE_CACHE;
		}

		pbyOutline += sizeof( uint32 ) +
			  (BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
			  + sizeof( uint32 )                      /* Outlines Exist (padded)  */
			  + sizeof( uint32 )                      /* Scan Type (padded)        */
			  + sizeof( uint32 )                      /* Glyph Index (padded)      */
			  + sizeof( uint32 )                      /* Outline Cache Size        */
			  + sizeof( uint32 )                      /* Gray Over Scale Factor    */
			  + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
			  + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
			  + sizeof( metricsType )                 /* Metrics information       */
			  + sizeof( verticalMetricsType )         /* Vert metrics information  */
			  + sizeof( GlyphBitMap )
			  + sizeof( GlyphBitMap )                 /* Over Scale structure      */
			  + sizeof( WorkScan );

		key->WScan.pchRBuffer = (char *)pbyOutline;

		/* No need to further unload outline cache */
	}

	pGBMap = &key->GBMap;                           /* default usual structure */
	key->usBandWidth = inputPtr->param.band.usBandWidth;
	key->usBandType = inputPtr->param.band.usBandType;

	if (key->bGrayScale)                                 /* if doing gray scale */
	{
		pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
		key->usBandWidth *= key->usOverScale;
/*  
 *  Band width for the over scaled bitmap is basically just the requested band 
 *  width times the overscale factor.  However! if the gray scaled bounding 
 *  box has been trimmed to match the monochrome box (i.e. bMatchBBox = TRUE),
 *  then top and bottom bands must be made bigger to include the entire over
 *  scaled bitmap.  If this were not done it would break dropout control, and
 *  bitmaps would change with banding.  So that's why we do this messing around
 *  with overshoot in the key->usBandWidth calculation.
 */
		sMaxOvershoot = 0;
		sHiOvershoot = (int16)(key->OverGBMap.rectBounds.top -
					   key->GBMap.rectBounds.top * (int16)key->usOverScale);
		if (sHiOvershoot > sMaxOvershoot)
		{
			sMaxOvershoot = sHiOvershoot;
		}
		sLoOvershoot = (int16)(key->GBMap.rectBounds.bottom * (int16)key->usOverScale -
					   key->OverGBMap.rectBounds.bottom);
		if (sLoOvershoot > sMaxOvershoot)
		{
			sMaxOvershoot = sLoOvershoot;
		}
		key->usBandWidth += (uint16)sMaxOvershoot;
	}

	error = fsc_MeasureBand(
		pGBMap,                     /* orig or over scaled bounding box, etc. */
		&key->WScan,
		key->usBandType,
		key->usBandWidth,           /* worst case band width */
		key->usScanType );
	if (error != NO_ERR)
	{
		return(error);
	}

	if (key->bGrayScale)                                 /* if doing gray scale */
	{
		key->GBMap.lMMemSize = (int32)key->GBMap.sRowBytes * (int32)inputPtr->param.band.usBandWidth;
		outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize;
	}
	
	outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
	outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
	outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;
	
	if( !key->bOutlineIsCached )
	{
		fsg_CheckWorkSpaceForFit(
			&(key->WorkSpaceOffsets),
			key->lExtraWorkSpace,
			key->WScan.lRMemSize,                             /* MeasureGlyph workspace */
			&(outputPtr->memorySizes[BITMAP_PTR_2]),
			&(outputPtr->memorySizes[BITMAP_PTR_3]));
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	}

	return NO_ERR;
}

/*********************************************************************/

#ifdef FSCFG_CONVERT_GRAY_LEVELS

// Tables to speed up bitmap translation from different GrayLevels.
uint8 Gray4To5Table[4]= {0,1,3,4};
uint8 Gray16To5Table[16]={0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4};

uint8 Gray4To17Table[4]= {0,5,11,16};
uint8 Gray16To17Table[16]={0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16};

uint8 Gray4To65Table[4]= {0,21,43,64};
uint8 Gray16To65Table[16]={0,4,9,13,17,21,26,30,34,38,43,47,51,55,60,64};

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth);

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth)
	{
	  uint16    index; // Gray level xlate table index
      switch (usOverScale) {
       case 2:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To5Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
		   }
          break;
       case 4:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To17Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
			 } /* endswitch */
		   }
          break;
       case 8:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To65Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
			 } /* endswitch */
		   }
          break;

       default:
               return BAD_GRAY_LEVEL_ERR;
       } /* endswitch */
	   return NO_ERR;

    } /* end if bGrayScale */

#endif // FSCFG_CONVERT_GRAY_LEVELS

/* Generate a bitmap                                                 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{    
	ContourList     CList;        /* newscan contour list type */
	fs_SplineKey *  key;
	char *          pBitmapPtr2;
	char *          pBitmapPtr3;
	uint8 *         pbyOutline;
	ErrorCode       error;
	GlyphBitMap *   pGBMap;             /* orig or over pointer */


	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_ON_SCAN;                    /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if( !key->bOutlineIsCached )                /* if outline or embedded bitmap */
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

		if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
		{
			fsg_UpdateWorkSpaceAddresses(
				 key->memoryBases[WORK_SPACE_BASE],
				 &(key->WorkSpaceOffsets),
				 &(key->pWorkSpaceAddr));

			fsg_UpdateWorkSpaceElement(
				 &(key->WorkSpaceOffsets),
				 &(key->pWorkSpaceAddr));

			key->apbPrevMemoryBases[WORK_SPACE_BASE] = key->memoryBases[WORK_SPACE_BASE];
		}

		fsg_SetUpWorkSpaceBitmapMemory(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			key->memoryBases[BITMAP_PTR_2],
			key->memoryBases[BITMAP_PTR_3],
			&pBitmapPtr2,                       /* sbits may need Ptr2 */
			&pBitmapPtr3);

        /* check for embedded bitmap, quick return if found */

#ifdef FSCFG_SUBPIXEL
	    if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))  				/* if bitmap are not disabled */
#else
	    if (key->bEmbeddedBitmap)  				/* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL	
    	{
    		if ((inputPtr->param.scan.topClip > inputPtr->param.scan.bottomClip) &&  /* if legal band */
               ((inputPtr->param.scan.topClip < key->GBMap.rectBounds.top) ||
                (inputPtr->param.scan.bottomClip > key->GBMap.rectBounds.bottom)))
    		{
        		return SBIT_BANDING_ERR;            /* can't band sbits */
            }

    		error = sbit_GetBitmap (
    			&key->SbitMono,
    			&key->ClientInfo,
    			(uint8 *) inputPtr->memoryBases[BITMAP_PTR_1],
    			(uint8 *) pBitmapPtr2 );
		
    		if (error != NO_ERR)
    		{
    			return((FS_ENTRY)error);
    		}
        	outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

        	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
       		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

        	STAT_OFF_SCAN;                  /* stop STAT timer */

#ifdef FSCFG_CONVERT_GRAY_LEVELS
			if (key->bGrayScale)
			{
				error = fs_ConvertGrayLevels (outputPtr, key->usOverScale, key->SbitMono.usBitDepth);
			
				if(error)
				{
					return (FS_ENTRY)error;
				}
			} /* end if bGrayScale */
#endif // FSCFG_CONVERT_GRAY_LEVELS

        	return NO_ERR;                  /* return now with an sbit */
    	}
        else        /* if scan converting an outline */
        {
			fsg_GetWorkSpaceExtra(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->WScan.pchRBuffer));

			fsg_GetContourData(
				&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
				FALSE,            
#endif // FSCFG_SUBPIXEL
				&CList.afxXCoord,
				&CList.afxYCoord,
				&CList.asStartPoint,
				&CList.asEndPoint,
				&CList.abyOnCurve,
				&CList.abyFc,
				&CList.usContourCount);
        }
    }
    else            /* Unload the outline cache */
	{
		pbyOutline = (uint8 *)inputPtr->param.scan.outlineCache;

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
		{
			 return TRASHED_OUTLINE_CACHE;
		}

		pbyOutline += sizeof( uint32 ) +
			(BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
			+ sizeof( uint32 )                      /* Outlines Exist (padded)  */
			+ sizeof( uint32 )                      /* Scan Type (padded)        */
			+ sizeof( uint32 )                      /* Glyph Index (padded)      */
			+ sizeof( uint32 )                      /* Outline Cache Size        */
			+ sizeof( uint32 )                      /* Gray Over Scale Factor    */
	        + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
	        + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
			+ sizeof( metricsType )                 /* Metrics information       */
			+ sizeof( verticalMetricsType )         /* Vert metrics information  */
			+ sizeof( GlyphBitMap )
			+ sizeof( GlyphBitMap )                 /* Over Scale structure      */
			+ sizeof( WorkScan );

		key->WScan.pchRBuffer = (char *)pbyOutline;
		pbyOutline += key->WScan.lRMemSize;

		fsg_RestoreContourData(
			&pbyOutline,
			&CList.afxXCoord,
			&CList.afxYCoord,
			&CList.asStartPoint,
			&CList.asEndPoint,
			&CList.abyOnCurve,
			&CList.abyFc,
			&CList.usContourCount);

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP2 )
		{
			return TRASHED_OUTLINE_CACHE;
		}

		pBitmapPtr2 = key->memoryBases[BITMAP_PTR_2];
		pBitmapPtr3 = key->memoryBases[BITMAP_PTR_3];
	}

	if (pBitmapPtr3 == NULL)  /* Allow client to turn off DOControl */
	{
		key->usScanType = SK_NODROPOUT;
	}

	key->GBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_1];
	key->GBMap.sHiBand = inputPtr->param.scan.topClip;
	key->GBMap.sLoBand = inputPtr->param.scan.bottomClip;

	if (key->GBMap.sHiBand <= key->GBMap.sLoBand)            /* if negative or no band */
	{
		key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* then for Apple compatiblity */
		key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* do the entire bitmap */
	}
	if (key->GBMap.sHiBand > key->GBMap.rectBounds.top)
	{
		key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* clip to bounding box */
	}
	if (key->GBMap.sLoBand < key->GBMap.rectBounds.bottom)
	{
		key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* clip to bounding box */
	}
		 
	if ((key->usBandType == FS_BANDINGFASTER) &&
		((key->apbPrevMemoryBases[BITMAP_PTR_2] != pBitmapPtr2) ||
		 (key->apbPrevMemoryBases[BITMAP_PTR_3] != pBitmapPtr3)))
	{
		 key->usBandType = FS_BANDINGFAST;  /* to recalculate memory */
	}

	if (key->usBandType == FS_BANDINGOLD)   /* if FindGrayBandingSize wasn't called */
	{
		if ((key->GBMap.sHiBand != key->GBMap.rectBounds.top) ||
			(key->GBMap.sLoBand != key->GBMap.rectBounds.bottom))   /* if banding */
		{
			if (key->bGrayScale)
			{
				return GRAY_OLD_BANDING_ERR;        /* gray scale fails with old banding */
			}
			key->usScanType = SK_NODROPOUT;         /* else force dropout off */
		}
	}
	else if (key->usBandType == FS_BANDINGSMALL)  /* if small mem type */
	{
		if (key->bGrayScale)
		{
			if (key->usOverScale *(key->GBMap.sHiBand - key->GBMap.sLoBand) > (int16)key->usBandWidth)
			{
				return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
			}
		} else {
			if (key->GBMap.sHiBand - key->GBMap.sLoBand > (int16)key->usBandWidth)
			{
				return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
			}
		}
		key->usScanType = SK_NODROPOUT;       /* turn off dropout control */
	}
	pGBMap = &key->GBMap;                     /* default to usual structure */
	
	if (key->bGrayScale)
	{
		pGBMap = &key->OverGBMap;             /* measure overscaled structure */
		
		if (key->GBMap.sHiBand == key->GBMap.rectBounds.top)            /* if gray band at top */
		{
			key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;     /* use over top */
		}
		else
		{
			key->OverGBMap.sHiBand = (int16)(key->GBMap.sHiBand * (int16)key->usOverScale);
			if (key->OverGBMap.sHiBand > key->OverGBMap.rectBounds.top)
			{
				key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top; /* clip */
			}
		}
		if (key->GBMap.sLoBand == key->GBMap.rectBounds.bottom)         /* if gray band at bottom */
		{
			key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* use over bottom */
		}
		else
		{
			key->OverGBMap.sLoBand = (int16)(key->GBMap.sLoBand * (int16)key->usOverScale);
			if (key->OverGBMap.sLoBand < key->OverGBMap.rectBounds.bottom)
			{
				key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* clip */
			}
		}
		key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];
	}
#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		pGBMap = &key->OverGBMap;             /* draw into the overscaled structure */

	    key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];

        /* no banding yet !!! */
	    key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;
	    key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;
    }
#endif // FSCFG_SUBPIXEL

	key->WScan.pchHBuffer = pBitmapPtr2;
	key->WScan.pchVBuffer = pBitmapPtr3;

	error = fsc_FillGlyph(
		&CList,
		pGBMap,
		&key->WScan,
		key->usBandType,
		key->usScanType
		);
	if (error != NO_ERR)
	{
		return(error);
	}
	 
	if (key->bGrayScale)
	{
		error = fsc_CalcGrayMap(
			&key->OverGBMap, 
			&key->GBMap, 
			key->usOverScale
			);
		if (error != NO_ERR)
		{
			return((FS_ENTRY)error);
		}
	}

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
		outputPtr->overscaledBitmapInfo.baseAddr = key->OverGBMap.pchBitMap;
		outputPtr->overscaledBitmapInfo.rowBytes = key->OverGBMap.sRowBytes;
		outputPtr->overscaledBitmapInfo.bounds = key->OverGBMap.rectBounds; // save for more detailed processing
#endif
        fsc_OverscaleToSubPixel (&key->OverGBMap, (key->flSubPixel & FNT_SP_BGR_ORDER) > 0, &key->GBMap);
	}
#endif // FSCFG_SUBPIXEL

	if (key->bBitmapEmboldening)
	{
		if (key->bGrayScale)
		{
			uint16 usGrayLevels = key->usOverScale * key->usOverScale + 1;
			sbit_EmboldenGray(key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
						  (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes,usGrayLevels, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		} 
#ifdef FSCFG_SUBPIXEL
		else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
		{
			sbit_EmboldenSubPixel(key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
						  (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		} 
#endif // FSCFG_SUBPIXEL
		else 
		{
			sbit_Embolden(pGBMap->pchBitMap, (uint16)(pGBMap->rectBounds.right - pGBMap->rectBounds.left), 
						  (uint16)(pGBMap->sHiBand - pGBMap->sLoBand), pGBMap->sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		}
	}

/*  Setting the Band Type to FS_BANDINGFASTER will allow the next call      */
/*  to fsc_FillGlyph to skip the rendering phase of scan conversion and     */
/*  get right to the bitmap fill.  If the client moves either memoryBase[6] */ 
/*  or memoryBase[7] between fs_ContourScan calls, then we must reset the   */
/*  band type to FS_BANDINGFAST to regenerate the data structures.          */

	if (key->usBandType == FS_BANDINGFAST)
	{
		key->usBandType = FS_BANDINGFASTER;    /* to save re-rendering */
		key->apbPrevMemoryBases[BITMAP_PTR_2] = pBitmapPtr2;
		key->apbPrevMemoryBases[BITMAP_PTR_3] = pBitmapPtr3;
	}

	outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	}

	STAT_OFF_SCAN;                /* stop STAT timer */

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	FS_UNUSED_PARAMETER(inputPtr);
	FS_UNUSED_PARAMETER(outputPtr);
	return NO_ERR;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void FS_ENTRY_PROTO fs_InitializeData (void)
	{
		fsg_InitializeData ();
	}
#endif



/*********************************************************************/

/* fs_GetScaledAdvanceWidths returns only horizontal advance widths and is not meant to be used under rotation */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths)
{
	fs_SplineKey *      key;
	void *              pvGlobalGS;
	void *              pvStack;
	void *              pvFontProgram;
	void *              pvPreProgram;
	void *              pvTwilightZone;
	uint16              usCurrentGlyphIndex;
	uint16              usGlyphIndex;
	uint16              usPPEm;
	int16               sNonScaledLSB;
	vectorType          fxGlyphWidth;
	point               f26DevAdvanceWidth;
	boolean             bHdmxEntryExist;
	boolean             bBitmapFound;
	ErrorCode           error;
#ifdef FSCFG_SUBPIXEL	
	boolean             bSubPixelWidth = FALSE;
    fsg_TransformRec *  TransformInfoForGridFit;
	void *              pvGlobalGSSubPixel;
	void *              pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	/*  Initialization  */

	bHdmxEntryExist = FALSE;

#ifdef FSCFG_SUBPIXEL	
	if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL	

	/*  Save current glyph index    */

	usCurrentGlyphIndex = key->ClientInfo.usGlyphIndex;

	/*  Check input parameters  */

	if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
		(usLastGlyph < usFirstGlyph))
	{
		return INVALID_GLYPH_INDEX;
	}

	if( psGlyphWidths == NULL )
	{
		return NULL_INPUT_PTR_ERR;
	}

	/*  Find our current PPEm   */

	fsg_QueryPPEM(pvGlobalGS, &usPPEm);
	/* Only Grab 'hdmx' if not stretched or rotated */

#ifdef FSCFG_SUBPIXEL	
    /* for SubPixel, use Hdmx width only if we are in compatible width mode */
	if( !bSubPixelWidth &&
	    (!fsg_IsTransformStretched( &key->TransformInfo )) &&
		(!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
	if( (!fsg_IsTransformStretched( &key->TransformInfo )) &&
		(!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL	
	{

		/*  Check if we can quickly grab the widths from the 'hdmx' table   */

		error = sfac_CopyHdmxEntry(
			&key->ClientInfo,
			usPPEm,
			&bHdmxEntryExist,
			usFirstGlyph,
			usLastGlyph,
			psGlyphWidths);

		if (error != NO_ERR)
		{
			return(error);
		}

		/* If we got a hit on the 'hdmx' we are done    */

		if( bHdmxEntryExist )
		{
			return NO_ERR;
		}
	}

	/* No hit on 'hmdx', now it is time for the dirty work  */

	/* We need to prepare ourselves here for a potential grid fit */

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL
    TransformInfoForGridFit = &key->TransformInfo;
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
	    pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
    }
#endif // FSCFG_SUBPIXEL

    /*  potentially do delayed pre program execution */

	if (key->bExecutePrePgm)
	{
		/* Run the pre program and scale the control value table */

		key->bExecutePrePgm = FALSE;

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			NULL);

		if(error)
		{
			/* If the pre-program fails, prevent further glyphs from being called */
			fs_SetState(key, (INITIALIZED | NEWSFNT));

			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL	
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    NULL);

		    if(error)
		    {
			    /* If the pre-program fails, prevent further glyphs from being called */
			    fs_SetState(key, (INITIALIZED | NEWSFNT));

                /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
	    }
#endif // FSCFG_SUBPIXEL	
	}

	/*  Now check 'LTSH' table for linear cutoff information    */

	error = sfac_GetLTSHEntries(
		&key->ClientInfo,
		usPPEm,
		usFirstGlyph,
		usLastGlyph,
		psGlyphWidths);

	/* The pfxGlyphWidths array contains a boolean for each glyph (from     */
	/* first glyph to last glyph) that indicates if the glyph scales        */
	/* linearly.                                                            */

	/* Handle each glyph    */

	for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
	{
#ifdef FSCFG_SUBPIXEL
        /* for SubPixel, use linear width only if we are in compatible width mode */
		if( !bSubPixelWidth &&
            (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
			(!fsg_IsTransformStretched( &key->TransformInfo )) &&
			(!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
		if( (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
			(!fsg_IsTransformStretched( &key->TransformInfo )) &&
			(!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL	
		{
			/* Glyph Scales Linearly    */


		error = sfac_ReadGlyphHorMetrics (
				&key->ClientInfo,
				usGlyphIndex,
				&key->usNonScaledAW,
				&sNonScaledLSB);

			if(error)
			{
				return (FS_ENTRY)error;
			}

			fsg_UpdateAdvanceWidth (
				&key->TransformInfo,
				pvGlobalGS,
				key->usNonScaledAW,
				&fxGlyphWidth);

			psGlyphWidths[usGlyphIndex - usFirstGlyph] = (int16)((fxGlyphWidth.x + ONEHALFFIX) >> 16);
		}
		else    /* Glyph does not scale linearly */
		{
			error = LookForSbitAdvanceWidth (
				key, 
				usGlyphIndex, 
				&bBitmapFound, 
				&f26DevAdvanceWidth );          /* value returned if found */
			
			if(error)
			{
				return (FS_ENTRY)error;
			}

			if (bBitmapFound == FALSE)
			{
				/* Glyph needs to be grid fitted */

				key->ClientInfo.usGlyphIndex = usGlyphIndex;

				error = fsg_GridFit (
					&key->ClientInfo,
					&key->maxProfile,
					&key->TransformInfo,
					pvGlobalGS,
					&key->pWorkSpaceAddr,
					pvTwilightZone,
					(FntTraceFunc)NULL,
					TRUE,
					&key->usScanType,
					&key->bGlyphHasOutline,
					&key->usNonScaledAW,
					key->bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
					);

				if(error)
				{
					return (FS_ENTRY)error;
				}

				fsg_GetDevAdvanceWidth (
					&key->pWorkSpaceAddr,
					&f26DevAdvanceWidth );
#ifdef FSCFG_SUBPIXEL
                if (bSubPixelWidth)
                /* we need to scale the value downs from hinting overscale */
                {
                    ROUND_FROM_HINT_OVERSCALE(f26DevAdvanceWidth.x);
                }
#endif // FSCFG_SUBPIXEL
			}
			psGlyphWidths[(size_t)(usGlyphIndex - usFirstGlyph)] = (int16)((f26DevAdvanceWidth.x + DOT6ONEHALF) >> 6);
		}
	}

	/* Restore current glyph    */

	key->ClientInfo.usGlyphIndex = usCurrentGlyphIndex;
	
	return NO_ERR;
}

/*********************************************************************/

/*                  Vertical Metrics Helper Function                 */

/*            returns AdvanceHeight vectors for glyph range          */

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights)
{
	fs_SplineKey *      key;
	void *              pvGlobalGS;
	void *              pvFontProgram;
	void *              pvPreProgram;
	void *              pvStack;
	uint16              usGlyphIndex;
	uint16              usPPEm;
    uint16              usNonScaledAH;              /* advance height from vmtx */
	int16               sNonScaledTSB;              /* top side bearing from vmtx, not used */
	shortVector		    svDevAdvanceHeight;         /* advance height from sbits */
	vectorType			vecAdvanceHeight;
	vectorType			vecTopSideBearing;			/* not used */
	point               f26DevAdvanceHeight;
	boolean             bBitmapFound;
	ErrorCode           error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	/*  Check input parameters  */

	if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
		(usLastGlyph < usFirstGlyph))
	{
		return INVALID_GLYPH_INDEX;
	}

	if( psvAdvanceHeights == NULL )
	{
		return NULL_INPUT_PTR_ERR;
	}

	/*  Find our current PPEm   */

	fsg_QueryPPEM(pvGlobalGS, &usPPEm);

	/* Handle each glyph    */

	for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
	{
		error = LookForSbitAdvanceHeight (
				key, 
				usGlyphIndex, 
				&bBitmapFound, 
				&f26DevAdvanceHeight);           /* values returned if found */

		if(error)
		{
			return (FS_ENTRY)error;
		}

		if (bBitmapFound)                      /*   if bitmap metrics found */
		{
			svDevAdvanceHeight.x = (int16)((f26DevAdvanceHeight.x + DOT6ONEHALF) >> 6);
			svDevAdvanceHeight.y = (int16)((f26DevAdvanceHeight.y + DOT6ONEHALF) >> 6);
		}
		else        /* if (bBitmapFound == FALSE)   if no bitmap, read vmtx */
		{
			error = sfac_ReadGlyphVertMetrics (
				&key->ClientInfo,
				usGlyphIndex,
				&usNonScaledAH,
				&sNonScaledTSB);

			if(error)
			{
				return (FS_ENTRY)error;
			}

			fsg_ScaleVerticalMetrics (
				&key->TransformInfo,
				pvGlobalGS,
				usNonScaledAH,
				sNonScaledTSB,
				&vecAdvanceHeight,
				&vecTopSideBearing);

			svDevAdvanceHeight.x = (int16)((vecAdvanceHeight.x + ONEHALFFIX) >> 16);
			svDevAdvanceHeight.y = (int16)((vecAdvanceHeight.y + ONEHALFFIX) >> 16);
		}
    	
    	*psvAdvanceHeights++ = svDevAdvanceHeight;
	}

	return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance width */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(
	fs_SplineKey *key,
	uint16 usGlyphIndex, 
	boolean *pbBitmapFound, 
	point *pf26DevAdvanceWidth )
{
	uint16      usFoundCode;
	ErrorCode   error;
	uint16		usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	
	*pbBitmapFound = FALSE;                 /* default value */

	error = sbit_SearchForBitmap(
		&key->SbitMono,
		&key->ClientInfo,
		usGlyphIndex, 
		key->usOverScale,
		&usBitDepth,
		&usFoundCode );

	if (error)
	{
		return (FS_ENTRY)error;
	}

	if (usFoundCode != 0)
	{
		error = sbit_GetDevAdvanceWidth (
			&key->SbitMono,
			&key->ClientInfo,
			pf26DevAdvanceWidth );
		
		if (error)
		{
			return (FS_ENTRY)error;
		}
		*pbBitmapFound = TRUE;
	}
	return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance height */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(
	fs_SplineKey *key,
	uint16 usGlyphIndex, 
	boolean *pbBitmapFound, 
	point *pf26DevAdvanceHeight )
{
	uint16      usFoundCode;
	ErrorCode   error;
	uint16		usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	
	*pbBitmapFound = FALSE;                 /* default value */

	error = sbit_SearchForBitmap(
		&key->SbitMono,
		&key->ClientInfo,
		usGlyphIndex, 
		key->usOverScale,
		&usBitDepth,
		&usFoundCode );

	if (error)
	{
		return (FS_ENTRY)error;
	}

	if (usFoundCode != 0)
	{
		error = sbit_GetDevAdvanceHeight (
			&key->SbitMono,
			&key->ClientInfo,
        	pf26DevAdvanceHeight);
		
		if (error)
		{
			return (FS_ENTRY)error;
		}
		*pbBitmapFound = TRUE;
	}
	return NO_ERR;
}


/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*      returns glyph IDs for array or range of character codes      */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID)
{
	ErrorCode           error;
	fs_SplineKey *      key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_GetMultiGlyphIDs(
	    &key->ClientInfo, 
	    usCharCount, 
	    usFirstChar, 
	    pusCharCode, 
	    pusGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to Win95 - needs no font context, just a cmap pointer  */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID)
{
	ErrorCode           error;

	error = sfac_GetWin95GlyphIDs(
	    pbyCmapSubTable, 
	    usCharCount, 
	    usFirstChar, 
	    pusCharCode, 
	    pusGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to WinNT                                               */

/*********************************************************************/

/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID)
{
	ErrorCode           error;
	fs_SplineKey *      key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_GetWinNTGlyphIDs(
	    &key->ClientInfo, 
	    usCharCount, 
	    usFirstChar, 
		ulCharCodeOffset,
	    pulCharCode, 
	    pulGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}


/*********************************************************************/

/*                Outline Coordinates Helper Function                */

/* returns (x,y) coordinates of array of points on the glyph outline */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates)
{
	ErrorCode       error;
	ContourList     CList;        /* newscan contour list type */
	fs_SplineKey *  key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}
	if (key->ulState & SIZEKNOWN)               /* fail a call after FindBimapSize */
	{
		return OUT_OFF_SEQUENCE_CALL_ERR;
	}
    
    if (key->bGlyphHasOutline == FALSE)
    {
        return BAD_POINT_INDEX_ERR;             /* no meaning if no outlines */
    }

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		  fsg_UpdateWorkSpaceAddresses(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  fsg_UpdateWorkSpaceElement(
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	fsg_GetContourData(
		&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
		(boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
		&CList.afxXCoord,
		&CList.afxYCoord,
		&CList.asStartPoint,
		&CList.asEndPoint,
		&CList.abyOnCurve,
		&CList.abyFc,
		&CList.usContourCount);

	error = fsc_GetCoords(&CList, usPointCount, pusPointIndex, (PixCoord *)psvCoordinates);
	if (error != NO_ERR)
	{
		return(error);
	}

	return NO_ERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fshelper.h ===
/*
	 File:		 helper.h

	 Contains:	 Helper exports for Font Scaler

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1993. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		 <1>		 6/11/93	 GregH		Created.
*/

#ifndef FS_MATH_PROTO
#define FS_MATH_PROTO
#endif

int32 FS_MATH_PROTO ShortMulDiv(int32 a, int16 b, int16 c);	 /* (a*b)/c */

Fract FS_MATH_PROTO FracSqrt(Fract);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fsglue.c ===
/*++
	File:       FSglue.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):


				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <>     02/21/97    CB      ClaudeBe, scaled component in composite glyphs
		 <>     12/14/95    CB      add usNonScaledAH and sNonScaledTSB to  GlyphData
		 <7>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
													and one (always fractional) metrics. [rb]
		 <6>    11/16/90    MR      Add SnapShotOutline to make instructions after components work
													[rb]
		 <5>     11/9/90    MR      Unrename fsg_ReleaseProgramPtrs to RELEASESFNTFRAG. [rb]
		 <4>     11/5/90    MR      Change globalGS.ppemDot6 to globalGS.fpem, change all instrPtr
													and curve flags to uint8. [rb]
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Change matrix[2][2] back to a fract (in response to change in
													skia). However, ReduceMatrix converts it to a fixed after it has
													been used to "regularize" the matrix. Changed scaling routines
													for outline and CVT to use integer pixelsPerEm. Removed
													scaleFunc from the splineKey. Change some routines that were
													calling FracDiv and FixDiv to use LongMulDiv and ShortMulDiv for
													greater speed and precision. Removed fsg_InitScaling. [rb]
		<20>     8/22/90    MR      Only call fixmul when needed in finalComponentPass loop
		<19>      8/1/90    MR      Add line to set non90DegreeTransformation
		<18>     7/26/90    MR      remove references to metricInfo junk, don't include ToolUtils.h
		<17>     7/18/90    MR      Change error return type to int, split WorkSpace routine into
													two calls, added SWAPW macros
		<16>     7/14/90    MR      Fixed reference to const SQRT2 to FIXEDSQRT2
		<15>     7/13/90    MR      Ansi-C stuff, tried to use correct sizes for variables to avoid
									coercion (sp?)
		<12>     6/21/90    MR      Add calls to ReleaseSfntFrag
		<11>      6/4/90    MR      Remove MVT, change matrix to have bottom right element be a
									fixed.
		<10>      6/1/90    MR      Thou shalt not pay no more attention to the MVT!
		<8+>     5/29/90    MR      look for problem in Max45Trick
		 <8>     5/21/90    RB      bugfix in fsg_InitInterpreterTrans setting key->imageState
		 <7>      5/9/90    MR      Fix bug in MoreThanXYStretch
		 <6>      5/4/90    RB      support for new scan converter and decryption          mrr - add
									fsg_ReverseContours and key->reverseContour         to account
									for glyphs that are flipped.         This keeps the
									winding-number correct for         the scan converter.  Mike
									fixed fsg_Identity
		 <5>      5/3/90    RB      support for new scan converter and decryption  mrr - add
									fsg_ReverseContours and key->reverseContour to account for
									glyphs that are flipped. This keeps the winding-number correct
									for the scan converter.
		 <4>     4/10/90    CL      Fixed infinite loop counter - changed uint16 to int16 (Mikey).
		 <3>     3/20/90    CL      Added HasPerspective for finding fast case
									Removed #ifdef SLOW, OLD
									Changed NormalizeTransformation to use fpem (16.16) and to use max instead of length
									and to loop instead of recurse.
									Removed compensation for int ppem in fsg_InitInterpreterTrans (not needed with fpem)
									Greased loops in PreTransformGlyph, PostTransformGlyph, LocalPostTransformGlyph,
													 ShiftChar, ZeroOutTwilightZone, InitLocalT
									Changed GetPreMultipliers to special case unit vector * 2x2 matrix
									Added support for ppemDot6 and pointSizeDot6
									Changed fsg_MxMul to treat the perspective elements as Fracts
									arrays to pointers in ScaleChar
									Fixed bugs in loops in posttransformglyph, convert loops to --numPts >= 0
		 <2>     2/27/90    CL      It reconfigures itself during runtime !  New lsb and rsb
									calculation.  Shift bug in instructed components:  New error
									code for missing but needed table. (0x1409)  Optimization which
									has to do with shifting and copying ox/x and oy/y.  Fixed new
									format bug.  Changed transformed width calculation.  Fixed
									device metrics for transformed uninstructed sidebearing
									characters.  Dropoutcontrol scanconverter and SCANCTRL[]
									instruction.  Fixed transformed component bug.
									
	   <3.3>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. The old perspective bug has been fixed. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Changed
									sidebearing point calculations to use 16.16 precision. For zero
									or negative numbers in my tricky/fast square root computation it
									would go instable and loop forever. It was not able to handle
									large transformations correctly. This has been fixed and the
									normalization may call it self recursively to gain extra
									precision! It used to normalize an identity transformation
									unecessarily.
	   <3.2>     10/6/89    CEL     Phantom points were removed causing a rounding of last 2 points
									bug. Characters would become distorted.
	   <3.1>     9/27/89    CEL     Fixed transformation anchor point bug.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some
									enhanclocalpostements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/* rwb r/24/90 - Add support for scanControlIn and scanControlOut variables in global graphiscs
 * state
 */
/** System Includes **/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "interp.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "scale.h"

/*  CONSTANTS   */

/*  These constants are used for interpreting the scan control and scan type
	fields returned by the interpreter. They are documented in the TrueType
	specification under the SCANCTRL and SCANTYPE instructions.
 */

#define SCANINFO_SIZE_MASK   0x000000FF
#define SCANINFO_FLAGS_MASK  0x00003F00
#define SCANINFO_TYPE_MASK   0xFFFF0000
#define SCANINFO_SIZE_CLEAR  ~SCANINFO_SIZE_MASK
#define SCANINFO_FLAGS_CLEAR ~SCANINFO_FLAGS_MASK
#define SCANINFO_TYPE_CLEAR  ~SCANINFO_TYPE_MASK
#define SCANINFO_FLAGS_DONT  0x00003800
#define SCANINFO_FLAGS_DO    0x00000700
#define SCANCTRL_SIZE_MASK                   0x000000FF
#define SCANCTRL_DROPOUT_ALL_SIZES           0xFF
#define SCANCTRL_DROPOUT_IF_LESS             0x0100
#define SCANCTRL_DROPOUT_IF_ROTATED          0x0200
#define SCANCTRL_DROPOUT_IF_STRETCHED        0x0400
#define SCANCTRL_NODROP_UNLESS_LESS          0x0800
#define SCANCTRL_NODROP_UNLESS_ROTATED       0x1000
#define SCANCTRL_NODROP_UNLESS_STRETCH       0x2000
#define SCANTYPE_UNINITIALIZED               0xFFFF

/* fo the key->imageState field */
#define IMAGESTATE_ROTATED      0x0400
#define IMAGESTATE_STRETCHED    0x1000
#define IMAGESTATE_NON_POS_RECT 0x2000
#define IMAGESTATE_SIZE_MASK    0x00FF
#define IMAGESTATE_MAX_PPEM_SIZE 0x000000FF

#define COMPOSITE_ROOT                  0
#define MAX_TWILIGHT_CONTOURS       1
#define DEFAULT_COMPONENT_ELEMENTS  3UL
#define DEFAULT_COMPONENT_DEPTH     1UL
static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};

/*********** macros ************/

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define CHECK_GLYPHDATA(pglyphdata) FS_ASSERT((( (pglyphdata)->acIdent[0] == 'G') &&                            \
											( (pglyphdata)->acIdent[1] == 'D')),"Illegal GlyphData pointer");
#define MAX_COMPONENT_DEPTH(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentDepth, DEFAULT_COMPONENT_DEPTH)
#define MAX_COMPONENT_ELEMENTS(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentElements, DEFAULT_COMPONENT_ELEMENTS)

#define MAX_NESTED_GLYPHS(pMaxProfile) (uint32)((MAX_COMPONENT_DEPTH(pMaxProfile) + 1) + MAX_COMPONENT_ELEMENTS(pMaxProfile));

/**********************************************************************************/
/*  TYPEDEFS    */

typedef enum {
	glyphSimple,
	glyphIncompleteComposite,
	glyphComposite,
	glyphUndefined
} GlyphTypes;


/* Glyph Data   */

typedef struct GlyphData GlyphData;

struct GlyphData{
	char        acIdent[2];             /* Identifier for GlyphData                         */
	GlyphData * pSibling;               /* Pointer to siblings                              */
	GlyphData * pChild;                 /* Pointer to children                              */
	GlyphData * pParent;                /* Pointer to parent                                */
	sfac_GHandle hGlyph;                /* Handle for font access                           */
	GlyphTypes  GlyphType;              /* Type of glyph                                    */
	uint16      usGlyphIndex;           /* Glyph Index                                      */
	BBOX        bbox;                   /* Bounding box for glyph                           */
	uint16      usNonScaledAW;          /* Nonscaled Advance Width                          */
	uint16      usNonScaledAH;          /* Nonscaled Advance Height                         */
	int16       sNonScaledLSB;          /* Nonscaled Left Side Bearing                      */
	int16       sNonScaledTSB;          /* Nonscaled Top Side Bearing                       */
	uint16      usDepth;                /* Depth of Glyph in composite tree                 */
	sfac_ComponentTypes MultiplexingIndicator;/* Flag for arguments of composites                */
	boolean     bRoundXYToGrid;         /* Round composite offsets to grid                  */
	int16       sXOffset;               /* X offset for composite (if supplied)             */
	int16       sYOffset;               /* Y offset for composite (if supplied)             */
	uint16      usAnchorPoint1;         /* Anchor Point 1 for composites (if not offsets)   */
	uint16      usAnchorPoint2;         /* Anchor Point 2 for composites (if not offsets)   */
	transMatrix mulT;                   /* Transformation matrix for composite              */
	boolean     bUseChildMetrics;       /* Should use child metrics?                        */
	boolean     bUseMyMetrics;          /* Is glyph USE_MY_METRICS?                         */
	boolean     bScaleCompositeOffset; 	/* false by default, Apple scale the composite offset, MS doesn't */ 
	point       ptDevLSB;               /* Left Side Bearing Point                          */
	point       ptDevRSB;               /* Right Side Bearing Point                         */
	uint16      usScanType;             /* ScanType value for this glyph                    */
	uint16      usSizeOfInstructions;   /* Size (in bytes) of glyph instructions            */
	uint8 *     pbyInstructions;        /* Pointer to glyph instructions                    */
	fnt_ElementType * pGlyphElement;    /* Current glyph element pointer                    */

	/* the following variables were added to allow correct handling of scaled/rotated coposite glyphs */
	transMatrix currentTMatrix;         /* current Transf matrix, composite + user transform */
	boolean     bSameTransformAsMaster; /* same transformation as the master glyph, no composite scaling or rotation  */
};

/**********************************************************************************/

/* PRIVATE PROTOTYPES <4> */

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16      usMaxPoints,
	uint16      usMaxContours,
	fsg_OutlineFieldInfo * offsetPtr,
	uint32 *    pulOutlineSize,
	uint32 *    pulReusableMarker);

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter   */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW);    /* Return NonScaled Advance Width    */

FS_PRIVATE ErrorCode   fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max nested components */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,      /* True if glyph has outline         */
    uint32*             pCompositePoints,   /* total number of point for composites, to check for overflow */
    uint32*             pCompositeContours);/* total number of contours for composites, to check for overflow */

FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address        */
	GlyphData *         pGlyphData,         /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData);   /* Next GlyphData pointer   */

FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,             /* GlyphData pointer        */
	GlyphData *     pChildGlyphData);       /* Child GlyphData pointer  */

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution);

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData);            /* GlyphData pointer    */

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,             /* GlyphData pointer    */
	GlyphData *     pParentGlyphData);      /* GlyphData pointer    */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState);

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr);/* WorkSpace Address    */

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData **            ppGlyphData);   /* GlyphData pointer    */

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address    */
	GlyphData *         pGlyphData);        /* GlyphData pointer    */

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth);       /* Glyph depth          */

FS_PRIVATE void fsg_CheckFit(
	int32       lSize1,
	int32       lSize2,
	int32       lSize3,
	int32       lTotalSize,
	uint32 *    pfResult);

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    );

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement);

/* FSGlue Code  */

/* ..............MEMORY MANAGEMENT ROUTINES................ */


/*                                                              
 * fsg_PrivateFontSpaceSize : This data should remain intact for the life of the sfnt
 *              because function and instruction defs may be defined in the font program
 *              and/or the preprogram.
 */
/*

	 PRIVATE SPACE Memory Layout

typedef struct fsg_PrivateSpaceOffsets {
	 0  +===========+   ---------------------  <- PrivateSpaceOffsets.offset_storage;
		|           |
		|           |   TrueType Storage
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_functions;
		|           |
		|           |   TrueType Function Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_instrDefs;
		|           |
		|           |   TrueType Instruction Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_controlValues;
		|           |
		|           |   TrueType Scaled CVT
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_globalGS;
		| pStack    |
		| pStorage  |
		| pCVT      |
		| pFDEF     |   TrueType Global GS
		| pIDEF     |
		| pFPGM     |
		| pPPGM     |
		| pGlyphPgm |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_FontProgram;
		|           |
		|           |   TrueType Font Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_PreProgram;
		|           |
		|           |   TrueType Pre Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightZone;
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Twilight Element
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightOutline;
		|x[maxtzpts]|   Twilight Outline
		+-----------+
		|y[maxtzpts]|
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxtzct]|
		+-----------+
		|ox[maxtzpt]|
		+-----------+
		|oox[mxtzpt]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxtzpts]|
		+===========+   ---------------------

*/
FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	LocalMaxProfile *           pMaxProfile,      /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets)
{
	uint32  ulOutlineSize;
	uint32  ulReusableMarker;   /* Unused dummy variable */
    uint32  ulLastOffset;

	PrivateSpaceOffsets->offset_storage         = 0L;
	PrivateSpaceOffsets->offset_functions       = PrivateSpaceOffsets->offset_storage         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefs       = PrivateSpaceOffsets->offset_functions   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValues   = PrivateSpaceOffsets->offset_instrDefs   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGS        = PrivateSpaceOffsets->offset_controlValues + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGS);
#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_storageSubPixel         = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
	PrivateSpaceOffsets->offset_functionsSubPixel       = PrivateSpaceOffsets->offset_storageSubPixel         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefsSubPixel       = PrivateSpaceOffsets->offset_functionsSubPixel   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValuesSubPixel   = PrivateSpaceOffsets->offset_instrDefsSubPixel   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGSSubPixel        = PrivateSpaceOffsets->offset_controlValuesSubPixel + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGSSubPixel);
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGSSubPixel + (uint32)sizeof (fnt_GlobalGraphicStateType);
#else
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
#endif // FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_PreProgram      = PrivateSpaceOffsets->offset_FontProgram + (uint32)SFAC_LENGTH (ClientInfo, sfnt_fontProgram);

    PrivateSpaceOffsets->offset_TwilightZone    = PrivateSpaceOffsets->offset_PreProgram      + (uint32)SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZone);

#ifdef FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_TwilightZoneSubPixel    = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZoneSubPixel);
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZoneSubPixel + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
#else
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutline;
#endif // FSCFG_SUBPIXEL

/*
	Setup Twilight Zone outline space. This space contains all of the components
	to describe a Twilight Zone outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the field
	offsets e.g. x, ox, oox, &c.
*/
	/*** Outline -- TWILIGHT ZONE ***/

	fsg_GetOutlineSizeAndOffsets(
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS,
		&(PrivateSpaceOffsets->TwilightOutlineFieldOffsets),
		&ulOutlineSize,
		&ulReusableMarker);

#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_TwilightOutlineSubPixel = PrivateSpaceOffsets->offset_TwilightOutline + ulOutlineSize;
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutlineSubPixel);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL

#ifdef FSCFG_FONTOGRAPHER_BUG
/*
		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error */

	if ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_controlValues < 256 * (uint32)sizeof (F26Dot6))
	{
		ulOutlineSize = (256 * (uint32)sizeof (F26Dot6)) + PrivateSpaceOffsets->offset_controlValues - ulLastOffset;
	}
#endif // FSCFG_FONTOGRAPHER_BUG

	return ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_storage);
}


/*                          
 * fsg_WorkSpaceSetOffsets : This stuff changes with each glyph
 *
 * Computes the workspace size and sets the offsets into it.
 *
 */

/*

	WORKSPACE Memory Layout

	  0 +===========+    ---------------------  <- WorkSpaceOffsets.ulGlyphElementOffset
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 1
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 2
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|           |
		:           :          :
		|           |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element [MaxComponentDepth + 1]
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphOutlineOffset
		|x[maxpts]  |   Glyph Outline
		+-----------+
		|y[maxpts]  |
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxctrs]|
		+-----------+
		|ox[maxpts] |   <- WorkSpaceOffsets.ulReusableMemoryOffset


        !!! with SubPixel, we need to put the ulReusableMemoryOffset after ox because of the conversion done in GetContourData !!!
		+-----------+
		|oox[maxpts]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxpts]  |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataByteSetBaseOffset
		| T| F| T| F|
		+-----------+
		| F| F| F| F|
		+-----------+
		| F| F| F| F|   Glyph Data Allocation ByteSet
		+-----------+   (number of bytes = ulGlyphDataCount)
		| F| F| F| F|
		+-----------+
		| F| F| F| F|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataBaseOffset
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 1
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 2
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|           |
		:           :           :
		|           |
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData [ulGlyphDataCount]
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulStackOffset
		|           |
		|           |
		|           |   Stack
		|           |
		|           |
		|           |
		+===========+   ---------------------

*/

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	LocalMaxProfile *        pMaxProfile,    /* Max Profile Table    */
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace)
{
	uint32                       ulOutlineDataSize;
	uint32                       ulWorkSpacePos;
	uint32                       ulGlyphDataCount;
    uint16                       maxStackElements;

	ulWorkSpacePos = 0UL;

/*
	Setup the glyph element data array. This data structure contains all of the
	addresses into the glyph outline space. There are the same number of glyph
	element arrays as there are outline spaces; this allows us to handle the
	worstcase composite in the font.
*/
	WorkSpaceOffsets->ulGlyphElementOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof (fnt_ElementType) *
		  (uint32)(MAX_COMPONENT_DEPTH(pMaxProfile) + 1);

/*** Outline -- GLYPH *****/
/*
	Setup Glyph outline space. This space contains all of the components
	to describe a Glyph outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the elemental
	offsets e.g. x, ox, oox, &c.

	Once we have calculated the size of one outline space, we will duly note
	its size, and then add enough space to handle the outlines for the worst
	case composite depth in the font.
*/
	ALIGN(int16, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphOutlineOffset = ulWorkSpacePos; /* Remember start of Glyph Element */

	fsg_GetOutlineSizeAndOffsets(
		(uint16)(PHANTOMCOUNT + MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints)),
		(uint16)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours),
		&(WorkSpaceOffsets->GlyphOutlineFieldOffsets),
		&ulOutlineDataSize,
		(uint32 *)&(WorkSpaceOffsets->ulReusableMemoryOffset));

	/* Adjust Reusable memory marker to be based from zero, rather than GlyphOutline */

	WorkSpaceOffsets->ulReusableMemoryOffset += WorkSpaceOffsets->ulGlyphOutlineOffset;

	ulWorkSpacePos += ulOutlineDataSize;
/*
	Set the GlyphData ByteSet array. This array is used to track the memory used
	in GlyphData. Each entry in this array is a boolean.  One needs to also
	calculate the number of GlyphData's that will be needed to handle the
	worstcase composite in the font.
*/
	ALIGN(boolean, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataByteSetOffset = ulWorkSpacePos;
	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	ulWorkSpacePos += ulGlyphDataCount * (uint32)sizeof (boolean);
/*
	Set up the GlyphData array. This array contains the information needed
	to describe composites and components for a glyph.
*/
	ALIGN(voidPtr, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof(GlyphData) * ulGlyphDataCount;


	ALIGN(F26Dot6, ulWorkSpacePos);
	WorkSpaceOffsets->ulStackOffset = ulWorkSpacePos;

    maxStackElements = pMaxProfile->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
        maxStackElements = 1;
    }
#endif // FSCFG_EUDC_EDITOR_BUG

	ulWorkSpacePos += (uint32)maxStackElements * (uint32)sizeof (F26Dot6);

/* Calculate amount of extra memory */

	*plExtraWorkSpace = (int32)ulWorkSpacePos - (int32)WorkSpaceOffsets->ulReusableMemoryOffset;
	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

/* Return the total size of the WorkSpace memory.   */

	return(ulWorkSpacePos);

}

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16                  usMaxPoints,
	uint16                  usMaxContours,
	fsg_OutlineFieldInfo *  offsetPtr,
	uint32 *                pulOutlineSize,
	uint32 *                pulReusableMarker)

{
	uint32      ulArraySize;

	offsetPtr->onCurve = 0;

	*pulOutlineSize    = (uint32)usMaxPoints * (uint32)sizeof (uint8);
	ALIGN(int16, *pulOutlineSize);

	offsetPtr->sp   = *pulOutlineSize;
	ulArraySize = (uint32)usMaxContours * (uint32)sizeof (int16);
	*pulOutlineSize += ulArraySize;
	offsetPtr->ep   = *pulOutlineSize;
	*pulOutlineSize += ulArraySize;

	/* need to be before the reusable marker, now that this flag is exported */
	offsetPtr->fc       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxContours * (uint32)sizeof (uint8);

	ALIGN(F26Dot6, *pulOutlineSize);
	offsetPtr->x       = *pulOutlineSize;
	ulArraySize = (uint32)usMaxPoints * (uint32)sizeof (F26Dot6);
	*pulOutlineSize    += ulArraySize;
	offsetPtr->y       = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifndef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL
	/* Everything below this point can be reused during contour scanning */

	offsetPtr->ox      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifdef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL

    offsetPtr->oy      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

    offsetPtr->oox     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;
	offsetPtr->ooy     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

	offsetPtr->f       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (uint8);

    ALIGN(int32, *pulOutlineSize);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	offsetPtr->pcr      = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (PhaseControlRelation);
#endif

}


FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,     /* Cached sfnt information  */
	LocalMaxProfile *       pMaxProfile,     /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram)   /* pointer to pre program   */
{
	void *                       pvGlobalGS;
	void *                       pvCVT;          /* pointer to CVT  */
	void *                       pvStore;
	void *                       pvFuncDef;
	void *                       pvInstrDef;
	uint32                       ulLengthFontProgram, ulLengthPreProgram;

	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storage;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functions;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefs;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS;

	*pvFontProgram =  pPrivateFontSpace + PrivateSpaceOffsets->offset_FontProgram;
	ulLengthFontProgram = SFAC_LENGTH(ClientInfo, sfnt_fontProgram);
	*pvPreProgram =   pPrivateFontSpace + PrivateSpaceOffsets->offset_PreProgram;
	ulLengthPreProgram = SFAC_LENGTH(ClientInfo, sfnt_preProgram);

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);

#ifdef FSCFG_SUBPIXEL
    /* prepare the second pvGlobalGS for SubPixel compatible width */
	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValuesSubPixel;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storageSubPixel;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functionsSubPixel;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefsSubPixel;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel;

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);
#endif // FSCFG_SUBPIXEL

}

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	pWorkSpaceAddr->pStack = (F26Dot6 *)(WorkSpaceOffsets->ulStackOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphOutlineBase = WorkSpaceOffsets->ulGlyphOutlineOffset + pWorkSpace;
	pWorkSpaceAddr->pGlyphElement = (fnt_ElementType *)(WorkSpaceOffsets->ulGlyphElementOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphDataByteSet = (boolean *)(WorkSpaceOffsets->ulGlyphDataByteSetOffset + pWorkSpace);
	pWorkSpaceAddr->pvGlyphData = (void *)(WorkSpaceOffsets->ulGlyphDataOffset + pWorkSpace);
	pWorkSpaceAddr->pReusableMemoryMarker = WorkSpaceOffsets->ulReusableMemoryOffset + pWorkSpace;
}

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	char *                  pOutlineBase;
	fnt_ElementType *       pGlyphElement;        /* Address of Glyph Element array   */
	fsg_OutlineFieldInfo *  pOffset;

	pOutlineBase =  (char *)pWorkSpaceAddr->pGlyphOutlineBase;
	pGlyphElement = pWorkSpaceAddr->pGlyphElement;

	/* Note: only the first level glyph element has address updated. Second */
	/* levels are updated when referenced.                                           */

	pOffset             = & (WorkSpaceOffsets->GlyphOutlineFieldOffsets);

	pGlyphElement->x        = (F26Dot6 *) (pOutlineBase + pOffset->x);
	pGlyphElement->y        = (F26Dot6 *) (pOutlineBase + pOffset->y);
	pGlyphElement->ox       = (F26Dot6 *) (pOutlineBase + pOffset->ox);
	pGlyphElement->oy       = (F26Dot6 *) (pOutlineBase + pOffset->oy);
	pGlyphElement->oox      = (F26Dot6 *) (pOutlineBase + pOffset->oox);
	pGlyphElement->ooy      = (F26Dot6 *) (pOutlineBase + pOffset->ooy);
	pGlyphElement->sp       = (int16 *) (pOutlineBase + pOffset->sp);
	pGlyphElement->ep       = (int16 *) (pOutlineBase + pOffset->ep);
	pGlyphElement->onCurve  = (uint8 *) (pOutlineBase + pOffset->onCurve);
	pGlyphElement->f        = (uint8 *) (pOutlineBase + pOffset->f);

	pGlyphElement->fc       = (uint8 *) (pOutlineBase + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pGlyphElement->pcr      = (PhaseControlRelation *) (pOutlineBase + pOffset->pcr);
#endif
}

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS));
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel));
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutline;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZone);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

	pTwilightElement->fc        = (uint8 *) (pTemp + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif

	return (void *)pTwilightElement;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZoneSubPixel);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif
	return (void *)pTwilightElement;
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
    /* we don't allow the stack to be used to pass informations between pre-program and glyph program
       or between two glyph programs */
	return ((void *)pWorkSpaceAddr->pStack);
}

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets)
{
	return pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset;
}

FS_PUBLIC void  fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	uint32              ulMemoryOffset;

	ulMemoryOffset = WorkSpaceOffsets->ulReusableMemoryOffset;

	ulMemoryOffset += (uint32)lMGWorkSpace;  /* correct for MeasureGlyph Workspace */
	lExtraWorkSpace -= lMGWorkSpace;

	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

	/* Save original sizes */

	WorkSpaceOffsets->ulMemoryBase6Size = *plSizeBitmap1;
	WorkSpaceOffsets->ulMemoryBase7Size = *plSizeBitmap2;

	if( *plSizeBitmap1 > *plSizeBitmap2)
	{
		if( *plSizeBitmap1 <= lExtraWorkSpace )
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap1;

			if (( *plSizeBitmap2 <= lExtraWorkSpace - *plSizeBitmap1 ) &&
				( *plSizeBitmap2 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
				*plSizeBitmap2 = 0L;
			}
			*plSizeBitmap1 = 0L;
		}
		else if (( *plSizeBitmap2 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap2 > 0L))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			*plSizeBitmap2 = 0L;
		}

	}
	else  /* (plSizeBitmap1 <= *plSizeBitmap2) */
	{
		if(( *plSizeBitmap2 <= lExtraWorkSpace ) &&
		   ( *plSizeBitmap2 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap2;

			if (( *plSizeBitmap1 <= lExtraWorkSpace - *plSizeBitmap2 ) &&
				 ( *plSizeBitmap1 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
				*plSizeBitmap1 = 0L;
			}
			*plSizeBitmap2 = 0L;
		}
		else if (( *plSizeBitmap1 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap1 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			*plSizeBitmap1 = 0L;
		}
	}
}

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	 *plSizeBitmap1 = WorkSpaceOffsets->ulMemoryBase6Size;
	 *plSizeBitmap2 = WorkSpaceOffsets->ulMemoryBase7Size;
}

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7)
{
	if(WorkSpaceOffsets->ulMemoryBase6Offset != 0L)
	{
		*ppMemoryBase6 = WorkSpaceOffsets->ulMemoryBase6Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase6 = pClientBitmapPtr2;
	}

	if(WorkSpaceOffsets->ulMemoryBase7Offset != 0L)
	{
		  *ppMemoryBase7 = WorkSpaceOffsets->ulMemoryBase7Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase7 = pClientBitmapPtr3;
	}
}

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra)
{
	 *ppWorkSpaceExtra = (char *)(pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset);
}

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	scl_QueryPPEM(pvGlobalGS, pusPPEM);
}

/*  Return PPEM in both X and Y and 90 degree rotation factor for sbit matching */

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation)
{
	*pusRotation = mth_90degRotationFactor( &TransformInfo->currentTMatrix );
	scl_QueryPPEMXY(pvGlobalGS, pusPPEMX, pusPPEMY);
}


/*  FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **            pFc,
	uint16 *            pNc)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	*pX =       pElement->x;
	*pY =       pElement->y;
	*pSp =      pElement->sp;
	*pEp =      pElement->ep;
	*pOnCurve = pElement->onCurve;
	*pFc =     pElement->fc;
	*pNc      = (uint16)pElement->nc;
#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		/* we scale down the coordinate from x,y into ox, oy and return those */
		scl_ScaleDownFromSubPixelOverscale(pElement);
		*pX =       pElement->ox;
	}
#endif // FSCFG_SUBPIXEL
}

FS_PUBLIC uint32      fsg_GetContourDataSize(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	return( scl_GetContourDataSize( pElement ) );
}

FS_PUBLIC void  fsg_DumpContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	uint8 **            ppbyOutline)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_DumpContourData(pElement, ppbyOutline);
}

FS_PUBLIC void  fsg_RestoreContourData(
	uint8 **        ppbyOutline,
	F26Dot6 **      ppX,
	F26Dot6 **      ppY,
	int16 **        ppSp,
	int16 **        ppEp,
	uint8 **        ppOnCurve,
	uint8 **        ppFc,
	uint16 *        pNc)
{
	fnt_ElementType     pElement;

	scl_RestoreContourData(&pElement, ppbyOutline);

	*ppX =          pElement.x;
	*ppY =          pElement.y;
	*ppSp =         pElement.sp;
	*ppEp =         pElement.ep;
	*ppOnCurve =    pElement.onCurve;
	*ppFc =         pElement.fc;
	*pNc =          (uint16)pElement.nc;
}

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceWidth)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceWidth(pElement, pDevAdvanceWidth);
}

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceHeight)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceHeight(pElement, pDevAdvanceHeight);
}

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT)
{
	*ppScaledCVT = (F26Dot6 *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues);
}

FS_PUBLIC void  fsg_45DegreePhaseShift(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_45DegreePhaseShift(pElement);
}

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth)
{
	AdvanceWidth->y = 0;
	scl_ScaleAdvanceWidth(
		pvGlobalGS,
		AdvanceWidth,
		usNonScaledAW,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight)
{
	AdvanceHeight->x = 0;
	scl_ScaleAdvanceHeight(
		pvGlobalGS,
		AdvanceHeight,
		usNonScaledAH,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}


FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing )
{
	pvecAdvanceHeight->x = 0;           /* start with x values at zero */
	pvecTopSideBearing->x = 0;          /* since 'vmtx' refers to y values */

    scl_ScaleVerticalMetrics (
    	pvGlobalGS,
    	usNonScaledAH,
    	sNonScaledTSB,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix,
    	pvecAdvanceHeight,
    	pvecTopSideBearing);
}


FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceWidth,
	point *                 devLeftSideBearing,
	point *                 LeftSideBearing,
	point *                 devLeftSideBearingLine,
	point *                 LeftSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcLSBsAndAdvanceWidths(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceWidth,
		devLeftSideBearing,
		LeftSideBearing,
		devLeftSideBearingLine,
		LeftSideBearingLine);
}

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceHeight,
	point *                 devTopSideBearing,
	point *                 TopSideBearing,
	point *                 devTopSideBearingLine,
	point *                 TopSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcTSBsAndAdvanceHeights(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceHeight,
		devTopSideBearing,
		TopSideBearing,
		devTopSideBearingLine,
		TopSideBearingLine);
}

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_STRETCHED ) == IMAGESTATE_STRETCHED);
}

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_ROTATED ) == IMAGESTATE_ROTATED);
}

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16            usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16              usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *				psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *				psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	)
{
	ErrorCode       error;
	uint32          ulPixelsPerEm;
	transMatrix *   trans;

	trans = &TransformInfo->currentTMatrix;

	error = scl_InitializeScaling(
		pvGlobalGS,
		TransformInfo->bIntegerScaling,
		&TransformInfo->currentTMatrix,
		TransformInfo->usEmResolution,
		fxPointSize,
		sXResolution,
		sYResolution,
		usEmboldWeightx,       /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
		usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
		sWinDescender,
		lDescDev,
		psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
		psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
		bHintAtEmSquare,
		&ulPixelsPerEm);

	if(error)
	{
		return error;
	}

	TransformInfo->bPhaseShift = false;

	if ( ulPixelsPerEm > IMAGESTATE_MAX_PPEM_SIZE )
	{
		TransformInfo->ulImageState = (uint32)IMAGESTATE_MAX_PPEM_SIZE;
	}
	else
	{
		TransformInfo->ulImageState = ulPixelsPerEm;
	}

	TransformInfo->bPositiveSquare = mth_PositiveSquare( trans );

	if ( !(mth_PositiveRectangle( trans )))
	{
		TransformInfo->ulImageState |= IMAGESTATE_NON_POS_RECT;
	}

	if ( !(TransformInfo->bPositiveSquare) )
	{
		if( mth_GeneralRotation (trans))
		{
			TransformInfo->ulImageState |=  IMAGESTATE_ROTATED;
		}

		TransformInfo->ulImageState |= IMAGESTATE_STRETCHED;

		TransformInfo->bPhaseShift = mth_IsMatrixStretched(trans); /*<8>*/
	}

	TransformInfo->bEmboldSimulation = ((usEmboldWeightx != 0) || (usEmboldWeighty != 0)); 

	return NO_ERR;
}

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	scl_SetHintFlags(
		pvGlobalGS,
		bHintForGray
#ifdef FSCFG_SUBPIXEL
	    ,flHintForSubPixel
#endif // FSCFG_SUBPIXEL
        );
}
/*
 *  All this guy does is record FDEFs and IDEFs, anything else is ILLEGAL
 */
FS_PUBLIC ErrorCode fsg_RunFontProgram(
	void *                  pvGlobalGS,               /* GlobalGS     */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	void *                  pvTwilightElement,
	FntTraceFunc           traceFunc)
{
	return itrp_ExecuteFontPgm (
		(fnt_ElementType *)pvTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);
}

/*
 * fsg_RunPreProgram
 *
 * Runs the pre-program and scales the control value table
 *
 */
FS_PUBLIC ErrorCode fsg_RunPreProgram (
	sfac_ClientRec *    ClientInfo,
	LocalMaxProfile *   pMaxProfile,     /* Max Profile Table    */
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc)
{
	ErrorCode           result;
	F26Dot6 *           pfxCVT;
	fnt_ElementType *   pTwilightElement;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	result = itrp_SetDefaults (pvGlobalGS, TransformInfo->fxPixelDiameter);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_GetCVTPtr(pvGlobalGS, &pfxCVT);

	result = sfac_CopyCVT(ClientInfo, pfxCVT);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_ScaleCVT (pvGlobalGS, pfxCVT);

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	scl_ZeroOutlineData(
		pTwilightElement,
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = itrp_ExecutePrePgm (
		pTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);

	return result;
}

/*
 *      fsg_GridFit
 */
FS_PUBLIC ErrorCode fsg_GridFit (
	sfac_ClientRec *    ClientInfo,     /* sfnt Client information      */
	LocalMaxProfile *   pMaxProfile,    /* Max Profile Table            */
	fsg_TransformRec *  TransformInfo,  /* Transformation information   */
	void *              pvGlobalGS,     /* GlobalGS                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc,
	boolean             bUseHints,
	uint16 *            pusScanType,
	boolean *           pbGlyphHasOutline,
	uint16 *            pusNonScaledAW,
	boolean            bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	)
{
	ErrorCode           result;
	fnt_ElementType *   pTwilightElement;
	fnt_GlobalGraphicStateType *globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = fsg_CreateGlyphData (
		ClientInfo,
		pMaxProfile,
		TransformInfo,
		pvGlobalGS,
		pWorkSpaceAddr,
		pTwilightElement,
		traceFunc,
		bUseHints,
		pusScanType,
		pbGlyphHasOutline,
		pusNonScaledAW);

	if(result == NO_ERR)
	{
		if (TransformInfo->bEmboldSimulation)
			fsg_Embold( pWorkSpaceAddr, pvGlobalGS, bUseHints, bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );

		if ((TransformInfo->ulImageState & (IMAGESTATE_NON_POS_RECT)) || globalGS->bHintAtEmSquare)
		{
			scl_PostTransformGlyph (
				pvGlobalGS,
				pWorkSpaceAddr->pGlyphElement,
				&TransformInfo->currentTMatrix);
		}

		/* apply the translation part of the transformation matrix */
		scl_ApplyTranslation (
			pWorkSpaceAddr->pGlyphElement,
			&TransformInfo->currentTMatrix,
			bUseHints,
			globalGS->bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
	}
	return result;
}

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW)     /* Return NonScaled Advance Width    */
{
	GlyphData * pGlyphData;
	GlyphData * pNextGlyphData;
	boolean      bHasOutline;
	uint32       ulGlyphDataCount;
	ErrorCode   ReturnCode;
    uint32      CompositePoints = 0;
    uint32      CompositeContours = 0;

	*pbGlyphHasOutline = FALSE;
	bHasOutline = FALSE;

	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	fsg_InitializeGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr);
	ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pGlyphData); /* Allocates GlyphData for topmost   */
	if(ReturnCode != NO_ERR)
	{
		return ReturnCode;
	}
												 /* parent  */
	fsg_InitializeGlyphData(pGlyphData, pWorkSpaceAddr,
		ClientInfo->usGlyphIndex, COMPOSITE_ROOT);

	while(pGlyphData != NULL)
	{
		CHECK_GLYPHDATA( pGlyphData );

		ReturnCode = fsg_ExecuteGlyph(
			ClientInfo,
			pMaxProfile,
			TransformInfo,
			ulGlyphDataCount,
			pvGlobalGS,
			pGlyphData,
			pWorkSpaceAddr,
			pTwilightElement,
			traceFunc,
			bUseHints,
			&bHasOutline,
            &CompositePoints,
            &CompositeContours);
		if(ReturnCode)
		{
			return ReturnCode;
		}
		*pbGlyphHasOutline |= bHasOutline;
		*pusScanType = pGlyphData->usScanType;
		fsg_ChooseNextGlyph(pWorkSpaceAddr, pGlyphData, &pNextGlyphData);
		*pusNonScaledAW = pGlyphData->usNonScaledAW;
		pGlyphData = pNextGlyphData;
	}

	return NO_ERR;
}

FS_PRIVATE ErrorCode    fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max Number of nested glyphs */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                      */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,       /* True if glyph has outline         */
    uint32*                pCompositePoints,/* total number of point for composites, to check for overflow */
    uint32*                pCompositeContours)  /* total number of contours for composites, to check for overflow */
{
	ErrorCode       ReturnCode;
	boolean         bCompositeGlyph;
	boolean         bLastComponent;
	boolean         bWeHaveInstructions;
	boolean         bWeHaveCompositeInstructions;
	boolean         bScanInfoChanged;
	boolean 		bWeHaveAScale;
	uint16          usScanType;
	uint16          usScanControl;
	GlyphData *     pChildGlyphData;
	uint16          usComponentElementCount;
	uint16          contour;

	*pbHasOutline = FALSE;

	if (pGlyphData->GlyphType == glyphUndefined)
	{
		if(pGlyphData->pParent != NULL)
		{
			scl_IncrementChildElement(pGlyphData->pGlyphElement, pGlyphData->pParent->pGlyphElement);
		} else {
			pGlyphData->currentTMatrix = TransformInfo->currentTMatrix;
		}

		ReturnCode = sfac_ReadGlyphHeader(ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->hGlyph, &bCompositeGlyph, pbHasOutline,
			&pGlyphData->pGlyphElement->nc, &pGlyphData->bbox);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		/* Get advance width, advance height, left side bearing and top side bearing information  */

		ReturnCode = sfac_ReadGlyphMetrics(
			ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->usNonScaledAW, &pGlyphData->usNonScaledAH, 
			&pGlyphData->sNonScaledLSB, &pGlyphData->sNonScaledTSB);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (bCompositeGlyph)
		{
			pGlyphData->GlyphType = glyphIncompleteComposite;
		}
		else
		{
			pGlyphData->GlyphType = glyphSimple;
		}
	}

	if (pGlyphData->GlyphType == glyphSimple)
	{
		ReturnCode = sfac_ReadOutlineData(
			pGlyphData->pGlyphElement->onCurve,
			pGlyphData->pGlyphElement->ooy, pGlyphData->pGlyphElement->oox,
			&pGlyphData->hGlyph, pMaxProfile, *pbHasOutline, pGlyphData->pGlyphElement->nc,
			pGlyphData->pGlyphElement->sp, pGlyphData->pGlyphElement->ep,
			&pGlyphData->usSizeOfInstructions, &pGlyphData->pbyInstructions,
            pCompositePoints, pCompositeContours);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

            	fsg_CheckOutlineOrientation (pGlyphData->pGlyphElement);

        ReturnCode = fsg_SimpleInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
		{
			pGlyphData->usScanType = SK_NODROPOUT;
		}
		else
		{
			pGlyphData->usScanType = usScanType;
		}

		// here we update the contour orientation bit if necessary, to reflect the final orientation of the contours in the composite
		if (FixMul(pGlyphData->mulT.transform[0][0],pGlyphData->mulT.transform[1][1]) - FixMul(pGlyphData->mulT.transform[0][1],pGlyphData->mulT.transform[1][0]) < 0) {
			for (contour = 0; contour < pGlyphData->pGlyphElement->nc; contour++) {
				pGlyphData->pGlyphElement->fc[contour] ^= OUTLINE_MISORIENTED;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphComposite)
	{
		ReturnCode = fsg_CompositeInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (pGlyphData->bUseChildMetrics)
		{
			scl_SetSideBearingPoints(
				pGlyphData->pGlyphElement,
				&pGlyphData->ptDevLSB,
				&pGlyphData->ptDevRSB);
		}

		/* If composite has set SCANCTRL, use that value, otherwise merged children */

		if(bScanInfoChanged)
		{
			if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
			{
				pGlyphData->usScanType = SK_NODROPOUT;
			}
			else
			{
				pGlyphData->usScanType = usScanType;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphIncompleteComposite)
	{
		bLastComponent = FALSE;
		bWeHaveInstructions = FALSE;
		bWeHaveCompositeInstructions = FALSE;

		pGlyphData->GlyphType = glyphComposite;

		usComponentElementCount = 0;

		do
		{
			if(pGlyphData->usDepth + 1UL > MAX_COMPONENT_DEPTH(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			usComponentElementCount++;

			if(usComponentElementCount > MAX_COMPONENT_ELEMENTS(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pChildGlyphData);
			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			fsg_InitializeGlyphData(
				pChildGlyphData,
				pWorkSpaceAddr,
				NULL_GLYPH,
				(uint16)(pGlyphData->usDepth + 1U) );

			fsg_LinkChild(pGlyphData, pChildGlyphData);

			ReturnCode = sfac_ReadComponentData(
				&pGlyphData->hGlyph,
				&pChildGlyphData->MultiplexingIndicator,
				&pChildGlyphData->bRoundXYToGrid,
				&pChildGlyphData->bUseMyMetrics,
				&pChildGlyphData->bScaleCompositeOffset,
				&bWeHaveInstructions,
				&pChildGlyphData->usGlyphIndex,
				&pChildGlyphData->sXOffset,
				&pChildGlyphData->sYOffset,
				&pChildGlyphData->usAnchorPoint1,
				&pChildGlyphData->usAnchorPoint2,
				&pChildGlyphData->mulT,
				&bWeHaveAScale,
				&bLastComponent);

			if (bWeHaveAScale)
			{
				mth_MxConcat2x2( &pChildGlyphData->mulT, &pChildGlyphData->currentTMatrix );
				if (!mth_UnitarySquare(&pChildGlyphData->mulT))
				{
					pChildGlyphData->bSameTransformAsMaster	= FALSE; /* the component is scaled/rotated */
				}

			}

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			bWeHaveCompositeInstructions |= bWeHaveInstructions;
		}
		while (!bLastComponent);

		if(bWeHaveCompositeInstructions)
		{
			ReturnCode = sfac_ReadCompositeInstructions(
				&pGlyphData->hGlyph,
				&pGlyphData->pbyInstructions,
				&pGlyphData->usSizeOfInstructions);

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}
		}

	}
	return NO_ERR;
}


/*
 *      fsg_SimpleInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix			CurrentTMatrix,                  /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode           result;
/*
	On entry to fsg_SimpleInnerGrid fit the element structure should
	contain only valid original points (oox, ooy). The original points
	will be scaled into the old points (ox, oy) and those will be
	copied into the current points (x, y).
*/
	itrp_SetCompositeFlag(pvGlobalGS, FALSE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH);

	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
		}

		/* hint and same transformation as master glyph */
		scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldCharSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);
		scl_AdjustOldPhantomSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentCharPoints(pGlyphElement);
		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}

		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}
	}
	else 
		/* no hints */
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentCharPoints(pGlyphElement);
			scl_CopyCurrentPhantomPoints(pGlyphElement);
		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalCharPointsToCurrentFixedFUnits (pGlyphElement);
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);
		}
	}

	return NO_ERR;
}


/*
 *      fsg_CompositeInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode             result;
/*
	On entry to fsg_CompositeInnerGridFit, the current points (x, y)
	are the only valid points in the element. We copy the current points
	onto the old points (ox, oy)
*/
	itrp_SetCompositeFlag(pvGlobalGS, TRUE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	/* Note: The original composite character points are invalid at this point. */
	/*       The interpreter handles this case correctly for composites.        */

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH);
																  
	scl_CopyOldCharPoints(pGlyphElement);


	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
			scl_ScaleFixedCurrentCharPoints (pGlyphElement, pvGlobalGS);
		}

		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldSideBearingPoints(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}
		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}

	}
	else 
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentPhantomPoints(pGlyphElement);

		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);

		}
	}

	return NO_ERR;
}

FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address        */
	GlyphData *         pGlyphData,     /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData)/* Next GlyphData pointer   */
{
	if (pGlyphData->pChild != NULL)
	{
		*ppNextGlyphData = pGlyphData->pChild;
		CHECK_GLYPHDATA( *ppNextGlyphData );
		pGlyphData->pChild = NULL;
	}
	else
	{
		*ppNextGlyphData = pGlyphData->pSibling;
		fsg_DeallocateGlyphDataMemory(pWorkSpaceAddr, pGlyphData);
	}
}

#ifdef FSCFG_SUBPIXEL
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM);
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM) {
	if (CTM->transform[0][1] == 0 && CTM->transform[1][0] == 0) return 0; // Identity, 180 rotation, mirroring in x or y
	if (CTM->transform[0][0] == 0 && CTM->transform[1][1] == 0) return 1; // 90 rotation, 270 rotation, or any combination of these rotation with a mirroring in x or y
	return 2; // assume arbitrary rotation
} // fsg_AnalyzeCurrentTransformationMatrix
#endif

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution)
{
	fnt_ElementType * pChildElement;
	fnt_ElementType * pParentElement;
	F26Dot6         fxXOffset, fxYOffset;
	GlyphData *     pParentGlyphData; /* Parent GlyphData pointer   */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity;
#endif

	CHECK_GLYPHDATA(pChildGlyphData);
	pParentGlyphData = pChildGlyphData->pParent;
	CHECK_GLYPHDATA(pParentGlyphData);

	pChildElement = pChildGlyphData->pGlyphElement;
	pParentElement = pParentGlyphData->pGlyphElement;

	fsg_TransformChild(pChildGlyphData);

	if (!pChildGlyphData->bSameTransformAsMaster && pChildGlyphData->pParent->bSameTransformAsMaster)
	{
		/* coordinates need to be converted from fixed FUnits to user space */
		/* scaling the cordinate of the child glyph from fixed FUnits to user space,
		   scaling from original coordinate x/y to original coordinate x/y 
		   this is done to have the child and parent glyph at the same coordinate space */

		/* use the master transform */
		itrp_SetSameTransformFlag(pvGlobalGS, TRUE);

		scl_ScaleFixedCurrentCharPoints(pChildElement, pvGlobalGS);
		scl_ScaleFixedCurrentPhantomPoints(pChildElement, pvGlobalGS);

		pChildGlyphData->bSameTransformAsMaster = TRUE;
	}
	
#ifdef FSCFG_SUBPIXEL
	rotationParity = fsg_AnalyzeCurrentTransformationMatrix(&pParentGlyphData->currentTMatrix);
#endif

	if (pChildGlyphData->MultiplexingIndicator == OffsetPoints)
	{
		if (!pChildGlyphData->pParent->bSameTransformAsMaster)
		{
			/* we have both the parent and the child that are not at the same transformation as the master glyph
			   we need to use the scaling of the parent as a child scaling to scale the offset */
			scl_InitializeChildScaling(
				pvGlobalGS,
				pChildGlyphData->pParent->currentTMatrix,
				usEmResolution);
		}

		scl_CalcComponentOffset(
			pvGlobalGS,
			pChildGlyphData->sXOffset,
			pChildGlyphData->sYOffset,
			pChildGlyphData->bRoundXYToGrid,
			pChildGlyphData->bSameTransformAsMaster,
			pChildGlyphData->bScaleCompositeOffset,
			pChildGlyphData->mulT,
#ifdef FSCFG_SUBPIXEL
			rotationParity,
#endif
			&fxXOffset,
			&fxYOffset);
	}
	else        /* Values are anchor points */
	{
		FS_ASSERT(pChildGlyphData->MultiplexingIndicator == AnchorPoints,
			   "Bad Multiplexing Indicator");
		scl_CalcComponentAnchorOffset(
			pParentElement,
			pChildGlyphData->usAnchorPoint1,
			pChildElement,
			pChildGlyphData->usAnchorPoint2,
			&fxXOffset,
			&fxYOffset);
	}
	scl_ShiftCurrentCharPoints(pChildElement, fxXOffset, fxYOffset);


	/* If USE_MY_METRICS, copy side bearings to parent  */

	if (pChildGlyphData->bUseMyMetrics)
	{
		pParentGlyphData->bUseChildMetrics = TRUE;

		scl_SaveSideBearingPoints(
			pChildElement,
			&pParentGlyphData->ptDevLSB,
			&pParentGlyphData->ptDevRSB);
	}

	fsg_MergeScanType(pChildGlyphData, pParentGlyphData);

	/* Start the copy   */

	/* scl_AppendOutlineData(pChildElement, pParentElement); */

	scl_UpdateParentElement(pChildElement, pParentElement);

	pChildElement->nc = 0;
}



FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,     /* GlyphData pointer        */
	GlyphData *     pChildGlyphData)/* Child GlyphData pointer  */
{
	GlyphData * pTempGlyphData;

	if (pGlyphData->pChild == NULL)
	{
		pGlyphData->pChild = pChildGlyphData;
	}
	else
	{

		pTempGlyphData = pGlyphData->pChild;

		CHECK_GLYPHDATA(pTempGlyphData);

		while (pTempGlyphData->pSibling != pGlyphData)
		{
			pTempGlyphData = pTempGlyphData->pSibling;
			CHECK_GLYPHDATA(pTempGlyphData);
		}

		pTempGlyphData->pSibling = pChildGlyphData;
	}
	pChildGlyphData->pSibling = pGlyphData;
	pChildGlyphData->pParent =  pGlyphData;

	/* copy the transformation info from the parent */
	pChildGlyphData->currentTMatrix = pGlyphData->currentTMatrix;
	pChildGlyphData->bSameTransformAsMaster = pGlyphData->bSameTransformAsMaster;
}

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData)     /* GlyphData pointer    */
{

	/* Apply local transform to glyph   */

	if (!mth_Identity(&pGlyphData->mulT))
	{
		scl_LocalPostTransformGlyph (pGlyphData->pGlyphElement, &pGlyphData->mulT);
	}
}

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,       /* GlyphData pointer  */
	GlyphData *     pParentGlyphData) /* GlyphData pointer  */
{
	CHECK_GLYPHDATA(pGlyphData);
	CHECK_GLYPHDATA(pParentGlyphData);

	/* Merge Scan Type of parent and child  */

	if(pParentGlyphData->usScanType != SCANTYPE_UNINITIALIZED)
	{

		pParentGlyphData->usScanType =
			(uint16)(((pParentGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS)) &
			(pGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS))) |
			(pParentGlyphData->usScanType & SK_SMART));
	}
	else
	{
		pParentGlyphData->usScanType = pGlyphData->usScanType;
	}
}

/* Use various spline key values to determine if dropout control is to be activated
 * for this glyph, and if so what kind of dropout control.
 * The use of dropout control mode in the scan converter is controlled by 3 conditions.
 * The conditions are: Is the glyph rotated?, is the glyph stretched?,
 * is the current pixels per Em less than a specified threshold?
 * These conditions can be OR'd or ANDed together to determine whether the dropout control
 * mode ought to be used.

Six bits are used to specify the joint condition.  Their meanings are:

BIT     Meaning if set
8       Do dropout mode if other conditions don't block it AND
			pixels per em is less than or equal to bits 0-7
9       Do dropout mode if other conditions don't block it AND
			glyph is rotated
10      Do dropout mode if other conditions don't block it AND
			glyph is stretched
11      Do not do dropout mode unless ppem is less than or equal to bits 0-7
			A value of FF in 0-7  means all sizes
			A value of 0 in 0-7 means no sizes
12      Do not do dropout mode unless glyph is rotated
13      Do not do dropout mode unless glyph is stretched

In other words, we do not do dropout control if:
No bits are set,
Bit 8 is set, but ppem is greater than threshold
Bit 9 is set, but glyph is not rotated
Bit 10 is set, but glyph is not stretched
None of the conditions specified by bits 11-13 are true.

For example, 0xA10 specifies turn dropout control on if the glyph is rotated providing
that it is also less than 0x10 pixels per em.  A glyph is considered stretched if
the X and Y resolutions are different either because of the device characteristics
or because of the transformation matrix.  If both X and Y are changed by the same factor
the glyph is not considered stretched.

 */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState)
{
	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) <= (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((usScanControl & SCANCTRL_SIZE_MASK) == SCANCTRL_DROPOUT_ALL_SIZES))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_ROTATED) &&
		(ulImageState & IMAGESTATE_ROTATED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_STRETCHED) &&
		(ulImageState & IMAGESTATE_STRETCHED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) > (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_ROTATED) &&
		! (ulImageState & IMAGESTATE_ROTATED))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_STRETCH) &&
		! (ulImageState & IMAGESTATE_STRETCHED))
	{
		return FALSE;
	}

	return FALSE;
}

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr) /* WorkSpace Address      */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	for(ulIndex = 0; ulIndex < ulGlyphDataCount; ulIndex++)
	{
		abyGlyphDataFreeBlocks[ulIndex] = TRUE;
	}
}

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address      */
	GlyphData **        ppGlyphData)      /* GlyphData pointer    */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ulIndex = 0;
	while((!abyGlyphDataFreeBlocks[ulIndex]) && ulIndex < ulGlyphDataCount)
	{
		ulIndex++;
	}

	if (ulIndex == ulGlyphDataCount)
	{
		return SFNT_RECURSIVE_COMPOSITE_ERR;
	}

	abyGlyphDataFreeBlocks[ulIndex] = FALSE;

	*ppGlyphData = (GlyphData *)&((GlyphData *)pWorkSpaceAddr->pvGlyphData)[ulIndex];
	return NO_ERR;
}

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData *         pGlyphData)     /* GlyphData pointer    */
{
	ptrdiff_t   ptIndex;
	boolean *   abyGlyphDataFreeBlocks;

	pGlyphData->acIdent[0] = '\0';
	pGlyphData->acIdent[1] = '\0';

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ptIndex = (ptrdiff_t)(pGlyphData - (GlyphData *)pWorkSpaceAddr->pvGlyphData);

	abyGlyphDataFreeBlocks[ptIndex] = TRUE;
}

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth)        /* Glyph depth          */
{
	pGlyphData->acIdent[0] = 'G';
	pGlyphData->acIdent[1] = 'D';
	pGlyphData->pSibling = NULL;
	pGlyphData->pChild = NULL;
	pGlyphData->pParent = NULL;
	pGlyphData->GlyphType = glyphUndefined;
	pGlyphData->hGlyph.pvGlyphBaseAddress = NULL;
	pGlyphData->hGlyph.pvGlyphNextAddress = NULL;
	pGlyphData->usDepth = usDepth;
	pGlyphData->bUseMyMetrics = FALSE;
	pGlyphData->bScaleCompositeOffset = FALSE;
	pGlyphData->bUseChildMetrics = FALSE;
	pGlyphData->bbox.xMin = SHRT_MAX;
	pGlyphData->bbox.yMin = SHRT_MAX;
	pGlyphData->bbox.xMax = SHRT_MIN;
	pGlyphData->bbox.yMax = SHRT_MIN;
	pGlyphData->usSizeOfInstructions = 0;
	pGlyphData->pbyInstructions = NULL;
	pGlyphData->usNonScaledAW = 0;
	pGlyphData->sNonScaledLSB = 0;
	pGlyphData->MultiplexingIndicator = Undefined;
	pGlyphData->bRoundXYToGrid = FALSE;
	pGlyphData->usGlyphIndex = usGlyphIndex;
	pGlyphData->sXOffset = 0;
	pGlyphData->sYOffset = 0;
	pGlyphData->usAnchorPoint1 = 0;
	pGlyphData->usAnchorPoint2 = 0;
	pGlyphData->mulT = IdentTransform;
	pGlyphData->usScanType = SCANTYPE_UNINITIALIZED;
	pGlyphData->ptDevLSB.x = 0L;
	pGlyphData->ptDevLSB.y = 0L;
	pGlyphData->ptDevRSB.x = 0L;
	pGlyphData->ptDevRSB.y = 0L;
	pGlyphData->pGlyphElement = &pWorkSpaceAddr->pGlyphElement[usDepth];
	pGlyphData->pGlyphElement->nc = 0;
	pGlyphData->currentTMatrix = IdentTransform;
	pGlyphData->bSameTransformAsMaster = TRUE;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void)
{
	itrp_InitializeData ();
}
#endif

/* definitions and prototype for functions used in emboldening */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

#define LEFTSIDEBEARING 0
#define RIGHTSIDEBEARING 1

#define TOPSIDEBEARING 2
#define BOTTOMSIDEBEARING 3

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define POSINFINITY               0x7FFFFFFFUL

#define NotSameKnot(a,b) ((a).x != (b).x || (a).y != (b).y)

/* used by QDiv2 and FQuadraticEqn */
#define places16 16
#define half16 (1 << (places16-1))

#define F32Dot32 int64

#ifndef	Sgn
	#define Sgn(a)		((a) < 0 ? -1 : ((a) > 0 ? 1 : 0))
#endif

typedef struct F26Dot6VECTOR {
	F26Dot6 x;
	F26Dot6 y;
} F26Dot6VECTOR;

typedef struct { long x,y; } Vector;

typedef enum { linkBlack, linkGrey, linkWhite } LinkColor;

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY);

int64 QDiv2(int64 a, int64 b);

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2);

F32Dot32 FSqrt(uint64 radicand);

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2);

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1);

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1);

void MinMax2Vectors (Vector A,Vector B,Vector *Min, Vector *Max);

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max);

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber);

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1,int16 extremumNumber);

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect);

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt);

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented, 
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement); 
 
boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement);

/* emboldening related code */

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect)
{
	VECTOR Vec;

	itrp_Normalize (pVect->x, pVect->y, &Vec);

	/* transform from ShortFract to 26.6 */
	pVect->x = Vec.x >> 8;
	pVect->y = Vec.y >> 8;	
}

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt)
{
	/* this procedure was inspired by itrp_ISECT */
	F26Dot6 N, D;
	F26Dot6VECTOR B, A;
	F26Dot6VECTOR dB, dA;

	  dA.x = Pt2.x - (A.x = Pt1.x);
	  dA.y = Pt2.y - (A.y = Pt1.y);

	  dB.x = Pt4.x - (B.x = Pt3.x);
	  dB.y = Pt4.y - (B.y = Pt3.y);

	  if (dA.y == 0) 
	  {
		if (dB.x == 0) 
		{
		  ResultPt->x = B.x;
		  ResultPt->y = A.y;
		  return;
		}
		N = B.y - A.y;
		D = -dB.y;
	  } 
	  else if (dA.x == 0) 
	  {
		if (dB.y == 0) 
		{
		  ResultPt->x = A.x;
		  ResultPt->y = B.y;
		  return;
		}
		N = B.x - A.x;
		D = -dB.x;
	  } 
	  else if (MABS (dA.x) >= MABS (dA.y))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (B.y - A.y) - MulDiv26Dot6 (B.x - A.x, dA.y, dA.x);
		D = MulDiv26Dot6 (dB.x, dA.y, dA.x) - dB.y;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (B.y - A.y, dA.x, dA.y) - (B.x - A.x);
		D = dB.x - MulDiv26Dot6 (dB.y, dA.x, dA.y);
	  }

	  if (MABS(D) > 16) /* this test used to be D != 0 but for very small D we get degenerescence */
	  {
		ResultPt->x = B.x + (F26Dot6) MulDiv26Dot6 (dB.x, N, D);
		ResultPt->y = B.y + (F26Dot6) MulDiv26Dot6 (dB.y, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, what make sence in this special case is to take the
		  middle point between Pt2 and Pt3 */
		ResultPt->x = (Pt2.x + Pt3.x) >> 1;
		ResultPt->y = (Pt2.y + Pt3.y) >> 1;
	  }

	
}

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented,
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement) 


{
	F26Dot6VECTOR dPrev, dNext, Shift, CurrPt1,  NewPt, Delta ;
	F26Dot6 fxTemp;
    int32 i;

	dPrev.x = CurrPt.x - PrevPt.x;
	dPrev.y = CurrPt.y - PrevPt.y;

	dNext.x = NextPt.x - CurrPt.x;
	dNext.y = NextPt.y - CurrPt.y;

	/* compute the orthogonal vectors */

	fxTemp = dPrev.x;
	dPrev.x = -dPrev.y;
	dPrev.y = fxTemp;

	fxTemp = dNext.x;
	dNext.x = -dNext.y;
	dNext.y = fxTemp;

    if (bMisoriented)
    {
	    dPrev.x = -dPrev.x;
	    dPrev.y = -dPrev.y;
	    dNext.x = -dNext.x;
	    dNext.y = -dNext.y;
    }

    /* copy of the current point */

	CurrPt1 = CurrPt;

    if (bUnderTheThreshold)
    {
        /* most common case, we are just moving control points one pixel horizontally */

 	    if (dPrev.x > 0)
	    {
            CurrPt1.x += fxRightShift;
	    }
	    if (dNext.x > 0)
	    {
            CurrPt.x += fxRightShift;
	    }
    } else 
    {
        /* generalization, move along the vector normal to the curve */

	    /* normalize the vectors */
	    NormalizeVector26Dot6 (&dPrev);
	    NormalizeVector26Dot6 (&dNext);


        /* apply the shift on the previous segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dPrev.x > 0)
	    {
		    Shift.x = Mul26Dot6(dPrev.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dPrev.x, fxLeftShift);
	    }

	    if (dPrev.y < 0)
	    {
		    Shift.y = Mul26Dot6(dPrev.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dPrev.y, fxTopShift);
	    }

	    PrevPt.x += Shift.x;
	    PrevPt.y += Shift.y;

	    CurrPt1.x += Shift.x;
	    CurrPt1.y += Shift.y;

	    /* second segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dNext.x > 0)
	    {
		    Shift.x = Mul26Dot6(dNext.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dNext.x, fxLeftShift);
	    }

	    if (dNext.y < 0)
	    {
		    Shift.y = Mul26Dot6(dNext.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dNext.y, fxTopShift);
	    }

	    NextPt.x += Shift.x;
	    NextPt.y += Shift.y;

	    CurrPt.x += Shift.x;
	    CurrPt.y += Shift.y;
    }

	if (CurrPt1.x == CurrPt.x && CurrPt1.y == CurrPt.y)
	{
		/* both points were moved by the same value, no need to intersect */
		pElement->x[iPt] = CurrPt.x;
		pElement->y[iPt] = CurrPt.y;
	} else
	{
	/* we need to reintersect */
		Intersect26Dot6(PrevPt, CurrPt1, CurrPt, NextPt, &NewPt);

		/* sanity check that we are not moving the point too far from it's original position,
			this happen at low ppem size when segment lenght get small compared to the shift 
			or when hinting caused outline overlapp */
		Delta.x = NewPt.x - pElement->x[iPt];
		Delta.y = NewPt.y - pElement->y[iPt];

		if (Delta.x > fxRightShift)
		{
			NewPt.x = pElement->x[iPt] + fxRightShift;
		}
		if (Delta.x < -fxLeftShift)
		{
			NewPt.x = pElement->x[iPt] - fxLeftShift;
		}
		if (Delta.y < -fxBottomShift)
		{
			NewPt.y = pElement->y[iPt] - fxBottomShift;
		} 
		if (Delta.y > fxTopShift)
		{
			NewPt.y = pElement->y[iPt] + fxBottomShift;
		} 

		pElement->x[iPt] = NewPt.x;
		pElement->y[iPt] = NewPt.y;

	}
	/* shift all points by fxLeftShift, fxTopShift */
	pElement->x[iPt] += fxLeftShift;
	pElement->y[iPt] += fxBottomShift;

	if (pElement->y[iPt] < fxScaledDescender)
	{
		/* clipping to prevent going below the descender and causing out of bounds problems */
		pElement->y[iPt] = fxScaledDescender;
	}

    if (iPt != iPt1)
    {
        /* duplicate points at the same coordinate, we need to move them all */
	    for(i= iPt + 1; i <= iPt1; i++)
        {
	        pElement->x[i] = pElement->x[iPt];
	        pElement->y[i] = pElement->y[iPt];
        }
    }

}

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	fnt_ElementType *pElement;
	fnt_GlobalGraphicStateType *globalGS;
	int32 iContour, iPt, iPt1, iStartPt, iEndPt;
	F26Dot6VECTOR FirstPt, PrevPt, NextPt, CurrPt;
	F26Dot6 fxRightShift, fxLeftShift; 
	F26Dot6 fxTopShift, fxBottomShift; 
    boolean bUnderTheThreshold;
    boolean bMisoriented;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pElement = pWorkSpaceAddr->pGlyphElement;

    bUnderTheThreshold = (globalGS->uBoldSimulHorShift == 1);

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
    {
        bUnderTheThreshold = (globalGS->uBoldSimulHorShift <= HINTING_HOR_OVERSCALE);
    }
#endif // FSCFG_SUBPIXEL

	/* adjust the right sidebearing */
    if (pElement->x[RSBPOINTNUM(pElement)] != pElement->x[LSBPOINTNUM(pElement)]) 
        /* we don't increase the width of a zero width glyph, problem with indic script */
	    pElement->x[RSBPOINTNUM(pElement)] += (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */

	/* adjust the bottom sidebearing, this is done by the value of the HorShift and not the VertShift for backwards compatibility
	   in vertical writing */
    if (pElement->y[BOTTOMSBPOINTNUM(pElement)] != pElement->y[TOPSBPOINTNUM(pElement)])
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
#ifdef FSCFG_SUBPIXEL
	    if (bSubPixel)
        {
    	    pElement->y[BOTTOMSBPOINTNUM(pElement)] -= ( ( 1 / HINTING_HOR_OVERSCALE) << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        } else {
#endif // FSCFG_SUBPIXEL
    	    pElement->y[BOTTOMSBPOINTNUM(pElement)] -= (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
#ifdef FSCFG_SUBPIXEL
        }
#endif // FSCFG_SUBPIXEL
    }

	if (!bBitmapEmboldening)
	{    

		if (bUseHints)
		{
			/* to preserve the hinting, we should move by an integer amount of pixel */
			/* divide by 2, round to pixel, convert to 26.6 */
#ifdef FSCFG_SUBPIXEL
	        if (bSubPixel)
            {
			    fxLeftShift = ((globalGS->uBoldSimulHorShift /HINTING_HOR_OVERSCALE) >> 1) * HINTING_HOR_OVERSCALE; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
            } else {
#endif // FSCFG_SUBPIXEL
			    fxLeftShift = globalGS->uBoldSimulHorShift >> 1; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
#ifdef FSCFG_SUBPIXEL
            }
#endif // FSCFG_SUBPIXEL
			fxTopShift = globalGS->uBoldSimulVertShift >> 1;
			fxBottomShift = (globalGS->uBoldSimulVertShift - fxTopShift) << 6;
			fxTopShift = fxTopShift << 6;
		} else {
			/* divide by 2, convert to 26.6 */
			fxRightShift = globalGS->uBoldSimulHorShift << 5;
			fxLeftShift = globalGS->uBoldSimulHorShift << 5; 
			fxTopShift = globalGS->uBoldSimulVertShift << 5;
			fxBottomShift = globalGS->uBoldSimulVertShift << 5;
		}

		for (iContour = 0; iContour < pElement->nc; iContour++)
		{
			iStartPt = pElement->sp[iContour];
			iEndPt = pElement->ep[iContour];

			if (iEndPt - iStartPt >= 2)
			/* contour with less than 3 points cannot be emboldened */
			{
                bMisoriented = FALSE;
                if (pElement->fc[iContour] & OUTLINE_MISORIENTED)
                {
                    bMisoriented = TRUE;
                }
				/* we need to save the original coordinate of the first point for the computation of the last point */
				/* to compute the new coordinate for a point, we need the original coordinate of the point, the previous point
				  and the next point */

				FirstPt.x = pElement->x[iStartPt];
				FirstPt.y = pElement->y[iStartPt];

				CurrPt = FirstPt;

				PrevPt.x = pElement->x[iEndPt];
				PrevPt.y = pElement->y[iEndPt];

				NextPt.x = pElement->x[iStartPt+1];
				NextPt.y = pElement->y[iStartPt+1];

				iPt = iStartPt;

				while (iPt <= iEndPt)
				{
					iPt1 = iPt;

					/* deal with the special case of two points at the same coordinate, current and next */
					while ((NextPt.x == CurrPt.x) && (NextPt.y == CurrPt.y) && (iPt1 < iEndPt))
					{
						iPt1++;

						 if (iPt1 >= iEndPt)
							 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
						{
							NextPt.x = FirstPt.x;
							NextPt.y = FirstPt.y;
						} else {
							NextPt.x = pElement->x[iPt1 +1];
							NextPt.y = pElement->y[iPt1 +1];
						}
					}

					/* we do the computation for the current point */

					EmboldPoint(iPt, iPt1, bUnderTheThreshold, bMisoriented, PrevPt, CurrPt, NextPt, 
							fxRightShift, fxLeftShift, fxTopShift, fxBottomShift, globalGS->fxScaledDescender, pElement); 
                
					iPt = iPt1;

					iPt++;
					/* we compute Prev, Next, Curr coordinate for the next point */

					PrevPt = CurrPt;

					CurrPt = NextPt;

					 if (iPt >= iEndPt)
						 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
					{
						NextPt.x = FirstPt.x;
						NextPt.y = FirstPt.y;
					} else {
						NextPt.x = pElement->x[iPt +1];
						NextPt.y = pElement->y[iPt +1];
					}
				}
			}
		}
    }
}

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY)
{
    int32 sgn;

	/* as our coordinates are in desing unit, they fit in 16 bits and we are not overflowing here */

    sgn = DeltaPrevX*DeltaNextY - DeltaPrevY*DeltaNextX;
	return (short)Sgn(sgn); // +1 => left turn, -1 => right turn, 0 => straight
}

Vector AddV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	return c;
} // AddV

Vector SubV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	return c;
} // SubV

Vector ShlV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x << by;
	b.y = a.y << by;
	return b;
} // ShlV

Vector ShrV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x >> by;
	b.y = a.y >> by;
	return b;
} // ShrV

int64 QDiv2(int64 a, int64 b) { // special version that replaces epsilons by 1, which is actually 1/65536 since we're actually returning F48Dot16
	int64 q;

	if (a < 0 != b < 0) {
		if (a < 0) a = -a; else b = -b;
		if (a < b) q = -1; else if (a > b << places16) q = -65536-1; else q = -((a + (b >> 1))/b);
	} else {
		if (a < 0) a = -a, b = -b;
		if (a < b) q = 1; else if (a > b << places16) q = 65536+1; else q = (a + (b >> 1))/b;
	}
	return q;
} // QDiv2

F32Dot32 FSqrt(uint64 radicand) {
	uint64 bit,root,s;

	root = 0;
	for (bit = (uint64)1 << 62; bit >= 0x8000 /* we don't need the last 16 bits */; bit >>= 1) {
		s = bit + root;
		if (s <= radicand) {
			radicand -= s;
			root |= (bit << 1);
		};
		radicand <<= 1;
	}
	return root;
} // FSqrt

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2) {
	// the usual method for solving quadratic equations
	// input is actually in 32bit, output is F48Dot16
	int64 radicand,root,b1,b2,c1;
	
	*solutions = 0;
	if (a == 0) {
		if (b != 0) {
			*solutions = 1;
			c1 = -(c << places16);
			*t1 = QDiv2(c1,b);
		} // else b == 0, no solutions
	} else {
		a *= 2;
		radicand = b*b - 2*a*c;
		if (radicand > 0) {
			*solutions = 2;

            root = (FSqrt(radicand) + half16) >> places16;
            b <<= places16;

			b1 = -(b - root);
			b2 = -(b + root);
			*t1 = QDiv2(b1,a);
			*t2 = QDiv2(b2,a);
		} else if (radicand == 0) {
			*solutions = 1;
			b1 = -(b << places16);
			*t1 = QDiv2(b1,a);
		} // else radicand < 0, no solutions
	}
} // FQuadraticEqn

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1) {

//	here we're intersecting a straight line (W0, W1) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u + B.x = C.x*v + D.x
//		A.y*u + B.y = C.y*v + D.y
//
//	a system of two "halfway" linear eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u + B.x - D.x)/C.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u + B.y - D.y = C.y*(A.x*u + B.x - D.x)/C.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*C.x - C.y*A.x)*u + B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x = 0
//
//	which is a single linear eqn. in u with 0 thru 1 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual segment
//	and we don't count start/end points twice by including them in adjacent segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D;
    int64 a, b;
	long transitions;
	int64 u,vd;

//	re-write Line in polynomial form
//	(W1 - W0)*u + W0, which follows immediately from the "first degree" Bzier "curve" W0*(1-u) + W1*u
	A = SubV(W1,W0);
	B = W0;


//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	C = SubV(V1,V0);
	D = V0;

    a = (A.y*C.x - C.y*A.x);

	transitions = 0;

    if (a != 0)
    {
        b = B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x;

    //  a*u + b = 0 => u = -b / a

	    b = -b << places16;
	    u = QDiv2(b,a); /* u stored in 48.16 */
	    
	    if (0 < u && u <= 0x10000) {
                /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(C.x) > MABS(C.y))
            {
			    vd = ((int64)A.x)*u  + ((int64)(B.x - D.x))*0x10000; // avoid division by 0 => multiply by C.x
		    //	transitions += 0 < vd && vd <= Abs(C.x);
			    if (C.x >= 0) {
				    if (0 < vd && vd <= ((int64)C.x)*0x10000) transitions++;
			    } else {
				    if (((int64)C.x)*0x10000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u  + ((int64)(B.y - D.y))*0x10000; // avoid division by 0 => multiply by C.y
		    //	transitions += 0 < vd && vd <= Abs(C.y);
			    if (C.y >= 0) {
				    if (0 < vd && vd <= ((int64)C.y)*0x10000) transitions++;
			    } else {
				    if (((int64)C.y)*0x10000 <= vd && vd < 0) transitions++;
			    }
            }
	    }
    }

	return transitions;
} // CurveTransitionsSegment

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2) {

//	here we're intersecting a quadratic Bzier curve (W0, W1, W2) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u^2 + B.x*u + C.x = D.x*v + E.x
//		A.y*u^2 + B.y*u + C.y = D.y*v + E.y
//
//	a system of two "halfway" quadratic eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u^2 + B.y*u + C.y - E.y = D.y*(A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*D.x - D.y*A.x)*u^2 + (B.y*D.x - D.y*B.x)*u + C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x = 0
//
//	which is a single quadratic eqn. in u with 0 thru 2 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual Bzier segment
//	and we don't count start/end points twice by including them in adjacent Bzier segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D,E;
	long i,solutions,transitions;
	int64 u[2],vd;

//	re-write Bzier curve in polynomial form
//	W0*(1-u)^2 + 2*W1*(1-u)*u + W2*u^2 = W0*(1 - 2*u + u^2) + 2*W1*(u - u^2) + W2*u^2 = 
//	(W0 - 2*W1 + W2)*u^2 + 2*(W1 - W0)*u + W0
	A = AddV(SubV(W0,ShlV(W1,1)),W2);
	B = ShlV(SubV(W1,W0),1);
	C = W0;

//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	D = SubV(V1,V0);
	E = V0;

	FQuadraticEqn(A.y*D.x - D.y*A.x,B.y*D.x - D.y*B.x,C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x,&solutions,&u[0],&u[1]);
	
	transitions = 0;
	for (i = 0; i < solutions; i++) {
		if (0 < u[i] && u[i] <= 0x10000) {
            /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(D.x) > MABS(D.y))
            {
			    vd = ((int64)A.x)*u[i]*u[i] + ((int64)B.x)*u[i]*0x10000 + ((int64)(C.x - E.x))*0x100000000; // avoid division by 0 => multiply by D.x
		    //	transitions += 0 < vd && vd <= Abs(D.x);
			    if (D.x >= 0) {
				    if (0 < vd && vd <= ((int64)D.x)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.x)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u[i]*u[i] + ((int64)B.y)*u[i]*0x10000 + ((int64)(C.y - E.y))*0x100000000; // avoid division by 0 => multiply by D.y
		    //	transitions += 0 < vd && vd <= Abs(D.y);
			    if (D.y >= 0) {
				    if (0 < vd && vd <= ((int64)D.y)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.y)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            }
		}
	}


	return transitions;
} // CurveTransitions

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber)
{
    Vector Min, Max;

    /* the curve is completely conatined in the triangle W0,W1,W2 */
    MinMax3Vectors (W0, W1, W2, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxCurve, illegal case");
        return TRUE;
    }

}

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1, int16 extremumNumber)
{
    Vector Min, Max;

    MinMax2Vectors (W0, W1, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxSegment, illegal case");
        return TRUE;
    }

}

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0X - 2*V1X + V2X;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0X - V1X;
		u1Num = V2X - V1X;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;
	//	if we're calculating the left extremal point, we floor the result for the probing line
	//	not to start inside the contour as a result of rounding. Starting on the contour should be fine,
	//	as this is handled in CurveTransitions, which does not include the lower end of the interval.
		*extrX = min ? (long)(xNum/uDen2) : (long)((xNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrY = yNum >= 0 ? (long)((yNum + uDen2)/uDen2) : -(long)((uDen2 - yNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateXExtremum

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0Y - 2*V1Y + V2Y;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0Y - V1Y;
		u1Num = V2Y - V1Y;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;

        *extrY = min ? (long)(yNum/uDen2) : (long)((yNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrX = xNum >= 0 ? (long)((xNum + uDen2)/uDen2) : -(long)((uDen2 - xNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateYExtremum

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1)
{
/* extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY,
    the coordinates returned in C0 and C1 are scaled by 2 */

    switch (extremumNumber) {
	case 0:
        /* line from minX to infinity */
	    C0->x = extremum.x+1;
	    C0->y = extremum.y;
	    C1->x = -32768;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 1:
        /* line from maxX to infinity */
	    C0->x = extremum.x-1;
	    C0->y = extremum.y;
	    C1->x = 32767;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 2:
        /* line from minY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y+1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = -32768;
        break;
	case 3:
        /* line from maxY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y-1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = 32767;
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, FindExtremaKnot, illegal case");
    }
}

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (C.x < Min->x) Min->x = C.x;
    if (B.y < Min->y) Min->y = B.y;
    if (C.y < Min->y) Min->y = C.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (C.x > Max->x) Max->x = C.x;
    if (B.y > Max->y) Max->y = B.y;
    if (C.y > Max->y) Max->y = C.y;
}

void MinMax2Vectors (Vector A,Vector B, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (B.y < Min->y) Min->y = B.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (B.y > Max->y) Max->y = B.y;
}

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement)
{
    int32 Contour;
    boolean bMisoriented;
    short knot, n, i, start, end, predKnot, succKnot;
    short extremumKnot[4];
	Vector extremum[4];
    long minX, maxX, minY, maxY;
    long distance0_1, distance0_2, distance0_3;
    uint16 extremaNumber2, extremaNumber3;

    for (Contour = 0; Contour < pElement->nc; Contour++)
	{
        pElement->fc[Contour] = 0;

        start = pElement->sp[Contour];
        end = pElement->ep[Contour];
        
        n = end - start + 1;

        if (n > 2) 
        {
            /* we are not interested in degenerated contours */

            /* look for exterma knots to decide which direction to look to increase our chance of getting the correct result even on bad fonts */

            /* we will look for the following extrema :
               extremumKnot = 0 : MinX
               extremumKnot = 1 : MaxX
               extremumKnot = 2 : MinY
               extremumKnot = 3 : MaxY */

            for (i = 0; i < 4; i++) extremumKnot[i] = -1;
            
            minX = minY = 0x7fffffff;
    	    maxX = maxY = 0x80000000;

	        for (knot = 0; knot < n; knot++) {
                /* look for Min X */
		        if (pElement->oox[start + knot] < minX || 
			        pElement->oox[start + knot] == minX && !pElement->onCurve[extremumKnot[0]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == minX && pElement->onCurve[extremumKnot[0]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] < pElement->ooy[extremumKnot[0]]) {
					extremumKnot[0] = start + knot;
					minX = pElement->oox[extremumKnot[0]];
					if (pElement->onCurve[extremumKnot[0]]) {
						extremum[0].x = pElement->oox[extremumKnot[0]] << 1;
						extremum[0].y = pElement->ooy[extremumKnot[0]] << 1;
					} else {
						predKnot = extremumKnot[0] == start ? end : extremumKnot[0] - 1;
						succKnot = extremumKnot[0] == end ? start : extremumKnot[0] + 1;
						CalculateXExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[0]],pElement->ooy[extremumKnot[0]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[0].x,&extremum[0].y);
					}
				}
                /* look for Max X */
		        if (pElement->oox[start + knot] > maxX || 
			        pElement->oox[start + knot] == maxX && !pElement->onCurve[extremumKnot[1]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == maxX && pElement->onCurve[extremumKnot[1]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] > pElement->ooy[extremumKnot[1]]) {
					extremumKnot[1] = start + knot;
					maxX = pElement->oox[extremumKnot[1]];
					if (pElement->onCurve[extremumKnot[1]]) {
						extremum[1].x = pElement->oox[extremumKnot[1]] << 1;
						extremum[1].y = pElement->ooy[extremumKnot[1]] << 1;
					} else {
						predKnot = extremumKnot[1] == start ? end : extremumKnot[1] - 1;
						succKnot = extremumKnot[1] == end ? start : extremumKnot[1] + 1;
						CalculateXExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[1]],pElement->ooy[extremumKnot[1]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[1].x,&extremum[1].y);
		        		}
				}
                /* look for Min Y */
		        if (pElement->ooy[start + knot] < minY || 
			        pElement->ooy[start + knot] == minY && !pElement->onCurve[extremumKnot[2]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == minY && pElement->onCurve[extremumKnot[2]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] > pElement->oox[extremumKnot[2]]) {
					extremumKnot[2] = start + knot;
					minY = pElement->ooy[extremumKnot[2]];
					if (pElement->onCurve[extremumKnot[2]]) {
						extremum[2].x = pElement->oox[extremumKnot[2]] << 1;
						extremum[2].y = pElement->ooy[extremumKnot[2]] << 1;
					} else {
						predKnot = extremumKnot[2] == start ? end : extremumKnot[2] - 1;
						succKnot = extremumKnot[2] == end ? start : extremumKnot[2] + 1;
						CalculateYExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[2]],pElement->ooy[extremumKnot[2]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[2].x,&extremum[2].y);
					}
				}
                /* look for Max Y */
		        if (pElement->ooy[start + knot] > maxY || 
			        pElement->ooy[start + knot] == maxY && !pElement->onCurve[extremumKnot[3]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == maxY && pElement->onCurve[extremumKnot[3]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] < pElement->oox[extremumKnot[3]]) {
					extremumKnot[3] = start + knot;
					maxY = pElement->ooy[extremumKnot[3]];
					if (pElement->onCurve[extremumKnot[3]]) {
						extremum[3].x = pElement->oox[extremumKnot[3]] << 1;
						extremum[3].y = pElement->ooy[extremumKnot[3]] << 1;
					} else {
						predKnot = extremumKnot[3] == start ? end : extremumKnot[3] - 1;
						succKnot = extremumKnot[3] == end ? start : extremumKnot[3] + 1;
						CalculateYExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[3]],pElement->ooy[extremumKnot[3]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[3].x,&extremum[3].y);
					}
				}
	        }

            /* diagonal distance, we don't need a precise distance */

            distance0_1 = MABS(pElement->oox[extremumKnot[1]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[1]] - pElement->ooy[extremumKnot[0]]);
            distance0_2 = MABS(pElement->oox[extremumKnot[2]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[2]] - pElement->ooy[extremumKnot[0]]);
            distance0_3 = MABS(pElement->oox[extremumKnot[3]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[3]] - pElement->ooy[extremumKnot[0]]);

            if (distance0_2 > distance0_3)
            {
                /* we will look at MinY */
                extremaNumber2 = 2;
                if (distance0_3 > distance0_1)
                {
                    /* we will look then at MaxY */
                    extremaNumber3 = 3;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            } else {
                /* we will look at MaxY */
                extremaNumber2 = 3;
                if (distance0_2 > distance0_1)
                {
                    /* we will look then at MinY */
                    extremaNumber3 = 2;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            }

            bMisoriented = Misoriented(Contour, 0 /* MinX */, extremumKnot[0], extremum[0], pElement);

            /* look in a second direction to check if same result 
               this additional work help weed out problems with bad fonts having self-intersecting
               or overlapping outlines */
            if (bMisoriented != Misoriented(Contour, extremaNumber2, extremumKnot[extremaNumber2], extremum[extremaNumber2], pElement))
            {
                /* we need to look in a third direction */
                bMisoriented = Misoriented(Contour, extremaNumber3, extremumKnot[extremaNumber3], extremum[extremaNumber3], pElement);
            }

                // at this point we store the orientation of the original component (original in the sense of before the composite code potentially
                // applies a mirroring), such that the concertina code can work on the component w/o having to know about composite transformations
                if (bMisoriented) pElement->fc[Contour] |= OUTLINE_MISORIENTED;
        }
    }
}

boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement)
/* we will check the coutour orientation at the following extrema :
   extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY */

{
	LinkColor color,orientation;
	short predKnot,cont,knot,start,iter,end,n;
	long parity;
	Vector V[3],D[2],C[2],W[3],Wi;
	boolean on[3];

    short dirChange = 0;      
    
	start = pElement->sp[contour];
	end = pElement->ep[contour];
	n = end - start + 1;

	// here we determine the straight line that runs from the extreme of the contour to infinity, to be used below.
    SetLineToInfinity(extremumNumber, extremum, &C[0], &C[1]);
	
	// find out the current orientation of the contour
	// to do so first determine what kinds of turns we make at each knot
	orientation = linkBlack; // assume as default

    knot = extremumKnot - start;
    predKnot = (knot+n-1)%n;

    V[0].x = pElement->oox[start+predKnot]; V[1].x = pElement->oox[start+knot];
	V[0].y = pElement->ooy[start+predKnot]; V[1].y = pElement->ooy[start+knot];
	D[0] = SubV(V[1],V[0]);
	for (iter = 0; iter < n && !dirChange; iter++) {
		V[2].x = pElement->oox[start + (knot + 1)%n];
		V[2].y = pElement->ooy[start + (knot + 1)%n];
		if (NotSameKnot(V[1],V[2])) {
    		D[1] = SubV(V[2],V[1]);
		    dirChange = ComputeSign(D[0].x, D[0].y, D[1].x, D[1].y);
		    V[0] = V[1]; V[1] = V[2]; D[0] = D[1];
        }
        knot = (knot + 1)%n;
	}

    if (iter < n && dirChange > 0)
    {
        orientation = linkWhite; /* counter clockwise */
    }
	
	// now find out what the orientation of the contour should really be
	// to do so we intersect the above probing line with all other contours.
	// If the number of intersections is odd, we have started inside, else outside.
	// if this doesn't correspond to the contour orientation determined above, then we're misoriented.
	// The loops below follow the same pattern used for Contour::Draw but are separate due to different underlying data structure.
	// Notice that this doesn't work for overlapping or self-intersecting contours. They're against the TT laws...
	parity = 0;
	for (cont = 0; cont < pElement->nc; cont++) {
        if (cont != contour) 
        /* we are not interested by the intersections of the contour with itself, optimization */
        {
		    start = pElement->sp[cont];
		    end = pElement->ep[cont];
		    n = end - start + 1;
		    W[1].x = pElement->oox[start] << 1;
		    W[1].y = pElement->ooy[start] << 1;
		    on[1] = pElement->onCurve[start];
		    if (!on[1]) { // we start amidst a curve => get curve start point
			    W[0].x = pElement->oox[end] << 1;
			    W[0].y = pElement->ooy[end] << 1;
			    on[0] = pElement->onCurve[end];
			    if (!on[0]) { // curve start point is implied on-curve point => compute
				    W[0] = ShrV(AddV(W[0],W[1]),1);
			    }
		    }
		    knot = start;
		    do {
			    knot = knot == end ? start : knot + 1;
			    W[2].x = pElement->oox[knot] << 1;
			    W[2].y = pElement->ooy[knot] << 1;
			    on[2] = pElement->onCurve[knot];
			    switch (on[1] << 1 | on[2]) {
				    case 3: // on---on => start and end a line => intersect with line
					    if (NotSameKnot(W[1],W[2]))
                        {
                        /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxSegment(C[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitionsSegment(C[0],C[1],W[1],W[2]); // repeating first vertex makes Bzier curve a line...
							}
                        }
					    break;
				    case 2: // on---off => start a curve => intersect with nothing
					    W[0] = W[1];
					    break;
				    case 1: // off---on => end a curve => intersect with the curve
					    if (NotSameKnot(W[0],W[2])) 
                        {
                            /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],W[2]);
							}
                        }
					    break;
				    case 0: // off---off => end a curve => intersect with the curve; then start a curve => intersect with nothing
					    Wi = ShrV(AddV(W[1],W[2]),1);
					    if (NotSameKnot(W[0],Wi))
                        {
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],Wi,extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],Wi);
							}
                        }
					    W[0] = Wi;
					    break;
			    }
			    W[1] = W[2]; on[1] = on[2];
		    } while (knot != start);
        }
	}
	color = parity & 1 ? linkBlack : linkWhite;

	return color == orientation; // cw (black) contours should have white to their left, and v.v., else they're oriented the wrong way round
} // Misoriented

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel)
{
	fnt_GlobalGraphicStateType *globalGS, *globalGSSubPixel;
	int32 i;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGSSubPixel = (fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel;

	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGSSubPixel->funcDef[i] = globalGS->funcDef[i];

	}

    globalGSSubPixel->instrDefCount = globalGS->instrDefCount;

	for (i = 0; i < globalGS->instrDefCount; i++)
	{
		globalGSSubPixel->instrDef[i] = globalGS->instrDef[i];

	}
	globalGSSubPixel->subPixelCompatibilityFlags = globalGS->subPixelCompatibilityFlags;
}


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_ScaleToCompatibleWidth(pElement, fxCompatibleWidthScale);
}


FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_AdjustCompatibleMetrics(pElement, horTranslation, newDevAdvanceWidthX);
}

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX);

}

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevNatHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX, pNatAdvanceWidthX, pNatLeftSideBearingX, pNatRightSideBearingX);

}

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fscdefs.h ===
/*
	File:       fscdefs.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	Copyright:  c 1991-1999 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		
				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <3>    11/27/90    MR      Add #define for PASCAL. [ph]
		 <2>     11/5/90    MR      Move USHORTMUL from fontmath.h, add Debug definition [rb]
		 <7>     7/18/90    MR      Add byte swapping macros for INTEL, moved rounding macros from
									fnt.h to here
		 <6>     7/14/90    MR      changed defines to typedefs for int[8,16,32] and others
		 <5>     7/13/90    MR      Declared ReleaseSFNTFunc and GetSFNTFunc
		 <4>      5/3/90    RB      cant remember any changes
		 <3>     3/20/90    CL      type changes for Microsoft
		 <2>     2/27/90    CL      getting bbs headers
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#ifndef FSCDEFS_DEFINED
#define FSCDEFS_DEFINED

#include "fsconfig.h"
#include <stddef.h>
#include <limits.h>

#if !defined(__cplusplus)       // true/false are reserved words for C++
#define true 1
#define false 0
#endif

#ifndef TRUE
	#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef FS_PRIVATE
#define FS_PRIVATE static
#endif

#ifndef FS_PUBLIC
#define FS_PUBLIC
#endif

#define ONEFIX      ( 1L << 16 )
#define ONEFRAC     ( 1L << 30 )
#define ONEHALFFIX  0x8000L
#define ONEVECSHIFT 16
#define HALFVECDIV  (1L << (ONEVECSHIFT-1))

#define NULL_GLYPH  0

/* banding type constants */

#define FS_BANDINGOLD       0
#define FS_BANDINGSMALL     1
#define FS_BANDINGFAST      2
#define FS_BANDINGFASTER    3

/* Dropout control values are now defined as bit masks to retain compatability */
/* with the old definition, and to allow for current and future expansion */

#define SK_STUBS          0x0001       /* leave stubs white */
#define SK_NODROPOUT      0x0002       /* disable all dropout control */
#define SK_SMART              0x0004        /* symmetrical dropout, closest pixel */

/* Values used to decode curves */

#define ONCURVE             0x01

typedef signed char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;
typedef long int32;
typedef unsigned long uint32;

typedef __int64 int64;
typedef unsigned __int64 uint64;

typedef short FUnit;
typedef unsigned short uFUnit;

typedef short ShortFract;                       /* 2.14 */

#ifndef F26Dot6
#define F26Dot6 long
#endif

#ifndef boolean
#define boolean int
#endif

#ifndef ClientIDType
#define ClientIDType int32
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef TMP_CONV
#define TMP_CONV
#endif

#ifndef FS_MAC_PASCAL
#define FS_MAC_PASCAL
#endif

#ifndef FS_PC_PASCAL
#define FS_PC_PASCAL
#endif

#ifndef FS_MAC_TRAP
#define FS_MAC_TRAP(a)
#endif

/* QuickDraw Types */

#ifndef _MacTypes_
#ifndef __TYPES__
	typedef struct Rect {
		int16 top;
		int16 left;
		int16 bottom;
		int16 right;
	} Rect;

typedef long Fixed;         /* also defined in Mac's types.h */
typedef long Fract;

#endif
#endif

typedef struct {
	Fixed       transform[3][3];
} transMatrix;

typedef struct {
	Fixed       x, y;
} vectorType;

/* Private Data Types */
typedef struct {
	int16 xMin;
	int16 yMin;
	int16 xMax;
	int16 yMax;
} BBOX;

typedef struct {
	F26Dot6 x;
	F26Dot6 y;
} point;

typedef int32 ErrorCode;

#define ALIGN(object, p) p =    (p + ((uint32)sizeof(object) - 1)) & ~((uint32)sizeof(object) - 1);

#define ROWBYTESLONG(x)     (((x + 31) >> 5) << 2)

#ifndef SHORTMUL
#define SHORTMUL(a,b)   (int32)((int32)(a) * (b))
#endif

#ifndef SHORTDIV
#define SHORTDIV(a,b)   (int32)((int32)(a) / (b))
#endif

#ifdef FSCFG_BIG_ENDIAN /* target byte order matches Motorola 68000 */
	#define SWAPL(a)        (a)
	#define CSWAPL(a)       (a)
	#define SWAPW(a)        (a)
	#define CSWAPW(a)       (a)
	#define SWAPWINC(a)     (*(a)++)
#else
	/* Portable code to extract a short or a long from a 2- or 4-byte buffer */
	/* which was encoded using Motorola 68000 (TrueType "native") byte order. */
	#define FS_2BYTE(p) ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
	#define FS_4BYTE(p) ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )
	#define SWAPW(a)	((int16) FS_2BYTE( (unsigned char *)(&a) ))
	#define CSWAPW(num)	(((((num) & 0xff) << 8) & 0xff00) + (((num) >> 8) & 0xff)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPL(a)	((int32) FS_4BYTE( (unsigned char *)(&a) ))
	#define CSWAPL(num)	((CSWAPW((num) & 0xffff) << 16) + CSWAPW((num) >> 16)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPWINC(a) SWAPW(*(a)); a++    /* Do NOT parenthesize! */
#endif

#ifndef SWAPW // provoke compiler error if still not defined
	#define SWAPW	a
	#define SWAPW	b
#endif

#ifndef LoopCount
#define LoopCount int16      /* short gives us a Motorola DBF */
#endif

#ifndef ArrayIndex
#define ArrayIndex int32     /* avoids EXT.L on Motorola */
#endif

typedef void (*voidFunc) ();
typedef void * voidPtr;
typedef void (FS_CALLBACK_PROTO *ReleaseSFNTFunc) (voidPtr);
typedef void * (FS_CALLBACK_PROTO *GetSFNTFunc) (ClientIDType, int32, int32);

#ifndef	FS_ASSERT
#define FS_ASSERT(expression, message)
#endif

#ifndef Assert
#define Assert(a)
#endif

#ifndef MEMSET
#define MEMSET(dst, value, size) (void)memset(dst,value,(size_t)(size))
#define FS_NEED_STRING_DOT_H
#endif

#ifndef MEMCPY
#define MEMCPY(dst, src, size) (void)memcpy(dst,src,(size_t)(size))
#ifndef FS_NEED_STRING_DOT_H
#define FS_NEED_STRING_DOT_H
#endif
#endif

#ifdef FS_NEED_STRING_DOT_H
#undef FS_NEED_STRING_DOT_H
#include <string.h>
#endif

#ifndef FS_UNUSED_PARAMETER
#define FS_UNUSED_PARAMETER(a) (a=a)     /* Silence some warnings */
#endif

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} LocalMaxProfile;

#ifdef FSCFG_SUBPIXEL

	// master switch for turning on Backwards Compatible SubPixel
	// if we turn this off, we basically get the same as in b/w, but with coloured fringes
	// to get the complete original 16x overscaling behaviour back, set HINTING_HOR_OVERSCALE below to 16
	#define	SUBPIXEL_BC
	
	#define ProjVectInX(localGS)	((localGS).proj.x == ONEVECTOR && (localGS).proj.y == 0)
	#define	ProjVectInY(localGS)	((localGS).proj.y == ONEVECTOR && (localGS).proj.x == 0)
	
	#ifdef SUBPIXEL_BC
		
		// master switch for turning on Enhanced Backwards Compatible Advance Width SubPixel Algorithm
		#define SUBPIXEL_BC_AW_STEM_CONCERTINA
		
		#define RunningSubPixel(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_SUB_PIXEL))
		#define CompatibleWidthSP(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
		#define VerticalSPDirection(globalGS)	((uint16)((globalGS)->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
		#define BGROrderSP(globalGS)			((uint16)((globalGS)->flHintForSubPixel & FNT_SP_BGR_ORDER))
	//	assume that horizontal direction RGB is more frequent than vertical direction, hence put the latter into the else-path
	//	Notice that in order to decide whether we're currently in SubPixel direction, we look at the projection vector, because that's the direction
	//	along which distances are measured. If this projection vector has a non-zero component in the physical direction of our device, we will decide
	//	that rounding should be done in the SubPixel way. For example, if our device has its SubPixel direction in x, and if the projection vector
	//	points in any direction other than the y direction, the pv has a non-zero component in x, hence we round in the SubPixel way. This behaviour
	//	corresponds to the original implementation of the 16x overscaling rasterizer, where the non-zero component in x would be overscaled by 16.
		#define InSubPixelDirection(localGS)	((uint16)(!VerticalSPDirection((localGS).globalGS) ? !ProjVectInY(localGS) : !ProjVectInX(localGS)))
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				16 // for itrp_RoundToGrid & al to work properly, this should be a power of two, else have to tabulate rounding
		#define VISUAL_OVERSCALE				2  // between 1.7 and 3, corresponding to the visually experienced resolution relative to the physical resolution.
												   // for our purposes, the exact value is not particularly crucial (cf. ENGINE_COMP_OVERSCALE, MIN_DIST_OVERSCALE,
												   // in interp.c) hence we set it to 2 for efficiency
	#else
		#define RunningSubPixel(globalGS)		false
		#define CompatibleWidthSP(globalGS)		false
		#define VerticalSPDirection(globalGS)	false
		#define InSubPixelDirection(localGS)	false
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				1
		#define VISUAL_OVERSCALE				1
	#endif
//	#define VIRTUAL_PIXELSIZE		(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
//	these values are used in various rounding functions, which includes rounding the advance width
//	they are specific to the rounding operation, if this should become necessary in the future
	#define VIRTUAL_PIXELSIZE_RTDG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RDTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RUTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTHG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_ROFF	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	

	#define HINTING_HOR_OVERSCALE 1 // see SUBPIXEL_BC above for further comments

#ifdef FSCFG_SUBPIXEL_STANDALONE
	
	#define R_Subpixels		5
	#define G_Subpixels		9
	#define B_Subpixels		2

	/* IMPORTANT :
 
	   If you change any of the above
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) <= 256

	  */

	#define RGB_OVERSCALE (R_Subpixels + G_Subpixels + B_Subpixels)

#else

	#define SUBPIXEL_OVERSCALE 2

	/* IMPORTANT :
 
	   If you change SUBPIXEL_OVERSCALE
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) <= 256

	  */

	#define RGB_OVERSCALE (SUBPIXEL_OVERSCALE * 3)
#endif

	#define ROUND_FROM_RGB_OVERSCALE(x) x = ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE
	#define ROUND_FROM_HINT_OVERSCALE(x) x = ((x) + (HINTING_HOR_OVERSCALE >> 1) ) / HINTING_HOR_OVERSCALE
	#define ROUND_RGB_OVERSCALE(x) ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE

	#define FLOOR_RGB_OVERSCALE(x) ((x) < 0) ? -((-(x)+ RGB_OVERSCALE -1) / RGB_OVERSCALE) : ((x) / RGB_OVERSCALE) // by the way, this is NOT a floor operation
	#define CEIL_RGB_OVERSCALE(x) FLOOR_RGB_OVERSCALE((x) + RGB_OVERSCALE -1)

	/* we are storing into 2 bits per pixels, weight for each color can be 0,1 or 2 */
	#define MAX_RGB_INDEX (2 * 16 + 2 * 4 + 2 )

	#define SUBPIXEL_SCALEBACK_FACTOR ((RGB_OVERSCALE << 16) / HINTING_HOR_OVERSCALE)

	#define SUBPIXEL_SCALEBACK_UPPER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *120 /100)
	#define SUBPIXEL_SCALEBACK_LOWER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *100 /120)
#endif // FSCFG_SUBPIXEL

#endif  /* FSCDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fsconfig.h ===
/*
	File:       fsconfig.h : (Portable "Standard C" version)

	Written by: Lenox Brassell

	Contains:   #define directives for FontScaler build options

   Copyright:  c 1989-1993 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		<3>      4/21/93 GregH Documented file
		<2>      7/16/92    DJ      Added fnt_Report_Error() declaration.
		<1>      8/27/91    LB      Created file.

	Usage:  This file is "#include"-ed as the first statement in
			"fscdefs.h".  This file contains platform-specific
			override definitions for the following #define-ed data
		types and macros, which have default definitions in
		"fscdefs.h":

	Purpose:

		This file gives the integrator a place to override the
		default definitions of these items, as well as a place
		to define other configuration-specific macros.

	Definitions:

		The following type definitations can be changed. The defaults have been
		set up for a 32-bit system. Caveat emptor: any change to the defaults may
		severly effect performace or place severe limitations on the capabilities
		of the TrueType rasterizer.

				F26Dot6
					 This is currently defined as a fixed point 26.6 number.
					 If changed to short, it is a 10.6 number.

		The following definition changes the return type for all Font Scalar
		Client Interface calls.

				FS_ENTRY

		The following definition changes the calling convention for all Font
		Scalar Client Interface calls.  By default, the rasterizer uses register
		calling conventions because of the performance gains.

				FS_ENTRY_PROTO

		The following definitions are used for all private and public entry points
		in the TrueType Rasterizer. By default FS_PRIVATE is set to static, but
		for some uses, like profiling and debugging this is undesirable, and
		FS_PRIVATE can be set to null. FS_PUBLIC defaults to null.

				FS_PRIVATE
				FS_PUBLIC

		The following definitions are used for calling conventions to external
		math routines. The Macintosh has external math routines that use pascal
		calling conventions. To enable these, the FS_MAC_PASCAL must be set to
		"pascal". Similary the FS_PC_PASCAL variable needs to be set to "pascal"
		when calling external routines using pascal calling conventions.

				FS_MAC_PASCAL
				FS_PC_PASCAL

		This definition is used for calling Macintosh ToolBox routines. If the
		rasterizer is implemented on a non-Macintosh platform, this Macro should
		be null.

				FS_MAC_TRAP

		These macros are used to override the C memcpy and memset routines

				MEMCPY
				MEMSET

		These math routines can be hooked out by system routines.

				SHORTDIV
				SHORTMUL

		These macros are used to convert big-endian to little-endian. When
		running on a big-endian platform these macros are not necessary.

				SWAPL
				SWAPW
				SWAPWINC

		These macros are used to replace some math routines by faster assembly
		language routines. The notation used for the assembly language routines
		should indicate the processor targeted. For example:

				#define CompMul   CompMul386
				#define CompDiv   CompDiv386
				#define FracSqrt      FracSqrt386

	The following definitions change the way the TrueType rasterizer works on
	specific implementations. These definitions are usually switches that are
	defined or not defined.

		FSCFG_DEBUG

		This is used to create a debugging version of the rasterizer. This
		version does additional error checking and creates a debugger trap
		when the TrueType DEBUG instruction is called.

		FSCFG_FNTERR

		This is used to create a error checking version of the rasterizer. With
		this set, parameters passed to TrueType instructions are range checked.
		If any instructions fails a test, a error message is returned.

		FSCFG_MOVEABLE_MEMBASE

		This is used to implement moveable memory bases. If it is possible that
		the address of a memory base could change between a Font Scaler Client
		Interface call, then this flag should be set in the rasterizer.

		FSCFG_MICROSOFT_KK

		This flag is used to implement the Microsoft KK version of the TrueType
		rasterizer. The effect of this flag is to use a slightly different
		algorithm for parsing the Format 2 cmap table.

		FSCFG_BIG_ENDIAN

		This flag indicates the target platform of the rasterizer uses big-endian
		representation of multiple-byte integers. If this flag is not set, SWAP
		macros are used to convert all multiple-byte integers read from TrueType
		Font Files.

		FSCFG_REENTRANT

		This flag indicates that the TrueType rasterizer should be reentrant.
		This allows multiple treads of execution through the executable and gives
		better system through put on multi-threaded/process environments. Slight
		performance gains are possible when not setting this flag in single tasking
		environments.

		FSCFG_NO_INITIALIZED_DATA

		This flag should be set for platforms that do not support static
		initialization of data. With this flag, a new Font Scalar Client Interface
		call fs_InitializeData needs to be made.

		FSCFG_USESTATCARD

		This flag is set to turn on stat card timing services in the rasterizer.
		This can be used to collect timing information for profiling.
		
		FSCFG_USE_MASK_SHIFT

		This flag is set to enable bitmask generated by shifting rather than by
		table lookup.  Shifted bitmasks use less memory and MAY be faster than
		table bitmasks.  On Big-Endian platforms shifted bitmasks will produce
		bitmaps that are identical to Apple's definition (same byte order).
		Table bitmaps will be identical for all platforms.

		FSCFG_DISABLE_GRAYSCALE

		This flag is set to disable all grayscale functions and save a little
		code space along the way. If defined, all grayscale functions return
		a BAD_GRAY_LEVEL_ERR error code.

		FSCFG_FONTOGRAPHER_BUG

		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error

		FSCFG_EUDC_EDITOR_BUG

		The EUDC editor under NT 4.0 has a bug and create bogous fonts.
        	The EUDC editor set maxp->maxStackElements to 0 and use 1 stack element
        	in the pre/font program. If this flag is defined, we will ensure that
        	at least one StackElement is reserved to avoid memory corruption.

       		FSCFG_CONVERT_GRAY_LEVELS

        	with grayscale embedded bitmap, the number of gray levels can be different than expected
        	4, 16, 256 instead of 5, 17, 65. If FSCFG_CONVERT_GRAY_LEVELS is defined, a conversion will be done
        	in the rasterizer to the expected number of gray levels

       FSCFG_SUBPIXEL

        will activate the SubPixel code

		FSCFG_SUBPIXEL_STANDALONE

		will activate a special variant of the SubPixel code for the stand-alone rasterizer
		
        	FSCFG_SECURE

        	Enable critical error checking in the TrueType rasterizer.

		MAC_INIT

		This flag indicates that the TrueType rasterizer will be implemented as
		a Macintosh Init.

		UNNAMED_UNION

		This flag is set for compilers that implement unnamed unions

                ClientIDType

                This definition allow the change the type definition for ClientID. If you are using ClientID to pass a pointer
                and compiling the TrueType rasterizer for a platform where pointer are bigger than 32 bits, 
                you need to change this definition.
*/

/* #define FSCFG_MICROSOFT_KK   */
/* #define FSCFG_USESTATCARD      */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_FNTERR           */
/* #define FSCFG_DEBUG            */
/* #define FSCFG_MOVABLE_MEM_BASE */
/* #define FSCFG_BIG_ENDIAN   */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_USE_MASK_SHIFT */
/* #define FSCFG_DISABLE_GRAYSCALE */

#define FSCFG_REENTRANT

#define FSCFG_FONTOGRAPHER_BUG

#define FSCFG_EUDC_EDITOR_BUG

#define FSCFG_SECURE

#define FSCFG_CONVERT_GRAY_LEVELS

#define FSCFG_SUBPIXEL


/* Windows NT, is moving the definition of the internal rasterizer key in fscaler.h for optimization purpose */
#define FSCFG_MOVE_KEY_IN_DOT_H

/* !!! This should be removed */
#define NOT_ON_THE_MAC

/* Assembly Optimization Switches */

/* #define CompMul      CompMul386  */
/* #define CompDiv      CompDiv386  */
/* #define FracSqrt     FracSqrt386 */

// use RtlRoutines for memory operations

// in all uses in the rasterizer MEMSET  is used to zero out the mem

// to get the prototype for RtlZeroMemory and RtlCopyMemory :

#ifdef FSCFG_INTERNAL
#include "nt.h"
#include "ntrtl.h"

#if DBG
/* to activate rasterizer assertions : */
VOID __cdecl TtfdDbgPrint(PCHAR DebugMessage,...);

void __stdcall DebugBreak(void);
    
#define FS_ASSERT(expression, message) { if (!(expression)) { TtfdDbgPrint(message); DebugBreak();} }
#define Assert(expression) { if (!(expression)) { TtfdDbgPrint("FONT: TrueType rasterizer internal assert"); DebugBreak();} }
#endif // DBG

#endif

#define MEMSET(dst, value, size) RtlZeroMemory(dst, size)
#define MEMCPY(dst, src, size)   RtlCopyMemory(dst, src, size)


// easier to debug with no static functions [BODIND]

#define FS_PRIVATE

// interface to the outside world [bodind]

#define FS_ENTRY_PROTO           __cdecl
#define FS_CALLBACK_PROTO	 __cdecl

// client ID is commonly used to pass a pointer to a structure, for backwards compatibility it
// need to be at least a 32 bits value, to get ready for the 64 bits platform, we define it as ULONG_PTR

#define ClientIDType ULONG_PTR

// only do stamp checking in the debug version

// #if DBG
// #define DEBUGSTAMP
// #endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fserror.h ===
/*
    File:       fserror.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		<>      10/14/97    CB      error if FDEF/IDEF in GlyphProgram
 		 <>     04/30/97    CB      ClaudeBe, missing ENDF, infinite loop/recursion
		 <>     03/1/97    CB      ClaudeBe, div by 0 in hinting error
        <4>     7/13/90    MR      made endif at bottom use a comment
         <3>      5/3/90    RB      Changed char to int8 for variable type.   Now it is legal to
                                    pass in zero as the address of memory when a piece of
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)
       <3.1>    11/14/89    CEL     Now it is legal to pass in zero as the address of memory when a
                                    piece of the sfnt is requested by the scaler. If this happens
                                    the scaler will simply exit with an error code !
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/************/
/** ERRORS **/
/************/
#define NO_ERR                      0x0000
#define NULL_KEY                    0x0000


/** EXTERNAL INTERFACE PACKAGE **/
#define NULL_KEY_ERR                0x1001
#define NULL_INPUT_PTR_ERR          0x1002
#define NULL_MEMORY_BASES_ERR       0x1003
#define VOID_FUNC_PTR_BASE_ERR      0x1004  /* No longer used */
#define OUT_OFF_SEQUENCE_CALL_ERR   0x1005
#define BAD_CLIENT_ID_ERR           0x1006
#define NULL_SFNT_DIR_ERR           0x1007
#define NULL_SFNT_FRAG_PTR_ERR      0x1008
#define NULL_OUTPUT_PTR_ERR         0x1009
#define INVALID_GLYPH_INDEX         0x100A
#define BAND_TOO_BIG_ERR            0x100B  /* possible with FindBandingSize */
#define INVALID_CHARCODE_ERR        0x100C

/* fnt_execute */
#define UNDEFINED_INSTRUCTION_ERR   0x1101
#define TRASHED_MEM_ERR             0x1102
#define DIV_BY_0_IN_HINTING_ERR     0x1103
#define MISSING_ENDF_ERR			0x1104
#define MISSING_EIF_ERR				0x1105
#define INFINITE_RECURSION_ERR		0x1106 
#define INFINITE_LOOP_ERR			0x1107 
#define FDEF_IN_GLYPHPGM_ERR		0x1108 
#define IDEF_IN_GLYPHPGM_ERR		0x1109 

#define TRACE_FAILURE_ERR			0x110A  /* can be used by a trace function to notify of an 
                                               internal error (memory allocation failed,...) */
#define JUMP_BEFORE_START_ERR	    0x110B
#define INSTRUCTION_ERR             0x110C  /* can be used by a trace function to notify the discovery of an error */

#define RAW_NOT_IN_GLYPHPGM_ERR		0x110D 

#define SECURE_STACK_UNDERFLOW      0x1110
#define SECURE_STACK_OVERFLOW       0x1111
#define SECURE_POINT_OUT_OF_RANGE   0x1112
#define SECURE_INVALID_STACK_ACCESS 0x1113
#define SECURE_FDEF_OUT_OF_RANGE    0x1114
#define SECURE_ERR_FUNCTION_NOT_DEFINED    0x1115
#define SECURE_INVALID_ZONE         0x1116
#define SECURE_INST_OPCODE_TO_LARGE 0x1117
#define SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP  0x1118
#define SECURE_STORAGE_OUT_OF_RANGE 0x1119
#define SECURE_CONTOUR_OUT_OF_RANGE 0x111A
#define SECURE_CVT_OUT_OF_RANGE     0x111B
#define SECURE_UNITIALIZED_ZONE     0x111C


/* fsg_CalculateBBox */
#define POINT_MIGRATION_ERR         0x1201

/* sc_ScanChar */
#define BAD_START_POINT_ERR         0x1301
#define SCAN_ERR                    0x1302
#define BAD_SCAN_KIND_ERR           0x1303
#define BAD_POINT_INDEX_ERR         0x1304

#define SMART_DROP_OVERFLOW_ERR     0x1305


/** SFNT DATA ERROR and errors in sfnt.c **/
#define SFNT_DATA_ERR               0x1400
#define POINTS_DATA_ERR             0x1401
#define INSTRUCTION_SIZE_ERR        0x1402
#define CONTOUR_DATA_ERR            0x1403
#define GLYPH_INDEX_ERR             0x1404
#define BAD_MAGIC_ERR               0x1405
#define OUT_OF_RANGE_SUBTABLE       0x1406
#define UNKNOWN_COMPOSITE_VERSION   0x1407
#define CLIENT_RETURNED_NULL        0x1408
#define MISSING_SFNT_TABLE          0x1409
#define UNKNOWN_CMAP_FORMAT         0x140A
#define BAD_MAXP_DATA               0x140B
#define SFNT_RECURSIVE_COMPOSITE_ERR 0x140C
#define GLYF_TABLE_CORRUPTION_ERR   0x140D

/* spline call errors */
#define BAD_CALL_ERR                0x1500

#define TRASHED_OUTLINE_CACHE       0x1600

/* gray scale errors */
#define BAD_GRAY_LEVEL_ERR          0x1701
#define GRAY_OLD_BANDING_ERR        0x1703
#define GRAY_NO_OUTLINE_ERR         0x1704

/* embedded bitmap (sbit) errors */
#define SBIT_COMPONENT_MISSING_ERR  0x1801
#define SBIT_ROTATION_ERR           0x1802
#define SBIT_BANDING_ERR            0x1803
#define SBIT_OUTLINE_CACHE_ERR      0x1804

/* new transformation errors : */
#define TRAN_NULL_TRANSFORM_ERR     0x1901

/************ For Debugging *************/

#ifdef XXX
#define DEBUG_ON
pascal  Debug ()                     /* User break drop into Macsbug */
#ifdef  DEBUG_ON
extern  0xA9FF;
#else
{
    ;
}
#endif

#ifndef DEBUGGER
pascal void DEBUGGER(void) = 0xA9FF; 
#endif

#ifdef  LEAVEOUT
#ifndef DEBUGSTR
pascal  void DEBUGSTR (aString) int8 *aString; extern 0xABFF;
int8    *c2pstr ();
#define BugInfo( aString) DEBUGSTR( c2pstr(aString))
#endif
#endif

#endif  /* XXX */
/****************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fsglue.h ===
/*
	File:       fsglue.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1996. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

	      <>    12/15/95    CB      add fsg_UpdateAdvanceHeight
	   <11+>     7/17/90    MR      Change error return type to int
		<11>     7/13/90    MR      Declared function pointer prototypes, Debug fields for runtime
									range checking
		 <8>     6/21/90    MR      Add field for ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vectorMappingF
		 <6>      6/4/90    MR      Remove MVT
		 <5>      6/1/90    MR      Thus endeth the too-brief life of the MVT...
		 <4>      5/3/90    RB      adding support for new scan converter and decryption.
		 <3>     3/20/90    CL      Added function pointer for vector mapping
									Removed devRes field
									Added fpem field
		 <2>     2/27/90    CL      Change: The scaler handles both the old and new format
									simultaneously! It reconfigures itself during runtime !  Changed
									transformed width calculation.  Fixed transformed component bug.
	   <3.1>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Now it is legal to pass in zero as the address of
									memory when a piece of the sfnt is requested by the scaler. If
									this happens the scaler will simply exit with an error code !
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Added flag executeFontPgm, set in fs_NewSFNT
*/


/*** Offset table ***/

typedef struct {
	uint32 x;
	uint32 y;
	uint32 ox;
	uint32 oy;
	uint32 oox;
	uint32 ooy;
	uint32 onCurve;
	uint32 sp;
	uint32 ep;
	uint32 f;
	uint32 fc;        
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	uint32 pcr;
#endif
} fsg_OutlineFieldInfo;

typedef struct fsg_WorkSpaceAddr{
	 F26Dot6 *              pStack;                     /* Address of stack                  */
	 void *                 pGlyphOutlineBase;      /* Address of Glyph Outline Base     */
	 fnt_ElementType *  pGlyphElement;          /* Address of Glyph Element array    */
	 boolean *              pGlyphDataByteSet;      /* Address of ByteSet array          */
	 void *                 pvGlyphData;                /* Address of GlyphData array        */
	 void *                 pReusableMemoryMarker;  /* Address of reusable memory        */
} fsg_WorkSpaceAddr;

typedef struct fsg_WorkSpaceOffsets {
	uint32                  ulStackOffset;
	uint32                  ulGlyphOutlineOffset;
	uint32                  ulGlyphElementOffset;
	uint32                  ulGlyphDataByteSetOffset;
	uint32                  ulGlyphDataOffset;
	fsg_OutlineFieldInfo    GlyphOutlineFieldOffsets;
	 uint32                      ulReusableMemoryOffset;
	uint32                  ulMemoryBase6Offset;
	uint32                  ulMemoryBase7Offset;
	 uint32                      ulMemoryBase6Size;
	 uint32                      ulMemoryBase7Size;
} fsg_WorkSpaceOffsets;

typedef struct fsg_PrivateSpaceOffsets {
	 uint32                      offset_storage;
	 uint32                      offset_functions;
	 uint32                      offset_instrDefs;       /* <4> */
	 uint32                      offset_controlValues;
	 uint32                      offset_globalGS;
	 uint32                      offset_FontProgram;
	 uint32                      offset_PreProgram;
	 uint32                      offset_TwilightZone;
	 uint32                      offset_TwilightOutline;
	fsg_OutlineFieldInfo    TwilightOutlineFieldOffsets;
#ifdef FSCFG_SUBPIXEL
	 uint32                      offset_storageSubPixel;
	 uint32                      offset_functionsSubPixel;
	 uint32                      offset_instrDefsSubPixel;       /* <4> */
	 uint32                      offset_controlValuesSubPixel;
	 uint32                      offset_globalGSSubPixel;
	 uint32                      offset_TwilightZoneSubPixel;
	 uint32                      offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL
} fsg_PrivateSpaceOffsets;

typedef struct fsg_TransformRec {
	uint16              usEmResolution;     /* used to be int32 <4> */
	transMatrix         currentTMatrix;     /* Current Transform Matrix */
	boolean             bPhaseShift;        /* 45 degrees flag <4> */
	boolean             bPositiveSquare;    /* Transform is a positive square */
	boolean             bIntegerScaling;    /* Font uses integer scaling */
	Fixed               fxPixelDiameter;
	uint32              ulImageState;       /* is glyph rotated, stretched, etc. */
	boolean				bEmboldSimulation; 
	uint16	uBoldSimulHorShift;
} fsg_TransformRec;

/**********************/
/** MODULE INTERFACE **/
/**********************/

/*      Memory Management Routines  */

FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	 LocalMaxProfile *            pMaxProfile,    /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets);

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table    */
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace);

FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,      /* Cached sfnt information */
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram);  /* pointer to pre program   */

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets);

FS_PUBLIC void fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2);

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	 int32 *                     plSizeBitmap2);

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7);

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra);

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation);


/*      FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **			pFc,
	uint16 *            pNc);

FS_PUBLIC uint32      fsg_GetContourDataSize(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_DumpContourData(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 uint8 **               pbyOutline);

FS_PUBLIC void  fsg_RestoreContourData(
	 uint8 **               ppbyOutline,
	 F26Dot6 **             ppX,
	 F26Dot6 **             ppY,
	 int16 **               ppSp,
	 int16 **               ppEp,
	 uint8 **               ppOnCurve,
	 uint8 **               ppFc,
	 uint16 *               pNc);

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceWidth);

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceHeight);

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT);

FS_PUBLIC void  fsg_45DegreePhaseShift(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth);

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight);

FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing);

FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceWidth,
	 point *                devLeftSideBearing,
	 point *                LeftSideBearing,
	 point *                devLeftSideBearingLine,
	 point *                LeftSideBearingLine);

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceHeight,
	 point *                devTopSideBearing,
	 point *                TopSideBearing,
	 point *                devTopSideBearingLine,
	 point *                TopSideBearingLine);

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo);

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo);

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,     /* GlobalGS */
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16             usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16             usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *            psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *            psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	);

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC ErrorCode fsg_RunFontProgram(
	 void *                 globalGS,           /* GlobalGS */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_RunPreProgram (
	 sfac_ClientRec *   ClientInfo,
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table    */
	 fsg_TransformRec * TransformInfo,
	 void *                 pvGlobalGS,
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_GridFit (
	 sfac_ClientRec *   ClientInfo,      /* sfnt Client information     */
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table               */
	 fsg_TransformRec * TransformInfo,  /* Transformation information    */
	 void *                 pvGlobalGS,      /* GlobalGS                            */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc,
	 boolean                bUseHints,
	 uint16 *               pusScanType,
	 boolean *              pbGlyphHasOutline,
	 uint16 *               pusNonScaledAW,
	boolean                bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			    bSubPixel
#endif // FSCFG_SUBPIXEL
	 );

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void);
#endif

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel);


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\interp.h ===
/*
	 File:		 interp.h

	 Contains:	 Exports and constants used by TrueType Interpreter

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):
*/

#include 	"fnterr.h"

#define NOGRIDFITFLAG   1
#define DEFAULTFLAG     2
#define TUNED4SPFLAG	4

FS_PUBLIC ErrorCode itrp_SetDefaults (
    void *  pvGlobalGS,
    Fixed   fxPixelDiameter);

FS_PUBLIC void  itrp_UpdateGlobalGS(
    void *              pvGlobalGS, /* GlobalGS                             */
    void *              pvCVT,      /* Pointer to control value table       */
    void *              pvStore,    /* Pointer to storage                   */
    void *              pvFuncDef,  /* Pointer to function defintions       */
    void *              pvInstrDef, /* Pointer to instruction definitions   */
    void *              pvStack,    /* Pointer to the stack                 */
	 LocalMaxProfile *	maxp,
    uint16              cvtCount,
    uint32              ulLengthFontProgram, /* Length of font program      */
    void *              pvFontProgram, /* Pointer to font program           */
    uint32              ulLengthPreProgram, /* Length of pre program        */
    void *              pvPreProgram, /* Pointer to pre program             */
	ClientIDType        clientID);    /* User ID Number                     */

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void itrp_InitializeData (void);
#endif

FS_PUBLIC ErrorCode   itrp_ExecuteFontPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecutePrePgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecuteGlyphPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    uint8 *             ptr,
    uint8 *             eptr,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl);

FS_PUBLIC boolean itrp_bApplyHints(
    void *      pvGlobalGS);

FS_PUBLIC void  itrp_QueryScanInfo(
    void *      pvGlobalGS,
    uint16 *    pusScanType,
    uint16 *    pusScanControl);

FS_PUBLIC void	itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8		bCompositeFlag);

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster);

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\sbit.h ===
/*********************************************************************

      sbit.h -- Embedded Bitmap Module Export Definitions

      (c) Copyright 1993-1996  Microsoft Corp.  All rights reserved.

      01/12/96  claudebe    Vertical metrics support
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      01/05/94  deanb       Bitmap scaling state
      11/29/93  deanb       First cut 
 
**********************************************************************/

/*      SBIT Module State Definition    */

typedef struct
{
    uint32  ulStrikeOffset;         /* into bloc or bsca */
    uint32  ulMetricsOffset;        /* may be either table */
    uint32  ulBitmapOffset;         /* into bdat table */
    uint32  ulBitmapLength;         /* bytes of bdat data */
    uint32  ulOutMemSize;           /* bytes of bitmap output data */
    uint32  ulWorkMemSize;          /* bytes of pre-scaled,rotated bitmap data */
    uint32  ulReadMemSize;          /* bytes of extra memory, to read gray sbit under scaling or rotation */
    uint16  usTableState;           /* unsearched, bloc, bsca, or not found */
    uint16  usPpemX;                /* x pixels per Em */
    uint16  usPpemY;                /* y pixels per Em */
    uint16  usSubPpemX;             /* substitute x ppem for bitmap scaling */
    uint16  usSubPpemY;             /* substitute y ppem for bitmap scaling */
	uint16	usRotation;				/* 0=none; 1=90; 2=180; 3=270; 4=other */
    uint16  usMetricsType;          /* horiz, vert, or big */
    uint16  usMetricsTable;         /* bloc or bdat */
    uint16  usBitmapFormat;         /* bdat definitions */
    uint16  usHeight;               /* bitmap rows */
    uint16  usWidth;                /* bitmap columns */
    uint16  usAdvanceWidth;         /* advance width */
    uint16  usAdvanceHeight;        /* advance height */     /* NEW */
    uint16  usOriginalRowBytes;     /* bytes per row (padded long) */
    uint16  usExpandedRowBytes;     /* bytes per row after grayscale expansion (padded long) */
    uint16  usScaledHeight;         /* scaled bitmap rows */
    uint16  usScaledWidth;          /* scaled bitmap columns */
    uint16  usScaledRowBytes;       /* scaled bytes per row (padded long) */
    uint16  usOutRowBytes;          /* reported bytes per row (for rotation) */
    uint16  usShaveLeft;            /* white pixels on left of bbox in format 5 */
    uint16  usShaveRight;           /* white pixels on right of bbox in format 5 */
    uint16  usShaveTop;             /* white pixels on top of bbox in format 5 */   /* NEW */
    uint16  usShaveBottom;          /* white pixels on bottom of bbox in format 5 */  /* NEW */
	int16   sLSBearingX;            /* left side bearing */
	int16   sLSBearingY;            /* y coord of top left corner */ 
	int16   sTopSBearingX;          /* top side bearing X */ /* NEW */
	int16   sTopSBearingY;          /* top side bearing Y */ /* NEW */
    boolean bGlyphFound;            /* TRUE if glyph found in strike */
    boolean bMetricsValid;          /* TRUE when metrics have been read */
	uint16  usEmResolution;			/* needed when substituting missing metrics */ /* NEW */
	uint16	usBitDepth;				/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16	uBoldSimulHorShift;
	uint16	uBoldSimulVertShift;
} 
sbit_State;

/**********************************************************************/

/*      SBIT Export Prototypes      */

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16 	sBoldSimulHorShift,
    int16 	sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
);

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	uint16			usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode           /* 0 = not found, 1 = bloc, 2 = bsca */
);

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW 
);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (	/* NEW */
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH 
);

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvanceWidth,
    point           *pf26DevLeftSideBearing,
    point           *pf26LSB,
    point           *pf26DevAdvanceHeight, 	/* NEW */
    point           *pf26DevTopSideBearing,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize
);

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork
);


/**********************************************************************/

FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 suBoldSimulHorShift, int16 sBoldSimulVertShift);
#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\sbit.c ===
/*********************************************************************

      sbit.c -- Embedded Bitmap Module

      (c) Copyright 1993-96  Microsoft Corp.  All rights reserved.

      04/01/96  claudebe    adding support for embedded grayscale bitmap
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/31/95  deanb       memset unrotated bitmap to zero
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      12/21/94  deanb       rotation and vertical metrics support
      08/02/94  deanb       pf26DevLSB->y calculated correctly
      01/05/94  deanb       Bitmap scaling added
      11/29/93  deanb       First cut 
 
**********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for inttodot6 macro */
        
#include    "sfntaccs.h"            /* sfnt access functions */
#include    "sbit.h"                /* own function prototypes */

/**********************************************************************/

#define MAX_BIT_INDEX	8			/* maximum bit index in a byte */

/*  Local structure */

typedef struct
{
    uint8*  pbySrc;                 /* unrotated source bitmap (as read) */
    uint8*  pbyDst;                 /* rotated destination bitmap (as returned) */
    uint16  usSrcBytesPerRow;       /* source bitmap width */
    uint16  usDstBytesPerRow;       /* destination bitmap width */
    uint16  usSrcX;                 /* source horiz pixel index */
    uint16  usSrcY;                 /* destination horiz pixel index */
    uint16  usDstX;                 /* source vert pixel index */
    uint16  usDstY;                 /* destination vert pixel index */
	uint16	usBitDepth;				/* bit depth of source/destination bitmap */
} 
CopyBlock;

/**********************************************************************/

/*  Local prototypes  */

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead, 
    uint8           *pbyExpand 
);

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap );

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
);

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
);

FS_PRIVATE void CopyBit(
    CopyBlock* pcb );

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);



/**********************************************************************/
/***                                                                ***/
/***                       SBIT Functions                           ***/
/***                                                                ***/
/**********************************************************************/

/*  reset sbit state structure to default values */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16		sBoldSimulHorShift,
     int16		sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
	)
{
    pSbit->usPpemX = usPpemX;                       /* save requested ppem */
    pSbit->usPpemY = usPpemY;
    pSbit->usRotation = usRotation;                 /* used later on */

    pSbit->bGlyphFound = FALSE;
    pSbit->usTableState = SBIT_UN_SEARCHED;
    pSbit->usEmResolution = usEmResolution;

    /* with embedded bitmap, the emboldement is done before the rotation */
    pSbit->uBoldSimulHorShift = MABS(sBoldSimulHorShift); 
    pSbit->uBoldSimulVertShift = MABS(sBoldSimulVertShift); 
    if ((pSbit->usRotation == 1) || (pSbit->usRotation == 3))
    {
        /* with embedded bitmap, the emboldement is done before the rotation */
        uint16 temp;
        temp = pSbit->uBoldSimulHorShift;
        pSbit->uBoldSimulHorShift = pSbit->uBoldSimulVertShift;
        pSbit->uBoldSimulVertShift = temp;
    }
    return NO_ERR;
}

/**********************************************************************/

/*  Determine whether a glyph bitmap exists */

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint16          usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode )         /* 0 = not found, 1 = bloc, 2 = bsca */
{    
    ErrorCode   ReturnCode;

    *pusFoundCode = 0;                              /* default */
    if (pSbit->usRotation > 3)
    {
        return NO_ERR;                              /* can't match a general rotation */
    }


    if (pSbit->usTableState == SBIT_UN_SEARCHED)    /* new trans - 1st glyph */
    {
        ReturnCode = sfac_SearchForStrike (         /* look for a strike */
            pClientInfo,
            pSbit->usPpemX, 
            pSbit->usPpemY, 
			usOverScale,            /* outline magnification requested */
			&pSbit->usBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
            &pSbit->usTableState,                   /* may set to BLOC or BSCA */
            &pSbit->usSubPpemX,                     /* if BSCA us this ppem */
            &pSbit->usSubPpemY,
            &pSbit->ulStrikeOffset );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
    }

	*pusBitDepth = pSbit->usBitDepth;

    if ((pSbit->usTableState == SBIT_BLOC_FOUND) || 
        (pSbit->usTableState == SBIT_BSCA_FOUND))
    {
        ReturnCode = sfac_SearchForBitmap (         /* now look for this glyph */
            pClientInfo,
            usGlyphCode,
            pSbit->ulStrikeOffset,
            &pSbit->bGlyphFound,                    /* return values */
            &pSbit->usMetricsType,
            &pSbit->usMetricsTable,
            &pSbit->ulMetricsOffset,
            &pSbit->usBitmapFormat,
            &pSbit->ulBitmapOffset,
            &pSbit->ulBitmapLength );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
        
        if (pSbit->bGlyphFound)
        {
            if (pSbit->usTableState == SBIT_BLOC_FOUND)
            {
                *pusFoundCode = 1;
            }
            else
            {
                *pusFoundCode = 2;
            }
            pSbit->bMetricsValid = FALSE;
        }
    }
    return NO_ERR;
}


/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW )
{
    point       ptDevAdvW;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceWidth */
	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ptDevAdvW.x = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    ptDevAdvW.y = 0L;                           /* always zero for horizontal metrics */

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pf26DevAdvW->x = ptDevAdvW.x;
        pf26DevAdvW->y = ptDevAdvW.y;
		break;
	case 1:                                     /* 90 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.y;
        pf26DevAdvW->y = ptDevAdvW.x;
		break;
	case 2:                                     /* 180 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.x;
        pf26DevAdvW->y = -ptDevAdvW.y;
		break;
	case 3:                                     /* 270 degree rotation */
        pf26DevAdvW->x = ptDevAdvW.y;
        pf26DevAdvW->y = -ptDevAdvW.x;
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

	/* metrics without rotation */
    FS_ASSERT(((pSbit->usRotation == 0) || (pSbit->usRotation == 2)), "sbit_CalcDevHorMetrics called under rotation\n");

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        *pDevAdvanceWidthX = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX - INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	case 2:                                     /* 180 degree rotation */
        *pDevAdvanceWidthX = -INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = -INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX + INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
    

    return NO_ERR;
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH )
{
    point       ptDevAdvH;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceHeight */
	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

/* set x components to zero */

    ptDevAdvH.x = 0L;
    ptDevAdvH.y = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
        
     switch(pSbit->usRotation)                   /* handle 90 degree rotations */
    {
    case 0:                                     /* no rotation */
           pf26DevAdvH->x = ptDevAdvH.x;
           pf26DevAdvH->y = ptDevAdvH.y;
    	break;
    case 1:                                     /* 90 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.y;
           pf26DevAdvH->y = ptDevAdvH.x;
    	break;
    case 2:                                     /* 180 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.x;
           pf26DevAdvH->y = -ptDevAdvH.y;
    	break;
    case 3:                                     /* 270 degree rotation */
           pf26DevAdvH->x = ptDevAdvH.y;
           pf26DevAdvH->y = -ptDevAdvH.x;
    	break;
    default:                                    /* non 90 degree rotation */
    	return SBIT_ROTATION_ERR;
    }
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW,
    point           *pf26DevLSB,
    point           *pf26LSB,
    point           *pf26DevAdvH, 	/* NEW */
    point           *pf26DevTopSB,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize )
{
    ErrorCode   ReturnCode;
    uint32      ulOrgMemSize;               /* size of unscaled bitmap */
    uint32      ulExpMemSize;               /* size of unscaled bitmap after gray expansion */
    uint32      ulScaMemSize;               /* size of scaled bitmap */
    uint32      ulMaxMemSize;               /* size of larger of scaled, unscaled */
    
    F26Dot6     f26DevAdvWx;                /* unrotated metrics */
    F26Dot6     f26DevAdvWy;
    F26Dot6     f26DevLSBx;
    F26Dot6     f26DevLSBy;
    F26Dot6     f26DevAdvHx;                /* unrotated metrics */
    F26Dot6     f26DevAdvHy;
    F26Dot6     f26DevTopSBx;
    F26Dot6     f26DevTopSBy;
    int16       sTop;                       /* unrotated bounds */
    int16       sLeft;
    int16       sBottom;
    int16       sRight;
	uint16		usOutBitDepth;				/* number of bit per pixel in the output */

	if (pSbit->usBitDepth == 1)
	{
		usOutBitDepth = 1;
	} else {
		usOutBitDepth = 8;
	}

    ReturnCode = GetSbitMetrics(pSbit, pClientInfo);
    if (ReturnCode != NO_ERR) return ReturnCode;
    
    pSbit->usScaledWidth = UScaleX(pSbit, pSbit->usWidth);
    pSbit->usScaledHeight = UScaleY(pSbit, pSbit->usHeight);


    
    sTop = SScaleY(pSbit, pSbit->sLSBearingY);            /* calc scaled metrics */
    sLeft = SScaleX(pSbit, pSbit->sLSBearingX);
    sBottom = sTop - (int16)pSbit->usScaledHeight;
    sRight = sLeft + (int16)pSbit->usScaledWidth;

    f26DevAdvWx = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    f26DevAdvWy = 0L;                   /* always zero for horizontal metrics */
    f26DevAdvHx = 0L;                   /* always zero for vertical metrics */
    f26DevAdvHy = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
    f26DevLSBx = INTTODOT6(SScaleX(pSbit, pSbit->sLSBearingX));
    f26DevLSBy = INTTODOT6(SScaleY(pSbit, pSbit->sLSBearingY));
    f26DevTopSBx = INTTODOT6(SScaleX(pSbit, pSbit->sTopSBearingX));
    f26DevTopSBy = INTTODOT6(SScaleY(pSbit, pSbit->sTopSBearingY));

    pSbit->usOriginalRowBytes = ROWBYTESLONG(pSbit->usWidth * pSbit->usBitDepth);   /* keep unscaled */
    pSbit->usExpandedRowBytes = ROWBYTESLONG(pSbit->usWidth * usOutBitDepth);   /* keep unscaled */
    pSbit->usScaledRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);

	pSbit->ulReadMemSize = 0; /* size of extra memory, to read gray sbit under scaling or rotation */

    ulOrgMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usOriginalRowBytes;
    ulExpMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usExpandedRowBytes;
    ulScaMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usScaledRowBytes;
    if (ulExpMemSize >= ulScaMemSize)
    {
         ulMaxMemSize = ulExpMemSize;
    }
    else
    {
         ulMaxMemSize = ulScaMemSize;
    }

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pRect->top = sTop;                      /* return scaled metrics */
        pRect->left = sLeft;
        pRect->bottom = sBottom;
        pRect->right = sRight;

        pf26DevAdvW->x = f26DevAdvWx;
        pf26DevAdvW->y = f26DevAdvWy;
        pf26DevLSB->x = f26DevLSBx;
        pf26DevLSB->y = f26DevLSBy;
        pf26LSB->x = f26DevLSBx;
        pf26LSB->y = INTTODOT6(sTop);

        pf26DevAdvH->x = f26DevAdvHx;
        pf26DevAdvH->y = f26DevAdvHy;
        pf26DevTopSB->x = f26DevTopSBx;
        pf26DevTopSB->y = f26DevTopSBy;
        pf26TopSB->x = f26DevTopSBx;
        pf26TopSB->y = f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;

        if ((pSbit->usTableState == SBIT_BSCA_FOUND) || (pSbit->usBitDepth != 1))
        {
            pSbit->ulWorkMemSize = ulMaxMemSize;  /* room to read & scale or expand gray pixels */
			if (pSbit->usBitDepth != 1)
			{
				pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
				pSbit->ulReadMemSize = ulOrgMemSize;
			}
        }
        else
        {
            pSbit->ulWorkMemSize = 0L;
        }
		break;
	case 1:                                     /* 90 degree rotation */
        pRect->top = sRight;
        pRect->left = -sTop;
        pRect->bottom = sLeft;
        pRect->right = -sBottom;
        
        pf26DevAdvW->x = -f26DevAdvWy;
        pf26DevAdvW->y = f26DevAdvWx;
        pf26DevLSB->x = -f26DevLSBy;
        pf26DevLSB->y = f26DevLSBx + INTTODOT6(sRight - sLeft);
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(sRight) - f26DevLSBx;

        pf26DevAdvH->x = -f26DevAdvHy;
        pf26DevAdvH->y = f26DevAdvHx;
        pf26DevTopSB->x = -f26DevTopSBy;
        pf26DevTopSB->y = f26DevTopSBx + INTTODOT6(sRight - sLeft);

        pf26TopSB->x = INTTODOT6(-sTop) - f26DevTopSBy; 
        pf26TopSB->y = 0L; 	

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes; 
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 2:                                     /* 180 degree rotation */
        pRect->top = -sBottom;
        pRect->left = -sRight;
        pRect->bottom = -sTop;
        pRect->right = -sLeft;

        pf26DevAdvW->x = -f26DevAdvWx;
        pf26DevAdvW->y = -f26DevAdvWy;
        pf26DevLSB->x = -f26DevLSBx + INTTODOT6(sLeft - sRight);
        pf26DevLSB->y = -f26DevLSBy + INTTODOT6(sTop - sBottom);
        pf26LSB->x = -f26DevLSBx;
        pf26LSB->y = INTTODOT6(-sBottom);

        pf26DevAdvH->x = -f26DevAdvHx;
        pf26DevAdvH->y = -f26DevAdvHy;
        pf26DevTopSB->x = -f26DevTopSBx + INTTODOT6(sLeft - sRight);
        pf26DevTopSB->y = -f26DevTopSBy + INTTODOT6(sTop - sBottom);

		pf26TopSB->x = INTTODOT6(-sRight);	
        pf26TopSB->y = -f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 3:                                     /* 270 degree rotation */
        pRect->top = -sLeft;
        pRect->left = sBottom;
        pRect->bottom = -sRight;
        pRect->right = sTop;
        
        pf26DevAdvW->x = f26DevAdvWy;
        pf26DevAdvW->y = -f26DevAdvWx;
        pf26DevLSB->x = f26DevLSBy + INTTODOT6(sBottom - sTop);
        pf26DevLSB->y = -f26DevLSBx;
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(-sLeft) + f26DevLSBx;

        pf26DevAdvH->x = f26DevAdvHy;
        pf26DevAdvH->y = -f26DevAdvHx;
        pf26DevTopSB->x = f26DevTopSBy + INTTODOT6(sBottom - sTop);
        pf26DevTopSB->y = -f26DevTopSBx;

        pf26TopSB->x = INTTODOT6(sBottom) -INTTODOT6(sTop) -INTTODOT6(sTop) + f26DevTopSBy;
        pf26TopSB->y = 0L;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
        
    *pusRowBytes = pSbit->usOutRowBytes;
    *pulOutSize = pSbit->ulOutMemSize;          /* return mem requirement */
    *pulWorkSize = pSbit->ulWorkMemSize;
    return NO_ERR;
}

/******************************Public*Routine******************************\
*
* sbit_Embolden adapted from vTtfdEmboldenX
*
* Does emboldening in the x direction
*
* History:
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  24-Jun-1997 -by- Bodin Dresevic [BodinD]
* Stole from YungT
\**************************************************************************/

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)

/* embold only one pixel in the x direction */
#define DXABSBOLD 1

// array of masks for the last byte in a row

static uint8 gjMaskLeft[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static uint8 gjMaskRight[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1f, 0X3f, 0X7f };

//FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8   *pCur, *pyCur, *pyCurEnd, *pAdd, newByte;	

    uint8    beginMask, endMask;
    int32    i, j;
    int32    noOfValidBitsAtEndBold;
    int32    noOfValidBitsAtEndNormal;
    int32    noOfBytesForOneLineNormal;
    int32    noOfBytesForOneLineBold;
    int32   nBytesMore;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	// we want to embolden by sBoldSimulHorShift pixels horizontally(if sBoldSimulHorShift>0 then to the right; else to the left) along the base line 
    // and by sBoldSimulVertShift vertically(if sBoldSimulVertShift>0 then to the bottom; else to the top) )

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}


    noOfValidBitsAtEndBold = usBitmapWidth & 7; // styoo: same as noOfValidBitsAtEndBold = usBitmapWidth % 8

    // Before emboldening,the origninal image had scans of width
    // usBitmapWidth - sBoldSimulHorShift.

    noOfBytesForOneLineBold = CJ_MONOCHROME_SCAN(usBitmapWidth);
    if( sBoldSimulHorShift >= 0 ){
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - sBoldSimulHorShift);
        noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }
    else{
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - (-sBoldSimulHorShift));
        noOfValidBitsAtEndNormal = (usBitmapWidth - (-sBoldSimulHorShift)) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

//=============================================================================================================
	//Horizontal To Right
    if( sBoldSimulHorShift > 0){
        endMask = gjMaskLeft[noOfValidBitsAtEndNormal];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/
            

            pCur = &pyCur[noOfBytesForOneLineNormal - 1];
            *pCur &= endMask;

            pCur++;
            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = &pyCur[noOfBytesForOneLineBold - 1];

            while( pCur >= pyCur)
            {
                newByte = *pCur;
                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is 8, we need to borrow 2 bytes(current byte(0) and previous byte(-1))
                // if if sBoldSimulHorShift is 9, we need to borrow 3 bytes(current byte(0) and 2 previous bytes(-1,-2)
                nBytesMore = (sBoldSimulHorShift+7)/8;

                for(i = 1; i <= sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur-j < pyCur then out of bound
                        if(pCur-j < pyCur)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[-j] >> (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[-j] << (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur--;
            }

        // Special implementation for the last byte, styoo: don't need to borrow from previous byte

        }
    }

    //Horizontal To Left
    else if( sBoldSimulHorShift < 0){
        beginMask = gjMaskRight[8-(-sBoldSimulHorShift)];
        endMask = gjMaskLeft[noOfValidBitsAtEndBold];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
            *pCur &= beginMask;

            pCur = &pyCur[noOfBytesForOneLineBold-1];
            *pCur &= endMask;
            pCur++;

            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = pyCur;
            pyCurEnd = pyCur+(noOfBytesForOneLineBold-1);

            while( pCur <= pyCurEnd)
            {
                newByte = *pCur;

                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is -8, we need to borrow 2 bytes(current byte(0) and next byte(+1))
                // if if sBoldSimulHorShift is -9, we need to borrow 3 bytes(current byte(0) and 2 next bytes(+1,+2)
                nBytesMore = (-sBoldSimulHorShift+7)/8;

                for(i = 1; i <= -sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur+j > pyCur+usRowBytes then out of bound
                        if(pCur+j > pyCurEnd)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[j] << (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[j] >> (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur++;
            }

            // Special implementation for the last byte, styoo: don't need to borrow from previous byte


        }
    }
    // Vertical To the Bottom
	if( sBoldSimulVertShift > 0 ){
		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }

        //
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur -= usRowBytes;
		}

	}
    // Vertical To the Top
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur += usRowBytes;
		}
	}
}

/******************************Public*Routine******************************\
* sbit_EmboldenGray adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 newPix;
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels

            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur )
					    newPix += *(pCur-i);
			    }

                if (newPix >= usGrayLevels)
                    newPix = (uint8)(usGrayLevels -1);

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the leftt edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
				    if( (pCur+i) < pyCur+usBitmapWidth )
					    newPix += *(pCur+i);
			    }

                if (newPix >= usGrayLevels)
                    newPix = (uint8)(usGrayLevels -1);

                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
						newPix += *pAdd;
					else 
						break;
				}

				if (newPix >= usGrayLevels)
					newPix = (uint8)(usGrayLevels -1);

                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}

    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
						newPix += *pAdd;
					else 
						break;
				}

				if (newPix >= usGrayLevels)
					newPix = (uint8)(usGrayLevels -1);

                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}
}

#ifdef FSCFG_SUBPIXEL

#define MAX(a,b)        ((a) > (b) ? (a) : (b))

/******************************Public*Routine******************************\
* sbit_EmboldenSubPixel adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
	uint8 newPix;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }


	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the right side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur && *(pCur-i) )
                    {
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur-i);
					}
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the left side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the left edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
                    if( (pCur+i) < pyCur+usBitmapWidth && *(pCur+i) ){
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur+i);
                    }
			    }

                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
                    if(pAdd >= pyTopNormal){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
					else 
						break;
				}

                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}
    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
                    if(pAdd < pyBottomNormal+usRowBytes){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
                    else 
						break;
				}

                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/
/*  if scaling or rotating, read bitmap into workspace,               */
/*  fix it up and copy it to the output map                           */

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork )
{
    ErrorCode   ReturnCode;
    uint8       *pbyRead;
    uint8       *pbyExpand;
    CopyBlock   cb;                                 /* for bitmap rotations */
    uint16      usSrcXMax;
    uint16      usSrcYMax;

    MEMSET(pbyOut, 0, pSbit->ulOutMemSize);         /* always clear the output map */

    if ((pSbit->usRotation == 0) &&                 /* if no rotation */
        (pSbit->usTableState != SBIT_BSCA_FOUND))   /* and no scaling */
    {
		if (pSbit->usBitDepth != 1)
		{
			MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyOut;						 /* expand in the output */
		} else {
			pbyRead = pbyOut;                           /* read straight to output map */
			pbyExpand = NULL;							/* expansion memory not used in that case */
		}
    } else                                            /* if any rotation or scaling */
    {
        MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
		if (pSbit->usBitDepth != 1)
		{
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyWork + pSbit->ulReadMemSize;	/* expand in the work memory */
		} else {
			pbyRead = pbyWork;                          /* read into workspace */
			pbyExpand = pbyWork;						/* scaling done in pbyExpand */
		}
    }

    ReturnCode = GetSbitComponent (                 /* fetch the bitmap */
        pClientInfo,
        pSbit->ulStrikeOffset,
        pSbit->usBitmapFormat,                      /* root data only in state */
        pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
        pSbit->usHeight,
        pSbit->usWidth,
        pSbit->usShaveLeft,
        pSbit->usShaveRight,
        pSbit->usShaveTop,
        pSbit->usShaveBottom,
        0,                                          /* no offset for the root */
        0,
        pSbit->usOriginalRowBytes,
        pSbit->usExpandedRowBytes,
		pSbit->usBitDepth,
        pbyRead,
		pbyExpand);
            
    if (ReturnCode != NO_ERR) return ReturnCode;

    
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        ScaleVertical (
            pbyExpand, 
            pSbit->usExpandedRowBytes, 
            pSbit->usHeight, 
            pSbit->usScaledHeight );

        ScaleHorizontal (
            pbyExpand, 
            pSbit->usExpandedRowBytes,
            pSbit->usScaledRowBytes,
            pSbit->usBitDepth, 
            pSbit->usWidth, 
            pSbit->usScaledWidth,
            pSbit->usScaledHeight );
            
        if (pSbit->usRotation == 0)                         /* if no rotation */
        {
            MEMCPY (pbyOut, pbyExpand, pSbit->ulOutMemSize);  /* keep this one */
        }
		/* in the SBIT_BSCA_FOUND the bitmap was already scaled to the final usScaledWidth, no need for additional emboldment */
	} else {
		if ((pSbit->uBoldSimulHorShift != 0) || (pSbit->uBoldSimulVertShift != 0))
		{
			if (pSbit->usRotation == 0)                             /* if no rotation */
			{
				cb.pbySrc = pbyOut;
			} else 
			{
				cb.pbySrc = pbyExpand;
			}
    
			if (pSbit->usBitDepth == 1)
			{
				sbit_Embolden(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			} else {
				uint16 usGrayLevels = (0x01 << pSbit->usBitDepth) ; /* Max gray level index */
				sbit_EmboldenGray(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, usGrayLevels, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			}

		}
    }

    if (pSbit->usRotation == 0)                             /* if no rotation */
    {
        return NO_ERR;                                      /* done */
    }
    
    cb.pbySrc = pbyExpand;
    cb.pbyDst = pbyOut;
    cb.usSrcBytesPerRow = pSbit->usScaledRowBytes;
    cb.usDstBytesPerRow = pSbit->usOutRowBytes;

	cb.usBitDepth = 1;
	if (pSbit->usBitDepth != 1)
		cb.usBitDepth = 8;

    usSrcXMax = pSbit->usScaledWidth;
    usSrcYMax = pSbit->usScaledHeight;

   	switch(pSbit->usRotation)
	{
	case 1:                                     /* 90 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = cb.usSrcY;                          /* x' = y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = usSrcXMax - cb.usSrcX - 1;      /* y' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 2:                                     /* 180 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstY = usSrcYMax - cb.usSrcY - 1;          /* y' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstX = usSrcXMax - cb.usSrcX - 1;      /* x' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 3:                                     /* 270 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = usSrcYMax - cb.usSrcY - 1;          /* x' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = cb.usSrcX;                      /* y' = x */
                CopyBit(&cb);
            }
        }
		break;
	default:                                    /* shouldn't happen */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}


/**********************************************************************/

/*      Private Functions                                             */

/**********************************************************************/

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo
)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    if (pSbit->bMetricsValid)
    {
        return NO_ERR;                      /* already got 'em */
    }

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ReturnCode = sfac_ShaveSbitMetrics (
	    pClientInfo,
        pSbit->usBitmapFormat,
	    pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
		pSbit->usBitDepth,
    	&pSbit->usHeight,
    	&pSbit->usWidth,
        &pSbit->usShaveLeft,
        &pSbit->usShaveRight,
        &pSbit->usShaveTop,
        &pSbit->usShaveBottom,
    	&pSbit->sLSBearingX,
    	&pSbit->sLSBearingY,
    	&pSbit->sTopSBearingX,
    	&pSbit->sTopSBearingY);

    if (ReturnCode != NO_ERR) return ReturnCode;
        
    pSbit->bMetricsValid = TRUE;
    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAH;
	int16	sNonScaledTSB;

	ReturnCode = sfac_ReadGlyphVertMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAH,
		&sNonScaledTSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceHeight = UEmScaleY(pSbit, usNonScaledAH);

	pSbit->sTopSBearingX = pSbit->sLSBearingX;
	pSbit->sTopSBearingY = - SEmScaleY(pSbit, sNonScaledTSB);

    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAW;
	int16	sNonScaledLSB;

	ReturnCode = sfac_ReadGlyphHorMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAW,
		&sNonScaledLSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceWidth = UEmScaleX(pSbit, usNonScaledAW);

	pSbit->sLSBearingX = pSbit->sTopSBearingX;
	pSbit->sLSBearingY = SEmScaleY(pSbit, sNonScaledLSB);
	
    return NO_ERR;
}

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap )
{
	uint16          usCount;
	uint16			usBitIndex, usOriginalBitIndex;
	uint8			*pbyDstBitRow;
	uint8			*pbySrcBitRow;
	uint16			usMask, usShift, usMaxLevel;

	usMaxLevel = (0x01 << usBitDepth) -1; /* Max gray level index */

	if (usBitDepth == 2)
	{
		usMask = 0x03;
		usShift = 0x02;
		usOriginalBitIndex = ((usWidth -1) & 0x03) << 0x01;
	} else if (usBitDepth == 4)
	{
		usMask = 0x0F;
		usShift = 0x01;
		usOriginalBitIndex = ((usWidth -1) & 0x01) << 0x02;
	} else if (usBitDepth == 8)
	{
		usMask = 0xFF;
		usShift = 0x00;
		usOriginalBitIndex = 0; /* ((usWidth -1) & 0x00) << 0x03 */
	} else
	{
		return;
	}

	/* start from the end to be able to use overlapping memories */
	pbyDstBitRow = pbyDstBitMap + (long) (usHeight-1) * (long) usExpandedRowBytes;
	pbySrcBitRow = pbySrcBitMap + (long) (usHeight-1) * (long) usOriginalRowBytes;
	
	while (usHeight > 0)
	{
		pbyDstBitMap = pbyDstBitRow + (long)(usWidth -1);
		pbySrcBitMap = pbySrcBitRow + (long)((usWidth -1) >> usShift);
		usBitIndex = usOriginalBitIndex;

		*pbySrcBitMap = *pbySrcBitMap >> (MAX_BIT_INDEX - usBitDepth - usBitIndex);

		for (usCount = usWidth; usCount > 0; usCount--)
		{
			if (*pbyDstBitMap == 0)
			{
				/* 99.9% of the case */
				*pbyDstBitMap = *pbySrcBitMap & usMask;
			} else {
				*pbyDstBitMap = usMaxLevel - 
						(usMaxLevel - *pbyDstBitMap) * (usMaxLevel - *pbySrcBitMap & usMask) / usMaxLevel;
			}
			*pbySrcBitMap = *pbySrcBitMap >> usBitDepth;

			pbyDstBitMap--;
			if (usBitIndex == 0)
			{
				usBitIndex = MAX_BIT_INDEX;
				pbySrcBitMap--;
			}
			usBitIndex = usBitIndex - usBitDepth;

		}
		pbyDstBitRow -= usExpandedRowBytes;
		pbySrcBitRow -= usOriginalRowBytes;
		usHeight--;
	}
}
/**********************************************************************/

/*  This is the recursive composite routine */

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead,
    uint8           *pbyExpand )
{
    uint32          ulCompMetricsOffset;            /* component params */
    uint32          ulCompBitmapOffset;
    uint32          ulCompBitmapLength;
    uint16          usComponent;                    /* index counter */
    uint16          usCompCount;
    uint16          usCompGlyphCode;
    uint16          usCompXOff;
    uint16          usCompYOff;
    uint16          usCompMetricsType;
    uint16          usCompMetricsTable;
    uint16          usCompBitmapFormat;
    uint16          usCompHeight;
    uint16          usCompWidth;
    uint16          usCompShaveLeft;
    uint16          usCompShaveRight;
    uint16          usCompShaveTop;
    uint16          usCompShaveBottom;
    uint16          usCompAdvanceWidth;
    uint16          usCompAdvanceHeight;
    int16           sCompLSBearingX;
    int16           sCompLSBearingY;
    int16           sCompTopSBearingX;
    int16           sCompTopSBearingY;
    boolean         bCompGlyphFound;
   	boolean         bCompHorMetricsFound;
   	boolean         bCompVertMetricsFound;
    ErrorCode       ReturnCode;

		ReturnCode = sfac_GetSbitBitmap (               /* fetch the bitmap */
        pClientInfo,
        usBitmapFormat,
        ulBitmapOffset,
        ulBitmapLength,
        usHeight,
        usWidth,
        usShaveLeft,
        usShaveRight,
        usShaveTop,
        usShaveBottom,
        usXOffset,
        usYOffset,
        usOriginalRowBytes,
		usBitDepth,
        pbyRead,
        &usCompCount );                             /* zero for simple glyph */
            
    if (ReturnCode != NO_ERR) return ReturnCode;
    
	/* we expand after handling composite glyphs and before scaling and applying rotation */	
	if (usBitDepth != 1 && usCompCount == 0)
		ExpandSbitToBytePerPixel (
			usHeight,
			usWidth,
			usOriginalRowBytes,
			usExpandedRowBytes,
			usBitDepth,
			pbyRead,
			pbyExpand );

    if (usCompCount > 0)                            /* if composite glyph */
    {
        for (usComponent = 0; usComponent < usCompCount; usComponent++)
        {
			if (usBitDepth != 1)
			{
				/* for grayscale, the composition is done during expansion, I need to
				   clean the memory used to read between each component */
				MEMSET(pbyRead, 0, usOriginalRowBytes*usHeight);
			}
            ReturnCode = sfac_GetSbitComponentInfo (
                pClientInfo,
                usComponent,                        /* component index */
                ulBitmapOffset,
                ulBitmapLength,
                &usCompGlyphCode,                   /* return values */
                &usCompXOff,
                &usCompYOff );
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_SearchForBitmap (     /* look for component glyph */
                pClientInfo,
                usCompGlyphCode,
                ulStrikeOffset,                     /* same strike for all */
                &bCompGlyphFound,                   /* return values */
                &usCompMetricsType,
                &usCompMetricsTable,
                &ulCompMetricsOffset,
                &usCompBitmapFormat,
                &ulCompBitmapOffset,
                &ulCompBitmapLength );
            
            if (ReturnCode != NO_ERR) return ReturnCode;
            
            if (bCompGlyphFound == FALSE)           /* should be there! */
            {
                return SBIT_COMPONENT_MISSING_ERR;
            }

            ReturnCode = sfac_GetSbitMetrics (      /* get component's metrics */
                pClientInfo,
                usCompMetricsType,
                usCompMetricsTable,
                ulCompMetricsOffset,
                &usCompHeight,                      /* these matter */
                &usCompWidth,
                &sCompLSBearingX,                     /* these don't */
                &sCompLSBearingY,
                &sCompTopSBearingX,                     
                &sCompTopSBearingY,
                &usCompAdvanceWidth,
                &usCompAdvanceHeight,
   				&bCompHorMetricsFound,
   				&bCompVertMetricsFound	);
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_ShaveSbitMetrics (    /* shave white space for const metrics */
        	    pClientInfo,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
				usBitDepth,
            	&usCompHeight,
            	&usCompWidth,
                &usCompShaveLeft,
                &usCompShaveRight,
                &usCompShaveTop,
                &usCompShaveBottom,
            	&sCompLSBearingX,
            	&sCompLSBearingY,
            	&sCompTopSBearingX,
             	&sCompTopSBearingY );

            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = GetSbitComponent (         /* recurse here */
                pClientInfo,
                ulStrikeOffset,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
                usCompHeight,
                usCompWidth,
                usCompShaveLeft,
                usCompShaveRight,
                usCompShaveTop,
                usCompShaveBottom,
                (uint16)(usCompXOff + usXOffset + usCompShaveLeft),   /* for nesting */
                (uint16)(usCompYOff + usYOffset + usCompShaveTop),
                usOriginalRowBytes,                         /* same for all */
                usExpandedRowBytes,                         /* same for all */
				usBitDepth,
                pbyRead,
				pbyExpand);
            
            if (ReturnCode != NO_ERR) return ReturnCode;
        }
    }
    return NO_ERR;
}

/********************************************************************/

/*                  Bitmap Scaling Routines                         */

/********************************************************************/

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemX << 1; 
        ulValue += (uint32)pSbit->usSubPpemX;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemX << 1;
        usValue = (uint16)ulValue;
    }
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemY << 1; 
        ulValue += (uint32)pSbit->usSubPpemY;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemY << 1;
        usValue = (uint16)ulValue;
    }
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleX(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleX(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}

/********************************************************************/

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleY(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleY(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}


FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemX;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemX = pSbit->usSubPpemX;
    } else {
		usPpemX = pSbit->usPpemX;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemX << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemY;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemY = pSbit->usSubPpemY;
    } else {
		usPpemY = pSbit->usPpemY;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemY << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleX(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleX(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleY(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleY(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
)
{
    uint8 *pbyOrgRow;                   /* original data pointer */
    uint8 *pbyNewRow;                   /* new data pointer */
    uint16 usErrorTerm;                 /* for 'Bresenham' calculation */
    uint16 usLine;                      /* loop counter */

    usErrorTerm = usOrgHeight >> 1;                 /* used by both comp and exp */

    if (usOrgHeight > usNewHeight)                  /* Compress Vertical */
    {
        pbyOrgRow = pbyBitmap;
        pbyNewRow = pbyBitmap;

        for (usLine = 0; usLine < usNewHeight; usLine++)
        {
            while (usErrorTerm >= usNewHeight)
            {
                pbyOrgRow += usBytesPerRow;         /* skip a row */
                usErrorTerm -= usNewHeight;
            }
            if (pbyOrgRow != pbyNewRow)
            {
                MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
            }
            pbyNewRow += usBytesPerRow;
            usErrorTerm += usOrgHeight;
        }
        for (usLine = usNewHeight; usLine < usOrgHeight; usLine++)
        {
            MEMSET(pbyNewRow, 0, usBytesPerRow);    /* erase the leftover */
            pbyNewRow += usBytesPerRow;
        }
    }
    else if (usNewHeight > usOrgHeight)             /* Expand Vertical */
    {
        pbyOrgRow = pbyBitmap + (usOrgHeight - 1) * usBytesPerRow;
        pbyNewRow = pbyBitmap + (usNewHeight - 1) * usBytesPerRow;

        for (usLine = 0; usLine < usOrgHeight; usLine++)
        {
            usErrorTerm += usNewHeight;
            
            while (usErrorTerm >= usOrgHeight)      /* executes at least once */
            {
                if (pbyOrgRow != pbyNewRow)
                {
                    MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
                }
                pbyNewRow -= usBytesPerRow;
                usErrorTerm -= usOrgHeight;
            }
            pbyOrgRow -= usBytesPerRow;
        }
    }
}

/********************************************************************/

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
)
{
    uint8 *pbyOrgRow;               /* points to original row beginning */
    uint8 *pbyNewRow;               /* points to new row beginning */
    uint8 *pbyOrg;                  /* original data pointer */
    uint8 *pbyNew;                  /* new data pointer */
    uint8 byOrgData;                /* original data read 1 byte at a time */
    uint8 byNewData;                /* new data assembled bit by bit */

    uint16 usErrorTerm;             /* for 'Bresenham' calculation */
    uint16 usByte;                  /* to byte counter */
    uint16 usOrgBytes;              /* from width rounded up in bytes */
    uint16 usNewBytes;              /* to width rounded up in bytes */
    
    int16 sOrgBits;                 /* counts valid bits of from data */
    int16 sNewBits;                 /* counts valid bits of to data */
    int16 sOrgBitsInit;             /* valid original bits at row begin */
    int16 sNewBitsInit;             /* valid new bits at row begin */

    
	if (usBitDepth == 1)
	{
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;
			usNewBytes = (usNewWidth + 7) >> 3;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = 0;                           /* start at left edge */
				sNewBits = 0;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)
				{
					while (usErrorTerm >= usNewWidth)
					{
						sOrgBits--;                     /* skip a bit */
						usErrorTerm -= usNewWidth;
					}
					while (sOrgBits <= 0)               /* if out of data */
					{
						byOrgData = *pbyOrg++;          /*   then get some fresh */
						sOrgBits += 8;
					}
					byNewData <<= 1;                    /* new bit to lsb */
					byNewData |= (byOrgData >> (sOrgBits - 1)) & 1;
                
					sNewBits++;
					if (sNewBits == 8)                  /* if to data byte is full */
					{
						*pbyNew++ = byNewData;          /*   then write it out */
						sNewBits = 0;
						usByte++;                       /* loop counter */
					}
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = (usOrgWidth + 7) >> 3;
			sOrgBitsInit = (int16)((usOrgWidth + 7) & 0x07) - 7;
        
			usNewBytes = (usNewWidth + 7) >> 3;
			sNewBitsInit = 7 - (int16)((usNewWidth + 7) & 0x07);

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytes - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = sOrgBitsInit;                /* initially unaligned */
				sNewBits = sNewBitsInit;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)             /* for each output byte */
				{
					if (sOrgBits <= 0)                  /* if out of data */
					{
						byOrgData = *pbyOrg--;          /*   then get some fresh */
						sOrgBits += 8;
					}
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						byNewData >>= 1;                /* use the msb of byte */
						byNewData |= (byOrgData << (sOrgBits - 1)) & 0x80;
                    
						sNewBits++;
						if (sNewBits == 8)              /* if to data byte is full */
						{
							*pbyNew-- = byNewData;      /*   then write it out */
							sNewBits = 0;
							usByte++;                   /* loop counter */
						}
						usErrorTerm -= usOrgWidth;
					}
					sOrgBits--;                         /* get next bit */
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
    } else {											/* one byte per pixel */
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = 0;
				while (usByte < usNewWidth)
				{
					while (usErrorTerm >= usNewWidth)
					{
						pbyOrg++;                     /* skip a byte */
						usErrorTerm -= usNewWidth;
					}
					*pbyNew++ = *pbyOrg;
					usByte++;                       /* loop counter */
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = usOrgWidth;        
			usNewBytes = usNewWidth ;

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytesPerRow - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = usNewBytesPerRow;
				while (usByte > usNewBytes)
				{
					*pbyNew-- = 0;                      /* blank out the extra bytes on the right */
					usByte--;
				}
				while (usByte > 0)             /* for each output byte */
				{
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						*pbyNew-- = *pbyOrg;

						usByte--;                   /* loop counter */
						usErrorTerm -= usOrgWidth;
					}
					pbyOrg--;
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
	}
}

/********************************************************************/

FS_PRIVATE void CopyBit(
    CopyBlock* pcb )
{
    uint16  usSrcOffset;
    uint16  usSrcShift;
    uint16  usDstOffset;
    uint16  usDstShift;
    
    static  uint16 usByteMask[8] = 
        { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

/*  if speed becomes an issue, this next multiply could be moved up */
/*  to the calling routine, and placed outside the 'x' loop */

/*  if speed becomes an issue, the test between 1 bit and 1 byte per pixel */
/*  could be moved up to the calling routine */

	if (pcb->usBitDepth == 1)
	{
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + (pcb->usSrcX >> 3);
		usSrcShift = pcb->usSrcX & 0x0007;

		if (pcb->pbySrc[usSrcOffset] & usByteMask[usSrcShift])
		{
			usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + (pcb->usDstX >> 3);
			usDstShift = pcb->usDstX & 0x0007;
			pcb->pbyDst[usDstOffset] |= usByteMask[usDstShift];
		}
	} else {
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + pcb->usSrcX;
		usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + pcb->usDstX;
		pcb->pbyDst[usDstOffset] = pcb->pbySrc[usSrcOffset];
	}

}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scale.c ===
/****************************** Module Header ******************************\
* Module Name: Scale.c
*
* Created: 16-Oct-1992
*
* Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
*             (c) 1989-1999. Microsoft Corporation.
*
* All Rights Reserved
*
* History:
*  Tue 16-Oct-1992 09:53:51 -by-  Greg Hitchcock [gregh]
* Created.
*   
*	 7/10/99	BeatS	   Add support for native SP fonts, vertical RGB
*	 4/01/99	BeatS	   Implement alternative interpretation of TT instructions for SP
*	02/21/97    claudebe   scaled component in composite glyphs
*	12/14/95    claudebe   adding two private phantom points for vertical positionning
* .
\***************************************************************************/

#define FSCFG_INTERNAL

/* INCLUDES */

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "scale.h"

#include "stat.h"

/* Constants    */

/* use the lower ones for public phantom points */

// public phantom points moved to fnt.h more global use

/* private phantom points start here */

#define ORIGINPOINT 4
#define LEFTEDGEPOINT 5

#define TOPORIGINPOINT 6
#define TOPEDGEPOINT 7

#define CANTAKESHIFT    0x02000000

/* MACROS   */

/* d is half of the denumerator */
#define FROUND( x, n, d, s ) \
		((SHORTMUL (x, n) + (d)) >> s)

#define SROUND( x, n, d, halfd ) \
	(x < 0 ? -((SHORTMUL (-(x), (n)) + (halfd)) / (d)) : ((SHORTMUL ((x), (n)) + (halfd)) / (d)))

#define NUMBEROFCHARPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1)
#define NUMBEROFTOTALPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1 + PHANTOMCOUNT)

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define ORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + ORIGINPOINT)
#define LEFTEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTEDGEPOINT)

#define TOPORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPORIGINPOINT)
#define TOPEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPEDGEPOINT)

/* PROTOTYPES   */

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D);
FS_PRIVATE F26Dot6 scl_FRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_SRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_FixRound (fnt_ScaleRecord* rec, F26Dot6 value);

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints);

FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);
/* FUNCTIONS    */

#define BOLD_FACTOR 0x51e
#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )
#define POINTSPERINCH               72

void  multiplyForEmbold(long a, long b, long *highRes, long *lowRes)
{
    long lowA, highA, lowB, highB, temp1, temp2;

    lowA = a & 0xffff;
    highA = (a & 0xffff0000) >> 16;
    lowB = b & 0xffff;
    highB = (b & 0xffff0000) >> 16;

    *highRes = highA*highB;
    *lowRes = lowA*lowB;

    temp1 = highA*lowB;
    temp2 = lowA*highB;

    *highRes += (temp1 & 0xffff0000) >> 16;
    *highRes += (temp2 & 0xffff0000) >> 16;

    *lowRes += (temp1 & 0xffff) << 16;
    *lowRes += (temp2 & 0xffff) << 16;
}

void  adjustTrans(transMatrix *trans)   //Adjust matrix for Emboldening
{
    int i,j;
    int  bNegative;
    long tmp, highRes, lowRes;

    for(i=0; i<2; i++)
        for(j=0; j<2; j++){
        
        	tmp = (long) trans->transform[i][j];

            bNegative = tmp < 0 ? TRUE: FALSE;
            tmp = MABS(tmp);

            multiplyForEmbold(tmp, BOLD_FACTOR, &highRes, &lowRes);

            highRes <<= 16;
            tmp -= highRes;

            if(bNegative)
	            tmp = -tmp;

            trans->transform[i][j] = tmp;
        }
}

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm)         /* OUT: Pixels Per Em       */
{
	Fixed        maxScale;
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	transMatrix   origTrans = *trans;
	uint16		usRotation;
	boolean			non90degreeRotation,nonUniformStretching;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	mth_FoldPointSizeResolution(fxPointSize, sXResolution, sYResolution, trans);

	if ( ( (usEmboldWeightx != 0) || (usEmboldWeighty != 0))  && 							// Adjust matrix for Emboldening
		 (uint16)ROUNDFIXTOINT(ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH)) > 50 )// when bigger than 50 ppem
	{
        adjustTrans(trans);
    }

	mth_ReduceMatrix (trans);

	fxUpem = INTTOFIX(usUpem);

/*
 *  First set up the scalars...
 */

	/*save the flag for use in composite glyphs */
	globalGS->bHintAtEmSquare = bHintAtEmSquare;

	if (bHintAtEmSquare)
	{
		globalGS->interpScalarX = fxUpem;
		globalGS->interpScalarY = fxUpem;
		globalGS->fxMetricScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->fxMetricScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);

		/* we don't want to round the interpScalar */
	}
	else
	{
		globalGS->interpScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->interpScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);
		globalGS->fxMetricScalarX = globalGS->interpScalarX;
		globalGS->fxMetricScalarY = globalGS->interpScalarY;

		if (bIntegerScaling)
		{
			globalGS->interpScalarX = (Fixed)ROUNDFIXED(globalGS->interpScalarX);
			globalGS->interpScalarY = (Fixed)ROUNDFIXED(globalGS->interpScalarY);
		}
	}

	globalGS->ScaleFuncX = scl_ComputeScaling(&globalGS->scaleX, globalGS->interpScalarX, fxUpem);
	globalGS->ScaleFuncY = scl_ComputeScaling(&globalGS->scaleY, globalGS->interpScalarY, fxUpem);

	if ((globalGS->interpScalarX == 0) && (globalGS->interpScalarY == 0))
	{
		return TRAN_NULL_TRANSFORM_ERR;
	}
	if (globalGS->interpScalarX >= globalGS->interpScalarY)
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncX;
		globalGS->scaleCVT = globalGS->scaleX;
		globalGS->cvtStretchX = ONEFIX;
		globalGS->cvtStretchY = FixDiv(globalGS->interpScalarY, globalGS->interpScalarX);;
		maxScale = globalGS->interpScalarX;
	}
	else
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncY;
		globalGS->scaleCVT = globalGS->scaleY;
		globalGS->cvtStretchX = FixDiv(globalGS->interpScalarX, globalGS->interpScalarY);
		globalGS->cvtStretchY = ONEFIX;
		maxScale = globalGS->interpScalarY;
	}

	*pulPixelsPerEm = (uint32)ROUNDFIXTOINT (globalGS->interpScalarY);

	globalGS->bSameStretch  = (uint8)mth_SameStretch( globalGS->interpScalarX, globalGS->interpScalarY );
	globalGS->pixelsPerEm   = (uint16)ROUNDFIXTOINT(maxScale);
	globalGS->pointSize     = (uint16)ROUNDFIXTOINT( fxPointSize );
	globalGS->fpem          = maxScale;
	globalGS->identityTransformation = (int8)mth_PositiveSquare( trans );

	/* Use bit 1 of non90degreeTransformation to signify stretching.  stretch = 2 */

	mth_Non90DegreeTransformation(&origTrans,&non90degreeRotation,&nonUniformStretching);

	globalGS->non90DegreeTransformation = 0;

	if (non90degreeRotation)  globalGS->non90DegreeTransformation |= NON90DEGTRANS_ROTATED;
	if (nonUniformStretching) globalGS->non90DegreeTransformation |= NON90DEGTRANS_STRETCH;


	*psBoldSimulHorShift = 0;
	*psBoldSimulVertShift = 0;

	if ((usEmboldWeightx != 0) || (usEmboldWeighty != 0))
	{
		/* we cannot use globalGS->pixelsPerEm because it s incorrect under non 90degree rotation */
		uint16 ppemY;
		Fixed fxBoldSimulHorShift,fxBoldSimulVertShift;
		F26Dot6	fxDefaultDescender;
        transMatrix reverseTrans;
        Fixed   fxDeterminant;
		Fixed fxScale;

		fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
		ppemY = (uint16)ROUNDFIXTOINT(fxScale);  
		usRotation = mth_90degRotationFactor(trans);
		if( usRotation == 4 )   // Consider Italic/Bold case
            usRotation = mth_90degClosestRotationFactor(trans);

		if (bHintAtEmSquare)
		{
            *psBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000; /* save the number of pixels for bitmap emboldening */
			ppemY = usUpem;
		}

		/* this computation is intended to give backwards compatible results with the
			bitmap emboldening simulation done in Windows NT 4.0
		    The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
			for an emboldening factor of 2% (usEmboldWeight = 20)
		*/

		globalGS->uBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000;
		globalGS->uBoldSimulHorShift = (ppemY * usEmboldWeightx - 10) /1000 + 1;

		if (!bHintAtEmSquare)
		    *psBoldSimulVertShift = globalGS->uBoldSimulVertShift; /* save the number of pixels for bitmap emboldening */

 		switch(usRotation)                   /* handle 90 degree rotations */
		{
		case 0:                                     /* no rotation */
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift);
 			break;
		case 1:                                     /* 90 degree rotation */
			*psBoldSimulHorShift = -(*psBoldSimulVertShift);
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 2:                                     /* 180 degree rotation */
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = *psBoldSimulVertShift;
			break;
		case 3:                                     /* 270 degree rotation */
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		default:                                    /* non 90 degree rotation */
			*psBoldSimulHorShift = 0;
			*psBoldSimulVertShift = 0;
		}

		if (!bHintAtEmSquare && (sYResolution != sXResolution))
		{
			fxBoldSimulHorShift = globalGS->uBoldSimulHorShift << 16;
			fxBoldSimulVertShift = globalGS->uBoldSimulVertShift << 16;
            fxDeterminant = MABS( FixMul(origTrans.transform[0][0],origTrans.transform[1][1]) - FixMul(origTrans.transform[0][1],origTrans.transform[1][0]) );

			if (fxDeterminant == 0)
			{
				globalGS->uBoldSimulHorShift = 0;  
				globalGS->uBoldSimulVertShift = 0;  
			}
			else
			{
				origTrans.transform[0][0] = FixDiv(origTrans.transform[0][0], fxDeterminant);
				origTrans.transform[0][1] = FixDiv(origTrans.transform[0][1], fxDeterminant);
				origTrans.transform[1][0] = FixDiv(origTrans.transform[1][0], fxDeterminant);
				origTrans.transform[1][1] = FixDiv(origTrans.transform[1][1], fxDeterminant);
				reverseTrans = origTrans;
				reverseTrans.transform[0][1] = - reverseTrans.transform[0][1];
				reverseTrans.transform[1][0] = - reverseTrans.transform[1][0];

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&origTrans,
					ONEFIX,
					ONEFIX);

				fxBoldSimulHorShift = ShortMulDiv(fxBoldSimulHorShift, sXResolution, sYResolution);

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&reverseTrans,
					ONEFIX,
					ONEFIX);

				globalGS->uBoldSimulHorShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulHorShift));  
				globalGS->uBoldSimulVertShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulVertShift));  
			}

        }

		if (!(globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
		{
			/* 90 degree rotation, convert the device value into 26.6 */
			globalGS->fxScaledDescender = -lDescDev << 6;
		} else 
		{
			/* under rotation, we use the value from head-Descender and scale it */
			fxDefaultDescender = sWinDescender;

			scl_Scale (&globalGS->scaleY,
					globalGS->ScaleFuncY,
					&fxDefaultDescender,
					&globalGS->fxScaledDescender,
					1);

			/* add the uBoldSimulVertShift and round to the next pixel */
			globalGS->fxScaledDescender = globalGS->fxScaledDescender & ~(LOWSIXBITS);
		}
	} else {
		globalGS->uBoldSimulHorShift = 0;
		globalGS->uBoldSimulVertShift = 0;
		globalGS->fxScaledDescender = 0;
	}
	return NO_ERR;
}

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem)                 /* Current units per Em     */
{
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed           interpScalarX;    
	Fixed           interpScalarY;    

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	fxUpem = INTTOFIX(usUpem);

/* 
 * This procedure is a subset from scl_InitializeScaling. 
 * There is no perfect solution here, we decided that the best, in the case of a
 * component that is not at the same transformation as the master glyph,
 * is to scale this child glyph to the user grid for hinting, without re-running
 * the pre-program, without rescaling the cvt or changing other GloblaGS information (pointSize, pixelPerEm,...)
 */

/*
 *  First set up the scalars...
 */
	if (globalGS->bHintAtEmSquare)
	{
		interpScalarX = fxUpem;
		interpScalarY = fxUpem;
	}
	else
	{
		interpScalarX = mth_max_abs (CurrentTMatrix.transform[0][0], CurrentTMatrix.transform[0][1]);
		interpScalarY = mth_max_abs (CurrentTMatrix.transform[1][0], CurrentTMatrix.transform[1][1]);
	}

	globalGS->ScaleFuncXChild = scl_ComputeScaling(&globalGS->scaleXChild, interpScalarX, fxUpem);
	globalGS->ScaleFuncYChild = scl_ComputeScaling(&globalGS->scaleYChild, interpScalarY, fxUpem);

}

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->bHintForGray = bHintForGray;

#ifdef FSCFG_SUBPIXEL
	globalGS->flHintForSubPixel = flHintForSubPixel;
#endif // FSCFG_SUBPIXEL
}

/******************** These three scale 26.6 to 26.6 ********************/
/*
 * Fast (scaling)
 */
FS_PRIVATE F26Dot6 scl_FRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FROUND (value, rec->numer, rec->denom >> 1, rec->shift);
}

/*
 * Medium (scaling)
 */
FS_PRIVATE F26Dot6 scl_SRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	int32 D;

	D = rec->denom;
	return (F26Dot6) SROUND (value, rec->numer, D, D >> 1);
}

/*
 * Fixed Rounding (scaling), really slow
 */
FS_PRIVATE F26Dot6 scl_FixRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FixMul ((Fixed)value, rec->fixedScale);
}

/********************************* End scaling utilities ************************/

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D)
{
	int32     lShift;

	lShift = mth_CountLowZeros((uint32)(N | D) ) - 1;

	if (lShift > 0)
	{
		N >>= lShift;
		D >>= lShift;
	}


	if ( N < CANTAKESHIFT )
	{
		N <<= FNT_PIXELSHIFT;
	}
	else
	{
		D >>= FNT_PIXELSHIFT;
	}

	/* fixedScale is now set in every case for the scale back in scaled composites */
	rec->fixedScale = FixDiv(N, D);

	if (N <= SHRT_MAX)   /* Check to see if N fits in a short    */
	{
		lShift = mth_GetShift ((uint32) D);
		rec->numer = (int32)N;
		rec->denom = (int32)D;

		if ( lShift >= 0 )                  /* FAST SCALE */
		{
			rec->shift = (int32)lShift;
			return (GlobalGSScaleFunc)scl_FRound;
		}
		else                                /* MEDIUM SCALE */
		{
			return (GlobalGSScaleFunc)scl_SRound;
		}
	}
	else                                    /* SLOW SCALE */
	{
		return (GlobalGSScaleFunc)scl_FixRound;
	}
}


FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	if (ScaleFunc == scl_FRound)
	{
		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, sr->shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], sr->numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], sr->fixedScale);
			}
		}
	}
}


FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	Scale;
	int32	Shift;
	int32	Numer;

	/* we are now multiplying a 26.6 by sr->numer, we could overflow if (sr->numer >= SHRT_MAX >> FNT_PIXELSHIFT) */
	if ((ScaleFunc == scl_FRound) && (sr->numer < (SHRT_MAX >> FNT_PIXELSHIFT) ))
	{
		
		Shift = sr->shift + FNT_PIXELSHIFT;

		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, Shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			Numer = sr->numer >> FNT_PIXELSHIFT;

			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], Numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			Scale = sr->fixedScale >> FNT_PIXELSHIFT;
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], Scale);
			}
		}
	}
}

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	ScaleBack;

	ScaleBack = sr->fixedScale >> FNT_PIXELSHIFT;
	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (F26Dot6) FixDiv ((Fixed)oop[Index], ScaleBack);
	}
}

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (Fixed)oop[Index] << FNT_PIXELSHIFT;
	}
}

/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleOldCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}
/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleOldPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}

}

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;


	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	Assert(globalGS->bSameTransformAsMaster);

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ScaleFromFixedFUnits (&globalGS->scaleX,
			   globalGS->ScaleFuncX,
			   &(pElement->x[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ScaleFromFixedFUnits (&globalGS->scaleY,
			   globalGS->ScaleFuncY,
			   &(pElement->y[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

}

/*
 *  scl_ScaleBackCurrentCharPoints                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
}

/*
 *  scl_OriginalCharPointsToCurrentFixedFUnits                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{

	scl_ConvertToFixedFUnits (
			   pElement->oox,
			   pElement->x,
			   (int32)NUMBEROFCHARPOINTS(pElement));

	scl_ConvertToFixedFUnits (
			   pElement->ooy,
			   pElement->y,
			   (int32)NUMBEROFCHARPOINTS(pElement));
}

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{
	uint16                    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ConvertToFixedFUnits (
			   &(pElement->oox[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ConvertToFixedFUnits (
			   &(pElement->ooy[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);
}

/*
 * scl_ScaleCVT
 */

FS_PUBLIC void  scl_ScaleCVT(
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if(globalGS->cvtCount > 0)
	{
		scl_Scale (
			&globalGS->scaleCVT,
			globalGS->ScaleFuncCVT,
			pfxCVT,
			globalGS->controlValueTable,
			(int32)globalGS->cvtCount);
	}
}

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pfxCVT = globalGS->controlValueTable;

}

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH)  /* Non-scaled Advance Height    */
{

	F26Dot6             fxXMinMinusLSB;
	F26Dot6             fxYMaxPlusTSB;

	MEMSET (&(pElement->ooy[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->ooy[0]));

	MEMSET (&(pElement->oox[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->oox[0]));

	fxXMinMinusLSB = ((F26Dot6)bbox->xMin - (F26Dot6)sNonScaledLSB);

	pElement->oox[LSBPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[RSBPOINTNUM(pElement)] = fxXMinMinusLSB + (F26Dot6)usNonScaledAW;
	pElement->oox[ORIGINPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[LEFTEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->xMin;

	fxYMaxPlusTSB = ((F26Dot6)bbox->yMax + (F26Dot6)sNonScaledTSB);

	pElement->ooy[TOPSBPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[BOTTOMSBPOINTNUM(pElement)] = fxYMaxPlusTSB - (F26Dot6)usNonScaledAH;
	pElement->ooy[TOPORIGINPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[TOPEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->yMax;
}

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
	uint16      cNumCharPoints;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	cNumCharPoints = NUMBEROFCHARPOINTS(pElement);

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		0,
		cNumCharPoints);

}

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		LSBPOINTNUM(pElement),
		PHANTOMCOUNT);
}

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6 fxOldLeftOrigin;
	F26Dot6 fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	pElement->ox[LSBPOINTNUM(pElement)]  = fxNewLeftOrigin;
	pElement->ox[RSBPOINTNUM(pElement)] += fxNewLeftOrigin - fxOldLeftOrigin;
}

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->ox, pElement->x, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->oy, pElement->y, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->x, pElement->ox, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->y, pElement->oy, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	uint16    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);
	MEMCPY(&pElement->x[usFirstPhantomPoint],
		   &pElement->ox[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));

	MEMCPY(&pElement->y[usFirstPhantomPoint],
		   &pElement->oy[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution)
{
	F26Dot6     fxWidth;
	F26Dot6     fxHeight;
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	/* autoround the right side bearing */

	fxWidth = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarX,
		(int16)(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxWidth = globalGS->ScaleFuncX(&globalGS->scaleX,
		(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]));
*/

#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)  ) {
		fxWidth += VIRTUAL_PIXELSIZE_RTG / 2;
		fxWidth &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else { // for SubPixel in compatible width mode, always round to full pixel to get full pixel advance width
#endif
		fxWidth += FNT_PIXELSIZE / 2;
		fxWidth &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif
	pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + fxWidth;

	/* autoround the top side bearing */

	fxHeight = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarY,
		(int16)(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxHeight = globalGS->ScaleFuncY(&globalGS->scaleY,
		(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]));
*/

	/* in the vertical direction, as we don't round the old TOPSBPOINT 
	    and do scl_ShiftOldPoints, we need to round TOPSBPOINT here */
	pElement->y[TOPSBPOINTNUM(pElement)] =
		(pElement->y[TOPSBPOINTNUM(pElement)] + DOT6ONEHALF) & ~(LOWSIXBITS);

	pElement->y[BOTTOMSBPOINTNUM(pElement)] =
		pElement->y[TOPSBPOINTNUM(pElement)] + (fxHeight + DOT6ONEHALF) & ~(LOWSIXBITS);
}

/*
 *  scl_ShiftChar
 *
 *  Shifts a character          <3>
 */
FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift)

{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->x[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->y[ulCharIndex] += fxYShift;
		}
	}
}

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints)
{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->ox[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->oy[ulCharIndex] += fxYShift;
		}
	}
}

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset)         /* Y Offset             */
{
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed     scalarX;
	Fixed     scalarY;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (bSameTransformAsMaster) {
		*pfxXOffset = globalGS->ScaleFuncX(&globalGS->scaleX,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncY(&globalGS->scaleY,(F26Dot6)sYOffset);
	} else {
		*pfxXOffset = globalGS->ScaleFuncXChild(&globalGS->scaleXChild,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncYChild(&globalGS->scaleYChild,(F26Dot6)sYOffset);
	}

	if (bScaleCompositeOffset)
	/* the composite is designed to have its offset scaled (designed for Apple) */
	{
		/* Apple use a 45 degree special case that they are dropping on their GX rasterizer,
		   I'm not implementing this special rule here */
		scalarX = mth_max_abs (mulT.transform[0][0], mulT.transform[0][1]);
		scalarY = mth_max_abs (mulT.transform[1][0], mulT.transform[1][1]);
		if ((scalarX != ONEFIX) || (scalarY != ONEFIX)) {
			*pfxXOffset = (F26Dot6) FixMul ((Fixed)*pfxXOffset, scalarX);
			*pfxYOffset = (F26Dot6) FixMul ((Fixed)*pfxYOffset, scalarY);
		}
	}

	if (bRounding) {
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) != VerticalSPDirection(globalGS)))) {
			*pfxXOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxXOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxXOffset += FNT_PIXELSIZE / 2;
			*pfxXOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) == VerticalSPDirection(globalGS)))) {
			*pfxYOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxYOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxYOffset += FNT_PIXELSIZE / 2;
			*pfxYOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}
	if (!bSameTransformAsMaster)
	/* we need to scale back the offset in fixed FUnits */
	{
		scl_ScaleBack (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pfxXOffset,
				pfxXOffset,
				1 /* only one value to scale */);
		scl_ScaleBack (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pfxYOffset,
				pfxYOffset,
				1 /* only one value to scale */);
	}
}

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset)         /* Y Offset             */
{
	*pfxXOffset = pParentElement->x[usAnchorPoint1] - pChildElement->x[usAnchorPoint2];
	*pfxYOffset = pParentElement->y[usAnchorPoint1] - pChildElement->y[usAnchorPoint2];
}



FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pElement->x[usPhantomPointNumber] = pptLSB->x;
	pElement->y[usPhantomPointNumber] = pptLSB->y;
	usPhantomPointNumber++;
	pElement->x[usPhantomPointNumber] = pptRSB->x;
	pElement->y[usPhantomPointNumber] = pptRSB->y;
}

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pptLSB->x = pElement->x[usPhantomPointNumber];
	pptLSB->y = pElement->y[usPhantomPointNumber];
	usPhantomPointNumber++;
	pptRSB->x = pElement->x[usPhantomPointNumber];
	pptRSB->y = pElement->y[usPhantomPointNumber];
}

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,       /* Element  */
	int16               sMaxPoints,
	int16               sMaxContours)
{
	pElement->sp[0] = 0;
	pElement->ep[0] = sMaxPoints - 1;
	pElement->nc = sMaxContours;
}

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType * pElement,     /* Element pointer  */
	uint16      usNumberOfPoints,
	uint16      usNumberOfContours)
{

	MEMSET (&pElement->x[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->y[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ooy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->onCurve[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));
	MEMSET (&pElement->f[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));

	MEMSET (&pElement->sp[0], 0, (size_t)usNumberOfContours * sizeof(int16));
	MEMSET (&pElement->ep[0], 0, (size_t)usNumberOfContours * sizeof(int16));
}

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement)     /* Element pointer  */
{
	MEMSET (&pElement->f[0], 0, (size_t)NUMBEROFTOTALPOINTS(pElement) * sizeof(uint8));
}

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usParentNewStartPoint;

	if(pParentElement->nc != 0)
	{
		usParentNewStartPoint = LSBPOINTNUM(pParentElement);

		pChildElement->x = &pParentElement->x[usParentNewStartPoint];
		pChildElement->y = &pParentElement->y[usParentNewStartPoint];

		pChildElement->ox = &pParentElement->ox[usParentNewStartPoint];
		pChildElement->oy = &pParentElement->oy[usParentNewStartPoint];

		pChildElement->oox = &pParentElement->oox[usParentNewStartPoint];
		pChildElement->ooy = &pParentElement->ooy[usParentNewStartPoint];

		pChildElement->onCurve = &pParentElement->onCurve[usParentNewStartPoint];
		pChildElement->f = &pParentElement->f[usParentNewStartPoint];

		pChildElement->fc = &pParentElement->fc[pParentElement->nc];

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		pChildElement->pcr = &pParentElement->pcr[usParentNewStartPoint];
#endif

		pChildElement->sp = &pParentElement->sp[pParentElement->nc];
		pChildElement->ep = &pParentElement->ep[pParentElement->nc];

		pChildElement->nc = 0;
	}
	else
	{
		MEMCPY(pChildElement, pParentElement, sizeof(fnt_ElementType));
	}
}

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usNumberOfParentPoints;
	uint32          ulPointIndex;

	if(pParentElement->nc != 0)
	{
		usNumberOfParentPoints = NUMBEROFCHARPOINTS(pParentElement);

		for(ulPointIndex = (uint32)(uint16)pParentElement->nc;
			ulPointIndex < (uint32)(uint16)pParentElement->nc + (uint32)(uint16)pChildElement->nc;
			ulPointIndex++)
		{
			pParentElement->sp[ulPointIndex] += (int16)usNumberOfParentPoints;
			pParentElement->ep[ulPointIndex] += (int16)usNumberOfParentPoints;
		}
	}

	pParentElement->nc += pChildElement->nc;
}

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement)
{
	 uint16 usNumberOfPoints;
	 uint32 ulSize;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 ulSize =  sizeof( pElement->nc );
	 ulSize += sizeof( *pElement->sp ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->ep ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->x ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->y ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->onCurve ) * (size_t)usNumberOfPoints;

	 return( ulSize );
}

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 *((int16 *)*ppbyOutline) = pElement->nc;
	 *ppbyOutline += sizeof( pElement->nc   );

	 MEMCPY(*ppbyOutline, pElement->sp, (size_t)pElement->nc * sizeof( *pElement->sp ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->ep, (size_t)pElement->nc * sizeof( *pElement->ep ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->x, (size_t)usNumberOfPoints * sizeof(*pElement->x));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->x );

	 MEMCPY(*ppbyOutline, pElement->y, (size_t)usNumberOfPoints * sizeof(*pElement->y));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->y );

	 MEMCPY(*ppbyOutline, pElement->onCurve, (size_t)usNumberOfPoints * sizeof(*pElement->onCurve));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->onCurve );

}

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 pElement->nc = *((int16 *)(*ppbyOutline));
	 *ppbyOutline += sizeof( int16 );

	 pElement->sp = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 pElement->ep = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 pElement->x = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->y = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->onCurve = (uint8 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( uint8 );
}

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceWidth->x = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarX, (int16)usNonScaledAW, (int16)usEmResolution );
        if (AdvanceWidth->x != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceWidth->x = FixRatio( (int16)usNonScaledAW, (int16)usEmResolution );
        if ((globalGS->fxMetricScalarX != ONEFIX) && (globalGS->uBoldSimulHorShift != 0))
        {
            AdvanceWidth->x = FixMul(AdvanceWidth->x, globalGS->fxMetricScalarX);
            if (AdvanceWidth->x != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
            AdvanceWidth->x = FixDiv(AdvanceWidth->x, globalGS->fxMetricScalarX);
        }
        else
        {
            if (AdvanceWidth->x != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        }
		mth_FixXYMul( &AdvanceWidth->x, &AdvanceWidth->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceHeight->y = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarY, (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
		mth_FixXYMul( &AdvanceHeight->x, &AdvanceHeight->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing
)
{
	fnt_GlobalGraphicStateType *    globalGS;

	if ( bPositiveSquare )
	{
	    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
		pvecAdvanceHeight->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    (int16)usNonScaledAH, 
		    (int16)usEmResolution );
		
		pvecTopSideBearing->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    sNonScaledTSB, 
		    (int16)usEmResolution );
	}
	else
	{
		pvecAdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
		mth_FixXYMul( &pvecAdvanceHeight->x, &pvecAdvanceHeight->y, trans );

		pvecTopSideBearing->y = FixRatio( sNonScaledTSB, (int16)usEmResolution );
		mth_FixXYMul( &pvecTopSideBearing->x, &pvecTopSideBearing->y, trans );
	}
}


FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine)
{
	scl_CalcDevAdvanceWidth(pElement, devAdvanceWidth);

	devLeftSideBearing->x = f26XMin - pElement->x[LSBPOINTNUM(pElement)];
	devLeftSideBearing->y = f26YMax - pElement->y[LSBPOINTNUM(pElement)];

	LeftSideBearing->x = pElement->x[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->x -= pElement->x[ORIGINPOINTNUM(pElement)];
	LeftSideBearing->y = f26YMax - pElement->y[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->y -= pElement->y[ORIGINPOINTNUM(pElement)];

	*devLeftSideBearingLine = *devLeftSideBearing;
	*LeftSideBearingLine = *LeftSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth)

{
	devAdvanceWidth->x = pElement->x[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->x -= pElement->x[LSBPOINTNUM(pElement)];
	devAdvanceWidth->y = pElement->y[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->y -= pElement->y[LSBPOINTNUM(pElement)];
}

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine)
{
	scl_CalcDevAdvanceHeight(pElement, devAdvanceHeight);

	devTopSideBearing->x = f26XMin - pElement->x[TOPSBPOINTNUM(pElement)];
	devTopSideBearing->y = f26YMax - pElement->y[TOPSBPOINTNUM(pElement)];

	TopSideBearing->x = f26XMin - pElement->x[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->x -= pElement->x[TOPORIGINPOINTNUM(pElement)];
	TopSideBearing->y = pElement->y[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->y -= pElement->y[TOPORIGINPOINTNUM(pElement)];

	*devTopSideBearingLine = *devTopSideBearing;
	*TopSideBearingLine = *TopSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight)

{
	devAdvanceHeight->x = pElement->x[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->x -= pElement->x[BOTTOMSBPOINTNUM(pElement)];
	devAdvanceHeight->y = pElement->y[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->y -= pElement->y[BOTTOMSBPOINTNUM(pElement)];
}


FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEM = globalGS->pixelsPerEm;
}

/*  Return ppem in X and Y directions for sbits */

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEMX = (uint16)ROUNDFIXTOINT(globalGS->interpScalarX);
	*pusPPEMY = (uint16)ROUNDFIXTOINT(globalGS->interpScalarY);
}


FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement)
{
  F26Dot6 * x;
  int16     count;

  x = pElement->x;
  count = (int16)NUMBEROFCHARPOINTS(pElement) - 1;
  for (; count >= 0; --count)
  {
	(*x)++;
	++x;
  }
}

/*
 *  scl_PostTransformGlyph              <3>
 */
FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bHintAtEmSquare)
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
			globalGS->interpScalarX,
			globalGS->interpScalarY); 
	}
	else
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
	/*        globalGS->interpScalarX,
			globalGS->interpScalarY); */
			globalGS->fxMetricScalarX,
			globalGS->fxMetricScalarY);
	}
}

/*
 *  scl_ApplyTranslation              
 */
FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	int32 ulPointIndex;
	F26Dot6 xShift, yShift;

	/* transform from 16.16 to 26.6 */
	xShift = (trans->transform[0][2] + 0x200) >> 10;
	yShift = (trans->transform[1][2] + 0x200) >> 10;

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		xShift = xShift * RGB_OVERSCALE;
    }
#endif
	
	if (bUseHints && !bHintAtEmSquare) {
#ifdef FSCFG_SUBPIXEL
		if (bSubPixel) {
			/* We want to round to a virtual pixel boundary when hinted */ 
			xShift += VIRTUAL_PIXELSIZE_RTG/2; 
			xShift &= ~(VIRTUAL_PIXELSIZE_RTG - 1); 
		} else {
#endif
			/* We want to round to a pixel boundary when hinted */ 
			xShift += FNT_PIXELSIZE/2; 
			xShift &= ~(FNT_PIXELSIZE - 1); 
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}

	if (xShift != 0 || yShift != 0)
	{
		for(ulPointIndex = 0;
				ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
				ulPointIndex++)
		{
			pElement->x[ulPointIndex] += xShift;
			pElement->y[ulPointIndex] += yShift;
		}
	}

}
/*
 *      scl_LocalPostTransformGlyph                             <3>
 *
 * (1) Inverts the stretch from the CTM
 * (2) Applies the local transformation passed in in the trans parameter
 * (3) Applies the global stretch from the root CTM
 * (4) Restores oox, ooy, oy, ox, and f.
 */
FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans)
{
	int32 lCount;

	lCount = (int32)NUMBEROFTOTALPOINTS(pElement);

	mth_IntelMul (lCount, pElement->x, pElement->y, trans, ONEFIX, ONEFIX);
}

#ifdef FSCFG_SUBPIXEL

FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement)   /* Element  */
{
	int32 ulPointIndex;
	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->ox[ulPointIndex] = ROUND_RGB_OVERSCALE(pElement->x[ulPointIndex]);
	}
}

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale)  
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] = FixMul(pElement->x[ulPointIndex], fxCompatibleWidthScale);
	}
}


FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] += horTranslation;
	}
    pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + newDevAdvanceWidthX;
}


FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
	int32 ulPointIndex;
	F26Dot6 fxMaxX;             /* for bounding box left, right */

	*pDevLeftSideBearingX = LONG_MAX;     /* default bounds limits */
	fxMaxX = LONG_MIN;

	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]; 
	*pDevAdvanceWidthX -= pElement->x[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		if (pElement->x[ulPointIndex] > fxMaxX)
			fxMaxX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex] < *pDevLeftSideBearingX)
			*pDevLeftSideBearingX = pElement->x[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - fxMaxX;

}

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
	int32 ulPointIndex;

	*pDevLeftSideBearingX = LONG_MAX; *pDevRightSideBearingX = LONG_MIN;
	*pNatLeftSideBearingX = LONG_MAX; *pNatRightSideBearingX = LONG_MIN;
	
	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]  - pElement->x[LSBPOINTNUM(pElement)];
	*pNatAdvanceWidthX = pElement->ox[RSBPOINTNUM(pElement)] - pElement->ox[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0; ulPointIndex < NUMBEROFCHARPOINTS(pElement); ulPointIndex++) {
		if (pElement->x[ulPointIndex]  > *pDevRightSideBearingX) *pDevRightSideBearingX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex]  < *pDevLeftSideBearingX)  *pDevLeftSideBearingX  = pElement->x[ulPointIndex];
		if (pElement->ox[ulPointIndex] > *pNatRightSideBearingX) *pNatRightSideBearingX = pElement->ox[ulPointIndex];
		if (pElement->ox[ulPointIndex] < *pNatLeftSideBearingX)  *pNatLeftSideBearingX  = pElement->ox[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevRightSideBearingX;
    *pNatRightSideBearingX = *pNatAdvanceWidthX - *pNatRightSideBearingX;
} // scl_CalcDevNatHorMetrics

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scale.h ===
/*

	Copyright:  (c) 1992-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				7/10/99  BeatS	Add support for native SP fonts, vertical RGB
	   <1>     02/21/97    CB   claudebe, scaled component in composite glyphs
	   <1>     12/14/95    CB   add private phantom points for vertical positionning
*/

/* total number of phantom points */

typedef enum { evenMult90DRotation = 0, oddMult90DRotation, arbitraryRotation } RotationParity;

#define PHANTOMCOUNT 8

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm);        /* OUT: Pixels Per Em       */

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem);                 /* Current units per Em     */

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT);

FS_PUBLIC void  scl_ScaleCVT (
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT);

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH); /* Non-scaled Advance Height    */

FS_PUBLIC void  scl_ScaleOldCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleOldPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution);

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParityParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset);        /* Y Offset             */

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset);        /* Y Offset             */


FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             xShift,
	F26Dot6             yShift);

FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,
	int16               sMaxPoints,
	int16               sMaxContours);

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType *   pElement,           /* Element              */
	uint16              usNumberOfPoints,   /* Number of Points     */
	uint16              usNumberOfContours);/* Number of Contours   */

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement);            /* Element pointer  */

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement);

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               pbyOutline);

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline);

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing);

FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine);

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine);

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth);

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight);

FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY);

FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement);

FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans);

FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement);   /* Element  */

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scanlist.c ===
/*********************************************************************

	  scanlist.c -- New Scan Converter ScanList Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/22/93  deanb   all dropouts confined to bounding box
	   6/10/93  deanb   fsc_InitializeScanlist added, stdio & assert gone
	   4/26/93  deanb   fix pointers now works with segmented memory
	   4/19/93  deanb   banding added
	   4/07/93  deanb   sorting is now done on the fly
	   4/01/93  deanb   intersection arrays replace linked lists
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   memory requirements reworked
	  10/19/92  deanb   smart dropout tiebreak left & down
	  10/14/92  deanb   delete usScanKind from state
	  10/09/92  deanb   reentrant
	  10/08/92  deanb   reworked for split workspace
	  10/02/92  deanb   correct AddVertDropoutScan assertions
	   9/25/92  deanb   separate nodrop/dropout entry points
	   9/22/92  deanb   smart dropout control
	   9/17/92  deanb   stub control
	   9/15/92  deanb   simple dropout control
	   9/11/92  deanb   setupscan handles scankind
	   9/09/92  deanb   dropout / nodropout begun
	   8/17/92  deanb   include struc.h scconst.h
	   8/07/92  deanb   initial dropout control
	   8/06/92  deanb   assertions reinstated
	   7/27/92  deanb   bitmap clear added
	   7/16/92  deanb   gulBytesRemaining -> gulIntersectRemaining
	   6/18/92  deanb   int x coord for HorizScanAdd
	   6/01/92  deanb   incorporate bitmap functions
	   5/08/92  deanb   reordered includes for precompiled headers
	   5/04/92  deanb   Array tags added
	   4/28/92  deanb   list array sentinels added
	   4/21/92  deanb   single HorizScanAdd routine
	   4/15/92  deanb   calls to BitMap
	   4/13/92  deanb   uiY to iY for HorizScanOn/Off
	   4/09/92  deanb   New types
	   4/03/92  deanb   HorizScan On/Off coded
	   3/31/92  deanb   InitScanArray begun
	   3/25/92  deanb   GetWorkSizes and local types
	   3/23/92  deanb   First cut

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scbitmap.h"            /* bit blt operations */
#include    "scmemory.h"            /* for allocations */

/*********************************************************************/

/*      Contour reversal list structures                             */

/*********************************************************************/

typedef struct Rev                  /* Reversal list entry */
{
	int16 sScan;                    /* scan line */
	int16 sCross;                   /* direction +1 or -1 */
	struct Rev *prevLink;           /* link to next reversal */
}
Reversal;

struct RevRoots                     /* Reversal list roots */
{
	Reversal *prevYRoot;            /* Y direction contour reversals */
	Reversal *prevXRoot;            /* X direction contour reversals */
	Reversal *prevNext;             /* Next available list item */
	Reversal *prevEnd;              /* End of buffer (for overflow check) */
	struct RevRoots *prrSelf;       /* to check for moved memory */
};

#include    "scanlist.h"            /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void AddReversal (Reversal**, Reversal*, F26Dot6, int16);
FS_PRIVATE int32 GetIxEstimate(Reversal*);
FS_PRIVATE void FixPointers(PRevRoot);

FS_PRIVATE void AddHorizSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSimpleBand(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartBand(PSTATE int32, int32);

FS_PRIVATE int32 LookForDropouts(PSTATE char*, uint16);
FS_PRIVATE int32 DoHorizDropout(PSTATE int16*, int16*, int32, char*, uint16);
FS_PRIVATE int32 DoVertDropout(PSTATE int16*, int16*, int32, char*, uint16);

FS_PRIVATE int32 HorizCrossings(PSTATE int32, int32);
FS_PRIVATE int32 VertCrossings(PSTATE int32, int32);

FS_PRIVATE uint32 GetBitAbs(PSTATE char*, int32, int32);
FS_PRIVATE int32 SetBitAbs(PSTATE char*, int32, int32);


/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_InitializeScanlist()
{
	fsc_InitializeBitMasks();
}


/*********************************************************************/

/*      Contour Reversal Functions                                   */

/*********************************************************************/

/* setup the contour reversal list roots structure */

FS_PUBLIC PRevRoot  fsc_SetupRevRoots (
		char* pchRevBuf,
		int32 lRevBufSize )
{
	PRevRoot prrRoots;
	Reversal *prevSentinel;
	
	prrRoots = (PRevRoot) pchRevBuf;                /* workspace begin */
	prevSentinel = (Reversal*) (prrRoots + 1);      /* just past the roots */

	prrRoots->prevYRoot = prevSentinel;             /* point to sentinel */
	prrRoots->prevXRoot = prevSentinel;             /* for both lists */
	prevSentinel->sScan = HUGEINT;                  /* stop value */
	prevSentinel->sCross = 0;
	prevSentinel->prevLink = NULL;
	prrRoots->prevNext = prevSentinel + 1;          /* to next free record */
	
	prrRoots->prevEnd = (Reversal*)(pchRevBuf + lRevBufSize);
	prrRoots->prrSelf = prrRoots;                   /* for address validation */
	
	return prrRoots;
}

/*********************************************************************/

/* insert into y list one countour reversal structure */

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevYRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x list one countour reversal structure */

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevXRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x or y list one countour reversal structure */

FS_PRIVATE void AddReversal (
		Reversal **pprevList,
		Reversal *prevNext,
		F26Dot6 fxCoord,
		int16 sDir )
{
	int16 sScan;

	sScan = (int16)((fxCoord + SUBHALF + (sDir >> 1)) >> SUBSHFT);

	while(sScan > (*pprevList)->sScan)          /* will stop before sentinel */
	{
		pprevList = &((*pprevList)->prevLink);  /* else link to next */
	}
	prevNext->sScan = sScan;                    /* save scanline */
	prevNext->sCross = -sDir;                   /* count up from bottom */
	prevNext->prevLink = *pprevList;            /* link rest of list */

	*pprevList = prevNext;                      /* insert new item */
}

/*********************************************************************/

/* return the total number of reversals in the lists */

FS_PUBLIC int32 fsc_GetReversalCount (PRevRoot prrRoots)
{
	return (int32)(( prrRoots->prevNext - 1 -           /* don't count sentinel */
			 (Reversal*)((char*)prrRoots + sizeof(struct RevRoots))) );
}

/*********************************************************************/

/* calculate anticipated horizontal intersections */

FS_PUBLIC int32 fsc_GetHIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevYRoot ) );
}

/*********************************************************************/

/* calculate anticipated vertical intersections */

FS_PUBLIC int32 fsc_GetVIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevXRoot ) );
}

/*********************************************************************/

/* calculate anticipated intersections */

FS_PRIVATE int32 GetIxEstimate(Reversal *prevList)
{
	int32 lTotalIx;
	
	lTotalIx = 0L;
	while (prevList->sScan < HUGEINT)       /* look through list */
	{
		if (prevList->sCross == 1)          /* adding up columns! */
		{
			lTotalIx -= (int32)prevList->sScan;
		}
		else
		{
			lTotalIx += (int32)prevList->sScan;
		}
		prevList = prevList->prevLink;
	}
	return(lTotalIx);
}

/*********************************************************************/

/* calculate horizontal intersections for banding */

FS_PUBLIC int32 fsc_GetHIxBandEst(
		PRevRoot prrRoots,
		Rect* prectBox,
		  int32 lBandWidth
)
{
	Reversal *prevHiList;               /* high band reversal pointer */
	Reversal *prevLoList;               /* low band reversal pointer */
	int16 sHiScan;                      /* current top of band */
	int16 sLoScan;                      /* current bottom of band */
	int16 sHiCross;                     /* top of band's crossings */
	int16 sLoCross;                     /* bottom of band's crossings*/
	int32 lTotalIx;                     /* intersection count for each band */
	int32 lBiggestIx;                   /* largest intersection count */

	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	lTotalIx = 0;
	prevHiList = prrRoots->prevYRoot;
	sHiScan = prectBox->bottom;
	sHiCross = 0;
	while (lBandWidth > 0)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in this line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)sHiCross;            /* add up first band's crossings */
		sHiScan++;
		lBandWidth--;
	}
	lBiggestIx = lTotalIx;

	prevLoList = prrRoots->prevYRoot;
	sLoScan = prectBox->bottom;
	sLoCross = 0;
	while (sHiScan < prectBox->top)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in high line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		while (prevLoList->sScan <= sLoScan)
		{
			sLoCross += prevLoList->sCross;     /* add in low line's crossings */
			prevLoList = prevLoList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)(sHiCross - sLoCross);
		if (lTotalIx > lBiggestIx)
		{
			lBiggestIx = lTotalIx;              /* save the largest value */
		}
		sHiScan++;
		sLoScan++;
	}
	return(lBiggestIx);
}

/*********************************************************************/

/*      return number of bytes used by reversal lists                */

FS_PUBLIC int32 fsc_GetRevMemSize(PRevRoot prrRoots)
{
	return (int32)((char*)(prrRoots->prevNext) - (char*)prrRoots);
}

/*********************************************************************/

/*  when reversal list has moved, recalculate the pointers           */

FS_PRIVATE void FixPointers(PRevRoot prrRoots)
{
	char *pchNewBase;
	char *pchOldBase;
	Reversal *prevList;

	pchNewBase = (char*)prrRoots;
	pchOldBase = (char*)prrRoots->prrSelf;          /* pre-move base addr */

	prrRoots->prevYRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevYRoot - pchOldBase));
	prrRoots->prevXRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevXRoot - pchOldBase));
	prrRoots->prevNext = (Reversal*)(pchNewBase + ((char*)prrRoots->prevNext - pchOldBase));
	prrRoots->prevEnd = (Reversal*)(pchNewBase + ((char*)prrRoots->prevEnd - pchOldBase));
	
	prevList = prrRoots->prevYRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prevList = prrRoots->prevXRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prrRoots->prrSelf = prrRoots;                   /* for next time */
}

/*********************************************************************/

/*      Workspace Calcluation Functions                              */

/*********************************************************************/

/* calculate horizontal scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanHMem(
		uint16 usScanKind,      /* scan type */
		int32 lHScan,           /* number of horiz scanlines */
		int32 lHInter )         /* number of horiz intersections */
{
	ALIGN(voidPtr, lHScan); 
	ALIGN(voidPtr, lHInter ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lHScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lHScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (4 * sizeof(int16)));     /* for ix/code arrays */
	}
}


/*********************************************************************/

/* calculate vertical scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanVMem(
		uint16 usScanKind,      /* scan type */
		int32 lVScan,           /* number of vert scanlines */
		int32 lVInter,          /* number of vert intersections */
		int32 lElemPts )        /* number of contour element points */
{
	ALIGN(voidPtr, lVScan); 
	ALIGN(voidPtr, lVInter); 
	ALIGN(voidPtr, lElemPts ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lVScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lVScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (4 * sizeof(int16)) +     /* for ix/code arrays */
				lElemPts * (2 * sizeof(F26Dot6)));  /* for element (x, y) */
	}
}

/*********************************************************************/

/*      Scan Conversion Preparation Functions                        */

/*********************************************************************/

/*  Line, Spline, and Endpoint register their callbacks here */

FS_PUBLIC void fsc_SetupCallBacks(
		PSTATE                       /* pointer to state variables */
		int16 sCode,                 /* element code (line, spline, endpoint) */
		F26Dot6 (*pfnHoriz)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*pfnVert)(int32, F26Dot6*, F26Dot6*)     /* vert callback */
)
{
	STATE.pfnHCallBack[sCode] = pfnHoriz;
	STATE.pfnVCallBack[sCode] = pfnVert;
}


/*********************************************************************/

/*  Allocate scan workspace memory and set up pointer arrays */

FS_PUBLIC int32 fsc_SetupScan(
		PSTATE                      /* pointer to state variables */
		Rect* prectBox,             /* bounding box */
		uint16 usScanKind,          /* dropout control value */
		int32 lHiBand,              /* top scan limit */
		int32 lLoBand,              /* bottom scan limit */
		boolean bSaveRow,           /* save last bitmap row for dropout */
		int32 lRowBytes,            /* for last row alloc */
		int32 lHInterCount,         /* estimate of horiz intersections */
		int32 lVInterCount,         /* estimate of vert intersections */
		int32 lElemCount,           /* estimate of element points */
		PRevRoot prrRoots           /* reversal list roots */
)
{
	int32 lHorizBandCount;          /* number of horizontal scan lines */
	int32 lVertScanCount;           /* number of vertical scan lines */
	int32 lPointerArraySize;        /* bytes per pointer array */

	int16 sScan;                    /* current scan line */
	int16 sCross;                   /* crossings on this line */
	int16 *psScanIx;                /* temp scan intersection array */
	Reversal *prevList;             /* pointer to reversal list */
	
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
	int16 **ppsHOffEnd;
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffBegin;
	int16 **ppsVOffEnd;


	STATE.lBoxTop = (int32)prectBox->top;   /* copy the bounding box */
	STATE.lBoxBottom = (int32)prectBox->bottom;
	STATE.lBoxLeft = (int32)prectBox->left;
	STATE.lBoxRight = (int32)prectBox->right;
	
	STATE.lHiScanBand = lHiBand;    /* copy scan band limits */
	STATE.lLoScanBand = lLoBand;
	
/*  set STATE according to dropout and banding requirements */

	if ((usScanKind & SK_NODROPOUT) || !(usScanKind & SK_SMART))
	{
		STATE.sIxSize = 1;          /* one int16 per intersection */
		STATE.sIxShift = 0;         /* log2 of size */

		if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
		{
			STATE.pfnAddHoriz = AddHorizSimpleScan;
		}
		else    /* if banding */
		{
			STATE.pfnAddHoriz = AddHorizSimpleBand;
		}
		STATE.pfnAddVert = AddVertSimpleScan;
	}
	else        /* if smart dropout */
	{
		STATE.sIxSize = 2;          /* two int16's per intersection */
		STATE.sIxShift = 1;         /* log2 of size */

		if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
		{
			STATE.pfnAddHoriz = AddHorizSmartScan;
		}
		else    /* if banding */
		{
			STATE.pfnAddHoriz = AddHorizSmartBand;
		}
		STATE.pfnAddVert = AddVertSmartScan;
	}

/* setup horizontal intersection array for all cases */
	
	lHorizBandCount = STATE.lHiScanBand - STATE.lLoScanBand;
	Assert(lHorizBandCount > 0);
	
	lPointerArraySize = lHorizBandCount * sizeof(int16*);
	STATE.apsHOnBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOffBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOnEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOffEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	
	STATE.lPoint = 0L;                      /* initial element index */
	STATE.lElementPoints = lElemCount;

	psScanIx = (int16*) fsc_AllocHMem(ASTATE lHInterCount << (STATE.sIxShift + 2));
			
	if (prrRoots != prrRoots->prrSelf)      /* if reversals have moved */
	{
		FixPointers(prrRoots);              /* then patch up the pointers */
	}
	prevList = prrRoots->prevYRoot;         /* root of y list reversals */
	sCross = 0;
	
	ppsHOnBegin = STATE.apsHOnBegin;        /* for init speed */
	ppsHOnEnd = STATE.apsHOnEnd;
	ppsHOffBegin = STATE.apsHOffBegin;
	ppsHOffEnd = STATE.apsHOffEnd;

/* initialize horizontal scan arrays */
	
	for (sScan = (int16)STATE.lLoScanBand; sScan < (int16)STATE.lHiScanBand; sScan++)
	{
		while (prevList->sScan <= sScan)
		{
			sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
			prevList = prevList->prevLink;                  /* link to next reversal */
		}
		*ppsHOnBegin = psScanIx;
		ppsHOnBegin++;
		*ppsHOnEnd = psScanIx;
		ppsHOnEnd++;
		psScanIx += sCross;
				
		*ppsHOffBegin = psScanIx;
		ppsHOffBegin++;
		*ppsHOffEnd = psScanIx;
		ppsHOffEnd++;
		psScanIx += sCross;
	}
	
/* if doing dropout control, setup X intersection array */

	if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
	{
		lVertScanCount = (int32)(prectBox->right - prectBox->left);
		Assert(lVertScanCount > 0);

		lPointerArraySize = lVertScanCount * sizeof(int16*);
		STATE.apsVOnBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOffBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOnEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOffEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);

		if (bSaveRow)                           /* if fast banding & dropout */
		{
			STATE.pulLastRow = (uint32*) fsc_AllocVMem(ASTATE lRowBytes);
			STATE.lLastRowIndex = HUGEFIX;      /* impossible value => uninitialized */
		}
		psScanIx = (int16*) fsc_AllocVMem(ASTATE lVInterCount << (STATE.sIxShift + 2));
				
		prevList = prrRoots->prevXRoot;         /* root of x list reversals */
		sCross = 0;
		sScan = prectBox->left;
	
		ppsVOnBegin = STATE.apsVOnBegin;        /* for init speed */
		ppsVOnEnd = STATE.apsVOnEnd;
		ppsVOffBegin = STATE.apsVOffBegin;
		ppsVOffEnd = STATE.apsVOffEnd;
	
		for (sScan = prectBox->left; sScan < prectBox->right; sScan++)
		{
			while (prevList->sScan <= sScan)
			{
				sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
				prevList = prevList->prevLink;                  /* link to next reversal */
			}
			*ppsVOnBegin = psScanIx;
			ppsVOnBegin++;
			*ppsVOnEnd = psScanIx;
			ppsVOnEnd++;
			psScanIx += sCross;
					
			*ppsVOffBegin = psScanIx;
			ppsVOffBegin++;
			*ppsVOffEnd = psScanIx;
			ppsVOffEnd++;
			psScanIx += sCross;
		}
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
			STATE.afxXPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
			STATE.afxYPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/* This function saves the first contour point for smart dropout calcs */

FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                              /* pointer to state variables */
		uint16 usScanKind,                  /* scan type */
		F26Dot6 fxX1,                       /* starting point x coordinate */
		F26Dot6 fxY1                        /* starting point y coordinate */
)
{
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART)) /* if smart dropout */
	{
		STATE.afxXPoints[STATE.lPoint] = fxX1;
		STATE.afxYPoints[STATE.lPoint] = fxY1;
		STATE.lPoint++;
		Assert (STATE.lPoint <= STATE.lElementPoints);
	}
}

/*********************************************************************/
	
/* This function is called at the beginning of each line, subdivided */
/* spline, or endpoint-on-scanline.  It sets scanline state variables, */
/* save control points (for smart dropout control), and return the */
/* appropriate AddScan function pointers */

FS_PUBLIC void fsc_BeginElement(
	PSTATE                                      /* pointer to state variables */
	uint16 usScanKind,                          /* type of dropout control */
	int32 lQuadrant,                            /* determines scan on/off */
	int32 lElementCode,                         /* element (line, spline, ep) */
	int32 lPts,                                 /* number of points to store */
	F26Dot6 *pfxX,                              /* next x control point(s) */
	F26Dot6 *pfxY,                              /* next y control point(s) */
	void (**ppfnAddHorizScan)(PSTATE int32, int32),  /* horiz add scan return */
	void (**ppfnAddVertScan)(PSTATE int32, int32)    /* vert add scan return */
)
{
	*ppfnAddHorizScan = STATE.pfnAddHoriz;      /* set horiz add scan func */
	*ppfnAddVertScan = STATE.pfnAddVert;        /* set vert add scan func */

	
	if ((lQuadrant == 1) || (lQuadrant == 2))
	{
		STATE.apsHorizBegin = STATE.apsHOnBegin;    /* add 'on' interscections */
		STATE.apsHorizEnd = STATE.apsHOnEnd;
	}
	else
	{
		STATE.apsHorizBegin = STATE.apsHOffBegin;   /* add 'off' interscections */
		STATE.apsHorizEnd = STATE.apsHOffEnd;
	}
	
	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		if ((lQuadrant == 2) || (lQuadrant == 3))
		{
			STATE.apsVertBegin = STATE.apsVOnBegin; /* add 'on' interscections */
			STATE.apsVertEnd = STATE.apsVOnEnd;
		}
		else
		{
			STATE.apsVertBegin = STATE.apsVOffBegin; /* add 'off' interscections */
			STATE.apsVertEnd = STATE.apsVOffEnd;
		}
		
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
            Assert((STATE.lPoint - 1) <= (0xFFFF >> SC_CODESHFT));
			STATE.usScanTag = (uint16)(((STATE.lPoint - 1) << SC_CODESHFT) | lElementCode);

			while (lPts > 0)                    /* save control points */
			{
				STATE.afxXPoints[STATE.lPoint] = *pfxX;
				pfxX++;
				STATE.afxYPoints[STATE.lPoint] = *pfxY;
				pfxY++;
				STATE.lPoint++;
				lPts--;
				Assert (STATE.lPoint <= STATE.lElementPoints);
			}
		}
	}
}


/*********************************************************************/

/*      Add Scanline Intersection Functions                          */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSimpleScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sX;

/* printf("H(%li, %li)  ", lX, lY); */

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	lY -= STATE.lBoxBottom;         /* normalize */
	psBegin = STATE.apsHorizBegin[lY];
	ppsEnd = &STATE.apsHorizEnd[lY];
	psEnd = *ppsEnd;
	(*ppsEnd)++;                    /* bump ptr for next time */
	
	psLead = psEnd - 1;
	sX = (int16)lX;
	
	while((psLead >= psBegin) && (*psLead > sX))
	{
		*psEnd-- = *psLead--;       /* make room */
	}
	*psEnd = sX;                    /* store new value */
}

/*********************************************************************/

/*  Sort a simple intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSimpleScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sY;

/* printf("V(%li, %li)  ", lX, lY); */

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY <= STATE.lBoxTop);

	lX -= STATE.lBoxLeft;           /* normalize */
	psBegin = STATE.apsVertBegin[lX];
	ppsEnd = &STATE.apsVertEnd[lX];
	psEnd = *ppsEnd;
	(*ppsEnd)++;                    /* bump ptr for next time */

	psLead = psEnd - 1;
	sY = (int16)lY;
	
	while((psLead >= psBegin) && (*psLead > sY))
	{
		*psEnd-- = *psLead--;       /* make room */
	}
	*psEnd = sY;                    /* store new value */
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSmartScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;                /* pts to first array element */
	uint32 *pulEnd;                  /* pts past last element */
	uint32 *pulLead;                 /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);
	
	lY -= STATE.lBoxBottom;         /* normalize */
	pulBegin = (uint32*)STATE.apsHorizBegin[lY];
	ppsEnd = &STATE.apsHorizEnd[lY];
	pulEnd = (uint32*)*ppsEnd;
	(*ppsEnd) += 2;                 /* value & tag */

	pulLead = pulEnd - 1;
	sX = (int16)lX;

	while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
	{
		*pulEnd-- = *pulLead--;     /* make room */
	}
	psInsert = (int16*)pulEnd;
	*psInsert = sX;                 /* store new value */
	psInsert++;
	*psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Sort a smart intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSmartScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;                /* pts to first array element */
	uint32 *pulEnd;                  /* pts past last element */
	uint32 *pulLead;                 /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sY;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY <= STATE.lBoxTop);
	
	lX -= STATE.lBoxLeft;         /* normalize */
	pulBegin = (uint32*)STATE.apsVertBegin[lX];
	ppsEnd = &STATE.apsVertEnd[lX];
	pulEnd = (uint32*)*ppsEnd;
	(*ppsEnd) += 2;                 /* value & tag */

	pulLead = pulEnd - 1;
	sY = (int16)lY;

	while((pulLead >= pulBegin) && (*((int16*)pulLead) > sY))
	{
		*pulEnd-- = *pulLead--;     /* make room */
	}
	psInsert = (int16*)pulEnd;
	*psInsert = sY;                 /* store new value */
	psInsert++;
	*psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Add an intersection with banding                                 */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSimpleBand(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	
	if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
	{
		lY -= STATE.lLoScanBand;    /* normalize */
		psBegin = STATE.apsHorizBegin[lY];
		ppsEnd = &STATE.apsHorizEnd[lY];
		psEnd = *ppsEnd;
		(*ppsEnd)++;                /* bump ptr for next time */
		
		psLead = psEnd - 1;
		sX = (int16)lX;

		while((psLead >= psBegin) && (*psLead > sX))
		{
			*psEnd-- = *psLead--;   /* make room */
		}
		*psEnd = sX;                /* store new value */
	}
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSmartBand(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;               /* pts to first array element */
	uint32 *pulEnd;                 /* pts past last element */
	uint32 *pulLead;                /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	
	if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
	{
		lY -= STATE.lLoScanBand;    /* normalize */
		pulBegin = (uint32*)STATE.apsHorizBegin[lY];
		ppsEnd = &STATE.apsHorizEnd[lY];
		pulEnd = (uint32*)*ppsEnd;
		(*ppsEnd) += 2;             /* value & tag */

		pulLead = pulEnd - 1;
		sX = (int16)lX;

		while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
		{
			*pulEnd-- = *pulLead--;  /* make room */
		}
		psInsert = (int16*)pulEnd;
		*psInsert = sX;              /* store new value */
		psInsert++;
		*psInsert = STATE.usScanTag; /* keep tag too */
	}
}


/*********************************************************************/

/*  When all contours have been scanned, fill in the bitmap          */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap(
		PSTATE                          /* pointer to state variables */
		char *pchBitMap,                /* target memory */
		int32 lHiBand,                  /* top bitmap limit */
		int32 lLoBand,                  /* bottom bitmap limit */
		int32 lRowBytes,                /* bitmap bytes per row */
		int32 lOrgLoBand,               /* original low band row */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lHeight;                      /* of scan band in pixels */
	int32 lIndex;                       /* array index */
	int32 lFirstScan;                   /* first scanline index */

	int16 sXOffset;                     /* bitmap box shift */
	int16 sXStart;                      /* on transition */
	int16 sXStop;                       /* off transition */
	
	uint32 *pulRow;                     /* row beginning pointer */
	uint32 ulBMPLongs;                  /* longs per bitmap */
	int32 lRowLongs;                    /* long words per row */
	int32 lErrCode;
	
	int16 **ppsHOnBegin;                /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	

/*  printf("%li : %li\n", lHiBand, lLoBand); */
	
	STATE.lHiBitBand = lHiBand;                 /* copy bit band limits */
	STATE.lLoBitBand = lLoBand;
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	
	STATE.lRowBytes = lRowBytes;                /* save bytes per row */
	lRowLongs = lRowBytes >> 2;                 /* long words per row */
	
	ulBMPLongs = (uint32)(lRowLongs * (int32)lHeight);
	pulRow = (uint32*)pchBitMap;                /* start at glyph top */
	lErrCode = fsc_ClearBitMap(ulBMPLongs, pulRow);
	if (lErrCode != NO_ERR) return lErrCode;

	sXOffset = (int16)STATE.lBoxLeft;
	
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
						
/*  now go through the bitmap from top to bottom */

	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
				
		Assert(psHorizOnEnd <= psHorizOff);
		Assert(psHorizOnEnd - psHorizOn == STATE.apsHOffEnd[lFirstScan - lIndex] - psHorizOff);

		while (psHorizOn < psHorizOnEnd)
		{
			sXStart = *psHorizOn - sXOffset;
			psHorizOn += STATE.sIxSize;
			sXStop = *psHorizOff - sXOffset;
			psHorizOff += STATE.sIxSize;

			if (sXStart < sXStop)                   /* positive run */
			{
				lErrCode = fsc_BLTHoriz(sXStart, sXStop - 1, pulRow);
			}
			else if (sXStart > sXStop)              /* negative run */
			{
				lErrCode = fsc_BLTHoriz(sXStop, sXStart - 1, pulRow);
			}
			if (lErrCode != NO_ERR) return lErrCode;
		}
		pulRow += lRowLongs;                        /* next row */
	}
	
/* if doing dropout control, do it now */

	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lErrCode = LookForDropouts(ASTATE pchBitMap, usScanKind);
		if (lErrCode != NO_ERR) return lErrCode;
		
		if (lOrgLoBand != STATE.lLoScanBand)        /* if fast banding & dropout */
		{
			pulRow -= lRowLongs;                    /* back to overscan row */
			pulRow -= lRowLongs;                    /* back to low row */
			lErrCode = fsc_BLTCopy (pulRow, STATE.pulLastRow, lRowLongs);
			if (lErrCode != NO_ERR) return lErrCode;

			STATE.lLastRowIndex = STATE.lLoBitBand + 1; /* save row ID */
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Dropout Control Functions                                    */

/*********************************************************************/
	
FS_PRIVATE int32 LookForDropouts(
		PSTATE                      /* pointer to state variables  */
		char *pchBitMap,
		uint16 usScanKind )         /* dropout control value */
{
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffEnd;
			
	int16 *psVertOn;
	int16 *psVertOff;
	int16 *psVertOnBegin;

	int32 lHeight;
	int32 lWidth;
	int32 lIndex;                   /* array index */
	int32 lFirstScan;               /* first scanline index */
	
	int32 lErrCode;

/*  Check horizontal scan lines for dropouts  */
	
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
		
	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
		
		while (psHorizOn < psHorizOnEnd)
		{
			if (*psHorizOn == *psHorizOff)  /* zero length run */
			{
				lErrCode = DoHorizDropout(ASTATE psHorizOn, psHorizOff,
										 STATE.lHiBitBand - lIndex - 1,
										 pchBitMap,
										 usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psHorizOn += STATE.sIxSize;
			psHorizOff += STATE.sIxSize;
		}
	}
		
/*  Check vertical scan lines for dropouts  */
	
	lWidth = STATE.lBoxRight - STATE.lBoxLeft;
	ppsVOnBegin = STATE.apsVOnBegin;
	ppsVOnEnd = STATE.apsVOnEnd;
	ppsVOffEnd = STATE.apsVOffEnd;
	
	for (lIndex = 0; lIndex < lWidth; lIndex++)
	{
		psVertOnBegin = *ppsVOnBegin;
		ppsVOnBegin++;
		psVertOn = *ppsVOnEnd - STATE.sIxSize;  /* start at end (glyph top) */
		ppsVOnEnd++;
		psVertOff = *ppsVOffEnd - STATE.sIxSize;
		ppsVOffEnd++;
		
		while (psVertOn >= psVertOnBegin)       /* from top to bottom */
		{
			if (*psVertOn == *psVertOff)        /* zero length run */
			{
				lErrCode = DoVertDropout(ASTATE psVertOn, psVertOff,
										 STATE.lBoxLeft + lIndex,
										 pchBitMap, usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psVertOn -= STATE.sIxSize;
			psVertOff -= STATE.sIxSize;
		}
	}
	return NO_ERR;
}


/*********************************************************************/

FS_PRIVATE int32 DoHorizDropout(
		PSTATE                  /* pointer to state variables */
		int16 *psOn,            /* pointer to on intersection */
		int16 *psOff,           /* pointer to off intersection */
		int32 lYDrop,           /* y coord of dropout */
		char *pchBitMap,        /* target memory */
		uint16 usScanKind )     /* dropout control value */
{
	int32 lXDrop;                                   /* x coord of dropout */
	int32 lCross;                                   /* scanline crossings */
	F26Dot6 fxX1, fxX2;                             /* for smart dropout */
	uint16 usOnTag, usOffTag;                       /* element info */
	int16 sOnPt, sOffPt;                            /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);    /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*);   /* off callback */

	lXDrop = (int32)*psOn;
	
/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop + 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation above */
		}
		
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation below */
		}
	}

/*  passed stub control, now check pixels left and right  */

	if (lXDrop > STATE.lBoxLeft)                /* if pixel to left */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop - 1, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}
	if (lXDrop < STATE.lBoxRight)               /* if pixel to right */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}

/*  no pixels left or right, now determine bit placement  */

	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnHCallBack[usOnTag & SC_CODEMASK];
		fxX1 = pfnOn(lYDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnHCallBack[usOffTag & SC_CODEMASK];
		fxX2 = pfnOff(lYDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lXDrop = (int32)((fxX1 + fxX2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lXDrop--;                               /* always to the left */
	}
	
	if (lXDrop < STATE.lBoxLeft)                /* confine to bounding box */
	{
		lXDrop = STATE.lBoxLeft;
	}
	if (lXDrop >= STATE.lBoxRight)
	{
		lXDrop = STATE.lBoxRight - 1L;
	}

	return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
}


/*********************************************************************/

FS_PRIVATE int32 DoVertDropout(
		PSTATE                      /* pointer to state variables */
		int16 *psOn,                /* pointer to on intersection */
		int16 *psOff,               /* pointer to off intersection */
		int32 lXDrop,               /* x coord of dropout */
		char *pchBitMap,            /* target memory descriptor */
		uint16 usScanKind )         /* dropout control value */
{
	int32 lYDrop;                                 /* y coord of dropout */
	int32 lCross;                                 /* scanline crossings */
	F26Dot6 fxY1, fxY2;                           /* for smart dropout */
	uint16 usOnTag, usOffTag;                     /* element info */
	int16 sOnPt, sOffPt;                          /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);  /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*); /* off callback */
	
	lYDrop = (int32)*psOn;

	if ((lYDrop < STATE.lLoBitBand) || (lYDrop > STATE.lHiBitBand))
	{
		return NO_ERR;                          /* quick return for outside band */
	}

/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to left */
		}
		
		lCross = VertCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to right */
		}
	}

/*  passed stub control, now check pixels below and above  */

	if (lYDrop > STATE.lBoxBottom)                  /* if pixel below */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop - 1) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}
	if (lYDrop < STATE.lBoxTop)                     /* if pixel above */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}

/*  no pixels above or below, now determine bit placement  */
	
	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnVCallBack[usOnTag & SC_CODEMASK];
		fxY1 = pfnOn(lXDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnVCallBack[usOffTag & SC_CODEMASK];
		fxY2 = pfnOff(lXDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lYDrop = (int32)((fxY1 + fxY2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lYDrop--;                               /* always below */
	}
	
	if (lYDrop < STATE.lBoxBottom)              /* confine to bounding box */
	{
		lYDrop = STATE.lBoxBottom;
	}
	if (lYDrop >= STATE.lBoxTop)
	{
		lYDrop = STATE.lBoxTop - 1L;
	}
		
	if ((lYDrop >= STATE.lLoBitBand) && (lYDrop < STATE.lHiBitBand))
	{
		return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Count contour crossings of a horizontal scan line segment  */

FS_PRIVATE int32 HorizCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sX;
	
	if ((lY < STATE.lLoScanBand) || (lY >= STATE.lHiScanBand))
	{
		return 0;                       /* if outside the scan region */
	}
	
	lCrossings = 0;
	lIndex = lY - STATE.lLoScanBand;
	psOn = STATE.apsHOnBegin[lIndex];
	psOff = STATE.apsHOffBegin[lIndex];
	psOnEnd = STATE.apsHOnEnd[lIndex];
	sX = (int16)lX;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sX)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sX)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}


/*********************************************************************/

/*  Count contour crossings of a vertical scan line segment  */

FS_PRIVATE int32 VertCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sY;
	
	if ((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight))
	{
		return 0;                       /* if outside the bitmap */
	}
	
	lCrossings = 0;
	lIndex = lX - STATE.lBoxLeft;
	psOn = STATE.apsVOnBegin[lIndex];
	psOff = STATE.apsVOffBegin[lIndex];
	psOnEnd = STATE.apsVOnEnd[lIndex];
	sY = (int16)lY;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sY)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sY)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}
		

/****************************************************************************/

/*              Get a pixel using absolute coordinates                      */

/*  When banding with dropout control, this routine uses the last low row   */
/*  of the previous bitmap when possible.                                   */

FS_PRIVATE uint32 GetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */

	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	if ((lY < STATE.lHiBitBand) && (lY >= STATE.lLoBitBand))  /* if within the bitmap */
	{
		pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
		return fsc_GetBit(lX - STATE.lBoxLeft, pulRow);       /* read the bitmap */
	}
	if (lY == STATE.lLastRowIndex)          /* if saved from last band */
	{
		return fsc_GetBit(lX - STATE.lBoxLeft, STATE.pulLastRow);
	}
	return(0L);                             /* outside bitmap doesn't matter */
}


/*********************************************************************/

/*  Set a pixel using absolute coordinates  */

FS_PRIVATE int32 SetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */
	
	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lLoBitBand);
	Assert(lY < STATE.lHiBitBand);
	
	pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
	
	return fsc_SetBit(lX - STATE.lBoxLeft, pulRow);
}


/*********************************************************************/

/*      Gray Scale Pass Through Functions                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap (
		uint32 ulCount,                     /* longs per bmp */
		uint32* pulBitMap                   /* bitmap ptr caste long */
)
{
	return fsc_ClearBitMap(ulCount, pulBitMap);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam* pGSP                /* pointer to param block */
)
{
	return fsc_CalcGrayRow(pGSP);
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scanlist.h ===
/*********************************************************************

	  scanlist.h -- ScanList Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/10/93  deanb   fsc_InitializeScanlist added
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   uiRowBytes moved from setup to fillbitmap
	  10/09/92  deanb   PSTP added
	  10/08/92  deanb   reworked for split workspace
	   9/25/92  deanb   separate entry for nodrop/dropout 
	   9/10/92  deanb   horiz & vert callbacks 
	   9/09/92  deanb   size_t changes 
	   9/08/92  deanb   SetElemGlobals added 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   6/01/92  deanb   New/Old FillBitMap for debug comparisons 
	   4/21/92  deanb   Single HorizScan with flag 
	   4/13/92  deanb   unsigned int to int for HorizScanOn/Off 
	   3/31/92  deanb   InitScanArray Rectangle param 
	   3/23/92  deanb   GetWorkSize added 
	   3/16/92  deanb   New types 
	   1/31/92  deanb   HorizScan[On/Off] export functions 
	   1/14/92  deanb   First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */
#include "scgray.h"                 /* for gray param definition */


typedef struct RevRoots *PRevRoot;  /* opaque type */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeScanlist (
		void
);

FS_PUBLIC PRevRoot fsc_SetupRevRoots (
		char*,                      /* reversal list buffer space */
		int32                       /* size of buffer space */
);

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC int32 fsc_GetReversalCount (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxEstimate  (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetVIxEstimate (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxBandEst  (
		PRevRoot,                   /* pointer to reversal roots */
		Rect*,                      /* bitmap bounding box */
		int32                                /* band width in scan lines */
);

FS_PUBLIC int32 fsc_GetRevMemSize(
		PRevRoot                    /* pointer to reversal roots */
);


/*********************************************************************/

FS_PUBLIC int32 fsc_GetScanHMem( 
		uint16,                     /* scan type */
		int32,                      /* number of horiz scanlines */
		int32                       /* number of horiz intersections */
);

FS_PUBLIC int32 fsc_GetScanVMem( 
		uint16,                     /* scan type */
		int32,                      /* number of vert scanlines */
		int32,                      /* number of vert intersections */
		int32                       /* number of contour element points */
);

/*********************************************************************/

FS_PUBLIC void fsc_SetupCallBacks( 
		PSTATE                      /* pointer to state variables */
		int16,                      /* element code (line, spline, endpoint) */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*)    /* vert callback */
);

FS_PUBLIC int32 fsc_SetupScan( 
		PSTATE                      /* pointer to state variables */
		Rect*,                      /* bitmap bounding box */
		uint16,                     /* scan type */
		int32,                      /* band scan upper limit */
		int32,                      /* band scan lower limit */
		boolean,                    /* save over scan bitmap row */
		int32,                      /* bytes per bitmap row */
		int32,                      /* estimate of horiz intersections */
		int32,                      /* estimate of vert intersections */
		int32,                      /* estimate of element points */
		PRevRoot                    /* reversal list Roots */ 
);


FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                      /* pointer to state variables */
		uint16,                     /* scan type */
		F26Dot6,                    /* starting point x coordinate */
		F26Dot6                     /* starting point y coordinate */
);


FS_PUBLIC void fsc_BeginElement( 
		PSTATE                      /* pointer to state variables */
		uint16,                     /* type of dropout control */
		int32,                      /* determines scan on/off */   
		int32,                      /* element (line, spline, ep) */
		int32,                      /* number of points to store */
		F26Dot6*,                   /* next x control point(s) */
		F26Dot6*,                   /* next y control point(s) */
		void (**)(PSTATE int32, int32),    /* horiz add scan return */
		void (**)(PSTATE int32, int32)     /* vert add scan return */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap( 
		PSTATE                      /* pointer to state variables */
		char*,                      /* target memory */
		int32,                      /* bitmap upper limit */
		int32,                      /* bitmap lower limit */
		int32,                      /* bitmap bytes per row */
		int32,                      /* original low band row */
		uint16                      /* scan type */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap ( 
		uint32,                     /* longs per bmp */
		uint32*                     /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam*             /* pointer to param block */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scbitmap.h ===
/*********************************************************************

	  scbitmap.h -- BitMap Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/19/93 deanb    fsc_CalcGrayRow added
	   6/10/93 deanb    fsc_InitializeBitMasks added
	   4/29/93 deanb    BLTCopy routine added
	   9/15/92 deanb    GetBit returns uint32 
	   8/17/92 deanb    GetBit, SetBit added 
	   7/27/92 deanb    ClearBitMap call added 
	   6/02/92 deanb    Row pointer, integer limits, no descriptor 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/15/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeBitMasks (
		void
);

FS_PUBLIC int32 fsc_ClearBitMap ( 
		uint32,             /* longs per bmp */
		uint32*             /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_BLTHoriz ( 
		int32,              /* x start */
		int32,              /* x stop */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_BLTCopy ( 
		uint32*,            /* source row pointer */
		uint32*,            /* destination row pointer */
		int32               /* long word counter */
);

FS_PUBLIC uint32 fsc_GetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_SetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_CalcGrayRow(
		GrayScaleParam*     /* pointer to param block */
);


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\interp.c ===
/*********************************************************************

	  interp.c -- TT Rasterizer Interpreter Module

	  Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				  (c) 1989-1999. Microsoft Corporation, all rights reserved.

	   7/10/99  BeatS	 62 Add support for native SP fonts, vertical RGB
	   4/01/99  BeatS	 61 Implement alternative interpretation of TT instructions for SP
	  10/14/97  claudebe 60 ClaudeBe, allowing a trace function to know if in FontProgram
							access to unitialized data
	  04/29/97  claudebe 59 ClaudeBe, catching illegal recursion and infinite loops
	  02/21/97  claudebe 58 ClaudeBe, scaled component in composite glyphs
	   2/05/96  claudebe 57 compfont for itpr_MD, wrong zone pointer
	   2/05/96  claudebe 56 GetInfo return HintForGray information
	   8/12/94  deanb  55   orphan routine CHECK_STATE deleted
	   2/09/94  deanb  54   RASTERIZER_VERSION defined for GETINFO
	  12/17/93  deanb  53   CHECK_POINT zone corrected in MIRP
	  12/08/93  deanb  52   itrp_SCANTYPE enabled for smart dropout control
	   9/15/93  deanb  51   InnerTraceEx double call fixed; iOpCode -> lOpCode
	   7/29/93  deanb  50   ALIGNPTS, SHE fixed; InnerTraceExecute saves first
	   7/12/93  deanb  49   itrp_IllegalInstruction works
	   6/28/93  deanb  48   gbyPushTable made const
	   2/16/93  deanb  47   fxUnRounded set after check single width
	   2/15/93  deanb  46   fall back to MIRPG when using single width
	   2/15/93  deanb  45   vector defaults for FONTPROGRAM, stat back
	   2/12/93  deanb  44   delete stat code
	   2/12/93  deanb  43   cleanup MSIRP & itrp_Execute
	   2/12/93  deanb  42   branch itrp_IP on MovePoint
	   2/11/93  deanb  41   use c8 register calling convetions
	   2/11/93  deanb  40   switch to Microsoft C ver 8
	   2/09/93  deanb  39   skipPushData inline in itrp_IF
	   2/09/93  deanb  38   do fast MIRP's with if statments
	   2/09/93  deanb  37   remove fast MDRPX and MIRPY routines
	   2/09/93  deanb  36   fast MDRPX and MIRPY routines
	   2/08/93  deanb  35   cleanup MIRPs, combine if statments
	   2/08/93  deanb  34   dual rounding with 6 ptr init values
	   2/08/93  deanb  33   IUP inner loop pointer check
	   2/08/93  deanb  32   repair skipPushData for npushw
	   2/05/93  deanb  31   check for fxHintedDelta = 0
	   2/05/93  deanb  30   use roundFuncPtr in fast MIRP's
	   2/05/93  deanb  29   itrp_SWAP done in place
	   2/05/93  deanb  28   fntMirpFunc defined for MIRPG/X/Y
	   2/05/93  deanb  27   iOpCode passed in to all functions
	   2/05/93  deanb  26   use instr ptr for param and return
	   2/04/93  deanb  25   pull oldRange out of itrp_IP loops
	   2/04/93  deanb  24   movePoint check for proj.x/y = 1
	   2/03/93  deanb  23   table driven skipPushData
	   2/03/93  deanb  22   zero based Unary Operand pointers
	   2/01/93  deanb  21   split out SetRoundState
	   2/01/93  deanb  20   eliminate OpCode assignemnt, registers
	   2/01/93  deanb  19   bump Normalize limit up to 0x20000000L
	   1/29/93  deanb  18   add SuperRound MIRPG fallback
	   1/29/93  deanb  17   fast MIRPX and MIRPY routines
	   1/27/93  deanb  16   single rounding routines restored
	   1/27/93  deanb  15   innerExecute tune up
	   1/27/93  deanb  14   rounding routines for engine/no engine
	   1/27/93  deanb  13   repair itrp_Normalize for BIG vectors
	   1/26/93  deanb  12   split out SPVTCA and SFVTCA
	   1/26/93  deanb  11   clean up itrp_IP
	   1/26/93  deanb  10   return IUP to old start/end calc
	   1/25/93  deanb   9   use pointers in IUP loops
	   1/25/93  deanb   8   major rewrite of itrp_IUP
	   1/25/93  deanb   7   rewrite itrp_Normalize
	   1/22/93  deanb   6   split and do Unary Operands in place
	   1/22/93  deanb   5   do Binary Operands in place
	   1/22/93  deanb   4   split out BinaryOperand
	   1/22/93  deanb   3   split out PUSHB1 and PUSHW1
	   1/22/93  deanb   2   split out PushSomeBytes/Words
	   1/22/93  deanb   1   split out SRP0-2, LLOOP, POP
	   1/22/93  deanb   0   STAT card timing added
	   1/22/93  deanb       dead code/comments moved to history.fnt
 
**********************************************************************/

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "interp.h"
#include "fserror.h"

#include "stat.h"                   /* for STAT card timing only */

#include <stdio.h>

#ifdef SEGMENT_LINK
#pragma segment FNT_C
#endif

/* perfect spot size (Fixed) */
#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

#ifdef FSCFG_SUBPIXEL
#define RASTERIZER_VERSION  37      /* MS reserved values 33 - 64 */
#else
#define RASTERIZER_VERSION  35      /* MS reserved values 33 - 64 */
#endif // FSCFG_SUBPIXEL
									/* 33 = Rasterizer v1.5 */
									/* 34 = Rasterizer v1.6 */
									/* 35 = Rasterizer v1.7 */
									/* 36 = Rasterizer v1.6+, Windows CE, SubPixel */
									/* 37 = Rasterizer v1.8, Windows 2000, SubPixel */

#ifdef FSCFG_SUBPIXEL
	// the following are 9 switches to avoid all kinds of "hinting techniques" that have adverse effects on SubPixel
	// they should be considered "band-aid" solutions, to avoid us the worst of the worst with existing fonts.
	// in the future, fonts that are optimized for SubPixel should be tagged as such.
	// This will permit to switch these switches off again.
	#define RDTGRoundsDownToGrid		// to avoid not aligning control points when Align translates to MDRP with RDTG preceded by SPVTL
	#define NoVirtRoundInPrep			// to avoid PMingLiU vertically misplacing strokes (vectors not set properly in prep for certain calculations)
	#define RoundOffRespectsCvtCutIn	// to avoid Palatino Italic's fractional grey-scale targetted cvts and unrounded MIRP (little r) which bypasses cvt cut-in
	#define MSIRPRespectsCvtCutIn		// to avoid fonts pre-calculating a distance and subsequently MSIRPing it (neither rounding nor cvt cut-in involved in MSIRP)
	#define InlineDeltasOnly			// to avoid all kinds of bumps, blops, or irregular weight gains
	#define DoDiagEndCtrlDeltas			// to avoid bypassing deltas in the support function to the old TMT DiagEndCtrl which needs deltas to undo the side-effects of "cross-over" strokes
	#define BypassDandIStroke			// to avoid collapsing strokes in (partly) auto-hinted fonts using DStroke and IStroke commands
	#define BypassJellesSpacing			// to avoid bloated characters
	#define BypassVacuformRound			// to avoid diamond shaped characters
	#define BypassTomsDiagonal			// to avoid Georgia italic to become upright

	// values derived from the primary values in fscdefs.h
	#define CVT_CUT_IN_OVERSCALE	VIRTUAL_OVERSCALE	// high value to encourage MIRP to fall back on original distance to avoid stroke weight jumps in size ramp
	#define ENGINE_COMP_OVERSCALE	VISUAL_OVERSCALE	// value not particularly relevant as engine compensation is not currently used
	#define MIN_DIST_OVERSCALE		VISUAL_OVERSCALE	// value not terribly important as it basically affects the minimum stroke weight

	#define Tuned4SubPixel(globalGS) ((uint16)((globalGS)->localParBlock.instructControl & TUNED4SPFLAG))
#else
	#define Tuned4SubPixel(globalGS) (false)
#endif

#define MAX_ELEMENTS 2
#define TWILIGHTZONE 0 /* The point storage */
#define GLYPHELEMENT 1 /* The actual glyph */

/* those constant are used as default to catch illegal fonts */
#define INTERP_MAX_JUMPS			10000
#define INTERP_MAX_RECURSIVE_CALLS	100

#define MAXANGLES       20

#define ROTATEDGLYPH        0x0100
#define STRETCHEDGLYPH      0x0200
/* new Apple 1994 */
#define VARIATIONGLYPH      0x0400
#define VERTICALGLYPH       0x0800
/* new Microsoft 1996 */
#define HINTEDFORGRAYGLYPH  0x1000

#define VERSIONINTERPRETERQUERY          0x0001
#define ROTATEDINTERPRETERQUERY          0x0002
#define STRETCHEDINTERPRETERQUERY        0x0004
/* new Apple 1994 */
#define VARIATIONINTERPRETERQUERY        0x0008
#define VERTICALMETRICSINTERPRETERQUERY  0x0010
/* new Microsoft 1996 */
#define HINTFORGRAYINTERPRETERQUERY      0x0020

/* new Microsoft 1998
   moved out of FSCFG_SUBPIXEL to build debug version for non SP environment */
#define HINTFORSUBPIXELINTERPRETERQUERY						0x0040
#define HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY		0x0080
#define HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY	0x0100
#define HINTFORSUBPIXELBGRORDERINTERPRETERQUERY				0x0200

#ifdef FSCFG_SUBPIXEL
/* new Microsoft 1998 */
#define HINTEDFORSUBPIXELGLYPH								0x02000
#define HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH				0x04000
#define HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH				0x08000
#define HINTEDFORSUBPIXELBGRORDERGLYPH						0x10000
#endif // FSCFG_SUBPIXEL

// this includes all SP specific flags, since we don't want a SP enabled font to break on a non SP enabled rasterizer
#define SELECTOR_FLAGS (VERSIONINTERPRETERQUERY | ROTATEDINTERPRETERQUERY | STRETCHEDINTERPRETERQUERY |					\
						VARIATIONINTERPRETERQUERY | VERTICALMETRICSINTERPRETERQUERY | HINTFORGRAYINTERPRETERQUERY |		\
						HINTFORSUBPIXELINTERPRETERQUERY | HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY |			\
						HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY | HINTFORSUBPIXELBGRORDERINTERPRETERQUERY)

#define MAXBYTE_INSTRUCTIONS 256

#define ONEVECTOR                       ONESHORTFRAC
#define VECTORMUL(value, component)     ShortFracMul((F26Dot6)(value), (ShortFract)(component))
#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define VECTORDIV(num,denum)            ShortFracDiv((ShortFract)(num),(ShortFract)(denum))
#define VECTORMULDIV(a,b,c)             ShortFracMulDiv((ShortFract)(a),(ShortFract)(b),(ShortFract)(c))
#define VECTOR2FIX(a)                   ((Fixed) (a) << 2)
#define ONESIXTEENTHVECTOR              ((ONEVECTOR) >> 4)

#ifdef FSCFG_REENTRANT
#define GSP0    fnt_LocalGraphicStateType* pLocalGS
#define GSP     fnt_LocalGraphicStateType* pLocalGS,
#define GSA0    pLocalGS
#define GSA     pLocalGS,
#define LocalGS (*pLocalGS)
#else 
#define GSP0    void
#define GSP
#define GSA0
#define GSA
fnt_LocalGraphicStateType LocalGS
 #ifndef FSCFG_NO_INITIALIZED_DATA
  = {0}
 #endif 
;
#endif 


#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )


/* Common Interpreter Function Parameter */

#define IPARAM         GSP uint8 *pbyInst, int32 lOpCode

#define MIRPG          0
#define MIRPX          1
#define MIRPY          2
				  
// color compensation flags in ROUND, MDRP, and MIRP
#define	GREY	0
#define BLACK	1
#define WHITE	2
#define OTHER	3

// flags for UTP, IUP, MovePoint
#define XMOVED 0x01
#define YMOVED 0x02


#define NUM_PHANTOM_PTS   4L

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA // master switch

	#define NumRelationShips(elem) (elem->ep[elem->nc - 1] + 1 + NUM_PHANTOM_PTS)

	// Make an empty data structure (DAG)
	void InitPhaseControl(fnt_ElementType *elem) {
		long i;
		PhaseControlRelation *rel;

		for (i = 0; i < NumRelationShips(elem); i++) {
			rel = &elem->pcr[i];
			rel->parent0 = rel->parent1 = rel->child = -1;
			rel->flags = 0;
			rel->phaseShift = 0;
		}
		elem->phaseControlExecuted = false;
	} // InitPhaseControl

	//	Function to avert circular dependencies, whose traversal would cause endless recursion in
	//	"PhaseShift" further below.
	//
	//	In the trivial case (self dependency), a child would depend on itself. This scenario is ex-
	//	cluded by respective tests in the callers.
	//
	//	In the simplest non-trivial case (direct dependency), before linking from a parent to a child,
	//	we want to determine whether the child links back to the parent:
	//
	//		IndirectlyDependsOn(..., parent, child, ...) ?
	//
	//	If it does, then "self" (the parent) depends on "whom" (the child), and we'd get a circular
	//	dependency, because the child would depend on the parent as a result of "AddDistance":
	//
	//		rel->parent0 == whom ?
	//
	//	noting that "rel" points to self's phase control relation structure.
	//
	//	In the more general case (indirect dependency, which includes direct dependency via zero
	//	indirections), self's parent may depend on the child (and recursively), hence:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) ?
	//
	//	In the most general case, there may be two parents involved, hence we have to follow both
	//	lines of ancestry:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) || 
	//		rel->parent1 == whom || IndirectlyDependsOn(..., rel->parent1, whom, ...) ?
	//
	//	Notice that in the actual code the latter is re-arranged for efficiency.
	//	Notice also that we don't have a simple case of tail recursion, which could be replaced by
	//	an iteration easily.

	boolean IndirectlyDependsOn(fnt_ElementType *elem, long self, long whom, long level) {
		PhaseControlRelation *rel;

		level--;
		if (level < 0) return true; // safeguard against stack overflow, probably redundant

	//	here we assume that we're called only from within AddDistance or AddProportion, hence
	//	"self" and "whom" have been range checked initially. Every recursion changes the actual
	//	value of "self", but only to a value obtained from a "pcr", which only gets range checked
	//	values, hence we don't need to range check "self" again. "whom" is invariant anyhow.
	//	Additionally, we also assume that "self" and "whom" are not the same. Since the algorithm
	//	below terminates if "self"'s parent equals "whom", "self" never becomes "whom".

		rel = &elem->pcr[self];
		if (rel->parent0 == -1) // 0 parents (MDAP, MIAP)
			return false; // no dependencies
		else if (rel->parent1 == -1) // 1 parent (MDRP, MIRP, SHP, ALIGNRP, etc.)
			return rel->parent0 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1);
		else // 2 parents (IP)
			return rel->parent0 == whom || rel->parent1 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1) || IndirectlyDependsOn(elem,rel->parent1,whom,level-1);
		return false; // we shouldn't get down here, but the compiler thinks we do...
	} // IndirectlyDependsOn

	// Called from the TT interpreter whenever a MIRP, MDRP, SHP, ALIGNRP (etc.) is executed
	// Add a distance relationship to the DAG
	void AddDistance(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from, long to, long color) {
		long parent;

		if (0 <= from && from < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from != to) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1) { // we have no parent for this child
				while ((parent = elem->pcr[from].parent0) != -1 && elem->oox[from] == elem->oox[parent])
					from = parent; // simplify link structure in case of links to "align" vertical edges
				elem->pcr[to].parent0 = (int16)from; // first link wins, bad links may produce suboptimal phase control
				elem->pcr[to].parent1 = -1;
			}
			if (color == BLACK && elem->pcr[from].child == -1 && elem->pcr[to].child != from) { // first black link wins...
				if ((parent = elem->pcr[from].parent0) != -1 && elem->pcr[parent].child == from)
					elem->pcr[to].flags |= BADREL;
				else
					elem->pcr[from].child = (int16)to;
			}
		}
	} // AddDistance
	
	// Called from the TT interpreter when an IP is executed
	// Add a proportion relationship to the DAG
	void AddProportion(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from0, long to, long from1) {
		if (0 <= from0 && from0 < NumRelationShips(elem) && 0 <= from1 && from1 < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from0 != to && from1 != to && from0 != from1) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from0,to,INTERP_MAX_RECURSIVE_CALLS) || IndirectlyDependsOn(elem,from1,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1 && elem->pcr[to].parent1 == -1) {
				elem->pcr[to].parent0 = (int16)from0; // first interpolate wins, bad interpolates
				elem->pcr[to].parent1 = (int16)from1; // ...may produce suboptimal phase control
			}
		}
	} // AddProportion
	
	// Calculate the phase shift resulting from a child point that depends on two parent points by proportion (interpolation)
	F26Dot6 CalcAvgXPhaseShift(fnt_ElementType *elem, long parent0, long child, long parent1, F26Dot6 phase0, F26Dot6 phase1) {
		F26Dot6 leftX,childX,rightX,leftPhase,rightPhase;
		
		// the phase of child control points that are interpolated between a pair of parent control points depends on the phase
		// applied to both of these parent control points.
		// If both parents have the same phase, then the child point gets that phase
		if (phase0 == phase1) return phase0; // IPs "within" strokes

		// if the phase is different, we try to calculcate a weighted average.
		// In dubious cases, this may fail (divide-by-zero), in which case we fall back on an unweighted (plain) average.
		if (elem->ox[parent0] < elem->ox[parent1]) {
			leftX = elem->ox[parent0]; rightX = elem->ox[parent1];
			leftPhase = phase0; rightPhase = phase1;
		} else {
			leftX = elem->ox[parent1]; rightX = elem->ox[parent0];
			leftPhase = phase1; rightPhase = phase0;
		}
		childX = elem->ox[child];
		
		return leftX != rightX 
			? ((childX - leftX)*rightPhase + (rightX - childX)*leftPhase)/(rightX - leftX) // weighted average
			: (leftPhase + rightPhase) / 2; // unweighted average
	} // CalcAvgXPhaseShift
	
	// This is the part that (recursively) traverses the data structure to apply the above rules.
	// Notice that it works much like the early prototype for the compiler that translates VTT's GUI into TMT
	F26Dot6 PhaseShift(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, short anyBadRelation, long child) {
		PhaseControlRelation *rel,*childRel;
		F26Dot6 phase;
		
		if (child == -1) return 0; // nothing, hence no phase shift
		
		rel = &elem->pcr[child];
		
		if (rel->flags & DOING) return 0; // prevent from endless recursion due to circular dependencies; probably redundant
		rel->flags |= DOING;

		if ((rel->flags & DONE) == 0) { // else been there already, know phase
			if (child > elem->ep[elem->nc-1]) { // LSB, RSB
				phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
			} else if (rel->parent0 == -1) { // MDAP, MIAP
				if (anyBadRelation) {
					phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
				} else {
					phase = 0;
				}
			} else if (rel->parent1 == -1) { // MDRP, MIRP, SHP, ALIGNRP, ...
				phase = PhaseShift(localGS,elem,anyBadRelation,rel->parent0);
			} else { // IP
				phase = CalcAvgXPhaseShift(elem,rel->parent0,child,rel->parent1,PhaseShift(localGS,elem,anyBadRelation,rel->parent0),PhaseShift(localGS,elem,anyBadRelation,rel->parent1));
			}
			
			if ((rel->flags & DONE) == 0) { // still not done, after above recursion
				if (rel->child != -1 && ((childRel = &elem->pcr[rel->child])->flags & DONE) == 0) {
					if (rel->parent0 == -1 || rel->parent1 == -1) { // not IP
						phase = LongMulDiv(elem->x[child] + elem->x[rel->child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x20000);
					}
					
					elem->x[child] += phase;
					elem->x[rel->child] += phase;
					
					childRel->phaseShift = phase;
					childRel->flags |= DONE;
					
				} else {
					if (anyBadRelation && rel->parent1 == -1) {
						phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
					} // else IP
					if (rel->parent0 != -1) {
						elem->x[child] += phase;
					}
				}
				rel->phaseShift = phase;
				rel->flags |= DONE;
			}
		}

		rel->flags &= ~DOING;
		return rel->phaseShift;
	} // PhaseShift

	// This is a plain old loop
	void ExecutePhaseControl(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem) {
		long i,numRelationShips;
		short anyBadRelation;
		F26Dot6 phase;

		numRelationShips = NumRelationShips(elem);
		for (i = 0; i < numRelationShips && (elem->pcr[i].flags & BADREL) == 0; i++);
		anyBadRelation = i < numRelationShips;
		for (i = 0; i < numRelationShips; i++) {
			phase = PhaseShift(localGS,elem,anyBadRelation,i);
		}
		elem->phaseControlExecuted = true;
	} // ExecutePhaseControl

	// helper function
	long ContNum(fnt_ElementType *elem, long knot) {
		long i;

		for (i = 0; i < elem->nc && knot > elem->ep[i]; i++);
		return i < elem->nc ? i : -1;
	} // ContNum

	// The "concertina algorithm" uses the color flags in the MDRP and MIRP instructions to "determine" the existence
	// of stems. Most of the time, the color flags are set correctly; in fact, if the TT code is generated by the TMT
	// compiler, they should always be correct. However, there is a small number of cases where the flags are erroneous
	// (a black stroke which is not flagged as black) or misleading (the extent of a cross bar, which is a black link
	// as defined in the TMT compiler, but which for the purpose of this algorithm had rather not be flagged as black).
	// Not surprisingly, most of these cases (avoiding to say, all of them) happen on grotesque fonts, with the MDRP
	// or MIRP between two neighbouring points on the outline (cases in which a compiler generating TT code could ar-
	// gueably be undecided). Therefore we make a last ditch effort in this function to correct the colour flags for
	// this special class of problems.
	long DoubleCheckLinkColor(fnt_ElementType *elem, long from, long to, long color) {
		long fromCont,fromStart,fromEnd,fromSucc,fromPred,toCont,toSucc,toPred;
		boolean fromRightTurn,toRightTurn,properlyOriented;

		// first, determine whether we link between a pair of neighbours on one and the same contour
		// one of the knots is not on any contour (LSB, RSB), hence can't be neighbours
		if ((fromCont = ContNum(elem,from)) < 0 || // error
			(toCont   = ContNum(elem,to))   < 0)
			return GREY; // it's not a black stroke
		
		// if they belong to different contours, we don't attempt to improve color flag
		if (fromCont != toCont) return color;
		
		// if they belong to the same contour, but are not neighbours, we don't attempt to improve color flag, either
		fromStart = elem->sp[fromCont];
		fromEnd   = elem->ep[fromCont];
		fromSucc = from == fromEnd ? fromStart : from+1;
		fromPred = from == fromStart ? fromEnd : from-1;
		if (to != fromSucc && to != fromPred) return color;

		// if they are neighbours, but the link is along the arm of a T-junction, we call it a grey link.
		// we determine this by testing whether the link starts at a point where the outline makes a right
		// turn and ends at a point where the outline makes a left turn, or vice versa.
		toSucc = to == fromEnd ? fromStart : to+1;
		toPred = to == fromStart ? fromEnd : to-1;
		fromRightTurn = (elem->oox[from]-elem->oox[fromPred])*(elem->ooy[fromSucc]-elem->ooy[from]) <
						(elem->ooy[from]-elem->ooy[fromPred])*(elem->oox[fromSucc]-elem->oox[from]);
		toRightTurn   = (elem->oox[to]-elem->oox[toPred])*(elem->ooy[toSucc]-elem->ooy[to]) <
						(elem->ooy[to]-elem->ooy[toPred])*(elem->oox[toSucc]-elem->oox[to]);
		if (fromRightTurn != toRightTurn)
			return GREY;

		// a extraneous case encountered, a link along a diagonal stroke
		if (2*MABS(elem->oox[to]-elem->oox[from]) < MABS(elem->ooy[to]-elem->ooy[from]))
			return GREY;

		properlyOriented = (elem->fc[fromCont] & OUTLINE_MISORIENTED) == 0;

		return properlyOriented == fromRightTurn ? BLACK : WHITE;
	} // DoubleCheckLinkColor

	// Determine whether an interpolation is actually an interpolation, as opposed to an extrapolation.
	// For actual interpolations, child points are moved along proportionally to the parent points. For
	// extrapolations child points are shifted along with the parent point(s). Notice that we implement
	// a behaviour similar to IUP (points between extrema are interpolated, the others are shifted along)
	boolean InterAlign(fnt_ElementType *elem, long parent0, long child, long parent1) {
		long parent0x,childx,parent1x,temp;

		parent0x = elem->oox[parent0];
		parent1x = elem->oox[parent1];
		if (parent0x > parent1x) { temp = parent0x; parent0x = parent1x; parent1x = temp; }
		childx = elem->oox[child];
		return parent0x <= childx && childx <= parent1x;
	} // InterAlign

#endif // SUBPIXEL_BC_AW_STEM_CONCERTINA


/* Private function prototypes */

FS_PRIVATE F26Dot6 itrp_RoundToDoubleGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundDownToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundUpToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToHalfGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundOff(GSP F26Dot6 xin, F26Dot6 engine);

#ifdef FSCFG_SUBPIXEL
	// a duplicate set of rounding functions, with either the b/w (above) or the sp (below) version being installed
	FS_PRIVATE F26Dot6 itrp_RoundToDoubleGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundDownToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundUpToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToHalfGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundOffSP(GSP F26Dot6 xin, F26Dot6 engine);
#endif

FS_PRIVATE F26Dot6 itrp_SuperRound(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_Super45Round(GSP F26Dot6 xin, F26Dot6 engine);

FS_PRIVATE void itrp_MovePoint  (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0);
FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);
FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);

FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_InnerExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_Check_PF_Proj (GSP0);
FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0);
FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound);
FS_PRIVATE F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 value);
FS_PRIVATE fnt_instrDef*itrp_FindIDef (GSP uint8 opCode);
FS_PRIVATE uint8* itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 base, int16 shift);

/* Actual instructions for the jump table */
FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SDPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SFVTL (IPARAM);
FS_PRIVATE uint8* itrp_WPV (IPARAM);
FS_PRIVATE uint8* itrp_WFV (IPARAM);
FS_PRIVATE uint8* itrp_RPV (IPARAM);
FS_PRIVATE uint8* itrp_RFV (IPARAM);
FS_PRIVATE uint8* itrp_SFVTPV (IPARAM);
FS_PRIVATE uint8* itrp_ISECT (IPARAM);
FS_PRIVATE uint8* itrp_SRP0 (IPARAM);
FS_PRIVATE uint8* itrp_SRP1 (IPARAM);
FS_PRIVATE uint8* itrp_SRP2 (IPARAM);
FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM);
FS_PRIVATE uint8* itrp_LLOOP (IPARAM);
FS_PRIVATE uint8* itrp_RTG (IPARAM);
FS_PRIVATE uint8* itrp_RTHG (IPARAM);
FS_PRIVATE uint8* itrp_RTDG (IPARAM);
FS_PRIVATE uint8* itrp_ROFF (IPARAM);
FS_PRIVATE uint8* itrp_RUTG (IPARAM);
FS_PRIVATE uint8* itrp_RDTG (IPARAM);
FS_PRIVATE uint8* itrp_SROUND (IPARAM);
FS_PRIVATE uint8* itrp_S45ROUND (IPARAM);
FS_PRIVATE uint8* itrp_LMD (IPARAM);
FS_PRIVATE uint8* itrp_RAW (IPARAM);
FS_PRIVATE uint8* itrp_LWTCI (IPARAM);
FS_PRIVATE uint8* itrp_LSWCI (IPARAM);
FS_PRIVATE uint8* itrp_LSW (IPARAM);
FS_PRIVATE uint8* itrp_DUP (IPARAM);
FS_PRIVATE uint8* itrp_POP (IPARAM);
FS_PRIVATE uint8* itrp_CLEAR (IPARAM);
FS_PRIVATE uint8* itrp_SWAP (IPARAM);
FS_PRIVATE uint8* itrp_DEPTH (IPARAM);
FS_PRIVATE uint8* itrp_CINDEX (IPARAM);
FS_PRIVATE uint8* itrp_MINDEX (IPARAM);
FS_PRIVATE uint8* itrp_ROTATE (IPARAM);
FS_PRIVATE uint8* itrp_MDAP (IPARAM);
FS_PRIVATE uint8* itrp_MIAP (IPARAM);
FS_PRIVATE uint8* itrp_IUP (IPARAM);
FS_PRIVATE uint8* itrp_SHP (IPARAM);
FS_PRIVATE uint8* itrp_SHC (IPARAM);
FS_PRIVATE uint8* itrp_SHE (IPARAM);
FS_PRIVATE uint8* itrp_SHPIX (IPARAM);
FS_PRIVATE uint8* itrp_IP (IPARAM);
FS_PRIVATE uint8* itrp_MSIRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM);
FS_PRIVATE uint8* itrp_SANGW (IPARAM);
FS_PRIVATE uint8* itrp_FLIPPT (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM);
FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM);
FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM);
FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM);
FS_PRIVATE uint8* itrp_AA (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM);
FS_PRIVATE uint8* itrp_WS (IPARAM);
FS_PRIVATE uint8* itrp_RS (IPARAM);
FS_PRIVATE uint8* itrp_WCVT (IPARAM);
FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM);
FS_PRIVATE uint8* itrp_RCVT (IPARAM);
FS_PRIVATE uint8* itrp_RC (IPARAM);
FS_PRIVATE uint8* itrp_WC (IPARAM);
FS_PRIVATE uint8* itrp_MD (IPARAM);
FS_PRIVATE uint8* itrp_MPPEM (IPARAM);
FS_PRIVATE uint8* itrp_MPS (IPARAM);
FS_PRIVATE uint8* itrp_GETINFO (IPARAM);
FS_PRIVATE uint8* itrp_FLIPON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM);
FS_PRIVATE uint8* itrp_IF (IPARAM);
FS_PRIVATE uint8* itrp_ELSE (IPARAM);
FS_PRIVATE uint8* itrp_EIF (IPARAM);
FS_PRIVATE uint8* itrp_JMPR (IPARAM);
FS_PRIVATE uint8* itrp_JROT (IPARAM);
FS_PRIVATE uint8* itrp_JROF (IPARAM);
FS_PRIVATE uint8* itrp_ROUND (IPARAM);
FS_PRIVATE uint8* itrp_NROUND (IPARAM);
FS_PRIVATE uint8* itrp_PUSHB (IPARAM);
FS_PRIVATE uint8* itrp_PUSHW (IPARAM);
FS_PRIVATE uint8* itrp_MDRP (IPARAM);
FS_PRIVATE uint8* itrp_MIRP (IPARAM);
FS_PRIVATE uint8* itrp_CALL (IPARAM);
FS_PRIVATE uint8* itrp_FDEF (IPARAM);
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM);
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM);
FS_PRIVATE uint8* itrp_IDEF (IPARAM);
FS_PRIVATE uint8* itrp_UTP (IPARAM);
FS_PRIVATE uint8* itrp_SDB (IPARAM);
FS_PRIVATE uint8* itrp_SDS (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM);

FS_PRIVATE uint8*  itrp_PUSHB1 (IPARAM);
FS_PRIVATE uint8*  itrp_PUSHW1 (IPARAM);

FS_PRIVATE uint8*  itrp_LT  (IPARAM);
FS_PRIVATE uint8*  itrp_LTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_GT  (IPARAM);
FS_PRIVATE uint8*  itrp_GTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_EQ  (IPARAM);
FS_PRIVATE uint8*  itrp_NEQ (IPARAM);
FS_PRIVATE uint8*  itrp_AND (IPARAM);
FS_PRIVATE uint8*  itrp_OR  (IPARAM);
FS_PRIVATE uint8*  itrp_ADD (IPARAM);
FS_PRIVATE uint8*  itrp_SUB (IPARAM);
FS_PRIVATE uint8*  itrp_DIV (IPARAM);
FS_PRIVATE uint8*  itrp_MUL (IPARAM);
FS_PRIVATE uint8*  itrp_MAX (IPARAM);
FS_PRIVATE uint8*  itrp_MIN (IPARAM);

FS_PRIVATE uint8*  itrp_ODD (IPARAM);
FS_PRIVATE uint8*  itrp_EVEN (IPARAM);
FS_PRIVATE uint8*  itrp_NOT (IPARAM);
FS_PRIVATE uint8*  itrp_ABS (IPARAM);
FS_PRIVATE uint8*  itrp_NEG (IPARAM);
FS_PRIVATE uint8*  itrp_CEILING (IPARAM);
FS_PRIVATE uint8*  itrp_FLOOR (IPARAM);

FS_PRIVATE uint8*  itrp_IllegalInstruction (IPARAM);

FS_PRIVATE fnt_ElementType*itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode);
FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy);
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8*);

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
FS_PRIVATE void itrp_DDT (int8 c, int32 n);
#endif
#endif
FS_PRIVATE uint8* itrp_DEBUG (IPARAM);

#define MAX(a,b)        ((a) > (b) ? (a) : (b))

FS_PRIVATE ErrorCode   itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc);

/* GLOBAL GS INITIALIZATION */

FS_PUBLIC void          itrp_UpdateGlobalGS(
	void *              pvGlobalGS, /* GlobalGS                             */
	void *              pvCVT,      /* Pointer to control value table       */
	void *              pvStore,    /* Pointer to storage                   */
	void *              pvFuncDef,  /* Pointer to function defintions       */
	void *              pvInstrDef, /* Pointer to instruction definitions   */
	void *              pvStack,    /* Pointer to the stack                 */
	LocalMaxProfile *       maxp,
	uint16              cvtCount,
	uint32              ulLengthFontProgram, /* Length of font program      */
	void *              pvFontProgram, /* Pointer to font program           */
	uint32              ulLengthPreProgram, /* Length of pre program        */
	void *              pvPreProgram,  /* Pointer to pre program            */
	ClientIDType        clientID)     /* User ID Number                     */
{
	fnt_GlobalGraphicStateType *    globalGS;
#ifdef FSCFG_SECURE
    uint16      maxStackElements = maxp->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
      maxStackElements = 1;
    }

#endif // FSCFG_EUDC_EDITOR_BUG
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->controlValueTable =   (F26Dot6 *)pvCVT;
	globalGS->store =               (F26Dot6 *)pvStore;
	globalGS->funcDef =             (fnt_funcDef *)pvFuncDef;
	globalGS->instrDef =            (fnt_instrDef *)pvInstrDef;
	globalGS->stackBase =           (F26Dot6 *)pvStack;
	globalGS->clientID =            clientID;
#ifdef FSCFG_SECURE
	globalGS->stackMax =             globalGS->stackBase + maxStackElements;
    globalGS->maxPointsIncludePhantom = MAX (maxp->maxPoints,maxp->maxCompositePoints) + NUM_PHANTOM_PTS;
#endif // FSCFG_SECURE

	if(ulLengthFontProgram)
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = (unsigned char *)pvFontProgram;
	}
	else
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = NULL;
	}
	if(ulLengthPreProgram)
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = (unsigned char *)pvPreProgram;
	}
	else
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = NULL;
	}

	globalGS->maxp = maxp;
	globalGS->cvtCount = cvtCount;
	globalGS->bCompositeGlyph = FALSE;
	globalGS->bSameTransformAsMaster = TRUE;
	globalGS->bOriginalPointIsInvalid = FALSE;

	globalGS->ulMaxJumpCounter = INTERP_MAX_JUMPS;
	globalGS->ulMaxRecursiveCall = INTERP_MAX_RECURSIVE_CALLS;
}

FS_PUBLIC boolean itrp_bApplyHints(
	void *      pvGlobalGS)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	return (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG));
}

FS_PUBLIC void  itrp_QueryScanInfo(
	void *      pvGlobalGS,
	uint16 *    pusScanType,
	uint16 *    pusScanControl)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
}

FS_PUBLIC void  itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8       bCompositeFlag)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bCompositeGlyph = bCompositeFlag;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bSameTransformAsMaster = (uint8)bSameTransformAsMaster;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

/*
*  function table
*/

FntFunc function [MAXBYTE_INSTRUCTIONS]
#ifndef FSCFG_NO_INITIALIZED_DATA
=
{
  itrp_SVTCA_0, itrp_SVTCA_1, itrp_SPVTCA_0, itrp_SPVTCA_1, itrp_SFVTCA_0, itrp_SFVTCA_1, itrp_SPVTL, itrp_SPVTL,
  itrp_SFVTL, itrp_SFVTL, itrp_WPV, itrp_WFV, itrp_RPV, itrp_RFV, itrp_SFVTPV, itrp_ISECT,
  itrp_SRP0, itrp_SRP1, itrp_SRP2, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_LLOOP,
  itrp_RTG, itrp_RTHG, itrp_LMD, itrp_ELSE, itrp_JMPR, itrp_LWTCI, itrp_LSWCI, itrp_LSW,
  itrp_DUP, itrp_POP, itrp_CLEAR, itrp_SWAP, itrp_DEPTH, itrp_CINDEX, itrp_MINDEX, itrp_ALIGNPTS,
  itrp_RAW, itrp_UTP, itrp_LOOPCALL, itrp_CALL, itrp_FDEF, itrp_IllegalInstruction, itrp_MDAP, itrp_MDAP,
  itrp_IUP, itrp_IUP, itrp_SHP, itrp_SHP, itrp_SHC, itrp_SHC, itrp_SHE, itrp_SHE,
  itrp_SHPIX, itrp_IP, itrp_MSIRP, itrp_MSIRP, itrp_ALIGNRP, itrp_RTDG, itrp_MIAP, itrp_MIAP,
  itrp_NPUSHB, itrp_NPUSHW, itrp_WS, itrp_RS, itrp_WCVT, itrp_RCVT, itrp_RC, itrp_RC,
  itrp_WC, itrp_MD, itrp_MD, itrp_MPPEM, itrp_MPS, itrp_FLIPON, itrp_FLIPOFF, itrp_DEBUG,
  itrp_LT, itrp_LTEQ, itrp_GT, itrp_GTEQ, itrp_EQ, itrp_NEQ, itrp_ODD, itrp_EVEN,
  itrp_IF, itrp_EIF, itrp_AND, itrp_OR, itrp_NOT, itrp_DELTAP1, itrp_SDB, itrp_SDS,
  itrp_ADD, itrp_SUB, itrp_DIV, itrp_MUL, itrp_ABS, itrp_NEG, itrp_FLOOR, itrp_CEILING,
  itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND,
  itrp_WCVTFOD, itrp_DELTAP2, itrp_DELTAP3, itrp_DELTAC1, itrp_DELTAC2, itrp_DELTAC3, itrp_SROUND, itrp_S45ROUND,
  itrp_JROT, itrp_JROF, itrp_ROFF, itrp_IllegalInstruction, itrp_RUTG, itrp_RDTG, itrp_SANGW, itrp_AA,

  itrp_FLIPPT, itrp_FLIPRGON, itrp_FLIPRGOFF, itrp_IDefPatch, itrp_IDefPatch, itrp_SCANCTRL, itrp_SDPVTL, itrp_SDPVTL,
  itrp_GETINFO, itrp_IDEF, itrp_ROTATE, itrp_MAX, itrp_MIN, itrp_SCANTYPE, itrp_INSTCTRL, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_PUSHB1, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB,
  itrp_PUSHW1, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP
}
#endif /* FSCFG_NO_INITIALIZED_DATA */
;

/* the old itrp_Init function and tables now live in history.fnt - deanb */


#ifdef  GET_STACKSPACE
  int32 MaxStackSize = 0;

  #define PUSH(p, x) \
	{ \
	  if (p - LocalGS.globalGS->stackBase > MaxStackSize) \
		MaxStackSize = p - LocalGS.globalGS->stackBase; \
	  (*(p)++ = (x)); \
	}

#else
  #define PUSH( p, x ) ( *(p)++ = (x) )
#endif
  #define POP( p )     ( *(--p) )

#define BADCOMPILER

#ifdef BADCOMPILER
#define BOOLEANPUSH( p, x ) PUSH( p, ((x) ? 1 : 0) ) /* MPW 3.0 */
#else
#define BOOLEANPUSH( p, x ) PUSH( p, x )
#endif

#ifdef FSCFG_DEBUG
void CHECK_RANGE (int32 n, int32 min, int32 max);
void CHECK_RANGE (int32 n, int32 min, int32 max)
{
  if (n > max || n < min)
	ERR_REPORT (ERR_RANGE, n, min, max, 0);
}


void CHECK_ASSERTION (int32 expression);
void CHECK_ASSERTION (int32 expression)
{
  if (!expression)
	ERR_REPORT (ERR_ASSERTION, expression, 0, 0, 0);
}


void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt);
void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt)
{
  int32 cvtCount = (int32)(pGS->globalGS->cvtCount - 1L);

  if ((int32)cvt > cvtCount || (int32)cvt < 0L)
	ERR_REPORT (ERR_CVT, cvt, 0, cvtCount, 0);
}


void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef);
void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef)
{
  int32 maxFdef = (int32)(pGS->globalGS->maxp->maxFunctionDefs - 1L);

  if ((int32)fdef > maxFdef || (int32)fdef < 0L)
	ERR_REPORT (ERR_FDEF, fdef, 0, maxFdef, 0);
}

#define CHECK_PROGRAM(a)

void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem);
void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem)
{
  int32 maxElem = (int32)(pGS->globalGS->maxp->maxElements - 1L);

/*
  At least 1 maxElements will always be available
*/
  if (!maxElem)
	maxElem++;

  if ((int32)elem > maxElem || (int32)elem < 0L)
	ERR_REPORT (ERR_ELEMENT, elem, 0, maxElem, 0);
}

void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem);
void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem)
{
  if (elem == &pGS->elements[1])
  {
	 int32 maxctrs, maxpts;

	maxctrs = MAX (pGS->globalGS->maxp->maxContours,
				   pGS->globalGS->maxp->maxCompositeContours);
	maxpts  = MAX (pGS->globalGS->maxp->maxPoints,
				   pGS->globalGS->maxp->maxCompositePoints);

	if ((int32)elem->nc > (int32)maxctrs || (int32)elem->nc < 1L)
	  ERR_REPORT (ERR_CONTOUR, elem->nc, 1, maxctrs, 0);

	if ((int32)elem->ep[elem->nc-1] > maxpts - 1L ||
		(int32)elem->ep[elem->nc-1] < 0L)
	  ERR_REPORT (ERR_POINT, elem->ep[elem->nc-1], 0, maxpts - 1L, 0);
  }
  else if (elem != &pGS->elements[0])
	ERR_REPORT (ERR_INDEX, elem, &pGS->elements[0], &pGS->elements[1], 0);
}

void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index);
void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index)
{
  int32 maxIndex = (int32)(pGS->globalGS->maxp->maxStorage - 1L);

  if ((int32)index > maxIndex || (int32)index < 0L)
	ERR_REPORT (ERR_STORAGE, index, 0, maxIndex, 0);
}

void CHECK_STACK (fnt_LocalGraphicStateType* pGS);
void CHECK_STACK (fnt_LocalGraphicStateType* pGS)
{
  int32 base = (int32)(pGS->stackPointer - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt);
void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if (pGS->elements == elem)
  {
	if ((int32)pt > pGS->globalGS->maxp->maxTwilightPoints - 1L ||
		(int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, pGS->globalGS->maxp->maxTwilightPoints - 1L, 0);
  }
  else                                                      /* phantom points */
  {
	if ((int32)pt > elem->ep[elem->nc-1] + 2L || (int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, elem->ep[elem->nc-1] + 2L, 0);
  }
}

void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr);
void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if ((int32)ctr > elem->nc - 1L || (int32)ctr < 0L)
	ERR_REPORT (ERR_CONTOUR, ctr, 0, elem->nc -1L, 0);
}

void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y);
void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y)
{
  if ( x == 0 && y == 0 )
	ERR_REPORT (ERR_VECTOR, x, y, 0, 0);
}

void CHECK_LARGER (int32 min, int32 n);
void CHECK_LARGER (int32 min, int32 n)
{
  if ( n <= min )
	ERR_REPORT (ERR_LARGER, min, n, 0, 0);
}

void CHECK_INT8 (int32 n);
void CHECK_INT8 (int32 n)
{
  if ( n & 0xFFFFFF00 )
	ERR_REPORT (ERR_INT8, n, 0, 0, 0);
}

void CHECK_INT16 (int32 n);
void CHECK_INT16 (int32 n)
{
  if ( n & 0xFFFF0000 )
	ERR_REPORT (ERR_INT16, n, 0, 0, 0);
}

void CHECK_SELECTOR (int32 n);
void CHECK_SELECTOR (int32 n)
{
  if ( n & ~((int32)SELECTOR_FLAGS) )
	ERR_REPORT (ERR_SELECTOR, n, 0, 0, 0);
}

void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt);
void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt)
{
  int32 base = (int32)(pt - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void POP_CHECK (F26Dot6*);
void POP_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr <= base)
	ERR_REPORT (ERR_STACK, (stackPtr - base - 1L), 0, (max - base), 0);
  return;
}

void PUSH_CHECK (F26Dot6*);
void PUSH_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr > max )
	ERR_REPORT (ERR_STACK, (stackPtr - base), 0, (max - base), 0);
  return;
}

#define CHECK_POP(s)                (POP_CHECK(s),POP(s))
#define CHECK_PUSH(s, v)            (PUSH_CHECK(s),PUSH(s, v))

#else
#define CHECK_RANGE(a,b,c)
#define CHECK_ASSERTION(a)
#define CHECK_CVT(pgs,b)
#define CHECK_POINT(pgs,b,c)
#define CHECK_CONTOUR(pgs,b,c)
#define CHECK_FDEF(pgs,b)
#define CHECK_PROGRAM(a)
#define CHECK_ELEMENT(pgs,b)
#define CHECK_ELEMENTPTR(pgs,b)
#define CHECK_STORAGE(pgs,b)
#define CHECK_STACK(pgs)
#define CHECK_VECTOR(a,b)
#define CHECK_LARGER(a,b)
#define CHECK_INT8(a)
#define CHECK_INT16(a)
#define CHECK_SELECTOR(a)
#define CHECK_SUBSTACK(pgs,a)
#define CHECK_POP(s)                POP(s)
#define CHECK_PUSH(s, v)            PUSH(s, v)
#endif

/*@@*/

/* ClaudeBe 4/15/98 new secure rasterizer testing of critical errors */
/* errors originally detected by the fstrace callback trace function */
/* moved inside the rasterizer for performance reason */

#ifdef FSCFG_SECURE

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) \
 \
  if (stackPtr - (int32)(lNumItems) < LocalGS.globalGS->stackBase) \
{ \
	LocalGS.ercReturn = SECURE_STACK_UNDERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) \
 \
  if (stackPtr + (int32)(lNumItems) > LocalGS.globalGS->stackMax) \
{ \
	LocalGS.ercReturn = SECURE_STACK_OVERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_SUBSTACK(stackPtr) \
 \
  if ((stackPtr < LocalGS.globalGS->stackBase) || (stackPtr >= LocalGS.globalGS->stackMax)) \
{ \
	LocalGS.ercReturn = SECURE_INVALID_STACK_ACCESS;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_POINT(elem, pt) \
{ \
    if (LocalGS.elements == elem) \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxp->maxTwilightPoints || \
		 (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
    else \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxPointsIncludePhantom || (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
}

#define SECURE_CHECK_FDEF(fdef) \
{ \
    if ((int32)fdef >= (LocalGS.globalGS->maxp->maxFunctionDefs) || (int32)fdef < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_FDEF_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_PROGRAM(pgmIndex) \
{ \
    if (pgmIndex >= MAXPREPROGRAMS) \
    { \
	  LocalGS.ercReturn = SECURE_ERR_FUNCTION_NOT_DEFINED;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_ZONE(elem) \
{ /* in theory we should compare with maxp->maxElements but the rasterizer always allocate for MAX_ELEMENTS zones */ \
    if ((int32)elem >= MAX_ELEMENTS || (int32)elem < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_INVALID_ZONE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) \
{ \
	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM) \
	/* in the glyph program, both zone (glyph and twilight are initialized */ \
	{ \
	    if (LocalGS.globalGS->pgmIndex != PREPROGRAM || LocalGS.elements != elem ) \
		/* in the pre-program, only the twilight zone is initialized, */ \
		/* in any other zone i.e. font program, none of the zones are initialized */ \
		{ \
	       LocalGS.ercReturn = SECURE_UNITIALIZED_ZONE;  /* error returned to client */ \
	       return LocalGS.pbyEndInst; \
		} \
    } \
}


#define SECURE_CHECK_IDEF_OPCODE(idef) \
{ \
    if ( idef & 0xFFFFFF00 ) \
    { \
	  LocalGS.ercReturn = SECURE_INST_OPCODE_TO_LARGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_IDEF_OVERFLOW() \
{ \
    if (LocalGS.globalGS->instrDefCount >= LocalGS.globalGS->maxp->maxInstructionDefs) \
    { \
	  LocalGS.ercReturn = SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_STORAGE(index) \
{ \
    if ((int32)index >= (LocalGS.globalGS->maxp->maxStorage) || (int32)index < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_STORAGE_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CONTOUR(elem, ctr) \
{ /* The reason in SECURE_CHECK_CONTOUR that we are checking against elem->nc instead of maxContours */ \
	/* is that we will access CE2->sp[contour] and we may try to access a point out of bounds */ \
    if ((int32)ctr < 0L || (int32)ctr >= (elem)->nc) \
    { \
	  LocalGS.ercReturn = SECURE_CONTOUR_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CVT(cvt) \
{ \
    if ((int32)cvt >= (LocalGS.globalGS->cvtCount) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) \
{ \
    if (((int32)cvt >= (LocalGS.globalGS->cvtCount) && cvt > 255) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}
#endif // FSCFG_FONTOGRAPHER_BUG

#else

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) 
#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) 
#define SECURE_CHECK_SUBSTACK(stackPtr) 
#define SECURE_CHECK_POINT(elem, pt) 
#define SECURE_CHECK_FDEF(fdef) 
#define SECURE_CHECK_PROGRAM(pgmIndex)
#define SECURE_CHECK_ZONE(elem)
#define SECURE_CHECK_IDEF_OPCODE(idef) 
#define SECURE_CHECK_IDEF_OVERFLOW() 
#define SECURE_CHECK_STORAGE(index) 
#define SECURE_CHECK_CONTOUR(elem, ctr) 
#define SECURE_CHECK_CVT(cvt) 
#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) 

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) 
#endif // FSCFG_FONTOGRAPHER_BUG

#endif


#define BIT0( t ) ( (t) & 0x01 )
#define BIT1( t ) ( (t) & 0x02 )
#define BIT2( t ) ( (t) & 0x04 )
#define BIT3( t ) ( (t) & 0x08 )
#define BIT4( t ) ( (t) & 0x10 )
#define BIT5( t ) ( (t) & 0x20 )
#define BIT6( t ) ( (t) & 0x40 )
#define BIT7( t ) ( (t) & 0x80 )

/****** Element Codes *********/
#define SCE0_CODE       0x13
#define SCE1_CODE       0x14
#define SCE2_CODE       0x15
#define SCES_CODE       0x16

/****** Control Codes *********/
#define IF_CODE         0x58
#define ELSE_CODE       0x1B
#define EIF_CODE        0x59
#define ENDF_CODE       0x2d
#define MD_CODE         0x49

#ifdef FSCFG_SUBPIXEL
	// For SubPixel, rather than deciding within the rounding function whether we're currently
	// running SubPixel at all, and whether we're in the SubPixel-specific direction, we
	// install the appropriate version of the rounding function into the local ParameterBlock.
	// There are two parameters that determine this installation:
	// - a boolean "inSubPixelDirection" in LocalGS, set whenever the pv changes (eg. in SVTCA[X])
	// - an enum "roundState" in localParBlock, set whenever rounding state changes (eg. in RTG[])
	// It is necessary to have variables for these two parameters, because the states they
	// represent change independently, yet the round function depends on both parameters.
	// Whenever any of these two parameters change, we index the matrix "itrp_RoundFunction"
	// below to install the correct rounding function into the local ParameterBlock. 
	// Exception: itrp_RoundDownToGridSP, the SubPixel version of the RDTG function, inspects
	// the pv and actually rounds down to grid if pv == dpv. (cf. comments in itrp_RoundDownToGridSP)
	
	typedef enum { inRtdg = 0, inRdtg, inRutg, inRtg, inRthg, inRoff, inSRnd, inS45Rnd } RoundFunction;
	#ifndef FSCFG_NO_INITIALIZED_DATA
	const
	#endif
		  FntRoundFunc itrp_RoundFunction[2][8]
	#ifndef FSCFG_NO_INITIALIZED_DATA
												=  {{itrp_RoundToDoubleGrid,   itrp_RoundDownToGrid,   itrp_RoundUpToGrid,   itrp_RoundToGrid,   itrp_RoundToHalfGrid,   itrp_RoundOff,   itrp_SuperRound, itrp_Super45Round},
													{itrp_RoundToDoubleGridSP, itrp_RoundDownToGridSP, itrp_RoundUpToGridSP, itrp_RoundToGridSP, itrp_RoundToHalfGridSP, itrp_RoundOffSP, itrp_SuperRound, itrp_Super45Round}}
	#endif
	;
	// Following are two helper macros to update the aforementioned parameters "inSubPixelDirection"
	// and "roundState", along with installing the updated rounding function. The purpose of these
	// macros is to assert correspondence of the two parameters with the rounding function by system,
	// rather than by industriousness. The first helper macro is used whenever the projection vector
	// changes (eg. in SVTCA[X]) which changes whether or not we're in the SubPixel-specific direction.
	// The second helper macro is used whenever the round state changes (eg. in RTG[]).

	// Two versions of the first helper macro to update
	// - localGS.inSubPixelDirection (flag)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the projection vector.
	// We're using two different macros merely because VC wouldn't let us nest an #ifdef within a #define
	#ifdef NoVirtRoundInPrep
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection && (Tuned4SubPixel((localGS).globalGS) || (localGS).globalGS->pgmIndex != PREPROGRAM)][par->roundState];	\
			}
	#else
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
			}
	#endif

	// Second helper macro to update
	// - localParBlock.roundState (enum)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the round state.
	#define UpdateRoundFunctionByRoundState(localGS,state)											\
		{																							\
			fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																									\
			par->roundState = (state);																\
			par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
		}

	// Helper macro to used to determine whether or not to skip a delta instruction or function.
	// In backwardscompatibility mode, deltas are skipped if they are in SubPixel direction or
	// if they are applied to an untouched/unmoved point or if they are postIUP. Additionally,
	// deltas are skipped in composites if they are in SubPixel direction for proper centering
	// and vertical positioning of diacritical marks.
	// See also comments in itrp_SHP_Common.
	#ifdef InlineDeltasOnly
		#define AMovedPointInNonSPDirection(localGS,zonePtr,pointNum)							\
			((uint16)(!VerticalSPDirection((localGS).globalGS) ?								\
					  ProjVectInY((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & YMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupyCalled))) :	\
					  ProjVectInX((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & XMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupxCalled)))))
	#endif

#endif // FSCFG_SUBPIXEL

// Macros for rounding to grid etc. The purpose of these macros is to make the code more readable
// in cases such as MIRP, where rounding is performed inline for optimization reasons.
// - All rounding is applied to non-negative numbers only, negative numbers have their sign changed
//   before and after. 
// - Engine compensation is added to the unrounded number. Notice that substituting (literal) 0 for
//   engine will be optimized by the compiler
// - Rounding, in principle, follows the pattern in RTG:
//   - add half the "resolution" (this corresponds to adding 0.5)
//   - mask with the complement of "resolution"-minus-1 (this corresponds to a truncated division by
//	   "resolution", immediately followed by a multiplication by the same amount)
//	   Notice that masking only works with powers of two for the resolution

// for round-to-double-grid, we simply use half the resolution
#define RTDG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
		x = -x;						\
	}

// for round-down-to-grid, we skip the part that adds 0.5
#define RDTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-up-to-grid, we add "0.9999" instead of 0.5
#define RUTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

#define RTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-to-half-grid, we first round-down-to-grid, then add 0.5
#define RTHG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
		x = -x;						\
	}

// for round-off, we have to do the engine compensation part only
#define ROFF(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
	} else {						\
		x -= engine;				\
	}


// Macro for testing against cvt cut-in. The purpose of this macro is to make the code more readable
// in cases such as MIRP, where this test is performed in various places in accordance with #defines
// and flags. Notice that substituting (literal) 1 for overscale will be optimized by the compiler.
#define CVTCI(parameterBlock,distance,originalDistance,overscale)													\
	{																												\
		F26Dot6 difference = distance - originalDistance;															\
		difference *= overscale;																					\
		if (difference > parameterBlock->wTCI || difference < -parameterBlock->wTCI) /* not within cvt cut-in? */	\
			distance = originalDistance;																			\
	}

/* Set default values for all variables in globalGraphicsState DefaultParameterBlock
 *      Eventually, we should provide for a Default preprogram that could optionally be 
 *      run at this time to provide a different set of default values.
 */
ErrorCode itrp_SetDefaults (
	void *  pvGlobalGS,
	Fixed   fxPixelDiameter)
{
  fnt_ParameterBlock *par;
  fnt_GlobalGraphicStateType *  globalGS;

  globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

  par = &globalGS->defaultParBlock;

#ifdef FSCFG_SUBPIXEL
  par->roundState = inRtg;
  par->RoundValue = itrp_RoundFunction[RunningSubPixel(globalGS)
#ifdef NoVirtRoundInPrep
	// at this point, globalGS->pgmIndex is not defined. However, we may assume that we're called
	// exclusively from fsg_RunPreProgram, hence we assume that we're about to do the pre-program
	&& Tuned4SubPixel(globalGS)
#endif
	][par->roundState]; // at this point, LocalGS.inSubPixelDirection may not be defined
#else
  par->RoundValue = itrp_RoundToGrid;
#endif
  par->minimumDistance = FNT_PIXELSIZE;
  par->wTCI = FNT_PIXELSIZE * 17 / 16;
  par->sWCI = 0;
  par->sW   = 0;
  par->autoFlip = true;
  par->deltaBase = 9;
  par->deltaShift = 3;
  par->angleWeight = 128;
  par->scanControl = 0;
  par->instructControl = 0;

/* Set up the engine compensation array for the interpreter */
/* This will be indexed into by the booleans in some instructions */
  globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
  globalGS->engine[1] = FIXEDTODOT6 (FIXEDSQRT2 - fxPixelDiameter);  /* Black distance */
  globalGS->engine[2] = -globalGS->engine[1];                        /* White distance */

  return NO_ERR;
}

/************************************************************************/

/*
 * Illegal instruction trap
 */
FS_PRIVATE uint8* itrp_IllegalInstruction (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
	FS_UNUSED_PARAMETER(pbyInst);

	LocalGS.ercReturn = UNDEFINED_INSTRUCTION_ERR;  /* returned to client */
	return LocalGS.pbyEndInst;                      /* stops innerEx loop */
}

/************************************************************************/

/*  Scale vector (x,y) to unit length in 2.14   rewrite - 1/25/93 - deanb */

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec)
{
	Fract fLength;
	int32 lSumOfSquares;
	 int32 lShift;

	CHECK_RANGE (x, -32768L << 6, 32767L << 6);
	CHECK_RANGE (y, -32768L << 6, 32767L << 6);


	if ((x == 0L) && (y == 0L))             /* if null vector in */
	{
		pVec->x = ONEVECTOR;                /* default to unit x vector */
		pVec->y = 0;
	}
	else
	{
		if ((x < 32767L) && (x > -32768L) && (y < 32767L) && (y > -32768L))
		{
			lSumOfSquares = (x * x) + (y * y);  
			
				lShift = 8 * sizeof(Fract) - 17; /* to get x and y to 2.30 */
			while (lSumOfSquares < 0x20000000L)
			{
				lSumOfSquares <<= 2;        /* maximize precision */
					 lShift++;
			}
				x <<= lShift;
				y <<= lShift;                         /* keep x and y in step */
		}
		else
		{
			while ((x < 0x20000000L) && (x > -0x20000000L) && (y < 0x20000000L) && (y > -0x20000000L))
			{
				x <<= 1;
				y <<= 1;
			}
			lSumOfSquares = FracMul(x, x) + FracMul(y, y);
		}
		fLength = FracSqrt(lSumOfSquares);
		pVec->x = ROUNDFIXTOINT (FracDiv(x, fLength));
		pVec->y = ROUNDFIXTOINT (FracDiv(y, fLength));
	}
}


/******************** BEGIN Internal Rounding Routines ***************************/

F26Dot6 itrp_RoundToDoubleGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTDG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToDoubleGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTDG(x,engine,VIRTUAL_PIXELSIZE_RTDG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGridSP
#endif


F26Dot6 itrp_RoundDownToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RDTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundDownToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundDownToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
#ifdef RDTGRoundsDownToGrid
	// Historically, if a point to be aligned was away by 1.5 degrees or more from the line to which to align, the TypemanTalk
	// Align has translated to SPVTL, followed by RDTG and MDRP. This has a major problem: The MDRP instruction uses the set pv
	// to measure the original distance on the UNINSTRUCTED outline. This gives us an "original" distance which is more or less
	// wrong, depending on how far the reference point has moved already (notice that it is most likely that the reference point
	// has moved somewhat in x and in y before the alignee gets to be aligned). Subsequently, when MDRP gets to move the point,
	// it uses the same pv again, but this time around on the INSTRUCTED outline, in order to determine how far the point has to
	// be moved in the end. Luckily, this is used in connection with RDTG, which is applied to the "original" distance, and
	// thereby often reduces the "original" distance to 0, which often is closer the the correct original distance than the one
	// obtained by using the pv on the uninstructed outline.
	//   In SubPixel, however, these erroneous "original" distances would be rounded down to the nearest 1/16 of a pixel, and
	// with that become highly visible (a distance of just under 1 pixel, which is what gets rounded down to 0 in b/w, is too
	// large a distance to be ignored in SP). Therefore, we have to make an exception here. The recently introduced TypemanTalk
	// DAlign command, in contrast, uses the DUAL projection vector to measure the original distance on the UNINSTRUCTED outline,
	// which gives us the correct original distance. Therefore the exception is to test whether we're using the PV (in which case
	// we fall back onto the b/w rounding) or not (in which case we're using the SP rounding).
	if (Tuned4SubPixel(LocalGS.globalGS) || LocalGS.OldProject != itrp_Project) { // we're using the dual projection vector
#endif
		F26Dot6 x = xin;

		engine /= ENGINE_COMP_OVERSCALE;
		RDTG(x,engine,VIRTUAL_PIXELSIZE_RDTG);
		if (( (int32) (xin ^ x)) < 0 && xin) {
			x = 0; /* The sign flipped, make zero */
		}
		return x;
#ifdef RDTGRoundsDownToGrid
	} else { // we're using the "normal" projection vector
		return itrp_RoundDownToGrid(GSA xin,engine);
	}
#endif
} // itrp_RoundDownToGridSP
#endif


F26Dot6 itrp_RoundUpToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RUTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundUpToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RUTG(x,engine,VIRTUAL_PIXELSIZE_RUTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGridSP
#endif


F26Dot6 itrp_RoundToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTG(x,engine,VIRTUAL_PIXELSIZE_RTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGridSP
#endif


F26Dot6 itrp_RoundToHalfGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTHG(x,engine,FNT_PIXELSIZE);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? FNT_PIXELSIZE / 2 : -FNT_PIXELSIZE / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToHalfGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTHG(x,engine,VIRTUAL_PIXELSIZE_RTHG);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? VIRTUAL_PIXELSIZE_RTHG / 2 : -VIRTUAL_PIXELSIZE_RTHG / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGridSP
#endif


/*
 * Internal rounding routine
 */
F26Dot6 itrp_RoundOff (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	ROFF(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOff

/*
 * Internal rounding routine
 */
#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundOffSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	ROFF(x,engine,VIRTUAL_PIXELSIZE_ROFF);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOffSP
#endif


/************************************************************************/

/*
 * Internal rounding routine
 */
F26Dot6 itrp_SuperRound (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
	x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin) 
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 itrp_Super45Round (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
	x = -x;
  }
  if (((xin ^ x)) < 0 && xin)
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/******************** END Rounding Routines ***************************/


/* 3-versions ************************************************************************/

/*
 * Moves the point in element by delta (measured against the projection vector)
 * along the freedom vector.
 */

FS_PRIVATE void itrp_MovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
	VECTORTYPE pfProj;
	VECTORTYPE fx;
	VECTORTYPE fy;
	  
	pfProj = LocalGS.pfProj;
	fx = LocalGS.free.x;
	fy = LocalGS.free.y;

	CHECK_POINT (&LocalGS, element, point);

	if (pfProj != ONEVECTOR)
	{
		if (fx) 
		{
			if (pfProj == fx)                   /* if proj.x = 1 */
			{
				element->x[point] += delta;
			}
			else
			{
				element->x[point] += LongMulDiv (delta, (int32)fx, (int32)pfProj);
			}
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			if (pfProj == fy)                   /* if proj.y = 1 */
			{
				element->y[point] += delta;
			}
			else
			{
				element->y[point] += LongMulDiv (delta, (int32)fy, (int32)pfProj);
			}
			element->f[point] |= YMOVED;
		}
	}
	else
	{
		if (fx) 
		{
			element->x[point] += VECTORMUL (delta, fx);
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			element->y[point] += VECTORMUL (delta, fy);
			element->f[point] |= YMOVED;
		}
	}
}


/*
 * For use when the projection and freedom vectors coincide along the x-axis.
 */

FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType*element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->x[point] += delta;
  element->f[point] |= XMOVED;
}


/*
 * For use when the projection and freedom vectors coincide along the y-axis.
 */
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->y[point] += delta;
  element->f[point] |= YMOVED;
}

/*
 * projects x and y into the projection vector.
 */
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.proj.x) + VECTORMUL (y, LocalGS.proj.y));
}


/*
 * projects x and y into the old projection vector.
 */
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.oldProj.x) + VECTORMUL (y, LocalGS.oldProj.y));
}


/*
 * Projects when the projection vector is along the x-axis
 */
F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(y);

  return (x);
}


/*
 * Projects when the projection vector is along the y-axis
 */
F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(x);

  return (y);
}


/*************************************************************************/

/*** Compensation for Transformations ***/

/*
* Internal support routine, keep this guy FAST!!!!!!!          <3>
*/
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0)
{
  VECTORTYPE pvx, pvy;
  fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
  Fixed sySq, sxSq, strSq;

/* Do as few Math routines as possible to gain speed */

  pvx = LocalGS.proj.x;
  pvy = LocalGS.proj.y;
  if (pvy) 
  {
	if (pvx)
	{
	  if (LocalGS.cvtDiagonalStretch == 0)    /* cache is now invalid */
	  {
		pvy = VECTORDOT (pvy, pvy);
		pvx = VECTORDOT (pvx, pvx);
		sySq = FixMul (globalGS->cvtStretchY, globalGS->cvtStretchY);
		sxSq = FixMul (globalGS->cvtStretchX, globalGS->cvtStretchX);

		strSq = FixMul (VECTOR2FIX(pvx),sxSq) + FixMul (VECTOR2FIX(pvy),sySq);
		if  (strSq > ONEFIX)      /* Never happens! */
		  return ONEFIX;

		/* Convert 16.16 to 2.30, compute square root, round to 16.16 */
		LocalGS.cvtDiagonalStretch = (FracSqrt (strSq<<14) + (1<<13)) >> 14;
	  }
	  return LocalGS.cvtDiagonalStretch;
	}
	else        /* pvy == +1 or -1 */
	  return globalGS->cvtStretchY;
  }
  else  /* pvx == +1 or -1 */
	return globalGS->cvtStretchX;
}


/*      Functions for function pointer in local graphic state
*/

FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n)
{
  CHECK_CVT (&LocalGS, n);
  return LocalGS.globalGS->controlValueTable[ n ];
}


FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n)
{
  Fixed scale;

  CHECK_CVT (&LocalGS, n);
  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->controlValueTable[ n ], scale));
}


FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0)
{
  return LocalGS.globalGS->localParBlock.scaledSW;
}


/*
 *
 */
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0)
{
  Fixed scale;

  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->localParBlock.scaledSW, scale));
}


/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);
  CHECK_CVT (&LocalGS, number);
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}



/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);

  CHECK_CVT (&LocalGS, number);

  delta = FixDiv (delta, itrp_GetCVTScale(GSA0));
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}

/*************************************************************************/

/*
 * This is the tracing interpreter.
 */
FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */

	if (pbyInst < pbyEndInst)
	{
		ERR_START ();
		while ((pbyInst < pbyEndInst) && (LocalGS.TraceFunc != NULL))
		{
			LocalGS.insPtr = pbyInst;               /* save for client */
			LocalGS.opCode = *pbyInst;              /* save for client */
			ERR_RECORD (*pbyInst);
			LocalGS.TraceFunc (&LocalGS, pbyEndInst);
			if (LocalGS.TraceFunc == NULL)          /* allow client to break out */
			{
				break;
			}
			lOpCode = (int32)*pbyInst;
			pbyInst++;
			pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
			ERR_BREAK ();
		}
		ERR_END ();
	}
}

/*************************************************************************/

/*
 * This is the fast non-tracing interpreter inner loop.
 */

FS_PRIVATE void itrp_InnerExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	ERR_START ();
	
	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */
	
	while (pbyInst < pbyEndInst)
	{
		ERR_RECORD (*pbyInst);
			  
		lOpCode = (int32)*pbyInst;  /* opCode no longer saved in LocalGS */
		pbyInst++;

		pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
		ERR_BREAK ();
	}
	ERR_END ();
}

/*************************************************************************/


#ifdef FSCFG_DEBUG
FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n);

FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0)
{
  ERR_REPORT (ERR_GETSINGLEWIDTHNIL, 0, 0, 0, 0);
  return 0;
}

FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n)
{
  ERR_REPORT (ERR_GETCVTENTRYNIL, 0, 0, 0, 0);
  return 0;
}
#endif

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteFontPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	fnt_GlobalGraphicStateType *    globalGS;

#ifdef FSCFG_SECURE
	int32 i;
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->instrDefCount = 0;        /* none allocated yet, always do this, even if there's no fontProgram */
	globalGS->init          = TRUE;
	globalGS->pgmIndex = FONTPROGRAM;

	/* To avoid accessing unitialized memory when setting LocalGS.MIRPCode */
    globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
    globalGS->engine[1] = 0;  /* Black distance */
    globalGS->engine[2] = 0;                        /* White distance */


#ifdef FSCFG_SECURE
	/* initialize globalGS->funcDef[...].pgmIndex with MAXPREPROGRAMS to detect calls to undefined functions */
	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGS->funcDef[i].pgmIndex = MAXPREPROGRAMS;

	}
#endif // FSCFG_SECURE

	if (globalGS->pgmList[FONTPROGRAM].Instruction)
	{
		return itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[FONTPROGRAM].Instruction,
			globalGS->pgmList[FONTPROGRAM].Instruction +
				globalGS->pgmList[FONTPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	return NO_ERR;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecutePrePgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	ErrorCode   result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->init          = TRUE;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* copy gState parameters */

	globalGS->pgmIndex = PREPROGRAM;

	if (globalGS->pgmList[PREPROGRAM].Instruction)
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[PREPROGRAM].Instruction,
			globalGS->pgmList[PREPROGRAM].Instruction + globalGS->pgmList[PREPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	else
	{
		result = NO_ERR;
	}

	if (! (globalGS->localParBlock.instructControl & DEFAULTFLAG))
		globalGS->defaultParBlock = globalGS->localParBlock;    /* change default parameters */

	return result;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteGlyphPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	uint8 *             ptr,
	uint8 *    eptr,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode                       result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	result = NO_ERR;

	globalGS->init          = FALSE;
	globalGS->pgmIndex		= GLYPHPROGRAM;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* default parameters for glyphs */
	
	if (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG))
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			ptr,
			eptr,
			globalGS,
			TraceFunc);
	}
	*pbChangeScanControl = (globalGS->localParBlock.scanControl !=
						   globalGS->defaultParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);

	return result;
}

/*************************************************************************/

/*
 * Executes the font instructions.
 *
 * Parameter Description
 *
 * elements points to the character elements. Element 0 is always
 * reserved and not used by the actual character.
 *
 * ptr points at the first instruction.
 * eptr points to right after the last instruction
 *
 * globalGS points at the global graphics state
 *
 * TraceFunc is pointer to a callback functioned called with a pointer to the
 *              local graphics state if TraceFunc is not null.
 *
 * Note: The stuff globalGS is pointing at must remain intact
 *       between calls to this function.
 */
FS_PRIVATE ErrorCode itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc)

{
#ifdef FSCFG_REENTRANT
	fnt_LocalGraphicStateType thisLocalGS;
	fnt_LocalGraphicStateType* pLocalGS = &thisLocalGS;
#endif
	fnt_ElementType       aElements[MAX_ELEMENTS];

	MEMCPY((void*)&(aElements[TWILIGHTZONE]), (void*)pTwilightElement, sizeof (fnt_ElementType));
	MEMCPY((void*)&(aElements[GLYPHELEMENT]), (void*)pGlyphElement, sizeof (fnt_ElementType));
	
	STAT_ON_FNTEXEC;                        /* start STAT timer */    
	
	LocalGS.globalGS = globalGS;            /* init Local Graphics State */
	LocalGS.elements = aElements;
	LocalGS.Pt0 = 0; 
	LocalGS.Pt1 = 0; 
	LocalGS.Pt2 = 0;
	LocalGS.CE0 = &aElements[GLYPHELEMENT];
	LocalGS.CE1 = &aElements[GLYPHELEMENT];
	LocalGS.CE2 = &aElements[GLYPHELEMENT];
	LocalGS.free.x = ONEVECTOR;
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.oldProj.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.proj.y = 0;
	LocalGS.oldProj.y = 0;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
	LocalGS.OldProject = itrp_XProject;
	LocalGS.loop = 0;           /* 1 less than count for faster loops. mrr */

	LocalGS.ulJumpCounter = globalGS->ulMaxJumpCounter;           /* counter used to catch infinite loops */
	LocalGS.ulRecursiveCall = globalGS->ulMaxRecursiveCall;           /* counter used to catch deep recrusion */

	if (globalGS->engine[1] == 0)           /* if engine compenstion turned off */
	{
		LocalGS.MIRPCode = MIRPX;           /* default to fast mirp */
	}
	else
	{
		LocalGS.MIRPCode = MIRPG;           /* fall back to general mirp */
	}

	if (globalGS->pgmIndex == FONTPROGRAM)
	{
#ifdef FSCFG_SUBPIXEL
		// init since we don't do itrp_SetDefaults prior to executing the fpgm
		globalGS->localParBlock.roundState = inRtg;
		globalGS->localParBlock.RoundValue = itrp_RoundToGrid;

		globalGS->subPixelCompatibilityFlags = 0;
#endif
#ifdef FSCFG_DEBUG
		LocalGS.GetCVTEntry = itrp_GetCVTEntryNil;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthNil;
#else
		LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
#endif
		LocalGS.ChangeCvt = itrp_ChangeCvtFast;
	}
	else
	{
#ifdef FSCFG_SUBPIXEL
		globalGS->subPixelCompatibilityFlags &= ~(SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inDiagEndCtrl | SPCF_inVacuformRound | SPCF_inTomsDiagonal);
		// can't do this when doing the font program, would try to access the localParBlock, which is still uninitialized at this point.
		UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif
		if (globalGS->pixelsPerEm <= 1)
			return NO_ERR;
		  
		if (globalGS->bSameStretch)
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
			LocalGS.ChangeCvt = itrp_ChangeCvtFast;
		} 
		else 
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntrySlow;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthSlow;
			LocalGS.ChangeCvt = itrp_ChangeCvtSlow;
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}

		if (globalGS->localParBlock.sW)     /* We need to scale the single width for this size  */
		{
			globalGS->localParBlock.scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)(globalGS->localParBlock.sW));
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}
	}
	
	LocalGS.stackPointer = globalGS->stackBase;
	LocalGS.TraceFunc = TraceFunc;
	LocalGS.ercReturn = NO_ERR;             /* default return value */

	if (TraceFunc != NULL)
	{
		LocalGS.Interpreter = itrp_InnerTraceExecute;
	}
	else
	{
		LocalGS.Interpreter = itrp_InnerExecute;
	}
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(globalGS) && CompatibleWidthSP(globalGS))
			InitPhaseControl(LocalGS.CE0);
#endif

	(*LocalGS.Interpreter) (GSA ptr, eptr);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!LocalGS.CE0->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,LocalGS.CE0);
	//	phaseControlExecuted == true by now
	}
#endif
	STAT_OFF_FNTEXEC;                            /* stop STAT timer */
	
	return LocalGS.ercReturn;               /* NO_ERR unless illegal inst */
}


/*************************************************************************/

/*** 2 internal LocalGS.pfProj computation support routines ***/

/*
 * Only does the check of LocalGS.pfProj
 */
  FS_PRIVATE void itrp_Check_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj = LocalGS.pfProj;

	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  LocalGS.pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
  }


/*
 * Computes LocalGS.pfProj and then does the check
 */
  FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj;

	pfProj = (VECTORTYPE)(VECTORDOT (LocalGS.proj.x, LocalGS.free.x) + VECTORDOT (LocalGS.proj.y, LocalGS.free.y));
	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
	LocalGS.pfProj = pfProj;

	LocalGS.cvtDiagonalStretch = 0;      /* invalidate cache */ 
  }

/******************************************/
/******** The Actual Instructions *********/
/******************************************/

/*
 * Set Vectors To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = 0;
	LocalGS.free.y = LocalGS.proj.y = ONEVECTOR;
	LocalGS.MovePoint = itrp_YMovePoint;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_YProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPY;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Vectors To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = ONEVECTOR;
	LocalGS.free.y = LocalGS.proj.y = 0;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_XProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPX;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = 0;
	LocalGS.proj.y = ONEVECTOR;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.proj.y = 0;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Freedom Vector to Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = 0;
	LocalGS.free.y = ONEVECTOR;
	LocalGS.pfProj = LocalGS.proj.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector to Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.pfProj = LocalGS.proj.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SPVTL (IPARAM)
  {
	int32 arg1, arg2;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

	CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);
	}

	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Dual Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SDPVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

//	Do the current domain
	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);

//	Do the old domain
	itrp_Normalize (LocalGS.CE1->ox[arg1] - LocalGS.CE2->ox[arg2], LocalGS.CE1->oy[arg1] - LocalGS.CE2->oy[arg2], &LocalGS.oldProj);

	if (BIT0 (lOpCode))	{ // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);

	  tmp = LocalGS.oldProj.y;
	  LocalGS.oldProj.y = LocalGS.oldProj.x;
	  LocalGS.oldProj.x = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = itrp_OldProject;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector To Line
 */
  FS_PRIVATE uint8* itrp_SFVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.free);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp     = LocalGS.free.y;
	  LocalGS.free.y     = LocalGS.free.x;
	  LocalGS.free.x     = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Write Projection Vector
 */
  FS_PRIVATE uint8* itrp_WPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.proj.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.proj.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	CHECK_VECTOR (LocalGS.proj.x, LocalGS.proj.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Write Freedom vector
 */
  FS_PRIVATE uint8* itrp_WFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.free.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.free.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

	CHECK_VECTOR (LocalGS.free.x, LocalGS.free.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Read Projection Vector
 */
  FS_PRIVATE uint8* itrp_RPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.y);
	return pbyInst;
  }

/*
 * Read Freedom Vector
 */
  FS_PRIVATE uint8* itrp_RFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.y);
	return pbyInst;
  }

/*
 * Set Freedom Vector To Projection Vector
 */
  FS_PRIVATE uint8* itrp_SFVTPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free = LocalGS.proj;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * itrp_ISECT ()
 *
 * Computes the intersection of two lines without using floating point!!
 *
 * (1) Bx + dBx * t0 = Ax + dAx * t1
 * (2) By + dBy * t0 = Ay + dAy * t1
 *
 *  1  => (t1 = Bx - Ax + dBx * t0) / dAx
 *  +2 =>   By + dBy * t0 = Ay + dAy/dAx * [ Bx - Ax + dBx * t0 ]
 *     => t0 * [dAy/dAx * dBx - dBy] = By - Ay - dAy/dAx* (Bx-Ax)
 *     => t0 (dAy*DBx - dBy*dAx) = dAx (By - Ay) + dAy (Ax-Bx)
 *     => t0 = [dAx (By-Ay) + dAy (Ax-Bx)] / [dAy*dBx - dBy*dAx]
 *     => t0 = [dAx (By-Ay) - dAy (Bx-Ax)] / [dBx*dAy - dBy*dAx]
 *     t0 = N/D
 *     =>
 *          N = (By - Ay) * dAx - (Bx - Ax) * dAy;
 *              D = dBx * dAy - dBy * dAx;
 *      A simple floating point implementation would only need this, and
 *      the check to see if D is zero.
 *              But to gain speed we do some tricks and avoid floating point.
 *
 */
  FS_PRIVATE uint8* itrp_ISECT (IPARAM)
  {
	F26Dot6 N, D;
	int32   arg1, arg2;
	F26Dot6 Bx, By, Ax, Ay;
	F26Dot6 dBx, dBy, dAx, dAy;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int32 arg1p, arg2p;
#endif

	{
	  fnt_ElementType*element = LocalGS.CE0;
	  F26Dot6*stack = LocalGS.stackPointer;

	  FS_UNUSED_PARAMETER(lOpCode);

      SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 5);

	  arg2 = (int32)CHECK_POP (stack); /* get one line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg1);
	  dAx = element->x[arg2] - (Ax = element->x[arg1]);
	  dAy = element->y[arg2] - (Ay = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  arg2p = arg2;
	  arg1p = arg1;
#endif

	  element = LocalGS.CE1;
	  arg2 = (int32)CHECK_POP (stack); /* get the other line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);
	  dBx = element->x[arg2] - (Bx = element->x[arg1]);
	  dBy = element->y[arg2] - (By = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (MABS(dBx) > MABS(dAx)) { // pick the line which is closer to the x-axis
		  arg2p = arg2;
		  arg1p = arg1;
	  }
#endif
	  arg1 = (int32)CHECK_POP (stack); /* get the point number */
	  SECURE_CHECK_POINT (LocalGS.CE2, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE2, arg1);
	  LocalGS.stackPointer = stack;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  // for our purposes, handle like a proportion (have intersected point follow proportional to parents)
	  // need no fv, pv set for ISECT, hence we don't test against LocalGS.inSubPixelDirection
	  if (LocalGS.CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS))
		AddProportion(&LocalGS,LocalGS.CE2,arg1p,arg1,arg2p);
#endif
				


	}
	LocalGS.CE2->f[arg1] |= XMOVED | YMOVED;
	{
	  F26Dot6*elementx = LocalGS.CE2->x;
	  F26Dot6*elementy = LocalGS.CE2->y;
	  if (dAy == 0) 
	  {
		if (dBx == 0) 
		{
		  elementx[arg1] = Bx;
		  elementy[arg1] = Ay;
		  return pbyInst;
		}
		N = By - Ay;
		D = -dBy;
	  } 
	  else if (dAx == 0) 
	  {
		if (dBy == 0) 
		{
		  elementx[arg1] = Ax;
		  elementy[arg1] = By;
		  return pbyInst;
		}
		N = Bx - Ax;
		D = -dBx;
	  } 
	  else if (MABS (dAx) >= MABS (dAy))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (By - Ay) - MulDiv26Dot6 (Bx - Ax, dAy, dAx);
		D = MulDiv26Dot6 (dBx, dAy, dAx) - dBy;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (By - Ay, dAx, dAy) - (Bx - Ax);
		D = dBx - MulDiv26Dot6 (dBy, dAx, dAy);
	  }

	  if (D) 
	  {
		elementx[arg1] = Bx + (F26Dot6) MulDiv26Dot6 (dBx, N, D);
		elementy[arg1] = By + (F26Dot6) MulDiv26Dot6 (dBy, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, put point in the middle */
		elementx[arg1] = (Bx + (dBx >> 1) + Ax + (dAx >> 1)) >> 1;
		elementy[arg1] = (By + (dBy >> 1) + Ay + (dAy >> 1)) >> 1;
	  }
	}
	return pbyInst;
  }

/*
 * Load Minimum Distance
 */
  FS_PRIVATE uint8* itrp_LMD (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.minimumDistance = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.minimumDistance);
	return pbyInst;
  }

/*
 * Load Control Value Table Cut In
 */
  FS_PRIVATE uint8* itrp_LWTCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.wTCI = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.wTCI);
	return pbyInst;
  }

/*
 * Load Single Width Cut In
 */
  FS_PRIVATE uint8* itrp_LSWCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.sWCI = CHECK_POP (LocalGS.stackPointer);
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.sWCI);
	return pbyInst;
  }

/*
 * Load Single Width , assumes value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_LSW (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->sW = (int16)arg;
	CHECK_LARGER (-1L, pb->sW);

	pb->scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)pb->sW); /* measurement should not come from the outline */
	return pbyInst;
  }

/* these functions were split out from itrp_SetLocalGraphicState - deanb */
  
  FS_PRIVATE uint8* itrp_SRP0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt0 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt1 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP2 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_LLOOP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.loop = (int32)(CHECK_POP (LocalGS.stackPointer)) - 1;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_POP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }


  FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM)
  {
	int32             arg;
	fnt_ElementType * element;

	switch (lOpCode)
	{
	  case SCES_CODE: 
		ERR_OPC ("SCES");
		break;
	  case SCE0_CODE: 
		ERR_OPC ("SCE0");
		break;
	  case SCE1_CODE: 
		ERR_OPC ("SCE1");
		break;
	  case SCE2_CODE: 
		ERR_OPC ("SCE2");
		break;
	  default:
		ERR_OPC ("???");
		break;
	}

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg);
    CHECK_ELEMENT (&LocalGS, arg);
	element = &LocalGS.elements[ arg ];

	switch (lOpCode)
	{
	  case SCES_CODE: 
		LocalGS.CE2 = element;
		LocalGS.CE1 = element;
	  case SCE0_CODE: 
		LocalGS.CE0 = element;
		break;
	  case SCE1_CODE: 
		LocalGS.CE1 = element;
		break;
	  case SCE2_CODE: 
		LocalGS.CE2 = element;
		break;
#ifdef FSCFG_DEBUG
	  default:
		ERR_REPORT (ERR_INVOPC, lOpCode, 0, 0, 0);
		break;
#endif
	}
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_SROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, true);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inSRnd);
#else
	pb->RoundValue = itrp_SuperRound; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_S45ROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, false);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inS45Rnd);
#else
	pb->RoundValue = itrp_Super45Round; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*********************************************************************/

/*  These routines were split out from SetRoundState  */
/*  They set the current rounding state, and all but  */
/*  RoundToGrid cause MIRP to fall back to MIRPG      */


FS_PRIVATE uint8* itrp_RTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtg)
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToGrid;
#endif
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTHG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRthg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToHalfGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTDG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtdg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToDoubleGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_ROFF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRoff);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundOff;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RDTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRdtg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundDownToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RUTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRutg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundUpToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

/*********************************************************************/


#define FRACSQRT2DIV2   11591
/*
 * Internal support routine for the super rounding routines
 */
  FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound)
  {
	 int32       tmp;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

	tmp = arg1 & 0xC0;

	if (normalRound) 
	{
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period = FNT_PIXELSIZE / 2;
		break;
	  case 0x40:
		pb->period = FNT_PIXELSIZE;
		break;
	  case 0x80:
		pb->period = FNT_PIXELSIZE * 2;
		break;
	  default:
		pb->period = 999; /* Illegal */
	  }
	  pb->periodMask = ~ (pb->period - 1);
	} 
	else 
	{
	  pb->period45 = FRACSQRT2DIV2;
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period45 >>= 1;
		break;
	  case 0x40:
		break;
	  case 0x80:
		pb->period45 <<= 1;
		break;
	  default:
		pb->period45 = 999; /* Illegal */
	  }
	  tmp = (sizeof (pb->period45) * 8 - 2 - FNT_PIXELSHIFT);
	  pb->period = (int16) ((pb->period45 + (1L << (tmp - 1))) >> tmp); /*convert from 2.30 to 26.6 */
	}

	tmp = arg1 & 0x30;
	switch (tmp) 
	{
	case 0x00:
	  pb->phase = 0;
	  break;
	case 0x10:
	  pb->phase = (int16)((pb->period + 2) >> 2);
	  break;
	case 0x20:
	  pb->phase = (int16)((pb->period + 1) >> 1);
	  break;
	case 0x30:
	  pb->phase = (int16)((pb->period + pb->period + pb->period + 2) >> 2);
	  break;
	}
	tmp = arg1 & 0x0f;
	if (tmp == 0) 
	{
	  pb->threshold = (int16)(pb->period - 1);
	} 
	else 
	{
	  pb->threshold = (int16)(((tmp - 4) * pb->period + 4) >> 3);
	}
  }

/*
 * Read Advance Width
 */
  FS_PRIVATE uint8* itrp_RAW (IPARAM)
  {
	F26Dot6* ox;
	int32 index;  

	FS_UNUSED_PARAMETER(lOpCode);

	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM)
	{
		LocalGS.ercReturn = RAW_NOT_IN_GLYPHPGM_ERR;  /* returned to client, error RAW not in glyph program */
		return LocalGS.pbyEndInst;
	}

	ox = LocalGS.elements[GLYPHELEMENT].ox;
	index = LocalGS.elements[GLYPHELEMENT].ep[LocalGS.elements[GLYPHELEMENT].nc - 1] + 1;      /* lsb point */

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH( LocalGS.stackPointer, ox[index+1] - ox[index] );
	return pbyInst;
  }

/*
 * DUPlicate
 */
  FS_PRIVATE uint8* itrp_DUP (IPARAM)
  {
	F26Dot6 top;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	top = LocalGS.stackPointer[-1];
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, top);
	return pbyInst;
  }

/*
 * CLEAR stack
 */
  FS_PRIVATE uint8* itrp_CLEAR (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.stackPointer = LocalGS.globalGS->stackBase;
	return pbyInst;
  }

/*********************************************************************/

/*
 * SWAP
 */
FS_PRIVATE uint8* itrp_SWAP (IPARAM)
{
	F26Dot6 *pfxStack;
	F26Dot6 fxTemp;
		   
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxTemp = pfxStack[0];
	pfxStack[0] = pfxStack[-1];
	pfxStack[-1] = fxTemp;
	
	return pbyInst;
}

/*********************************************************************/

/*
 * DEPTH
 */
  FS_PRIVATE uint8* itrp_DEPTH (IPARAM)
  {
	F26Dot6 depth = (F26Dot6)(LocalGS.stackPointer - LocalGS.globalGS->stackBase);
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, depth);
	return pbyInst;
  }

/*
 * Copy INDEXed value
 */
  FS_PRIVATE uint8* itrp_CINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	CHECK_PUSH (stack , tmp);
	return pbyInst;
  }

/*
 * Move INDEXed value
 */
  FS_PRIVATE uint8* itrp_MINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	if (arg1 > 0) 
	{
	  do 
	  {
		*p = * (p + 1); 
		p++;
	  } while (--arg1);
	  CHECK_POP (stack);
	}
	CHECK_PUSH (stack, tmp);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 *      Rotate element 3 to the top of the stack                        <4>
 *      Thanks to Oliver for the obscure code.
 */
  FS_PRIVATE uint8* itrp_ROTATE (IPARAM)
  {
	F26Dot6 *stack = LocalGS.stackPointer;
	F26Dot6 element1;
	F26Dot6 element2;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 3);
	element1 = *--stack;
	element2 = *--stack;

    *stack = element1;
	element1 = *--stack;
	*stack = element2;
	* (stack + 2) = element1;
	return pbyInst;
  }

/*********************************************************************/

/*
 * Move Direct Absolute Point
 */
FS_PRIVATE uint8* itrp_MDAP (IPARAM) {
	F26Dot6 fxProj;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;
	int32 iPoint;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint; 
	LocalGS.Pt1 = iPoint;

	if (BIT0 (lOpCode)) { // round?
		fxProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);
		fxProj = pb->RoundValue (GSA fxProj, LocalGS.globalGS->engine[0]) - fxProj;
	} else {
		fxProj = 0;         /* mark the point as touched */
	}

	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxProj);
	return pbyInst;
} // itrp_MDAP

/*********************************************************************/

/*
 * Move Indirect Absolute Point
 */
FS_PRIVATE uint8* itrp_MIAP (IPARAM) {
	int32   iPoint;
	int32   iCVTIndex;
	F26Dot6 fxNewProj;
	F26Dot6 fxOrigProj;
	F26Dot6 fxProjDif;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	fxNewProj = LocalGS.GetCVTEntry (GSA iCVTIndex);

	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint;
	LocalGS.Pt1 = iPoint;

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE0->x[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.x);
		pCE0->ox[iPoint] = pCE0->x[iPoint];
		pCE0->y[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.y);
		pCE0->oy[iPoint] = pCE0->y[iPoint];
	}

	fxOrigProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);

	if (BIT0 (lOpCode)) { // round?
		fxProjDif = fxNewProj - fxOrigProj;
		if (fxProjDif < 0) {
			fxProjDif = -fxProjDif;
		}
		if (fxProjDif > pb->wTCI) {
			fxNewProj = fxOrigProj;
		}
		fxNewProj = pb->RoundValue (GSA fxNewProj, LocalGS.globalGS->engine[0]);
	}
	// Notice that unlike MIRP, here we don't have a switch that would require the round-off flag MIAP[r] to honour
	// the cvt cut-in. We assume that the context is a stroke placement with coordinates calculated to move a stroke
	// possibly from the origin to the targeted location such as in PMingLiU. See also comments in MSIRP and MIRP.
	
	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxNewProj - fxOrigProj);
	return pbyInst;
} // itrp_MIAP


/*********************************************************************/

FS_PRIVATE uint8* itrp_IUP (IPARAM)
{
	fnt_ElementType *pCE2;
	
	int32 *alOrig;                          /* original outline array */
	int32 *plOrig;
	int32 *plOrigTouch2;                    /* for loop stop */
	int32 *plOrigEnd;
	int32 lOrig1;                           /* touched point 1 */
	int32 lOrig2;                           /* touched point 2 */
	int32 lOrigMin;                         /* min coord touched point */
	int32 lOrigDelta;
	int32 lOrigCorr;
	
	F26Dot6 *afxScaled;                     /* scaled outline array */
	F26Dot6 *pfxScaled;
	F26Dot6 fxScaledMax;
	F26Dot6 fxScaledMin;
	F26Dot6 fxScaledCoord;
	
	F26Dot6 fxMovedMax;                     /* hint movement of max */
	F26Dot6 fxMovedMin;                     /* hint movement of min */

	F26Dot6 *afxHinted;                     /* hinted outline array */
	F26Dot6 *pfxHinted;
	F26Dot6 fxHintedMax;
	F26Dot6 fxHintedMin;
	F26Dot6 fxHintedDelta;

	uint8 *abyFlags;                        /* point flags array */
	uint8 byMask;
	
	int32 iPt;                         /* current point index */
	int32 iStartPt;                    /* start of contour */
	int32 iEndPt;                      /* end of contour */
	int32 iStopPt;                     /* touched point indicates completion */
	int32 iTouch1;
	int32 iTouch2;
	int32 iMin;
	int32 iMax;
			   
	int32 iContour;

	int32 lTemp;
	Fixed fRatio;

	STAT_ON_IUP;                        /* start STAT timer */    

	pCE2 = LocalGS.CE2;

	SECURE_CHECK_FOR_UNITIALIZED_ZONE(pCE2);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		VerticalSPDirection(LocalGS.globalGS) != (lOpCode & 0x01) && !pCE2->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,pCE2);
	//	phaseControlExecuted == true by now
	}
#endif
	
	abyFlags = pCE2->f;

	if (lOpCode & 0x01)              /* use x coordinates */
	{
		afxHinted = pCE2->x;
		afxScaled = pCE2->ox;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->ox;
		}
		else
		{
			alOrig = pCE2->oox;
		}
		byMask = XMOVED;
	} 
	else                                    /* use y coordinates */
	{
		afxHinted = pCE2->y;
		afxScaled = pCE2->oy;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->oy;
		}
		else
		{
			alOrig = pCE2->ooy;
		}
		byMask = YMOVED;
	}

	for (iContour = 0; iContour < pCE2->nc; iContour++)
	{
		iStartPt = pCE2->sp[iContour];
		iEndPt = pCE2->ep[iContour];
		plOrigEnd = &alOrig[iEndPt];        /* for limit check */

		iPt = iStartPt;
		while (!(abyFlags[iPt] & byMask) && (iPt <= iEndPt))
		{
			iPt++;
		}
		if (iPt <= iEndPt)                  /* if any points are touched */
		{
			iStopPt = iPt;                  /* save for done condition */
			
			do                              /* for each contour segment */
			{
				do                          /* find next untouched point */
				{
					iTouch1 = iPt;
					iPt++;
					if (iPt > iEndPt)
					{
						iPt = iStartPt;
					}
				} while ((abyFlags[iPt] & byMask) && iPt != iStopPt);

				if (iPt != iStopPt)
				{
					iTouch2 = iPt;
					do                      /* find next touched point */
					{
						iTouch2++;
						if (iTouch2 > iEndPt)
						{
							iTouch2 = iStartPt;
						}
					} while (!(abyFlags[iTouch2] & byMask));

					lOrig1 = alOrig[iTouch1];
					lOrig2 = alOrig[iTouch2];
					if (lOrig1 < lOrig2)
					{
						lOrigMin = lOrig1;
						lOrigDelta = lOrig2 - lOrig1;
						iMin = iTouch1;
						iMax = iTouch2;
					}
					else
					{
						lOrigMin = lOrig2;
						lOrigDelta = lOrig1 - lOrig2;
						iMin = iTouch2;
						iMax = iTouch1;
					}
					
					fxHintedMin = afxHinted[iMin];
					fxScaledMin = afxScaled[iMin];
					fxMovedMin = fxHintedMin - fxScaledMin;

					if (lOrigDelta != 0L)
					{
						fxScaledMax = afxScaled[iMax];
						fxHintedMax = afxHinted[iMax];
						fxMovedMax = fxHintedMax - fxScaledMax;
						fxHintedDelta = fxHintedMax - fxHintedMin;

						if (lOrigDelta < 32768 && fxHintedDelta < 32768)
						{
							plOrig = &alOrig[iPt];          /* set up pointers */
							pfxScaled = &afxScaled[iPt];
							pfxHinted = &afxHinted[iPt];
							lOrigCorr = lOrigDelta >> 1;
							plOrigTouch2 = &alOrig[iTouch2];    /* set limits */
							
							while (plOrig < plOrigTouch2)   /* if not across start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
							}                               /* end of time critical loop */
															
							while (plOrig != plOrigTouch2)  /* if points span start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
								
								if (plOrig > plOrigEnd)
								{
									plOrig = &alOrig[iStartPt];
									pfxScaled = &afxScaled[iStartPt];
									pfxHinted = &afxHinted[iStartPt];
								}
							}
							iPt = iTouch2;              /* keep in step */
						}
						else                /* if too big for 32 bit product */
						{
							fRatio = FixDiv (fxHintedDelta, lOrigDelta);
							while (iPt != iTouch2)
							{
								lTemp = afxScaled[iPt];
								if (lTemp <= fxScaledMin)
								{
									lTemp += fxMovedMin;
								}
								else if (lTemp >= fxScaledMax)
								{
									lTemp += fxMovedMax;
								}
								else
								{
									lTemp = alOrig[iPt];
									lTemp -= lOrigMin;
									lTemp = FixMul (lTemp, fRatio);
									lTemp += fxHintedMin;
								}
								afxHinted[iPt] = (F26Dot6)lTemp;
								
								if (iPt < iEndPt)
									iPt++;
								else
									iPt = iStartPt;
							}
						}                   /* endif (lOrigDelta < 32768 && fxHintedDelta < 32768) */
					}
					else                    /* if (lOrigDelta == 0L) */
					{
						while (iPt != iTouch2)
						{
							afxHinted[iPt] += fxMovedMin;
							
							if (iPt < iEndPt)
								iPt++;
							else
								iPt = iStartPt;
						}
					}                       /* endif (lOrigDelta != 0L) */
				}                           /* endif (iPt != iStopPt) */
			} while (iPt != iStopPt);       /* until contour is closed */
		}                                   /* endif (iPt <= iEndPt) */
	 }
								  /* next contour */
	STAT_OFF_IUP;                           /* stop STAT timer */    

#ifdef FSCFG_SUBPIXEL
	LocalGS.globalGS->subPixelCompatibilityFlags |= (lOpCode & 0x01 ? SPCF_iupxCalled : SPCF_iupyCalled);
#endif

	return pbyInst;
} // itrp_IUP

/*********************************************************************/

boolean IsSideBearingPoint(fnt_ElementType *element, int32 point);
boolean IsSideBearingPoint(fnt_ElementType *element, int32 point) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point && point <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingPoint

boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1);
boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point0 && point0 <= numPoints + RIGHTSIDEBEARING || numPoints + LEFTSIDEBEARING <= point1 && point1 <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingLink


  FS_PRIVATE fnt_ElementType* itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode)
  {
	F26Dot6 proj;
	int32 pt;
	fnt_ElementType * element;

	if (BIT0 (lOpCode))
	{
	  pt = LocalGS.Pt1;
	  element = LocalGS.CE0;
	} 
	else 
	{
	  pt = LocalGS.Pt2;
	  element = LocalGS.CE1;
	}
	proj = (*LocalGS.Project) (GSA element->x[pt] - element->ox[pt], element->y[pt] - element->oy[pt]);

	*dx = *dy = 0; // silence prefix

	if (LocalGS.pfProj != ONEVECTOR)
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.x, (int32)LocalGS.pfProj);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.y, (int32)LocalGS.pfProj);
	}
	else
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	}
	*point = pt;
	return element;
  }

/*********************************************************************/

FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy)
{
	fnt_ElementType *CE2;
	int32 count;
	int32 point;
	
	CE2 = LocalGS.CE2;
	count = LocalGS.loop + 1;         /* faster for ms c8 */

	while (count != 0)
	{
		point = (int32)CHECK_POP (LocalGS.stackPointer);
		SECURE_CHECK_POINT (LocalGS.CE2, point);
		CHECK_POINT (&LocalGS, LocalGS.CE2, point);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			AddDistance(&LocalGS,CE2,refPoint,point,OTHER);
#endif

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// here we assume that if we're doing a SHPIX instruction, we're in the context of a function that implements delta instructions
		// for a range of ppem sizes. If such a delta occurs on an untouched point, regardless of whether it's in SP direction or not,
		// it creates a dent in the outline. While for b/w this is intended to flip one or more pixels, it distorts the stroke in SP.
		// If such a delta occurs on a touched point, it moves along the entire outline, such as to place strokes differently. If this
		// happens in SP direction, this distorts the natural spacing of the stroke(s). Therefore we keep only deltas on touched points
		// in non SP direction.
		//   Notice that strictly speaking, we should keep inline deltas (in non SP direction) only. However, since we do not have the
		// tree of instructions at this level, we don't know whether there are any dependant points that have been touched already,
		// prior to applying the delta (in which case it's a pre-IUP delta), or not (in which case it's an inline delta). In cases
		// where a pre-IUP delta was used to cleanup several pixels of the b/w bitmap, the SP result won't be optimal, but not nearly
		// as bad as it would be in grey-scaling. This is due to the oversampling, which in grey-scaling is done in both directions,
		// while only in one direction in SP. As a result, even the oversampled pixels (stripes) are typically "in".
		//   Notice also that we cannot use the fact whether IUP has happened already or not (even though this would be easy to track),
		// since some pre-IUP deltas are erroneously applied to untouched points, the result of which is unreliable in the sense that
		// the delta amount applies to the original (untouched) position of the point, which typically differs from its post-IUP
		// position. While this may lead to the desired result in b/w, in SP point positions likely will differ from those in b/w.
		// This has lead to irregularly spaced (and "angled") glyphs in fonts such as Palatino italic.
		//   Notice, finally, that for composites, the touched/untouched rule does not apply the same way. A point that is flagged as
		// untouched may have been previously touched while executing the code for the respective component. Yet a subsequent SHPIX or
		// possibly delta applied to that point will not create a(nother) dent in the outline, but move the entire outline, instead.
		// This is used in b/w e.g. to re-position diacritics to ensure a minimal distance of 1 pixel between the base character and
		// the diacritic. Hence we also keep deltas in composites.

		if (!shpix || !RunningSubPixel(LocalGS.globalGS) || Tuned4SubPixel(LocalGS.globalGS) || AMovedPointInNonSPDirection(LocalGS,CE2,point)
#ifdef DoDiagEndCtrlDeltas
			|| (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_inDiagEndCtrl) > 0
#endif
			) {
#endif // InlineDeltasOnly
#endif // FSCFG_SUBPIXEL
		if (LocalGS.free.x) {
			CE2->x[point] += dx;
			CE2->f[point] |= XMOVED;
		}
		if (LocalGS.free.y) {
			CE2->y[point] += dy;
			CE2->f[point] |= YMOVED;
		}
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		}
#endif
#endif
		count--;
	}
	LocalGS.loop = 0;
    return pbyInst;
}

/*********************************************************************/

/*
 * SHift Point
 */
  FS_PRIVATE uint8* itrp_SHP (IPARAM)
  {
	F26Dot6 dx, dy;
	int32 point;

#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	itrp_SH_Common (GSA &dx, &dy, &point, lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

    return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		point,
#endif
#ifdef FSCFG_SUBPIXEL
		false, // we don't come from SHPIX
#endif
		dx, dy);
  }

/*
 * SHift Contour
 */
  FS_PRIVATE uint8* itrp_SHC (IPARAM)
  {
	fnt_ElementType *element;
	F26Dot6 dx, dy;
	int32 contour, point;

	{
	  F26Dot6 x, y;
	  int32 pt;

#ifdef FSCFG_SECURE
	  if (BIT0 (lOpCode))
	  {
	    SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	  } 
	  else 
	  {
	    SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	  }
#endif 
	  
	  element = itrp_SH_Common (GSA &x, &y, &pt, lOpCode);
	  point = pt;
	  dx = x;
	  dy = y;
	}
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	contour = (int32)CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!VerticalSPDirection(LocalGS.globalGS) && !element->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,element);
	//	phaseControlExecuted == true by now
		dx += element->pcr[point].phaseShift;
	}
#endif
	


	SECURE_CHECK_FOR_UNITIALIZED_ZONE(LocalGS.CE2);
	SECURE_CHECK_CONTOUR (LocalGS.CE2, contour);
	CHECK_CONTOUR (&LocalGS, LocalGS.CE2, contour);

	{
	  VECTORTYPE fvx = LocalGS.free.x;
	  VECTORTYPE fvy = LocalGS.free.y;
	  fnt_ElementType*CE2 = LocalGS.CE2;
	  int32 currPt = CE2->sp[contour];
	  int32 count = CE2->ep[contour] - currPt;
	  SECURE_CHECK_POINT (CE2, currPt + count);
	  CHECK_POINT (&LocalGS, CE2, currPt + count);
	  for (; count >= 0; --count)
	  {
		if (currPt != point || element != CE2)
		{
		  if (fvx) 
		  {
			CE2->x[currPt] += dx;
			CE2->f[currPt] |= XMOVED;
		  }
		  if (fvy) 
		  {
			CE2->y[currPt] += dy;
			CE2->f[currPt] |= YMOVED;
		  }
		}
		currPt++;
	  }
	}
	
	return pbyInst;
  }

/*********************************************************************/

/*
 * SHift Element                     rewritten 7/29/93 deanb
 *
 * Flags are no longer set to show touch in x or y direction
 */

FS_PRIVATE uint8* itrp_SHE (IPARAM)
{
	fnt_ElementType *element;
	F26Dot6 fxDX, fxDY;
	int32 lFirstPt, lRefPt, lLastPt, arg1;
	
	F26Dot6 fxSaveX;                    /* for ref point restoration */
	F26Dot6 fxSaveY;
	
	F26Dot6 *pfxX, *pfxStopX;           /* temporary element pointers */
	F26Dot6 *pfxY, *pfxStopY;
	
#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	element = itrp_SH_Common (GSA &fxDX, &fxDY, &lRefPt, lOpCode);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg1);
	CHECK_ELEMENT (&LocalGS, arg1);
	SECURE_CHECK_FOR_UNITIALIZED_ZONE(&LocalGS.elements[arg1]);

	lLastPt = LocalGS.elements[arg1].ep[LocalGS.elements[arg1].nc - 1];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lLastPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lLastPt);
	lFirstPt  = LocalGS.elements[arg1].sp[0];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lFirstPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lFirstPt);

	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		fxSaveX = LocalGS.elements[arg1].x[lRefPt];
		fxSaveY = LocalGS.elements[arg1].y[lRefPt];
	}
	
	if (LocalGS.free.x != 0) 
	{
		pfxX = &LocalGS.elements[arg1].x[lFirstPt];
		pfxStopX = &LocalGS.elements[arg1].x[lLastPt];

		while (pfxX <= pfxStopX)
		{
			*pfxX += fxDX;                      /* shift each point in x */
			pfxX++;
		}
	}

	if (LocalGS.free.y != 0) 
	{
		pfxY = &LocalGS.elements[arg1].y[lFirstPt];
		pfxStopY = &LocalGS.elements[arg1].y[lLastPt];

		while (pfxY <= pfxStopY)
		{
			*pfxY += fxDY;                      /* shift each point in y */
			pfxY++;
		}
	}
	
	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		LocalGS.elements[arg1].x[lRefPt] = fxSaveX;
		LocalGS.elements[arg1].y[lRefPt] = fxSaveY;
	}

	return pbyInst;
}

/*********************************************************************/

/*
 * SHift point by PIXel amount
 */
  FS_PRIVATE uint8* itrp_SHPIX (IPARAM)
  {
	F26Dot6 proj, dx, dy;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 2);
	proj = CHECK_POP (LocalGS.stackPointer);
	if (LocalGS.free.x)
	  dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	else
		dx = 0; // silence BC
	if (LocalGS.free.y)
	  dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	else
		dy = 0; // silence BC

	return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		-1,
#endif
#ifdef FSCFG_SUBPIXEL
		true, // we do come from SHPIX
#endif
		dx, dy);
  }

/*********************************************************************/

/*
 * Interpolate Point
 */

uint8* itrp_IP (IPARAM)
{
	int32 arg1;
	int32 RP1;
	int32 RP2;
	
	int32 cLoop;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_ElementType *pCE2;
	fnt_ElementType *pTwilight;
	
	F26Dot6 x_RP1;
	F26Dot6 ox_RP1;
	F26Dot6 *pCE1_ox;
	F26Dot6 *pCE2_ox;

	F26Dot6 y_RP1;
	F26Dot6 oy_RP1;
	F26Dot6 *pCE1_oy;
	F26Dot6 *pCE2_oy;

	F26Dot6 oldRange;
	F26Dot6 proj;
	F26Dot6 fxDelta;
	
	F26Dot6 *pfxStack;

	FntMoveFunc MovePoint;
	FntProject Project;
	

	FS_UNUSED_PARAMETER(lOpCode);

	cLoop = LocalGS.loop + 1;               /* faster for ms c8 */
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	pCE2 = LocalGS.CE2;
	pTwilight = &LocalGS.elements[TWILIGHTZONE];
	RP1 = LocalGS.Pt1;
	RP2 = LocalGS.Pt2;

	SECURE_CHECK_POINT (pCE0, RP1);
	SECURE_CHECK_POINT (pCE1, RP2);

	pfxStack = LocalGS.stackPointer;

	MovePoint = LocalGS.MovePoint;
	Project = LocalGS.Project;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, cLoop);
    
	if (pCE0 == pTwilight || pCE1 == pTwilight || pCE2 == pTwilight 
		|| LocalGS.globalGS->bOriginalPointIsInvalid)
	{
		ox_RP1 = pCE0->ox[RP1];
		oy_RP1 = pCE0->oy[RP1];
		pCE1_ox = pCE1->ox;
		pCE1_oy = pCE1->oy;
		pCE2_ox = pCE2->ox;
		pCE2_oy = pCE2->oy;
	}
	else
	{
		ox_RP1 = pCE0->oox[RP1];
		oy_RP1 = pCE0->ooy[RP1];
		pCE1_ox = pCE1->oox;
		pCE1_oy = pCE1->ooy;
		pCE2_ox = pCE2->oox;
		pCE2_oy = pCE2->ooy;
	}
	x_RP1 = pCE0->x[RP1];
	y_RP1 = pCE0->y[RP1];
		
	oldRange = LocalGS.OldProject (GSA pCE1_ox[RP2] - ox_RP1, pCE1_oy[RP2] - oy_RP1);
	
	if (oldRange != 0)                      /* this should always happen */
	{
		if (MovePoint == itrp_XMovePoint)   /* so project is also xproject */
		{
			proj = pCE1->x[RP2] - x_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_ox[arg1] - ox_RP1;
				fxDelta = (F26Dot6)MulDiv26Dot6 (proj, fxDelta, oldRange);
				
				pCE2->x[arg1] = fxDelta + x_RP1;
				pCE2->f[arg1] |= XMOVED;
				cLoop--;
			}
		}
		else if (MovePoint == itrp_YMovePoint)  /* so project is also yproject */
		{
			proj = pCE1->y[RP2] - y_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_oy[arg1] - oy_RP1; 
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				
				pCE2->y[arg1] = fxDelta + y_RP1;
				pCE2->f[arg1] |= YMOVED;
				cLoop--;
			}
		}
		else    /* if (MovePoint == itrp_MovePoint) */
		{
			proj = Project (GSA pCE1->x[RP2] - x_RP1, pCE1->y[RP2] - y_RP1);
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				MovePoint (GSA pCE2, arg1, fxDelta - 
					Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
				cLoop--;
			}
		}
	}
	else    /* if (oldRange == 0) */  
			/* this should never happen, but for safety's sake... */
	{
		while (cLoop != 0)
		{
			arg1 = (int32)CHECK_POP (pfxStack);
			SECURE_CHECK_POINT (pCE2, arg1);
			CHECK_POINT (&LocalGS, pCE2, arg1);
						
			fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
			MovePoint (GSA pCE2, arg1, fxDelta - 
				Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
			cLoop--;
		}
	}       /* endif (oldRange != 0) */
	
	LocalGS.stackPointer = pfxStack;
	LocalGS.loop = 0;
	return pbyInst;
}

/*********************************************************************/

/*
 * Move Stack Indirect Relative Point
 */

uint8* itrp_MSIRP (IPARAM) {
	int32 iPt0;
	int32 iPt2;                            // point #
	F26Dot6 fxDist;                        // distance
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	F26Dot6 fxOutlineDist;
	fnt_ParameterBlock *pb;
#endif
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	F26Dot6 fxPosition;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;

	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iPt0 = LocalGS.Pt0;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    fxDist = CHECK_POP (LocalGS.stackPointer);
	iPt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt2);
	CHECK_POINT (&LocalGS, pCE1, iPt2);
		
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPt2,BLACK); // don't really know any better
		AddDistance(&LocalGS,pCE1,iPt0,iPt2,color);
	}
#endif

	if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE1->ox[iPt2] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.x);
		pCE1->oy[iPt2] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.y);
		pCE1->x[iPt2] = pCE1->ox[iPt2];
		pCE1->y[iPt2] = pCE1->oy[iPt2];
	}
	
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	if (!Tuned4SubPixel(LocalGS.globalGS) && LocalGS.inSubPixelDirection) {
	// similarly to MIRP, here we honour a cvt cut-in in case there is a non-trivial outline distance between the
	// parent (reference) and the child (target) point involved, in which case we assume the context is a stroke weight,
	// else we assume the context is an accent placement function, in which case we use the actual distance as before
		fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt2] - pCE0->ox[iPt0], pCE1->oy[iPt2] - pCE0->oy[iPt0]);
		if (fxOutlineDist) { // else assume we're positioning accents with a calculated MSIRP, hence no cvt cut-in
			pb = &LocalGS.globalGS->localParBlock;
			// notice that unlike MIRP, we don't do the autoFlip since MSIRP is used with calculated distances that
			// would have the correct sign to begin with.
			CVTCI(pb,fxDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
		}
	}
#endif
#endif

	fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPt2] - pCE0->x[iPt0], pCE1->y[iPt2] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt2, fxDist - fxPosition);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt2;
	if (BIT0 (lOpCode)) {
		LocalGS.Pt0 = iPt2; // move the reference point
	}
	return pbyInst;
} // itrp_MSIRP

/*********************************************************************/

/*
 * Align Relative Point
 */

FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM)
  {
	fnt_ElementType*ce1 = LocalGS.CE1;
	F26Dot6 pt0x = LocalGS.CE0->x[LocalGS.Pt0];
	F26Dot6 pt0y = LocalGS.CE0->y[LocalGS.Pt0];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

	for (; LocalGS.loop >= 0; --LocalGS.loop)
	{
	  int32 ptNum = (int32)CHECK_POP (LocalGS.stackPointer);
	  F26Dot6 proj;

	  SECURE_CHECK_POINT (ce1, ptNum);
	  CHECK_POINT (&LocalGS, ce1, ptNum);
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (ce1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			// if we are aligning to some diagonal (pt0 and pt1 are set after SPVTL etc.), and if the child is between the parents
			// (InterAlign, cf. also omments there), we handle it as a proportion, else as a distance with non specific color.
			if (ce1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,ptNum,LocalGS.pt1))
				AddProportion(&LocalGS,ce1,LocalGS.pt0,ptNum,LocalGS.pt1);
			else
				AddDistance(&LocalGS,ce1,LocalGS.Pt0,ptNum,OTHER);
#endif
	  proj = -(* LocalGS.Project) (GSA ce1->x[ptNum] - pt0x, ce1->y[ptNum] - pt0y);
	  (*LocalGS.MovePoint) (GSA ce1, ptNum, proj);
	}
	LocalGS.loop = 0;
	return pbyInst;
  }


/*
 * Align Two Points (by moving both of them)
 */
  FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 move1, dist;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 2   */
	pt1  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 1   */
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
/* We do not have to check if we are in character element zero (the twilight zone)
		   since both points already have to have defined values before we execute this instruction */
	dist = LocalGS.CE1->x[pt2] - LocalGS.CE0->x[pt1];
	move1 = LocalGS.CE1->y[pt2] - LocalGS.CE0->y[pt1];
	if (LocalGS.Project != itrp_XProject)
	{
	  if (LocalGS.Project == itrp_YProject)
		dist = move1;
	  else
		dist = (*LocalGS.Project) (GSA dist, move1);
	}

	move1 = dist >> 1;
	(*LocalGS.MovePoint) (GSA LocalGS.CE0, pt1, move1);
	(*LocalGS.MovePoint) (GSA LocalGS.CE1, pt2, move1 - dist);
	return pbyInst;
  }

/*
 * Set Angle Weight
 */
  FS_PRIVATE uint8* itrp_SANGW (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.angleWeight = (int16)arg;
	return pbyInst;
  }

/*
 * Flip Point
 */
  FS_PRIVATE uint8* itrp_FLIPPT (IPARAM)
  {
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;
	int32 count = LocalGS.loop;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, count + 1);

    for (; count >= 0; --count)
	{
	  int32 point = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, point);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	  onCurve[ point ] ^= ONCURVE;
	}
	LocalGS.loop = 0;

	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip On a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ |= ONCURVE;
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip Off a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ &= ~ONCURVE;
	return pbyInst;
  }

/* 4/22/90 rwb - made more general
 * Sets lower 16 flag bits of ScanControl variable.  Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 *
 * stack: value => -;
 *
 */
  FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->scanControl = (pb->scanControl & 0xFFFF0000) | arg;
	return pbyInst;
  }

/* 5/24/90 rwb
 * Sets upper 16 bits of ScanControl variable. Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 */

  FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	int32 *scanPtr;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;
	scanPtr = (int32*)&(pb->scanControl);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);

/*  how it was:
	CHECK_SCANMODE (arg);
	if (arg == 0)  
	  *scanPtr &= 0xFFFF;
	else if (arg == 1)        
	  *scanPtr = (*scanPtr & 0xFFFF) | STUBCONTROL;
	else if (arg == 2)        
	  *scanPtr = (*scanPtr & 0xFFFF) | NODOCONTROL;
*/

/*  now any 8 bit value may be passed to the scan converter */
	
	*scanPtr = (*scanPtr & 0xFFFF) | (arg << 16);
	return pbyInst;
  }

/* 6/28/90 rwb
 * Sets instructControl flags in global graphic state.  Only legal in pre program.
 * A selector is used to choose the flag to be set.
 * Bit0 - NOGRIDFITFLAG - if set, then truetype instructions are not executed.
 *              A font may want to use the preprogram to check if the glyph is rotated or
 *              transformed in such a way that it is better to not gridfit the glyphs.
 * Bit1 - DEFAULTFLAG - if set, then changes in localParameterBlock variables in the
 *              globalGraphics state made in the CVT preprogram are not copied back into
 *              the defaultParameterBlock.  So, the original default values are the starting
 *              values for each glyph.
 * Bit2 - TUNED4SPFLAG - if set, a font will be rendered in native SP mode (as opposed to
 *              backwards compatible mode)
 *
 * stack: value, selector => -;
 *
 */
  FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM)  /* <13> */
  {
	fnt_GlobalGraphicStateType *globalGS;
	int32 *ic;
	int32 selector;
	int32 value;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;
	ic = (int32*)&globalGS->localParBlock.instructControl;
	arg = CHECK_POP (LocalGS.stackPointer);
	value = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (globalGS->init)
	{
	  if (selector == 1) 
		*ic &= ~NOGRIDFITFLAG;
	  else if (selector == 2) 
		*ic &= ~DEFAULTFLAG;
	  else if (selector == 3)
		*ic &= ~TUNED4SPFLAG;

	  *ic |= value;
	}
	return pbyInst;
  }

/*
 * AdjustAngle         <4>
 */
  FS_PRIVATE uint8* itrp_AA (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

	/* This is a NOP now. However, do pop the argument off the stack -amitc- 9/11/91. */
	/* Discard the popped value. -lenox- 11/11/91 */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	(void) CHECK_POP (LocalGS.stackPointer);
						 /* old code now lives in history.fnt - deanb */
	return pbyInst;
  }

/*********************************************************************/

/* Called by itrp_PUSHB and itrp_NPUSHB */

/* these functions were split out from itrp_PushSomeStuff - deanb */
  
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		CHECK_PUSH (stack, *pbyInst++);
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
	int16 word;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		word = *pbyInst++;
		CHECK_PUSH (stack, (int16) ((word << 8) + *pbyInst++));
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

/*********************************************************************/

/*
 * PUSH 1 Byte           the most commonly called pushb
 */
FS_PRIVATE uint8* itrp_PUSHB1 (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, *pbyInst++);
	return pbyInst;
}

/*
 * PUSH Bytes
 */
FS_PRIVATE uint8* itrp_PUSHB (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb0 + 1;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * N PUSH Bytes
 */
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * PUSH 1 Word           the most commonly called pushw
 */
FS_PRIVATE uint8* itrp_PUSHW1 (IPARAM)
{
	int16 word;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	word = *pbyInst++;
	CHECK_PUSH (LocalGS.stackPointer, (int16)((word << 8) + *pbyInst++));
	return pbyInst;
}

/*
 * PUSH Words           <3>
 */
FS_PRIVATE uint8* itrp_PUSHW (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb8 + 1;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*
 * N PUSH Words
 */
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*********************************************************************/

/*
 * Write Store
 */
  FS_PRIVATE uint8* itrp_WS (IPARAM)
  {
	F26Dot6 storage;
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	storage = CHECK_POP (LocalGS.stackPointer);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS,storeIndex);

	LocalGS.globalGS->store[ storeIndex ] = storage;
	return pbyInst;
  }

/*
 * Read Store
 */
  FS_PRIVATE uint8* itrp_RS (IPARAM) {
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS, storeIndex);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	if (storeIndex == 8 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedVacuformRound) > 0) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inVacuformRound;
		CHECK_PUSH (LocalGS.stackPointer, 0); // push 0 indicating we don't do vacuforming
	} else {
#endif
#endif
		CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->store[storeIndex]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	}
#endif
#endif
	return pbyInst;
  }

/*
 * Write Control Value Table from outLine, assumes the value comes form the outline domain
 */
  FS_PRIVATE uint8* itrp_WCVT (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);

	if (cvtValue != 0 && LocalGS.GetCVTEntry != itrp_GetCVTEntryFast)
	  cvtValue = FixDiv (cvtValue, itrp_GetCVTScale (GSA0));
	LocalGS.globalGS->controlValueTable[ cvtIndex ] = cvtValue;
	return pbyInst;
  }

/*
 * Write Control Value Table From Original Domain, assumes the value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);
	globalGS->controlValueTable[ cvtIndex ] = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, cvtValue);
	return pbyInst;
  }



/*
 * Read Control Value Table
 */
  FS_PRIVATE uint8* itrp_RCVT (IPARAM)
  {
	int32 cvtIndex;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

#ifndef FSCFG_FONTOGRAPHER_BUG
	SECURE_CHECK_CVT (cvtIndex);
#else
	SECURE_CHECK_CVT_READ_SPECIAL (cvtIndex);
#endif // FSCFG_FONTOGRAPHER_BUG

	CHECK_CVT (&LocalGS, cvtIndex);

	LocalGS.GetCVTEntry (GSA cvtIndex);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.GetCVTEntry (GSA cvtIndex));
	return pbyInst;
  }

/*
 * Read Coordinate
 */
  FS_PRIVATE uint8* itrp_RC (IPARAM)
  {
	int32 pt;
	fnt_ElementType * element;
	F26Dot6 proj;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pt = (int32)CHECK_POP (LocalGS.stackPointer);
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	if (BIT0 (lOpCode))
	  proj = (*LocalGS.OldProject) (GSA element->ox[pt], element->oy[pt]);
	else
	  proj = (*LocalGS.Project) (GSA element->x[pt], element->y[pt]);

	CHECK_PUSH (LocalGS.stackPointer, proj);
	return pbyInst;
  }

/*
 * Write Coordinate
 */
  FS_PRIVATE uint8* itrp_WC (IPARAM)
  {
	F26Dot6 proj, coord;
	int32 pt;
	fnt_ElementType *element;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	coord = CHECK_POP (LocalGS.stackPointer);/* value */
	pt = (int32)CHECK_POP (LocalGS.stackPointer);/* point */
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	proj = (*LocalGS.Project) (GSA element->x[pt],  element->y[pt]);
	proj = coord - proj;

	(*LocalGS.MovePoint) (GSA element, pt, proj);

	if (element == &LocalGS.elements[TWILIGHTZONE])
	{
	  element->ox[pt] = element->x[pt];
	  element->oy[pt] = element->y[pt];
	}
	return pbyInst;
  }


/*
 * Measure Distance
 */
  FS_PRIVATE uint8* itrp_MD (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 proj, *stack = LocalGS.stackPointer;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2 = (int32)CHECK_POP (stack);
	pt1 = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	if (BIT0 (lOpCode - MD_CODE)) { // MD[O] in original outline
		if (LocalGS.CE0 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.CE1 == &LocalGS.elements[TWILIGHTZONE] 
			|| LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->ox[pt1] - LocalGS.CE0->ox[pt2], LocalGS.CE1->oy[pt1] - LocalGS.CE0->oy[pt2]);
		}
		else if (globalGS->bSameStretch)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2], LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2] );
			proj = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, proj );
		}
		else
		{
			proj = (*LocalGS.OldProject) (GSA 
				globalGS->ScaleFuncX (&globalGS->scaleX, LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2]), 
				globalGS->ScaleFuncY (&globalGS->scaleY, LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2]) );
		}
	}

	/* old MS code, give different value than Apple :
	 * proj  = (*LocalGS.OldProject) (GSA LocalGS.CE0->ox[pt1] - LocalGS.CE1->ox[pt2], LocalGS.CE0->oy[pt1] - LocalGS.CE1->oy[pt2]);
	*/
	
	else { // MD[N] in grid-fitted outline
		proj  = (*LocalGS.Project) (GSA LocalGS.CE0->x[pt1] - LocalGS.CE1->x[pt2], LocalGS.CE0->y[pt1] - LocalGS.CE1->y[pt2]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
		if ((LocalGS.globalGS->subPixelCompatibilityFlags & (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound)) == (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound) && proj == FNT_PIXELSIZE)
			proj++; // increase by smallest possible amount to throw off type 2 vacuforms which are keyed off a distance being exacly 1 pixel
#endif
#endif
	}
	CHECK_PUSH (stack, proj);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Measure Pixels Per EM
 */
  FS_PRIVATE uint8* itrp_MPPEM (IPARAM)
  {
	uint16 ppem;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

	ppem = globalGS->pixelsPerEm;
	if (!globalGS->bSameStretch)
		ppem = (uint16)FixMul (ppem, itrp_GetCVTScale (GSA0));

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, ppem);
	return pbyInst;
  }

/*
 * Measure Point Size
 */
  FS_PRIVATE uint8* itrp_MPS (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->pointSize);
	return pbyInst;
  }

/*
 * Get Miscellaneous info: version number, rotated, stretched   <6>
 * Version number is 8 bits.  This is version 0x01 : 5/1/90
 *
 */

  FS_PRIVATE uint8* itrp_GETINFO (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	int32      info = 0;
	int32      selector;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (selector & VERSIONINTERPRETERQUERY)                            /* version */
	  info |= RASTERIZER_VERSION;
	if ((selector & ROTATEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
	  info |= ROTATEDGLYPH;
	if ((selector & STRETCHEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_STRETCH))
	  info |= STRETCHEDGLYPH;
	if ((selector & HINTFORGRAYINTERPRETERQUERY) && (globalGS->bHintForGray))
	  info |= HINTEDFORGRAYGLYPH;
#ifdef FSCFG_SUBPIXEL
	if ((selector & HINTFORSUBPIXELINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_SUB_PIXEL))
	  info |= HINTEDFORSUBPIXELGLYPH;
	if ((selector & HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
	  info |= HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH;
	if ((selector & HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
	  info |= HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH;
	if ((selector & HINTFORSUBPIXELBGRORDERINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_BGR_ORDER))
	  info |= HINTEDFORSUBPIXELBGRORDERGLYPH;
#endif // FSCFG_SUBPIXEL
	CHECK_PUSH (LocalGS.stackPointer, info);
	return pbyInst;
  } // itrp_GETINFO

/*
 * FLIP ON
 */
  FS_PRIVATE uint8* itrp_FLIPON (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = true;
	return pbyInst;
  }

/*
 * FLIP OFF
 */
  FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = false;
	return pbyInst;
  }

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
/*
 * DEBUG
 */
  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	int32 arg;
	int8 buffer[24];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);

	buffer[1] = 'D';
	buffer[2] = 'E';
	buffer[3] = 'B';
	buffer[4] = 'U';
	buffer[5] = 'G';
	buffer[6] = ' ';
	if (arg >= 0) 
	{
	  buffer[7] = '+';
	} 
	else 
	{
	  arg = -arg;
	  buffer[7] = '-';
	}

	buffer[13] = arg % 10 + '0'; 
	arg /= 10;
	buffer[12] = arg % 10 + '0'; 
	arg /= 10;
	buffer[11] = arg % 10 + '0'; 
	arg /= 10;
	buffer[10] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 9] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 8] = arg % 10 + '0'; 
	arg /= 10;

	buffer[14] = arg ? '*' : ' ';


	buffer[0] = 14; /* convert to pascal */
	DEBUGSTR (buffer);
	return pbyInst;
  }

#else           /* debug */

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* debug */
#else

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* ! not on the mac */


/* these functions were split out from itrp_BinaryOperand - deanb */

  FS_PRIVATE uint8* itrp_LT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] < pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_LTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] <= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] > pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] >= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] == pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] != pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_AND (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] && pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_OR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] || pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_ADD (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] += pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SUB (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] -= pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MUL (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] =  Mul26Dot6(pfxStack[-1], pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_DIV (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[0] == 0)
	{
		LocalGS.ercReturn = DIV_BY_0_IN_HINTING_ERR;  /* returned to client, error DIV by zero */
		return LocalGS.pbyEndInst;
	} 
	pfxStack[-1] = (int32)(((long)pfxStack[-1] << 6) / pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MAX (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] < pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_MIN (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] > pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

/**************************************************************************/

/* these functions were split out from itrp_UnaryOperand - deanb */

// for the ODD/EVEN pair, b/w, and no engine compensation case, we could
// essentially look at the two bits before and after the binary point of
// the F26Dot6 number:
//		1.100000 rounds to 2 (even)
//		1.000000 rounds to 1 (odd)
//		0.100000 rounds to 1 (odd)
//		0.000000 rounds to 0 (even)
// If the two bits are equal, then the number is even, else odd
// for engine compensation, we currently call the full itrp_RoundToGrid
// we'll allow tagged SP fonts to inquire about even/odd virtual pixels

  FS_PRIVATE uint8* itrp_ODD (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EVEN (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	fxArg++;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NOT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = !*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_ABS (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	if (*pfxStack < 0L)
	{
		*pfxStack = -*pfxStack;
	}
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_NEG (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = -*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_CEILING (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack += FNT_PIXELSIZE - 1;		// actually, this is not the pixel size, but the number 1 in 26.6
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// same here
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_FLOOR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// actually, this is not the pixel size, but the number 1 in 26.6
	return pbyInst;
  }
	  

/**************************************************************************/

/* This is called by itrp_IF, itrp_ELSE, itrp_FDEF, and itrp_IDEF         */
/* It is used to find the next TrueType instruction in the instruction    */
/* stream by skipping over push data.  It is table driven for speed.      */

static const uint8 gbyPushTable[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   21,22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 2, 3, 4, 5, 6, 7, 8, 2, 4, 6, 8,10,12,14,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8* pbyInst)
{
	int32 iDataCount;         /* count of data following push instruction */
	
	iDataCount = (int32)gbyPushTable[ pbyInst[-1] ];   /* opcode */
	
	if (iDataCount != 0)                        /* if a push instruction */
	{
		if (iDataCount == 21)                   /* special for npushb */
		{
			iDataCount = (int32)*pbyInst + 1;
		}
		else if (iDataCount == 22)              /* special for npushw */
		{
			iDataCount = ((int32)*pbyInst << 1) + 1;
		}
		pbyInst += iDataCount;

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * IF
 */
FS_PRIVATE uint8* itrp_IF (IPARAM)
{
	int32 iLevel;
	int32 iScanOpCode;
	int32 iDataCount;         /* count of data following push instruction */

	FS_UNUSED_PARAMETER(lOpCode);	
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	if (!CHECK_POP (LocalGS.stackPointer))
	{
		iLevel = 1;
		while ((iLevel != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
		{
			iScanOpCode = (int32)*pbyInst++;

			if (iScanOpCode == EIF_CODE)
			{
				ERR_IF (-1);
				iLevel--;
			} 
			else if (iScanOpCode == IF_CODE) 
			{
				ERR_IF (1);
				iLevel++;
			} 
			else if (iScanOpCode == ELSE_CODE) 
			{
				if (iLevel == 1) 
					break;
			} 
			else
			{
				iDataCount = (int32)gbyPushTable[iScanOpCode];
				
				if (iDataCount != 0)            /* if a push instruction */
				{
					if (iDataCount == 21)       /* special for npushb */
					{
						iDataCount = (int32)*pbyInst + 1;
					}
					else if (iDataCount == 22)  /* special for npushw */
					{
						iDataCount = ((int32)*pbyInst << 1) + 1;
					}
					pbyInst += iDataCount;
				}
			}
		}

		if ((pbyInst == LocalGS.pbyEndInst) && (iLevel != 0))
		{
			LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      ELSE for the IF
 */
FS_PRIVATE uint8* itrp_ELSE (IPARAM)
{
	int16 level;
	uint8 opCode;

	FS_UNUSED_PARAMETER(lOpCode);

	level = 1;
	while ((level != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
	{
		opCode = *pbyInst++;
		
		if (opCode == EIF_CODE)
		{
			ERR_IF (-1);
			level--;
		} 
		else if (opCode == IF_CODE) 
		{
			ERR_IF (1);
			level++;
		} 
		else
		{
			pbyInst = itrp_SkipPushData (GSA pbyInst);
		}
	}

	if (level != 0)
	{
		LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * End IF
 */
FS_PRIVATE uint8* itrp_EIF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);

	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative
 */
FS_PRIVATE uint8* itrp_JMPR (IPARAM)
{
	int32 offset;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);
	offset--;       /* since the interpreter post-increments the IP */
	pbyInst += offset;
	LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */

	if (LocalGS.ulJumpCounter == 0)
	{
		LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
    if (pbyInst < LocalGS.pbyStartInst)
	{
		LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
    }
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On True
 */
FS_PRIVATE uint8* itrp_JROT (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
		{
			LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On False
 */
FS_PRIVATE uint8* itrp_JROF (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (!bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
	    {
		    LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		    return LocalGS.pbyEndInst;
        }
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * ROUND
 */
  FS_PRIVATE uint8* itrp_ROUND (IPARAM)
  {
	F26Dot6 arg1;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x68, 0x6B);

	arg1 = pb->RoundValue (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x68]);
	
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/*
 * No ROUND
 */
  FS_PRIVATE uint8* itrp_NROUND (IPARAM)
  {
	F26Dot6 arg1;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x6C, 0x6F);

	arg1 = itrp_RoundOff (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x6c]);
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/**************************************************************************/

/*
 * An internal function used by MIRP an MDRP.
 */
  F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 fxValue) { // Single Width cut-in? B.St. to check
	F26Dot6 fxDelta;
	F26Dot6 fxScaledSW;
	fnt_ParameterBlock *pb;

	pb = &LocalGS.globalGS->localParBlock;
	fxScaledSW = LocalGS.GetSingleWidth (GSA0);

	if (fxValue >= 0) 
	{
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
	} 
	else 
	{
		fxValue = -fxValue;
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
		fxValue = -fxValue;
	}
	return fxValue;
}

/**************************************************************************/

/*
 * Move Direct Relative Point
 */
FS_PRIVATE uint8* itrp_MDRP (IPARAM)
{
	int32 iPt0;
	int32 iPt1;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	F26Dot6 fxMoveDist;
	F26Dot6 fxUnRounded;
	F26Dot6 fxMin;
	
	iPt0 = LocalGS.Pt0;
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPt1 = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt1);
	CHECK_POINT (&LocalGS, pCE0, iPt0);
	CHECK_POINT (&LocalGS, pCE1, iPt1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS))
		if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,iPt1,LocalGS.pt1))
			AddProportion(&LocalGS,pCE1,LocalGS.pt0,iPt1,LocalGS.pt1);
		else 
			AddDistance(&LocalGS,pCE1,iPt0,iPt1,OTHER); // strokes are hardly MDRPed, more likely to get black MDRPs that should be grey
#endif

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE] || pCE1 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.globalGS->bOriginalPointIsInvalid) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt1] - pCE0->ox[iPt0], pCE1->oy[iPt1] - pCE0->oy[iPt0]);
	} else if (globalGS->bSameStretch) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->oox[iPt1] - pCE0->oox[iPt0], pCE1->ooy[iPt1] - pCE0->ooy[iPt0]);
		fxMoveDist = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, fxMoveDist );
	} else {
		fxMoveDist = (*LocalGS.OldProject) (GSA 
			globalGS->ScaleFuncX (&globalGS->scaleX, pCE1->oox[iPt1] - pCE0->oox[iPt0]), 
			globalGS->ScaleFuncY (&globalGS->scaleY, pCE1->ooy[iPt1] - pCE0->ooy[iPt0]) );
	}

	if (pb->sWCI) { // Single Width cut-in? B.St. to check
		fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
	}

	fxUnRounded = fxMoveDist;

	if (BIT2 (lOpCode)) { // Round?
		fxMoveDist = pb->RoundValue (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	} else {
		fxMoveDist = itrp_RoundOff (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	}
	
	if (BIT3 (lOpCode)) { // Minimum distance?
		fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
		if (fxUnRounded >= 0) {
			if (fxMoveDist < fxMin)
				fxMoveDist = fxMin;
		} else {
			fxMin = -fxMin;
			if (fxMoveDist > fxMin)
				fxMoveDist = fxMin;
		}
	}

	fxMoveDist -= (*LocalGS.Project) (GSA pCE1->x[iPt1] - pCE0->x[iPt0], pCE1->y[iPt1] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt1, fxMoveDist);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt1;
	if (BIT4 (lOpCode))
	{
		LocalGS.Pt0 = iPt1;          /* move the reference point */
	}
	return pbyInst;
} // itrp_MDRP


/**************************************************************************/

/*
 * Move Indirect Relative Point     General
 */

/*    
 *  This routine branches to either the general MIRPG, or to the fast MIRPX 
 *  or MIRPY.  The MIRPCode is set to MIRPX at the beginning of each glyph, 
 *  and may be changed to MIRPY or to MIRPX by the SVTCA instructions.  
 *  Any other change in relevant state will cause the function vector to fall 
 *  back to MIRPG.
 *
 *  Conditions for fast MIRPX and MIRPY:
 *      fast cvt (identity transform)
 *      no single width cut in
 *      no twilight zone
 *      round to grid
 *      no engine compensation
 *      LocalGS.MovePoint = itrp_X[or Y]MovePoint;  
 */

FS_PRIVATE uint8* itrp_MIRP (IPARAM)
{
	int32 iPoint;
	int32 iPt0;
	int32 iCVTIndex;
	F26Dot6 fxMoveDist;
	F26Dot6 fxMin;
	F26Dot6 fxOutlineDist;
	F26Dot6 fxPosition;
	F26Dot6 fxEngine;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	
	fnt_ParameterBlock *pb;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;                /* common setup */
	pb = &globalGS->localParBlock;      
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE1, iPoint);
	CHECK_POINT (&LocalGS, LocalGS.CE1, iPoint);
	
	iPt0 = LocalGS.Pt0;
	SECURE_CHECK_POINT (LocalGS.CE0, iPt0);
	CHECK_POINT (&LocalGS, LocalGS.CE0, iPt0);
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPoint;
	
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPoint,lOpCode & 0x03);
		AddDistance(&LocalGS,pCE1,iPt0,iPoint,color);
	}
#endif

	if (LocalGS.MIRPCode == MIRPG)              /********* MIRPG *********/
	{
		fxMoveDist = LocalGS.GetCVTEntry (GSA iCVTIndex);

		if (pb->sWCI) { // Single Width cut-in? B.St. to check
			fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
		}

		if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
			pCE1->ox[iPoint] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.x);
			pCE1->x[iPoint] = pCE1->ox[iPoint];
			pCE1->oy[iPoint] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.y);
			pCE1->y[iPoint] = pCE1->oy[iPoint];
		}

		if (LocalGS.OldProject == itrp_XProject) {
			fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];
		} else if (LocalGS.OldProject == itrp_YProject) {
			fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];
		} else {
			fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPoint] - pCE0->ox[iPt0], pCE1->oy[iPoint] - pCE0->oy[iPt0]);
		}

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

		fxEngine = globalGS->engine[lOpCode & 0x03];

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// here we may honour a cvt cut-in even though the round-off flag would require not to do so. We assume that the
			// context is a stroke weight that has been tweaked for use with grey-scaling, and the only way to force MIRP
			// to use a particular distance is to round the cvt "by hand" and then turn off the rounding flag, which is
			// quite what we don't want to do in SubPixel, ie. to enforce an unnatural weight.
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif // RoundOffRespectsCvtCutIn
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else { // !Round
				fxMoveDist = itrp_RoundOffSP (GSA fxMoveDist, fxEngine);
			}
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL
			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else {
				fxMoveDist = itrp_RoundOff (GSA fxMoveDist, fxEngine);
			}
#ifdef FSCFG_SUBPIXEL
		}
#endif
		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}
		if (LocalGS.Project == itrp_XProject) {
			fxPosition = pCE1->x[iPoint] - pCE0->x[iPt0];
		} else if (LocalGS.Project == itrp_YProject) {
			fxPosition = pCE1->y[iPoint] - pCE0->y[iPt0];
		} else {
			fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPoint] - pCE0->x[iPt0], pCE1->y[iPoint] - pCE0->y[iPt0]);
		}

		(*LocalGS.MovePoint) (GSA pCE1, iPoint, fxMoveDist - fxPosition);
	
	} else if (LocalGS.MIRPCode == MIRPX) {        /********* MIRPX *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];  /* x direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->x[iPoint] = fxMoveDist + pCE0->x[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= XMOVED;
	
	} else { /* if (LocalGS.MIRPCode == MIRPY) */  /********* MIRPY *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];  /* y direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->y[iPoint] = fxMoveDist + pCE0->y[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= YMOVED;
	}
	
	if (BIT4 (lOpCode)) {
		LocalGS.Pt0 = iPoint;                   /* move the reference point */
	}
	return pbyInst;
} // itrp_MIRP

/**************************************************************************/

/*
 * CALL a function
 */
FS_PRIVATE uint8* itrp_CALL (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 *pbySubroutine;
	fnt_GlobalGraphicStateType *globalGS;
	int32 arg;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	uint8 patchedStore22 = false;
	F26Dot6 store22;
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef BypassJellesSpacing
	uint8 patchedStore24 = false;
	F26Dot6 store24;
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef DoDiagEndCtrlDeltas
	uint8 usingDiagEndCtrl = false;
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef DoDiagEndCtrlDeltas
	uint8 bypassTomsDiagonal = false;
	F26Dot6 cvtCI = 0;
#endif
#endif

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);

	CHECK_PROGRAM (funcDef->pgmIndex);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);
	funcDef = &globalGS->funcDef[ arg ];

 	SECURE_CHECK_PROGRAM (funcDef->pgmIndex);

	pbySubroutine = globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (pbySubroutine != 0);

	pbySubroutine += funcDef->start;
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;        /* save for parent */

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	// here we're assuming that fns 64 through 66 are support functions for the TMT D/IStroke commands, which may make strokes collapse in SubPixel.
	// To determine whether we've actually run into the context of these fns, we look at the first couple of bytes only, as the exact implementation
	// of these functions may have changed over time, but hopefully, the preamble (to look at storage #22) hasn't. The easiest way to by-pass these
	// fns is to flag storage #22 with 0, indicating not to use D/IStrokes, else we'd have to cleanup the stack.
	// Admittedly a bit of a hack. If anybody can think of a "better bandaid", I'll be happy to consider it.
	//    The reason, by the way, why DStroke doesn't work, is the following. DStroke brings pairs of points to the same y (or x), MIRP[m<rBl] the
	// floating point, and the moves it back to the old y (or x). Now that we re-interpret little r, cvt cut in actually gets to cut in, the original
	// distance gets to apply, just that the original distance is taken prior to bringing points to same y (or x), meaning it's likely to be WAY off.
	// As a result, the diagonal stroke weight (in x) starts to depend heavily on the distance (in y) of the control points involved, which obviously
	// is not what we want. Notice that for non-square aspect ratios, the DStroke is a NOP, therefore was a NOP with 16x SubPixel, and hence we're
	// not doing any major harm by skipping it in SubPixel.
	if (64 <= arg && arg <= 66 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedDandIStroke) > 0) {
		store22 = LocalGS.globalGS->store[22];
		LocalGS.globalGS->store[22] = 0;
		patchedStore22 = true;
	}
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef BypassJellesSpacing
	// here we're assuming that fns 0, 1, and 4 are support functions for Monotype's Jelle Bosma's spacing functions, which are not meant to work
	// with non-square aspect ratios, the latter being what we still sort of have in SubPixel. The fact that we do or do not have square aspect
	// ratio, in the context of Jelle's preps, is indicated in storage #24. From there, it's quite the same as with bypassing D/IStroke.
	if ((0 <= arg && arg <= 1 || arg == 4) && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedJellesSpacing) > 0) {
		store24 = LocalGS.globalGS->store[24];
		LocalGS.globalGS->store[24] = 0;
		patchedStore24 = true;
	}
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef DoDiagEndCtrlDeltas
	if (arg == 32 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedDiagEndCtrl) > 0) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inDiagEndCtrl;
		usingDiagEndCtrl = true;
	}
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef BypassTomsDiagonal
	if (arg == 58 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedTomsDiagonal) > 0) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inTomsDiagonal;
		cvtCI = LocalGS.globalGS->localParBlock.wTCI;
		LocalGS.globalGS->localParBlock.wTCI = 0x7fffffff;
		bypassTomsDiagonal = true;
	}
#endif
#endif

	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
	LocalGS.Interpreter (GSA pbySubroutine, pbySubroutine + funcDef->length);   /* recursion */
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	

#ifdef FSCFG_SUBPIXEL
#ifdef BypassTomsDiagonal
	if (bypassTomsDiagonal) {
		LocalGS.globalGS->localParBlock.wTCI = cvtCI;
		LocalGS.globalGS->subPixelCompatibilityFlags &= ~SPCF_inTomsDiagonal;
	}
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef DoDiagEndCtrlDeltas
	if (usingDiagEndCtrl) {
		LocalGS.globalGS->subPixelCompatibilityFlags &= ~SPCF_inDiagEndCtrl;
	}
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef BypassJellesSpacing
	if (patchedStore24) {
		LocalGS.globalGS->store[24] = store24;
	}
#endif
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	if (patchedStore22) {
		LocalGS.globalGS->store[22] = store22;
	}
#endif
#endif

	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
			
	return pbyInst;
}

/**************************************************************************/

/*
 * Function DEFinition
 */
FS_PRIVATE uint8* itrp_FDEF (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 * program, *funcStart;
	uint8 funcFragment[5][10] ={{0x01,0x20,0xB0,0x03,0x25},				// SVTCA[X] DUP[] #PUSH 3 CINDEX[]
								{0xB0,0x16,0x43,0x58},					// #PUSH 22 RS[] IF[]
								{0x01,0xB0,0x18,0x43,0x58},				// SVTCA[X] #PUSH 24 RS[] IF[]
								{0x45,0x23,0x46,0x60,0x20,0xB0,0x26},	// RCVT[] SWAP[] GC[N] ADD[] DUP[] #PUSH 38
								{0x20,0x20,0xB0,0x01,0x60,0x46,0xB0,0x40,0x23,0x42}}; // DUP[] DUP[] #PUSH[] 1 ADD[] GC[N] #PUSH[] 64 SWAP[] WS[]
	fnt_GlobalGraphicStateType * globalGS;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	if (LocalGS.globalGS->pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = FDEF_IN_GLYPHPGM_ERR;  /* returned to client, error FDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	funcDef = &globalGS->funcDef[ arg ];
	program = globalGS->pgmList[ funcDef->pgmIndex = LocalGS.globalGS->pgmIndex ].Instruction;

	CHECK_PROGRAM (funcDef->pgmIndex);
	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (globalGS->pgmList[funcDef->pgmIndex].Instruction != 0);

	funcDef->start = (int32)(pbyInst - program);

	funcStart = pbyInst;

#ifdef FSCFG_SUBPIXEL
#ifdef DoDiagEndCtrlDeltas
	if (arg == 32 && memcmp(funcStart,funcFragment[0],5) == 0) 
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedDiagEndCtrl;
#endif
#ifdef BypassDandIStroke
	if (64 <= arg && arg <= 66 && memcmp(funcStart,funcFragment[1],4) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedDandIStroke;
#endif
#ifdef BypassJellesSpacing
	if ((0 <= arg && arg <= 1 || arg == 4) && memcmp(funcStart,funcFragment[2],5) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedJellesSpacing;
#endif
#ifdef BypassVacuformRound
	if (arg == 0 && memcmp(funcStart,funcFragment[3],7) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedVacuformRound;
#endif
#ifdef BypassTomsDiagonal
	if (arg == 58 && memcmp(funcStart,funcFragment[4],10) == 0) 
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedTomsDiagonal;
#endif
#endif
	while ( ((*pbyInst++) != ENDF_CODE)  && (pbyInst < LocalGS.pbyEndInst) )
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	funcDef->length = (uint16)(pbyInst - funcStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * LOOP while CALLing a function
 */
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM)
{
	uint8 *start, *stop;
	InterpreterFunc Interpreter;
	fnt_funcDef *funcDef;
	int32 arg;
	int32 loop;
	uint8 * ins;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	funcDef = & (LocalGS.globalGS->funcDef[ arg ]);
	{
		SECURE_CHECK_PROGRAM (funcDef->pgmIndex);
		CHECK_PROGRAM (funcDef->pgmIndex);
		ins = LocalGS.globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

		start = &ins[funcDef->start];
		stop = &ins[funcDef->start + funcDef->length];  /* funcDef->end -> funcDef->length <4> */
	}
	Interpreter = LocalGS.Interpreter;
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	CHECK_LARGER (-1L, arg);
	loop = (int32)arg;
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}

	for (--loop; ((loop >= 0) && (LocalGS.ercReturn == NO_ERR)); --loop)
	{
		Interpreter (GSA start, stop);
	}
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      This guy returns the index of the given opCode, or 0 if not found <4>
 */
FS_PRIVATE fnt_instrDef *itrp_FindIDef (GSP uint8 opCode)
{
	fnt_GlobalGraphicStateType *globalGS;
	int32 count;
	fnt_instrDef*instrDef;
	
	globalGS = LocalGS.globalGS;
	count = globalGS->instrDefCount;
	instrDef = globalGS->instrDef;
		
	for (--count; count >= 0; instrDef++, --count)
	{
		if (instrDef->opCode == opCode)
		{
			return instrDef;
		}
	}
	return 0;
}

/**************************************************************************/

/*
 *      This guy gets called for opCodes that has been patch by the font's IDEF <4>
 *      or if they have never been defined.  If there is no corresponding IDEF,
 *      flag it as an illegal instruction.
 */
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM)
{
	fnt_instrDef *instrDef;
	uint8 *program;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	
	instrDef = itrp_FindIDef (GSA (uint8)lOpCode);
	if (instrDef == 0)
	{
		return itrp_IllegalInstruction (GSA pbyInst, lOpCode);
	}
	else
	{
		SECURE_CHECK_PROGRAM (instrDef->pgmIndex);
		CHECK_PROGRAM (instrDef->pgmIndex);
		program = LocalGS.globalGS->pgmList[ instrDef->pgmIndex ].Instruction;
		program += instrDef->start;
		
		LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
		if (LocalGS.ulRecursiveCall == 0)
		{
			LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}

		LocalGS.Interpreter (GSA program, program + instrDef->length);
	
		LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */

		LocalGS.pbyEndInst = pbyEndInst;    /* restore for parent */
		LocalGS.pbyStartInst = pbyStartInst;/* restore for parent */
		
		if (LocalGS.ercReturn != NO_ERR)    /* if illegal inst has been hit */
		{
			return pbyEndInst;              /* exit parent's loop */
		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 * Instruction DEFinition       <4>
 */
FS_PRIVATE uint8* itrp_IDEF (IPARAM)
{
	int32 arg;
	uint8 opCode;
	fnt_instrDef *instrDef;
	int32 pgmIndex;
	uint8 * program;
	uint8 * instrStart;

	FS_UNUSED_PARAMETER(lOpCode);

	pgmIndex = (int32)LocalGS.globalGS->pgmIndex;

	if (pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = IDEF_IN_GLYPHPGM_ERR;  /* returned to client, error IDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	program = LocalGS.globalGS->pgmList[ pgmIndex ].Instruction;
	instrStart = pbyInst;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_IDEF_OPCODE(arg);
    CHECK_INT8 (arg);
	opCode = (uint8)arg;
	CHECK_PROGRAM (pgmIndex);

	instrDef = itrp_FindIDef (GSA opCode);
	if (!instrDef)
	{
        SECURE_CHECK_IDEF_OVERFLOW();
		instrDef = LocalGS.globalGS->instrDef + LocalGS.globalGS->instrDefCount++;
	}

	instrDef->pgmIndex = (uint8) pgmIndex;
	instrDef->opCode = opCode;          /* this may or may not have been set */
	instrDef->start = (int32)(pbyInst - program);

	while (((*pbyInst++) != ENDF_CODE) && (pbyInst < LocalGS.pbyEndInst))
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	instrDef->length = (uint16)(pbyInst - instrStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * UnTouch Point
 */
  FS_PRIVATE uint8* itrp_UTP (IPARAM)
  {
	uint8*f = LocalGS.CE0->f;
	int32 point;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	point = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, point);
	CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	if (LocalGS.free.x)
	{
	  f[point] &= ~XMOVED;
	}
	if (LocalGS.free.y)
	{
	  f[point] &= ~YMOVED;
	}
	return pbyInst;
  }

/*
 * Set Delta Base
 */
  FS_PRIVATE uint8* itrp_SDB (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaBase = (int16)arg;
	return pbyInst;
  }

/*
 * Set Delta Shift
 */
  FS_PRIVATE uint8* itrp_SDS (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaShift = (int16)arg;
	return pbyInst;
  }

/**************************************************************************/

/*
 * DeltaEngine, internal support routine
 */
FS_PRIVATE uint8*  itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 sBase, int16 sShift)
{
	int32 iRange;
	int32 iAim;
	int32 iHigh;
	int32 iFakePPEM;
	int32 iPPEM;
	F26Dot6 fxDelta;

		/* Find the beginning of data pairs for this particular size */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iHigh = CHECK_POP (LocalGS.stackPointer) << 1;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, iHigh);
	LocalGS.stackPointer -= iHigh;              /* -= number of pops required */
	CHECK_STACK (&LocalGS);

	iRange = LocalGS.globalGS->pixelsPerEm;     /* same as itrp_MPPEM () */
	if (!LocalGS.globalGS->bSameStretch)
		iRange = (int32)FixMul(iRange, itrp_GetCVTScale (GSA0));
	iFakePPEM = iRange - (int32)sBase;

	if ((iFakePPEM >= 16) || (iFakePPEM < 0))
	{
		return pbyInst;                                 /* Not within exception range */
	}
	iFakePPEM = iFakePPEM << 4;

	iAim = 0;
	iRange = iHigh >> 1; 
	iRange &= ~1;
	while (iRange > 2)                          /* binary search for first data */
	{
		iPPEM = LocalGS.stackPointer[ iAim + iRange ]; /* [ iPPEM << 4 | exception ] */
		if ((iPPEM & ~0x0f) < iFakePPEM) 
		{
			iAim += iRange;                     /* approach the starting point */
		}
		iRange >>= 1; 
		iRange &= ~1;                           /* iRange must stay even */
	}

	while (iAim < iHigh) 
	{
		iPPEM = LocalGS.stackPointer[ iAim ];   /* [ iPPEM << 4 | exception ] */
		fxDelta = iPPEM & ~0x0f;
		if (fxDelta == iFakePPEM)
		{                                       /* We found an exception, go ahead and apply it */
			fxDelta = iPPEM & 0xf;              /* 0 ... 15 */
			fxDelta -= fxDelta >= 8 ? 7 : 8;    /* -8 ... -1, 1 ... 8 */
			fxDelta <<= FNT_PIXELSHIFT;        /* convert to pixels */
			fxDelta >>= sShift;                 /* scale to right size */
            
#ifdef FSCFG_SECURE
            if (doIt == LocalGS.MovePoint)
            {
                SECURE_CHECK_POINT(LocalGS.CE0,(int32)LocalGS.stackPointer[iAim+1]);
            } else
			{
				FS_ASSERT( (doIt == LocalGS.ChangeCvt), "itrp_DeltaEngine called with wrong doIt.")
                SECURE_CHECK_CVT((int32)LocalGS.stackPointer[iAim+1]);
			}
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// similar to itrp_SHP_Common above
		// main difference: we don't distinguish between SHPIX and SHP, but between CVT deltas and ordinary deltas
			if (doIt == LocalGS.ChangeCvt || !RunningSubPixel(LocalGS.globalGS) || Tuned4SubPixel(LocalGS.globalGS) || AMovedPointInNonSPDirection(LocalGS,CE0,(int16)LocalGS.stackPointer[iAim+1]))
#endif
#endif
				doIt (GSA LocalGS.CE0, (int32)LocalGS.stackPointer[iAim+1], (F26Dot6) fxDelta);
		} 
		else if (fxDelta > iFakePPEM)
		{
			break;                              /* we passed the data */
		}
		iAim += 2;
	}
    return pbyInst;
}

/**************************************************************************/

/*
 * DELTAP1
 */
  FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAP2
 */
  FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAP3
 */
  FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAC1
 */
  FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAC2
 */
  FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }

/*
 * DELTAC3
 */
  FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }


#ifdef FSCFG_NO_INITIALIZED_DATA
	
	void itrp_InitializeData (void)
	{
		int32 i;

		/***** 0x00 - 0x0f *****/
		function[0x00] = itrp_SVTCA_0;
		function[0x01] = itrp_SVTCA_1;
		function[0x02] = itrp_SPVTCA_0;
		function[0x03] = itrp_SPVTCA_1;
		function[0x04] = itrp_SFVTCA_0;
		function[0x05] = itrp_SFVTCA_1;
		function[0x06] = itrp_SPVTL;
		function[0x07] = itrp_SPVTL;
		function[0x08] = itrp_SFVTL;
		function[0x09] = itrp_SFVTL;
		function[0x0A] = itrp_WPV;
		function[0x0B] = itrp_WFV;
		function[0x0C] = itrp_RPV;
		function[0x0D] = itrp_RFV;
		function[0x0E] = itrp_SFVTPV;
		function[0x0F] = itrp_ISECT;

		/***** 0x10 - 0x1f *****/
		function[0x10] = itrp_SRP0;
		function[0x11] = itrp_SRP1;
		function[0x12] = itrp_SRP2;
		function[0x13] = itrp_SetElementPtr;
		function[0x14] = itrp_SetElementPtr;
		function[0x15] = itrp_SetElementPtr;
		function[0x16] = itrp_SetElementPtr;
		function[0x17] = itrp_LLOOP;
		function[0x18] = itrp_RTG;
		function[0x19] = itrp_RTHG;
		function[0x1A] = itrp_LMD;
		function[0x1B] = itrp_ELSE;
		function[0x1C] = itrp_JMPR;
		function[0x1D] = itrp_LWTCI;
		function[0x1E] = itrp_LSWCI;
		function[0x1F] = itrp_LSW;

		/***** 0x20 - 0x2f *****/
		function[0x20] = itrp_DUP;
		function[0x21] = itrp_POP;
		function[0x22] = itrp_CLEAR;
		function[0x23] = itrp_SWAP;
		function[0x24] = itrp_DEPTH;
		function[0x25] = itrp_CINDEX;
		function[0x26] = itrp_MINDEX;
		function[0x27] = itrp_ALIGNPTS;
		function[0x28] = itrp_RAW;
		function[0x29] = itrp_UTP;
		function[0x2A] = itrp_LOOPCALL;
		function[0x2B] = itrp_CALL;
		function[0x2C] = itrp_FDEF;
		function[0x2D] = itrp_IllegalInstruction;
		function[0x2E] = itrp_MDAP;
		function[0x2F] = itrp_MDAP;

		/***** 0x30 - 0x3f *****/
		function[0x30] = itrp_IUP;
		function[0x31] = itrp_IUP;
		function[0x32] = itrp_SHP;
		function[0x33] = itrp_SHP;
		function[0x34] = itrp_SHC;
		function[0x35] = itrp_SHC;
		function[0x36] = itrp_SHE;
		function[0x37] = itrp_SHE;
		function[0x38] = itrp_SHPIX;
		function[0x39] = itrp_IP;
		function[0x3A] = itrp_MSIRP;
		function[0x3B] = itrp_MSIRP;
		function[0x3C] = itrp_ALIGNRP;
		function[0x3D] = itrp_RTDG;
		function[0x3E] = itrp_MIAP;
		function[0x3F] = itrp_MIAP;

		/***** 0x40 - 0x4f *****/
		function[0x40] = itrp_NPUSHB;
		function[0x41] = itrp_NPUSHW;
		function[0x42] = itrp_WS;
		function[0x43] = itrp_RS;
		function[0x44] = itrp_WCVT;
		function[0x45] = itrp_RCVT;
		function[0x46] = itrp_RC;
		function[0x47] = itrp_RC;
		function[0x48] = itrp_WC;
		function[0x49] = itrp_MD;
		function[0x4A] = itrp_MD;
		function[0x4B] = itrp_MPPEM;
		function[0x4C] = itrp_MPS;
		function[0x4D] = itrp_FLIPON;
		function[0x4E] = itrp_FLIPOFF;
		function[0x4F] = itrp_DEBUG;

		/***** 0x50 - 0x5f *****/
		function[0x50] = itrp_LT;
		function[0x51] = itrp_LTEQ;
		function[0x52] = itrp_GT;
		function[0x53] = itrp_GTEQ;
		function[0x54] = itrp_EQ;
		function[0x55] = itrp_NEQ;
		function[0x56] = itrp_ODD;
		function[0x57] = itrp_EVEN;
		function[0x58] = itrp_IF;
		function[0x59] = itrp_EIF;
		function[0x5A] = itrp_AND;
		function[0x5B] = itrp_OR;
		function[0x5C] = itrp_NOT;
		function[0x5D] = itrp_DELTAP1;
		function[0x5E] = itrp_SDB;
		function[0x5F] = itrp_SDS;

		/***** 0x60 - 0x6f *****/
		function[0x60] = itrp_ADD;
		function[0x61] = itrp_SUB;
		function[0x62] = itrp_DIV;
		function[0x63] = itrp_MUL;
		function[0x64] = itrp_ABS;
		function[0x65] = itrp_NEG;
		function[0x66] = itrp_FLOOR;
		function[0x67] = itrp_CEILING;
		function[0x68] = itrp_ROUND;
		function[0x69] = itrp_ROUND;
		function[0x6A] = itrp_ROUND;
		function[0x6B] = itrp_ROUND;
		function[0x6C] = itrp_NROUND;
		function[0x6D] = itrp_NROUND;
		function[0x6E] = itrp_NROUND;
		function[0x6F] = itrp_NROUND;

		/***** 0x70 - 0x7f *****/
		function[0x70] = itrp_WCVTFOD;
		function[0x71] = itrp_DELTAP2;
		function[0x72] = itrp_DELTAP3;
		function[0x73] = itrp_DELTAC1;
		function[0x74] = itrp_DELTAC2;
		function[0x75] = itrp_DELTAC3;
		function[0x76] = itrp_SROUND;
		function[0x77] = itrp_S45ROUND;
		function[0x78] = itrp_JROT;
		function[0x79] = itrp_JROF;
		function[0x7A] = itrp_ROFF;
		function[0x7B] = itrp_IllegalInstruction;
		function[0x7C] = itrp_RUTG;
		function[0x7D] = itrp_RDTG;
		function[0x7E] = itrp_SANGW;
		function[0x7F] = itrp_AA;

		/***** 0x80 - 0x8d *****/
		function[0x80] = itrp_FLIPPT;
		function[0x81] = itrp_FLIPRGON;
		function[0x82] = itrp_FLIPRGOFF;
		function[0x83] = itrp_IDefPatch;
		function[0x84] = itrp_IDefPatch;
		function[0x85] = itrp_SCANCTRL;
		function[0x86] = itrp_SDPVTL;
		function[0x87] = itrp_SDPVTL;
		function[0x88] = itrp_GETINFO;
		function[0x89] = itrp_IDEF;
		function[0x8A] = itrp_ROTATE;
		function[0x8B] = itrp_MAX;
		function[0x8C] = itrp_MIN;
		function[0x8D] = itrp_SCANTYPE;
		function[0x8E] = itrp_INSTCTRL;

		/***** 0x8f - 0xaf *****/
		for ( i = 0x8F; i <= 0xAF;  ++i )
			function[i] = itrp_IDefPatch;

		/***** 0xb0 - 0xb7 *****/
		function[0xB0] = itrp_PUSHB1;
		function[0xB1] = itrp_PUSHB;
		function[0xB2] = itrp_PUSHB;
		function[0xB3] = itrp_PUSHB;
		function[0xB4] = itrp_PUSHB;
		function[0xB5] = itrp_PUSHB;
		function[0xB6] = itrp_PUSHB;
		function[0xB7] = itrp_PUSHB;

		/***** 0xb8 - 0xbf *****/
		function[0xB8] = itrp_PUSHW1;
		function[0xB9] = itrp_PUSHW;
		function[0xBA] = itrp_PUSHW;
		function[0xBB] = itrp_PUSHW;
		function[0xBC] = itrp_PUSHW;
		function[0xBD] = itrp_PUSHW;
		function[0xBE] = itrp_PUSHW;
		function[0xBF] = itrp_PUSHW;

		/***** 0xc0 - 0xdf *****/
		for ( i = 0xC0; i <= 0xDF;  i++ )
			function[i] = itrp_MDRP;

		/***** 0xe0 - 0xff *****/
		for ( i = 0xE0; i <= 0xFF;  i++ )
			function[i] = itrp_MIRP;
		
#ifdef FSCFG_SUBPIXEL
		// initialize round function table for SP
		itrp_RoundFunction[0][0] = itrp_RoundToDoubleGrid;
		itrp_RoundFunction[0][1] = itrp_RoundDownToGrid;
		itrp_RoundFunction[0][2] = itrp_RoundUpToGrid;
		itrp_RoundFunction[0][3] = itrp_RoundToGrid;
		itrp_RoundFunction[0][4] = itrp_RoundToHalfGrid;
		itrp_RoundFunction[0][5] = itrp_RoundOff;
		itrp_RoundFunction[0][6] = itrp_SuperRound;
		itrp_RoundFunction[0][7] = itrp_Super45Round;
		itrp_RoundFunction[1][0] = itrp_RoundToDoubleGridSP;
		itrp_RoundFunction[1][1] = itrp_RoundDownToGridSP;
		itrp_RoundFunction[1][2] = itrp_RoundUpToGridSP;
		itrp_RoundFunction[1][3] = itrp_RoundToGridSP;
		itrp_RoundFunction[1][4] = itrp_RoundToHalfGridSP;
		itrp_RoundFunction[1][5] = itrp_RoundOffSP;
		itrp_RoundFunction[1][6] = itrp_SuperRound;
		itrp_RoundFunction[1][7] = itrp_Super45Round;
#endif
	}

#endif /* FSCFG_NO_INITIALIZED_DATA */

/* END OF interp.c */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scendpt.c ===
/*********************************************************************

	  scendpt.c -- New Scan Converter EndPoint Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  10/28/92  deanb   reentrant params renamed
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/14/92  deanb   check vert topology written 
	   9/10/92  deanb   first dropout code 
	   8/18/92  deanb   include struc.h, scconst.h 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   5/08/92  deanb   reordered includes for precompiled headers 
	   4/21/92  deanb   Single HorizScanAdd 
	   4/09/92  deanb   New types 
	   4/06/92  deanb   Check Topology corrected 
	   4/02/92  deanb   Coded 
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scendpt.h"             /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void CheckHorizTopology( PSTATE F26Dot6, F26Dot6, uint16 );
FS_PRIVATE void CheckVertTopology( PSTATE F26Dot6, F26Dot6, uint16 );

FS_PRIVATE void AddHorizOn( PSTATE uint16 );
FS_PRIVATE void AddHorizOff( PSTATE uint16 );
FS_PRIVATE void AddVertOn( PSTATE uint16 );
FS_PRIVATE void AddVertOff( PSTATE uint16 );

FS_PRIVATE F26Dot6 CalcHorizEpSubpix( int32, F26Dot6*, F26Dot6* );
FS_PRIVATE F26Dot6 CalcVertEpSubpix( int32, F26Dot6*, F26Dot6* );


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupEndPt (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_ENDPTCODE, CalcHorizEpSubpix, CalcVertEpSubpix);
}

/*********************************************************************/

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX,         /* starting point x coordinate */
		F26Dot6 fxY )        /* starting point y coordinate */
{
	STATE.fxX1 = fxX;                   /* last = contour start point */
	STATE.fxY1 = fxY;
	STATE.fxX0 = HUGEFIX;               /* contour begin alert */
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX2,        /* x coordinate */
		F26Dot6 fxY2,        /* y coordinate */
		uint16 usScanKind )  /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
		{
			return NO_ERR;                  /*   and just ignore them   */
		}
				
		if (STATE.fxX0 == HUGEFIX)          /* if contour begin */
		{
			STATE.fxX2Save = fxX2;          /*   keep for contour end   */
			STATE.fxY2Save = fxY2;          
		}
		else                                /* if mid contour */
		{
			CheckHorizTopology(ASTATE fxX2, fxY2, usScanKind);
		}               
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
			{
				return NO_ERR;              /*   and just ignore them   */
			}
				
			if (STATE.fxX0 == HUGEFIX)      /* if contour begin */
			{
				STATE.fxX2Save = fxX2;      /*   keep for contour end   */
				STATE.fxY2Save = fxY2;
			}
			else                            /* if mid contour */
			{
				CheckVertTopology(ASTATE fxX2, fxY2, usScanKind);
			}               
		}
	}

	STATE.fxX0 = STATE.fxX1;                /* old = last */
	STATE.fxY0 = STATE.fxY1;
	STATE.fxX1 = fxX2;                      /* last = current */
	STATE.fxY1 = fxY2;
	
	return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE                          /* pointer to state variables */
		uint16 usScanKind )             /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		CheckHorizTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			CheckVertTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Private Functions      */

/*********************************************************************/

/*      Implement the endpoint-on-horiz-scanline case table    */

FS_PRIVATE void CheckHorizTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{

/* printf("(%li, %li)", fxX2, fxY2); */

	if (fxY2 > STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 < STATE.fxX0)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxY2 < STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 > STATE.fxX0)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxY2 == STATE.fxY1) */
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			if (fxX2 > STATE.fxX1)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			if (fxX2 < STATE.fxX1)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if ((STATE.fxX1 > STATE.fxX0) && (fxX2 < STATE.fxX1))
			{
				AddHorizOff(ASTATE usScanKind);
			}
			else if ((STATE.fxX1 < STATE.fxX0) && (fxX2 > STATE.fxX1))
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/

/*      Implement the endpoint-on-vert-scanline case table      */

FS_PRIVATE void CheckVertTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{
	if (fxX2 < STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 < STATE.fxY0)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxX2 > STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 > STATE.fxY0)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxX2 == STATE.fxX1) */
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			if (fxY2 > STATE.fxY1)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			if (fxY2 < STATE.fxY1)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if ((STATE.fxY1 > STATE.fxY0) && (fxY2 < STATE.fxY1))
			{
				AddVertOff(ASTATE usScanKind);
			}
			else if ((STATE.fxY1 < STATE.fxY0) && (fxY2 > STATE.fxY1))
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */
	
	lXScan = (int32)((STATE.fxX1 + SUBHALF - 1) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 4, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lXScan = (int32)((STATE.fxX1 + SUBHALF) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 2, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF - 1) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizEpSubpix(int32 lYScan, 
									 F26Dot6 *pfxX, 
									 F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lYScan);
	FS_UNUSED_PARAMETER(pfxY);

/* printf("HorizEndpt(%li %li)\n", *pfxX, *pfxY); */

	return *pfxX;                           /* exact intersection */
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertEpSubpix(int32 lXScan, 
									F26Dot6 *pfxX, 
									F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lXScan);
	FS_UNUSED_PARAMETER(pfxX);

/* printf("VertEndpt (%li %li)\n", *pfxX, *pfxY); */

	return *pfxY;                           /* exact intersection */
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scendpt.h ===
/*********************************************************************

	  scendpt.h -- EndPoint Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetEndpointElemSize returns size_t 
	   9/08/92 deanb    GetEndpointElemSize added 
	   7/24/92 deanb    ContourSave functions deleted 
	   4/09/92 deanb    New types again 
	   3/20/92 deanb    New types, save contour functions 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupEndPt ( PSTATE0 );

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* starting point x coordinate */
		F26Dot6             /* starting point y coordinate */
);

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* x coordinate */
		F26Dot6,            /* y coordinate */
		uint16              /* scan control type */
);

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE              /* pointer to state variables */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scentry.c ===
/*********************************************************************

	  scentry.c -- New Scan Converter NewScan Module

	  (c) Copyright 1992-1997  Microsoft Corp.  All rights reserved.

	  10/14/97  claudebe    accessing unitialized memory
	   1/31/95  deanb       added fsc_GetCoords function
	   8/04/94  deanb       State initialized to more it out of bss
	   8/24/93  deanb       flatcount fix to reversal detection
	   8/10/93  deanb       gray scale support routines added
	   6/22/93  deanb       all black bounding box, (0,0) for null glyph
	   6/11/93  gregh       Removed ONCURVE definition
	   6/11/93  deanb       if HiBand <= LoBand do entire bitmap
	   6/10/93  deanb       fsc_Initialize added, stdio & assert gone
	   4/06/92  deanb       CheckContour removed
	   3/19/92  deanb       ScanArrays rather than lists
	  12/22/92  deanb       MultDivide -> LongMulDiv; Rectangle -> Rect
	  12/21/92  deanb       interface types aligned with rasterizer
	  12/11/92  deanb       fserror.h imported, new error codes
	  11/30/92  deanb       WorkSpace renamed WorkScan
	  11/04/92  deanb       remove duplicate points function added
	  10/28/92  deanb       memory requirement calculation reworked
	  10/19/92  deanb       bad contours ignored rather than error'd
	  10/16/92  deanb       first contour point off curve fix
	  10/13/92  deanb       rect.bounds correction
	  10/12/92  deanb       reentrant State implemented
	  10/08/92  deanb       reworked for split workspace
	  10/05/92  deanb       global ListMemory replace with stListSize 
	   9/25/92  deanb       scankind included in line/spline/endpoint calls 
	   9/10/92  deanb       dropout coding begun 
	   9/08/92  deanb       MAXSPLINELENGTH now imported from scspline.h 
	   8/18/92  deanb       New i/f for dropout control, contour elems 
	   7/28/92  deanb       Recursive calls for up/down & left/right 
	   7/23/92  deanb       EvaluateSpline included 
	   7/17/92  deanb       Included EvaluateLine 
	   7/13/92  deanb       Start/End point made SHORT 
	   6/01/92  deanb       fsc_FillBitMap debug switch added 
	   5/08/92  deanb       reordered includes for precompiled headers 
	   4/27/92  deanb       Splines coded 
	   4/09/92  deanb       New types 
	   4/06/92  deanb       rectBounds calc corrected 
	   3/30/92  deanb       MinMax calc added to MeasureContour 
	   3/24/92  deanb       GetWorkspaceSize coded 
	   3/23/92  deanb       First cut 
 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for LongMulDiv */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scspline.h"            /* spline evaluation */
#include    "scline.h"              /* line evaluation */
#include    "scendpt.h"             /* for init and contour list */
#include    "scanlist.h"            /* for init and bitmap */
#include    "scmemory.h"            /* for setup mem */
#include    "scentry.h"             /* for own function prototypes */

/*********************************************************************/
											 
/*      Global state structure                                       */

/*********************************************************************/

#ifndef FSCFG_REENTRANT
	
FS_PUBLIC StateVars   State = {0};  /* global static:  available to all */

#endif

/*********************************************************************/
											 
/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema(ContourList*, GlyphBitMap*);

FS_PRIVATE int32 EvaluateSpline(PSTATE F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, uint16 );


/*********************************************************************/
											 
/*      Function Exports                                             */

/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_Initialize()
{
	fsc_InitializeScanlist();               /* scanlist calls to bitmap */
}


/*********************************************************************/

/*  Remove duplicated points from contour data                       */

/*  This was previously done in sc_FindExtrema of sc.c,              */
/*  but was pulled out to avoid having fsc_MeasureGlyph              */
/*  make changes to the contour list data structure.                 */

/*********************************************************************/

FS_PUBLIC int32 fsc_RemoveDups( 
		ContourList* pclContour )           /* glyph outline */
{
	uint16 usContour;                       /* contour limit */
	int16 sStartPt, sEndPt;                 /* coutour index limits */
	int16 sPt;                              /* point index */
	int16 s;                                /* index for list collapse */
	F26Dot6 *pfxX1, *pfxY1;                 /* leading point */
	F26Dot6 fxX2, fxY2;                     /* trailing point */

	for (usContour = 0; usContour < pclContour->usContourCount; usContour++)
	{
		sStartPt = pclContour->asStartPoint[usContour];
		sEndPt = pclContour->asEndPoint[usContour];
		
		pfxX1 = &(pclContour->afxXCoord[sStartPt]); 
		pfxY1 = &(pclContour->afxYCoord[sStartPt]); 
					
		for (sPt = sStartPt; sPt < sEndPt; ++sPt)
		{
			fxX2 = *pfxX1;                          /* check next pair */
			pfxX1++;
			fxY2 = *pfxY1;
			pfxY1++;
			
			if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if duplicate */
			{
				for(s = sPt; s > sStartPt; s--)     /* s = index of point to be removed */
				{
					pclContour->afxXCoord[s] = pclContour->afxXCoord[s - 1];
					pclContour->afxYCoord[s] = pclContour->afxYCoord[s - 1];
					pclContour->abyOnCurve[s] = pclContour->abyOnCurve[s - 1];
				}
				sStartPt++;                         /* advance start past dup */
				pclContour->asStartPoint[usContour] = sStartPt;
				pclContour->abyOnCurve[sPt + 1] |= ONCURVE; /* dup'd pt must be on curve */
			}
		}
		
		/* now pfxX1 and pfxY1 point to end point coordinates */

		if (sStartPt != sEndPt)                     /* finished if single point */
		{
			fxX2 = pclContour->afxXCoord[sStartPt];
			fxY2 = pclContour->afxYCoord[sStartPt];
								
			if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if start = end */
			{
				pclContour->asStartPoint[usContour]++;
				pclContour->abyOnCurve[sEndPt] |= ONCURVE;  /* dup'd pt must be on curve */
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given glyph into a given bitmap.  Get per intersection and     */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra )
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int16 sOrgDir;                      /* original contour direction */
	int16 sDir;                         /* current contour direction */
	int16 sFlatCount;                   /* for contours starting flat */
	int32 lVScanCount;                  /* total vertical scan lines */
	int32 lHScanCount;                  /* total horizontal scan lines */
	int32 lTotalHIx;
	int32 lTotalVIx;
	int32 lElementCount;                /* total element point estimate */
	int32 lDivide;                      /* spline element point counter */
	int32 lErrCode;    
	
	F26Dot6 fxX1, fxX2;                 /* x coord endpoints */
	F26Dot6 fxY1, fxY2;                 /* y coord endpoints */
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	F26Dot6 fxAbsDelta;                 /* for element count check */
	uint8 byF1, byF2;                   /* oncurve flag values */
	uint8 *pbyFlags;                    /* for element count check */

	PRevRoot prrRoots;                  /* reversal list roots structure */

	
	lErrCode = FindExtrema(pclContour, pbmpBitMap); /* calc bounding box */
	if (lErrCode != NO_ERR) return lErrCode;

	pbmpBitMap->rectBounds.left &= -((int32)usRoundXMin);   /* mask off low n bits */

	/* bitmap emboldening by 2% + 1 pixel horizontally, 2% vertically */
	if (sBitmapEmboldeningHorExtra > 0)
	{
	    pbmpBitMap->rectBounds.right += sBitmapEmboldeningHorExtra;
	}
	else
	{
	    pbmpBitMap->rectBounds.left += sBitmapEmboldeningHorExtra;
	}
	if (sBitmapEmboldeningVertExtra > 0)
	{
	    pbmpBitMap->rectBounds.bottom -= (sBitmapEmboldeningVertExtra);
	}
	else
	{
	    pbmpBitMap->rectBounds.top -= (sBitmapEmboldeningVertExtra);
	}

	prrRoots = fsc_SetupRevRoots(pwsWork->pchRBuffer, pwsWork->lRMemSize);
	lElementCount = 0;                  /* smart point counter */
	
	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
		if (sStart == sEnd)
		{
			continue;                               /* for anchor points */
		}

/* check contour Y values for direction reversals */

		fxY1 = pclContour->afxYCoord[sEnd];         /* start by closing */
		pfxYCoord = &pclContour->afxYCoord[sStart];

		sPt = sStart;
		sDir = 0;                                   /* starting dir unknown */
		sFlatCount = 0;
		while ((sDir == 0) && (sPt <= sEnd))
		{
			fxY2 = *pfxYCoord++;
			if (fxY2 > fxY1)                        /* find first up or down */
			{
				sDir = 1;
			}
			else if (fxY2 < fxY1)
			{
				sDir = -1;
			}
			else
			{
				sFlatCount++;                       /* countour starts flat */
			}
			fxY1 = fxY2;
			sPt++;
		}
		sOrgDir = sDir;                             /* save original ep check */

		while (sPt <= sEnd)
		{
			fxY2 = *pfxYCoord++;
			if (sDir == 1)
			{
				if (fxY2 <= fxY1)                   /* = is for endpoint cases */
				{
					fsc_AddYReversal (prrRoots, fxY1, 1);
					sDir = -1;
				}
			}
			else    /* if sDir == -1 */
			{
				if (fxY2 >= fxY1)                   /* = is for endpoint cases */
				{
					fsc_AddYReversal (prrRoots, fxY1, -1);
					sDir = 1;
				}
			}
			fxY1 = fxY2;                            /* next segment */
			sPt++;
		}
								
		while (sFlatCount > 0)                      /* if contour started flat */
		{
			if (sDir == 0)                          /* if completely flat */
			{
				sDir = 1;                           /* then pick a direction */
				sOrgDir = 1;
			}
			fsc_AddYReversal (prrRoots, fxY1, sDir); /* add one per point */
			sDir = -sDir;
			sFlatCount--;
		}
		if (sOrgDir != sDir)                        /* if endpoint reverses */
		{
			fsc_AddYReversal (prrRoots, fxY1, sDir); /* then balance up/down */
		}

/* if doing dropout control, check contour X values for direction reversals */

		if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
		{
			fxX1 = pclContour->afxXCoord[sEnd];     /* start by closing */
			pfxXCoord = &pclContour->afxXCoord[sStart];

			sPt = sStart;
			sDir = 0;                               /* starting dir unknown */
			sFlatCount = 0;
			while ((sDir == 0) && (sPt <= sEnd))
			{
				fxX2 = *pfxXCoord++;
				if (fxX2 > fxX1)                    /* find first up or down */
				{
					sDir = 1;
				}
				else if (fxX2 < fxX1)
				{
					sDir = -1;
				}
				else
				{
					sFlatCount++;                   /* countour starts flat */
				}
				fxX1 = fxX2;
				sPt++;
			}
			sOrgDir = sDir;                         /* save original ep check */

			while (sPt <= sEnd)
			{
				fxX2 = *pfxXCoord++;
				if (sDir == 1)
				{
					if (fxX2 <= fxX1)               /* = is for endpoint cases */
					{
						fsc_AddXReversal (prrRoots, fxX1, 1);
						sDir = -1;
					}
				}
				else    /* if sDir == -1 */
				{
					if (fxX2 >= fxX1)               /* = is for endpoint cases */
					{
						fsc_AddXReversal (prrRoots, fxX1, -1);
						sDir = 1;
					}
				}
				fxX1 = fxX2;                        /* next segment */
				sPt++;
			}
									
			while (sFlatCount > 0)                  /* if contour started flat */
			{
				if (sDir == 0)                      /* if completely flat */
				{
					sDir = 1;                       /* then pick a direction */
					sOrgDir = 1;
				}
				fsc_AddXReversal (prrRoots, fxX1, sDir); /* add one per point */
				sDir = -sDir;
				sFlatCount--;
			}
			if (sOrgDir != sDir)                    /* if endpoint reverses */
			{
				fsc_AddXReversal (prrRoots, fxX1, sDir); /* then balance up/down */
			}

			if (usScanKind & SK_SMART)              /* if smart dropout control */
			{                                       /* estimate the elem point count */
				fxX1 = pclContour->afxXCoord[sEnd];
				fxY1 = pclContour->afxYCoord[sEnd];
				byF1 = pclContour->abyOnCurve[sEnd];
				pfxXCoord = &pclContour->afxXCoord[sStart];
				pfxYCoord = &pclContour->afxYCoord[sStart];
				pbyFlags = &pclContour->abyOnCurve[sStart];

				lElementCount += (uint32)(sEnd - sStart) + 2L;  /* 1/pt + 1/contour */

				for (sPt = sStart; sPt <= sEnd; sPt++)
				{
					fxX2 = *pfxXCoord++;
					fxY2 = *pfxYCoord++;
					byF2 = *pbyFlags++;

					if (((byF1 & byF2) & ONCURVE) == 0) /* if this is a spline */
					{
						if (((byF1 | byF2) & ONCURVE) == 0)
						{
							lElementCount++;            /* +1 for midpoint */
						}
								
						if (FXABS(fxX2 - fxX1) > FXABS(fxY2 - fxY1))
						{
							fxAbsDelta = FXABS(fxX2 - fxX1);
						}
						else
						{
							fxAbsDelta = FXABS(fxY2 - fxY1);
						}
						lDivide = 0;
						while (fxAbsDelta > (MAXSPLINELENGTH / 2))
						{
							lDivide++;
							lDivide <<= 1;
							fxAbsDelta >>= 1;
						}
						lElementCount += lDivide;   /* for subdivision */
					}
					fxX1 = fxX2;
					fxY1 = fxY2;
					byF1 = byF2;
				}
			}
		}
	}
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART))  /* if smart dropout */
	{
		lElementCount += fsc_GetReversalCount(prrRoots) << 1;  /* add in 2 * reversals */
		if (lElementCount > (0xFFFF >> SC_CODESHFT))
		{
			return SMART_DROP_OVERFLOW_ERR;
		}
	}

		
/*  set horiz workspace return values */

	lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
	lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
	
	pbmpBitMap->sRowBytes = (int16)ROWBYTESLONG(lVScanCount);
	pbmpBitMap->lMMemSize = (lHScanCount * (int32)pbmpBitMap->sRowBytes);
	
	lTotalHIx = fsc_GetHIxEstimate(prrRoots);   /* intersection count */
	pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

/*  set vertical workspace return values */
	
	if (usScanKind & SK_NODROPOUT)                  /* if no dropout */
	{
		pwsWork->lVMemSize = 0L;
		lTotalVIx = 0;
	}
	else
	{
		lTotalVIx = fsc_GetVIxEstimate(prrRoots);   /* estimate intersection count */
		pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, lTotalVIx, lElementCount);
	}
	
	pwsWork->lHInterCount = lTotalHIx;              /* save for SetupScan */
	pwsWork->lVInterCount = lTotalVIx;
	pwsWork->lElementCount = lElementCount;
	pwsWork->lRMemSize = fsc_GetRevMemSize(prrRoots);

#ifdef FSCFG_REENTRANT
	
	pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif

	return NO_ERR;
} 


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given band into a given bitmap.  Get per intersection and      */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureBand( 
		GlyphBitMap* pbmpBitMap,        /* computed by MeasureGlyph */
		WorkScan* pwsWork,              /* to return new values */
		uint16 usBandType,              /* small or fast */
		uint16 usBandWidth,             /* scanline count */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lBandWidth;                   /* max scanline count */
	int32 lTotalHIx;                    /* est of horiz intersections in band */
	int32 lVScanCount;                  /* total vertical scan lines */
	int32 lHScanCount;                  /* total horizontal scan lines */

	lBandWidth = (int32)usBandWidth;
	pbmpBitMap->lMMemSize = (lBandWidth * (int32)pbmpBitMap->sRowBytes);
	
	if (usBandType == FS_BANDINGSMALL) 
	{
		lTotalHIx = fsc_GetHIxBandEst((PRevRoot)pwsWork->pchRBuffer, &pbmpBitMap->rectBounds, lBandWidth);
		pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
		pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lBandWidth, lTotalHIx);
		pwsWork->lVMemSize = 0L;            /* force dropout control off */
	}
	else if (usBandType == FS_BANDINGFAST) 
	{
		lTotalHIx = fsc_GetHIxEstimate((PRevRoot)pwsWork->pchRBuffer);  /* intersection count */
		pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
		
		lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
		pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

		if (usScanKind & SK_NODROPOUT)      /* if no dropout */
		{
			pwsWork->lVMemSize = 0L;
		}
		else                                /* if any kind of dropout */
		{
			pbmpBitMap->lMMemSize += (int32)pbmpBitMap->sRowBytes;  /* to save below row */
			
			lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
			pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, pwsWork->lVInterCount, pwsWork->lElementCount);
			pwsWork->lVMemSize += (int32)pbmpBitMap->sRowBytes;     /* to save above row */
			ALIGN(voidPtr, pwsWork->lVMemSize ); 
		}
	}
	
#ifdef FSCFG_REENTRANT
	
	pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif
	
	return NO_ERR;
}


/*********************************************************************/

/*  Scan Conversion Routine                                          */
/*  Trace the contour, passing out lines and splines,                */
/*  then call ScanList to fill the bitmap                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pgbBitMap,         /* target */
		WorkScan* pwsWork,              /* for scan array */
		uint16 usBandType,              /* old, small, fast or faster */
		uint16 usScanKind )             /* dropout control value */
{
	uint16 usCont;                      /* contour index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int32 lStateSpace;                  /* HMem used by state structure */
	int32 lErrCode;                     /* function return code */
	F26Dot6 *pfxXCoord;                 /* next x coord ptr */
	F26Dot6 *pfxYCoord;                 /* next y coord ptr */
	uint8 *pbyOnCurve;                  /* next flag ptr */
	F26Dot6 *pfxXStop;                  /* contour trace end condition */
	F26Dot6 fxX1, fxX2, fxX3;           /* x coord endpoints */
	F26Dot6 fxY1, fxY2, fxY3;           /* y coord endpoints */
	uint8 byOnCurve;                    /* point 2 flag variable */
	int32 lHiScanBand;                  /* top scan limit */ 
	int32 lLoScanBand;                  /* bottom scan limit */
	int32 lHiBitBand;                   /* top bitmap limit */
	int32 lLoBitBand;                   /* bottom bitmap limit */
	int32 lOrgLoBand;                   /* save for overscan fill check */
	F26Dot6 fxYHiBand, fxYLoBand;       /* limits in f26.6 */
	boolean bSaveRow;                   /* for dropout over scanning */
	boolean bBandCheck;                 /* eliminate out of band elements */

#ifdef FSCFG_REENTRANT
	
	StateVars *pState;                  /* reentrant State is accessed via pointer */

	pState = (StateVars*)pwsWork->pchHBuffer;  /* and lives in HMem (memoryBase[6]) */ 
	lStateSpace = sizeof(StateVars);

#else
	
	lStateSpace = 0L;                   /* no HMem needed if not reentrant */

#endif
	
	if (pgbBitMap->rectBounds.top <= pgbBitMap->rectBounds.bottom)
	{
		return NO_ERR;                              /* quick out for null glyph */
	}

	if (pgbBitMap->bZeroDimension)                  /* if no height or width */
	{
		usScanKind &= (~SK_STUBS);                  /* force no-stub dropout */
	}

	lHiBitBand = (int32)pgbBitMap->sHiBand, 
	lLoBitBand = (int32)pgbBitMap->sLoBand;
	lOrgLoBand = lLoBitBand;                        /* save for fill call */    
	
	Assert (lHiBitBand > lLoBitBand);               /* should be handled above */
	
	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lLoBitBand--;                               /* leave room below line */
	}
	if (lHiBitBand > pgbBitMap->rectBounds.top)
	{
		lHiBitBand = pgbBitMap->rectBounds.top;     /* clip to top */
	}
	if (lLoBitBand < pgbBitMap->rectBounds.bottom)
	{
		lLoBitBand = pgbBitMap->rectBounds.bottom;  /* clip to bottom */
	}
	if (usBandType == FS_BANDINGFAST)               /* if fast banding */
	{
		lHiScanBand = pgbBitMap->rectBounds.top;    /* render everything */
		lLoScanBand = pgbBitMap->rectBounds.bottom;
		bSaveRow = TRUE;                            /* keep last row for dropout */
	}
	else                                            /* if old or small banding */
	{
		lHiScanBand = lHiBitBand;                   /* just take the band */
		lLoScanBand = lLoBitBand;
		bSaveRow = FALSE;                           /* last row not needed */
	}
	
/*  if fast banding has already renderend elements, skip to FillBitMap */

	if (usBandType != FS_BANDINGFASTER)             /* if rendering required */
	{
		fsc_SetupMem(ASTATE                         /* init workspace */
				pwsWork->pchHBuffer + lStateSpace, 
				pwsWork->lHMemSize - lStateSpace,
				pwsWork->pchVBuffer, 
				pwsWork->lVMemSize);
		
		fsc_SetupLine(ASTATE0);             /* passes line callback to scanlist */
		fsc_SetupSpline(ASTATE0);           /* passes spline callback to scanlist */
		fsc_SetupEndPt(ASTATE0);            /* passes endpoint callback to scanlist */

/*  Eliminate out of band lines and splines, unless fast banding */

		bBandCheck = ((lHiScanBand < pgbBitMap->rectBounds.top) || (lLoScanBand > pgbBitMap->rectBounds.bottom));

		fxYHiBand = (F26Dot6)((lHiScanBand << SUBSHFT) - SUBHALF);  /* may be too wide */
		fxYLoBand = (F26Dot6)((lLoScanBand << SUBSHFT) + SUBHALF);

		lErrCode = fsc_SetupScan(ASTATE &(pgbBitMap->rectBounds), usScanKind, 
							 lHiScanBand, lLoScanBand, bSaveRow, (int32)pgbBitMap->sRowBytes,
							 pwsWork->lHInterCount, pwsWork->lVInterCount,
							 pwsWork->lElementCount, (PRevRoot)pwsWork->pchRBuffer );

		if (lErrCode != NO_ERR) return lErrCode;
		
		for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
		{
			sStart = pclContour->asStartPoint[usCont];
			sEnd = pclContour->asEndPoint[usCont];

			if (sStart == sEnd)
			{
				continue;                               /* for compatibilty */
			}
/*
	For efficiency in tracing the contour, we start by assigning (x1,y1)
	to the last oncurve point.  This is found by starting with the End
	point and backing up if necessary.  The pfxCoord pointers can then
	be used to trace the entire contour without being reset across the
	Start/End gap. 
*/
			pfxXCoord = &pclContour->afxXCoord[sStart];
			pfxYCoord = &pclContour->afxYCoord[sStart];
			pbyOnCurve = &pclContour->abyOnCurve[sStart];
			pfxXStop = &pclContour->afxXCoord[sEnd];

			if (pclContour->abyOnCurve[sEnd] & ONCURVE) /* if endpoint oncurve */
			{
				fxX1 = pclContour->afxXCoord[sEnd];
				fxY1 = pclContour->afxYCoord[sEnd];
				fxX2 = *pfxXCoord;
				fxY2 = *pfxYCoord;
				byOnCurve = *pbyOnCurve;                /* 1st pt might be off */
				pfxXStop++;                             /* stops at endpoint */
			}
			else                                        /* if endpoint offcurve */
			{
				fxX1 = pclContour->afxXCoord[sEnd - 1];
				fxY1 = pclContour->afxYCoord[sEnd - 1];
				fxX2 = pclContour->afxXCoord[sEnd];
				fxY2 = pclContour->afxYCoord[sEnd];
				if ((pclContour->abyOnCurve[sEnd - 1] & ONCURVE) == 0)
				{
					fxX1 = (fxX1 + fxX2 + 1) >> 1;      /* offcurve midpoint */
					fxY1 = (fxY1 + fxY2 + 1) >> 1;
				}
				byOnCurve = 0;
				pfxXCoord--;                            /* pre decrement */
				pfxYCoord--;
				pbyOnCurve--;
			}
			fsc_BeginContourEndpoint(ASTATE fxX1, fxY1);          /* 1st oncurve pt -> ep module */
			fsc_BeginContourScan(ASTATE usScanKind, fxX1, fxY1);  /* to scanlist module too */
/*
	At this point, (x1,y1) is the last oncurve point; (x2,y2) is the next
	point (on or off); and the pointers are ready to be incremented to the
	point following (x2,y2).  
		
	Throughout this loop (x1,y1) is always an oncurve point (it may be the 
	midpoint between two offcurve points).  If (x2,y2) is oncurve, then we 
	have a line; if offcurve, we have a spline, and (x3,y3) will be the 
	next oncurve point.
*/
			if (!bBandCheck)
			{
				while (pfxXCoord < pfxXStop)
				{
					if (byOnCurve & ONCURVE)                /* if next point oncurve */
					{
						lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						fxX1 = fxX2;                        /* next oncurve point */
						fxY1 = fxY2;
								
						pfxXCoord++;
						pfxYCoord++;
						pbyOnCurve++;
					}
					else
					{
						pfxXCoord++;                        /* check next point */
						fxX3 = *pfxXCoord;
						pfxYCoord++;
						fxY3 = *pfxYCoord;
						pbyOnCurve++;
								
						if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
						{
							pfxXCoord++;
							pfxYCoord++;
							pbyOnCurve++;
						}
						else                                /* if not, calc next on */
						{
							fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
							fxY3 = (fxY2 + fxY3 + 1) >> 1;
						}
						lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						fxX1 = fxX3;                        /* next oncurve point */
						fxY1 = fxY3;
					}

					/* test to avoid reading past the end of memory on the last line */
					if (pfxXCoord != pfxXStop)
					{
						fxX2 = *pfxXCoord;                      /* next contour point */
						fxY2 = *pfxYCoord;
						byOnCurve = *pbyOnCurve;
					}
				}
			}
			else    /* if band checking */
			{
				while (pfxXCoord < pfxXStop)
				{
					if (byOnCurve & ONCURVE)                /* if next point oncurve */
					{
						lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand)) ||
							  ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand))))
						{
							lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}

						fxX1 = fxX2;                        /* next oncurve point */
						fxY1 = fxY2;
								
						pfxXCoord++;
						pfxYCoord++;
						pbyOnCurve++;
					}
					else
					{
						pfxXCoord++;                        /* check next point */
						fxX3 = *pfxXCoord;
						pfxYCoord++;
						fxY3 = *pfxYCoord;
						pbyOnCurve++;
								
						if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
						{
							pfxXCoord++;
							pfxYCoord++;
							pbyOnCurve++;
						}
						else                                /* if not, calc next on */
						{
							fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
							fxY3 = (fxY2 + fxY3 + 1) >> 1;
						}

						if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand) && (fxY3 > fxYHiBand)) ||
							  ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand) && (fxY3 < fxYLoBand))))
						{
							lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}
						else    /* if entirely outside of the band */
						{
							lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}

						fxX1 = fxX3;                        /* next oncurve point */
						fxY1 = fxY3;
					}

					/* test to avoid reading past the end of memory on the last line */
					if (pfxXCoord != pfxXStop)
					{
						fxX2 = *pfxXCoord;                      /* next contour point */
						fxY2 = *pfxYCoord;
						byOnCurve = *pbyOnCurve;
					}
				}
			}
			lErrCode = fsc_EndContourEndpoint(ASTATE usScanKind);
			if (lErrCode != NO_ERR) return lErrCode;
		}
	}
	
	lErrCode = fsc_FillBitMap(
			ASTATE 
			pgbBitMap->pchBitMap, 
			lHiBitBand, 
			lLoBitBand,
			(int32)pgbBitMap->sRowBytes, 
			lOrgLoBand,
			usScanKind
	);

	if (lErrCode != NO_ERR) return lErrCode;
	
	return NO_ERR;
}


#ifndef FSCFG_DISABLE_GRAYSCALE

/*********************************************************************/

/*  This routine scales up an outline for gray scale scan conversion */

/*********************************************************************/

FS_PUBLIC int32 fsc_OverScaleOutline( 
		ContourList* pclContour,        /* glyph outline */
		uint16 usOverScale              /* over scale factor */
)
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int16 sShift;                       /* for power of two multiply */
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	
	
	switch (usOverScale)                /* look for power of two */
	{
	case 1:
		sShift = 0;
		break;
	case 2:
		sShift = 1;
		break;
	case 4:
		sShift = 2;
		break;
	case 8:
		sShift = 3;
		break;
	default:
		sShift = -1;
		break;
	}

	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
				
		pfxXCoord = &pclContour->afxXCoord[sStart];
		pfxYCoord = &pclContour->afxYCoord[sStart];
			
		if (sShift >= 0)                    /* if power of two */
		{
			for (sPt = sStart; sPt <= sEnd; sPt++)
			{
				*pfxXCoord <<= sShift;
				pfxXCoord++;
				*pfxYCoord <<= sShift;
				pfxYCoord++;
			}
		}
		else                                /* if not a power of two */
		{
			for (sPt = sStart; sPt <= sEnd; sPt++)
			{
				*pfxXCoord *= (int32)usOverScale;
				pfxXCoord++;
				*pfxYCoord *= (int32)usOverScale;
				pfxYCoord++;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Gray scale bitmap calculation                                    */
/*  Count over scale pixels into gray scale byte array               */
/*  Be sure that Hi/LoBand are set correctly for both Over & Gray!   */

/*********************************************************************/

FS_PUBLIC int32 fsc_CalcGrayMap( 
		GlyphBitMap* pOverGBMap,        /* over scaled source */
		GlyphBitMap* pGrayGBMap,        /* gray scale target */
		uint16 usOverScale              /* over scale factor */
)
{
	char        *pchOverRow;            /* over scaled bitmap row pointer */
	char        *pchGrayRow;            /* gray scale bitmap row pointer */

	int16       sVOffset;               /* over scaled rows to skip */
	int16       sRightPix;              /* right edge of used over pix's */
		
	int16       sGrayRow;               /* gray scale row loop counter */
	uint16      usOverRowCount;         /* over scaled row loop counter */
	int16       sTotalRowCount;         /* over scaled whole band counter */
	
	uint32      ulBytes;                /* gray scale count for clear */
	int32       lErrCode;               /* function return code */
	
	GrayScaleParam  GSP;                /* param block for CalcGrayRow */


	Assert ((usOverScale == 1) || (usOverScale == 2) || (usOverScale == 4) || (usOverScale == 8));

	ulBytes = (uint32)pGrayGBMap->sRowBytes * (uint32)(pGrayGBMap->sHiBand - pGrayGBMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);
	fsc_ScanClearBitMap (ulBytes >> 2, (uint32*)pGrayGBMap->pchBitMap);
	
	GSP.usOverScale = usOverScale;
	GSP.pchOverLo = pOverGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchOverHi = pOverGBMap->pchBitMap + pOverGBMap->lMMemSize;
	GSP.pchGrayLo = pGrayGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchGrayHi = pGrayGBMap->pchBitMap + pGrayGBMap->lMMemSize;

	pchOverRow = pOverGBMap->pchBitMap;
	usOverRowCount = usOverScale;
	sTotalRowCount = pOverGBMap->sHiBand - pOverGBMap->sLoBand;
	sVOffset = pOverGBMap->sHiBand - usOverScale * pGrayGBMap->sHiBand;
	if (sVOffset < 0)                                   /* if mapped above over's bitmap */
	{
		usOverRowCount -= (uint16)(-sVOffset);          /* correct first band count */
	}
	else
	{
		pchOverRow += sVOffset * pOverGBMap->sRowBytes; /* point into bitmap */
		sTotalRowCount -= sVOffset;                     /* adjust for skipped rows */
	}
	
	sRightPix = pGrayGBMap->rectBounds.right * (int16)usOverScale - pOverGBMap->rectBounds.left;
	pchOverRow += (sRightPix - 1) >> 3;
	GSP.usFirstShift = (uint16)(7 - ((sRightPix-1) & 0x0007));

	GSP.sGrayCol = pGrayGBMap->rectBounds.right - pGrayGBMap->rectBounds.left;
	pchGrayRow = pGrayGBMap->pchBitMap + (GSP.sGrayCol - 1);

	for (sGrayRow = pGrayGBMap->sHiBand - 1; sGrayRow >= pGrayGBMap->sLoBand; sGrayRow--)
	{
		GSP.pchGray = pchGrayRow;
		while ((usOverRowCount > 0) && (sTotalRowCount > 0))
		{
			GSP.pchOver = pchOverRow;
			lErrCode = fsc_ScanCalcGrayRow( &GSP );
			if (lErrCode != NO_ERR) return lErrCode;
			
			pchOverRow += pOverGBMap->sRowBytes;
			usOverRowCount--;
			sTotalRowCount--;
		}                               
		pchGrayRow += pGrayGBMap->sRowBytes;
		usOverRowCount = usOverScale;
	}
	return NO_ERR;
}

#else                                   /* if grayscale is disabled */

FS_PUBLIC int32 fsc_OverScaleOutline( 
		ContourList* pclContour,        /* glyph outline */
		uint16 usOverScale              /* over scale factor */
)
{
	FS_UNUSED_PARAMETER(pclContour);
	FS_UNUSED_PARAMETER(usOverScale);
	
	return BAD_GRAY_LEVEL_ERR;
}


FS_PUBLIC int32 fsc_CalcGrayMap( 
		GlyphBitMap* pOverGBMap,        /* over scaled source */
		GlyphBitMap* pGrayGBMap,        /* gray scale target */
		uint16 usOverScale              /* over scale factor */
)
{
	FS_UNUSED_PARAMETER(pOverGBMap);
	FS_UNUSED_PARAMETER(pGrayGBMap);
	FS_UNUSED_PARAMETER(usOverScale);
	
	return BAD_GRAY_LEVEL_ERR;
}

#endif

/*********************************************************************/
											 
/*      Local Functions                                              */

/*********************************************************************/

/*********************************************************************/

/*  This routine examines a glyph contour by contour and calculates  */
/*  its bounding box.                                                */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap         /* to return bounds */
)
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int32 lMaxX, lMinX;                 /* for bounding box left, right */
	int32 lMaxY, lMinY;                 /* for bounding box top, bottom */
	
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	F26Dot6 fxMaxX, fxMinX;             /* for bounding box left, right */
	F26Dot6 fxMaxY, fxMinY;             /* for bounding box top, bottom */
	boolean bFirstContour;              /* set false after min/max set */


	fxMaxX = 0L;                        /* default bounds limits */
	fxMinX = 0L;
	fxMaxY = 0L;
	fxMinY = 0L;
	bFirstContour = TRUE;               /* first time only */
	
	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
		if (sStart == sEnd)
		{
			continue;                               /* for anchor points */
		}
		
		pfxXCoord = &pclContour->afxXCoord[sStart];
		pfxYCoord = &pclContour->afxYCoord[sStart];
				
		if (bFirstContour)            
		{
			fxMaxX = *pfxXCoord;                    /* init bounds limits */
			fxMinX = *pfxXCoord;
			fxMaxY = *pfxYCoord;
			fxMinY = *pfxYCoord;
			bFirstContour = FALSE;                  /* just once */
		}

		for (sPt = sStart; sPt <= sEnd; sPt++)      /* find the min & max */
		{
			if (*pfxXCoord > fxMaxX)
				fxMaxX = *pfxXCoord;
			if (*pfxXCoord < fxMinX)
				fxMinX = *pfxXCoord;
					
			if (*pfxYCoord > fxMaxY)
				fxMaxY = *pfxYCoord;
			if (*pfxYCoord < fxMinY)
				fxMinY = *pfxYCoord;

			pfxXCoord++;
			pfxYCoord++;
		}
	}
	
	pbmpBitMap->fxMinX = fxMinX;                    /* save full precision bounds */
	pbmpBitMap->fxMinY = fxMinY;
	pbmpBitMap->fxMaxX = fxMaxX;                    /* save full precision bounds */
	pbmpBitMap->fxMaxY = fxMaxY;

	lMinX = (fxMinX + SUBHALF - 1) >> SUBSHFT;      /* pixel black box */
	lMinY = (fxMinY + SUBHALF - 1) >> SUBSHFT;
	lMaxX = (fxMaxX + SUBHALF) >> SUBSHFT;
	lMaxY = (fxMaxY + SUBHALF) >> SUBSHFT;
			
	if ((F26Dot6)(int16)lMinX != lMinX ||           /* check overflow */
		(F26Dot6)(int16)lMinY != lMinY ||
		(F26Dot6)(int16)lMaxX != lMaxX ||
		(F26Dot6)(int16)lMaxY != lMaxY )
	{
		return POINT_MIGRATION_ERR;
	}

	pbmpBitMap->bZeroDimension = FALSE;             /* assume some size */
	
	if (bFirstContour == FALSE)                     /* if contours present */
	{                                               /* then force a non-zero bitmap */
		if (lMinX == lMaxX)
		{
			lMaxX++;                                /* force 1 pixel wide */
			pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
		}
		if (lMinY == lMaxY)
		{
			lMaxY++;                                /* force 1 pixel high */
			pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
		}
	}
	
/*  set bitmap structure return values */

	pbmpBitMap->rectBounds.left   = (int16)lMinX;
	pbmpBitMap->rectBounds.right  = (int16)lMaxX;
	pbmpBitMap->rectBounds.bottom = (int16)lMinY;
	pbmpBitMap->rectBounds.top    = (int16)lMaxY;

	return NO_ERR;
}

/*********************************************************************/

/* This recursive routine subdivides splines that are non-monotonic or   */
/* too big into splines that fsc_CalcSpline can handle.  It also         */
/* filters out degenerate (linear) splines, passing off to fsc_CalcLine. */


FS_PRIVATE int32 EvaluateSpline( 
		PSTATE                      /* pointer to state vars */
		F26Dot6 fxX1,               /* start point x coordinate */
		F26Dot6 fxY1,               /* start point y coordinate */
		F26Dot6 fxX2,               /* control point x coordinate */
		F26Dot6 fxY2,               /* control point y coordinate */
		F26Dot6 fxX3,               /* ending x coordinate */
		F26Dot6 fxY3,               /* ending y coordinate */
		uint16 usScanKind           /* scan control type */
)
{
	F26Dot6 fxDX21, fxDX32, fxDX31;     /* delta x's */
	F26Dot6 fxDY21, fxDY32, fxDY31;     /* delta y's */
	
	F26Dot6 fxDenom;                    /* ratio denominator  */
	F26Dot6 fxX4, fxY4;                 /* first mid point */
	F26Dot6 fxX5, fxY5;                 /* mid mid point */
	F26Dot6 fxX6, fxY6;                 /* second mid point */
	F26Dot6 fxX456, fxY456;             /* for monotonic subdivision */
	F26Dot6 fxAbsDX, fxAbsDY;           /* abs of DX31, DY31 */
	
	int32 lErrCode;


	fxDX21 = fxX2 - fxX1;                       /* get all four deltas */
	fxDX32 = fxX3 - fxX2;
	fxDY21 = fxY2 - fxY1;
	fxDY32 = fxY3 - fxY2;
  
/*  If spline goes up and down, then subdivide it  */

	if (((fxDY21 > 0L) && (fxDY32 < 0L)) || ((fxDY21 < 0L) && (fxDY32 > 0L)))
	{
		fxDenom = fxDY21 - fxDY32;              /* total y span */
		fxX4 = fxX1 + LongMulDiv(fxDX21, fxDY21, fxDenom);
		fxX6 = fxX2 + LongMulDiv(fxDX32, fxDY21, fxDenom);
		fxX5 = fxX4 + LongMulDiv(fxX6 - fxX4, fxDY21, fxDenom);
		fxY456 = fxY1 + LongMulDiv(fxDY21, fxDY21, fxDenom);
		
		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY456, fxX5, fxY456, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX5, fxY456, fxX6, fxY456, fxX3, fxY3, usScanKind);
	}
	
/*  If spline goes left and right, then subdivide it  */
	
	if (((fxDX21 > 0L) && (fxDX32 < 0L)) || ((fxDX21 < 0L) && (fxDX32 > 0L)))
	{
		fxDenom = fxDX21 - fxDX32;              /* total x span */
		fxY4 = fxY1 + LongMulDiv(fxDY21, fxDX21, fxDenom);
		fxY6 = fxY2 + LongMulDiv(fxDY32, fxDX21, fxDenom);
		fxY5 = fxY4 + LongMulDiv(fxY6 - fxY4, fxDX21, fxDenom);
		fxX456 = fxX1 + LongMulDiv(fxDX21, fxDX21, fxDenom);

		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX456, fxY4, fxX456, fxY5, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX456, fxY5, fxX456, fxY6, fxX3, fxY3, usScanKind);
	}

/*  By now the spline must be monotonic  */

	fxDX31 = fxX3 - fxX1;                       /* check overall size */
	fxDY31 = fxY3 - fxY1;
	fxAbsDX = FXABS(fxDX31);
	fxAbsDY = FXABS(fxDY31);

/*  If spline is too big to calculate, then subdivide it  */

	if ((fxAbsDX > MAXSPLINELENGTH) || (fxAbsDY > MAXSPLINELENGTH))
	{
		fxX4 = (fxX1 + fxX2) >> 1;              /* first segment mid point */
		fxY4 = (fxY1 + fxY2) >> 1;
		fxX6 = (fxX2 + fxX3) >> 1;              /* second segment mid point */
		fxY6 = (fxY2 + fxY3) >> 1;
		fxX5 = (fxX4 + fxX6) >> 1;              /* mid segment mid point */
		fxY5 = (fxY4 + fxY6) >> 1;

		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY4, fxX5, fxY5, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX5, fxY5, fxX6, fxY6, fxX3, fxY3, usScanKind);
	}

/*  The spline is now montonic and small enough  */

	lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);  /* first check endpoint */
	if (lErrCode != NO_ERR)  return lErrCode;

	if (fxDX21 * fxDY32 == fxDY21 * fxDX32)     /* if spline is degenerate (linear) */
	{                                           /* treat as a line */
		return fsc_CalcLine(ASTATE fxX1, fxY1, fxX3, fxY3, usScanKind);
	}
	else        
	{
		return fsc_CalcSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
	}
}


/*********************************************************************/

/*  Return an array of coordinates for outline points */

FS_PUBLIC int32 fsc_GetCoords(
		ContourList* pclContour,        /* glyph outline */
        uint16 usPointCount,            /* point count */
        uint16* pusPointIndex,          /* point indices */
        PixCoord* ppcCoordinate         /* point coordinates */
)
{
    uint16  usMaxIndex;                 /* last defined point */
    int32  lX;                          /* integer x coord */
    int32  lY;                          /* integer y coord */

    if (pclContour->usContourCount == 0)
    {
        return BAD_POINT_INDEX_ERR;     /* can't have a point without a contour */
    }
     
    usMaxIndex = pclContour->asEndPoint[pclContour->usContourCount - 1] + 2;    /* allow 2 phantoms */

    while (usPointCount > 0)
    {
        if (*pusPointIndex > usMaxIndex)
        {
            return BAD_POINT_INDEX_ERR;     /* beyond the last contour */
        }

        lX = (pclContour->afxXCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;
        lY = (pclContour->afxYCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;

        if ( ((int32)(int16)lX != lX) || ((int32)(int16)lY != lY) )
    	{
    		return POINT_MIGRATION_ERR;    /* catch overflow */
    	}

        ppcCoordinate->x = (int16)lX;
        ppcCoordinate->y = (int16)lY;

        pusPointIndex++;
        ppcCoordinate++;
        usPointCount--;                     /* loop through all points */
    }
	return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scbitmap.c ===
/*********************************************************************

      scbitmap.c -- New Scan Converter BitMap Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

      10/03/93  deanb   use (x) in bitmask shift macros
       8/23/93  deanb   gray scale functions
       6/11/93  deanb   use MEMSET macro, string & stddef removed
       6/10/93  deanb   Start/Stop/Bit mask macros
       6/10/93  deanb   InitializeBitMasks added, stdio & assert removed
       4/29/93  deanb   BLTCopy routine added
       3/19/93  deanb   size_t caste checked
      10/14/92  deanb   memset for fsc_ClearBitMap
       9/15/92  deanb   Set bit coded 
       8/18/92  deanb   include scconst.h 
       6/02/92  deanb   Row pointer, integer limits, no descriptor 
       5/08/92  deanb   reordered includes for precompiled headers 
       5/04/92  deanb   Array tags added 
       4/27/92  deanb   Negative runs handled 
       4/16/92  deanb   Coding 
       3/23/92  deanb   First cut 

**********************************************************************/

#define FSCFG_INTERNAL

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/


#include    "fscdefs.h"             /* shared data types */
#include    "scgray.h"              /* gray scale param block */
#include    "fserror.h"             /* error codes */
#include    "scbitmap.h"            /* for own function prototypes */


/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     MASKSIZE    32              /* bits per bitmap masks */
#define     MASKSHIFT   5               /* log2 of MASKSIZE */
#define     MASKBITS    0x0000001FL     /* masks pix loc of long word */

#define     ALL_ONES    ((uint32)0xFFFFFFFFL)
#define     HIGH_ONE    ((uint32)0x80000000L)


/*********************************************************************/

/*      Bitmask definitions                                          */

/*********************************************************************/
    
#ifndef FSCFG_USE_MASK_SHIFT    /* if using bitmask tables */

#define START_MASK(x)   aulStartBits[x]
#define STOP_MASK(x)    aulStopBits[x]
#define BIT_MASK(x)     aulBitMask[x]

/*  bitmask tables */

FS_PRIVATE uint32 aulStartBits[MASKSIZE];       /* such as:  0000111 */
FS_PRIVATE uint32 aulStopBits[MASKSIZE];        /* such as:  1110000 */
FS_PRIVATE uint32 aulBitMask[MASKSIZE];         /* such as:  0001000 */


#else                           /* if using bitmask shift */

#define START_MASK(x)   (ALL_ONES >> (x))
#define STOP_MASK(x)    (ALL_ONES << ((MASKSIZE - 1) - (x)))
#define BIT_MASK(x)     (HIGH_ONE >> (x))

#endif


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*      fsc_InitializeBitMasks() loads the arrays of 32-bit masks at 
 *      runtime to create CPU independent bitmap masks.
 *
 *      It is conditionally compiled because the arrays are unused
 *      in a "USE_MASK_SHIFT" (e.g. Apple, HP) configuration. 
 *
 *      We load the arrays by converting the Big-Endian value of
 *      the mask to the "native" representation of that mask.  The
 *      "native" representation can be applied to a "native" byte
 *      array to manipulate more than 8 bits at a time of an output
 *      bitmap.
 */

FS_PUBLIC void fsc_InitializeBitMasks (void)
{
#ifndef FSCFG_USE_MASK_SHIFT

    int32 lIdx;
    uint32 ulStartMask;
    uint32 ulStopMask;
    uint32 ulBitMask;

    ulStartMask = ALL_ONES;
    ulStopMask = ALL_ONES;
    ulBitMask = HIGH_ONE;
    
    for (lIdx = 0; lIdx < MASKSIZE; lIdx++)
    {
        aulStartBits[lIdx] = (uint32) SWAPL(ulStartMask);
        aulStopBits[MASKSIZE - lIdx - 1] = (uint32) SWAPL(ulStopMask);
        aulBitMask[lIdx] = (uint32) SWAPL(ulBitMask);

        ulStartMask >>= 1;
        ulStopMask <<= 1;
        ulBitMask >>= 1;
    }
#endif
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ClearBitMap (
        uint32 ulBMPLongs, 
        uint32 *pulMap )
{
    size_t stBytes;

    stBytes = (size_t)ulBMPLongs << 2;

    Assert((uint32)stBytes == (ulBMPLongs << 2));

    MEMSET((void*)pulMap, 0, stBytes);
    
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTHoriz (
        int32 lXStart, 
        int32 lXStop, 
        uint32 *pulMap )                 
{
    int32 lSkip;

    lSkip = (lXStart >> MASKSHIFT);         /* longwords to first black */
    pulMap += lSkip;
    lXStart -= lSkip << MASKSHIFT;          /* correct start/stop */
    lXStop -= lSkip << MASKSHIFT;
    while (lXStop >= MASKSIZE)
    {
        *pulMap |= START_MASK(lXStart);
        pulMap++;
        lXStart = 0;
        lXStop -= MASKSIZE;
    }
    *pulMap |= START_MASK(lXStart) & STOP_MASK(lXStop);
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTCopy ( 
        uint32 *pulSource,         /* source row pointer */
        uint32 *pulDestination,    /* destination row pointer */
        int32 lCount )             /* long word counter */
{
    while (lCount)
    {
        *pulDestination = *pulSource;
        pulDestination++;
        pulSource++;
        lCount--;
    }
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC uint32 fsc_GetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    return(pulMap[lXCoord >> MASKSHIFT] & BIT_MASK(lXCoord & MASKBITS));
}


/*********************************************************************/

FS_PUBLIC int32 fsc_SetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    pulMap[lXCoord >> MASKSHIFT] |= BIT_MASK(lXCoord & MASKBITS);
    
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale row bitmap calculation                                */
/*  Count one row of over scale pixels into gray scale row           */

/*********************************************************************/
                
FS_PUBLIC int32 fsc_CalcGrayRow(
        GrayScaleParam* pGSP
)
{            
    char        *pchOver;               /* pointer to overscaled bitmap */
    char        *pchGray;               /* pointer to gray scale bitmap */
    uint16      usShiftMask;            /* masks off over scaled bits of interest */
    uint16      usGoodBits;             /* number of valid bits in usOverBits */
    uint16      usOverBits;             /* a byte of overscaled bitmap */
    int16       sGrayColumns;           /* number of gray columns to calc */
    
    static char chCount[256] = {        /* count of one bits */    
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };


    pchGray = pGSP->pchGray;
    pchOver = pGSP->pchOver;
    sGrayColumns = pGSP->sGrayCol;
    usShiftMask = 0x00FF >> (8 - pGSP->usOverScale);  /* over bits per gray pix */
    usGoodBits = 8 - pGSP->usFirstShift;
    usOverBits = ((uint16)*pchOver) >> pGSP->usFirstShift;
                
    Assert (pchGray >= pGSP->pchGrayLo);
    Assert (pchGray < pGSP->pchGrayHi);
    
    *pchGray += chCount[usOverBits & usShiftMask];
    pchGray--;                              /* move backwards through both bitmaps! */
    sGrayColumns--;

    while (sGrayColumns > 0)                /* for each gray column (after 1st) */
    {
        usGoodBits -= pGSP->usOverScale;
        if (usGoodBits > 0)                 /* if bits remain in over byte */
        {
            usOverBits >>= pGSP->usOverScale;
        }
        else                                /* if we've looked at everything */
        {
            pchOver--;

            Assert (pchOver >= pGSP->pchOverLo);
            Assert (pchOver < pGSP->pchOverHi);

            usOverBits = (uint16)*pchOver;
            usGoodBits = 8;
        }

        Assert (pchGray >= pGSP->pchGrayLo);
        Assert (pchGray < pGSP->pchGrayHi);

        *pchGray += chCount[usOverBits & usShiftMask];  /* accumulate count */
        pchGray--;
        sGrayColumns--;
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scentry.h ===
/*********************************************************************

      scentry.h -- NewScan Module Exports

      (c) Copyright 1992-95  Microsoft Corp.  All rights reserved.

       1/23/95  deanb       added fsc_GetCoords helper function
       9/07/93  deanb       F26Dot6 min/max added to gbmp structure
       8/10/93  deanb       expand interface for gray scale
       6/10/93  deanb       fsc_Initialize added
       4/21/93  deanb       banding params for MeasureGlyph
       3/29/93  deanb       reversal memory added to WorkScan
       3/19/93  deanb       size_t replaced with int32
      12/22/92  deanb       Rectangle -> Rect
      12/21/92  deanb       Interface types aligned with rasterizer
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/05/92  deanb       ulPointCount removed from ContourList
      11/04/92  deanb       RemoveDups function added
      10/14/92  deanb       Exported data structures added
       8/18/92  deanb       Scan type param added 
       8/17/92  deanb       Functions renamed to ..Glyph 
       7/24/92  deanb       Polyline functions deleted 
       4/09/92  deanb       New types 
       3/30/92  deanb       WorkspaceSize renamed MeasureContour 
       3/24/92  deanb       BitMap back to WorkspaceSize 
       3/20/92  deanb       Structs moved to fscdefs.h, params trimmed 
       3/17/92  deanb       Add ulPointCount, rework fcn params 
       3/05/92  deanb       Add data structures 
       3/04/92  deanb       Size reports added 
       2/21/92  deanb       First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/********************************************************************/

/*      Exported Data Structures                                    */

/********************************************************************/

typedef struct
{
    uint16 usContourCount;          /* number of contours */
    int16 *asStartPoint;            /* contour startpoint index array */
    int16 *asEndPoint;              /* contour endpoint index array */
    F26Dot6 *afxXCoord;             /* contour x coordinate array */
    F26Dot6 *afxYCoord;             /* contour y coordinate array */
    uint8 *abyOnCurve;              /* on curve / off curve array */
    uint8 *abyFc;					/* contour flags, one byte for every contour */
}
ContourList;

typedef struct
{
    int16 sRowBytes;                /* bit map width in bytes */
    int16 sHiBand;                  /* upper banding limit */
    int16 sLoBand;                  /* lower banding limit */
    Rect rectBounds;                /* bit map border */
    boolean bZeroDimension;         /* flags zero width or height */
    F26Dot6 fxMinX;                 /* full precision x minimum */
    F26Dot6 fxMaxX;                 /* full precision x maximum */
    F26Dot6 fxMinY;                 /* full precision y minimum */
    F26Dot6 fxMaxY;                 /* full precision y maximum */
    int32 lMMemSize;                /* size of bitmap in bytes */
    char *pchBitMap;                /* pixel bit map */
}
GlyphBitMap;

typedef struct
{
    int32 lRMemSize;                /* workspace bytes for reversal lists */
    int32 lHMemSize;                /* workspace bytes needed for horiz scan */
    int32 lVMemSize;                /* additional workspace for vert scan */
    int32 lHInterCount;             /* estimate of horiz scan intersections */
    int32 lVInterCount;             /* estimate of vert scan intersections */
    int32 lElementCount;            /* estimate of element control points */
    char *pchRBuffer;               /* reversal workspace byte pointer */
    char *pchHBuffer;               /* horiz workspace byte pointer */
    char *pchVBuffer;               /* vert workspace byte pointer */
}
WorkScan;

typedef struct
{
    int16 x;                        /* x pixel value */
    int16 y;                        /* y pixel value */
}
PixCoord;

/*********************************************************************/

/*      Function Exports                                             */

/*********************************************************************

  fsc_Initialize

    This routine calls down to the bitmap module to initialize the
    bitmap masks.  It should be called once, before and scan conversion
    is done.  No harm will be done if it is called more than once.

*/

FS_PUBLIC void fsc_Initialize (
        void
);


/*********************************************************************

  fsc_RemoveDups

    This routine examines a glyph contour by contour and removes any
    duplicated points.  Two subtlties here:  1) following a call to
    this routine, the relation of End[i] + 1 = Start[i + 1] may no
    longer hold (in other words, the contours may not be tightly
    packed);  and 2) two duplicate off curve points will become a
    single ON curve point (this makes sense when you remember that
    between any two offs there must be an on).

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

  Returned Values:
    
    ContourList -   Start, X, Y, and OnCurve arrays may be modified

*/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList*        /* glyph outline */
);

/*********************************************************************

  fsc_OverScaleOutline(&Clist, inputPtr->param.gray.usOverScale);

    This routine scales up an outline for gray scale scan conversion

  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usOverScale     Multiplier

  Returned Values:
    
    ContourList -   X and Y arrays will be multiplied by usOverScale

*/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList*,       /* glyph outline */
        uint16              /* over scale factor */
);

/*********************************************************************

  fsc_MeasureGlyph

    This routine examines a glyph contour by contour and calculates 
    its size and the amount of workspace needed to scan convert it.

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Points to MeasureGlyph workspace used to
                                    store contour reversals.
                    lRMemSize       Size of RBuffer in bytes.  This should be
                                    2 * sizeof(Reversal) * NumberOfPoints to
                                    handle the worst case.
    
    uint16      -   usScanKind      Dropout control code

    uint16      -   usRoundXMin     Allows alignment of XMin for gray scale
                                    XMin modulo usRoundXMin will be zero

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Amount of RBuffer actually used.  This will
                                    typically be much less than the worst case.
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz scan intersections
                    lVInterCount    Estimate of vert scan intersections
                    lElementCount   Estimate of element control points

    GlyphBitMap -   sRowBytes       Bytes per row in bitmap (padded to 0 mod 4).
                    rectBounds      Worst case black bounding box.
                    lMMemSize       Size of bitmap in bytes
*/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra );
    
/*********************************************************************

  fsc_MeasureBand

    This routine calculates the amount of workspace needed to scan 
    convert a glyph using banding.

  Input Values:

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    lHMemSize       Size of horizontal memory from MeasureGlyph
                    lVMemSize       Size of vertical memory from MeasureGlyph
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph
    
    uint16      -   usBandType      FS_BANDINGSMALL or FS_BANDINGFAST
    
    uint16      -   usBandWidth     Number of scan lines of maximum band

    uint16      -   usScanKind      Dropout control code

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Unchanged
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz band intersections
                    lVInterCount    Unchanged
                    lElementCount   Unchanged

    GlyphBitMap -   sRowBytes       Unchanged
                    rectBounds      Unchanged
                    lMMemSize       Size of bitmap in bytes

*/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap*,        /* computed by MeasureGlyph */
        WorkScan*,           /* to return new values */
        uint16,              /* usBandType = small or fast */
        uint16,              /* usBandWidth = scanline count */
        uint16               /* usScanKind = dropout control value */
);


/*********************************************************************

  fsc_FillGlyph

    This routine is responsible for the actual creation of a bitmap
    from the outline.
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    pchHBuffer      Pointer to horizontal workspace memory
                    pchVBuffer      Pointer to vertical workspace memory
                    lHMemSize       Size of horizontal memory (for assertion checks)
                    lVMemSize       Size of vertical memory (for assertion checks)
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph

    GlyphBitMap -   pchBitMap       Pointer to bit map output buffer
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
  
    uint16      -   usBandType      Old, Small, or Fast banding code
    
    uint16      -   usScanKind      Dropout control code

  Returned Values:

    GlyphBitMap -   Bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList*,       /* glyph outline */
        GlyphBitMap*,       /* target */
        WorkScan*,          /* for scan array */
        uint16,             /* banding type */
        uint16              /* scan type */
);

/*********************************************************************

  fsc_CalcGrayMap

    This routine calculates a gray scale bitmap from an overscaled bitmap
    
  Input Values:

    GlyphBitMap1 -  pchBitMap       Pointer to over scaled bit map
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
    
    GlyphBitMap2 -  pchBitMap       Pointer to gray scale bit map output buffer
                    sRowBytes       1 byte per pixel
                    rectBounds      Same value as returned from fsc_MeasureExtrema
    
    uint16       -  usOverScale     Gray scale contour multiplier
  
  Returned Values:

    GlyphBitMap2 -  Gray scale bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap*,       /* over scaled source */
        GlyphBitMap*,       /* gray scale target */
        uint16              /* over scale factor */
);


/*********************************************************************

  fsc_GetCoords

    This routine returns an array of coordinates for outline points
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usPointCount    Number of points to look up

    uint16*     -   pusPointIndex   Array of point indices
  
  Returned Values:

    pxyCoords   -   Array of (x,y) integer (pixel) coordinates

*/

FS_PUBLIC int32 fsc_GetCoords(
        ContourList*,       /* glyph outline */
        uint16,             /* point count */
        uint16*,            /* point indices */
        PixCoord*           /* point coordinates */
);

 /*********************************************************************/

#ifdef FSCFG_SUBPIXEL

/*********************************************************************

  fsc_OverscaleToSubPixel

    This routine is the heart of the RGB striping algorithm
    
  Input Values:

    OverscaledBitmap
  
  Returned Values:

    SubPixelBitMap

*/

FS_PUBLIC void fsc_OverscaleToSubPixel (
    GlyphBitMap * OverscaledBitmap, 
	boolean bgrOrder, 
    GlyphBitMap * SubPixelBitMap
);

 /*********************************************************************/

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scgray.h ===
/*********************************************************************

	  scgray.h -- Gray Scale Parameter Block Definition

	  (c) Copyright 1993  Microsoft Corp.  All rights reserved.

	   8/23/93 deanb    First cut 

**********************************************************************/

#ifndef FSCGRAY_DEFINED
#define FSCGRAY_DEFINED


#include "fscdefs.h"                /* for type definitions */

/*********************************************************************/

/*      Gray scale calculation parameters                            */

/*********************************************************************/

typedef struct
{
	char* pchOver;                  /* pointer to overscaled bitmap */
	char* pchGray;                  /* pointer to gray scale bitmap */
	int16 sGrayCol;                 /* number of gray columns to calc */
	uint16 usOverScale;             /* outline magnification factor */
	uint16 usFirstShift;            /* first byte's shift */
	char* pchOverLo;                /* low limit of overscaled bitmap */
	char* pchOverHi;                /* high limit of overscaled bitmap */
	char* pchGrayLo;                /* low limit of gray scale bitmap */
	char* pchGrayHi;                /* high limit of gray scale bitmap */
}
GrayScaleParam;


/*********************************************************************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scline.h ===
/*********************************************************************

	  scline.h -- Line Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetLineElemSize returns size_t 
	   8/21/92 deanb    GetLineElemSize added 
	   7/23/92 deanb    Back to x2,y2 again 
	   7/17/92 deanb    Changed from longline to line 
	   4/21/92 deanb    Scan lines and on/off added 
	   4/09/92 deanb    New types 
	   4/01/92 deanb    Back to x2,y2 
	   3/20/92 deanb    Reintroduced 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupLine ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* point 1  x coordinate */
		F26Dot6,            /* point 1  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scglobal.h ===
/*********************************************************************

      scglobal.h -- Information shared by all scan converter modules

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       7/09/93 deanb    include fsconfig.h removed (fscdefs does it)
       4/19/93 deanb    banding limits added
       4/12/93 deanb    from old scconst.h + scstate.h

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */

/********************************************************************/

/*      Internal Constant Values                                    */

/********************************************************************/

#define HUGEINT         0x7FFF          /* impossibly large int16 value */
#define HUGEFIX         0x7FFFFFFFL     /* impossibly large fx value */

#define SUBPIX          64L             /* sub pixels per pix */
#define SUBHALF         32L             /* one half of SUBPIX */
#define SUBSHFT         6               /* log base two of SUBPIX */
    
#define ONSCANLINE(y)   ((y) & (SUBPIX - 1L)) == SUBHALF
#define SCANABOVE(y)    ((((y) + SUBHALF) & (-SUBPIX)) + SUBHALF)
#define SCANBELOW(y)    ((((y) - SUBHALF - 1L) & (-SUBPIX)) + SUBHALF)

/*      Math macros      */

#define FXABS(x)  ((x) >= 0L ? (x) : -(x))

/*      Module codes for subpix callbacks   */

#define SC_LINECODE     0
#define SC_SPLINECODE   1
#define SC_ENDPTCODE    2

#define SC_MAXCODES     3               /* number of codes above */
#define SC_CODESHFT     2               /* bits needed to store codes */
#define SC_CODEMASK     0x0003          /* to mask off codes */


/**********************************************************************

    The following structure defines all of the state variables for the 
    scan converter.  This structure is allocated statically for a non-
    reentrant implementation, or as an automatic variable to permit 
    reentrancy.  There are three sets of variables: one for the endpoint 
    module, one for scanlist, and one for memory.  Rules of the game are 
    that each module accesses ONLY its own variables for reading AND 
    writing.  It is possible for one module to read another's variables, 
    BUT IT WOULD BE WRONG.

**********************************************************************/

typedef struct statevar
{

/* endpoint state variables */

    F26Dot6 fxX0, fxY0;             /* point from call before last */
    F26Dot6 fxX1, fxY1;             /* point from previous call */
    F26Dot6 fxX2Save, fxY2Save;     /* for closing the contour */
                 
/* scanlist state variables */

    int32 lBoxLeft;                 /* bounding box xmin */
    int32 lBoxRight;                /* bounding box xmax */
    int32 lBoxTop;                  /* bounding box ymax */
    int32 lBoxBottom;               /* bounding box ymin */
    int32 lRowBytes;                /* bitmap bytes per row */
    int32 lHiScanBand;              /* banding upper scan limit */
    int32 lLoScanBand;              /* banding lower scan limit */
    int32 lHiBitBand;               /* banding upper bitmap limit */
    int32 lLoBitBand;               /* banding lower bitmap limit */
    int32 lLastRowIndex;            /* last row scan line index */
    uint32* pulLastRow;             /* for dropout banding */

    int16 **apsHOnBegin;            /* beginning of on pointers array */
    int16 **apsHOffBegin;           /* beginning of off pointers array */
    int16 **apsHOnEnd;              /* end of on pointers array */
    int16 **apsHOffEnd;             /* end of off pointers array */
    int16 **apsHorizBegin;          /* current pointer array */
    int16 **apsHorizEnd;            /* current pointer array */

    int16 **apsVOnBegin;            /* beginning of on pointers array */
    int16 **apsVOffBegin;           /* beginning of off pointers array */
    int16 **apsVOnEnd;              /* end of on pointers array */
    int16 **apsVOffEnd;             /* end of off pointers array */
    int16 **apsVertBegin;           /* current pointer array */
    int16 **apsVertEnd;             /* current pointer array */
              
#ifdef FSCFG_REENTRANT              /* needed to avoid circular PSTATE */
    void (*pfnAddHoriz)(struct statevar*, int32, int32);
    void (*pfnAddVert)(struct statevar*, int32, int32);
#else
    void (*pfnAddHoriz)(int32, int32);
    void (*pfnAddVert)(int32, int32);
#endif

    F26Dot6 (*pfnHCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
    F26Dot6 (*pfnVCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
        
    F26Dot6 *afxXPoints;            /* x element control points */
    F26Dot6 *afxYPoints;            /* y element control points */
    int32 lElementPoints;           /* estimate of element points */
    int32 lPoint;                   /* index to element control points */
    uint16 usScanTag;               /* stores point index, element code */
    int16 sIxSize;                  /* int16's per intersection */
    int16 sIxShift;                 /* log2 of size */

/* memory state variables */

    char *pchHNextAvailable;        /* horizontal memory pointer */
    char *pchVNextAvailable;        /* vertical memory pointer */
    char *pchHWorkSpaceEnd;         /* horizontal memory overflow */
    char *pchVWorkSpaceEnd;         /* vertical memory overflow */
}
StateVars;

/********************************************************************/

/*              Reentrancy parameters                               */

/********************************************************************/

#ifdef FSCFG_REENTRANT

#define PSTATE      StateVars *pState,
#define PSTATE0     StateVars *pState
#define ASTATE      pState,
#define ASTATE0     pState
#define STATE       (*pState)

#else 

#define PSTATE
#define PSTATE0     void
#define ASTATE
#define ASTATE0
#define STATE       State

extern  StateVars   State;              /* statically alloc'd in NewScan */

#endif 

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scmemory.h ===
/*********************************************************************

      scmemory.h -- Memory Module Exports

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       3/19/93 deanb    size_t replaced with int32
      10/14/92 deanb    New SetupMem parameters
      10/09/92 deanb    PSTP added
      10/08/92 deanb    Horiz/Vert memory alloc's
       9/09/92 deanb    Alloc param int32  
       9/08/92 deanb    Setup with WorkSpace pointer 
       8/21/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE              /* pointer to state variables */
        char*,              /* pointer to horiz workspace */
        int32 ,             /* size of horiz workspace */
        char*,              /* pointer to vert workspace */
        int32               /* size of vert workspace */
);

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from horiz memory pool */
);

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from vert memory pool */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scspline.c ===
/*********************************************************************

      scspline.c -- New Scan Converter Spline Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
       3/19/93  deanb   size_t replaced with int32
      10/28/92  deanb   memory requirements reworked
      10/09/92  deanb   reentrant
       9/28/92  deanb   quick out for nearly vert/horiz splines 
       9/25/92  deanb   branch on scan kind 
       9/22/92  deanb   subpix calculation using subdivision 
       9/14/92  deanb   reflection correction with iX/YOffset 
       9/10/92  deanb   first dropout code 
       9/02/92  deanb   Precision reduction by shifting control points 
       7/24/92  deanb   Initial Q set for perfect symmetry 
       7/23/92  deanb   EvaluateSpline split out and moved to NewScan 
       7/20/92  deanb   removed unreachable case 
       7/16/92  deanb   faster power of 2 
       7/06/92  deanb   Cleanups 
       7/01/92  deanb   Reinstate a single spline routine 
       6/30/92  deanb   Implicit spline rendering 
       3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for power of 2 calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* for direct horizscan add call */
#include    "scspline.h"            /* for own function prototypes */
                
/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     QMAXSHIFT      7            /* shift limit q precision */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/
 
FS_PRIVATE F26Dot6 CalcHorizSpSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertSpSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
    
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupSpline (PSTATE0) 
{
    fsc_SetupCallBacks(ASTATE SC_SPLINECODE, CalcHorizSpSubpix, CalcVertSpSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcSpline( 
        PSTATE                  /* pointer to state variables */
        F26Dot6 fxX1,           /* start point x coordinate */
        F26Dot6 fxY1,           /* start point y coordinate */
        F26Dot6 fxX2,           /* control point x coordinate */
        F26Dot6 fxY2,           /* control point y coordinate */
        F26Dot6 fxX3,           /* ending x coordinate */
        F26Dot6 fxY3,           /* ending y coordinate */
        uint16 usScanKind )     /* dropout control type */
{
    F26Dot6 fxXInit, fxYInit;           /* initial step values */
    F26Dot6 fxXScan, fxYScan;           /* set to first crossings */
    F26Dot6 fxXX2, fxYY2;               /* translated reflected control point */
    F26Dot6 fxXX3, fxYY3;               /* translated reflected end point */
    
    F26Dot6 afxXControl[2];             /* params for BeginElement call */
    F26Dot6 afxYControl[2];

    void (*pfnAddHorizScan)(PSTATE int32, int32);
    void (*pfnAddVertScan)(PSTATE int32, int32);
    
    int32 lABits;                       /* 1+int(log2(alpha)) */
    int32 lXYBits;                      /* 1+int(log2(max(x3,y3))) */
    int32 lZBits;                       /* 6, 5, 4 log2(subpixels per pix) */
    int32 lZShift;                      /* 0, 1, 2 shift to minipixel */
    F26Dot6 fxZRound;                   /* rounding factor for minipix shift */
    F26Dot6 fxZSubpix;                  /* 64, 32, 16 subpixels per pix */
    int32 lQuadrant;                    /* 1, 2, 3, or 4 */

    F26Dot6 fxAx, fxAy;                 /* parametric 2nd order terms */
    F26Dot6 lAlpha;                     /* cross product measures curvature */

    int32 lR, lT;                       /* quadratic coefficients for xx, yy */
    int32 lS2, lU2, lV2;                /* half coefficients for xy, x, y */
    int32 lRz, lSz, lTz;                /* coeff's times subpix size */
        
    int32 lQ;                           /* cross product value */
    int32 lDQx, lDQy;                   /* first order derivative */
    int32 lDDQx, lDDQy;                 /* second order derivative */

    int32 lYScan;                       /* scan line counter */
    int32 lYStop;                       /* scan line end */
    int32 lYIncr;                       /* scan line direction */
    int32 lYOffset;                     /* reflection correction */
    int32 lXScan;                       /* horiz pix position */
    int32 lXStop;                       /* pix end */
    int32 lXIncr;                       /* pix increment direction */
    int32 lXOffset;                     /* reflection correction */

    static const int32 lZShiftTable[] = { /* for precision adjustment */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /*  0 -  9  */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 10 - 19 */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 20 - 29 */
        1, 1, 1, 2, 2, 2, 3, 3          /* 30 - 34 */
    };


/* printf("(%li, %li) - (%li, %li) -(%li, %li)\n", fxX1, fxY1, fxX2, fxY2, fxX3, fxY3 ); */


/*  Translate spline point 1 to (0,0) and reflect into the first quadrant  */
    
    if (fxY3 > fxY1)                            /* if going up */
    {
        lQ = 0L;
        lQuadrant = 1;

        fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
        fxYInit = fxYScan - fxY1;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANBELOW(fxY3)) >> SUBSHFT) + 1;
        lYIncr = 1;        
        lYOffset = 0;                           /* no reflection */
        fxYY2 = fxY2 - fxY1;                    /* translate */
        fxYY3 = fxY3 - fxY1;
    }
    else                                        /* if going down */
    {
        lQ = 1L;                                /* to include pixel centers */
        lQuadrant = 4;
        
        fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
        fxYInit = fxY1 - fxYScan;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANABOVE(fxY3)) >> SUBSHFT) - 1;
        lYIncr = -1;        
        lYOffset = 1;                           /* reflection correction */
        fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
        fxYY3 = fxY1 - fxY3;
    }
    
    if (fxX3 > fxX1)                            /* if going right */
    {
        fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
        fxXInit = fxXScan - fxX1;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANBELOW(fxX3)) >> SUBSHFT) + 1;
        lXIncr = 1;        
        lXOffset = 0;                           /* no reflection */
        fxXX2 = fxX2 - fxX1;                    /* translate */
        fxXX3 = fxX3 - fxX1;
    }
    else                                        /* if going left or straight */
    {
        lQ = 1L - lQ;                           /* to include pixel centers */
        lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

        fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
        fxXInit = fxX1 - fxXScan;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANABOVE(fxX3)) >> SUBSHFT) - 1;
        lXIncr = -1;        
        lXOffset = 1;                           /* reflection correction */
        fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
        fxXX3 = fxX1 - fxX3;
    }

/*-------------------------------------------------------------------*/
    
    afxXControl[0] = fxX2;
    afxYControl[0] = fxY2;
    afxXControl[1] = fxX3;
    afxYControl[1] = fxY3;

    fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_SPLINECODE,  /* where and what */
                      2, afxXControl, afxYControl,                  /* number of pts */
                      &pfnAddHorizScan, &pfnAddVertScan );          /* what to call */

/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        if (lYScan == lYStop)                   /* and if no scan crossings */
        {
            return NO_ERR;                      /* then quick exit */
        }
        
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }
    }
        
/*-------------------------------------------------------------------*/

    else                                        /* if smart dropout control on */
    {
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }

        if (lYScan == lYStop)                   /* if nearly horizontal */
        {
            lYScan += lYOffset;
            while (lXScan != lXStop)
            {
                pfnAddVertScan(ASTATE lXScan, lYScan);
                lXScan += lXIncr;               /* advance x scan + or - */
            }        
            return NO_ERR;                      /* quick out */
        }
    }

/*-------------------------------------------------------------------*/

/*  Now calculate parametric term precision      */

    Assert(fxXX3 <= MAXSPLINELENGTH);
    Assert(fxYY3 <= MAXSPLINELENGTH);

    lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;      /* curvature term */
    
    lABits = PowerOf2(lAlpha);
    lXYBits = fxXX3 > fxYY3 ? PowerOf2((int32)fxXX3) : PowerOf2((int32)fxYY3);
    
    Assert(lXYBits <= 12);                      /* max allowed spline bits */
    Assert(lABits <= 25);

    lZShift = lZShiftTable[lABits + lXYBits];   /* look up precision fix */
    lZBits = SUBSHFT - lZShift;

    if (lZShift > 0)                            /* if precision fix is needed */
    {
        fxZRound = 1L << (lZShift - 1);
        
        fxXX2 = (fxXX2 + fxZRound) >> lZShift;  /* shift to 32 or 16 subpix grid */
        fxXX3 = (fxXX3 + fxZRound) >> lZShift;
        fxYY2 = (fxYY2 + fxZRound) >> lZShift;
        fxYY3 = (fxYY3 + fxZRound) >> lZShift;
        
        fxXInit = (fxXInit + fxZRound) >> lZShift;
        fxYInit = (fxYInit + fxZRound) >> lZShift;

        lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;  /* recompute curvature */
    }

    Assert (FXABS(lAlpha * fxXX3) < (1L << 29) + (3L << 24));
    Assert (FXABS(lAlpha * fxYY3) < (1L << 29) + (3L << 24));

/*  Calculate terms for Q = Rxx + Sxy + Tyy + Ux + Vy  */

    fxAx = fxXX3 - (fxXX2 << 1);
    fxAy = fxYY3 - (fxYY2 << 1);

    lR = fxAy * fxAy;
    lS2 = -fxAx * fxAy;
    lT = fxAx * fxAx;
    lU2 = fxYY2 * lAlpha;
    lV2 = -fxXX2 * lAlpha;

/*  
    Calculate starting forward difference terms:

    lQ = Q(x,y) = Rxx + Sxy + Tyy + Ux + Vy
    lDQx = Q(x+z, y) - Q(x, y) = R(2xz + zz) + Syz + Uz
    lDQy = Q(x, y+z) - Q(x, y) = T(2yz + zz) + Sxz + Vz 

*/
    fxZSubpix = 1L << lZBits;                   /* adjusted subpix per pix */

    if (lXYBits <= QMAXSHIFT)                   /* if small enough use full Q */
    {
        lQ += (lR * fxXInit + (lS2 << 1) * fxYInit + (lU2 << 1)) * fxXInit + 
              (lT * fxYInit + (lV2 << 1)) * fxYInit;
        lDQx = (lR * ((fxXInit << 1) + fxZSubpix) + (lS2 << 1) * fxYInit + (lU2 << 1)) << lZBits;
        lDQy = (lT * ((fxYInit << 1) + fxZSubpix) + (lS2 << 1) * fxXInit + (lV2 << 1)) << lZBits;
        
        lRz = lR << (lZBits << 1);              /* needed in the loop */
        lSz = (lS2 << 1) << (lZBits << 1);
        lTz = lT << (lZBits << 1);
    }
    else                                        /* if too big take out a 2 * Z */
    {
        lQ += (((lR >> 1) * fxXInit + lS2 * fxYInit + lU2) >> lZBits) * fxXInit + 
              (((lT >> 1) * fxYInit + lV2) >> lZBits) * fxYInit;
        
        lDQx = lR * (fxXInit + (fxZSubpix >> 1)) + lS2 * fxYInit + lU2;
        lDQy = lT * (fxYInit + (fxZSubpix >> 1)) + lS2 * fxXInit + lV2;
        
        lRz = lR << (lZBits - 1);               /* needed in the loop */
        lSz = lS2 << lZBits;
        lTz = lT << (lZBits - 1);
    }
    lDDQx = lRz << 1;                           /* 2nd derivative terms */
    lDDQy = lTz << 1;
                
/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        lXScan += lXOffset;                     /* pre increment */
        lXStop += lXOffset;                     /* limit too */

/*  Branch to appropriate inner loop  */

        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if past bounding box, finish up */

        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }        

/*-------------------------------------------------------------------*/

    else                                        /* if dropout control on */
    {
        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if outside the bounding box, finish up */

        while (lXScan != lXStop)
        {
            pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
            lXScan += lXIncr;                   /* advance x scan + or - */
        }        
        
        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }

/*-------------------------------------------------------------------*/

    return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions      */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizSpSubpix(
    int32 lYScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxYDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/

    fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+2))) ||
           ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+2))));

    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);
    
    if (*pfxY < *(pfxY+2))                      /* if spline goes up */
    {
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes down */
    {
        fxX1 = *(pfxX+2);                       /* flip it upside down */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do                                          /* midpoint subdivision */
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxYMid > fxYDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide down */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxYMid < fxYDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide up */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxYMid != fxYDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */

    return fxXMid;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertSpSubpix(
    int32 lXScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxXDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/
    
    fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+2))) ||
           ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+2))));
    
    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);

    if (*pfxX < *(pfxX+2))                      /* if spline goes right */
    {                                                                  
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes left */
    {                                                                  
        fxX1 = *(pfxX+2);                       /* flip it around */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxXMid > fxXDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide left */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxXMid < fxXDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide right */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxXMid != fxXDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */
    
    return fxYMid;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scline.c ===
/*********************************************************************

	  scline.c -- New Scan Converter Line Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   MultDivide replaced with LongMulDiv
	  10/28/92  deanb   mem requirement reworked
	  10/13/92  deanb   horiz / vert line rework
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/21/92  deanb   rework horiz & vert lines 
	   9/14/92  deanb   reflection correction with iX/YOffset 
	   9/10/92  deanb   first dropout code 
	   9/08/92  deanb   quickstep deleted 
	   8/18/92  deanb   include struc.h, scconst.h 
	   7/23/92  deanb   Back to x1,y1,x2,y2 input params 
	   7/17/92  deanb   Changed from longline to line 
	   6/18/92  deanb   Cross product line rendering  
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for subpix calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scline.h"              /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
	
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupLine (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_LINECODE, CalcHorizLineSubpix, CalcVertLineSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE                /* pointer to state variables */
		F26Dot6 fxX1,         /* point 1  x coordinate */
		F26Dot6 fxY1,         /* point 1  y coordinate */
		F26Dot6 fxX2,         /* point 2  x coordinate */
		F26Dot6 fxY2,         /* point 2  y coordinate */
		uint16 usScanKind     /* dropout control type */
)
{
	int32 lXScan;                           /* current x pixel index */
	int32 lXSteps;                          /* vert scanline index count */
	int32 lXIncr;                           /* x pixel increment */
	int32 lXOffset;                         /* reflection correction */
	
	int32 lYScan;                           /* current scanline index */
	int32 lYSteps;                          /* horiz scanline index count */
	int32 lYIncr;                           /* y pixel increment */
	int32 lYOffset;                         /* reflection correction */

	F26Dot6 fxXInit, fxYInit;               /* sub steps to first pixel */
	F26Dot6 fxXScan, fxYScan;               /* x,y pixel center coords */
	F26Dot6 fxXX2, fxYY2;                   /* absolute value of DX, DY */
	F26Dot6 fxXTemp, fxYTemp;               /* for horiz/vert line calc */
	
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	int32 lQuadrant;                        /* 1, 2, 3, or 4 */
	int32 lQ;                               /* cross product */
	int32 lDQy, lDQx;                       /* cross product increments */
	int32 i;                                /* loop counter */


/* printf("(%li, %li) - (%li, %li)\n", fxX1, fxY1, fxX2, fxY2); */
	
/*  check y coordinates  */

	if (fxY2 >= fxY1)                           /* if going up or flat */
	{
		lQuadrant = 1;
		lQ = 0L;
		
		fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
		fxYInit = fxYScan - fxY1;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = (int32)((SCANBELOW(fxY2)) >> SUBSHFT) - lYScan + 1;
		lYIncr = 1;        
		lYOffset = 0;                           /* no reflection */
		fxYY2 = fxY2 - fxY1;                    /* translate */
	}
	else                                        /* if going down */
	{
		lQuadrant = 4;
		lQ = 1L;                                /* to include pixel centers */
		
		fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
		fxYInit = fxY1 - fxYScan;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = lYScan - (int32)((SCANABOVE(fxY2)) >> SUBSHFT) + 1;
		lYIncr = -1;        
		lYOffset = 1;                           /* reflection correction */
		fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
	}
	
	if (fxY2 == fxY1)                           /* if horizontal line */
	{
		if (usScanKind & SK_NODROPOUT)          /* if no dropout control */
		{
			return NO_ERR;                      /* if only horiz scan, done */
		}
		if (fxX2 < fxX1)                        /* if going left  */
		{
			fxYTemp = fxY1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going right */
		{
			fxYTemp = fxY1;          
		}
		lYScan = (int32)(SCANABOVE(fxYTemp) >> SUBSHFT);
		lYSteps = 0;
	}

/*  check x coordinates  */
	
	if (fxX2 >= fxX1)                           /* if going right or vertical */
	{
		fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
		fxXInit = fxXScan - fxX1;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = (int32)((SCANBELOW(fxX2)) >> SUBSHFT) - lXScan + 1;
		lXIncr = 1;        
		lXOffset = 0;                           /* no reflection */
		fxXX2 = fxX2 - fxX1;                    /* translate */
	}
	else                                        /* if going left */
	{
		lQ = 1L - lQ;                           /* reverse it */
		lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

		fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
		fxXInit = fxX1 - fxXScan;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = lXScan - (int32)((SCANABOVE(fxX2)) >> SUBSHFT) + 1;
		lXIncr = -1;        
		lXOffset = 1;                           /* reflection correction */
		fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
	}
	
	if (fxX2 == fxX1)                           /* if vertical line       */
	{
		if (fxY2 > fxY1)                        /* if going up  */
		{
			fxXTemp = fxX1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going down */
		{
			fxXTemp = fxX1;          
		}
		lXScan = (int32)(SCANABOVE(fxXTemp) >> SUBSHFT);
		lXSteps = 0;
	}

/*-------------------------------------------------------------------*/
	
	fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_LINECODE, /* where and what */
					  1, &fxX2, &fxY2,                           /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );       /* what to call */

/*-------------------------------------------------------------------*/

	if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
	{
		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		lXScan += lXOffset;

		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
/*-------------------------------------------------------------------*/
	
	else  /* if dropout control */
	{                                           /* handle special case lines  */
		if (fxY1 == fxY2)                       /* if horizontal line */
		{
			for (i = 0; i < lXSteps; i++)       /*   then blast a row   */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan);
				lXScan += lXIncr;               /* advance x scan + or - */
			}
			return NO_ERR;
		}

		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32 lYScan, 
									   F26Dot6 *pfxX, 
									   F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+1))) ||
		   ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+1))));

	fxXDrop = *pfxX + LongMulDiv(*(pfxX+1) - *pfxX, fxYDrop - *pfxY, *(pfxY+1) - *pfxY);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxXDrop;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32 lXScan, 
									  F26Dot6 *pfxX, 
									  F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+1))) ||
		   ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+1))));

	fxYDrop = *pfxY + LongMulDiv(*(pfxY+1) - *pfxY, fxXDrop - *pfxX, *(pfxX+1) - *pfxX);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxYDrop;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scmemory.c ===
/*********************************************************************

      scmemory.c -- New Scan Converter Memory Managment Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
      10/28/92  deanb   reentrant params renamed
      10/14/92  deanb   New fsc_SetupMem parameters
      10/09/92  deanb   Reentrant
      10/08/92  deanb   Separate Horiz/Vert memory pools
       9/10/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "scglobal.h"            /* structures & constants */
#include    "scmemory.h"            /* for own function prototypes */


/**********************************************************************

    Workspace memory is divided into two pools, identified here as
    HMem (horizontal memory) and VMem (vertical memory).  HMem is
    always used, and contains horizontal scan array lists.  VMem is 
    used only when dropout control is enabled, and contains the 
    vertical scan array lists and the contour elements used to compute 
    subpixel intersections for smart dropout control.  This division 
    into two pools was done, in part, for backward compatiblity with 
    the Apple rasterizer.  It allows a client to force dropout control
    off by setting the allocated size of VMem to zero.

**********************************************************************/
    
/*********************************************************************/

/*      Export Functions      */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE                           /* pointer to state variables */
        char* pchHBuffer,                /* pointer to horiz workspace */
        int32 lHMemSize,                 /* size of horiz workspace */
        char* pchVBuffer,                /* pointer to vert workspace */
        int32 lVMemSize )                /* size of vert workspace */
{
    STATE.pchHNextAvailable = pchHBuffer;
    STATE.pchHWorkSpaceEnd = pchHBuffer + lHMemSize;
    
    STATE.pchVNextAvailable = pchVBuffer;
    STATE.pchVWorkSpaceEnd = pchVBuffer + lVMemSize;
}


/********************************************************************/

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE                         /* pointer to state variables  */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;
    
/* printf("H: %ui   ", lSize); */

    pvTemp = (void*)STATE.pchHNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchHNextAvailable += lSize;
    
    Assert(STATE.pchHNextAvailable <= STATE.pchHWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE                         /* pointer to state variables */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;

/* printf("V: %ui   ", lSize); */
    
    pvTemp = (void*)STATE.pchVNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchVNextAvailable += lSize;
    
    Assert(STATE.pchVNextAvailable <= STATE.pchVWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\sfntaccs.h ===
/*
	File:       private sfnt.h

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
		<3+>     7/17/90    MR      Change return types to in for computemapping and readsfnt
		 <3>     7/14/90    MR      changed SQRT to conditional FIXEDSQRT2
		 <2>     7/13/90    MR      Change parameters to ReadSFNT and ComputeMapping
		<1+>     4/18/90    CL      
		 <1>     3/21/90    EMT     First checked in with Mike Reed's blessing.

	To Do:
*/

#include    "sfnt.h"

/* EXPORTED DATA TYPES */

typedef struct {
  uint32    ulOffset;
  uint32    ulLength;
} sfac_OffsetLength;

typedef struct sfac_ClientRec *sfac_ClientRecPtr;

typedef uint16 (*MappingFunc) (const uint8 *, uint16 , sfac_ClientRecPtr);

typedef struct sfac_ClientRec {
	ClientIDType        lClientID;          /* User ID Number                           */
	GetSFNTFunc         GetSfntFragmentPtr; /* User function to eat sfnt                */
	ReleaseSFNTFunc     ReleaseSfntFrag;    /* User function to relase sfnt             */
	int16               sIndexToLocFormat;  /* Format of loca table                     */
	uint32              ulMapOffset;        /* Offset to platform mapping data          */
	sfac_OffsetLength   TableDirectory[sfnt_NUMTABLEINDEX]; /* Table offsets/lengths    */
	uint16              usNumberOf_LongHorMetrics; /* Number of entries in hmtx table   */
	uint16              usNumLongVertMetrics;      /* number of entries with AH         */
	boolean				bValidNumLongVertMetrics; /* true if 'vhea' table exist         */
    uint16              usMappingFormat;    /* format code (0,2,4,6) for mapping func   */
	MappingFunc			GlyphMappingF;		/* mapping function char to glyph			*/
	uint16              usGlyphIndex;       /* Current glyph index                      */
	uint16				usFormat4SearchRange; /* Format 4 cached SearchRange			*/
	uint16				usFormat4EntrySelector; /* Format 4 cached EntrySelector		*/
	uint16				usFormat4RangeShift;/* Format 4 cached Range Shift				*/
	/* value for sDefaultAscender and sDefaultDescender comes from TypoAscender and     */
	/* TypoDescender from 'OS/2', if the 'OS/2' is missing, alternate values comes from */
	/* the horizontal header Ascender and Descender                                     */
	int16				sDefaultAscender;
	int16				sDefaultDescender;
	int16				sWinDescender;
} sfac_ClientRec;


/* It would be great if we could make this an opaque data type
// But in this case, the ownership of the memory for the data is the
// responsibility of the owner module. (i.e. sfntaccs.c) This adds
// complications to our model (read: it is much easier to allocate the
// data off the stack of the caller) so we won't implement this for now.
*/

/*  Glyph Handle -- Used for access to glyph data in 'glyf' table   */

typedef struct {
	 const void *     pvGlyphBaseAddress; /* Base address of glyph, needed for Release */
	 const void *     pvGlyphNextAddress; /* Current position in glyph                    */
	 const void *     pvGlyphEndAddress; /* End address of glyph, used to catch glyph corruption */
} sfac_GHandle;

/*  ComponentTypes -- Method used for positioning component in composite    */

typedef enum {
	AnchorPoints,
	OffsetPoints,
	Undefined
} sfac_ComponentTypes;

/* MACROS */

#define SFAC_LENGTH(ClientInfo,Table)  ClientInfo->TableDirectory[(int)Table].ulLength

/* PUBLIC PROTOTYPE CALLS */

/*
 * Creates mapping for finding offset table
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *    ClientInfo);    /* Sfnt Client information  */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information      */
	uint16              usPlatformID,   /* Platform Id used for mapping */
	uint16              usSpecificID);  /* Specific Id used for mapping */

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16              usCharacterCode);   /* Character code to be mapped  */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,    /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	 sfac_ClientRec *   ClientInfo,      /* Sfnt Client information     */
	 uint16 *               pusEmResolution,/* Sfnt Em Resolution               */
	 boolean *              pbIntegerScaling,/* Sfnt flag for int scaling   */
	 LocalMaxProfile *  pMaxProfile);    /* Sfnt Max Profile table      */

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	int16 *             psNonScaledLSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information           */
	uint16 *            pusNumLongVertMetrics, /* Entries for which AH exists */
	boolean *           pbValidNumLongVertMetrics ); /* true if 'vhea' table exist  */

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client Information  */
	char *              pFontProgram,   /* pointer to Font Program  */
	char *              pPreProgram);   /* pointer to Pre Program   */

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,     /* Client Information       */
	F26Dot6 *           pCVT);          /* pointer to CVT           */

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           bFound,         /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	sfac_GHandle *      hGlyph,             /* Return glyph handle          */
	boolean *           pbCompositeGlyph,   /* Is glyph a composite?        */
	boolean *           pbHasOutline,       /* Does glyph have outlines?    */
	int16 *             psNumberOfContours, /* Number of contours in glyph  */
	BBOX *              pbbox);             /* Glyph Bounding box           */

FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	 uint8 *                abyOnCurve,           /* Array of on curve indicators per point  */
	 F26Dot6 *              afxOoy,               /* Array of ooy points for every point         */
	 F26Dot6 *              afxOox,               /* Array of oox points for every point         */
	 sfac_GHandle *     hGlyph,
	 LocalMaxProfile *  maxProfile,       /* MaxProfile Table                                */
	 boolean                bHasOutline,          /* Does glyph have outlines?                   */
	 int16                  sNumberOfContours,  /* Number of contours in glyph               */
	 int16 *                asStartPoints,    /* Array of start points for every contour  */
	 int16 *                asEndPoints,          /* Array of end points for every contour   */
	 uint16 *               pusSizeOfInstructions, /* Size of instructions in bytes          */
	 uint8 **               pbyInstructions,   /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours);    /* total number of contours for composites, to check for overflow */

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets    */
	boolean *               pbRoundXYToGrid,    /* Round composite offsets to grid              */
	boolean *               pbUseMyMetrics,     /* Use component metrics                        */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions                 */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component                 */
	int16 *                 psXOffset,          /* X Offset of component (if app)               */
	int16 *                 psYOffset,          /* Y Offset of component (if app)               */
	uint16 *                pusAnchorPoint1,    /* Anchor point 1 of component (if app)         */
	uint16 *                pusAnchorPoint2,    /* Anchor point 2 of component (if app)         */
	transMatrix             *pMulT,             /* Transformation matrix for component          */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent);   /* Is this the last component?                  */

/*  sfac_ReadCompositeInstructions

	Returns pointer to TrueType instructions for composites.

 */

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle *  hGlyph,
	uint8 **        pbyInstructions,    /* Pointer to start of glyph instructions   */
	uint16 *        pusSizeOfInstructions); /* Size of instructions in bytes        */


/*  sfac_ReleaseGlyph

	Called when access to glyph in 'glyf' table is finished.

 */

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *    ClientInfo, /* Sfnt Client Information  */
	sfac_GHandle *      hGlyph);    /* Glyph Handle Information */


/**********************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

#ifndef FSCFG_DISABLE_GRAYSCALE
#define SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#else

#define SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#endif


/*      SFNTACCS Export Prototypes for SBIT      */

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset 
);

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength
);

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound /* NEW */
);

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY /* NEW */
);

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount
);

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
);


/**********************************************************************/

/*  Results of search for strike's bitmapSizeSubtable   */

#define     SBIT_UN_SEARCHED    0
#define     SBIT_NOT_FOUND      1
#define     SBIT_BLOC_FOUND     2
#define     SBIT_BSCA_FOUND     3

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\sfntaccs.c ===
/*
	File:       sfnt.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
	   <17+>     10/9/90    MR,rb   Remove classification of unused tables in sfnt_Classify
		<17>     8/10/90    MR      Pass nil for textLength parameter to MapString2, checked in
									other files to their precious little system will BUILD.  Talk
									about touchy!
		<16>     8/10/90    gbm     rolling out Mike's textLength change, because he hasn't checked
									in all the relevant files, and the build is BROKEN!
		<15>     8/10/90    MR      Add textLength arg to MapString2
		<14>     7/26/90    MR      don't include toolutil.h
		<13>     7/23/90    MR      Change computeindex routines to call functins in MapString.c
		<12>     7/18/90    MR      Add SWAPW macro for INTEL
		<11>     7/13/90    MR      Lots of Ansi-C stuff, change behavior of ComputeMapping to take
									platform and script
		 <9>     6/27/90    MR      Changes for modified format 4: range is now times two, loose pad
									word between first two arrays.  Eric Mader
		 <8>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vector mapping functions
		 <6>      6/4/90    MR      Remove MVT
		 <5>      5/3/90    RB      simplified decryption.
		 <4>     4/10/90    CL      Fixed mapping table routines for double byte codes.
		 <3>     3/20/90    CL      Joe found bug in mappingtable format 6 Added vector mapping
									functions use pointer-loops in sfnt_UnfoldCurve, changed z from
									int32 to int16
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)  New
									CharToIndexMap Table format.
									Assume subtablenumber zero for old sfnt format.  Fixed
									transformed component bug.
	   <3.2>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Glyph-length 0
									bug in sfnt.c is fixed. Now it is legal to pass in zero as the
									address of memory when a piece of the sfnt is requested by the
									scaler. If this happens the scaler will simply exit with an
									error code ! Fixed bug with instructions in components.
	   <3.1>     9/27/89    CEL     Removed phantom points.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
		<3+>     3/20/90    mrr     Fixed mapping table routines for double byte codes.
									Added support for font program.
									Changed count from uint16 to int16 in vector char2index routines.
*/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/

#include "fserror.h"
#include "fscdefs.h"
#include "sfntaccs.h"
#include "sfntoff.h"
/*#include "MapString.h" */

#include "stat.h"                   /* STAT timing card prototypes */

/*  CONSTANTS   */

#define MISSING_GLYPH_INDEX     0
#define MAX_FORMAT0_CHAR_INDEX  256
#define MAX_LINEAR_X2           16
static  const   transMatrix   IdentTransform =
   {{{ONEFIX,      0,      0},
	 {     0, ONEFIX,      0},
	 {     0,      0, ONEFIX}}};

/*  MACROS  */
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define GETSFNTFRAG(ClientInfo,lOffset,lLength) (ClientInfo)->GetSfntFragmentPtr(ClientInfo->lClientID, lOffset, lLength)
#define RELEASESFNTFRAG(ClientInfo,data)        (ClientInfo)->ReleaseSfntFrag((voidPtr)data)

#define SFAC_BINARYITERATION \
	  newP = (uint16 *) ((char *)tableP + (usSearchRange >>= 1)); \
		if (charCode > (uint16) SWAPW (*newP)) tableP = newP;

#define SFAC_GETUNSIGNEDBYTEINC( p ) ((uint8)(*p++))

/* PRIVATE PROTOTYES */

FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir);

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);

FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*  pGlyphTableIndex);

FS_PRIVATE ErrorCode    sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
    const void * *     ppvTablePtr);

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,		/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID);         /* Output glyph ID array        */

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift);		/* OUTPUT */

FS_PRIVATE ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	BBOX *              pbbox);             /* Glyph Bounding box           */

/*
 * Internal routine (make this an array and do a look up?)
 */
FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir)
{
	int32 Index;

	switch ((uint32)SWAPL(*((sfnt_TableTag *)&dir[SFNT_DIRECTORYENTRY_TAG])))
	{
		case tag_FontHeader:
			Index = (int32)sfnt_fontHeader;
			break;
		case tag_HoriHeader:
			Index = (int32)sfnt_horiHeader;
			break;
		case tag_IndexToLoc:
			Index = (int32)sfnt_indexToLoc;
			break;
		case tag_MaxProfile:
			Index = (int32)sfnt_maxProfile;
			break;
		case tag_ControlValue:
			Index = (int32)sfnt_controlValue;
			break;
		case tag_PreProgram:
			Index = (int32)sfnt_preProgram;
			break;
		case tag_GlyphData:
			Index = (int32)sfnt_glyphData;
			break;
		case tag_HorizontalMetrics:
			Index = (int32)sfnt_horizontalMetrics;
			break;
		case tag_CharToIndexMap:
			Index = (int32)sfnt_charToIndexMap;
			break;
		case tag_FontProgram:
			Index = (int32)sfnt_fontProgram;   /* <4> */
			break;
		case tag_GlyphDirectory:         /* Used for GlyphDirectory Download */
			Index = (int32)sfnt_GlyphDirectory;
			break;
		case tag_HoriDeviceMetrics:
			Index = (int32)sfnt_HoriDeviceMetrics;
			break;
		case tag_LinearThreshold:
			Index = (int32)sfnt_LinearThreshold;
			break;
		case tag_BitmapData:
			Index = (int32)sfnt_BitmapData;
			break;
		case tag_BitmapLocation:
			Index = (int32)sfnt_BitmapLocation;
			break;
		case tag_BitmapScale:
			Index = (int32)sfnt_BitmapScale;
			break;
		case tag_VertHeader:
			Index = (int32)sfnt_vertHeader;
			break;
		case tag_VerticalMetrics:
			Index = (int32)sfnt_verticalMetrics;
			break;
		case tag_OS_2:
			Index = (int32)sfnt_OS_2;
			break;
		default:
			Index = -1;
			break;
	}
	if (Index >= 0)
	{
		  TableDirectory[Index].ulOffset = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLEOFFSET]));
		  TableDirectory[Index].ulLength = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLELENGTH]));
	}
}


/*
 * Creates mapping for finding offset table     <4>
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *  ClientInfo)    /* Sfnt Client information */

{
	int32        i;
	uint8 *      sfntDirectory;
	int32        cTables;
	uint8 *      dir;

	STAT_OFF_CALLBACK;                  /* pause STAT timer */

	sfntDirectory = (uint8 *) GETSFNTFRAG (ClientInfo, 0L, (int32)SIZEOF_SFNT_OFFSETTABLE);

	STAT_ON_CALLBACK;                /* restart STAT timer */

	if (sfntDirectory != NULL)
	{
		cTables = (int32) SWAPW (*((uint16 *)&sfntDirectory[SFNT_OFFSETTABLE_NUMOFFSETS]));
		RELEASESFNTFRAG(ClientInfo, sfntDirectory);

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		sfntDirectory = (uint8 *) GETSFNTFRAG (
			ClientInfo,
			0L,
			((int32)SIZEOF_SFNT_OFFSETTABLE + (int32)SIZEOF_SFNT_DIRECTORYENTRY * (int32)(cTables)));

		STAT_ON_CALLBACK;             /* restart STAT timer */


		if (sfntDirectory == NULL)
		{
			return(CLIENT_RETURNED_NULL);
		}
	}
	else
	{
		return(NULL_SFNT_DIR_ERR);
	}

	/* Initialize */

	MEMSET (ClientInfo->TableDirectory, 0, sizeof (ClientInfo->TableDirectory));

	dir = &sfntDirectory[SFNT_OFFSETTABLE_TABLE];

	for (i = 0; i < cTables; i++)
	{
		sfac_Classify (ClientInfo->TableDirectory, dir);
		dir += SIZEOF_SFNT_DIRECTORYENTRY;
	}

	/* Used when glyphs are accessed from the base of memory */

	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulOffset = 0U;
	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulLength = ~0U;

	RELEASESFNTFRAG(ClientInfo, sfntDirectory);

	return NO_ERR;
}

/*
 * Use this function when only part of the table is needed.
 *
 * n is the table number.
 * offset is within table.
 * length is length of data needed.
 * To get an entire table, pass length = ULONG_MAX     <4>
 */

FS_PRIVATE ErrorCode sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
	const void **       ppvTablePtr)
{
	uint32      ulTableLength;

	ulTableLength = SFAC_LENGTH(ClientInfo, TableRef);

	if (ulTableLength > 0)
	{
		if(ulLength == ULONG_MAX)
		{
			ulLength = ulTableLength;
		}

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		*ppvTablePtr = (void *)GETSFNTFRAG (
			ClientInfo,
			(int32)(ulOffset + ClientInfo->TableDirectory[(int32)TableRef].ulOffset),
			(int32)ulLength);

		STAT_ON_CALLBACK;             /* restart STAT timer */

		if (*ppvTablePtr == NULL)
		{
			return CLIENT_RETURNED_NULL; /* Do a gracefull recovery   */
		}
	}
	else
	{
		*ppvTablePtr = (void *)NULL;

		if (bMustHaveTable)
		{
			return MISSING_SFNT_TABLE; /* Do a gracefull recovery  */
		}
	}

	return NO_ERR;
}


/*
 * This, is when we don't know what is going on
 */

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(mapping);
	FS_UNUSED_PARAMETER(charCode);
	FS_UNUSED_PARAMETER(ClientInfo);
	return MISSING_GLYPH_INDEX;
}


/*
 * Byte Table Mapping 256->256          <4>
 */
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(ClientInfo);
	if (charCode < MAX_FORMAT0_CHAR_INDEX)
	{
		return (uint16)mapping[charCode];
	}
	else
	{
		return MISSING_GLYPH_INDEX;
	}
}

/*
 * High byte mapping through table
 *
 * Useful for the national standards for Japanese, Chinese, and Korean characters.
 *
 * Dedicated in spirit and logic to Mark Davis and the International group.
 *
 *  Algorithm: (I think)
 *      First byte indexes into KeyOffset table.  If the offset is 0, keep going, else use second byte.
 *      That offset is from beginning of data into subHeader, which has 4 words per entry.
 *          entry, extent, delta, range
 *
 */

FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	uint16          usIndex;
	uint16          usMapMe;
	uint16          usHighByte;
	uint16          usGlyph;
	const uint8 *   Table2;
	const uint8 *   subHeader;

	FS_UNUSED_PARAMETER(ClientInfo);
	Table2 = (const uint8 *) mapping;

	usHighByte = (uint16)(charCode >> 8);

	if (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte])
	{
		usMapMe = (uint16)(charCode & 0xFF); /* We also need the low byte. */
	}
	else
	{
#ifdef  FSCFG_MICROSOFT_KK
		if(usHighByte != 0)
		{
			usMapMe = usHighByte;
		}
		else
		{
				usMapMe = (uint16)(charCode & 0xFF);
		}
#else
		usMapMe = usHighByte;
#endif
	}

	subHeader = (const uint8 *) ((char *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERS] +
		(uint16)SWAPW (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte]));

	usMapMe -= (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_FIRSTCODE]));    /* Subtract first code. */

	if (usMapMe < (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_ENTRYCOUNT])))
	{  /* See if within range. */

		usGlyph = (uint16)(* ((uint16 *) ((char *) &subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET] +
			(uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET]))) + usMapMe));

		if (usGlyph != 0) /* Note: usGlyph has not been swapped yet */
		{
			usIndex = (uint16)((int32)(uint32)(uint16)SWAPW(usGlyph) + (int32)SWAPW (*((int16 *)&subHeader[SFNT_SUBHEADER2_IDDELTA])));
		}
		else
		{
			usIndex = MISSING_GLYPH_INDEX;
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}

/*
 * Segment mapping to delta values, Yack.. !
 *
 * In memory of Peter Edberg. Initial code taken from code example supplied by Peter.
 */
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint16 *  tableP;
	const uint8 *   Table4;
	uint16          usIdDelta;
	uint16          usOffset;
	uint16          usIndex;
	uint16          usSegCountX2;
	uint16			usSearchRange;
	uint16			usEntrySelector;
	uint16			usRangeShift;
	const uint16 *  newP;    /* temporary pointer for binary iteration   */
	uint16          usStartCount;

	Table4 = (const uint8 *)mapping;

	usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));
	tableP = (const uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENDCOUNT];

	/* If there are just a few segments, skip straight to the linear search */

	if (usSegCountX2 >= MAX_LINEAR_X2 && charCode > 0xFF)
	{
		/* start with unrolled binary search */

		/* tableP points at endCount[] */
		if( ClientInfo == NULL )
		{
			sfac_ComputeBinarySearchParams(
				(uint16)(usSegCountX2 / 2),
				&usSearchRange,
				&usEntrySelector,
				&usRangeShift);
		}
		else
		{
			usSearchRange = ClientInfo->usFormat4SearchRange;

			/* Assert(SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_RANGESHIFT])) == ClientInfo->usFormat4RangeShift); */
			usRangeShift = ClientInfo->usFormat4RangeShift;

			/* Assert((uint16)SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENTRYSELECTOR])) == ClientInfo->usFormat4EntrySelector); */
			usEntrySelector = ClientInfo->usFormat4EntrySelector;
		}

		if (charCode >= (uint16) SWAPW (* ((uint16 *) ((char *)tableP + usSearchRange))))
		{
			tableP = (uint16 *) ((char *)tableP + usRangeShift); /* range to low shift it up */
		}


		switch( usEntrySelector )
		{
		case 15:
			SFAC_BINARYITERATION;
			/* fall through */
		case 14:
			SFAC_BINARYITERATION;
			/* fall through */
		case 13:
			SFAC_BINARYITERATION;
			/* fall through */
		case 12:
			SFAC_BINARYITERATION;
			/* fall through */
		case 11:
			SFAC_BINARYITERATION;
			/* fall through */
		case 10:
			SFAC_BINARYITERATION;
			/* fall through */
		case 9:
			SFAC_BINARYITERATION;
			/* fall through */
		case 8:
			SFAC_BINARYITERATION;
			/* fall through */
		case 7:
			SFAC_BINARYITERATION;
			/* fall through */
		case 6:
			SFAC_BINARYITERATION;
			/* fall through */
		case 5:
			SFAC_BINARYITERATION;
			/* fall through */
		case 4:
			SFAC_BINARYITERATION;
			/* fall through */
		case 3:
		case 2:   /* drop through */
		case 1:
		case 0:
			break;
		default:
			Assert(FALSE);
			break;
		}
	}

	/*  Now do linear search */

	while(charCode > (uint16) SWAPW(*tableP))
	{
		tableP++;
	}

	tableP++;                  /*  Skip Past reservedPad word    */

	/* End of search, now do mapping */

	tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point at startCount[] */
	usStartCount = (uint16) SWAPW (*tableP);

	if (charCode >= usStartCount)
	{
		  usOffset = (uint16)(charCode - (uint16) SWAPW (*tableP));
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idDelta[] */
		usIdDelta = (uint16) SWAPW (*tableP);
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idRangeOffset[] */

		if ((uint16) SWAPW (*tableP) == 0)
		{
				usIndex   = (uint16)(charCode + usIdDelta);
		}
		else
		{
			/* Use glyphIdArray to access index */

			usOffset += usOffset; /* make word offset */
			tableP   = (uint16 *) ((char *)tableP + (uint16) SWAPW (*tableP) + usOffset); /* point to glyphIndexArray[] */

			if((uint16)SWAPW (*tableP) != MISSING_GLYPH_INDEX)
			{
					 usIndex    = (uint16)((uint16) SWAPW (*tableP) + usIdDelta);
			}
			else
			{
				usIndex = MISSING_GLYPH_INDEX;
			}
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}


/*
 * Trimmed Table Mapping
 */

FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint8 *Table6;

	FS_UNUSED_PARAMETER(ClientInfo);

	Table6 = (const uint8 *) mapping;

	charCode  -= (uint16)SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_FIRSTCODE]));

	if (charCode < (uint16) SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_ENTRYCOUNT])))
	{
		return ((uint16) SWAPW (((uint16 *)&Table6[SFNT_MAPPINGTABLE6_GLYPHIDARRAY]) [charCode]));
	}
	else
	{
		return   MISSING_GLYPH_INDEX;
	}
}


/*
 * Sets up our mapping function pointer.
 */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *  ClientInfo,
	uint16            usPlatformID,
	uint16            usSpecificID)

{
	const uint8 *   table;
	const uint8 *   MappingTable;
	const uint8 *   Table4;
	boolean         bFound;
	ErrorCode       Ret;
	const uint8 *	plat;
	uint16			usSegCountX2;

	bFound = FALSE;

	/* the following code allow a client that is only interested by glyph indices to
               call fs_NewSfnt with -1 for PlatformID and SpecificID */
	if(usPlatformID == 0xFFFF)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}


	Ret = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, FALSE, (const void **)&table);

	if(Ret != NO_ERR)
	{
		return Ret;
	}


	if (table == NULL)
	{
		/* If no "cmap" is present, permits access to characters by glyph index */

		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}

	/* APPLE Code
	if(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_VERSION]) != 0)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	*/

	/* mapping */

	plat = (uint8 *) &table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM]; /* <4> */

	while(plat < (uint8 *)&table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM + ((uint16)SWAPW(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_NUMTABLES])) *
		  SIZEOF_SFNT_PLATFORMENTRY)] && !bFound)
	{
		if (((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_PLATFORMID])) == usPlatformID) &&
			((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_SPECIFICID])) == usSpecificID))
		{
			bFound = TRUE;
			ClientInfo->ulMapOffset = (uint32) SWAPL (*((uint32 *)&plat[SFNT_PLATFORMENTRY_PLATFORMOFFSET]));   /* skip header */
		}
		plat += SIZEOF_SFNT_PLATFORMENTRY;
	}


	if (!bFound)
	{
		ClientInfo->ulMapOffset = 0;
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	else
	{
		Assert(Ret == NO_ERR);
		MappingTable = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);  /* back up for header */
		ClientInfo->ulMapOffset += (uint32)SIZEOF_SFNT_MAPPINGTABLE;
	}

    ClientInfo->usMappingFormat = (uint16)SWAPW (*((uint16 *)&MappingTable[SFNT_MAPPINGTABLE_FORMAT]));

	switch (ClientInfo->usMappingFormat)
	{
	case 0:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex0;
		break;
	case 2:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex2;
		break;
	case 4:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex4;

		/* Pre-compute several values used for Index 4 lookups */
		/* This becomes necessary because of several font vendors who */
		/* have placed incorrect values in the TrueType font file. */

		Table4 = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);
		usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));

		sfac_ComputeBinarySearchParams(
			(uint16)(usSegCountX2 / 2),
			&ClientInfo->usFormat4SearchRange,
			&ClientInfo->usFormat4EntrySelector,
			&ClientInfo->usFormat4RangeShift);

		break;
	case 6:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex6;
		break;
	default:
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		Ret = UNKNOWN_CMAP_FORMAT;
		break;
	}
	RELEASESFNTFRAG(ClientInfo, table);

	return Ret;
}

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift)		/* OUTPUT */
{
	uint16			usLog;
	uint16			usPowerOf2;

	usLog = 0;
	usPowerOf2 = 1;

	while((2 * usPowerOf2) <= usSegCount )
	{
		usPowerOf2 *= 2;
		usLog++;
	}

	*pusSearchRange = 2 * usPowerOf2;
	*pusEntrySelector = usLog;
	*pusRangeShift = (2 * usSegCount) - (2 * usPowerOf2);
}

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *  ClientInfo,
	uint16            usCharacterCode)
{
	 const uint8 *   mappingPtr;
	ErrorCode   error;

	 error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	ClientInfo->usGlyphIndex = ClientInfo->GlyphMappingF (mappingPtr + ClientInfo->ulMapOffset, usCharacterCode, ClientInfo);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return NO_ERR;
}

/*  return glyph ID's for a range or for an array of character codes */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*  special version for Win95 doesn't require a font context */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,       /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
   	uint16              usMappingFormat;    /* cmap subtable format code    */
   	MappingFunc			pfnGlyphMapping;	/* mapping func char to glyph   */
    const uint8 *       pbyCmapData;        /* past subtable header         */
 	ErrorCode           errCode;

    usMappingFormat = (uint16)SWAPW (*((uint16 *)&pbyCmapSubTable[SFNT_MAPPINGTABLE_FORMAT]));
	switch (usMappingFormat)
	{
	case 0:
		pfnGlyphMapping = sfac_ComputeIndex0;
		break;
	case 2:
		pfnGlyphMapping = sfac_ComputeIndex2;
        break;
	case 4:
		pfnGlyphMapping = sfac_ComputeIndex4;
        break;
	case 6:
		pfnGlyphMapping = sfac_ComputeIndex6;
		break;
    default:
        return UNKNOWN_CMAP_FORMAT;
    }
    pbyCmapData = pbyCmapSubTable + SIZEOF_SFNT_MAPPINGTABLE;


    errCode = sfac_GetGlyphIDs (
   	    pfnGlyphMapping,
        pbyCmapData,
        NULL,                               /* ClientInfo */
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID );

	return errCode;
}

/* special helper function for NT
   - an offset usCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID)        /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetLongGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
		ulCharCodeOffset,
	    pulCharCode,
	    pulGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*      common code for the two get glyph ID helper routines */

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	if (pusCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pusGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
            if (*pusCharCode == 0xFFFF)     /* trap illegal char code */
            {
                return INVALID_CHARCODE_ERR;
            }
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, *pusCharCode, ClientInfo);
            pusGlyphID++;
            pusCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*      special for NT */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID)         /* Output glyph ID array        */
{
	if (pulCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pulGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
			if ((*pulCharCode + ulCharCodeOffset) > 0x0000FFFFL)
            {
                return INVALID_CHARCODE_ERR;   /* trap an illegal range */
            }
			usCharCode = (uint16) (*pulCharCode + ulCharCodeOffset);
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pulGlyphID++;
            pulCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusEmResolution,
	boolean *               pbIntegerScaling,
	LocalMaxProfile *       pMaxProfile)
{
	ErrorCode       error;
	const uint8 *   fontHead;
	const uint8 *   horiHead;
	const uint8 *   pTempMaxProfile;
	const uint8 *   pTempOS_2;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontHeader, TRUE, (const void **)&fontHead);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horiHeader, TRUE, (const void **)&horiHead);

	if(error != NO_ERR)
	{
		return error;
	}

	if ((uint32)SWAPL (*((uint32 *)&fontHead[SFNT_FONTHEADER_MAGICNUMBER])) != SFNT_MAGIC)
	{
		return BAD_MAGIC_ERR;
	}

	*pusEmResolution     = (uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_UNITSPEREM]));
	*pbIntegerScaling    = (((uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_FLAGS]))& USE_INTEGER_SCALING) ==
									 USE_INTEGER_SCALING);
	ClientInfo->usNumberOf_LongHorMetrics = (uint16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS]));
	ClientInfo->sIndexToLocFormat       = SWAPW (*((int16 *)&fontHead[SFNT_FONTHEADER_INDEXTOLOCFORMAT]));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_OS_2, FALSE, (const void **)&pTempOS_2); /* not a mandatory table */

	if(error != NO_ERR)
	{
		return error;
	}

	if(pTempOS_2 != NULL)
	{
		/* get TypoAscender and TypoDescender from the OS/2 table */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPOASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPODESCENDER]));
		RELEASESFNTFRAG(ClientInfo, pTempOS_2);
	} else {
		/* if OS/2 is not there get the values from horizontal header */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));
	}
	ClientInfo->sWinDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));

	RELEASESFNTFRAG(ClientInfo, horiHead);
	RELEASESFNTFRAG(ClientInfo, fontHead);

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_maxProfile, TRUE, (const void **)&pTempMaxProfile);

	if(error != NO_ERR)
	{
		return error;
	}

	pMaxProfile->version =              (Fixed)SWAPL(*((Fixed *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_VERSION]));
	pMaxProfile->numGlyphs =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_NUMGLYPHS]));
	pMaxProfile->maxPoints =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXPOINTS]));
	pMaxProfile->maxContours =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCONTOURS]));
	pMaxProfile->maxCompositePoints =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS]));
	pMaxProfile->maxCompositeContours = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS]));
	pMaxProfile->maxElements =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXELEMENTS]));
	pMaxProfile->maxTwilightPoints =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS]));
	pMaxProfile->maxStorage =           (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTORAGE]));
	pMaxProfile->maxFunctionDefs =      (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS]));
	pMaxProfile->maxInstructionDefs =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS]));
	pMaxProfile->maxStackElements =     (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS]));
	pMaxProfile->maxSizeOfInstructions =(uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS]));
	pMaxProfile->maxComponentElements = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS]));
	pMaxProfile->maxComponentDepth =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH]));

	RELEASESFNTFRAG(ClientInfo, pTempMaxProfile);

	error = sfac_ReadNumLongVertMetrics(ClientInfo, &ClientInfo->usNumLongVertMetrics,&ClientInfo->bValidNumLongVertMetrics);

	return error;
}



/*
 *
 */

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	int16 *             psNonScaledLSB)
{
	const uint8 *   horizMetricPtr;
	uint16          numberOf_LongHorMetrics;
	ErrorCode       error;
	int16 *         lsb;

	numberOf_LongHorMetrics = ClientInfo->usNumberOf_LongHorMetrics;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horizontalMetrics, TRUE, (const void **)&horizMetricPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	if (glyphIndex < numberOf_LongHorMetrics)
	{
		*pusNonScaledAW     = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB     = SWAPW (*((int16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING]));
	}
	else
	{
		lsb = (int16 *) (char *)& horizMetricPtr[numberOf_LongHorMetrics * SIZEOF_SFNT_HORIZONTALMETRICS]; /* first entry after[AW,LSB] array */

		*pusNonScaledAW       = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[((numberOf_LongHorMetrics-1) * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB      = SWAPW (lsb[glyphIndex - numberOf_LongHorMetrics]);
	}

	RELEASESFNTFRAG(ClientInfo, horizMetricPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledTSB)
{
	const uint8 *   vertMetricPtr;
	uint16          usNumLongVertMetrics;       /* number of entries with AH */
	ErrorCode       error;
	int16 *         psTSB;
	BBOX            bbox;           


	usNumLongVertMetrics = ClientInfo->usNumLongVertMetrics;
	if(ClientInfo->bValidNumLongVertMetrics)
	{

		error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_verticalMetrics, FALSE, (const void **)&vertMetricPtr);  /* not a mandatory table */

		if(error != NO_ERR)
		{
			return error;
		}
	}

	if (ClientInfo->bValidNumLongVertMetrics && (vertMetricPtr != NULL) )
	{
		if (glyphIndex < usNumLongVertMetrics)
		{
			*pusNonScaledAH     = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB     = SWAPW (*((int16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_TOPSIDEBEARING]));
		}
		else
		{
			psTSB = (int16 *) (char *)& vertMetricPtr[usNumLongVertMetrics * SIZEOF_SFNT_VERTICALMETRICS]; /* first entry after[AW,TSB] array */

			*pusNonScaledAH       = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[((usNumLongVertMetrics-1) * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB      = SWAPW (psTSB[glyphIndex - usNumLongVertMetrics]);
		}

		RELEASESFNTFRAG(ClientInfo, vertMetricPtr);
	} else {

		/* We don't have vertical metrics, let's set to default values */

		/* to get the glyph bbox for the defalut value of the vertical metrics */
		error = sfac_ReadGlyphBbox(ClientInfo,ClientInfo->usGlyphIndex, &bbox);

		if(error != NO_ERR)
		{
			return error;
		}		

		/* default if no vertical metrics found */
		*pusNonScaledAH = ClientInfo->sDefaultAscender - ClientInfo->sDefaultDescender;   
		*psNonScaledTSB = ClientInfo->sDefaultAscender - bbox.yMax;
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB)
{
	ErrorCode       error;

	error = sfac_ReadGlyphHorMetrics (ClientInfo, glyphIndex, pusNonScaledAW, psNonScaledLSB);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_ReadGlyphVertMetrics (ClientInfo, glyphIndex, pusNonScaledAH, psNonScaledTSB);
	return error;
}

/*
 *  Read Number of Long Vertical Metrics from vhea table
 */

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusNumLongVertMetrics,
	boolean *               pbValidNumLongVertMetrics )
{
	ErrorCode       error;
	const uint8 *   vertHead;

	*pbValidNumLongVertMetrics = FALSE;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_vertHeader, FALSE, (const void **)&vertHead);

	if(error != NO_ERR)
	{
		return error;
	}		
	
	if(vertHead != NULL)
	{
		*pusNumLongVertMetrics = (uint16)SWAPW (*((uint16 *)&vertHead[SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS]));
		*pbValidNumLongVertMetrics = TRUE;

		RELEASESFNTFRAG(ClientInfo, vertHead);
	}

	return NO_ERR;
}


FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*    pGlyphTableIndex)

{
	const void *    indexPtr;
	ErrorCode       error;
	uint16 *        shortIndexToLoc;
	uint32 *        longIndexToLoc;
	uint32 *        offsetPtr;
	uint16 *        lengthPtr;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_GlyphDirectory, FALSE, (const void **)&indexPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	/* If there is a glyph directory, first check for the glyph there.  */

	if (indexPtr != NULL)
	{
		offsetPtr = (uint32 *)((char *)indexPtr+((int32)gIndex*(int32)(sizeof(int32)+sizeof(uint16))));
		lengthPtr = (uint16 *)(char *)(offsetPtr+1);

		*ulOffset = (uint32)SWAPL(*offsetPtr);

		if(*ulOffset == 0L)
		{
			*ulLength =  0L;
		}
		else
		{
			*ulLength =  (uint32) (uint16)SWAPW(*lengthPtr);
		}

		/* sfnt_BeginningOfFont references the beginning of memory  */

		*pGlyphTableIndex = sfnt_BeginningOfFont;

		RELEASESFNTFRAG(ClientInfo, indexPtr);
		return NO_ERR;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_indexToLoc, TRUE, (const void **)&indexPtr);
	if(error != NO_ERR)
	{
		return error;
	}

	if (ClientInfo->sIndexToLocFormat == SHORT_INDEX_TO_LOC_FORMAT)
	{
		shortIndexToLoc = (uint16 *)indexPtr + gIndex;
		*ulOffset = (uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1;
		shortIndexToLoc++;
		*ulLength =  (((uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1) - *ulOffset);
	}
	else
	{
		longIndexToLoc = (uint32 *)indexPtr + gIndex;
		*ulOffset = (uint32) SWAPL (*longIndexToLoc);
		longIndexToLoc++;
		*ulLength = ((uint32)SWAPL (*longIndexToLoc) - *ulOffset);
	}

	*pGlyphTableIndex = sfnt_glyphData;

	RELEASESFNTFRAG(ClientInfo, indexPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,    /* Client Information         */
	char *              pFontProgram,  /* pointer to Font Program    */
	char *              pPreProgram)   /* pointer to Pre Program     */
{
	uint32              ulLength;
	const char *        pFragment;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_fontProgram);
	if (ulLength)
	{
		MEMCPY (pFontProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_preProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	if (ulLength)
	{
		MEMCPY (pPreProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,    /* Client Information   */
	F26Dot6 *           pCVT)       /* pointer to CVT    */
{
	uint32              ulLength;
	const int16 *       pFragment;
	int32               lNumCVT;
	int32               lCVTCount;
	const int16 *       psSrcCVT;
	F26Dot6 *           pfxDstCVT;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_controlValue, FALSE, (const void **)&pFragment);

	if(error)
	{
		return error;
	}

	ulLength = SFAC_LENGTH (ClientInfo, sfnt_controlValue);

	if (ulLength)
	{
		psSrcCVT = pFragment;
		pfxDstCVT = pCVT;

		lNumCVT = ((int32)ulLength / (int32)sizeof( sfnt_ControlValue));

		for(lCVTCount = 0L; lCVTCount < lNumCVT; lCVTCount++)
		{
			pfxDstCVT[lCVTCount] = (F26Dot6)SWAPW(psSrcCVT[lCVTCount]);
		}

		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           pbFound,        /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pHdmx;
	const uint8 *       pCurrentHdmxRecord;
	uint32              ulHdmxRecordSize;
	uint16              usRecordIndex;
	uint16              usGlyphIndex;
	ErrorCode           error;

	Assert( usFirstGlyph <= usLastGlyph );
	Assert( psBuffer != NULL );

	*pbFound = FALSE;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_HoriDeviceMetrics, FALSE, (const void **)&pHdmx);

	if(error)
	{
		return error;
	}

	/* If no 'hdmx' return success and not found    */

	if( pHdmx == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pHdmx[SFNT_HDMX_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		ulHdmxRecordSize = (uint32)SWAPL(*((uint32 *)&pHdmx[SFNT_HDMX_LSIZERECORD]));

		usRecordIndex = 0;
		pCurrentHdmxRecord = &pHdmx[SFNT_HDMX_HDMXTABLE];
		while (  (usRecordIndex < (uint16)SWAPW(*((uint16 *)&pHdmx[SFNT_HDMX_SNUMRECORDS]))) && !*pbFound )
		{
			if( usPixelsPerEm == (uint16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BEMY] )
			{
				*pbFound = TRUE;
			}
			else
			{
				pCurrentHdmxRecord += ulHdmxRecordSize;
			}
			usRecordIndex++;
		}

		if ( *pbFound )
		{
			for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
			{
				*psBuffer = (int16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BWIDTHS + usGlyphIndex];
				psBuffer++;
			}
		}
	}

	RELEASESFNTFRAG(ClientInfo, pHdmx);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pLTSH;
	uint16              usGlyphIndex;
	ErrorCode           error;

	MEMSET(psBuffer, FALSE, ((usLastGlyph - usFirstGlyph) + 1) * sizeof(int16));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_LinearThreshold, FALSE, (const void **)&pLTSH);

	if(error)
	{
		return error;
	}
	
	if( pLTSH == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pLTSH[SFNT_LTSH_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++ )
		{
			if( usPixelsPerEm >= (uint16)pLTSH[SFNT_LTSH_UBYPELSHEIGHT + usGlyphIndex] )
			{
				*psBuffer = TRUE;
			}
			else
			{
				*psBuffer = FALSE;
			}
			psBuffer++;
		}
	}

	RELEASESFNTFRAG(ClientInfo, pLTSH);

	return NO_ERR;
}



/***************************** Public  Function ****************************\
* sfac_ReadGlyphHeader
*
* This routine sets up the glyph handle to a glyph, and returns the header
* information in the glyph.
*
* Effects:
*
* Error Returns:
*
* UNKNOWN_COMPOSITE_VERSION
*
* History:
* Wed 26-Aug-1992 09:55:19 -by-  Greg Hitchcock [gregh]
*      Added CodeReview fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	sfac_GHandle *      hGlyph,           /* Return glyph handle        */
	boolean *           pbCompositeGlyph, /* Is glyph a composite?      */
	boolean *           pbHasOutline,     /* Does glyph have outlines?  */
	int16 *             psNumberOfContours, /* Number of contours in glyph */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;

	hGlyph->pvGlyphBaseAddress = NULL;
	hGlyph->pvGlyphNextAddress = NULL;

	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		*psNumberOfContours = 1;
		MEMSET(pbbox, 0, sizeof(BBOX));
		*pbHasOutline = FALSE;
		*pbCompositeGlyph = FALSE;
	}
	else
	{
		if (ulLength < SFNT_PACKEDSPLINEFORMAT_ENDPOINTS)
		{
			return GLYF_TABLE_CORRUPTION_ERR;
		}

		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&hGlyph->pvGlyphBaseAddress);

		if(error)
		{
			return error;
		}

		hGlyph->pvGlyphEndAddress = (uint8 *)hGlyph->pvGlyphBaseAddress + ulLength;

		GlyphHeader = (uint8 *)hGlyph->pvGlyphBaseAddress;
		*psNumberOfContours = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS]));

		if( *psNumberOfContours < COMPONENTCTRCOUNT )
		{
			return UNKNOWN_COMPOSITE_VERSION;
		}

		if( *psNumberOfContours == COMPONENTCTRCOUNT )
		{
			*pbCompositeGlyph = TRUE;
			*psNumberOfContours = 0;
			*pbHasOutline = FALSE;
		}
		else
		{
			*pbCompositeGlyph = FALSE;
			*pbHasOutline = TRUE;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}

		if(pbHasOutline)
		{
			hGlyph->pvGlyphNextAddress = (voidPtr)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_ENDPOINTS];
		}
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadGlyphBbox
*
*
* Effects:
*         This function release the glyph memory immediately
*
* Error Returns:
*
* SFNT_DATA_ERR
*
* History:
* Wed 20-Dec-1996 18:42:51 -by-  Claude Betrisey [claudebe]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;


	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		MEMSET(pbbox, 0, sizeof(BBOX));
	}
	else
	{
		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&GlyphHeader);

		if(error)
		{
			return error;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		RELEASESFNTFRAG(ClientInfo, GlyphHeader );

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}


	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadOutlineData
*
*   This routine reads the outline data from the font file. This information
*   includes x and y coordinates, and on-curve indicators as well as start/end
*   points, flags, and instruction data.
*
* Effects:
*   hGlyph
*
* Error Returns:
*   CONTOUR_DATA_ERR
*
* History:
* Wed 26-Aug-1992 09:55:49 -by-  Greg Hitchcock [gregh]
*      Added Code Review fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/


FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	uint8 *             abyOnCurve,             /* Array of on curve indicators per point */
	F26Dot6 *           afxOoy,                 /* Array of ooy points for every point    */
	F26Dot6 *           afxOox,                 /* Array of oox points for every point    */
	sfac_GHandle *      hGlyph,
	LocalMaxProfile *   pMaxProfile,            /* copy of profile                        */
	boolean             bHasOutline,            /* Does glyph have outlines?              */
	int16               sNumberOfContours,      /* Number of contours in glyph            */
	int16 *             asStartPoints,          /* Array of start points for every contour   */
	int16 *             asEndPoints,            /* Array of end points for every contour    */
	uint16 *            pusSizeOfInstructions,  /* Size of instructions in bytes        */
	 uint8 **               pbyInstructions,    /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours) /* total number of contours for composites, to check for overflow */

{

	uint8 *     pbyCurrentSfntLocation;
	int16 *     psCurrentLocation;
	int16 *     asSfntEndPoints;
	uint8 *     pbySfntFlags;
	uint8       byRepeatFlag;

	int32       lNumPoints;
	int32       lContourIndex;
	int32       lPointCount;
	int32       lPointIndex;
	uint16      usRepeatCount;
	int16       sXValue;
	int16       sYValue;
	uint8 *     pbyFlags;
	F26Dot6 *   pf26OrigX;
	F26Dot6 *   pf26OrigY;

	/* Initialize Fields */

	asStartPoints[0] = 0;
	asEndPoints[0] = 0;

	abyOnCurve[0] = ONCURVE;
	afxOox[0] = 0;
	afxOoy[0] = 0;

	*pbyInstructions = NULL;
	*pusSizeOfInstructions = 0;

	/* If we don't have an outline, exit here   */

	if (!bHasOutline)
	{
		return NO_ERR;
	}

	if (sNumberOfContours <= 0 || sNumberOfContours > (int16)pMaxProfile->maxContours)
	{
		return CONTOUR_DATA_ERR;
	}

    /* Handle the case of outlines   */

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	asSfntEndPoints = psCurrentLocation;
	psCurrentLocation += sNumberOfContours;

	if ((voidPtr)psCurrentLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	pbySfntFlags = (uint8 *)((char *)psCurrentLocation + *pusSizeOfInstructions);

	if ((voidPtr)pbySfntFlags > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}


    *pCompositeContours += sNumberOfContours;
	if (*pCompositeContours > (uint32)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours))
	{
		return CONTOUR_DATA_ERR;
	}

	lContourIndex = 0;

	asStartPoints[lContourIndex] = 0;
	asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
	lNumPoints = (int32)asEndPoints[lContourIndex] + 1;

	for(lContourIndex = 1; lContourIndex < (int32)sNumberOfContours; lContourIndex++)
	{
		asStartPoints[lContourIndex] = (int16)(asEndPoints[lContourIndex - 1] + 1);
		asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
		if ((lNumPoints > asEndPoints[lContourIndex]) || (lNumPoints > (int32)pMaxProfile->maxPoints))
		{
			/* array of end points is not in ascending order, or too many points */
			return POINTS_DATA_ERR;
		}
		lNumPoints = (int32)asEndPoints[lContourIndex] + 1;
	}

    *pCompositePoints += lNumPoints;
	if (*pCompositePoints > (uint32)MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints) )
	{
		return POINTS_DATA_ERR;
	}

	/* Do flags */

	usRepeatCount = 0;

	lPointCount = lNumPoints;
	pbyFlags = abyOnCurve;

	while(lPointCount > 0)
	{
		if(usRepeatCount == 0)
		{
			*pbyFlags = *pbySfntFlags;

			if(*pbyFlags & REPEAT_FLAGS)
			{
				pbySfntFlags++;
				usRepeatCount = (uint16)*pbySfntFlags;
			}
			pbySfntFlags++;
			pbyFlags++;
			lPointCount--;
		}
		else
		{
			byRepeatFlag = pbyFlags[-1];
			lPointCount -= (int32)usRepeatCount;

			if (lPointCount < 0)
			{
				return GLYF_TABLE_CORRUPTION_ERR;
			}

			while(usRepeatCount > 0)
			{
				*pbyFlags = byRepeatFlag;
				pbyFlags++;
				usRepeatCount--;
			}
		}
	}

	pbyCurrentSfntLocation = pbySfntFlags;

	if(usRepeatCount > 0)
	{
		return POINTS_DATA_ERR;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Do X first */

	sXValue = 0;
	pf26OrigX = afxOox;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & XSHORT)
		{
			if(*pbyFlags & SHORT_X_IS_POS)
			{
				sXValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sXValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_X_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sXValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigX = (F26Dot6)sXValue;
		pf26OrigX++;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Now Do Y */

	sYValue = 0;
	pf26OrigY = afxOoy;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & YSHORT)
		{
			if(*pbyFlags & SHORT_Y_IS_POS)
			{
				sYValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sYValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_Y_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sYValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigY = (F26Dot6)sYValue;
		pf26OrigY++;

		/* Clear out extraneous bits in OnCurve */

		*pbyFlags &= ONCURVE;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	hGlyph->pvGlyphNextAddress = (voidPtr)pbyCurrentSfntLocation;

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadComponentData
*
*   This routine reads information from the font file for positioning and
*   scaling a glyph component.
*
* Effects:
*
* Error Returns:
*   none
*
* History:
* Wed 26-Aug-1992 09:56:29 -by-  Greg Hitchcock [gregh]
*      Added Code Review Fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets  */
	boolean *               pbRoundXYToGrid,  /* Round composite offsets to grid     */
	boolean *               pbUseMyMetrics,   /* Use component metrics            */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions         */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component         */
	int16 *                 psXOffset,        /* X Offset of component (if app)      */
	int16 *                 psYOffset,        /* Y Offset of component (if app)      */
	uint16 *                pusAnchorPoint1,  /* Anchor point 1 of component (if app) */
	uint16 *                pusAnchorPoint2,  /* Anchor point 2 of component (if app) */
	transMatrix             *pMulT,           /* Transformation matrix for component */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent)   /* Is this the last component?                  */

{
	int16 *     psCurrentLocation;
	uint16      usComponentFlags;
	char *      byteP;

	Fixed       fMultiplier;


	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	/* Initialize values */

	/* Initialize transformation matrix to identity */

	*pMulT = IdentTransform;

	*psXOffset = 0;
	*psYOffset = 0;
	*pusAnchorPoint1 = 0;
	*pusAnchorPoint2 = 0;
	*pbWeHaveAScale = FALSE;

	usComponentFlags = (uint16)SWAPWINC(psCurrentLocation);

	*pbWeHaveInstructions = ((usComponentFlags & WE_HAVE_INSTRUCTIONS) == WE_HAVE_INSTRUCTIONS);
	*pbUseMyMetrics =    ((usComponentFlags & USE_MY_METRICS) == USE_MY_METRICS);
	*pbRoundXYToGrid =      ((usComponentFlags & ROUND_XY_TO_GRID) == ROUND_XY_TO_GRID);

	/* new flags that indicate if the glyph was designed to have the component offset scaled or not
	   Apple does scale the component offset, MS doesn't, those flags are supposed to be clear on old fonts
	   on new fonts, only one of these flags must be set,
	   default is set to false, MS behavior */
	if ((usComponentFlags & SCALED_COMPONENT_OFFSET) == SCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = TRUE;
	}
	if ((usComponentFlags & UNSCALED_COMPONENT_OFFSET) == UNSCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = FALSE;
	}

	*pusComponentGlyphIndex = (uint16)SWAPWINC(psCurrentLocation);

	if (usComponentFlags & ARGS_ARE_XY_VALUES)
	{
		*pMultiplexingIndicator = OffsetPoints;
	}
	else
	{
		*pMultiplexingIndicator = AnchorPoints;
	}


	/*
		!!!APPLEBUG The rasterizer did not handle Word Anchor Points. This
		!!!APPLEBUG has been corrected in our version of the rasterizer, but
		!!!APPLEBUG we need to verify with the Apple source code.  --GregH
	 */

	if (usComponentFlags & ARG_1_AND_2_ARE_WORDS)
	{
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
			*psXOffset    = SWAPWINC (psCurrentLocation);
			*psYOffset    = SWAPWINC (psCurrentLocation);
		}
		else
		{
			*pusAnchorPoint1 = (uint16) SWAPWINC (psCurrentLocation);
			*pusAnchorPoint2 = (uint16) SWAPWINC (psCurrentLocation);
		}
	}
	else
	{
		byteP = (char *)psCurrentLocation;
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
		/* offsets are signed */
			*psXOffset = (int16)(int8)*byteP++;
			*psYOffset = (int16)(int8)*byteP;
		}
		else
		{
		/* anchor points are unsigned */
			*pusAnchorPoint1 = (uint16)(uint8) * byteP++;
			*pusAnchorPoint2 = (uint16)(uint8) * byteP;
		}
		++psCurrentLocation;
	}


	if (usComponentFlags & (WE_HAVE_A_SCALE | WE_HAVE_AN_X_AND_Y_SCALE | WE_HAVE_A_TWO_BY_TWO))
	{

		*pbWeHaveAScale = TRUE;

		if (usComponentFlags & WE_HAVE_A_TWO_BY_TWO)
		{
			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][1] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][1] = (fMultiplier << 2); /* turn into 16.16 */

		}
		else
		{
			/* If we have a scale factor, build it into the transformation matrix   */

			pMulT->transform[0][1] = 0;
			pMulT->transform[1][0] = 0;

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier <<= 2); /* turn into 16.16 */

			if (usComponentFlags & WE_HAVE_AN_X_AND_Y_SCALE)
			{
				fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
				pMulT->transform[1][1] = (fMultiplier <<= 2); /* turn into 16.16 */
			}
			else
			{
				pMulT->transform[1][1] = pMulT->transform[0][0];
			}
		}
	}
	*pbLastComponent = !((usComponentFlags & MORE_COMPONENTS) == MORE_COMPONENTS);

	hGlyph->pvGlyphNextAddress = (voidPtr)psCurrentLocation;

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadCompositeInstructions
*
*   This routine returns the instructions for the composite
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle * hGlyph,
	uint8 **    pbyInstructions,     /* Pointer to start of glyph instructions */
	uint16 *    pusSizeOfInstructions) /* Size of instructions in bytes           */
{
	int16 *    psCurrentLocation;

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	hGlyph->pvGlyphNextAddress = (voidPtr)(*pbyInstructions + *pusSizeOfInstructions);

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReleaseGlyph
*
*   This routine releases the glyph handle for the font file
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *  ClientInfo,
	sfac_GHandle *    hGlyph)
{
	if(hGlyph->pvGlyphNextAddress)
	{
		RELEASESFNTFRAG(ClientInfo,(voidPtr)hGlyph->pvGlyphBaseAddress);

		hGlyph->pvGlyphNextAddress = NULL;
		hGlyph->pvGlyphBaseAddress = NULL;

	}

	return NO_ERR;
}

/***************************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

/*  Local constants  */

#define     SBIT_BLOC_TABLE         1       /* which table are metrics in */
#define     SBIT_BDAT_TABLE         2

#define     SBIT_HORIZ_METRICS      1       /* which kind of metrics */
#define     SBIT_VERT_METRICS       2
#define     SBIT_BIG_METRICS        3

typedef enum {                              /* metrics type */
	flgHorizontal = 0x01,
	flgVertical = 0x02
} bitmapFlags;

FS_PRIVATE boolean FindBlocStrike (         /* helper function prototype */
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset );

FS_PRIVATE boolean FindBscaStrike (         /* helper function prototype */
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset );

/*  byte size bitmap range masks */

static uint8    achStartMask[] = { 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01 };
static uint8    achStopMask[] =  { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF };
					
/**********************************************************************/

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset )
{
	const uint8 *   pbyBloc;
	const uint8 *   pbyBsca;
	ErrorCode       ReturnCode;
	
	*pusTableState = SBIT_NOT_FOUND;                /* defaults */
	*pulStrikeOffset = 0L;
	*pusSubPpemX = 0;
	*pusSubPpemY = 0;

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		0L,                                         /* table start */
		ULONG_MAX,                                  /* read whole table */
		sfnt_BitmapLocation,                        /* registered tag */
		FALSE,                                      /* doesn't have to be there */
		(const void**)&pbyBloc );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
	
	if (pbyBloc != NULL)                            /* if bloc exists */
	{
		if (FindBlocStrike (pbyBloc, usPpemX, usPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
		{
			*pusTableState = SBIT_BLOC_FOUND;       /* exact match */
		}
		else                                        /* if bloc and NO match */
		{
			ReturnCode = sfac_GetDataPtr (
				pClientInfo,                        /* callback etc. */
				0L,                                 /* table start */
				ULONG_MAX,                          /* read whole table */
				sfnt_BitmapScale,                   /* registered tag */
				FALSE,                              /* doesn't have to be there */
				(const void**)&pbyBsca );           /* data pointer */
			
			if (ReturnCode != NO_ERR) return ReturnCode;
			
			if (pbyBsca != NULL)                    /* if bsca exists */
			{
				if (FindBscaStrike (pbyBsca, usPpemX, usPpemY, pulStrikeOffset))
				{
					*pusSubPpemX = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMX];
					*pusSubPpemY = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMY];
					
					if (FindBlocStrike (pbyBloc, *pusSubPpemX, *pusSubPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
					{
						*pusTableState = SBIT_BSCA_FOUND;
					}
				}
				RELEASESFNTFRAG(pClientInfo, pbyBsca );
			}
		}
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
	}
	return NO_ERR;
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bloc table */

FS_PRIVATE boolean FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	uint32          ulColorRefOffset;
	uint16			usPreferedBitDepth, usBestBitDepth, usCurrentBitDepth;
	uint16			usSbitBitDepthMask;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
	ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

	usBestBitDepth = 0;
	
	if (usOverScale == 0)
	{
		usPreferedBitDepth = 1;
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & 0x0002; /* accept only black/white bitmap */
	} else 
	{
		if (usOverScale == 2)
		{
			usPreferedBitDepth = 2;
		} else if (usOverScale == 4) 
		{
			usPreferedBitDepth = 4;
		} else
		{
			usPreferedBitDepth = 8;
		}
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & ~0x0002; /* accept only grayscale bitmap */
	} 

	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpemY == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
			ulColorRefOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_COLORREF]));
			usCurrentBitDepth = pbyBloc[ulStrikeOffset + SFNT_BLOC_BITDEPTH];

			if (((0x01 << usCurrentBitDepth) & usSbitBitDepthMask) && (ulColorRefOffset == 0L))
			{
				if (usCurrentBitDepth == usPreferedBitDepth)
				{
					/* perfect match */
					*pulStrikeOffset = ulStrikeOffset;
					*pusBitDepth = usPreferedBitDepth;
					return TRUE;      
				} else if (usCurrentBitDepth > usPreferedBitDepth)
				{
					/* above is better than below */
					if ((usCurrentBitDepth < usBestBitDepth) || (usBestBitDepth < usPreferedBitDepth))
					{
						/* above and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				} else /* if (usCurrentBitDepth < usPreferedBitDepth) */
				{
					/* we look below the prefered only if we don't have found anything above */
					if ((usBestBitDepth < usPreferedBitDepth) && (usCurrentBitDepth > usBestBitDepth))
					{
						/* below and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				}
			}
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	if (usBestBitDepth != 0)
	{
		*pusBitDepth = usBestBitDepth;
		return TRUE;                                   /* best match found */
	} 

	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bsca table */

FS_PRIVATE boolean FindBscaStrike (
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBsca[SFNT_BSCA_NUMSIZES]));
	ulStrikeOffset = SFNT_BSCA_FIRSTSTRIKE;
								
	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMX]) &&
			(usPpemY == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMY]))
		{
			*pulStrikeOffset = ulStrikeOffset;
			return TRUE;                            /* match found */
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BSCA_SIZESUBTABLE;
	}
	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Look for a glyph in a given strike */        

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,                   /* return values */
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength )
{
	const uint8 *   pbyBloc;
	ErrorCode       ReturnCode;

	uint32      ulNumIndexTables;
	uint32      ulIndexArrayTop;
	uint32      ulIndexArrayOffset;
	uint32      ulSubTableOffset;
	uint32      ulGlyphOffset;
	uint32      ulNextGlyphOffset;
	uint32      ulBitmapLength;
	uint32      ulImageDataOffset;
	uint32      ulNumGlyphs;
	uint32      ulTop;                      /* binary search ranges */
	uint32      ulBottom;
	uint32      ulHit;
	uint32      ulHitOffset;

	uint16      usStartGlyph;               /* for whole strike */
	uint16      usEndGlyph;
	uint16      usFirstGlyph;               /* for one sub table */
	uint16      usLastGlyph;
	uint16      usIndexFormat;
	uint16      usImageFormat;
	uint16      usHitCode;
	
	bitmapFlags bmfDirection;               /* horiz or vert */

	
	*pbGlyphFound = FALSE;                              /* default */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                    /* callback etc. */
		0L,                                             /* table start */
		ULONG_MAX,                                      /* read whole table */
		sfnt_BitmapLocation,                            /* registered tag */
		TRUE,                                           /* better be there now */
		(const void**)&pbyBloc );                       /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
		
	usStartGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_STARTGLYPH]));
	usEndGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_ENDGLYPH]));

	if ((usStartGlyph > usGlyphCode) || (usEndGlyph < usGlyphCode))
	{
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
		return NO_ERR;                                  /* glyph out of range */
	}

	ulNumIndexTables = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_NUMINDEXTABLES]));
	ulIndexArrayTop = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_INDEXARRAYOFFSET]));
	ulIndexArrayOffset = ulIndexArrayTop;

	while ((ulNumIndexTables > 0) && (*pbGlyphFound == FALSE))
	{
		usFirstGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_FIRSTGLYPH]));
		usLastGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_LASTGLYPH]));
	
		if ((usFirstGlyph <= usGlyphCode) && (usLastGlyph >= usGlyphCode))
		{
			ulSubTableOffset = ulIndexArrayTop +
				(uint32)SWAPL(*((uint32*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_ADDITIONALOFFSET]));
			
			usIndexFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_INDEXFORMAT]));
			usImageFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEFORMAT]));
			ulImageDataOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEOFFSET]));

/* decode the individual index subtable formats */            

			switch(usIndexFormat)                       /* different search req's */
			{
			case 1:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint32) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint32);
				ulNextGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 2:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX2IMAGESIZE]));
				ulImageDataOffset += ulBitmapLength * (usGlyphCode - usFirstGlyph);
				*pulBitmapOffset = ulImageDataOffset;
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX2METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				break;
			
			case 3:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint16) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint16);
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 4:
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX4NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX4OFFSETARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					}
				}
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4OFFSET]));
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SIZEOF_CODEOFFSETPAIR + SFNT_BLOC_IDX4OFFSET]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;
				
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 5:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5IMAGESIZE]));
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX5METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX5CODEARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
					}
				}
				ulImageDataOffset += ulBitmapLength * ulHit;
				*pulBitmapOffset = ulImageDataOffset;
				break;
			
			
			default:
				
				RELEASESFNTFRAG(pClientInfo, pbyBloc);
				return NO_ERR;                          /* unknown format */
			}

/* use the glyph formats to calculate metrics type & data offsets */
				
			*pulBitmapLength = ulBitmapLength;
			*pusBitmapFormat = usImageFormat;           /* save for bitmap decoding */
			bmfDirection = (bitmapFlags)pbyBloc[ulStrikeOffset + SFNT_BLOC_FLAGS];

			switch(usImageFormat)                       /* different metrics sizes */
			{
			case 1:                                     /* small glyph metrics */
			case 2:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 3:
				break;
			
			case 4:
				break;
			
			case 5:             /* bitmap offset and metrics type set above */
				*pbGlyphFound = TRUE;
				break;
			
			case 6:
			case 7:
			case 9:
				*pusMetricsType = SBIT_BIG_METRICS;
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_BIGMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 8:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS + SIZEOF_SBIT_GLYPH8PAD;
				*pbGlyphFound = TRUE;
				break;

			default:
				break;
			}
		}
		ulNumIndexTables--;    
		ulIndexArrayOffset += SIZEOF_BLOC_INDEXARRAY;
	}
	
	RELEASESFNTFRAG(pClientInfo, pbyBloc);
	return NO_ERR;
}


/**********************************************************************/

/* fetch the horizontal metrics */

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound ) /* NEW */
{
	const uint8     *pbyTable;
	uint32          ulTableLength;
	sfnt_tableIndex TableIndex;
	ErrorCode       ReturnCode;

	*pbHorMetricsFound = FALSE;                        /* default */
	*pbVertMetricsFound = FALSE;                        /* default */

	if (usMetricsTable == SBIT_BDAT_TABLE)          /* if metrics in bdat */
	{
		TableIndex = sfnt_BitmapData;
	}
	else                                            /* if metrics in bloc */
	{
		TableIndex = sfnt_BitmapLocation;
	}
	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
		ulTableLength = SIZEOF_SBIT_BIGMETRICS;
	}
	else                                            /* if only h or v metrics */
	{
		ulTableLength = SIZEOF_SBIT_SMALLMETRICS;
	}

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulMetricsOffset,                            /* metrics start */
		ulTableLength,                              /* read just metrics */
		TableIndex,                                 /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

/*  for horizontal metrics, offsets could be different for big & small */

	*pusHeight = (uint16)pbyTable[SFNT_SBIT_HEIGHT];
	*pusWidth = (uint16)pbyTable[SFNT_SBIT_WIDTH];

	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_VERTADVANCE];
		*pbHorMetricsFound = TRUE;                        
		*pbVertMetricsFound = TRUE;                     
	}
	else if (usMetricsType == SBIT_HORIZ_METRICS)   
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbHorMetricsFound = TRUE;                        
	}
	else /* if (usMetricsType == SBIT_VERT_METRICS) */  
	{
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbVertMetricsFound = TRUE;                     
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

	return NO_ERR;
}

/**********************************************************************/

/* shave the white space from horizontal metrics for bitmap format 5 */

#define     ROWSIZE     16                      /* 16 bytes = 128 bits max */

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY) /* NEW */
{
    uint8           abyBitRow[ROWSIZE];         /* or bitmap into one row */
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
    uint8           *pbyBitMap;
    uint8           byMask;
    uint8           byUpMask;
    uint8           byLowMask;
	uint16          usBitData;
	uint16          usFreshBits;
	uint16       	usOutBits;
	uint16       	usRow;
	uint16       	usStopBit;
    uint16          usShaveLeft;
    uint16          usShaveRight;
    uint16          usShaveTop;
    uint16          usShaveBottom;
	uint16          usStart;
	ErrorCode       ReturnCode;
	boolean			bWeGotBlackPixels;				/* used in vertical shaving */
	uint8			byBlackPixelsInCurrentRaw;		/* used in vertical shaving */
	uint8			byTempBuffer;		/* temporary buffer used to detect the first/last row containing black pixels */

    *pusShaveLeft = 0;                          /* defaults */
    *pusShaveRight = 0;
    *pusShaveTop = 0;                          /* defaults */
    *pusShaveBottom = 0;

    if (usBitmapFormat != 5)                    /* if not constant metrics data */
    {
        return NO_ERR;
    }

    if ((*pusWidth * usBitDepth) > (ROWSIZE << 3))
    {
    	return NO_ERR;                          /* punt huge bitmaps */
    }
    
    MEMSET(abyBitRow, 0, ROWSIZE);              /* clear to zeros */

/*      read the bitmap data    */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                            /* callback etc. */
		ulBitmapOffset,                         /* metrics start */
		ulBitmapLength,                         /* read bitmap data */
		sfnt_BitmapData,                        /* registered tag */
		TRUE,                                   /* should be there */
		(const void**)&pbyTable );              /* data pointer */

	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	usBitData = 0;                              /* up to 16 bits of bdat */
	usFreshBits = 0;                            /* read & unwritten */

	bWeGotBlackPixels = FALSE;					/* used for vertical shaving */
	usShaveTop = 0;
	usShaveBottom = 0;


/*      'or' the bitmap data into a single row    */    
	usRow = *pusHeight;

    while (usRow > 0)
	{
		pbyBitMap = abyBitRow;
		usOutBits = *pusWidth * usBitDepth;
		usStopBit = 8;
		byBlackPixelsInCurrentRaw = 0;

		while (usOutBits > 0)                   /* if more to do */
		{
			if (usFreshBits < 8)                /* if room for fresh data */
			{
				usBitData <<= 8;
                if (ulBitmapLength > 0)         /* prevent read past data end */
                {
                    usBitData |= (uint16)*pbyBdat++;
                    ulBitmapLength--;
                }
				usFreshBits += 8;
			}
			
			if (usStopBit > usOutBits)
			{
				usStopBit = usOutBits;
			}
			byMask = achStopMask[usStopBit];
			
			byTempBuffer = (uint8)((usBitData >> (usFreshBits - 8)) & byMask);

			byBlackPixelsInCurrentRaw |= byTempBuffer;

			*pbyBitMap++ |= byTempBuffer;

			usFreshBits -= usStopBit;
			usOutBits -= usStopBit;
		}
		if (byBlackPixelsInCurrentRaw != 0)
		{
			bWeGotBlackPixels = TRUE;
			usShaveBottom = usRow-1;
		}
		if (!bWeGotBlackPixels) usShaveTop ++;
        usRow--;
	}

	if (usShaveTop == *pusHeight)
	{
		/* the bitmap is completely white */
		usShaveTop = 0;
		usShaveBottom = 0;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

/*      calculate white space on the left    */
    
    pbyBitMap = abyBitRow;
	if (usBitDepth == 1)
	{
		byUpMask = 0x80;
		byLowMask = 0x01;
	} else if (usBitDepth == 2)
	{
		byUpMask = 0xC0;
		byLowMask = 0x03;
	} else if (usBitDepth == 4)
	{
		byUpMask = 0xF0;
		byLowMask = 0x0F;
	} else /* usBitDepth == 8 */
	{
		byUpMask = 0xFF;
		byLowMask = 0xFF;
	}
	byMask = byUpMask;
    usShaveLeft = 0;

    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveLeft++;
        if (usShaveLeft == *pusWidth)
        {
            return NO_ERR;          /* no black found, don't shave */
        }
        byMask >>= usBitDepth;
        if (byMask == 0)
        {
            byMask = byUpMask;
            pbyBitMap++;
        }
    }

/*      calculate white space on the right    */
    
    usStart = (*pusWidth - 1) * usBitDepth;
    pbyBitMap = &abyBitRow[usStart >> 3];
    byMask = byUpMask >> (usStart & 0x0007);
    usShaveRight = 0;
    
    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveRight++;
        if (byMask == byUpMask)
        {
            byMask = byLowMask;
            pbyBitMap--;
        }
        else
        {
            byMask <<= usBitDepth;
        }
    }

/*      correct the width and sidebearing    */

    *pusShaveLeft = usShaveLeft;
    *pusShaveRight = usShaveRight;
    *pusWidth -= usShaveLeft + usShaveRight;
    *psLSBearingX += (int16)usShaveLeft;
    *psTopSBearingX += (int16)usShaveLeft;

	*pusShaveTop = usShaveTop;
    *pusShaveBottom = usShaveBottom;
    *pusHeight -= usShaveTop + usShaveBottom;
    *psLSBearingY -= (int16)usShaveTop;
    *psTopSBearingY -= (int16)usShaveTop;

	return NO_ERR;
}


/**********************************************************************/


/* fetch the bitmap */

/*  Currently supporting the following bdat formats:
	
	1 - Small metrics;  Byte aligned data
	2 - Small metrics;  Bit aligned data
	5 - Const metrics;  Bit aligned data
	6 - Big metrics;    Byte aligned data
	7 - Big metrics;    Bit aligned data
	8 - Small metrics;  Composite data
	9 - Big metrics;    Composite data
*/

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,                             /* for white space in fmt 5 */
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usDstRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount )
{
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
	uint8           *pbyBitRow;                     /* start of bitmap row */

	uint16          usSrcRowBytes;                  /* bytes per row in bdat */
	ErrorCode       ReturnCode;

	uint16          usBitData;                      /* bdat data read into 16 bits */
	uint16          usOutBits;                      /* num of bits to put to bitmap */
	uint16          usCount;
	uint16          usXOffBytes;
	uint16          usXOffBits;
	uint16          usStartBit;
	uint16          usStopBit;
	int16           sFreshBits;                     /* num of bits read not written */
	uint8           byMask;                         /* for partial bytes */
	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	*pusCompCount = 0;                              /* usual case */
	
	pbyBitRow = pbyBitMap + (usDstRowBytes * usYOffset);
	usXOffBytes = (usXOffset * usBitDepth) >> 3;
	usXOffBits = (usXOffset * usBitDepth) & 0x07;

	switch(usBitmapFormat)
	{
	case 1:                                         /* byte aligned */
	case 6:
		
		usSrcRowBytes = ((usWidth * usBitDepth) + 7) / 8;

		if (usXOffBits == 0)                         /* if byte aligned */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					*pbyBitMap++ |= *pbyBdat++;
				}
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		else                                        /* if offset in x */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
				usBitData = 0;

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					usBitData |= (uint16)*pbyBdat++;
					*pbyBitMap++ |= (usBitData >> usXOffBits) & 0x00FF;
					usBitData <<= 8;
				}
				*pbyBitMap |= (usBitData >> usXOffBits) & 0x00FF;
							 
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		break;
	
	case 2:                                         /* bit aligned data */
	case 5:
	case 7:
		
		usBitData = 0;                              /* up to 16 bits of bdat */
		sFreshBits = 0;                             /* read & unwritten */
	
		usHeight += usShaveTop;

		while (usHeight > 0)                        /* for each row */
		{
			pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
			usOutBits = usWidth * usBitDepth;
			usStartBit = usXOffBits;
			usStopBit = 8;
			sFreshBits -= (int16)usShaveLeft * usBitDepth;       /* skip the left white bits */

			while (usOutBits > 0)                   /* if more to do */
			{
				while (sFreshBits < 8)              /* if room for fresh data */
				{
					usBitData <<= 8;
					if (ulBitmapLength > 0)         /* prevent read past data end */
					{
						usBitData |= (uint16)*pbyBdat++;
						ulBitmapLength--;
					}
					sFreshBits += 8;
				}
				
				if (usStopBit > usOutBits + usStartBit)
				{
					usStopBit = usStartBit + usOutBits;
				}
				byMask = achStartMask[usStartBit] & achStopMask[usStopBit];
				
				*pbyBitMap++ |= (uint8)((usBitData >> (sFreshBits + (int16)usStartBit - 8)) & byMask);

				sFreshBits -= (int16)(usStopBit - usStartBit);
				usOutBits -= usStopBit - usStartBit;
				usStartBit = 0;
			}
			sFreshBits -= (int16)usShaveRight*usBitDepth;      /* skip the right white bits */

			if (usShaveTop == 0)
			{
				pbyBitRow += usDstRowBytes;             /* next row */
			} else {
				usShaveTop --;
			}
			usHeight--;
		}
		break;
	
	case 3:                                         /* various */
	case 4:
		break;
	
	case 8:                                         /* composites */
	case 9:                                         /* just return count */
		
		*pusCompCount = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPCOUNT]));
		break;
	
	default:
		Assert(FALSE);
		break;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
)
{
	const uint8 *   pbyBdat;
	ErrorCode       ReturnCode;

	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyBdat );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat += SFNT_BDAT_FIRSTCOMP + (SIZEOF_SBIT_BDATCOMPONENT * usComponent);
		
	*pusCompGlyphCode = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPGLYPH]));
	*pusCompXOffset = (uint16)pbyBdat[SFNT_BDAT_COMPXOFF];
	*pusCompYOffset = (uint16)pbyBdat[SFNT_BDAT_COMPYOFF];

	RELEASESFNTFRAG(pClientInfo, pbyBdat);

	return NO_ERR;
}

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\sfnt.h ===
/*
	File:       sfnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	            (c) 1989-1999 by Microsoft Corporation.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <3>    02/21/97    CB      ClaudeBe, add flags for scaled composite offset compatibility
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Remove unneeded tables from sfnt_tableIndex. [rb]
		<12>     7/18/90    MR      platform and specific should always be unsigned
		<11>     7/14/90    MR      removed duplicate definitions of int[8,16,32] etc.
		<10>     7/13/90    MR      Minor type changes, for Ansi-C
		 <9>     6/29/90    RB      revise postscriptinfo struct
		 <7>      6/4/90    MR      Remove MVT
		 <6>      6/1/90    MR      pad postscriptinfo to long word aligned
		 <5>     5/15/90    MR      Add definition of PostScript table
		 <4>      5/3/90    RB      mrr     Added tag for font program 'fpgm'
		 <3>     3/20/90    CL      chucked old change comments from EASE
		 <2>     2/27/90    CL      getting bbs headers
	   <3.1>    11/14/89    CEL     Instructions are legal in components.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
		<3+>     3/20/90    mrr     Added tag for font program 'fpgm'
*/

#pragma pack(1)

#ifndef SFNT_DEFINED
#define SFNT_DEFINED

#include "fscdefs.h" // DO NOT REMOVE
#include "sfnt_en.h"

typedef struct {
	uint32 bc;
	uint32 ad;
} BigDate;

typedef struct {
	sfnt_TableTag   tag;
	uint32          checkSum;
	uint32          offset;
	uint32          length;
} sfnt_DirectoryEntry;

/*
 *  The search fields limits numOffsets to 4096.
 */
typedef struct {
	int32 version;                  /* 0x10000 (1.0) */
	uint16 numOffsets;              /* number of tables */
	uint16 searchRange;             /* (max2 <= numOffsets)*16 */
	uint16 entrySelector;           /* log2 (max2 <= numOffsets) */
	uint16 rangeShift;              /* numOffsets*16-searchRange*/
	sfnt_DirectoryEntry table[1];   /* table[numOffsets] */
} sfnt_OffsetTable;
#define OFFSETTABLESIZE     12  /* not including any entries */

/*
 *  for the flags field
 */
#define Y_POS_SPECS_BASELINE            0x0001
#define X_POS_SPECS_LSB                 0x0002
#define HINTS_USE_POINTSIZE             0x0004
#define USE_INTEGER_SCALING             0x0008
#define INSTRUCTED_ADVANCE_WIDTH        0x0010

/* flags 5-10 defined by Apple */
#define APPLE_VERTICAL_LAYOUT           0x0020
#define APPLE_RESERVED                  0x0040
#define APPLE_LINGUISTIC_LAYOUT         0x0080
#define APPLE_GX_METAMORPHOSIS          0x0100
#define APPLE_STRONG_RIGHT_TO_LEFT      0x0200
#define APPLE_INDIC_EFFECT              0x0400

#define FONT_COMPRESSED                 0x0800
#define FONT_CONVERTED                  0x1000

#define OUTLINE_CORRECT_ORIENTATION     0x4000
#define SFNT_MAGIC 0x5F0F3CF5

#define SHORT_INDEX_TO_LOC_FORMAT       0
#define LONG_INDEX_TO_LOC_FORMAT        1
#define GLYPH_DATA_FORMAT               0

typedef struct {
	Fixed       version;            /* for this table, set to 1.0 */
	Fixed       fontRevision;       /* For Font Manufacturer */
	uint32      checkSumAdjustment;
	uint32      magicNumber;        /* signature, should always be 0x5F0F3CF5  == MAGIC */
	uint16      flags;
	uint16      unitsPerEm;         /* Specifies how many in Font Units we have per EM */

	BigDate     created;
	BigDate     modified;

	/** This is the font wide bounding box in ideal space
 (baselines and metrics are NOT worked into these numbers) **/
	FUnit       xMin;
	FUnit       yMin;
	FUnit       xMax;
	FUnit       yMax;

	uint16      macStyle;               /* macintosh style word */
	uint16      lowestRecPPEM;          /* lowest recommended pixels per Em */

	/* 0: fully mixed directional glyphs, 1: only strongly L->R or T->B glyphs, 
	   -1: only strongly R->L or B->T glyphs, 2: like 1 but also contains neutrals,
	   -2: like -1 but also contains neutrals */
	int16       fontDirectionHint;

	int16       indexToLocFormat;
	int16       glyphDataFormat;
} sfnt_FontHeader;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */

	FUnit       yAscender;
	FUnit       yDescender;
	FUnit       yLineGap;       /* Recommended linespacing = ascender - descender + linegap */
	uFUnit      advanceWidthMax;
	FUnit       minLeftSideBearing;
	FUnit       minRightSideBearing;
	FUnit       xMaxExtent; /* Max of (LSBi + (XMAXi - XMINi)), i loops through all glyphs */

	int16       horizontalCaretSlopeNumerator;
	int16       horizontalCaretSlopeDenominator;

	uint16      reserved0;
	uint16      reserved1;
	uint16      reserved2;
	uint16      reserved3;
	uint16      reserved4;

	int16       metricDataFormat;           /* set to 0 for current format */
	uint16      numberOf_LongHorMetrics;    /* if format == 0 */
} sfnt_HorizontalHeader;

typedef struct {
	uint16      advanceWidth;
	int16       leftSideBearing;
} sfnt_HorizontalMetrics;

typedef struct {
	uint16      advanceHeight;
	int16       topSideBearing;
} sfnt_VerticalMetrics;

/*
 *  CVT is just a bunch of int16s
 */
typedef int16 sfnt_ControlValue;

/*
 *  Char2Index structures, including platform IDs
 */
typedef struct {
	uint16  format;
	uint16  length;
	uint16  version;
} sfnt_mappingTable;

typedef struct {
	uint16  platformID;
	uint16  specificID;
	uint32  offset;
} sfnt_platformEntry;

typedef struct {
	uint16  version;
	uint16  numTables;
	sfnt_platformEntry platform[1]; /* platform[numTables] */
} sfnt_char2IndexDirectory;
#define SIZEOFCHAR2INDEXDIR     4

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  int16   idDelta;
  uint16  idRangeOffset;
} sfnt_subHeader2;

typedef struct {
  uint16            subHeadersKeys [256];
  sfnt_subHeader2   subHeaders [1];
} sfnt_mappingTable2;

typedef struct {
  uint16  segCountX2;
  uint16  searchRange;
  uint16  entrySelector;
  uint16  rangeShift;
  uint16  endCount[1];
} sfnt_mappingTable4;

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  uint16  glyphIdArray [1];
} sfnt_mappingTable6;

typedef struct {
	uint16 platformID;
	uint16 specificID;
	uint16 languageID;
	uint16 nameID;
	uint16 length;
	uint16 offset;
} sfnt_NameRecord;

typedef struct {
	uint16 format;
	uint16 count;
	uint16 stringOffset;
/*  sfnt_NameRecord[count]  */
} sfnt_NamingTable;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} sfnt_maxProfileTable;

typedef struct {
  int16       numberOfContours;
  BBOX        bbox;
  int16       endPoints[1];
} sfnt_PackedSplineFormat;

#define DEVEXTRA    2   /* size + max */
/*
 *  Each record is n+2 bytes, padded to long word alignment.
 *  First byte is ppem, second is maxWidth, rest are widths for each glyph
 */
typedef struct {
	int16               version;
	int16               numRecords;
	int32               recordSize;
	/* Byte widths[numGlyphs+2] * numRecords */
} sfnt_DeviceMetrics;

#ifdef UNNAMED_UNION        /* Anonymous unions are supported */
#define postScriptNameIndices   /* by some C implementations,  */
#endif              /* but they are not portable. */

typedef struct {
	Fixed   version;                /* 1.0 */
	Fixed   italicAngle;
	FUnit   underlinePosition;
	FUnit   underlineThickness;
	uint32  isFixedPitch;
	uint32  minMemType42;
	uint32  maxMemType42;
	uint32  minMemType1;
	uint32  maxMemType1;

	uint16  numberGlyphs;
	union
	{
	  uint16  glyphNameIndex[1];   /* version == 2.0 */
	  int8    glyphNameIndex25[1]; /* version == 2.5 */
	} postScriptNameIndices;
} sfnt_PostScriptInfo;

#ifdef postScriptNameIndices
#undef postScriptNameIndices
#endif 

typedef struct {
	uint16  Version;
	int16   xAvgCharWidth;
	uint16  usWeightClass;
	uint16  usWidthClass;
	int16   fsType;
	int16   ySubscriptXSize;
	int16   ySubscriptYSize;
	int16   ySubscriptXOffset;
	int16   ySubscriptYOffset;
	int16   ySuperScriptXSize;
	int16   ySuperScriptYSize;
	int16   ySuperScriptXOffset;
	int16   ySuperScriptYOffset;
	int16   yStrikeOutSize;
	int16   yStrikeOutPosition;
	int16   sFamilyClass;
	uint8   Panose [10];
	uint32  ulCharRange [4];
	char    achVendID [4];
	uint16  usSelection;
	uint16  usFirstChar;
	uint16  usLastChar;
	int16   sTypoAscender;
	 int16  sTypoDescender;
	int16   sTypoLineGap;
	int16   sWinAscent;
	int16   sWinDescent;
	uint32  ulCodePageRange[2];
} sfnt_OS2;

typedef struct
{
	uint8   bEmY;
	uint8   bEmX;
	uint8   abInc[1];
} sfnt_hdmxRecord;

typedef struct
{
	uint16          Version;
	int16           sNumRecords;
	int32           lSizeRecord;
	sfnt_hdmxRecord HdmxTable;
} sfnt_hdmx;

typedef struct
{
	uint16    Version;
	uint16    usNumGlyphs;
	uint8     ubyPelsHeight;
} sfnt_LTSH;

typedef struct
{
	uint16          rangeMaxPPEM;
	uint16          rangeGaspBehavior;
} sfnt_gaspRange;

typedef struct
{
	uint16          version;
	uint16          numRanges;
	sfnt_gaspRange  gaspRange[1];
} sfnt_gasp;

/* various typedef to access to the sfnt data */

typedef sfnt_OffsetTable          *sfnt_OffsetTablePtr;
typedef sfnt_FontHeader           *sfnt_FontHeaderPtr;
typedef sfnt_HorizontalHeader     *sfnt_HorizontalHeaderPtr;
typedef sfnt_maxProfileTable      *sfnt_maxProfileTablePtr;
typedef sfnt_ControlValue         *sfnt_ControlValuePtr;
typedef sfnt_char2IndexDirectory  *sfnt_char2IndexDirectoryPtr;
typedef sfnt_HorizontalMetrics    *sfnt_HorizontalMetricsPtr;
typedef sfnt_VerticalMetrics      *sfnt_VerticalMetricsPtr;
typedef sfnt_platformEntry        *sfnt_platformEntryPtr;
typedef sfnt_NamingTable          *sfnt_NamingTablePtr;
typedef sfnt_OS2                  *sfnt_OS2Ptr;
typedef sfnt_DirectoryEntry       *sfnt_DirectoryEntryPtr;
typedef sfnt_PostScriptInfo       *sfnt_PostScriptInfoPtr;
typedef sfnt_gasp                 *sfnt_gaspPtr;

/*
 * 'gasp' Table Constants
*/

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002


/*
 * UNPACKING Constants
*/
/*define ONCURVE                 0x01   defined in FSCDEFS.H    */
#define XSHORT              0x02
#define YSHORT              0x04
#define REPEAT_FLAGS        0x08 /* repeat flag n times */
/* IF XSHORT */
#define SHORT_X_IS_POS      0x10 /* the short vector is positive */
/* ELSE */
#define NEXT_X_IS_ZERO      0x10 /* the relative x coordinate is zero */
/* ENDIF */
/* IF YSHORT */
#define SHORT_Y_IS_POS      0x20 /* the short vector is positive */
/* ELSE */
#define NEXT_Y_IS_ZERO      0x20 /* the relative y coordinate is zero */
/* ENDIF */
/* 0x40 & 0x80              RESERVED
** Set to Zero
**
*/

/*
 * Composite glyph constants
 */
#define COMPONENTCTRCOUNT           -1      /* ctrCount == -1 for composite */
#define ARG_1_AND_2_ARE_WORDS       0x0001  /* if set args are words otherwise they are bytes */
#define ARGS_ARE_XY_VALUES          0x0002  /* if set args are xy values, otherwise they are points */
#define ROUND_XY_TO_GRID            0x0004  /* for the xy values if above is true */
#define WE_HAVE_A_SCALE             0x0008  /* Sx = Sy, otherwise scale == 1.0 */
#define NON_OVERLAPPING             0x0010  /* set to same value for all components */
#define MORE_COMPONENTS             0x0020  /* indicates at least one more glyph after this one */
#define WE_HAVE_AN_X_AND_Y_SCALE    0x0040  /* Sx, Sy */
#define WE_HAVE_A_TWO_BY_TWO        0x0080  /* t00, t01, t10, t11 */
#define WE_HAVE_INSTRUCTIONS        0x0100  /* instructions follow */
#define USE_MY_METRICS              0x0200  /* apply these metrics to parent glyph */
#define OVERLAP_COMPOUND			0x0400  /* used by Apple in GX fonts */
#define SCALED_COMPONENT_OFFSET     0x0800  /* composite designed to have the component offset scaled (designed for Apple) */
#define UNSCALED_COMPONENT_OFFSET   0x1000  /* composite designed not to have the component offset scaled (designed for MS) */

/*
 *  Private enums for tables used by the scaler.  See sfnt_Classify
 */
typedef enum {
	sfnt_fontHeader,
	sfnt_horiHeader,
	sfnt_indexToLoc,
	sfnt_maxProfile,
	sfnt_controlValue,
	sfnt_preProgram,
	sfnt_glyphData,
	sfnt_horizontalMetrics,
	sfnt_charToIndexMap,
	sfnt_fontProgram,
	sfnt_Postscript,
	sfnt_HoriDeviceMetrics,
	sfnt_LinearThreshold,
	sfnt_Names,
	sfnt_OS_2,
	sfnt_GlyphDirectory,
	sfnt_BitmapData,
	sfnt_BitmapLocation,
	sfnt_BitmapScale,
	sfnt_vertHeader,
	sfnt_verticalMetrics,
	sfnt_BeginningOfFont,       /* References the beginning of memory   */
	sfnt_NUMTABLEINDEX
} sfnt_tableIndex;

#endif
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\stat.h ===
/*********************************************************************/
/*                                                                   */
/*    stat.h -- stat.asm exports                                     */
/*                                                                   */
/*    (c) Copyright 1992  Microsoft Corp.  All rights reserved.      */
/*                                                                   */
/*     4/9/96  claudebe adding profiling with IceCAP                 */
/*     2/26/93 deanb    macros come back                             */
/*     2/22/93 deanb    timing switch moved to fsconfig.h macros     */
/*     2/11/93 deanb    __cdecl's for ms C8                          */
/*    12/22/92 deanb    Apple types                                  */
/*    11/20/92 deanb    Timing switches revised                      */
/*    11/17/92 deanb    First cut                                    */
/*                                                                   */
/*********************************************************************/

/* STAT Card Timing Switches */

#ifdef FSCFG_USESTATCARD         /* compile option for profiling */
  #define STAT_ON               gbTimer = TRUE; StartSample();
  #define STAT_OFF              StopSample(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) StartSample();
  #define STAT_OFF_CALLBACK     if (gbTimer) StopSample();
#elif FSCFG_USEICECAP          /* compile option for profiling with IceCAP */
//#include <ICAPExp.h>
  #define STAT_ON               gbTimer = TRUE; StartCAP();
  #define STAT_OFF              StopCAP(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) ResumeCAP();
  #define STAT_OFF_CALLBACK     if (gbTimer) SuspendCAP();
#else
  #define STAT_ON
  #define STAT_OFF
  #define STAT_ON_CALLBACK
  #define STAT_OFF_CALLBACK
#endif

#if 1

#define STAT_ON_NEWSFNT         STAT_ON
#define STAT_OFF_NEWSFNT        STAT_OFF
#define STAT_ON_NEWTRAN         STAT_ON
#define STAT_OFF_NEWTRAN        STAT_OFF
#define STAT_ON_NEWGLYPH        STAT_ON
#define STAT_OFF_NEWGLYPH       STAT_OFF
#define STAT_ON_GRIDFIT         STAT_ON
#define STAT_OFF_GRIDFIT        STAT_OFF
#define STAT_ON_FINDBMS         STAT_ON
#define STAT_OFF_FINDBMS        STAT_OFF
#define STAT_ON_SCAN            STAT_ON
#define STAT_OFF_SCAN           STAT_OFF
#define STAT_ON_FNTEXEC         
#define STAT_OFF_FNTEXEC        
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#else

#define STAT_ON_NEWSFNT
#define STAT_OFF_NEWSFNT
#define STAT_ON_NEWTRAN
#define STAT_OFF_NEWTRAN
#define STAT_ON_NEWGLYPH
#define STAT_OFF_NEWGLYPH
#define STAT_ON_GRIDFIT         STAT_ON         
#define STAT_OFF_GRIDFIT        STAT_OFF         
#define STAT_ON_FINDBMS   
#define STAT_OFF_FINDBMS  
#define STAT_ON_SCAN            
#define STAT_OFF_SCAN           
#define STAT_ON_FNTEXEC
#define STAT_OFF_FNTEXEC
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#endif

/*********************************************************************/

/*              Global timing variable                               */

/*********************************************************************/

extern boolean gbTimer;                /* set true when timer running */

/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


#ifdef FSCFG_USESTATCARD         /* compile option for profiling */

uint16 __cdecl  InitStat( void );

uint16 __cdecl  ConfigElapsed( void );

uint16 __cdecl  ConfigSample( void );

uint16 __cdecl  StartElapsed( void );

uint16 __cdecl  StartSample( void );

uint32 __cdecl  ReadElapsed( void );

uint32 __cdecl  ReadSample( void );

uint16 __cdecl  ReadSample_Count( void );

uint16 __cdecl  StopElapsed( void );

uint16 __cdecl  StopSample( void );

uint16 __cdecl  ResetElapsed( void );

uint16 __cdecl  ResetSample( void );

#endif  /* FSCFG_USESTATCARD */

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\scspline.h ===
/*********************************************************************

	  scspline.h -- Spline Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTATE added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetSplineElemSize returns size_t 
	   9/08/92 deanb    MAXSPLINELENGTH added 
	   8/17/92 deanb    PowerOf2 moved to math 
	   7/23/92 deanb    EvaluateSpline replaced with CalcSpline + PowerOf2 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/14/92 deanb    First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupSpline ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcSpline( 
		PSTATE          /* pointer to state varables */
		F26Dot6,        /* start point x coordinate */
		F26Dot6,        /* start point y coordinate */
		F26Dot6,        /* control point x coordinate */
		F26Dot6,        /* control point y coordinate */
		F26Dot6,        /* ending x coordinate */
		F26Dot6,        /* ending y coordinate */
		uint16          /* scan control type */
);

/********************************************************************/

/*              Export Definitions                                  */

/********************************************************************/

#define MAXSPLINELENGTH     3200        /* calculation overflow limit */

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\subpixel.c ===
/*********************************************************************

	  subpixel.c -- sub pixel rendering

	  (c) Copyright 1999-2000  Microsoft Corp.  All rights reserved.

 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "scentry.h"             /* for own function prototypes */

#ifdef FSCFG_SUBPIXEL

#ifdef FSCFG_SUBPIXEL_STANDALONE

// this should be considered a temporary solution. currently, the rasterizer is plumbed for 8 bpp output in SubPixel,
// and appears to have John Platt's filter hard-wired in. In the future, we would rather have the overscaled b/w bitmap
// as output, such that we can do any color filtering and gamma correction outside and independent of the rasterizer

// Index values for wRGBColors and awColorIndexTable

#define RED_INDEX	0
#define GREEN_INDEX	1
#define	BLUE_INDEX	2

// The abColorIndexTable datastructure contains one entry for each virtual subpixel.
// We index into this table to determine which color is assigned to that subpixel.
// To create the table, we set the first number of subpixels assigned to red to the red index,
// and likewise for green and blue.

static const uint8 abColorIndexTable[2][RGB_OVERSCALE] = // 2 Tables to indicate color for each subpixel, 0 = RGB striping order, 1 = BGR striping order
	{{RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,														// R_Subpixels, hard-wired
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,	// G_Subpixels, hard-wired
	  BLUE_INDEX, BLUE_INDEX},																						// B_Subpixels, hard-wired
	 {BLUE_INDEX, BLUE_INDEX,
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,
	  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX}};

#define PIXEL_ON	1
#define PIXEL_OFF	0
#define CHAR_BIT	8         /* number of bits in a char */

char GetInputPixel( char *pbyInputRowData, uint32 ulWidthIndex )
{
	uint32	ulRowIndex;
	char	byPixelMask;
	
	ulRowIndex = ulWidthIndex / CHAR_BIT;			// Determines which byte to check out
	byPixelMask = 0x80 >> ulWidthIndex % CHAR_BIT; // Determine offset within byte
	return ( (pbyInputRowData[ ulRowIndex ] & byPixelMask)?PIXEL_ON:PIXEL_OFF );
}


FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
	char byPixel;						// Contents of one pixel from the rasterizer
	uint16 usRGBColors[ 3 ];				// Contains sum of each color based on number of subpixels
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;
    uint32 ulBytes;
	
	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = ulOverscaledBitmapWidth + sBitmapSubPixelStart;

    /* clear the resulting bitmap */
	ulBytes = (uint32)SubPixelBitMap->sRowBytes * (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				
		// Initialize RGBColors

		usRGBColors[RED_INDEX] = 0;
		usRGBColors[GREEN_INDEX] = 0;
		usRGBColors[BLUE_INDEX] = 0;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = sBitmapSubPixelStart; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            byPixel = GetInputPixel( pbyInputRowData, ulWidthIndex - sBitmapSubPixelStart );
			FS_ASSERT((byPixel <= 1),"Input Pixel greater than one");
			usRGBColors[abColorIndexTable[bgrOrder][ulWidthIndex % RGB_OVERSCALE]] += byPixel;

			// If we've finished one pixel or the scanline, write out pixel 

			if((( ulWidthIndex % RGB_OVERSCALE ) == (uint32)(RGB_OVERSCALE - 1)) || // Finish one pixel
				ulWidthIndex == ( ulOverscaledBitmapWidth + sBitmapSubPixelStart - 1) ) // Finish row
			{
                /* write out current pixel, 8 bits in range 0 through 179 = (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) */

                usColorIndex = usRGBColors[RED_INDEX]   * (G_Subpixels + 1) * (B_Subpixels + 1) +
                               usRGBColors[GREEN_INDEX] * (B_Subpixels + 1) +
                               usRGBColors[BLUE_INDEX];

                        FS_ASSERT((usColorIndex < 256),"Resulting pixel doesn't fit in a byte");

                *pbyOutputRowData = (char) usColorIndex;
                pbyOutputRowData++;
				usRGBColors[RED_INDEX] = 0;
				usRGBColors[GREEN_INDEX] = 0;
				usRGBColors[BLUE_INDEX] = 0;
            }
		}
	}
}

#else // !FSCFG_SUBPIXEL_STANDALONE


#define CHAR_BIT      8         /* number of bits in a char */

unsigned char ajRGBToWeight222[64] = {
    0,1,1,2,4,5,5,6,4,5,5,6,8,9,9,10,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    32,33,33,34,36,37,37,38,36,37,37,38,40,41,41,42};

    unsigned char ajRGBToWeightMask[CHAR_BIT] = { 
        0xFC, 0x7E, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01};

FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;

    uint16 usSubPixelIndex;
    int16 uSubPixelRightShift, uSubPixelLeftShift;
    char * pbyInputEndRowData;


	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = (uint32)(SubPixelBitMap->rectBounds.right - SubPixelBitMap->rectBounds.left);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
        pbyInputEndRowData = pbyInputRowData + OverscaledBitmap->sRowBytes;
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				

        /* do the first partial byte : */

        usColorIndex = (unsigned char)(*pbyInputRowData) >> (sBitmapSubPixelStart + (8 - RGB_OVERSCALE));
        usColorIndex = ajRGBToWeight222[usColorIndex];

        *pbyOutputRowData = (char) usColorIndex;

        pbyOutputRowData++;

        usSubPixelIndex = (CHAR_BIT + RGB_OVERSCALE - sBitmapSubPixelStart) % CHAR_BIT;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = 1; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            uSubPixelLeftShift = 0;
            uSubPixelRightShift = CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;
            if (uSubPixelRightShift < 0) 
            {
                uSubPixelLeftShift = - uSubPixelRightShift;
                uSubPixelRightShift = 0;
            }

            usColorIndex = ((unsigned char)(*pbyInputRowData) & ajRGBToWeightMask[usSubPixelIndex]) >> uSubPixelRightShift << uSubPixelLeftShift;

            if (pbyInputRowData+1 < pbyInputEndRowData)
            {
                /* avoid reading too far for the partial pixel at the end */
                uSubPixelRightShift = CHAR_BIT + CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;

                usColorIndex += (unsigned char)(*(pbyInputRowData+1)) >> uSubPixelRightShift;
            }
            usColorIndex = ajRGBToWeight222[usColorIndex];

            *pbyOutputRowData = (char) usColorIndex;

            pbyOutputRowData++;

            usSubPixelIndex = (usSubPixelIndex + RGB_OVERSCALE);
            if (usSubPixelIndex >= CHAR_BIT)
            {
                usSubPixelIndex = usSubPixelIndex % CHAR_BIT;
                pbyInputRowData ++;
            }
		}
	}
}

#endif // FSCFG_SUBPIXEL_STANDALONE

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\sfnt_en.h ===
/*
	File:       sfnt_en.h

	Written by: Mike Reed

	Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

		<8+>     7/16/90    MR      Fixed INTEL version of tag_GlyphData
		 <8>     7/16/90    MR      Conditionalize redefinition of script codes
		 <7>     7/13/90    MR      Conditionalize enums to allow for byte-reversal on INTEL chips
		 <6>     6/30/90    MR      Remove tag reference to 'mvt ' and 'cryp'
		 <4>     6/26/90    MR      Add all script codes, with SM naming conventions
		 <3>     6/20/90    MR      Change tag enums to #defines to be ansi-correct
		 <2>      6/1/90    MR      Add postscript name to sfnt_NameIndex and 'post' to tags.
	To Do:
*/

#ifndef SFNT_ENUMS

#define SFNT_ENUMS

typedef enum {
	plat_Unicode,
	plat_Macintosh,
	plat_ISO,
	plat_MS
} sfnt_PlatformEnum;

#ifndef __SCRIPT__
typedef enum {
	smRoman,
	smJapanese,
	smTradChinese,
	smChinese = smTradChinese,
	smKorean,
	smArabic,
	smHebrew,
	smGreek,
	smCyrillic,
	smRussian = smCyrillic,
	smRSymbol,
	smDevanagari,
	smGurmukhi,
	smGujarati,
	smOriya,
	smBengali,
	smTamil,
	smTelugu,
	smKannada,
	smMalayalam,
	smSinhalese,
	smBurmese,
	smKhmer,
	smThai,
	smLaotian,
	smGeorgian,
	smArmenian,
	smSimpChinese,
	smTibetan,
	smMongolian,
	smGeez,
	smEthiopic = smGeez,
	smAmharic = smGeez,
	smSlavic,
	smEastEurRoman = smSlavic,
	smVietnamese,
	smExtArabic,
	smSindhi = smExtArabic,
	smUninterp
} sfnt_ScriptEnum;
#endif

typedef enum {
	lang_English,
	lang_French,
	lang_German,
	lang_Italian,
	lang_Dutch,
	lang_Swedish,
	lang_Spanish,
	lang_Danish,
	lang_Portuguese,
	lang_Norwegian,
	lang_Hebrew,
	lang_Japanese,
	lang_Arabic,
	lang_Finnish,
	lang_Greek,
	lang_Icelandic,
	lang_Maltese,
	lang_Turkish,
	lang_Yugoslavian,
	lang_Chinese,
	lang_Urdu,
	lang_Hindi,
	lang_Thai
} sfnt_LanguageEnum;

typedef enum {
	name_Copyright,
	name_Family,
	name_Subfamily,
	name_UniqueName,
	name_FullName,
	name_Version,
	name_Postscript
} sfnt_NameIndex;

typedef uint32 sfnt_TableTag;

#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */
#define tag_ControlValue        0x63767420        /* 'cvt ' */
#define tag_BitmapData          0x45424454        /* 'EBDT' */
#define tag_BitmapLocation      0x45424c43        /* 'EBLC' */
#define tag_BitmapScale         0x45425343        /* 'EBSC' */
#define tag_Editor0             0x65647430        /* 'edt0' */
#define tag_Editor1             0x65647431        /* 'edt1' */
#define tag_Encryption          0x63727970        /* 'cryp' */
#define tag_FontHeader          0x68656164        /* 'head' */
#define tag_FontProgram         0x6670676d        /* 'fpgm' */
#define tag_GridfitAndScanProc	0x67617370		  /* 'gasp' */
#define tag_GlyphDirectory      0x67646972        /* 'gdir' */
#define tag_GlyphData           0x676c7966        /* 'glyf' */
#define tag_HoriDeviceMetrics   0x68646d78        /* 'hdmx' */
#define tag_HoriHeader          0x68686561        /* 'hhea' */
#define tag_HorizontalMetrics   0x686d7478        /* 'hmtx' */
#define tag_IndexToLoc          0x6c6f6361        /* 'loca' */
#define tag_Kerning             0x6b65726e        /* 'kern' */
#define tag_LinearThreshold     0x4c545348        /* 'LTSH' */
#define tag_MaxProfile          0x6d617870        /* 'maxp' */
#define tag_NamingTable         0x6e616d65        /* 'name' */
#define tag_OS_2                0x4f532f32        /* 'OS/2' */
#define tag_Postscript          0x706f7374        /* 'post' */
#define tag_PreProgram          0x70726570        /* 'prep' */
#define tag_VertDeviceMetrics	0x56444d58		  /* 'VDMX' */
#define tag_VertHeader	        0x76686561		  /* 'vhea' */
#define tag_VerticalMetrics     0x766d7478		  /* 'vmtx' */

#define tag_TTO_GSUB     		0x47535542		  /* 'GSUB' */
#define tag_TTO_GPOS     		0x47504F53		  /* 'GPOS' */
#define tag_TTO_GDEF     		0x47444546		  /* 'GDEF' */
#define tag_TTO_BASE     		0x42415345		  /* 'BASE' */
#define tag_TTO_JSTF     		0x4A535446		  /* 'JSTF' */

#endif      /* not sfnt_enums */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\sfntoff.h ===
#define BIGDATE_BC      0
#define BIGDATE_AD      4
#define SIZEOF_BIGDATE  8

#define BBOX_XMIN   0
#define BBOX_YMIN   2
#define BBOX_XMAX   4
#define BBOX_YMAX   6
#define SIZEOF_BBOX 8

#define SFNT_DIRECTORYENTRY_TAG         0
#define SFNT_DIRECTORYENTRY_CHECKSUM    4
#define SFNT_DIRECTORYENTRY_TABLEOFFSET 8
#define SFNT_DIRECTORYENTRY_TABLELENGTH 12
#define SIZEOF_SFNT_DIRECTORYENTRY      16

#define SFNT_OFFSETTABLE_VERSION        0
#define SFNT_OFFSETTABLE_NUMOFFSETS     4
#define SFNT_OFFSETTABLE_SEARCHRANGE    6
#define SFNT_OFFSETTABLE_ENTRYSELECTOR  8
#define SFNT_OFFSETTABLE_RANGESHIFT     10
#define SFNT_OFFSETTABLE_TABLE          12
#define SIZEOF_SFNT_OFFSETTABLE         12

#define SFNT_FONTHEADER_VERSION             0
#define SFNT_FONTHEADER_FONTREVISION        4
#define SFNT_FONTHEADER_CHECKSUMADJUSTMENT  8
#define SFNT_FONTHEADER_MAGICNUMBER         12
#define SFNT_FONTHEADER_FLAGS               16
#define SFNT_FONTHEADER_UNITSPEREM          18
#define SFNT_FONTHEADER_CREATED             20
#define SFNT_FONTHEADER_MODIFIED            28
#define SFNT_FONTHEADER_XMIN                36
#define SFNT_FONTHEADER_YMIN                38
#define SFNT_FONTHEADER_XMAX                40
#define SFNT_FONTHEADER_YMAX                42
#define SFNT_FONTHEADER_MACSTYLE            44
#define SFNT_FONTHEADER_LOWESTRECPPEM       46
#define SFNT_FONTHEADER_FONTDIRECTIONHINT   48
#define SFNT_FONTHEADER_INDEXTOLOCFORMAT    50
#define SFNT_FONTHEADER_GLYPHDATAFORMAT     52
#define SIZEOF_SFNT_FONTHEADER              54

#define SFNT_HORIZONTALHEADER_VERSION                           0
#define SFNT_HORIZONTALHEADER_YASCENDER                         4
#define SFNT_HORIZONTALHEADER_YDESCENDER                        6
#define SFNT_HORIZONTALHEADER_YLINEGAP                          8
#define SFNT_HORIZONTALHEADER_ADVANCEWIDTHMAX                   10
#define SFNT_HORIZONTALHEADER_MINLEFTSIDEBEARING                12
#define SFNT_HORIZONTALHEADER_MINRIGHTSIDEBEARING               14
#define SFNT_HORIZONTALHEADER_XMAXEXTENT                        16
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPENUMERATOR     18
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPEDENOMINATOR   20
#define SFNT_HORIZONTALHEADER_RESERVED0                         22
#define SFNT_HORIZONTALHEADER_RESERVED1                         24
#define SFNT_HORIZONTALHEADER_RESERVED2                         26
#define SFNT_HORIZONTALHEADER_RESERVED3                         28
#define SFNT_HORIZONTALHEADER_RESERVED4                         30
#define SFNT_HORIZONTALHEADER_METRICDATAFORMAT                  32
#define SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS           34
#define SIZEOF_SFNT_HORIZONTALHEADER                            36

#define SFNT_HORIZONTALMETRICS_ADVANCEWIDTH     0
#define SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING  2
#define SIZEOF_SFNT_HORIZONTALMETRICS           4

#define SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS            34

#define SFNT_VERTICALMETRICS_ADVANCEHEIGHT      0
#define SFNT_VERTICALMETRICS_TOPSIDEBEARING     2
#define SIZEOF_SFNT_VERTICALMETRICS             4



#define SFNT_CONTROLVALUE 2

#define SFNT_MAPPINGTABLE_FORMAT            0
#define SFNT_MAPPINGTABLE_MAPTABLELENGTH    2
#define SFNT_MAPPINGTABLE_VERSION           4
#define SIZEOF_SFNT_MAPPINGTABLE            6

#define SFNT_PLATFORMENTRY_PLATFORMID       0
#define SFNT_PLATFORMENTRY_SPECIFICID       2
#define SFNT_PLATFORMENTRY_PLATFORMOFFSET   4
#define SIZEOF_SFNT_PLATFORMENTRY           8

#define SFNT_CHAR2INDEXDIRECTORY_VERSION    0
#define SFNT_CHAR2INDEXDIRECTORY_NUMTABLES  2
#define SFNT_CHAR2INDEXDIRECTORY_PLATFORM   4
#define SIZEOF_SFNT_CHAR2INDEXDIRECTORY     4

#define SFNT_SUBHEADER2_FIRSTCODE       0
#define SFNT_SUBHEADER2_ENTRYCOUNT      2
#define SFNT_SUBHEADER2_IDDELTA         4
#define SFNT_SUBHEADER2_IDRANGEOFFSET   6
#define SIZEOF_SFNT_SUBHEADER2          8

#define SFNT_MAPPINGTABLE2_SUBHEADERSKEYS   0
#define SFNT_MAPPINGTABLE2_SUBHEADERS       512
#define SIZEOF_SFNT_MAPPINGTABLE2           512

#define SFNT_MAPPINGTABLE4_SEGCOUNTX2       0
#define SFNT_MAPPINGTABLE4_SEARCHRANGE      2
#define SFNT_MAPPINGTABLE4_ENTRYSELECTOR    4
#define SFNT_MAPPINGTABLE4_RANGESHIFT       6
#define SFNT_MAPPINGTABLE4_ENDCOUNT         8
#define SIZEOF_SFNT_MAPPINGTABLE4           8

#define SFNT_MAPPINGTABLE6_FIRSTCODE    0
#define SFNT_MAPPINGTABLE6_ENTRYCOUNT   2
#define SFNT_MAPPINGTABLE6_GLYPHIDARRAY 4
#define SIZEOF_SFNT_MAPPINGTABLE6       4

#define SFNT_NAMERECORD_PLATFORMID  0
#define SFNT_NAMERECORD_SPECIFICID  2
#define SFNT_NAMERECORD_LANGUAGEID  4
#define SFNT_NAMERECORD_NAMEID      6
#define SFNT_NAMERECORD_NAMELENGTH  8
#define SFNT_NAMERECORD_NAMEOFFSET  10
#define SIZEOF_SFNT_NAMERECORD      12

#define SFNT_NAMINGTABLE_FORMAT         0
#define SFNT_NAMINGTABLE_COUNT          2
#define SFNT_NAMINGTABLE_STRINGOFFSET   4
/*  SFNT_NAMERECORD[COUNT]  */
#define SIZEOF_SFNT_NAMINGTABLE         6

#define SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS    0
#define SFNT_PACKEDSPLINEFORMAT_BBOX                2
#define SFNT_PACKEDSPLINEFORMAT_ENDPOINTS           10
#define SIZEOF_SFNT_PACKEDSPLINEFORMAT              10

#define SFNT_DEVICEMETRICS_VERSION      0
#define SFNT_DEVICEMETRICS_NUMRECORDS   2
#define SFNT_DEVICEMETRICS_RECORDSIZE   4
/* BYTE WIDTHS[NUMGLYPHS+2] * NUMRECORDS */
#define SIZEOF_SFNT_DEVICEMETRICS       8

#define POSTSCRIPTNAMEINDICES_VERSION               0
#define POSTSCRIPTNAMEINDICES_ITALICANGLE           4
#define POSTSCRIPTNAMEINDICES_UNDERLINEPOSITION     8
#define POSTSCRIPTNAMEINDICES_UNDERLINETHICKNESS    10
#define POSTSCRIPTNAMEINDICES_ISFIXEDPITCH          12
#define POSTSCRIPTNAMEINDICES_PAD                   14
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE42          16
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE42          20
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE1           24
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE1           28
#define POSTSCRIPTNAMEINDICES_NUMBERGLYPHS          32
#define GLYPHNAMEINDEX                              34
#define GLYPHNAMEINDEX25                            34
#define SIZEOF_SFNT_POSTSCRIPTINFO                  36

#define SFNT_OS2_VERSION                0
#define SFNT_OS2_XAVGCHARWIDTH          2
#define SFNT_OS2_USWEIGHTCLASS          4
#define SFNT_OS2_USWIDTHCLASS           6
#define SFNT_OS2_FSTYPE                 8
#define SFNT_OS2_YSUBSCRIPTXSIZE        10
#define SFNT_OS2_YSUBSCRIPTYSIZE        12
#define SFNT_OS2_YSUBSCRIPTXOFFSET      14
#define SFNT_OS2_YSUBSCRIPTYOFFSET      16
#define SFNT_OS2_YSUPERSCRIPTXSIZE      18
#define SFNT_OS2_YSUPERSCRIPTYSIZE      20
#define SFNT_OS2_YSUPERSCRIPTXOFFSET    22
#define SFNT_OS2_YSUPERSCRIPTYOFFSET    24
#define SFNT_OS2_YSTRIKEOUTSIZE         26
#define SFNT_OS2_YSTRIKEOUTPOSITION     28
#define SFNT_OS2_SFAMILYCLASS           30
#define SFNT_OS2_PANOSE                 32
#define SFNT_OS2_ULCHARRANGE            42
#define SFNT_OS2_ACHVENDID              58
#define SFNT_OS2_USSELECTION            62
#define SFNT_OS2_USFIRSTCHAR            64
#define SFNT_OS2_USLASTCHAR             66
#define SFNT_OS2_STYPOASCENDER          68
#define SFNT_OS2_STYPODESCENDER         70
#define SFNT_OS2_STYPOLINEGAP           72
#define SFNT_OS2_SWINASCENT             74
#define SFNT_OS2_SWINDESCENT            76
#define SIZEOF_SFNT_OS2                 78

#define SFNT_HDMX_VERSION               0
#define SFNT_HDMX_SNUMRECORDS           2
#define SFNT_HDMX_LSIZERECORD           4
#define SFNT_HDMX_HDMXTABLE             8
#define SIZEOF_SFNT_HDMX                8

#define SFNT_HDMXRECORD_BEMY            0
#define SFNT_HDMXRECORD_BEMX            1
#define SFNT_HDMXRECORD_BWIDTHS         2
#define SIZEOF_SFNT_HDMXRECORD          2

#define SFNT_LTSH_VERSION               0
#define SFNT_LTSH_NUMGLYPHS             2
#define SFNT_LTSH_UBYPELSHEIGHT         4
#define SIZEOF_SFNT_LTSH                4

#define SFNT_MAXPROFILETABLE_VERSION                0
#define SFNT_MAXPROFILETABLE_NUMGLYPHS              4
#define SFNT_MAXPROFILETABLE_MAXPOINTS              6
#define SFNT_MAXPROFILETABLE_MAXCONTOURS            8
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS     10
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS   12
#define SFNT_MAXPROFILETABLE_MAXELEMENTS            14
#define SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS      16
#define SFNT_MAXPROFILETABLE_MAXSTORAGE             18
#define SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS        20
#define SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS     22
#define SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS       24
#define SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS  26
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS   28
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH      30
#define SIZEOF_SFNT_MAXPROFILETABLE 				32

#define SFNT_GASPRANGE_RANGEMAXPPEM 		0
#define SFNT_GASPRANGE_RANGEGASPBEHAVIOR	2
#define SIZEOF_SFNT_GASPRANGE				4

#define SFNT_GASP_VERSION					0
#define SFNT_GASP_NUMRANGES 				2
#define SFNT_GASP_GASPRANGE 				4
#define SIZEOF_SFNT_GASP					4

/**********************************************************************/

/*      Embedded Bitmap (sbit) Table Offsets      */

/**********************************************************************/

/*  Bloc, Bdat and Bsca file constants    */

/*  This first bloc is common to both bloc and bsca tables */

#define     SFNT_BLOC_NUMSIZES               4
#define     SFNT_BLOC_FIRSTSTRIKE            8

#define     SFNT_BLOC_INDEXARRAYOFFSET       0
#define     SFNT_BLOC_NUMINDEXTABLES         8
#define     SFNT_BLOC_COLORREF              12
#define     SFNT_BLOC_STARTGLYPH            40
#define     SFNT_BLOC_ENDGLYPH              42
#define     SFNT_BLOC_PPEMX                 44
#define     SFNT_BLOC_PPEMY                 45
#define     SFNT_BLOC_BITDEPTH              46
#define     SFNT_BLOC_FLAGS                 47
#define     SIZEOF_BLOC_SIZESUBTABLE        48

#define     SFNT_BLOC_FIRSTGLYPH             0
#define     SFNT_BLOC_LASTGLYPH              2
#define     SFNT_BLOC_ADDITIONALOFFSET       4
#define     SIZEOF_BLOC_INDEXARRAY           8

#define     SFNT_BLOC_INDEXFORMAT            0
#define     SFNT_BLOC_IMAGEFORMAT            2
#define     SFNT_BLOC_IMAGEOFFSET            4
#define     SFNT_BLOC_OFFSETARRAY            8

#define     SFNT_BLOC_IDX2IMAGESIZE          8
#define     SFNT_BLOC_IDX2METRICS           12

#define     SFNT_BLOC_IDX4NUMGLYPHS          8
#define     SFNT_BLOC_IDX4OFFSETARRAY       12

#define     SFNT_BLOC_IDX4CODE               0
#define     SFNT_BLOC_IDX4OFFSET             2
#define     SIZEOF_CODEOFFSETPAIR            4
                
#define     SFNT_BLOC_IDX5IMAGESIZE          8
#define     SFNT_BLOC_IDX5METRICS           12
#define     SFNT_BLOC_IDX5NUMGLYPHS         20
#define     SFNT_BLOC_IDX5CODEARRAY         24

#define     SFNT_SBIT_HEIGHT                 0
#define     SFNT_SBIT_WIDTH                  1
#define     SFNT_SBIT_BEARINGX               2
#define     SFNT_SBIT_BEARINGY               3
#define     SFNT_SBIT_ADVANCE                4
#define     SFNT_SBIT_VERTBEARINGX           5
#define     SFNT_SBIT_VERTBEARINGY           6
#define     SFNT_SBIT_VERTADVANCE            7
#define     SIZEOF_SBIT_SMALLMETRICS         5
#define     SIZEOF_SBIT_BIGMETRICS           8

#define     SFNT_BDAT_COMPCOUNT              0
#define     SIZEOF_SBIT_GLYPH8PAD            1
#define     SFNT_BDAT_FIRSTCOMP              2

#define     SFNT_BDAT_COMPGLYPH              0
#define     SFNT_BDAT_COMPXOFF               2
#define     SFNT_BDAT_COMPYOFF               3
#define     SIZEOF_SBIT_BDATCOMPONENT        4

#define     SFNT_BSCA_NUMSIZES               4
#define     SFNT_BSCA_FIRSTSTRIKE            8

#define     SFNT_BSCA_PPEMX                 24
#define     SFNT_BSCA_PPEMY                 25
#define     SFNT_BSCA_SUBPPEMX              26
#define     SFNT_BSCA_SUBPPEMY              27
#define     SIZEOF_BSCA_SIZESUBTABLE        28

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\dxtc\S3_quant.h ===
// !!!!!!!!! DO NOT RELEASE THIS SOURCE FILE !!!!!!!

/*
 *   Copyright (c) 1997-8  S3 Inc.  All Rights Reserved.
 *
 *   Module Name:  s3_quant.h
 *
 *   Purpose:   Headr file for <quantizer.c> - 
 *				S3 linear interpolation encoding and decoding
 *              mechanism for texture map compression.
 *
 *   Author:   Konstantine Iourcha, Dan Hung
 *
 *   Revision History:
 *      04.03.01 - Cleaned up a bit and added to XGraphics.lib (JHarding)
 *	version Beta 1.00.00-98-03-26
 */
#ifndef _S3_QUANT_H_

#define _S3_QUANT_H_


#define	MAX_PIXEL_PER_BLOCK		16

    /* RGB block structure, contains array of texels with colors in RGB888 
       format as well as variables for coded results			    */

typedef struct _RGBBlock {
    /* INPUTS */
    int n;			/* number of texels for  this block	    */
    double colorChannel[MAX_PIXEL_PER_BLOCK][3];	
				/* array of RGB channel values		
				   assumed to be  normalized to [0.,1.]	    */
    double weight[3];		/* quantization weights on each channel	    */
    int inLevel;		/* quantization level (type)	
				   3 - quantized to line with two endpoints
				       and single interpolant inbetween 
				       plus trancparency index if needed;
				   4 - quantized to line with two endpoints
				       and two interpolants inbetween	    */

    /* OUTPUTS */
    int outLevel;		/* actual number of quantized points	    */
    int endPoint[2][3];		/* quantized end points in RGB565 format,
				   unordered				    */
    int index[MAX_PIXEL_PER_BLOCK];		
				/* texel indices to quantized points	    */
} RGBBlock;

    /* Alpha block structure, contains array of texels with alpha in 
       8-bit format plus various variables for coded results		    */
typedef struct _AlphaBlock {
    /* INPUTS */
	int n;			/* number of alpha values for this block    */
	float alpha[MAX_PIXEL_PER_BLOCK];	
				/* array of alpha normalized to [0.,1.]	    */
	int need0;		/* !=0 if exact 0.0 is needed in compressed
				   format ==0 otherwise			    */
	int need1;		/* !=0 if exact 1.0 is needed in compressed
				    format==0 otherwise			    */
    int protectnonzero; /* != 0 if we need to ensure non-zero values
                        don't get quantized to 0 */

    /* OUTPUTS */
	int outLevel;		/* actual number of quantized points	    */
	int endPoint[2];	/* quantized end points in 8-bit alpha,
				   unordered				    */
	int index[MAX_PIXEL_PER_BLOCK];		
				/* alpha texel indices to quantized 
				   points				    */
} AlphaBlock;

    /* for details on the mathematical basis of this, see easys3tc.doc 
       "S3TC made easy"							*/

    /* function which encodes a block					*/
void CodeRGBBlock(RGBBlock *b);

void CodeAlphaBlock(AlphaBlock *b);
			   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\dxtc\S3_intrf.h ===
// !!!!!!!!! DO NOT RELEASE THIS SOURCE FILE !!!!!!!

/*
 *   Copyright (c) 1997-8  S3 Inc.  All Rights Reserved.
 *
 *   Module Name:  s3_intrf.h
 *
 *   Purpose:  Constant, structure, and prototype definitions for S3TC
 *             interface to DX surface
 *
 *   Author:  Dan Hung, Martin Hoffesommer
 *
 *   Revision History:
 *      04.03.01 - Cleaned up a bit and added to XGraphics.lib (JHarding)
 *  version Beta 1.00.00-98-03-26
 */

// Highlevel interface

#ifndef _S3_INTRF_H_
#define _S3_INTRF_H_

#if XBOX
    #include "xgrphseg.h"
    #include "xtl.h"
#else
    #include "windows.h"
    #include "d3d8-xbox.h"
#endif

#include "xgraphics.h"

// RGB encoding types
#define S3TC_ENCODE_RGB_FULL            0x0
#define S3TC_ENCODE_RGB_COLOR_KEY       0x1
#define S3TC_ENCODE_RGB_ALPHA_COMPARE   0x2
#define _S3TC_ENCODE_RGB_MASK           0xff

// alpha encoding types
#define S3TC_ENCODE_ALPHA_NONE          0x000
#define S3TC_ENCODE_ALPHA_EXPLICIT      0x100
#define S3TC_ENCODE_ALPHA_INTERPOLATED  0x200
#define _S3TC_ENCODE_ALPHA_MASK         0xff00

// additional alpha encoding flags
#define S3TC_ENCODE_ALPHA_NEED0             0x10000
#define S3TC_ENCODE_ALPHA_NEED1             0x20000
#define S3TC_ENCODE_ALPHA_PROTECTNONZERO    0x40000

// common encoding types
//@@@TBD

#if 0
// determine number of bytes needed to compress given source image
unsigned S3TCgetEncodeSize(LPDIRECT3DTEXTURE8 lpDesc,   // [in]
                           unsigned dwEncodeType    // [in]
                           );
// encode (compress) given source image to given destination surface
void S3TCencode(void *lpSrcBufIn, DWORD log2Width, DWORD log2Height,
                void *lpDestBufIn, DWORD dwLevel, float *weight);

// determine number of bytes needed do decompress given compressed image
unsigned S3TCgetDecodeSize(LPDIRECT3DTEXTURE8 lpDesc);

// decode (decompress) to ARGB8888
void S3TCdecode(LPDIRECT3DTEXTURE8 lpSrc,       // [in]
                LPDIRECT3DTEXTURE8 lpDest,      // [out]
                void *lpDestBuf             // [in]
                );
#endif // 0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\link\sources.inc ===
MAJORCOMP=xgraphics
MINORCOMP=xgraphics
TARGETNAME=xgraphics$(D)

TARGETTYPE=LIBRARY

SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1

OBJLIBFILES = \
    ..\..\pushbuffer\$(WHICHBUILD)\obj\*\pushbuffer$(D).lib \
    ..\..\shadeasm\$(WHICHBUILD)\obj\*\shadeasm$(D).lib \
    ..\..\swizzler\$(WHICHBUILD)\obj\*\swizzler$(D).lib \
    ..\..\math\$(WHICHBUILD)\obj\*\xgmath$(D).lib \
    ..\..\misc\$(WHICHBUILD)\obj\*\misc$(D).lib \
    ..\..\dxtc\$(WHICHBUILD)\obj\*\dxtc$(D).lib \
    ..\..\..\xfont\library\$(WHICHBUILD)\obj\*\xfont$(D).lib \
    ..\..\..\xfont\scaler\$(WHICHBUILD)\obj\*\xfonttt$(D).lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\dxtc\s3_quant.cpp ===
// !!!!!!!!! DO NOT RELEASE THIS SOURCE FILE !!!!!!!

/*****************************************************************************
**   Copyright (c) 1997-8  S3 Inc.  All Rights Reserved.		    **
**									    **
**   Module Name:  s3_quant.c						    **
**									    **
**   Purpose:   S3 texture map compression quantizers for RGB		    **
**		and alpha.						    **
**									    **
**		The quantizers computes suboptimal solution of the 	    **
**		corresponsing						    **
**		mean square error minimisation (MMSE) problem.		    **
**		(for details on the mathematical basis of this, see 	    **
**		easys3tc.doc "S3TC made easy"				    **
**									    **
**									    **
**   Author:   Konstantine Iourcha, Dan Hung				    **
**									    **
**   Revision History:							    **
**      04.03.01 - Cleaned up a bit and added to XGraphics.lib (JHarding)
**	version Beta 1.00.00-98-03-26					    **
**									    **
**									    **
******************************************************************************/

/*****************************************************************************
**									    **
**	INCLUDE FILES							    **
**									    **
*****************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "S3_quant.h"

/*****************************************************************************
**									    **
**	MACROS AND MAGIC NUMBERS					    **
**									    **
*****************************************************************************/

    /* IMPORTANT PERFORMACE TUNNING PARAMETERS								
    
       <STATIC_ARR> can be defined as <static> or as < > (blank)
       In the former case some <double> arrays will be defined as <static>,
       otherwise they will be automatic.

       <STATIC>  has the similar effect for some additional <double> variables
       
	The need to use it arises from the fact, that the MS VC++ 4.2 does not 
	do stack frame alignment (or at least we were not been able to 
	configure it to do stack frame aligments)
	
	The new MS VC++ 5.00 (with or without service pack 3) does do stack '
	aligment, but the FPU schedule / optimizer does not do a good job at
	scheduling FPU (or at least we were not been able to configure it to do 
	good scheduling).

	As a result, in some cases we observed the code from v.4.2 with 
	misaligned data running faster then the samed code compiled with 
	v.5.00 (with good aligment).

	The misaligned data in this code, can cause up to 2 x (!) performace
	degradation.

	Most of known "workarounds" for stack frame alignmet are either 
	non-portable, messy or complex (or all of them). 
	
	As we bilieve the problem should be solved in the compiler (which 
	actually is very easy), we use the simplest possible approach.

	Note, that the problem is Intel specific, and on most of "normal" 
	machines defining <double> arrays as static vs. automatic will 
	decrease performace because automatic provides better cache coherency, 
	especially with direct-mapped write-no-allocate caches.

	(On DEC Alpha NT platform the perfomace drop is about 20 -25% using 
	static)

	SO, THE RULES for the parametes are:
	    - if you compile code for Intel machine using compiler which 
	      does NOT do stack frame alignment, set both parameter to <static>

	    - otherwise, set them to <> (blank)

	    - better yet, try both (or three combinations) and do performance 
	      profiling

	    - when <STATIC> defined as <static>, there are no reason to have 
	      <STATIC_ARR> as <> (blank). The opposite combination might 
	      work in some cases
    									    */
/*	
#define STATIC_ARR 
#define STATIC 
*/

#define STATIC_ARR static
#define STATIC static



    /*	The ALL_SAME_THRESHOLD defines a cube in RGB space with the edges 
	aligned to the coordinate axis and having length of twice the value 
	of ALL_SAME_THRESHOLD. If for some cube position (the center of the
	cube is in the first point color) all point of the block are inside,
	then the block collapses to a single color cluster and goes into
	<allSame bypass>. For 256 levels grid, the value should be 
	1/256/2/2 or less (1/256/4/2).					    */

#define ALL_SAME_THRESHOLD 1/256./4./2.			

    /*  Muximum number of <seach43Mult> calls (iterations) for one block.
        Note, that on average that will be just between 1 and 2 calls 
	(about 1.2) made per block, as the iterator stops anyhow when it 
	cannot get further improvement.

	However on some blocks, the iterator can run into very long infinite 
	loop without forced exit.
	
	On rare ocasions for some blocks the number of iterations might
	be higher, so the the reasonable number should not be too small
	as it will results in poorer quanlity on some blocks and vitually no
	performance gain.

	The following numbers were define using some statistical profiling
	on the large set of images and believed to be optimal		    */

#define UNCLIPPED_ITERATION_LIMIT 16

    /*	Maximum number of <seachClipped43Mult> calls (iterations) for one 
	block, similar to UNCLIPPED_ITERATION_LIMIT, see above		    */

#define CLIPPED_ITERATION_LIMIT 8

    /* During <seach43Mult> / <seachClipped43Mult> iterative calls 
       each configuration is defined by the ordering of the points, which 
       is described by the index.
       
       Index log keeps some number of indicies already checked, to provide
       loop detection and exit.						    

       Unless UNCLIPPED_ITERATION_LIMIT and CLIPPED_ITERATION_LIMIT are very
       big (100 and up), the following parameter should be equal to the 
       biggest of those two values					    */
       
#define INDEX_LOG_SIZE 16

    /* maximum number of levels (values in the linear ramp) for alpha 
       quantizer							    */

#define MAX_ALPHA_LEVELS	8

    /* Maximum number of iteration for incremental optimizer of alpha 
       quatization.
       
       As alpha quantizer has completely different nature then RGB quantizer
       this number should be much bigger then the iteration limits for RGB 
       quantizer. (But the iterations are much faster too).

       The next number was defined based on statistical profiling	    */	

#define ALPHA_ITERATION_LIMIT	64


    /* Macro to clip <X> to the range [X_MIN, X_MAX] for <float> or <double>*/
#define CLIP(X, X_MIN, X_MAX)						    \
    (((fabs(X_MIN - X) + X_MIN ) + (X_MAX - fabs(X_MAX - X))) * 0.5 ) 



/*****************************************************************************
**									    **
**	FUNCTION PROTOTYPES						    **
**									    **
*****************************************************************************/

static void getAxis(int n,double (*q)[3],double axis[3]);

static void getDiameter(int n, double (*q)[3],double axis[3]);

static void sortProjection(int n, double (*q)[3], double axis[3], 
		    int index [MAX_PIXEL_PER_BLOCK], int reverse);

static int sameOrder (int n, 
  int index1[MAX_PIXEL_PER_BLOCK], int index2[MAX_PIXEL_PER_BLOCK]);

static double search43Mult (int *levLim, int n, double (*q)[3], double *pMult,
  int idx [MAX_PIXEL_PER_BLOCK], double endPointOut[2][3],
  double axis[3] );

static double searchClipped43Mult (int *levLim, int n, double (*q)[3], double *pMult,
  int idx [MAX_PIXEL_PER_BLOCK], double range[2][3],double endPointOut[2][3],
  double axis[3] );

static double roundMult (int nColors, int n, double (*q)[3], double *pMult, double w[3], 
  double endPointIn[2][3], int endPointOut[2][3], 
  int index [MAX_PIXEL_PER_BLOCK]);

static double allSame(int *nColors, int n, double (*q)[3], double weight[3], 
  int endPointOut[2][3], int index [MAX_PIXEL_PER_BLOCK]);


static double mapAndRoundMult(int *nColors, bool bForce4, int levelLimit, int n,  double (*q)[3], 
    double *pMult, double weight[3], double endPointIn[2][3], int endPointOut[2][3], 
    int index [MAX_PIXEL_PER_BLOCK]);

static double quantizeAlpha (int level, int n, 
  double alpha[MAX_PIXEL_PER_BLOCK], int endPointOut[2], 
  int  index [MAX_PIXEL_PER_BLOCK]);



/*****************************************************************************
**									    **
**	RGB QUANTIZER "FRONT END FUNCTIONS" - geting optimal line	    **
**      (direction), ordering, etc.					    **
**									    **
*****************************************************************************/


/*
**    
**  statci void getAxis(int n,double (*q)[3],double axis[3])
**
**	Derive a direction for the best-fit line, based on 3D optimization.
**
**	The direction is an eigenvector, corresponding to the biggest 
**	eigenvalue of the covariance matrix of color points. 
**	(The same as an eigenvector, corresponding to the smallest 
**	eigenvalue of the tensor of inertia of color points.) 
**
**	Note, that if the biggest eigenvalue and the next one are close, the 
**	function will give relatively poor approximation of the eigenvector.
**	This is not very important, though, as some other error bounds (which
**	actually affect the resulting quantization error) will be satisfied.
**  
**	Also, if the two (three) biggest eigenvectors are the same, the result
**	will be any vector from the appropriate plane (space)
**
**  Input:
**
**	n	- number of points (per block) 
**	q	- array of points coordinates (RGB), weighted, 
**		  should be centered (!) 
**
**  Output
**	axis	- resulting eigenvector approximation (best fit axis) 
**		  (actully it will be very poor approximation of the 
**		  eigenvector in some cases, this is fine for our purposes, 
**		  see above)  
**
*/  

static void getAxis(int n,double (*q)[3],double axis[3]) {
    STATIC_ARR double s[3][3];		/* self-conjugated covariance matrix of q[i]
				   and its power of 2^n			    */
    STATIC_ARR double t[3][3];		/* second copy of covariance matrix s[i] 
				   for static unroll to avoid data dependency
									    */
    STATIC double sp,f;		/* factors used to scale s		    */

    int c,i,j;			/* counter variables			    */

    /* initialize upper triangle of s					    */

    s[0][0] = s[0][1] = s[0][2] = s[1][1] = s[1][2] = s[2][2] = 0.0;
	
    /* calculate upper triangle of s = sum of self-conjugated matrix over all 
       q[i]'s = sum(q[i]xT(q[i])); where T() = transpose function	    */
    for (i=0;i<n;i++) {
	s[0][0] += q[i][0] * q[i][0];
	s[0][1] += q[i][0] * q[i][1];
	s[0][2] += q[i][0] * q[i][2];
	s[1][1] += q[i][1] * q[i][1];
	s[1][2] += q[i][1] * q[i][2];
	s[2][2] += q[i][2] * q[i][2];
    }

    /* start repetitive multiply to solve for optimal vector		    */
    /* OUTER LOOP START 						    */
    
    for (c = 0; c < 3; c++) {
    /* the number of iteration of this (and inner loop), 3 and 4 are 
       defined as to reach required error bound 			    */
    
    /*  scale matrix s to bound coefficients to prevent underflow/overflow,

	    let sp = s[0][0] + s[1][1] + s[2][2] 

	as s is positive defined, for  its biggest eigenvlaue lM

	    max(s[][])   <= lM <=  sp;

	On the other hand, lM * 3 >= sp and lM >= sp / 3
	So,  1 / 3 <= lM / sp  <= 1 and for the scaler of 3.5 * sp 
	    1 < = 3.5 / 3 <= lM * (3.5 / sp) <= 3.5
	and 
	    max(s[][]) * (3.5 / sp) <= 3.5,
	Hence the biggest eigenvalue will not degenerate during power 
	computation and we have and upper bound of 3.5 ^ n for coefficients 
	of  s^n.							    */

	sp = s[0][0] + s[1][1] + s[2][2];
	f = 3.5 / sp;
	for (i = 0; i < 3; i++) 
	    for (j = i; j < 3; j++) 
		s[i][j] *= f;

    /* derive the optimal vector via repetitive multiply 
       4 iterations can be sustaned without overflow since initial eigenvalue 
       has an upperbound of 4.0 (actually 3.5), i.e. initial exponent of 2.  
       
       Maximum exponent for double is 1024 and each iteration the exponent is 
       increased fourfold, hence  1024 = 2^10 > 2 * 4^4 (4 iterations 
       wothout exponent overflow).					    */
	    
	for (j = 0; j < 4; j++) {
    /* t = s*s; set up the matrix multiply in such a way as to avoid data 
       dependencies via the use of t (compiles to faster code), 
       compute the upper triangle only					    */
	    t[0][0] = s[0][0] * s[0][0] + s[0][1] * s[0][1] + s[0][2] * s[0][2];
	    t[0][1] = s[0][0] * s[0][1] + s[0][1] * s[1][1] + s[0][2] * s[1][2];
	    t[0][2] = s[0][0] * s[0][2] + s[0][1] * s[1][2] + s[0][2] * s[2][2];
	    t[1][1] = s[0][1] * s[0][1] + s[1][1] * s[1][1] + s[1][2] * s[1][2];
	    t[1][2] = s[0][1] * s[0][2] + s[1][1] * s[1][2] + s[1][2] * s[2][2];
	    t[2][2] = s[0][2] * s[0][2] + s[1][2] * s[1][2] + s[2][2] * s[2][2];

	    s[0][0] = t[0][0] * t[0][0] + t[0][1] * t[0][1] + t[0][2] * t[0][2];
	    s[0][1] = t[0][0] * t[0][1] + t[0][1] * t[1][1] + t[0][2] * t[1][2];
	    s[0][2] = t[0][0] * t[0][2] + t[0][1] * t[1][2] + t[0][2] * t[2][2];
	    s[1][1] = t[0][1] * t[0][1] + t[1][1] * t[1][1] + t[1][2] * t[1][2];
	    s[1][2] = t[0][1] * t[0][2] + t[1][1] * t[1][2] + t[1][2] * t[2][2];
	    s[2][2] = t[0][2] * t[0][2] + t[1][2] * t[1][2] + t[2][2] * t[2][2];
	}
    }
    /* OUTER LOOP END							    */

    /* find maximum diagonal coefficient in s, this square of the norm of 
       corresponding column (row) of t					    */
    i = s[0][0] > s[1][1] ? 
	(s[0][0] > s[2][2] ? 0 : 2) : (s[1][1] > s[2][2] ? 1 : 2);	    

    /* normalize and return axis					    */
    f = 1.0 / sqrt(s[i][i]);

    for (j = 0; j < i; j++)
	axis[j] = t[j][i] * f;
    for (     ; j < 3; j++)
	axis[j] = t[i][j] * f;
}

/*
**    
**  static void getDiameter(int n, double (*q)[3],double axis[3])
**
**	Derive a direction for the best-fit line, based on 3D optimization.
**
**	getDiameter returns the diameter of the set of 3D point q[], 
**	which represent the vector between two q points that has the
**	maximum distance over all such vectors among the points q[].
**
**  Input:
**
**	n	- number of points (per block) 
**	q	- array of points coorsinates (RGB), weigthed, 
**		  might of might not be centered
**	
**
**  Output
**	axis	- resulting diameter approximation (best fit axis) 
**
*/  
static void getDiameter(int n, double (*q)[3],double axis[3]) {
    STATIC double dia,tmpDia;
    int diaInd0,diaInd1;
    int i,j;
    /* exhaustive search for diameter of the points / texels.
       diameter here is defined as largest distance between two points (texels).
       (actually, in code below the variable dia is diameter squared until the 
       end)								    */
    for (dia =0.0, i = 0; i < n; i++) {
	for (j = i; j < n; j++) {
    /* calculate vector between texels q[i] and q[j]			    */
	    double c0,c1,c2;
	    c0 = q[i][0] - q[j][0];
	    c1 = q[i][1] - q[j][1];
	    c2 = q[i][2] - q[j][2];
    /* square distance between two texels q[i] and q[j]			    */
	    tmpDia = c0*c0 + c1*c1 + c2*c2;
    /* find largest square distance and corresponding vector		    */
	    if (tmpDia>dia) {
		dia = tmpDia;
		diaInd0 = i;
		diaInd1 = j;
	    }
	}
    }

    /* calculate largest distance and return normalized diameter vector	    */
    dia = 1.0 / sqrt(dia);
    axis[0] = (q[diaInd0][0] - q[diaInd1][0]) * dia;
    axis[1] = (q[diaInd0][1] - q[diaInd1][1]) * dia;
    axis[2] = (q[diaInd0][2] - q[diaInd1][2]) * dia;
}


/*
**    
**  static void sortProjection(int n, double (*q)[3], double axis[3], 
**		    int index [MAX_PIXEL_PER_BLOCK], int reverse)
**
**	Sort the projection of 3D points q[] onto vector axis[].
**      The sort is stable (this is importatnt for its intended usaga), 
**	i.e. the points with equal projections should have the same order
**	in the output as they have in the input. (Or reversing stable
**	if reverse set to 1).
**
**
**  Input:
**
**	n	- number of points (per block) 
**	q	- array of points coorsinates (RGB), weigthed, 
**		  might of might not be centered
**	axis	- vector to projec on.
**	reverse - if 0 the elements with equal projections shold have
**		  the same order in the output array as they have in the
**		  input; if 1 they should have exactly opposite order.
**
**  Output
**	index	- index defining the order of projections; the original
**		  point array has  unchanged order
**
*/  
static void sortProjection(int n, double (*q)[3], double axis[3], 
		    int index [MAX_PIXEL_PER_BLOCK], int reverse) {

    STATIC_ARR double projection [MAX_PIXEL_PER_BLOCK];
    int mask [MAX_PIXEL_PER_BLOCK];
    int i, j, k;

    /* compute projections and intialize index				    */
    for (i = 0; i < n; i++) {
	projection[i] = 
	    q[i][0] * axis[0] + q[i][1] * axis[1] + q[i][2] * axis[2];  
	mask[i] = 1;
    }

    /* sort, revers controls order of equal elements			    */
    if (reverse) {
	for (i = 0; i < n; i++) {
	    for (j = 0; j < n; j++)  
		if (mask[j])
		    break;
	    for (k = j++; j < n; j++)  {
		if (mask[j] && projection[j] <= projection[k]) 
		    k = j;
	    }
	    mask[k] = 0;
	    index[i] = k;
	}
    } 
    else {
	for (i = 0; i < n; i++) {
	    for (j = 0; j < n; j++)  
		if (mask[j])
		    break;
	    for (k = j++; j < n; j++)  {
		if (mask[j] && projection[j] < projection[k]) 
		    k = j;
	    }
	    mask[k] = 0;
	    index[i] = k;
	}
    }
}

/*
**    
**  static int sameOrder (int n, 
**	int index1[MAX_PIXEL_PER_BLOCK], int index2[MAX_PIXEL_PER_BLOCK])
**
**	Check if the two indicies has the same or exactly reversd order
**
**  Input:
**
**	n	- number of points (per block) 
**	index1	- first index to compare
**	index2	- second index to compare
**
**  Output:	none, all input values are unchanged
**
**  Return value: 1 if the indecies have the same or reveresed orded,
**		  0 otherwise
**
*/  

static int sameOrder (int n, 
  int index1[MAX_PIXEL_PER_BLOCK], int index2[MAX_PIXEL_PER_BLOCK]) {

    int i;
    /*  check if the same order						    */
    for (i = 0; i < n; i++)
	if (index1[i] != index2[i])
	    break;
    /* if not, check if reverse order					    */
    if (i < n)
	for (i = 0; i < n; i++)
	    if (index1[i] != index2[n-1-i])
		break;
    return (i == n); 
}


/*****************************************************************************
**									    **
**	RGB QUANTIZER COLOR RAMP FITTING FUNCTIONS			    **
**      (in "continuous" <double> based 3D  model			    **
**									    **
*****************************************************************************/


/*
**    
**  static double search43Mult (int *levLim, int n, double (*q)[3], 
**      double *pMult, int idx [MAX_PIXEL_PER_BLOCK], double endPointOut[2][3],
**	double axis[3] )
**
**	Given set of 3D points q[], and ordering in idx[], go through 
**      different clustering such that each cluster consist of consecutive 
**	points as defined by the order in idx[].
**	For each clustering compute color ramp with minimal square error 
**      according to weights.  then return color ramp w/ minimal error among 
**	all possible ramp over all possible clustering.
**
**	Note that the endpoints on the color ramp may be outside color cube.
**
**  Input:
**	int *levLim	- maximum allowed number of the points in color ramp 
**			  minus one.  (possible value 2 or 3)
**	int n		- number of points
**	double (*q)[3]	- 3D points (should be centered, weighted, and
**			  multiplied by multiplicity factor pMult[].)
**      double *pMult	- multiplicity factor (sum of all factors should be
**			  1.0)
**	int idx []	- order of 3D points to use for clustering
**
**  Output:
**	int *levLim	- actual number of points in color ramp minus one.
**			  (might be 1, 2, or 3).
**	double endPointOut[2][3]
**			- endpoints of the optimal ramp (duh!)
**	double axis[3]  - direction of the ramp, provided for additional 
**			  convenience.
**
**  Return value: some linear functional of square error for this particular
**	color ramp (as returned in output).
**	It's not actually square error but you can compare 
**	outputs, and the smaller is better.  For it's used for
**	comparison purposes.
**
*/  

static double search43Mult (int *levLim, int n, double (*q)[3], double *pMult,
  int idx [MAX_PIXEL_PER_BLOCK], double endPointOut[2][3],
  double axis[3] ) {

    STATIC_ARR double qs   [16][3];
    STATIC_ARR double mult [16];

    /* interpolants stack for 3 levels					    */
    STATIC_ARR double kq	[3][3];
    STATIC_ARR double k2	[3];
    STATIC_ARR double sK	[3];
    
    STATIC double numer = 0;
    STATIC double denom = 1.;

    int lev = 0;
    int vLev;
	
    int i, j;
    int i0, i1, i2;
    int jk[4];

  


    for (i = 0; i < n; i++)
        for(j=0; j < 3; j++) {
           qs[i][j] = q[idx[i]][j];
           mult[i] = pMult[idx[i]];
	}

    kq[0][0] = kq[0][1] = kq[0][2] = k2[0] = sK[0] = 0;
    kq[1][0] = kq[1][1] = kq[1][2] = k2[1] = sK[1] = 0;
    kq[2][0] = kq[2][1] = kq[2][2] = k2[2] = sK[2] = 0;


    for (i0 = n; ; ) {
        for (i1 = n; ; ) {
	        for (i2 = n; ; ) { 
	            double num_ = - kq[2][0] * kq[2][0] 
			          - kq[2][1] * kq[2][1] 
			          - kq[2][2] * kq[2][2]; 

		        if (numer * k2[2] >= denom * num_) {
		            numer = num_;
		            denom = k2[2];
		            jk[0] = i0;
		            jk[1] = i1;
		            jk[2] = i2;

		        }
		        if ((--i2 < i1) || (*levLim < 3))
		            break;
		        kq[2][0] = kq[2][0] + qs[i2][0];
	                kq[2][1] = kq[2][1] + qs[i2][1];
	                kq[2][2] = kq[2][2] + qs[i2][2];
	                k2[2]    = k2[2]    + 
		            (5.  - 2. * sK[2] - mult[i2]) * mult[i2];
	                sK[2]    = sK[2]    + mult[i2];
	                lev = 3;
	        }
	        if (--i1 < i0)
	            break;
	        kq[2][0] = kq[1][0] = kq[1][0] + qs[i1][0];
	        kq[2][1] = kq[1][1] = kq[1][1] + qs[i1][1];
	        kq[2][2] = kq[1][2] = kq[1][2] + qs[i1][2];
	        k2[2]    = k2[1]    = k2[1]    + 
		    (3.  - 2. * sK[1] - mult[i1]) * mult[i1];
	        sK[2]    = sK[1]    = sK[1]    + mult[i1];
	        lev = 2;
	    }
	    if (--i0 <1)
	        break;
	    kq[2][0] = kq[1][0] = kq[0][0] = kq[0][0] + qs[i0][0];
	    kq[2][1] = kq[1][1] = kq[0][1] = kq[0][1] + qs[i0][1];
	    kq[2][2] = kq[1][2] = kq[0][2] = kq[0][2] + qs[i0][2];
	    k2[2]    = k2[1]    = k2[0]    = k2[0]    + 
	        (1.  - 2. * sK[0] - mult[i0]) * mult[i0];
	    sK[2]    = sK[1]    = sK[0]    = sK[0]    + mult[i0];
	    lev = 1;
    }
    /* get endpoints and error						    */
    assert(numer < 0);

    jk[3] = n;
    /* collapse jk[] to have standard representation for 2 clusters 
       (important to have deterministic quantization in some ambigious
       cases								    */
  
    /* <vLev> is number of clusters minus 1; <lev> is (was) the highest 
       cluster number; some clusters in between might be empty, so ,<vLev> 
       and <lev> are not the same					    */
    vLev = (jk[0] != jk[1]) + (jk[1] != jk[2]) + (jk[2] != jk[3]);
    /* move it all the way to the top					    */
    // NOTE (JHarding): These next 2 FOR loops have been changed from 
    // the original S3 code.  The original loops are commented out.
    if (vLev == 1) {
    // for (i = 2; i--; jk[i] == jk[i+1]);        
	for (i = 2; jk[i] == jk[i+1]; i--); 
				/* empty body on purpose		    */
    // for( ; i++; i<3 )
	for ( ; i< 2; i++ )
	    jk[i+1] = jk[i];
    }

    for (kq[2][0] = kq[2][1] = kq[2][2] = sK[2] = k2[2]= 0., lev = i = j = 0; 
      j < 4; j++) {
        for (; i < jk[j]; i++) {
    	    sK[2] += (double) j * mult[i];
	        k2[2] += (double) j * (double) j * mult[i];
	        kq[2][0] += (double) j * qs[i][0];
	        kq[2][1] += (double) j * qs[i][1];
	        kq[2][2] += (double) j * qs[i][2];
	    }
	    lev += (jk[j] != n);
    }
    k2[2] -= sK[2] * sK[2];
    {
        double k0  =	 - sK[2];
        double k1  = (double)lev - sK[2];
        double num_ = - kq[2][0] * kq[2][0] 
		      - kq[2][1] * kq[2][1] 
		      - kq[2][2] * kq[2][2]; 

    	for (j = 0; j < 3; j++) {		    
	    endPointOut[0][j] = (k0 * kq[2][j]) /k2[2];
	    endPointOut[1][j] = (k1 * kq[2][j]) /k2[2];
	    axis[j] = kq[2][j];
	}
	*levLim = (vLev == 1) ? 1 : lev;
	return(num_/k2[2]);
    }
}

/*
**    
**  static double searchClipped43Mult (int *levLim, int n, double (*q)[3], 
**	double *pMult,int idx [MAX_PIXEL_PER_BLOCK], double range[2][3],
**	double endPointOut[2][3],double axis[3] )
**
**	Given set of 3D points q[], and ordering in idx[], go through 
**      different clustering such that each cluster consist of consecutive 
**	points as defined by the order in idx[].
**	For each clustering compute color ramp inside clipping volume with 
**	minimal square error according to weights.  
**	Then return color ramp w/ minimal error among all possible ramp 
**	over all possible clustering.
**
**	Note that the endpoints on the color ramp are guaranteed to be inside
**	    the clipping rectangular volume (unlike search43Mult() ).
**
**  Input:
**	int *levLim	- maximum allowed number of the points in color ramp 
**			  minus one.  (possible value 2 or 3)
**	int n		- number of points
**	double (*q)[3]	- 3D points (should be centered, weighted, and
**			  multiplied by multiplicity factor pMult[].)
**      double *pMult	- multiplicity factor (sum of all factors should be
**			  1.0)
**	int idx []	- order of 3D points to use for clustering
**	double range[2][3]
**			- clipping rectangular volume for centered and
**			  weighted points q[].
**
**  Output:
**	int *levLim	- actual number of points in color ramp minus one.
**			  (might be 1, 2, or 3).
**	double endPointOut[2][3]
**			- endpoints of the optimal ramp (duh!)
**	double axis[3]  - direction of the ramp, provided for additional 
**			  convenience.
**
**  Return value: some linear functional of square error for this particular
**	color ramp (as returned in output).
**	It's not actually square error but you can compare 
**	outputs, and the smaller is better.  For it's used for
**	comparison purposes.
**
*/  

static double searchClipped43Mult (int *levLim, int n, double (*q)[3], double *pMult,
  int idx [MAX_PIXEL_PER_BLOCK], double range[2][3],double endPointOut[2][3],
  double axis[3] ) {

    STATIC_ARR double qs   [16][3];
    STATIC_ARR double mult [16];
	
    /* interpolants stack for 3 levels					    */
    STATIC_ARR double kq	[3][3];
    STATIC_ARR double k2	[3];
    STATIC_ARR double sK	[3];
    
    STATIC double numer = 0;
    STATIC double denom = 1.;

    int lev = 0;
    int vLev;
	
    int i, j;
    int i0, i1, i2;
    int jk[4];


    for (i = 0; i < n; i++)
        for(j=0; j < 3; j++) {
           qs[i][j] = q[idx[i]][j];
           mult[i] = pMult[idx[i]];
	}

    kq[0][0] = kq[0][1] = kq[0][2] = k2[0] = sK[0] = 0;
    kq[1][0] = kq[1][1] = kq[1][2] = k2[1] = sK[1] = 0;
    kq[2][0] = kq[2][1] = kq[2][2] = k2[2] = sK[2] = 0;


    for (i0 = n; ; ) {
        for (i1 = n; ; ) {
	    for (i2 = n; ; ) { 
	        double k0  =	 - sK[2];
	        double k1  = (double) lev - sK[2];
	        double f00 = k2[2] + k0 * k0;
	        double f01 = k2[2] + k0 * k1;
	        double f11 = k2[2] + k1 * k1;
	        double f0011 = f00 * f11;
	        double den_ = 
		  k2[2] * f0011 * f0011 * (double)lev * (double)lev; 
	        double num_ = 0;

    		for (j = 0; j < 3; j++) {		    
		    double x0,  x1;
		    double x0m, x1m;
		    double x0M, x1M;
		
		    x1m = range[0][j] * k2[2];
		    x1M = range[1][j] * k2[2];

		    x0 = k0 * kq[2][j]; 
		    x1 = k1 * kq[2][j]; 

		    x0m = x1m - x0;
		    x0M = x1M - x0;

		    x1m = (x1m - x1) * f00;
		    x1M = (x1M - x1) * f00;

		    x0 = (CLIP(0., x0m, x0M)) * f01;

		    x0m *= f0011;
		    x0M *= f0011;

		    x1 = CLIP (x0, x1m, x1M);

		    x0 = x1 * f01;
		    x1 *= f11;
			
		    x0 = CLIP(x0, x0m, x0M);
    /* "rotate" varialbles						    */
    		    x0m = x0 - x1;
	    	    x0M = k0 * x1 - k1 * x0;
			
		    num_ += k2[2] * x0m * x0m + x0M * x0M - 
		      kq[2][j] * kq[2][j] * den_;
		}
		den_ *= k2[2];

		if (numer * den_ >= denom * num_) {
		    numer = num_;
		    denom = den_;
		    jk[0] = i0;
		    jk[1] = i1;
		    jk[2] = i2;

		}
		if ((--i2 < i1) || (*levLim < 3))
		    break;
		kq[2][0] = kq[2][0] + qs[i2][0];
	        kq[2][1] = kq[2][1] + qs[i2][1];
	        kq[2][2] = kq[2][2] + qs[i2][2];
	        k2[2]    = k2[2]    + 
		    (5.  - 2. * sK[2] - mult[i2]) * mult[i2];
	        sK[2]    = sK[2]    + mult[i2];
	        lev = 3;
	    }
	    if (--i1 < i0)
	        break;
	    kq[2][0] = kq[1][0] = kq[1][0] + qs[i1][0];
	    kq[2][1] = kq[1][1] = kq[1][1] + qs[i1][1];
	    kq[2][2] = kq[1][2] = kq[1][2] + qs[i1][2];
	    k2[2]    = k2[1]    = k2[1]    + 
		(3.  - 2. * sK[1] - mult[i1]) * mult[i1];
	    sK[2]    = sK[1]    = sK[1]    + mult[i1];
	    lev = 2;
	}
	if (--i0 <1)
	    break;
	kq[2][0] = kq[1][0] = kq[0][0] = kq[0][0] + qs[i0][0];
	kq[2][1] = kq[1][1] = kq[0][1] = kq[0][1] + qs[i0][1];
	kq[2][2] = kq[1][2] = kq[0][2] = kq[0][2] + qs[i0][2];
	k2[2]    = k2[1]    = k2[0]    = k2[0]    + 
	    (1.  - 2. * sK[0] - mult[i0]) * mult[i0];
	sK[2]    = sK[1]    = sK[0]    = sK[0]    + mult[i0];
	lev = 1;
    }
    /* get endpoints and error						    */
    assert(numer < 0);

    jk[3] = n;
    /* collapse jk[] to have standard representation for 2 clusters 
       (important to have deterministic quantization in some ambigious
       cases								    */
    /* <vLev> is number of clusters minus 1; <lev> is (was) the highest 
       cluster number; some clusters in between might be empty, so ,<vLev> 
       and <lev> are not the same					    */
    vLev = (jk[0] != jk[1]) + (jk[1] != jk[2]) + (jk[2] != jk[3]);
    /* move it all the way to the top					    */
    // NOTE (JHarding): These next 2 FOR loops have been changed from 
    // the original S3 code.  The original loops are commented out.
    if (vLev == 1) {
    // for (i = 2; i--; jk[i] == jk[i+1]);        
	for (i = 2; jk[i] == jk[i+1]; i-- ); 
				/* empty body on purpose		    */
    // for( ; i++; i<3 )
	for ( ; i< 2; i++ )
	    jk[i+1] = jk[i];
    }

    for (kq[2][0] = kq[2][1] = kq[2][2] = sK[2] = k2[2]= 0., lev = i = j = 0; 
      j < 4; j++) {
        for (; i < jk[j]; i++) {
    	    sK[2] += (double) j * mult[i];
	    k2[2] += (double) j * (double) j * mult[i];
	    kq[2][0] += (double) j * qs[i][0];
	    kq[2][1] += (double) j * qs[i][1];
	    kq[2][2] += (double) j * qs[i][2];
	}
	lev += (jk[j] != n);
    }
    k2[2] -= sK[2] * sK[2];
    {
        double k0  =	 - sK[2];
        double k1  = (double)lev - sK[2];
        double f00 = k2[2] + k0 * k0;
        double f01 = k2[2] + k0 * k1;
        double f11 = k2[2] + k1 * k1;
	double f0011 = f00 * f11;
	double den_ = 
	  k2[2] * f0011 * f0011 * (double)lev * (double)lev; 
	double num_ = 0;


    	for (j = 0; j < 3; j++) {		    
	    double x0,  x1;
	    double x0m, x1m;
	    double x0M, x1M;
		
	    x1m = range[0][j] * k2[2];
	    x1M = range[1][j] * k2[2];

	    x0 = k0 * kq[2][j]; 
	    x1 = k1 * kq[2][j]; 

	    x0m = x1m - x0;
	    x0M = x1M - x0;

	    x1m = (x1m - x1) * f00;
	    x1M = (x1M - x1) * f00;

	    x0 = (CLIP(0., x0m, x0M)) * f01;

	    x0m *= f0011;
	    x0M *= f0011;

	    x1 = CLIP (x0, x1m, x1M);

	    x0 = x1 * f01;
	    x1 *= f11;
			
	    x0 = CLIP(x0, x0m, x0M);
    /* "rotate" varialbles						    */
    	    x0m = x0 - x1;
	    x0M = k0 * x1 - k1 * x0;
			
	    num_ += k2[2] * x0m * x0m + x0M * x0M - 
	      kq[2][j] * kq[2][j] * den_;

	    endPointOut[0][j] = (x0 / f0011 + k0 * kq[2][j]) /k2[2];
	    endPointOut[1][j] = (x1 / f0011 + k1 * kq[2][j]) /k2[2];
	    axis[j] = kq[2][j];
	}
	*levLim = (vLev == 1) ? 1 : lev;
	den_ *= k2[2];
	return(num_/den_);
    }
}

/*****************************************************************************
**									    **
**	RGB QUANTIZER "BACK-END" FUNCTIONS			    	    **
**      (rounding to s3tc grid, etc.		)			    **
**									    **
*****************************************************************************/


/*
**    
**  static double roundMult (int nColors, int n, double (*q)[3], 
**  double *pMult, double w[3], double endPointIn[2][3], 
**  int endPointOut[2][3], int index [MAX_PIXEL_PER_BLOCK])
**
**	Do optinmal rounding for the ramp of three or four 
**	colors, compute new colors and two bits to map old 
**	colors to new colors.
**
**	We assume, that the <endPointOut> are in 5.6.5 format and the decoder
**	    1. first upscales them like ....
**	    2. computes intermidiate points like ...
**		exactly as specified in S3TC.
**		Basically the function provide optimized endpoints for this 
**		particular encoder (in terms of weighted square error.)
**
**  Input:
**      int nColors     - number of colors on ramp (three or four)
**	int n,		- number of points to quantize
**	double (*q)[3]	- array of <n> points each of three componets, assume 
**			  to be already weighted by the weights <w>
**      double *pMult	- multiplicity factor (sum of all factors should be
**			  1.0)
**	double w[3]	- weight coeeficients for the corrsponding channels 
**			  (primary colors)
**	endPointIn[2][3]- two endpoints of the ramp, weighted by the weights 
**			  <w>, which is the result of the continuous 
**			  quantization.
**
**  Output
**	int endPointOut[2][3] - rounded endpoints (format integer 5, 6, 5 
**			  right aligned and NOT PACKED)
**	int index [MAX_PIXEL_PER_BLOCK] - indecies mapping original point to
**			  the 4 colors ramp computed with end-
**    			  points <ndPointOut>  The indicies are like follows:
**			  unpacked, and the mapping is as specified in S3TC 
**			  spec.
**      NOTE: the indices are as in S3TC but the order of the endpoints is
**	    arbitrary, so during packing one needs to check the ordering
**	    of the endpoints and possibly change the indices to reflect
**	    swapping of endpoints.
**
**  Return value is error measure (linear relation of square error).
**
*/

static double roundMult (int nColors, int n, double (*q)[3], double *pMult, 
  double w[3], double endPointIn[2][3], int endPointOut[2][3], 
  int index [MAX_PIXEL_PER_BLOCK]) {

    STATIC_ARR double  ramp[3][4][4] ;	/* float ramps	    - weighted iEP		 
	    			   first  index	    - channel number
				   second index	    - ramp number;
				   third index	    - (new)point number	    */

    STATIC_ARR double  rampVal[3][4][4*MAX_PIXEL_PER_BLOCK];	
				/* rampVal[i][j][k] - error of mapping 
				   channel i of a point unto ramp j.  where
				   k = point # * cluster # mapped to        */
    STATIC double m;
    STATIC double cf;
    
    static const int bitNum[3] = {5,6,5};	
				/* number of bits per channel		    */
    
    int     iRamp[3][4][4] ;	/* integer ramps with differnt rounding	    */

    int i,j,k;
    int i0;
    int c;
    
    
  
    int    lSB;			/* leftmost bit which can be non-zero when 
				   channel is scaled to 0..255		    */
    
    assert(nColors == 3 || nColors == 4);
    /* "unweight endpoints map; compute the lower and higher values of the 
	grid (taking upscaling into account) and weight them back	    */
    for (i = 0; i < 3; i++) {
	lSB = (1 << (8 - bitNum[i]));
	assert(w[i] != 0);
    /* some defence for real time					    */
	for (j = 0; j < 2; j++) {
	    if (w[i] != 0) 
		cf = endPointIn[j][i] / w[i] * 255.;
	    else
		cf = 0.;
	    c = (int)floor (cf);
    /* clip, just in case						    */
	    c = c < 0 ? 0 : ( c < 256 ? c : (256 - lSB));
    /* strip LSB's, according to a new format				    */
	    c &= (256 - lSB);
    /* check if expanded color still smaller then the FP one, decrease if 
       needed and possible						    */
	    if ((double)(c + (c >> bitNum[i])) >  cf)
		c = (c - lSB) < 0 ? c : (c - lSB);
    /* "rounding" down to the "expanded" color grid 			    */
	    iRamp [i][0][j]  =  iRamp [i][1+j][j] = c + (c >> bitNum[i]);
    /* get next value up the grid if exists				    */
	    c = (c  + lSB) < 256 ? (c  + lSB) : c;
    /* "rounding" up to the "expanded" color grid			    */
	    iRamp [i][2-j][j] =  iRamp [i][3][j] = c + (c >> bitNum[i]);

	}
    }
    /* generate intermediate points and floating point ramps		    */
    assert(n <= MAX_PIXEL_PER_BLOCK);

    /* check for 4 point quantization or 3 point quantization		    */
    if (nColors == 3) {
    /* 3 points quantization						    */
    	for (i = 0; i < 3; i++) {
	    for (j = 0; j < 4; j++) {
		double *p;
    /* compute intermediate points					    */
		iRamp [i][j][2] = (iRamp [i][j][0] +     iRamp [i][j][1]) / 2;
		for (k = 0; k < 3; k++) {
		    ramp[i][j][k] = (double)iRamp[i][j][k] * w[i] / 255.;
		}

    /* computer rampVal = error of mapping particular original point k onto a 
       cluster point (0,1,2,3) on a ramp j in channel i.		    */
		for (p = rampVal[i][j], k = 0; k < n; k++) {
		    *p++ = pMult[k] *
		      (q[k][i] - ramp[i][j][0]) * (q[k][i] - ramp[i][j][0]);
		    *p++ = pMult[k] *
		      (q[k][i] - ramp[i][j][1]) * (q[k][i] - ramp[i][j][1]);
		    *p++ = pMult[k] *
		      (q[k][i] - ramp[i][j][2]) * (q[k][i] - ramp[i][j][2]);
		}
	    }
	}
    } else if (nColors == 4) {
    /* 4 points quantization						    */
	for (i = 0; i < 3; i++) {
	    for (j = 0; j < 4; j++) {
		double *p;
    /* compute intermediate points					    */
		iRamp [i][j][2] = 
		  (2 * iRamp [i][j][0] +     iRamp [i][j][1] + 1) / 3;
		iRamp [i][j][3] = 
		  (    iRamp [i][j][0] + 2 * iRamp [i][j][1] + 1) / 3;
		for (k = 0; k < 4; k++) {
		    ramp[i][j][k] = (double)iRamp[i][j][k] * w[i] / 255.;
		}

    /* computer rampVal = error of mapping particular original point k onto a 
       cluster point (0,1,2,3) on a ramp j in channel i.		    */
		for (p = rampVal[i][j], k = 0; k < n; k++) {
	    	    *p++ = pMult[k] * 
		      (q[k][i] - ramp[i][j][0]) * (q[k][i] - ramp[i][j][0]);
		    *p++ = pMult[k] * 
		      (q[k][i] - ramp[i][j][1]) * (q[k][i] - ramp[i][j][1]);
		    *p++ = pMult[k] * 
		      (q[k][i] - ramp[i][j][2]) * (q[k][i] - ramp[i][j][2]);
		    *p++ = pMult[k] * 
		      (q[k][i] - ramp[i][j][3]) * (q[k][i] - ramp[i][j][3]);
		}
	    }
	}
    }

    /* macro to compute minimum square error of point N across all ramps    */

#define ACCUMULATE_MIN_POINT_ERROR(N)					    \
		 a =  p0[4*N+0] + p1[4*N+0]	+ p2[4*N+0];		    \
		 b =  p0[4*N+1] + p1[4*N+1]	+ p2[4*N+1];		    \
		 c = a + b - fabs(a-b);					    \
		 a =  p0[4*N+2] + p1[4*N+2]	+ p2[4*N+2];		    \
		 b =  p0[4*N+3] + p1[4*N+3]	+ p2[4*N+3];		    \
		 a = a + b - fabs(a-b);					    \
		 d += a + c - fabs(a-c);				    \


#define ACCUMULATE_MIN_POINT_ERROR_3(N)					    \
		 a =  p0[3*N+0] + p1[3*N+0]	+ p2[3*N+0];		    \
		 b =  p0[3*N+1] + p1[3*N+1]	+ p2[3*N+1];		    \
		 c = a + b - fabs(a-b);					    \
		 a =  2 * (p0[3*N+2] + p1[3*N+2]+ p2[3*N+2]);		    \
		 d += a + c - fabs(a-c);				    \

    assert(MAX_PIXEL_PER_BLOCK <= 16);

    /* check for 4 points or 3 points quantization			    */
    if (nColors == 4) {
    /* 4 point quantization						    */
    /* across all ramps compute the minimum error for all points and find the 
       ramp with the minimum error.					    */
	m = 2. * (w[0] * w[0] + w[1] * w[1] + w[2]*w[2]) * 
	  (double)MAX_PIXEL_PER_BLOCK;

	for (i0 = -1, i = 0; i < 64; i++) {
	    double a,b,c;
	    double *p0 = rampVal[0][i & 0x3];
	    double *p1 = rampVal[1][(i >> 2) & 0x3];
	    double *p2 = rampVal[2][(i >> 4)];
	    double d = 0.;
	    switch (n) {
		case 16: ACCUMULATE_MIN_POINT_ERROR(15)   
		case 15: ACCUMULATE_MIN_POINT_ERROR(14)   
		case 14: ACCUMULATE_MIN_POINT_ERROR(13)   
		case 13: ACCUMULATE_MIN_POINT_ERROR(12)   
		case 12: ACCUMULATE_MIN_POINT_ERROR(11)   
		case 11: ACCUMULATE_MIN_POINT_ERROR(10)   
		case 10: ACCUMULATE_MIN_POINT_ERROR( 9)   
		case  9: ACCUMULATE_MIN_POINT_ERROR( 8)   
		case  8: ACCUMULATE_MIN_POINT_ERROR( 7)   
		case  7: ACCUMULATE_MIN_POINT_ERROR( 6)   
		case  6: ACCUMULATE_MIN_POINT_ERROR( 5)   
		case  5: ACCUMULATE_MIN_POINT_ERROR( 4)   
		case  4: ACCUMULATE_MIN_POINT_ERROR( 3)   
		case  3: ACCUMULATE_MIN_POINT_ERROR( 2)   
		case  2: ACCUMULATE_MIN_POINT_ERROR( 1)   
		case  1: ACCUMULATE_MIN_POINT_ERROR( 0)   
	    }
    /* m = minimum amount of error in ramps so far, i0 = index of ramp with 
       minimum amount of error so far.					    */
	    if (d < m) {
		m = d;
		i0 = i;
	    }
	}
    } else if (nColors == 3) {
    /* 3 point quantization						    */
    /* across all ramps compute the minimum error for all points and find the 
       ramp withe the minimum error.					    */
	m = 2. * (w[0] * w[0] + w[1] * w[1] + w[2]*w[2]) * 
	  (double)MAX_PIXEL_PER_BLOCK;

        for (i0 = -1, i = 0; i < 64; i++) {
	    double a,b,c;
	    double *p0 = rampVal[0][i & 0x3];
	    double *p1 = rampVal[1][(i >> 2) & 0x3];
	    double *p2 = rampVal[2][(i >> 4)];
	    double d = 0.;
	    switch (n) {
		case 16: ACCUMULATE_MIN_POINT_ERROR_3(15)   
		case 15: ACCUMULATE_MIN_POINT_ERROR_3(14)   
		case 14: ACCUMULATE_MIN_POINT_ERROR_3(13)   
		case 13: ACCUMULATE_MIN_POINT_ERROR_3(12)   
		case 12: ACCUMULATE_MIN_POINT_ERROR_3(11)   
		case 11: ACCUMULATE_MIN_POINT_ERROR_3(10)   
		case 10: ACCUMULATE_MIN_POINT_ERROR_3( 9)   
		case  9: ACCUMULATE_MIN_POINT_ERROR_3( 8)   
		case  8: ACCUMULATE_MIN_POINT_ERROR_3( 7)   
		case  7: ACCUMULATE_MIN_POINT_ERROR_3( 6)   
		case  6: ACCUMULATE_MIN_POINT_ERROR_3( 5)   
		case  5: ACCUMULATE_MIN_POINT_ERROR_3( 4)   
		case  4: ACCUMULATE_MIN_POINT_ERROR_3( 3)   
		case  3: ACCUMULATE_MIN_POINT_ERROR_3( 2)   
		case  2: ACCUMULATE_MIN_POINT_ERROR_3( 1)   
		case  1: ACCUMULATE_MIN_POINT_ERROR_3( 0)   
	    }
    /* m = minimum amount of error in ramps so far, i0 = index of ramp with 
       minimum amount of error so far.					    */
	    if (d < m) {
    		m = d;
		i0 = i;
	    }
	}
    }
#undef ACCUMULATE_MIN_POINT_ERROR_4    
#undef ACCUMULATE_MIN_POINT_ERROR_3    
    {
	int j0;
	double *p0 = ramp[0][i0 & 0x3];
	double *p1 = ramp[1][(i0 >> 2) & 0x3];
	double *p2 = ramp[2][(i0 >> 4)];
	double a,b, d;
	
    /* output endpoints of the ramp					    */
	assert (i0 != -1);	
	for (i = 0; i < 3; i++) {
	    for (j = 0; j < 2; j++)
    /* right align 5.6.5 color values					    */
		endPointOut[j][i] = 
		  iRamp[i][(i0 >> (i << 1)) & 0x3][j] >> (8 - bitNum[i]);
	}

    /* having found the optimal ramp, now search through all possible 
       clustering / index mapping combination on the ramp for each point to 
       determine the optimal clustering / index mapping for each point.	    */
	d = 0;
	for (i = 0; i < n; i++) {
    	    b = 2. * (w[0] * w[0] + w[1] * w[1] + w[2]*w[2]);

	    for (j0 = -1,j = 0; j < nColors; j++) {
		 a = ((q[i][0] - p0[j]) * (q[i][0] - p0[j]) +	    
		     (q[i][1] - p1[j]) * (q[i][1] - p1[j]) +	    
		     (q[i][2] - p2[j]) * (q[i][2] - p2[j])) *  pMult[i];	    
		if (a < b) {
		    b = a;
		    j0 = j;
		}
	    }
    /* d = accumulation of error so far with this particular clustering / 
       index mapping combination. j0 = index of nearest pointin the ramp.   */
	    d += b; 
	    assert(j0 != -1);
	    index[i] = j0;
	}
	return(d);
    }
		    		    
}

/*
**    
** static double allSame(int *nColors, int n, double (*q)[3], 
**   double weight[3], int endPointOut[2][3], 
**   int index [MAX_PIXEL_PER_BLOCK])
**
**	Given that all points are within the ALL_SAME_THRESHOLD
**	of the first one.  This function computes the best point that
**	could be used to represent these points in terms of weighted
**	mean square error.
**
**	Note that the point is in some format as representable via S3TC
**	i.e. it could be endpoint or interpolated point (half or one-third).
**
**	Also note that because the input is floating point, we don't 
**	generally assume that the input points actually have the same 
**	values. Instead, we assume that they are in the the small sphere with
**	the center in the first point. The radius of the sphere should be 
**	smaller then half of 1 / 255.
**
**	We assume, that the <endPointOut> are in 5.6.5 format and the decoder
**	    1. first upscales them like ....
**	    2. computes intermidiate points like ...
**		exactly as specified in S3TC.
**		Basically the function provide optimized endpoints for this 
**		particular encoder (in terms of weighted square error.)
**
**  Input:
**	int n,		- number of points to quantize
**	double (*q)[3]	- array of <n> points each of three componets, assume 
**			  to be already weighted by the weights <w>
**			  1.0)
**	double weight[3]- weight coeeficients for the corrsponding channels 
**			  (primary colors)
**    
**
**  Output
**	int endPointOut[2][3] - rounded endpoints (format integer 5, 6, 5 
**			  right aligned and NOT PACKED)
**	int index [MAX_PIXEL_PER_BLOCK] - indecies mapping original point to
**			  the 4 colors ramp computed with end-
**    			  points <ndPointOut>  The indicies are like follows:
**			  unpacked, and the mapping is as specified in S3TC 
**			  spec.
**
**      NOTE: the indices are as in S3TC but the order of the endpoints is
**	    arbitrary, so during packing one needs to check the ordering
**	    of the endpoints and possibly change the indices to reflect
**	    swapping of endpoints.
**  
**  Return value is error measure (linear relation of square error).
**
*/
static double allSame(int *nColors, int n, double (*q)[3], double weight[3], 
  int endPointOut[2][3], int index [MAX_PIXEL_PER_BLOCK]) {

    /* Because the input is floating point, we don't generally assume that 
    ** the input points actually have the same values. Instead, we assume
    ** that they are in the the small sphere with the center in the first 
    ** point. The radius of the sphere should be smaller then 1 / 255 / 2   
    */

    /* Table of representable (by means of S3T block) points of 256 grid.   
       This should be static, and suppose to be initialized to 0. 
       We use dynamic initialization for flexibility reasons.		    */  
									    
    STATIC_ARR double colorError[3];	
				/* squared error for the block for each of 
				   endpoint, one half, one third 
				   representations 			    */

    static struct gridPoint_ {
	unsigned char valid;	/* if set, the value (defined by first index)
				   in the channel (defined by the second index)
				   is represetable with the coefficient defined
				   by the third index.			    */
	unsigned char point[2];	/* endpoints to interpolate on, if the 
				   value is represetable		    */
    } grid[256][3][3];		/* first index	- value of the channel
				   second index	- cannel (color), RGB
				   third index	- representation type: 
				   endpoint, one half, one third 	    */
    
    static int initFlag = 0;	/* set if the table has been initialized    */
    static int size[3] = {5,6,5};   
				/* with in bits of the RGB values for S3TC  
				   endpoints				    */ 
    static int intCoeff[3][4] =
	{{1, 0, 0, 1},{1, 1, 0, 2},{1, 2, 1, 3}};
				/* array of interpolation coeffitients to get
				   "endpoint", "one half", and "one third"
				   points like this:
				   (intCoeff[j][0] * p0 +intCoeff[j][1] * p1 +
				    intCoeff[j][2]) /intCoeff[j][3]	    */


    int channelValue[3][3];	/* channelValue[i][j] is the best representable
				   8 bit value for the channel i and 
				   representation (endpoint, one half, one 
				   third)				    */


    int i,j,k,l,m;

    assert(*nColors == 3 || *nColors == 4);

    if (! initFlag ) {
	int p,p0,p1;

	initFlag = 1;
    /* initialize table							    */
	for (l = 0; l < 3; l++) {
	    for (i = (1 << size[l]) - 1; i >=0; i--) {
    /* we use always the first 1/3rd point, so j should run from the beginning
       of the range; performance is not an issue here			    */
		for (j = (1 << size[l]) - 1; j >= 0 ; j--) {
    /* compute end values						    */
		    p0 = (i << (8-size[l])) | (i >> (2 * size[l] - 8));
		    p1 = (j << (8-size[l])) | (j >> (2 * size[l] - 8));
		    for(k=0; k < 3; k++) {
    /* compute represetable value with the end values above		    */
			p = (intCoeff[k][0] * p0 +intCoeff[k][1] * p1 +
			  intCoeff[k][2]) /intCoeff[k][3];
    /* let's try to make interval smaller; good for the decoder accuracy    */
			if (! grid[p][l][k].valid || 
			  abs(grid[p][l][k].point[1] -  
			      grid[p][l][k].point[0]) > abs(p1-p0)) {
    /* mark representable points					    */
			    grid[p][l][k].valid  = 1;
			    grid[p][l][k].point[0] = 
			      (unsigned char) (i << (8-size[l]));
			    grid[p][l][k].point[1] = 
			      (unsigned char) (j << (8-size[l]));
			}
		    }
		}
	    }
	}
    }

    /* For all of coefficients...					    */
    for (j = 0; j < *nColors - 1; j++) {
        int delta;		/* look a representable value above or below*/
        int cTopBot[2];		/* closest representable values above and 
				   below				    */ 
        STATIC_ARR double error[2];	/* error (for the block) for the the value
				   cTopBot[]				    */ 

	colorError[j] = 0;
    /* For all of color shannels					    */
	for (i = 0; i < 3; i++) {

    /* Pick the first input point, and round its j'th channel to 8-bit grid */
	    int c = (int)floor (q[0][i] * 255. / weight[i] + 0.5);
    
    /* Clip, just in case						    */
	    c = c < 0 ? 0 : ( c < 256 ? c : 255);

    /* get the represetable point first above then below and pick the one with
       the smallest error for the set of original points;		    */
	    for (delta = 1, l = 0; l < 2; l++, delta = -delta) {
    /* If the value of c is representable, to get the second point we need to 
       move in the direction  of q[0][i] from it			    */
		if (! grid[k = c][i][j].valid || 
		  (q[0][i] * 255. / weight[i] - (double) c) * (double) delta > 0 ) {
		    k = c + delta;
	    	    k = k < 0 ? 0 : (k < 256 ? k : 255);
    /* 0 and 255 are representable with any of coefficients, so the  
       loop will stop							    */
    		    for ( ;!grid[k][i][j].valid; k += delta);   
				/* empty loop body on purpose		    */  
    		}
    /* Compute error for this channel					    */
		for (error[l] = 0, m = 0; m < n; m++) {
		    double d = (double)k  * weight[i] - q[m][i] *255.;
		    error[l] += d*d;
		}
	        cTopBot[l] = k;
	    }

	    if (error[0] < error[1]) {
		colorError[j] += error[0];
		channelValue[i][j] = cTopBot[0];	    
	    }
	    else if (error[0] > error[1]) {
		colorError[j] += error[1];
		channelValue[i][j] = cTopBot[1];	    
	    }
	    else {
		colorError[j] += error[1];
    /* analog of even/odd rounding					    */
		channelValue[i][j] = (c & 1) ? cTopBot[0]:cTopBot[1];	    
	    }

	}

    }

    if (*nColors == 4) 
	j = ( (colorError[0] <= colorError[1]) ? 
	  ( (colorError[0] <= colorError[2]) ? 0 : 2) :
	  ( (colorError[1] <= colorError[2]) ? 1 : 2) );
    else if (*nColors == 3) 
	j = ( (colorError[0] <= colorError[1]) ? 0: 1 );

    for (i = 0; i < 3; i++)
        for (k = 0; k < 2; k++)
    /* right align 5.6.5 color values					    */
	    endPointOut[k][i] = 
	      grid[channelValue[i][j]][i][j].point[k] >> (8-size[i]);
	
    for (i = 0; i < n; i++)
        index[i] = j + 1; 
    
    if (j != 0)
	*nColors = j + 2; 
    /* else just keep nColors it as it was				    */

    return(colorError[j]);
}


/*
**    
**  static double mapAndRoundMult(int *nColors, int levelLimit, int n, 
**	double (*q)[3], double *pMult, 
**	double weight[3], double endPointIn[2][3], int endPointOut[2][3], 
**	int index [MAX_PIXEL_PER_BLOCK])
**
**	Generate all possible color ramps given particular number of points 
**	on a color ramp derived from continuous calculation.
**	Say you have a two point color ramp, it could be mapped to three
**	point or four point ramps in different ways.  So this function 
**	explores such different mapping and find the best one.
**
**	This is needed to optimize small variance blocks into higher effective
**	resolution than 5,6,5 resolution.
**
**	We assume, that the <endPointOut> are in 5.6.5 format and the decoder
**	    1. first upscales them like ....
**	    2. computes intermidiate points like ...
**		exactly as specified in S3TC.
**		Basically the function provide optimized endpoints for this 
**		particular encoder (in terms of weighted square error.)
**
**  Input:
**      int *nColors    - number of colors on ramp (two, three or four)
**	int levelLimit	- maximum allowed number of the points in color ramp 
**	int n,		- number of points to quantize
**	double (*q)[3]	- array of <n> points each of three componets, assume 
**			  to be already weighted by the weights <w> (but not
**			  centered!)
**      double *pMult	- multiplicity factor (sum of all factors should be
**			  1.0)
**	double w[3]	- weight coeeficients for the corrsponding channels 
**			  (primary colors)
**	endPointIn[2][3]- two endpoints of the ramp, weighted by the weights 
**			  <w>, which is the result of the continuous 
**			  quantization.
**
**  Output
**      int *nColors    - number of actual points on ramp (three or four)
**	int endPointOut[2][3] - rounded endpoints (format integer 5, 6, 5 
**			  right aligned and NOT PACKED)
**	int index [MAX_PIXEL_PER_BLOCK] - indecies mapping original point to
**			  the 4 colors ramp computed with end-
**    			  points <ndPointOut>  The indicies are like follows:
**			  unpacked, and the mapping is as specified in S3TC 
**			  spec.
**      NOTE: the indices are as in S3TC but the order of the endpoints is
**	    arbitrary, so during packing one needs to check the ordering
**	    of the endpoints and possibly change the indices to reflect
**	    swapping of endpoints.
**
**  Return value is error measure (linear relation of square error).
**
*/

static double mapAndRoundMult(int *nColors, bool bForce4, int levelLimit, int n, double (*q)[3], double *pMult, 
    double weight[3], double endPointIn[2][3], int endPointOut[2][3], 
    int index [MAX_PIXEL_PER_BLOCK]) {

    static int	mapNumber[2][3] = 
	{{2, 0, 0}, {6, 2, 0}} ;
				/* Array holding number of additional different
				   mappings of short ramps (2 and 3 colors) to 
				   longer ramps (besides endpoints to endpoints 
				   on the smallest ramp) 

				   first index  - 0 mapping to 3 level ramp
					        - 1 mapping to 4 level ramp	
				   second index - <(input) nColors - 2>	    */

    static double mapCoeff[2][2][6][2][2] =
				/* Array of coefficients to generate endpoint
				   colors for mapping short ramps (2 and 3 
				   colors) to longer ramps.
				   Only initialized coefficients are used.

				   first index  - 0 mapping to 3 level ramp
					        - 1 mapping to 4 level ramp	
				   second index - <(input) nColors - 2>
						  (there are now additional 
						  mappings for four color ramp)
				   third index  - mapping number (up to five 
						  possible)
				   forth index  - endpoint (0 or 1)
				   fith index   - coeeficient number (for the
						  first and second original 
						  endpoints)		    */
    {
        /* mappings to 3 color ramp						    */
	    { 
        /* two clusters							    */
	        {
	            {{  2. , -1. }, {  0. , 1. }},
	            {{  1. ,  0. }, { -1. , 2. }}
	        }
        /* three clusters							    */

	    },
        /* mappings to 4 color ramp						    */
	    { 
        /* two clusters							    */
	        {
	            {{  1. ,  0. }, {  0. , 1. }},
	            {{  1. ,  0. }, { -2. , 3. }},
	            {{  3. , -2. }, {  0. , 1. }},
	            {{  2. , -1. }, { -1. , 2. }},
	            {{  1.5, -0.5}, {  0. , 1. }},
	            {{  1. ,  0. }, { -0.5, 1.5}},

	        },
        /* three clusters							    */
	        {
	            {{  1.5, -0.5}, {  0. , 1. }},
	            {{  1. ,  0. }, { -0.5, 1.5}},
	        }
        }
    };

    STATIC_ARR double colorInVar[2][3];
    STATIC_ARR double e[2];		/* error for current and next mapping	    */
    int endPointOutVar[2][2][3];/* integer (5.6.5) endpoint colors for 
				   current and nex mapping		    */
    int outLevVar[2];		/* level (number of clusters in ramp) for 
				   current and nex mapping		    */
    int indexVar[2][MAX_PIXEL_PER_BLOCK];

		    
    int i, j, k, l;  
    int m;

    assert(*nColors > 1);
    assert(levelLimit > 1);
    assert(*nColors <= levelLimit);

    /* check "default" mapping						    */
    
    m = 0;
    
    outLevVar[m] = ( ( *nColors == 4 || bForce4 ) ? 1 : 0 );
    
    e[m] = roundMult (outLevVar[m] + 3, n, q, pMult, weight, endPointIn, endPointOutVar[m], 
      indexVar[m]);
    
    m = 1 - m;

    levelLimit -= 2;
    *nColors  -= 2;
    
    for (i = bForce4 ? 1 : 0; i < levelLimit; i++) {	/* enumerate ramps (3 or 4 clusters)*/
	for (j = 0; j < mapNumber[i][*nColors]; j++) {
					/* enumerate mappings for this ramp */
	    for (k = 0; k < 2; k ++) {	/* enumerate two new endpoints	    */
		for (l = 0; l < 3; l ++) {
					/* enumerate three color channels for 
					   endpoint			    */ 
		    colorInVar[k][l] = 
			mapCoeff[i][*nColors][j][k][0] * endPointIn[0][l] +
			mapCoeff[i][*nColors][j][k][1] * endPointIn[1][l];
    /* check clipping, don't waist time if out of range (not suppose to be) */
    /* we assume lower bound is alway 0 here, as the color space is standrd,
       the points however are weigted, so the upper bound may vary	    */
		    
		}
	    }
	    outLevVar[m] = i;
	    e[m] = roundMult (i + 3, n, q, pMult, weight, colorInVar, endPointOutVar[m], indexVar[m]);
    /* swap bufeers if new one is better				    */
	    if (e[m] < e[1 - m])
		m = 1 - m;
	}
    }
    m = 1 - m;
    for (i = 0; i < n; i++)
	index[i] = indexVar[m][i];
    for (i = 0; i < 2; i++)
	for (j = 0; j < 3; j++)
	    endPointOut[i][j] = endPointOutVar[m][i][j];
    *nColors = outLevVar[m] + 3;
    return(e[m]);
}


/*****************************************************************************
**									    **
**	MAIN RGB QUANTIZER					    	    **
**									    **
*****************************************************************************/

/*
**    
**  void CodeRGBBlock(RGBBlock *block)
**
**	Main RGB quantizer, take in a block (see S3_quant.h for details of 
**	block structure), and returns the block quantized.
**
**  Input:
**	RGBBlock *block - block of rgb color data and quantization parameters
**			  (for details, see S3_quant.h)    
**
**  Output
**	RGBBlock *block - block of rgb color data quantized as per S3TC spec
**			  (for details, see S3_quant.h)    
**
*/

void CodeRGBBlock(RGBBlock *block) {
    STATIC_ARR double q[MAX_PIXEL_PER_BLOCK][3];
			        /* RGB channel values, weighted		    */
    STATIC_ARR double qC[MAX_PIXEL_PER_BLOCK][3];
			        /* RGB channel values, weighted, centered   */
    STATIC_ARR double gC[3];		/* RGB pixels gravity center, weighted	    */
    
    /* Non-redundunt points are essential for rounding performace	    */
    
    STATIC_ARR double qNoRep[MAX_PIXEL_PER_BLOCK][3];
			        /* RGB channel values, with equal points
				   removed				    */
    STATIC_ARR double qCNoRep[MAX_PIXEL_PER_BLOCK][3];

    STATIC_ARR double pMult[MAX_PIXEL_PER_BLOCK];
			        /* Multiplicity of each point of qNoRep
				   in the original set			    */			      
    
    
    STATIC_ARR double weight[3];

    STATIC_ARR double range[2][3];		/* clipping range in centered coordinate 
				   system				    */

    STATIC_ARR double axis[3];

    STATIC_ARR double e[2];
    STATIC_ARR double endPointOut[2][2][3];
    STATIC double nRec;

    int indexMult[MAX_PIXEL_PER_BLOCK];
				/* index to map q[] onto qNoRep		    */
    int outIndexMult [MAX_PIXEL_PER_BLOCK];
				/* quantized index fro qNoRep		    */

    int index[INDEX_LOG_SIZE][MAX_PIXEL_PER_BLOCK];        
    int indexStore[2][MAX_PIXEL_PER_BLOCK];

    int levelLimit[2];
    
    int i, j, n, l;
    
    int nNoRep;

    int indexLogEnd;
    int indexLogFull;
    int sameIndex;
    
    int m;
    int count;
    int allsame = 1;
    int clipFlag = 0;
    
    if (block == NULL)
	return;
    n = block->n;
    
    if (n == 0)
	return;

    nRec = 1/ (double) n;

    for (j = 0; j < 3; j++)	
	weight[j] = (block->weight[j]<0)?0.:block->weight[j];

    /*  weight colors, check if all are the same and compute gravity center */
    for (j = 0; j < 3; j++) {
	for (gC[j] = 0., i = 0; i < n; i++) {
	    allsame &= 
	      fabs(block->colorChannel[i][j] - block->colorChannel[0][j]) <
	      ALL_SAME_THRESHOLD;
	    gC[j] += (q[i][j] =  block->colorChannel[i][j] * weight[j]);
	}
    }
    
    if (allsame) {
    /* code the block							    */
	levelLimit[0] = block->inLevel;
        allSame(levelLimit, n, q, weight, block->endPoint, block->index );
	block->outLevel = levelLimit[0];
	return;
    }


    /* compute centered source points and range				    */
    for (j = 0; j < 3; j++) {
	for (gC[j] /= (double) n, i = 0; i < n; i++) 
	    qC[i][j] = q[i][j] - gC[j];
	range[0][j] = - gC[j];
	range[1][j] = weight[j] - gC[j];
    }

    /* get rid of multiplicity						    */
    for (nNoRep = i = 0; i < n; i++) {
	    for (j = 0; j < nNoRep; j ++) {
	        if (qNoRep[j][0] == q[i][0] && qNoRep[j][1] == q[i][1] && 
	          qNoRep[j][2] == q[i][2]) 
		        break;
	    }
	    if (j == nNoRep) {
	        qNoRep[j][0] = q[i][0];
	        qNoRep[j][1] = q[i][1];
	        qNoRep[j][2] = q[i][2];
	        qCNoRep[j][0] = qC[i][0];
	        qCNoRep[j][1] = qC[i][1];
	        qCNoRep[j][2] = qC[i][2];
	        pMult[j] = 1;
	        nNoRep++;
	    }
	    else {
    	        qCNoRep[j][0] += qC[i][0];
	        qCNoRep[j][1] += qC[i][1];
	        qCNoRep[j][2] += qC[i][2];
	        pMult[j]++;
	    }
	    indexMult[i] = j;
    }

    /* normalize mulipicators						    */
    for (i = 0; i < nNoRep; i++) {
	pMult[i] *= nRec;
	qCNoRep[i][0] *= nRec;
	qCNoRep[i][1] *= nRec;
	qCNoRep[i][2] *= nRec;
    }

    
    /* two colors bypass						    */
    if (nNoRep == 2) {
	    block->outLevel = 2;
	    mapAndRoundMult(&(block->outLevel), block->inLevel == 4, block->inLevel,  nNoRep, qNoRep, 
	        pMult, weight, qNoRep, block->endPoint, outIndexMult);     
   
        /* restore index with multiplicity					    */
	    for (i = 0; i < n ; i++)
	        block->index[i] = outIndexMult[indexMult[i]];
	    return;
    }

    indexLogFull = indexLogEnd = 0; 
    getAxis(n, qC, axis);
    sortProjection(nNoRep, qNoRep, axis, index[0], 0);

    for (i = 0; i < 2; i++) {
	    count = UNCLIPPED_ITERATION_LIMIT;
	    
	    do {
        /* !!! search and search clipped use different levelLimint convention;
           it should be less by one						    */	
	        levelLimit[i] =  block->inLevel - 1;
    
        /* bypass the fist time when i== 1 to put new index on the index log
           (axis is coming from <getDiameter>				    */
	        
	        if (i - 1 + count != UNCLIPPED_ITERATION_LIMIT) {
	            e[i] = search43Mult (levelLimit + i, nNoRep, qCNoRep, pMult, 
		                                index[indexLogEnd], endPointOut[i], axis);
                /* biggest number of indexing to consider				    */
		        m = i;
	        }
	        else {
        /* get new axis							    */
		    getDiameter(nNoRep, qNoRep, axis);
	        }

	        indexLogEnd = (indexLogEnd + 1) % INDEX_LOG_SIZE;
	        indexLogFull |= (indexLogEnd == 0);

	        for (l =0; l < 2; l++) {
		        sortProjection(nNoRep, qNoRep, axis, index [indexLogEnd],l );
		        
		        for (j = indexLogEnd - 1; j >= 0; j--) {
            /* yes, this is an assigment in if					    */
		            if ((sameIndex = 
		              sameOrder(nNoRep, index[j], index[indexLogEnd])))
			            break;
		        }

		        if (!sameIndex && indexLogFull)   
		            for (j = indexLogEnd + 1; j < INDEX_LOG_SIZE; j++) {

            /* yes, this is an assigment in if					    */
			        if ((sameIndex = 
			          sameOrder(nNoRep, index[j], index[indexLogEnd])))
			            break;
		            }
		        if (!sameIndex || count == 0)
		            break;
	        }
	    }
	    while (count-- != 0 && ! sameIndex);

	    for (j = 0; j < nNoRep; j++)
	        indexStore[i][j] = index[indexLogEnd][j];
    }

    /* pick the best one						    */

    if (m == 1)
	m = (e[0] < e[1] ? 0 : 1);

    /* check clipping							    */
    for (clipFlag =0, i = 0; i < 2; i++) 
	for (j = 0; j < 3; j++)
	    clipFlag = clipFlag || (endPointOut[m][i][j] < range[0][j]) ||
	      (endPointOut[m][i][j] > range[1][j]); 
    
    if (clipFlag) {
    /* start with the best unclipped index				    */
	for (i = 0; i < nNoRep; i++)
		index[0][i] = indexStore[m][i];

	count = CLIPPED_ITERATION_LIMIT;
	indexLogFull = indexLogEnd = 0; 

	do {
    /* !!! FIXME: seach and seach clipped use different levelLimint convention;
       it should be less by one						    */	
	    levelLimit[m] =  block->inLevel - 1;
	    e[m] = searchClipped43Mult (levelLimit + m, nNoRep, qCNoRep, pMult, 
		index[indexLogEnd], 
		range, endPointOut[m], axis);
	    
	    indexLogEnd = (indexLogEnd + 1) % INDEX_LOG_SIZE;
	    indexLogFull |= (indexLogEnd == 0);

	    for (l =0; l < 2; l++) {
		sortProjection(nNoRep, qNoRep, axis, index [indexLogEnd],l );
		
		for (j = indexLogEnd - 1; j >= 0; j--) {
    /* yes, this is an assigment in if					    */
		    if ((sameIndex = 
		      sameOrder(nNoRep, index[j], index[indexLogEnd])))
			    break;
		}

		if (!sameIndex && indexLogFull)   
		    for (j = indexLogEnd + 1; j < INDEX_LOG_SIZE; j++) {

    /* yes, this is an assigment in if					    */
			if ((sameIndex = 
			  sameOrder(nNoRep, index[j], index[indexLogEnd])))
			    break;
		    }
		if (!sameIndex)
		    break;
	    }

	}
	while (count-- != 0 && ! sameIndex);

    }

    /* transfom endpoints to original (uncentered) system		    */
    for (i = 0; i < 2; i++) 
	for (j = 0; j < 3; j++) 
	    endPointOut[1-m][i][j] = endPointOut[m][i][j] + gC[j];

    block->outLevel = levelLimit[m]+1;

    mapAndRoundMult(&(block->outLevel), block->inLevel == 4, block->inLevel,  nNoRep, qNoRep, 
	pMult, weight, endPointOut[1-m], block->endPoint, outIndexMult);     
    
    /* restore index with multiplicity					    */
    for (i = 0; i < n ; i++)
	block->index[i] = outIndexMult[indexMult[i]];

}

/*****************************************************************************
**									    **
**	MAIN ALPHA QUANTIZER					    	    **
**									    **
*****************************************************************************/

/*
**    
** void CodeAlphaBlock(AlphaBlock *b)
**
**	Main alpha quantizer, take in a block containing alpha data
**	(see S3_quant.h for details of block structure), and returns the block 
**	quantized.)
**
**  Input:
**	AlphaBlock *b - block of alpha data and quantization parameters
**			  (for details, see S3_quant.h)    
**
**  Output
**	AlphaBlock *b - block of alpha color data quantized as per S3TC spec
**			  (for details, see S3_quant.h)    
**
*/
void CodeAlphaBlock(AlphaBlock *b) {
    /* quantization combinations to run
    comb#	ramp size	0 or 1 preserved?
    0	    -	8		(0 in 1 in)
    1	    -	6		(0 in 1 in)
    2	    -	6		(0 out 1 in)
    3	    -	6		(0 in 1 out)
    4	    -	6		(0 out 1  out)
    */

    STATIC_ARR double  e    [5];

    STATIC_ARR double  alphaFiltered   
			    [5][MAX_PIXEL_PER_BLOCK];

    int	    newLevel	    [5] = {8,6,6,6,6};
    int	    index	    [5][MAX_PIXEL_PER_BLOCK];
    int	    nFiltered	    [5];
    int	    endPointOut	    [5][2];

    int	    zeroMask	    [5] = {0,0,1,0,1};
    int	    oneMask	    [5] = {0,0,0,1,1};
    int	    mask[5];

    int	    enforceZero;
    int	    enforceOne;

   
    int i, j, k;

    /* filter alpha set to try different quantizations			    */
    for (i = 0; i < 5; i++) 
	nFiltered[i] = 0;

    for (i = 0; i < b->n; i++) {
	alphaFiltered[0][nFiltered[0]] = b->alpha[i];
	nFiltered[0] += 1;
	alphaFiltered[1][nFiltered[1]] = b->alpha[i];
	nFiltered[1] += 1;
	if (b->alpha[i] != 0.) {
	    alphaFiltered[2][nFiltered[2]] = b->alpha[i];
	    nFiltered[2] += 1;
	}
	if (b->alpha[i] != 1.) {
	    alphaFiltered[3][nFiltered[3]] = b->alpha[i];
	    nFiltered[3] += 1;
	}
	if (b->alpha[i] != 0. && b->alpha[i] != 1.) {
	    alphaFiltered[4][nFiltered[4]] = b->alpha[i];
	    nFiltered[4] += 1;
	}
    }
    enforceZero = (b->need0 && nFiltered[0] != nFiltered[2]);
    enforceOne  = (b->need1 && nFiltered[0] != nFiltered[3]);

    mask[0] = 1;
    mask[1] = 1;
    mask[2] = (nFiltered[2] != nFiltered[1]);
    mask[3] = (nFiltered[3] != nFiltered[1]);
    mask[4] = (nFiltered[4] != nFiltered[1]);
    
    for (i = 0; i < 5; i++) {
	if (mask[i]) {
	    e[i] = quantizeAlpha (newLevel[i], nFiltered[i], alphaFiltered[i],  
	      endPointOut[i], index [i]);
    /*	see if  will be  OK to use					    */     
	    mask[i] = 1;
	    if (enforceZero && ! zeroMask[i])
		mask[i] &= (endPointOut[i][0] == 0 || endPointOut[i][1] == 0);
	    if (enforceOne  && ! oneMask[i])
		mask[i] &= (endPointOut[i][0] == 255 || endPointOut[i][1] == 255);

        if( mask[i] && b->protectnonzero )
        {
            // If we met our need0/need1 requirements, then
            // make sure we meet protect-non-zero
            for( j = 0; j < nFiltered[i]; j++ )
            {
                if( alphaFiltered[i][j] != 0.0 && 
                    index[i][j] <= 1 &&
                    endPointOut[i][ index[i][j] ] == 0 )
                {
                    // Loop over each interpolated value.
                    // If the original is non-zero, and
                    // we've quantized to an endpoint (0 or 1).
                    // and that endpoint is the zero one
                    // then we have to do something
                    if( !enforceZero || zeroMask[i] )
                    {
                        // If we don't need to have an endpoint of 0,
                        // (wasn't asked for, weren't any zeros, or
                        // this option uses the explicit 0), then
                        // just squeeze it in
                        if( endPointOut[i][0] == 0 )
                            endPointOut[i][0] = 1;
                        else if( endPointOut[i][1] == 0 )
                            endPointOut[i][1] = 1;
                    }
                    else
                    {
                        // We do need that endpoint to be zero, so
                        // this option is no good
                        mask[i] = 0;
                    }
                    break;
                }
            }
        }
	}
    }

    /* get the best sutable						    */
    for (i = 0; i < 5; i++)
	if (mask[i])
	    break;

    for (k = i++ ; i < 5; i++)
	if (mask[i] && e[i] < e[k])
	    k = i;

    b->outLevel	    = newLevel[k];
    b->endPoint[0]  = endPointOut[k][0];
    b->endPoint[1]  = endPointOut[k][1];
    for (i = j = 0; i < b->n; i++) {
	if (b->alpha[i] == 0. && zeroMask[k]) 
	    b->index[i] = 6;
	else if (b->alpha[i] == 1. && oneMask[k]) 
	    b->index[i] = 7;
	else  
	    b->index[i] = index[k][j++];
    }
}

/*****************************************************************************
**									    **
**	ALPHA QUANTIZING ROUTINE					    **
**									    **
*****************************************************************************/

/*
**
**  static double quantizeAlpha (int level, int n, 
**    double alpha[MAX_PIXEL_PER_BLOCK], int endPointOut[2], 
**    int  index [MAX_PIXEL_PER_BLOCK])
**
**	Main alpha quantization routine.  Takes in alpha values, and via
**	heuristic method encode the alpha values on ramp divided 
**	into 6 or 8 bins.
**
** INPUT
**    int level	    - ramp size (6 or 8)
**    int n	    - number of alpha values
**    double alpha[MAX_PIXEL_PER_BLOCK]
**		    - actual alpha values
**    
** OUTPUT
**    int endPointOut[2]
**		    - 8 bit alpha ramp endpoints
**    int  index [MAX_PIXEL_PER_BLOCK])
**		    - indices as in S3TC
**
** RETURN VALUE: error measurement (linear of mean square error)
**
*/
static double quantizeAlpha (int level, int n, 
  double alpha[MAX_PIXEL_PER_BLOCK], int endPointOut[2], 
  int  index [MAX_PIXEL_PER_BLOCK]) {

    STATIC_ARR double binBoundary[MAX_ALPHA_LEVELS -1];
				/* array of current bin (cluster) boundaries*/
    STATIC_ARR double alphaCentered[MAX_PIXEL_PER_BLOCK];
				/* array of centered alpha values	    */
    
    STATIC_ARR double endPoint[2];		
				/* current ramp endpoints, usually centered */
    STATIC_ARR double endPoint_[2];		
				/* current ramp endpoints, usually centered */
  
    STATIC double qS;		/* average of uncentered alphas, (gravity 
				   center) 				    */
    STATIC double kS, kq, k2;	
				/* curren values of linear and quadratic 
				   forms to evaluate target functional, see
				   S3TC made easy			    */
    STATIC double e;		/* error				    */
    STATIC double num;		/* numerator of the error functional	    */
    STATIC double den;		/* denominator of the error functional	    */

    STATIC double nD;		/* n in double				    */
    STATIC double nR;		/* reciprocal of n			    */

    int cluster[MAX_ALPHA_LEVELS];
				/* number of points in each cluster, the 
				   the index here goes sequentially  along 
				   linear ramp				    */
    int clusterEnd[2][MAX_ALPHA_LEVELS];
				/* smallest and biggest value (if exist) 
				   in each cluster			    */
    int newAlpha[MAX_ALPHA_LEVELS];
				/* final integer alpha values for each cluster
				   in the original coordinate system	    */ 
  
    int i, j, k, l;
    int count = ALPHA_ITERATION_LIMIT;
				/* Counter to implement forced exit out of 
				   incremental optimzer (as otherwise the
				   number of iterations can potentially be 
				   very big and infinite cycling is possible 
				   as well)
				   In practiacal cses, though, expect about 
				   order of 3 iteretions per block on 
				   average				    */

    int stable;			/* Flag to indicate the optimal solution
				   (on phase 1 or on phases 1 and 2 has been
				   reached and the optimization can be 
				   stopped				    */
    int nClusters;		/* Current number of non-empty clusters	    */


    assert(level > 1 && level <= MAX_ALPHA_LEVELS);
    
    if (n == 0)
	return (0.);

    nD = (double) n;
    nR = 1 / nD;

    /* find minimum and maximum alphas, initialize index and compute sum    */
    for (qS = endPoint[0] = endPoint[1] = alpha[0], index[0] = 0, 
      i = 1; i < n; i++) {
	if (endPoint[0] > alpha[i])
	    endPoint[0] = alpha[i];
	if (endPoint[1] < alpha[i])
	    endPoint[1] = alpha[i];
	qS += alpha[i];
    /* assign all points to cluster 0, so the optimazer will classify it as 
       unstable and start to iterate (unless the case is actually 
       degenerative)							    */
	index[0] = 0;
    }
   /* compute gravity center and centered values			    */
    qS *= nR;
    for (i = 0; i < n; i++)
	alphaCentered[i] = alpha[i] - qS;
    
    endPoint[0] -= qS;
    endPoint[1] -= qS;

    /* run binning optimization						    */
    do  {
        /* assume bining is stable						    */
	    stable = 1;

        /* biuld bin boundaries and initialize clusters			    */
	    for (i = 0; i < level - 1; i++) {
	        binBoundary[i] = endPoint[0] + (endPoint[1] - endPoint[0]) / 
	          (double)(level - 1) * (0.5 + (double) i);
	        cluster[i] = 0;
	    }
	    cluster[level - 1] = 0;

        /* do binning, change this to binary search				    */

	    for (i = 0; i < n; i++) {
	        for (j = 0; j < level - 1; j++)
		    if (alphaCentered[i] < binBoundary[j])
		        break;
	        cluster[j]++;
	        stable  &= (index[i] == j);
	        index[i] = j;
	    }
        /* check if degenerate, to handle cases where all point are equal and 
           similar								    */
	    for (nClusters = 0, j = 0; j < level; j++)
	        nClusters += (cluster[j] != 0);

	    if (nClusters == 1)
	        break;

        /* stop otimization if the limit of iterations number is reached	    */

        /* compute target functional components optimal endpoints		    */
	    kq = kS = k2 =0.;
            for(i = 0; i < n; i ++) {
    	        kq += alphaCentered[i] * (double)index[i];
	        kS += (double)index[i];
	        k2 += (double)index[i] * (double)index[i];
	    }
	    kS *= nR;
	    k2 -= nD * kS * kS; 

        /* compute endpoints, do optimal cliping and final targe functional	    */
	    {
	        double k0  =	- kS;
	        double k1  = (double) level - 1. - kS;
	        double f00 = k2 + nD * k0 * k0;
	        double f01 = k2 + nD * k0 * k1;
	        double f11 = k2 + nD * k1 * k1;
	        double f0011 = f00 * f11;
	        double den_ = 
		      k2 * f0011 * f0011 * 
		      (double)(level - 1.) * (double)(level -1.); 
	        double num_ = 0;

  	        {		    
		        double x0,  x1;
		        double x0m, x1m;
		        double x0M, x1M;
        /* clipping range for the centered points is [-qS, 1-qS]		    */			
		        x1m = - qS * k2;
		        x1M = (1. - qS) * k2;

		        x0 = k0 * kq; 
		        x1 = k1 * kq; 

		        x0m = x1m - x0;
		        x0M = x1M - x0;

		        x1m = (x1m - x1) * f00;
		        x1M = (x1M - x1) * f00;

		        x0 = (CLIP(0., x0m, x0M)) * f01;

		        x0m *= f0011;
		        x0M *= f0011;

		        x1 = CLIP (x0, x1m, x1M);

		        x0 = x1 * f01;
		        x1 *= f11;
			    
		        x0 = CLIP(x0, x0m, x0M);
        /* "rotate" varialbles						    */
    		        x0m = x0 - x1;
	    	        x0M = k0 * x1 - k1 * x0;
		        
		        num = k2 * x0m * x0m + nD * x0M * x0M - 
		          kq * kq * den_;
		        den = den_ * k2;

		        endPoint_[0] = endPoint[0];
		        endPoint_[1] = endPoint[1];

		        endPoint[0] = (x0 / f0011 + k0 * kq) / k2;
		        endPoint[1] = (x1 / f0011 + k1 * kq) / k2;
		    }
	    }
	    if (count-- == 0)
	        break;

	    if (stable) {
        /* if clustering is self consistent, try to improve it, moving biggest
           ot smallest points in the cluster to the next (previous) one,
           otherwise skip this and go to new end points computations	    */

        /* initialize  index of minimum point of clusters			    */
 	        for (j = 0; j < level; j++)
		    clusterEnd[0][j] = -1;

        /* compute minimum and maximum points of the cluster		    */
	        for (i = 0; i < n; i++) {
        /* get cluster number						    */
		    j = index[i];
        /* update minimum and maximum points of the cluster			    */
		    if (clusterEnd[0][j] == -1)
		        clusterEnd[0][j] = clusterEnd[1][j] = i;
		    else {
		        if (alphaCentered[clusterEnd[0][j]] > alphaCentered[i])
			    clusterEnd[0][j]  = i;
		        if (alphaCentered[clusterEnd[1][j]] < alphaCentered[i])
			    clusterEnd[1][j]  = i;
		    }
	        }
        /* try to move points up or down to the next bin			    */
	        for (l = 0; l < 2; l++) {
		    double f = (l == 0 ? 1. : -1);
		    double kST = kS + f * nR;
		    double  k2T_0 = k2 + 1. - f * 2. * kS - nR;
		    for (j = l; j < level - 1 + l; j++) {
        /* don't allow collupse to a single cluster				    */
		        if (cluster[j] != 0 && (cluster[j] > 1 || nClusters > 2)) {
			    double kqT = kq + f * alphaCentered[clusterEnd[1-l][j]];
			    double k2T = k2T_0 + f * 2. * (double) j;
        /* compute endpoints, do optimal cliping and final targe functional	    */
		        
			    double k0  =	- kST;
			    double k1  = (double) level - 1.- kST;
			    double f00 = k2T + nD * k0 * k0;
			    double f01 = k2T + nD * k0 * k1;
			    double f11 = k2T + nD * k1 * k1;
			    double f0011 = f00 * f11;
			    double den_ = 
			       k2T * f0011 * f0011 * 
			       (double)(level - 1.) * (double)(level -1.); 
			    double num_;

			    double x0,  x1;
			    double x0m, x1m;
			    double x0M, x1M;
        /* clipping range for the centered points is [-qS, 1-qS]		    */			
			    x1m = - qS * k2T;
			    x1M = (1. - qS) * k2T;
    
			    x0 = k0 * kqT; 
			    x1 = k1 * kqT; 

			    x0m = x1m - x0;
			    x0M = x1M - x0;

			    x1m = (x1m - x1) * f00;
			    x1M = (x1M - x1) * f00;

			    x0 = (CLIP(0., x0m, x0M)) * f01;

			    x0m *= f0011;
			    x0M *= f0011;

			    x1 = CLIP (x0, x1m, x1M);

			    x0 = x1 * f01;
			    x1 *= f11;
			    
			    x0 = CLIP(x0, x0m, x0M);
        /* "rotate" varialbles						    */
    			    x0m = x0 - x1;
	    		    x0M = k0 * x1 - k1 * x0;

		        

			    num_ = k2T * x0m * x0m + nD * x0M * x0M - 
			          kqT * kqT * den_;
			    den_ = den_ * k2T;

			    if (num * den_  > num_ * den ) {
			        endPoint[0] = (x0 / f0011 + k0 * kqT) / k2T;
			        endPoint[1] = (x1 / f0011 + k1 * kqT) / k2T;
			        num = num_;
			        den = den_;
			        stable = 0;
			        break;
			    }
		        }
		    }
		    if (!stable)
		        break;
	        }
	    }
  
        /* the very first run we checked vs index of all zeros, so the result
           will be "unstable" (as the endpoints were different) and we'll go to 
           iterate into the optimizer					    */
    } while (! stable);

    for (i = 0; i < 2; i++) {
	newAlpha [i] = (int)floor((endPoint[i]  + qS) * 255. + 0.5);
        newAlpha[i] = (newAlpha[i] < 0 ? 0 : (newAlpha[i] > 255 ? 255 : newAlpha[i])); 
    }

    for (i = 2; i < level; i++) 
	newAlpha[i] = ((level - i) * newAlpha[0] +  (i - 1) * newAlpha[1] + 
	  (level - 2) / 2) / (level - 1);  

    endPointOut[0] = newAlpha [0];
    endPointOut[1] = newAlpha [1];
    
    for (e = 0., i = 0; i < n; i++) {	
	for (k = 0, j = 1; j < level; j++) 	
	    if (fabs((double)newAlpha[j] - alpha[i] * 255.) < 
	      fabs((double)newAlpha[k] - alpha[i] * 255.))
		k = j;
	index[i] = k;
	e += ((double)newAlpha[k] - alpha[i] * 255.) * ((double)newAlpha[k] - alpha[i] * 255.);
    }
    return (e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\dxtc\sources.inc ===
MAJORCOMP=directx
MINORCOMP=d3d

TARGETNAME=dxtc$(D)

TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES);..\..\inc

SOURCES = \
     s3_intrf.cpp \
     s3_quant.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\link\xbox\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\inc\xgrphseg.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       xgrphseg.h
//  Content:    sets the sections for code and data in d3dx8.lib
//
///////////////////////////////////////////////////////////////////////////

#ifndef __XGRPHSEG_H__
#define __XGRPHSEG_H__

#include "xboxverp.h"

#pragma code_seg("XGRPH")
#pragma data_seg("XGRPH_RW")
#pragma bss_seg("XGRPH_RW")
#pragma const_seg("XGRPH_RD")

// Tell the linker to merge constant data and data sections into code section.
#pragma comment(linker, "/merge:XGRPH_RD=XGRPH")
#pragma comment(linker, "/merge:XGRPH_RW=XGRPH")

// Tell the linker that the code section contains read/write data.
#pragma comment(linker, "/section:XGRPH,ERW")

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_XGraphicsBuildNumberD")
__declspec(selectany) unsigned short XGraphicsBuildNumberD[8] =
        { 'X' | ('G' << 8), 'R' | ('A' << 8), 'P' | ('H' << 8), 'C' | ('D' << 8),
          VER_PRODUCTVERSION | 0x8000 };
#else
#pragma comment(linker, "/include:_XGraphicsBuildNumber")
__declspec(selectany) unsigned short XGraphicsBuildNumber[8] =
        { 'X' | ('G' << 8), 'R' | ('A' << 8), 'P' | ('H' << 8), 'C',
          VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg()
#ifdef __cplusplus
}
#endif

#endif //__XGRPHSEG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\dxtc\s3_intrf.cpp ===
// !!!!!!!!! DO NOT RELEASE THIS SOURCE FILE !!!!!!!

/*   Copyright (c) 1998  S3 Inc.  All Rights Reserved.
 *
 *   Module Name:  s3_intrf.c
 *
 *   Purpose:  highlevel interface of S3TC to DX surface
 *
 *   Author:        Dan Hung, Martin Hoffesommer
 *   Maintained by: Dan Hung
 *
 *   Revision History:
 *      -> 04/09/98 : found bad assertion in S3TCencode(), commented it out
 *      -> 05/15/98 : fixed block ordering to be as in dx spec.  alpha blocks
 *                      coded first, then rgb blocks.
 *      -> 05/18/98 : fixed bug in S3TCdecode().
 *      -> 06/01/98 : fixed alpha compare bug.
 *      -> 06/01/98 : fixed colorkey bug for non-RGB888 surfaces.
 *      04.03.01 - Cleaned up a bit and added to XGraphics.lib (JHarding)
 *
 *  version Beta 1.00.00-98-06-01
 */

// !! NOTE !! "//@@@" indicates uncertain assumption or future work needed...

// Highlevel interface, implementation

#include <crtdbg.h>
#include <math.h>
#include "S3_intrf.h"
#include "S3_quant.h"


#if 0
// determine number of bytes needed to compress given source image
unsigned S3TCgetEncodeSize(LPDIRECT3DTEXTURE8 lpDesc, unsigned dwEncodeType)
{
    _ASSERTE(lpDesc!=NULL);
    _ASSERTE(lpDesc->Size=sizeof(D3DSURFACE_DESC));
    _ASSERTE((lpDesc->dwFlags&(DDSD_WIDTH|DDSD_HEIGHT))==(DDSD_WIDTH|DDSD_HEIGHT));

// calculate number of blocks and multiply by the number of bytes required per block
// if encoding alpha separately, requires 16 bytes per block, else 8 bytes
    return ((lpDesc->Width+3)/4)*((lpDesc->Height+3)/4)*    
                ((dwEncodeType&_S3TC_ENCODE_ALPHA_MASK)?16:8);
}
#endif

// determine number of shifts for given bit mask
_inline unsigned getNrOfShifts(DWORD dwMask)
{
    _ASSERTE(dwMask);

    // Bit scan forward returns index of 
    // least significant set bit
    _asm { 
        bsf eax, [dwMask]
        mov dwMask, eax
    }

    return dwMask;
}

// Pixel formats for various texture formats we'd like to compress
typedef struct {
    DWORD dwRMask;
    DWORD dwGMask;
    DWORD dwBMask;
    DWORD dwAMask;
    DWORD bpp;
} FORMAT_INFO;


//-----------------------------------------------------------------------------
// Name: GetFormatInfo
// Desc: Returns information about the specified format:
//       * Mask information for each channel of data
//       TODO: Add linear formats and missing PC formats
//-----------------------------------------------------------------------------
HRESULT GetFormatInfo( D3DFORMAT fmt, FORMAT_INFO * pfi )
{
    memset( pfi, 0, sizeof( FORMAT_INFO ) );

    switch( fmt )
    {
    case D3DFMT_LIN_A8R8G8B8:
        pfi->dwAMask = 0xFF000000;
        // Fall through
    case D3DFMT_LIN_X8R8G8B8:
        pfi->dwRMask = 0x00FF0000;
        pfi->dwGMask = 0x0000FF00;
        pfi->dwBMask = 0x000000ff;
        pfi->bpp     = 4;
        break;

    case D3DFMT_LIN_R5G6B5:
        pfi->dwRMask = 0x0000F800;
        pfi->dwGMask = 0x000007E0;
        pfi->dwBMask = 0x0000001F;
        pfi->bpp     = 2;
        break;

    case D3DFMT_LIN_A1R5G5B5:
        pfi->dwAMask = 0x00008000;
        // Fall through
    case D3DFMT_LIN_X1R5G5B5:
        pfi->dwRMask = 0x00007C00;
        pfi->dwGMask = 0x000003E0;
        pfi->dwBMask = 0x0000001F;
        pfi->bpp     = 2;
        break;

    case D3DFMT_LIN_A4R4G4B4:
        pfi->dwAMask = 0x0000F000;
        pfi->dwRMask = 0x00000F00;
        pfi->dwGMask = 0x000000F0;
        pfi->dwBMask = 0x0000000F;
        pfi->bpp     = 2;
        break;
                
    case D3DFMT_LIN_R6G5B5:
        pfi->dwRMask = 0x0000FC00;
        pfi->dwGMask = 0x000003E0;
        pfi->dwBMask = 0x0000001F;
        pfi->bpp     = 2;
        break;

    case D3DFMT_LIN_A8B8G8R8:
        pfi->dwAMask = 0xFF000000;
        pfi->dwBMask = 0x00FF0000;
        pfi->dwGMask = 0x0000FF00;
        pfi->dwRMask = 0x000000ff;
        pfi->bpp     = 4;
        break;

    case D3DFMT_LIN_B8G8R8A8:
        pfi->dwBMask = 0xFF000000;
        pfi->dwGMask = 0x00FF0000;
        pfi->dwRMask = 0x0000FF00;
        pfi->dwAMask = 0x000000ff;
        pfi->bpp     = 4;
        break;

    case D3DFMT_LIN_R4G4B4A4:
        pfi->dwRMask = 0x0000F000;
        pfi->dwGMask = 0x00000F00;
        pfi->dwBMask = 0x000000F0;
        pfi->dwAMask = 0x0000000F;
        pfi->bpp     = 2;
        break;

    case D3DFMT_LIN_R5G5B5A1:
        pfi->dwRMask = 0x0000F800;
        pfi->dwGMask = 0x000007C0;
        pfi->dwBMask = 0x0000003E;
        pfi->dwAMask = 0x00000001;
        pfi->bpp     = 2;
        break;

    case D3DFMT_LIN_R8G8B8A8:
        pfi->dwRMask = 0xFF000000;
        pfi->dwGMask = 0x00FF0000;
        pfi->dwBMask = 0x0000FF00;
        pfi->dwAMask = 0x000000ff;
        pfi->bpp     = 4;
        break;

    default:
        return E_INVALIDARG;
    }

    return S_OK;
}

#if _DEBUG
BOOL IsValidCoding( D3DFORMAT format, RGBBlock b )
{
    // For DXT1, we can take a 3- or 4-color ramp.
    if( format == D3DFMT_DXT1 )
        return true;

    // For DXT2-5, it has to be a 4-color ramp, so
    // assert we either got 4 levels out, or that
    // all quantized values are identical (in that
    // case, the quantizer doesn't set the endpoints
    // to be equal).
    if( b.outLevel == 4 )
        return true;

    for( int i = 1; i < b.n; i++ )
    {
        if( b.index[ i ] != b.index[ 0 ] )
            return false;
    }

    return true;
}
#endif // _DEBUG

//-----------------------------------------------------------------------------
// Name: XGCompressRect
// Desc: Compresses a texture to the specified buffer in the given format
// This is _almost_ unchanged code from s3.  The top of the function dealing
// with argument checking, texture formats, etc. is new.  Also, some bad loops
// were changed.  This means there may be many opportunities for optimization
//-----------------------------------------------------------------------------
extern "C"
HRESULT WINAPI XGCompressRect( LPVOID pDestBuf,
                               D3DFORMAT DestFormat,
                               DWORD dwDestPitch,
                               DWORD dwWidth,
                               DWORD dwHeight,
                               LPVOID pSrcData,
                               D3DFORMAT SrcFormat,
                               DWORD dwSrcPitch,
                               FLOAT fAlphaRef,
                               DWORD dwFlags )
{
    FORMAT_INFO fi;
    int y;                      // current Y line (steps 4 pixels each)
    unsigned char *lpSrcBuf;    // current beginning of line in source buffer
    unsigned char *lpDstBuf;    // current destination buffer pointer
    int bpp;                    // byte per pixel
    unsigned rgbShift[3];       // bit shifts for given color component
    unsigned aShift;            // bit shift for alpha component
    unsigned aRef;              // adjusted alpha reference value
    DWORD *  rgbBitMask;        // pointer to rgb bit mask
    int k;
    DWORD dwEncodeType;
    BYTE * pbSrc = NULL;
    FLOAT weight[3] = { 0.3086f, 0.6094f, 0.0820f };
    DWORD dwBytesPerBlock;
    DWORD dwWidthInBytes;
    DWORD DestPitchIncrement;   // Number of BYTEs to increment dest ptr, per row
    BOOL bPreMultiply = dwFlags & XGCOMPRESS_PREMULTIPLY;

    // Check input data and destination buffer
    if( !pSrcData || !pDestBuf )
        return E_INVALIDARG;
    
    // Make sure the format makes sense
    if( DestFormat != D3DFMT_DXT1 &&
        DestFormat != D3DFMT_DXT2 &&
        DestFormat != D3DFMT_DXT4 )
        return E_INVALIDARG;

    // Must be power-of-2 dimensions
    if( dwWidth & ( dwWidth - 1 ) )
        return E_INVALIDARG;
    if( dwHeight & ( dwHeight - 1 ) )
        return E_INVALIDARG;

    // Get info on the source texture format
    if( FAILED( GetFormatInfo( SrcFormat, &fi ) ) )
        return E_INVALIDARG;

    rgbBitMask = &fi.dwRMask;

    switch( DestFormat )
    {
    case D3DFMT_DXT1:
        dwEncodeType = S3TC_ENCODE_RGB_ALPHA_COMPARE|S3TC_ENCODE_ALPHA_NONE;
        dwBytesPerBlock = 8;
        break;
    case D3DFMT_DXT2:
        dwEncodeType = S3TC_ENCODE_RGB_FULL|S3TC_ENCODE_ALPHA_EXPLICIT;
        dwBytesPerBlock = 16;
        break;
    case D3DFMT_DXT4:
        dwEncodeType = S3TC_ENCODE_RGB_FULL|S3TC_ENCODE_ALPHA_INTERPOLATED;
        dwBytesPerBlock = 16;
        break;
    }

    if( dwFlags & XGCOMPRESS_NEEDALPHA0 )
        dwEncodeType |= S3TC_ENCODE_ALPHA_NEED0;
    if( dwFlags & XGCOMPRESS_NEEDALPHA1 )
        dwEncodeType |= S3TC_ENCODE_ALPHA_NEED1;
    if( dwFlags & XGCOMPRESS_PROTECTNONZERO )
        dwEncodeType |= S3TC_ENCODE_ALPHA_PROTECTNONZERO;

    dwWidthInBytes = ( dwWidth >> 2 ) * dwBytesPerBlock;

    // Calculate default pitches, if not specified.
    if( dwSrcPitch == 0 )
        dwSrcPitch = dwWidth * fi.bpp;
    if( dwDestPitch == 0 )
        dwDestPitch = dwWidthInBytes;

    // Number of bytes to skip for each row is the
    // difference between the dest pitch and the width
    // of the compressed data.  Normally, this will be
    // zero, unless a wider pitch was specified.  If this
    // is less than zero, then we were given an invalid
    // pitch
    if( dwDestPitch < dwWidthInBytes )
        return E_INVALIDARG;

    DestPitchIncrement = dwDestPitch - dwWidthInBytes;
    
    // precompute some useful values
    // XGBytesPerPixelFromFormat only understands xbox-flavored formats
    // bpp = XGBytesPerPixelFromFormat( SrcFormat );
    bpp = fi.bpp;
    rgbShift[0] = getNrOfShifts( fi.dwRMask );
    rgbShift[1] = getNrOfShifts( fi.dwGMask );
    rgbShift[2] = getNrOfShifts( fi.dwBMask );
    aShift      = fi.dwAMask ? getNrOfShifts( fi.dwAMask ) : 0;
    if ((dwEncodeType&_S3TC_ENCODE_RGB_MASK)==S3TC_ENCODE_RGB_ALPHA_COMPARE)
    {
        aRef = DWORD( fAlphaRef * ( fi.dwAMask >> aShift ) ) << aShift;
    }

    // now encode stuff (...)
    // Note, we read from the pointer that was given, so it better not be
    // swizzled, and if you want this fast, it better not be write-combined
    // memory
    lpSrcBuf = (unsigned char *)pSrcData;
    lpDstBuf = (unsigned char *)pDestBuf;

    // main y loop, go thru each upper-left most point on all 4x4 blocks
    for ( y = 0; y < (int)dwHeight; y += 4, lpSrcBuf += dwSrcPitch * 4 )
    {
        int x;                      // current X pixel (steps 4 pixels each)
        unsigned char *lpSrcCur;    // pointer to beginning of current source block
        int blockHeight;            // height of current blocks in pixel
        
        blockHeight=min(dwHeight-y,4);
        lpSrcCur=lpSrcBuf;
        // main x loop, go thru each upper left most point on all 4x4 blocks
        for ( x = 0; x <( int)dwWidth; x += 4, lpSrcCur += bpp * 4 )
        {
            int blockWidth;             // width of current block in pixel
            RGBBlock b;                 // current source block
            int k;                      // misc loop var
            int index[16];              // index of encoded texels in RGBBlock
                                        // if index[i] < 0, texel i is not quantizable
                                        // either due to colorkey, alpha compare, or
                                        // outside image boundry
            unsigned short endPt[2];    // RGB565 encoded quantized end points
            int bSwapped;               // end points swapped?
            unsigned dwIndex=0;         // encoded index values

            for (k=0;k<3;k++) 
                    b.weight[k]=weight[k];
            
            blockWidth=min(dwWidth-x,4);
            b.n=0;

            // start by encoding alpha stuff...
            switch(dwEncodeType&_S3TC_ENCODE_ALPHA_MASK)
            {
                case S3TC_ENCODE_ALPHA_NONE:
                    break;
                case S3TC_ENCODE_ALPHA_EXPLICIT:
                    {
                        int iy;                     // inner block pixel loop variable
                        unsigned char *lpCur;       // current pixel

                        if( fi.dwAMask )
                        {
                            lpCur=lpSrcCur;

                            // go thru all pixels in the block and write out the alpha values
                            for ( iy = 0 ; iy < 4 ; iy++, lpCur += dwSrcPitch - 4 * bpp )
                            {
                                if (iy<blockHeight)         // skip if outside
                                {
                                    unsigned short val = 0; // current output value
                                    int ix;
                                    for (ix=0;ix<4;ix++,lpCur+=bpp)
                                    {
                                        DWORD dwCurTexel;
                                        switch( bpp )
                                        {
                                        case 4:dwCurTexel = *(DWORD *)lpCur;
                                            break;
                                        case 2:dwCurTexel = (DWORD)(*(WORD *)lpCur);
                                            break;
                                        case 1:dwCurTexel = (DWORD)(*(BYTE *)lpCur);
                                            break;
                                        }
                                        // pack it...
                                        if (ix<blockWidth)
                                            val=(val>>4) | ( unsigned short(floor(( ( dwCurTexel & fi.dwAMask ) >> aShift ) / float( fi.dwAMask >> aShift )* 15.0f + 0.5f )) << 12 );
                                        else
                                            val>>=4;
                                    }
                                    // write it out
                                    *(unsigned short *)lpDstBuf=val;
                                }
                                else
                                    *(unsigned short *)lpDstBuf=0;
                                lpDstBuf+=2;
                            }
                        }
                        else
                        {
                            // Set to opaque
                            memset( lpDstBuf, 0xFFFF, 8 );
                            lpDstBuf += 8;
                        }
                    } 
                    break;
                case S3TC_ENCODE_ALPHA_INTERPOLATED:
                    {
                        AlphaBlock a;               // current alpha source block
                        int ix,iy;                  // inner block pixel loop variable
                        unsigned char *lpCur;       // current pixel
                        unsigned val;               // current output value

                        if( fi.dwAMask )
                        {
                            lpCur=lpSrcCur;

                            a.n=0;
                            k=0;
                            // go thru all pixels in the block and set up the AlphaBlock structure a
                            for ( iy = 0; iy < 4; iy++, lpCur += dwSrcPitch - 4 * bpp )
                                for ( ix = 0; ix < 4; ix++, lpCur += bpp)
                                    if ( ix < blockWidth && iy < blockHeight )
                                    {
                                        DWORD dwCurTexel;
                                        switch( bpp )
                                        {
                                        case 4:dwCurTexel = *(DWORD *)lpCur;
                                            break;
                                        case 2:dwCurTexel = (DWORD)(*(WORD *)lpCur);
                                            break;
                                        case 1:dwCurTexel = (DWORD)(*(BYTE *)lpCur);
                                            break;
                                        }
                                        unsigned cur,max;

                                        cur = ( dwCurTexel & fi.dwAMask ) >> aShift;
                                        max = fi.dwAMask >> aShift;
                                        index[k++]=a.n;
                                        a.alpha[a.n++]=(cur==max)?1.f:cur/((float)max); // to ensure that 1.0 exists
                                    }
                                    else
                                        index[k++]=-1;

                            // set flags -> do we need total opaqueness and total transparecy
                            // explicitly?
                            a.need0=dwEncodeType&S3TC_ENCODE_ALPHA_NEED0;
                            a.need1=dwEncodeType&S3TC_ENCODE_ALPHA_NEED1;
                            a.protectnonzero=dwEncodeType&S3TC_ENCODE_ALPHA_PROTECTNONZERO;

                            // check to see if there are no points to be quantized...
                            if (a.n==0) {
                                // zero out endpoints (they are invalid)
                                a.endPoint[0]=a.endPoint[1]=0;
                                for (k=0;k<16;k++)
                                    _ASSERTE(index[k]==-1);
                            } else
                                // !!! ENTRY INTO S3TC QUANTIZER !!!
                                CodeAlphaBlock(&a);

                            // check if endpoints are equal, if so, default to 6 points,
                            // second endpoint invalid, so increment to indicate 6 points.
                            // (JHarding): If 2nd endpoint is 255, can't increment, so
                            //   decrement first endpoint and use second instead.
                            // force all indices to endpoint 0 (or 1).
                            if (a.endPoint[0]==a.endPoint[1]) {
                                if( a.endPoint[1] < 255 )
                                {
                                    a.endPoint[1]++;
                                    for (k=0;k<a.n;k++) {
                                        a.index[k]=0;
                                    }
                                }
                                else
                                {
                                    a.endPoint[0]--;
                                    for(k=0;k<a.n;k++) {
                                        a.index[k]=1;
                                    }
                                }
                                a.outLevel=6;
                            }

                            // need swapping?
                            if ((a.endPoint[0]>a.endPoint[1])==(a.outLevel==6))
                            {
                                int sw=a.endPoint[0];
                                a.endPoint[0]=a.endPoint[1];
                                a.endPoint[1]=sw;
                                bSwapped=1;
                            }
                            else
                                bSwapped=0;

                            // write out endpoints
                            for (k=0;k<2;k++)
                            {
                                _ASSERTE(a.endPoint[k]>=0&&a.endPoint[k]<=255);
                                *lpDstBuf++=(unsigned char)a.endPoint[k];
                            }

                            // handle indices
                            memset(lpDstBuf,0,6);
                            val=0;
                            k=0;
                            // go thru indices and pack them...
                            // note packing is done 3 bytes (24 bits) at a time
                            // which correspond to 8 texels or 2 4-texel rows at a time
                            for (iy=0;iy<4;iy++)
                            {
                                for (ix=0;ix<4;ix++,k++)
                                {
                                    val>>=3;
                                    if (index[k]>=0)
                                    {
                                        int curIndex;

                                        curIndex=a.index[index[k]];
                                        _ASSERTE(curIndex>=0&&curIndex<=7);
                                        // handle indices swapping if needed
                                        // mapping as follows if swapped: 
                                        // outLevel==8 : 0->1, 1->0, 2->7, 3->6, 4->5, 5->4, 6->3, 7->2
                                        // outLevel==6 : 0->1, 1->0, 2->5, 3->4, 4->3, 5->2, 6->6, 7->7
                                        if (bSwapped) {
                                            if (a.outLevel==8) {
                                                curIndex = (curIndex>1) ? (9-curIndex) : (curIndex==0?1:0);
                                            } else if (a.outLevel==6) {
                                                curIndex = (curIndex>5) ? curIndex : ( (curIndex>1)?(7-curIndex):(curIndex==0?1:0) );
                                            }

                                        }
                                        _ASSERTE(curIndex>=0&&curIndex<=7);
                                        // pack it...
                                        val|=curIndex<<21;
                                    }
                                }

                                // check to see if we've finished 2 texel rows...
                                // equivalent to having packed 3 bytes (24 bits)...
                                if (iy&1)
                                {
                                    // write out packed indices
                                    *(unsigned *)(lpDstBuf)|=val;
                                    // realign boundry
                                    lpDstBuf+=3;
                                    val=0;
                                }
                            }
                        }
                        else
                        {
                            *lpDstBuf++ = 0x00;
                            *lpDstBuf++ = 0xFF;
                            memset( lpDstBuf, 0xFFFF, 6 );
                            lpDstBuf += 6;
                        }
                    }
                    break;
                default:
                    _ASSERTE(0);
            }
            
            // now encode rgb stuff...
#if 0
            if (lpPal)
            {
                // palettized image
                int ix,iy;                  // inner block pixel loop variables
                unsigned char *lpCur;       // current pixel

                lpCur=lpSrcCur;
                switch(dwEncodeType&_S3TC_ENCODE_RGB_MASK)
                {
                    case S3TC_ENCODE_RGB_FULL:
                        // go thru all pixels in the block and set up the RGBBlock structure b
                        for (k=0,iy=0;iy<4;iy++,lpCur+=lpSrc->lPitch-4)
                            for (ix=0;ix<4;ix++,lpCur++)
                                if (ix<blockWidth&&iy<blockHeight)
                                {
                                    double *pChannel;
                                    PALETTEENTRY *pEntry=lpPal+*lpCur;

                                    index[k++]=b.n;
                                    pChannel=b.colorChannel[b.n++];
                                    *pChannel++=(double)pEntry->peRed/255.;
                                    *pChannel++=(double)pEntry->peGreen/255.;
                                    *pChannel++=(double)pEntry->peBlue/255.;
                                }
                                else
                                    index[k++]=-1;      // non-quantizable if outside image
                        break;
                    case S3TC_ENCODE_RGB_COLOR_KEY:
                        // go thru all pixels in the block and set up the RGBBlock structure b
                        //@@@ assumption: color key in palettized format
                        //@@@ is in XBGR8888 format
                        for (k=0,iy=0;iy<4;iy++,lpCur+=lpSrc->lPitch-4)
                            for (ix=0;ix<4;ix++,lpCur++)
                                if (ix<blockWidth&&iy<blockHeight)
                                {
                                    double *pChannel;
                                    PALETTEENTRY *pEntry=lpPal+*lpCur;
                                    // check for color key
                                    if ( ((*(unsigned *)pEntry)&0xffffff)<lpSrc->ddckCKSrcBlt.dwColorSpaceLowValue ||
                                         ((*(unsigned *)pEntry)&0xffffff)>lpSrc->ddckCKSrcBlt.dwColorSpaceHighValue )
                                    {
                                        index[k++]=b.n;
                                        pChannel=b.colorChannel[b.n++];
                                        *pChannel++=(double)pEntry->peRed/255.;
                                        *pChannel++=(double)pEntry->peGreen/255.;
                                        *pChannel++=(double)pEntry->peBlue/255.;
                                    }
                                    else
                                        index[k++]=-1;  // non-quantizable texel if colorkey
                                }
                                else
                                    index[k++]=-1;      // non-quantizable texel if outside image
                        break;
                    default:
                        _ASSERTE(0);
                }
            }
            else
#endif
            {
                // non-palettized image
                int ix,iy;                  // inner block pixel loop variables
                unsigned char *lpCur;       // current pixel

                lpCur=lpSrcCur;
                // encode RGB stuff first...
                switch(dwEncodeType&_S3TC_ENCODE_RGB_MASK)
                {
                    case S3TC_ENCODE_RGB_FULL:
                        // go thru all pixels in the block and set up the RGBBlock structure b
                        for ( k = 0, iy = 0; iy < 4; iy++, lpCur += dwSrcPitch - 4 * bpp )
                            for ( ix = 0; ix < 4; ix++, lpCur += bpp)
                                if ( ix < blockWidth && iy < blockHeight )
                                {
                                    double *pChannel;
                                    int i;

                                    index[k++]=b.n;
                                    pChannel=b.colorChannel[b.n++];

                                    DWORD dwCurTexel;
                                    switch( bpp )
                                    {
                                    case 4:dwCurTexel = *(DWORD *)lpCur;
                                        break;
                                    case 2:dwCurTexel = (DWORD)(*(WORD *)lpCur);
                                        break;
                                    case 1:dwCurTexel = (DWORD)(*(BYTE *)lpCur);
                                        break;
                                    }

                                    float fAlpha = ( bPreMultiply && fi.dwAMask ) ? ( ( dwCurTexel & fi.dwAMask ) >> aShift ) / float( fi.dwAMask >> aShift ): 1.0f;
                                    for (i=0;i<3;i++)
                                        *pChannel++ = fAlpha * 
                                                      ( ( dwCurTexel & rgbBitMask[i] ) >> rgbShift[i] ) /
                                                      ( (double)( rgbBitMask[i] >> rgbShift[i] ) );
                                } else
                                    index[k++]=-1;          // non-quantizable if outside image
                        break;
#if 0
                    case S3TC_ENCODE_RGB_COLOR_KEY:
                        // go thru all pixels in the block and set up the RGBBlock structure b
                        for (k=0,iy=0;iy<4;iy++,lpCur+=lpSrc->lPitch-4*bpp)
                            for (ix=0;ix<4;ix++,lpCur+=bpp)
                                if (ix<blockWidth&&iy<blockHeight)
                                {
                                    double *pChannel;
                                    int i;
                                    unsigned curVal=*(unsigned *)lpCur;
                                    curVal&=(rgbBitMask[0]|rgbBitMask[1]|rgbBitMask[2]);

                                    // color key testing
                                    if (curVal<lpSrc->ddckCKSrcBlt.dwColorSpaceLowValue||
                                        curVal>lpSrc->ddckCKSrcBlt.dwColorSpaceHighValue)
                                    {
                                        index[k++]=b.n;
                                        pChannel=b.colorChannel[b.n++];
                                        for (i=0;i<3;i++)
                                            *pChannel++=((curVal&rgbBitMask[i])>>rgbShift[i])/((double)(rgbBitMask[i]>>rgbShift[i]));
                                    }
                                    else
                                        index[k++]=-1;      // non-quantizable if colorkey
                                }   
                                else
                                    index[k++]=-1;          // non-quantizable if outside image
                        break;
#endif // 0
                    case S3TC_ENCODE_RGB_ALPHA_COMPARE:
                        // go thru all pixels in the block and set up the RGBBlock structure b
                        for ( k = 0, iy = 0; iy < 4; iy++, lpCur+= dwSrcPitch - 4 * bpp )
                            for ( ix = 0; ix < 4; ix++, lpCur += bpp)
                                if ( ix < blockWidth && iy < blockHeight )
                                {
                                    double *pChannel;
                                    int i;

                                    DWORD dwCurTexel;
                                    switch( bpp )
                                    {
                                    case 4:dwCurTexel = *(DWORD *)lpCur;
                                        break;
                                    case 2:dwCurTexel = (DWORD)(*(WORD *)lpCur);
                                        break;
                                    case 1:dwCurTexel = (DWORD)(*(BYTE *)lpCur);
                                        break;
                                    }

                                    // alpha compare
                                    if ( fi.dwAMask == 0 || ( dwCurTexel & fi.dwAMask ) > aRef )
                                    {
                                        index[k++]=b.n;
                                        pChannel=b.colorChannel[b.n++];
                                        for (i=0;i<3;i++)
                                            *pChannel++=((dwCurTexel&rgbBitMask[i])>>rgbShift[i])/((double)(rgbBitMask[i]>>rgbShift[i]));
                                    }
                                    else
                                        index[k++]=-1;      // non-quantizable if alpha compare
                                }
                                else
                                    index[k++]=-1;          // non-quantizable if outside image
                        break;
                    default:
                        _ASSERTE(0);
                }
            }

            _ASSERTE(k==16);

            // input quantization is set to 3 if there are non-quantizable texels
            // so a spare flag can be used to indicate such, else set to 4.
            b.inLevel=b.n<blockWidth*blockHeight?3:4;

            // check to see if there are no points to be quantized...
            if (b.n==0) {
                // zero out endpoints (they are invalid)
                for (k=0;k<2;k++)
                    b.endPoint[k][0]=b.endPoint[k][1]=b.endPoint[k][2]=0;
                for (k=0;k<16;k++)
                    _ASSERTE(index[k]==-1);
            } else
            {
                // Run the actual quantizer
                CodeRGBBlock(&b);

                _ASSERTE( IsValidCoding( DestFormat, b ) );
            }

            // retrieve endpoints
            for (k=0;k<2;k++)
            {
                _ASSERTE(b.endPoint[k][0]>=0&&b.endPoint[k][0]<=31);
                _ASSERTE(b.endPoint[k][1]>=0&&b.endPoint[k][1]<=63);
                _ASSERTE(b.endPoint[k][2]>=0&&b.endPoint[k][2]<=31);
                endPt[k]=(b.endPoint[k][0]<<11)|(b.endPoint[k][1]<<5)|b.endPoint[k][2];
            }

            // check if end-points are equal, if so, default to 3 points,
            // second endpoint invalid, so increment to indicate 3 points.
            // force all indices to endpoint 0.
            if (endPt[0]==endPt[1]) {
                endPt[1]++;
                for (k=0;k<b.n;k++) {
                    b.index[k]=0;
                }
                b.outLevel=3;
            }

            // swap needed?
            if ((endPt[0]>endPt[1])==(b.outLevel==3))
            {
                unsigned short sw=endPt[0]; endPt[0]=endPt[1]; endPt[1]=sw;
                bSwapped=1;
            }
            else
                bSwapped=0;

            // write out end-points
            for (k=0;k<2;k++,lpDstBuf+=2)
                *(unsigned short *)lpDstBuf=endPt[k];

            // go thru indices and pack them...
            for (k=15;k>=0;k--)
            {
                dwIndex<<=2;
                // check if texel is not quantizable, if so, set index to 3
                if (index[k]<0) {
                    // _ASSERTE((b.inLevel==3)&&(b.outLevel==3));  <- bad assertion, taken out 4/9/98
                    dwIndex|=3;
                } else {
                    _ASSERTE(b.index[index[k]]>=0&&b.index[index[k]]<b.outLevel);
                    // pack indices
                    dwIndex|=b.index[index[k]];
                    // if swapped, changed the index
                    if (bSwapped)
                    {
                        if (b.outLevel==4)
                            dwIndex^=1;
                        else
                            dwIndex^=((dwIndex&2)>>1)^1;
                    }
                }
            }

            // write out indices
            *(unsigned *)lpDstBuf=dwIndex;

            lpDstBuf+=4;

        }
        // Increment to next row of blocks in dest buffer
        lpDstBuf += DestPitchIncrement;
    }

    delete[] pbSrc;
    return S_OK;
}

#if 0
// determine number of bytes needed do decompress given compressed image
unsigned S3TCgetDecodeSize(LPDIRECT3DTEXTURE8 lpDesc)
{
    _ASSERTE(lpDesc!=NULL);
    _ASSERTE(lpDesc->dwSize=sizeof(D3DSURFACE_DESC));
    _ASSERTE((lpDesc->dwFlags&(DDSD_WIDTH|DDSD_HEIGHT))==(DDSD_WIDTH|DDSD_HEIGHT));
    _ASSERTE(lpDesc->ddpfPixelFormat.dwFourCC=S3TC_FOURCC);

    return lpDesc->dwWidth*lpDesc->dwHeight*4;
}

// decode single RGB block (does not handle index) -> just return 
// endpoint and interpolated colors
static void decodeRGB(unsigned short *color, unsigned *rgb)
{
    int k;
    unsigned c[2][3];

    // _ASSERTE(color[0]!=color[1]);  <- no longer used, take out 5/15/98

    // go thru two endpoints
    for (k=0;k<2;k++)
    {
        // do color expansion: 5 bit abcde -> 8 bit abcdeabc
        // do color expansion: 6 bit abcdef -> 8 bit abcdefab
        c[k][0]=(unsigned)((color[k]>>11)<<3)|(color[k]>>13);
        c[k][1]=(unsigned)(((color[k]>>5)&0x3f)<<2)|((color[k]>>9)&0x3);
        c[k][2]=(unsigned)((color[k]&0x1f)<<3)|((color[k]>>3)&0x3);

        // set endpoint colors
        rgb[k]=0xff000000|(c[k][0]<<16)|(c[k][1]<<8)|c[k][2];
    }

    // check quantization level
    if (color[0]>color[1])
    {
        // if 4, interpolate colors at one-third and two-third points
        rgb[2]=rgb[3]=0xff000000;
        for (k=0;k<3;k++)
        {
            rgb[2]|=((2*c[0][k]+c[1][k]+1)/3)<<(16-k*8);
            rgb[3]|=((c[0][k]+2*c[1][k]+1)/3)<<(16-k*8);
        }
    }
    else
    {
        // if 3, interpolate color at mid-point
        rgb[2]=0xff000000;
        rgb[3]=0x00ff00ff;          // third color undefined - possibly color key
                                    // @@@ set magenta FOR NOW...
        for (k=0;k<3;k++)
            rgb[2]|=((c[0][k]+c[1][k])/2)<<(16-k*8);
    }
}

// decode single alpha block (does not handle index) -> just return 
// endpoint and interpolated alpha values
static void decodeAlpha(unsigned char *alpha, unsigned *rgb)
{
    int k;

    _ASSERTE(alpha[0]!=alpha[1]);

    // go thru two endpoints
    for (k=0;k<2;k++)
        rgb[k]=alpha[k]?((alpha[k]<<24)|0xffffff):0;

    // check quantization level
    if (alpha[0]>alpha[1])
    {
        // if 8, interpolate values at 1/7,2/7,...6/7 points
        for (k=0;k<6;k++)
        {
            rgb[2+k]=((alpha[1]*(k+1)+alpha[0]*(6-k)+3)/7)<<24;
            if (rgb[2+k])
                rgb[2+k]|=0xffffff;
        }
    }
    else
    {
        // if 6, interpolate values at 1/5,2/5,...4/5 points
        for (k=0;k<4;k++)
        {
            rgb[2+k]=((alpha[1]*(k+1)+alpha[0]*(4-k)+2)/5)<<24;
            if (rgb[2+k])
                rgb[2+k]|=0xffffff;
        }
        // last two points are explicit totally transparent and totally opaque
        rgb[6]=0;
        rgb[7]=0xffffffff;
    }
}

// decode (decompress) from surface to surface
void S3TCdecode(LPDIRECT3DTEXTURE8 lpSrc,       // [in]
                LPDIRECT3DTEXTURE8 lpDest,      // [out]
                void *lpDestBufIn           // [in]
                )
{
    int y;                      // current Y line (steps 4 pixels each)
    unsigned char *lpSrcBuf;    // current source buffer pointer
    unsigned char *lpDstBuf;    // current beginning of line in destination buffer

    // parameter validation
    _ASSERTE(lpSrc!=NULL);
    _ASSERTE(lpSrc->dwSize=sizeof(D3DSURFACE_DESC));
    _ASSERTE(lpDest!=NULL);
    _ASSERTE(lpDest->dwSize=sizeof(D3DSURFACE_DESC));
    _ASSERTE((lpSrc->dwFlags&(DDSD_WIDTH|DDSD_HEIGHT|DDSD_LPSURFACE|DDSD_PIXELFORMAT))==
                             (DDSD_WIDTH|DDSD_HEIGHT|DDSD_LPSURFACE|DDSD_PIXELFORMAT));
    _ASSERTE(lpDestBufIn);

    // fill in lpDest data members
    lpDest->dwFlags=DDSD_WIDTH|DDSD_HEIGHT|DDSD_LPSURFACE|DDSD_PITCH|DDSD_PIXELFORMAT;
    lpDest->dwWidth=lpSrc->dwWidth;
    lpDest->dwHeight=lpSrc->dwHeight;
    lpDest->lpSurface=lpDestBufIn;
    lpDest->lPitch=lpSrc->dwWidth*4;
    lpDest->ddpfPixelFormat.dwSize=sizeof(DDPIXELFORMAT);
    lpDest->ddpfPixelFormat.dwFlags=DDPF_RGB|DDPF_ALPHAPIXELS;
    lpDest->ddpfPixelFormat.dwRGBBitCount=32;
    lpDest->ddpfPixelFormat.dwRBitMask=0x00ff0000;
    lpDest->ddpfPixelFormat.dwGBitMask=0x0000ff00;
    lpDest->ddpfPixelFormat.dwBBitMask=0x000000ff;
    lpDest->ddpfPixelFormat.dwRGBAlphaBitMask=0xff000000;

    // now decompress...
    lpSrcBuf=(unsigned char *)lpSrc->lpSurface;
    lpDstBuf=(unsigned char *)lpDest->lpSurface;
    // main y loop, go thru each upper-left most point on all 4x4 blocks
    for (y=0;y<(int)lpSrc->dwHeight;y+=4,lpDstBuf+=4*lpDest->lPitch)
    {
        int x;                      // current X pixel (steps 4 pixels each)
        unsigned char *lpDstCur;    // pointer to beginning of current destination block
        int blockHeight;            // height of current blocks in pixel
        
        blockHeight=min(lpSrc->dwHeight-y,4);
        lpDstCur=lpDstBuf;
        // main x loop, go thru each upper-left most point on all 4x4 blocks
        for (x=0;x<(int)lpSrc->dwWidth;x+=4,lpDstCur+=16)
        {
            int blockWidth;             // width of current block in pixel
            int ix,iy;                  // misc loop var
            unsigned rgbValue[8];       // current RGB (including transparency)
            unsigned *lpCur;            // current pixel

            blockWidth=min(lpSrc->dwWidth-x,4);

            // alpha block
            switch(lpSrc->ddpfPixelFormat.dwRGBBitCount&_S3TC_ENCODE_ALPHA_MASK)
            {
                unsigned index;             // index for alpha encoding
                case S3TC_ENCODE_ALPHA_NONE:
                    break;
                case S3TC_ENCODE_ALPHA_EXPLICIT:
                    lpCur=(unsigned *)lpDstCur;
                    // go thru each texel in block and set alpha 
                    for (iy=0;iy<4;iy++,lpCur+=lpDest->dwWidth-4)
                    {
                        unsigned short index=*(unsigned short *)lpSrcBuf;
                        lpSrcBuf+=2;
                        if (iy<blockHeight)
                            for (ix=0;ix<4;ix++,index>>=4,lpCur++)
                                if (ix<blockWidth)
                                    *lpCur=(((unsigned)floor(((index&15)/15.f)*255.f))<<24)|0xffffff;
                    }
                    break;
                case S3TC_ENCODE_ALPHA_INTERPOLATED:
                    // decode reference alpha values
                    decodeAlpha(lpSrcBuf,rgbValue);
                    lpCur=(unsigned *)lpDstCur;
                    lpSrcBuf+=2;
                    index=*(unsigned *)(lpSrcBuf);
                    // go thru each texel in block and set alpha values as referenced via index
                    for (iy=0;iy<4;iy++,lpCur+=lpDest->dwWidth-4)
                    {
                        // if finished two texel rows, reset source byte boundry
                        if (iy==2)
                            index=*(unsigned *)(lpSrcBuf+3);
                        if (iy<blockHeight)
                            for (ix=0;ix<4;ix++,index>>=3,lpCur++)
                                if (ix<blockWidth)
                                    *lpCur=rgbValue[index&7];
                    }
                    lpSrcBuf+=6;
                    break;
            }

            // RGB block
            // decode referenced colors
            decodeRGB((unsigned short *)lpSrcBuf,rgbValue);
            lpSrcBuf+=4;

            lpCur=(unsigned *)lpDstCur;
            // go thru each texel in block and set color as referenced via index
            for (iy=0;iy<4;iy++,lpCur+=lpDest->dwWidth-4)
            {
                unsigned char index=*lpSrcBuf++;
                if (iy<blockHeight)
                    for (ix=0;ix<4;ix++,index>>=2,lpCur++)
                        if (ix<blockWidth) {
                            *lpCur&=0xff000000;
                            rgbValue[index&3]&=0x00ffffff;
                            *lpCur|=rgbValue[index&3];
                        }
            }
        }
    }
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\inc\debug.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    header file for debug helper functions
 *
 ***************************************************************************/

#pragma once

namespace XGRAPHICS
{

#include <xdbg.h>

#if DBG

    // DBG_CHECK is to be used to for any parameter validation checks, 
    // in the form:
    //
    //      if (DBG_CHECK(dwFlags & INVALID_FLAGS))
    //          return DDERR_UNSUPPORTED;
    //
    // On free, retail builds, the macro gets converted to a constant '0'
    // and the compiler will remove all the associated code.
       
    #define DBG_CHECK(exp) (exp)
    
    // NULL_CHECK is to be used for any parameter NULL pointer checks,
    // in the form:
    //
    //      if (NULL_CHECK(pFoo))
    //          return DDERR_INVALIDPARAMETER;
    
    #define NULL_CHECK(p) ((p) == NULL)
    
#else

    #define DBG_CHECK(exp) FALSE
    
    #define NULL_CHECK(p) FALSE
    
#endif

#if DBG

    void DPF3(const char* message, va_list list);
    void DPF2(const char* message,...);
    void DPF(int level,const char* message,...);

    VOID DXGRIP(PCHAR Format, ...);
    VOID WARNING(PCHAR Format, ...);

    #undef ASSERT
    #define ASSERT(cond)   \
        {                  \
            if (! (cond))  \
            {              \
                DXGRIP("Assertion failure: %s", #cond); \
            }              \
        }

    #undef ASSERTMSG
    VOID ASSERTMSG(BOOL cond, PCHAR Format, ...);

    #define DPF_ERR(msg) DXGRIP(msg)
    #define D3D_ERR(msg) DXGRIP(msg)
    #define DXGASSERT(cond) ASSERT(cond)
    #define DDASSERT(cond) ASSERT(cond)
    #define UNIMPLEMENTED() DXGRIP("Function not yet implemented")

#else

    #define DPF3
    #define DPF2
    #define DPF
    
    #define DXGRIP
    #define WARNING

    #undef ASSERT
    #define ASSERT(cond) {}
    #undef ASSERTMSG
    #define ASSERTMSG

    #define DPF_ERR
    #define D3D_ERR
    #define DXGASSERT
    #define DDASSERT
    #define UNIMPLEMENTED

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\misc\sources.inc ===
MAJORCOMP=directx
MINORCOMP=d3d

TARGETNAME=misc$(D)

TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES);..\..\inc

SOURCES = \
     debug.cpp \
     header.cpp \
     surfacetofile.cpp \
     writexpr.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\math\sources.inc ===
MAJORCOMP=directx
MINORCOMP=d3d

TARGETNAME=xgmath$(D)

TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES);..\..\inc

SOURCES=\
    xgmath.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\misc\header.cpp ===
#if XBOX
#include <xgrphseg.h>
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8-xbox.h>
#endif

#include <xgraphics.h>
#include <debug.h>
#include "header.h"

namespace XGRAPHICS
{

DWORD EncodeFormat(
    DWORD Width,
    DWORD Height,
    DWORD Depth,
    DWORD Levels,
    D3DFORMAT D3DFormat,
    DWORD Pitch,
    bool isCubeMap,
    bool isVolume,
    DWORD *pFormat,
    DWORD *pSize
    )
{
    if (DBG_CHECK(TRUE))
    {
        if (!Width || !Height || !Depth)
        {
            DXGRIP("PixelJar::EncodeFormat - All texture dimensions must be at least 1 texel.");
        }

        if (IsSwizzledD3DFORMAT(D3DFormat) || IsCompressedD3DFORMAT(D3DFormat))
        {
            if (Depth > 1)
            {
                if (Width > 512)
                {
                    DXGRIP("PixelJar::EncodeFormat - Volume texture width is larger than the 512 texel maximum.");
                }

                if (Height > 512)
                {
                    DXGRIP("PixelJar::EncodeFormat - Volume texture height is larger than the 512 texel maximum.");
                }

                if (Depth > 512)
                {
                    DXGRIP("PixelJar::EncodeFormat - Volume texture depth is larger than the 512 texel maximum.");
                }

                if (isCubeMap)
                {
                    DXGRIP("PixelJar::EncodeFormat - Volume textures cannot be cube mapped.");
                }

                if (IsValidDepthBufferD3DFORMAT(D3DFormat))
                {
                    DXGRIP("PixelJar::EncodeFormat - Volume textures cannot have a depth format.");
                }
            }
            else
            {
                if (Width > 4096)
                {
                    DXGRIP("PixelJar::EncodeFormat - Texture width is larger than the 4096 texel maximum.");
                }

                if (Height > 4096)
                {
                    DXGRIP("PixelJar::EncodeFormat - Texture height is larger than the 4096 texel maximum.");
                }
            }

            if ((Width & (Width - 1)) || (Height & (Height - 1)) || (Depth & (Depth - 1)))
            {
                DXGRIP("PixelJar::EncodeFormat - Each dimension of a swizzled texture must be a power of 2.");
            }

            if (Levels > 16)
            {
                DXGRIP("PixelJar::EncodeFormat - Texture mipmap level count is larger than the 16 level maximum.");
            }

            if (isCubeMap && IsValidDepthBufferD3DFORMAT(D3DFormat))
            {
                DXGRIP("PixelJar::EncodeFormat - Depth format textures cannot be cube mapped.");
            }

            if (isCubeMap && Width != Height)
            {
                DXGRIP("PixelJar::EncodeFormat - Cube maps must be square (width == height).");
            }
        }
        else
        {
            if (Depth != 1)
            {
                DXGRIP("PixelJar::EncodeFormat - Non swizzled and non compressed textures cannot be a volume texture.");
            }

            if (Width > 4096)
            {
                DXGRIP("PixelJar::EncodeFormat - Texture width is larger than the 4096 texel maximum.");
            }

            if (Height > 4096)
            {
                DXGRIP("PixelJar::EncodeFormat - Texture height is larger than the 4096 texel maximum.");
            }

            if (Levels > 1)
            {
                DXGRIP("PixelJar::EncodeFormat - Non swizzled and non compressed textures cannot be mip mapped.");
            }

            if (isCubeMap)
            {
                DXGRIP("PixelJar::EncodeFormat - Non swizzled and non compressed textures cannot be cube mapped.");
            }
        }
    }

    DWORD Size = 0;
    DWORD TexelSize = BitsPerPixelOfD3DFORMAT(D3DFormat);

    DWORD LogWidth;
    DWORD LogHeight;
    DWORD LogDepth;
    DWORD SizeWidth;
    DWORD SizeHeight;

    // Swizzed and compressed textures are always power-of-2.  Linear textures are always
    // treated a non power-of-2.
    //
    if (IsSwizzledD3DFORMAT(D3DFormat) || IsCompressedD3DFORMAT(D3DFormat))
    {
        LogWidth = Log2(Width);
        LogHeight = Log2(Height);
        LogDepth = Log2(Depth);
        SizeWidth = 0;
        SizeHeight = 0;

        DWORD LogMin = MinimumTextureSizeOfD3DFORMAT(D3DFormat);

        if (Levels == 0)
        {
            Levels = max(LogWidth, max(LogHeight, LogDepth)) + 1;
        }
        else if (DBG_CHECK(Levels > max(LogWidth, max(LogHeight, LogDepth)) + 1))
        {
            DXGRIP("PixelJar::EncodeFormat - too many mip levels were specified for this texture.");
        }

        // Figure out the total size of the texture.
        DWORD CurrentLevel;
        DWORD CurrentWidth = LogWidth;
        DWORD CurrentHeight = LogHeight;
        DWORD CurrentDepth = LogDepth;
        DWORD LogSize;

        for (CurrentLevel = Levels; CurrentLevel; CurrentLevel--)
        {
            LogSize = max(CurrentWidth, LogMin) + max(CurrentHeight, LogMin) + CurrentDepth;

            Size += (1 << LogSize) * TexelSize / 8;
    
            if (CurrentWidth > 0)
            {
                CurrentWidth--;
            }

            if (CurrentHeight > 0)
            {
                CurrentHeight--;
            }

            if (CurrentDepth > 0)
            {
                CurrentDepth--;
            }
        }

        if (isCubeMap)
        {
            Size = (Size + D3DTEXTURE_CUBEFACE_ALIGNMENT - 1) 
                     & ~(D3DTEXTURE_CUBEFACE_ALIGNMENT - 1);

            Size *= 6;
        }
    }

    // Non Power-of-2 texture.
    else
    {
        // What should these be set to for one of these?
        LogWidth = LogHeight = LogDepth = 0;

        // Just set the level appropriately.  We don't support mipmaps on non-swizzled
        // textures so just set it to 1.
        //
        if (Levels == 0)
        {
            Levels = 1;
        }

        if (Pitch == 0)
        {
            Pitch = CalcPitch(Width, TexelSize);
        }

        SizeWidth = Width;
        SizeHeight = Height;

        Size = Pitch * Height;
    }

    // Build the format.
    *pFormat =    (isCubeMap ? 0x00000004 : 0)
                | (isVolume ? 3 : 2) << D3DFORMAT_DIMENSION_SHIFT /* UNDONE: verify */
                | D3DFormat << D3DFORMAT_FORMAT_SHIFT
                | Levels << D3DFORMAT_MIPMAP_SHIFT
                | LogWidth << D3DFORMAT_USIZE_SHIFT
                | LogHeight << D3DFORMAT_VSIZE_SHIFT
                | LogDepth << D3DFORMAT_PSIZE_SHIFT
                | D3DFORMAT_DMACHANNEL_A
                | D3DFORMAT_BORDERSOURCE_COLOR;

    if (SizeWidth)
    {
        *pSize   =    (SizeWidth - 1)
                    | (SizeHeight - 1) << D3DSIZE_HEIGHT_SHIFT
                    | ((Pitch  / D3DTEXTURE_PITCH_ALIGNMENT) - 1) << D3DSIZE_PITCH_SHIFT;

        // Make sure we didn't overflow/underflow.
        ASSERT((*pSize & D3DSIZE_WIDTH_MASK) + 1 == SizeWidth);
        ASSERT(((*pSize & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1 == SizeHeight);
        ASSERT(PitchFromSize(*pSize) == Pitch);
    }
    else 
    {
        *pSize = 0;
    }

    return Size;
}

void EncodeTexture(
    DWORD Width,
    DWORD Height,
    DWORD Depth,
    DWORD Levels,
    DWORD Usage,
    D3DFORMAT Format,
    DWORD Pitch,
    bool isCubeMap,
    bool isVolume,
    DWORD Data,
    D3DBaseTexture *pTexture)
{
    EncodeFormat(Width,
                 Height,
                 Depth,
                 Levels,
                 Format,
                 Pitch,
                 isCubeMap,
                 isVolume,
                 &pTexture->Format,
                 &pTexture->Size);

    if (Usage & D3DUSAGE_BORDERSOURCE_TEXTURE)
    {
        pTexture->Format &= ~D3DFORMAT_BORDERSOURCE_COLOR;
    }

    pTexture->Common  = /* initial refcount */ 1 | D3DCOMMON_TYPE_TEXTURE | D3DCOMMON_VIDEOMEMORY;
    pTexture->Lock    = 0;
    pTexture->Data    = Data;
}

extern "C"
VOID WINAPI XGSetSurfaceHeader(
    UINT Width,
    UINT Height,
    D3DFORMAT Format,
    IDirect3DSurface8* pSurface,
    UINT Data,
    UINT Pitch
    )
{
    EncodeFormat(Width,
                 Height,
                 1,
                 1,
                 Format,
                 Pitch,
                 false,
                 false,
                 &pSurface->Format,
                 &pSurface->Size);

    pSurface->Common  = /* initial refcount */ 1 | D3DCOMMON_TYPE_SURFACE | D3DCOMMON_VIDEOMEMORY;
    pSurface->Lock    = 0;
    pSurface->Data    = Data;
    pSurface->Parent  = NULL;
}

extern "C"
VOID WINAPI XGSetTextureHeader(
    UINT Width,
    UINT Height,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    IDirect3DTexture8* pTexture,
    UINT Data,
    UINT Pitch
    )
{
    EncodeTexture(Width,
                  Height,
                  1,
                  Levels,
                  Usage,
                  Format,
                  Pitch,
                  false,
                  false,
                  Data,
                  (D3DBaseTexture*)pTexture);
}

extern "C"
VOID WINAPI XGSetCubeTextureHeader(
    UINT EdgeLength,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    IDirect3DCubeTexture8* pCubeTexture,
    UINT Data,
    UINT Pitch
    )
{
    EncodeTexture(EdgeLength,
                  EdgeLength,
                  1,
                  Levels,
                  Usage,
                  Format,
                  Pitch,
                  true,
                  false,
                  Data,
                  (D3DBaseTexture*)pCubeTexture);
}

extern "C"
VOID WINAPI XGSetVolumeTextureHeader(
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    IDirect3DVolumeTexture8* pVolumeTexture,
    UINT Data,
    UINT Pitch
    )
{
    EncodeTexture(Width,
                  Height,
                  Depth,
                  Levels,
                  Usage,
                  Format,
                  Pitch,
                  false,
                  true,
                  Data,
                  (D3DBaseTexture*)pVolumeTexture);
}

extern "C"
VOID WINAPI XGSetVertexBufferHeader(
    UINT Length,
    DWORD Usage,
    DWORD FVF,
    D3DPOOL Pool,
    IDirect3DVertexBuffer8 *pBuffer,
    UINT Data
    )
{
    pBuffer->Common = /* initial refcount */ 1 | D3DCOMMON_TYPE_VERTEXBUFFER;
    pBuffer->Data = Data;
    ((D3DResource*)pBuffer)->Lock = 0;
}

extern "C"
VOID WINAPI XGSetIndexBufferHeader(
    UINT Length,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    IDirect3DIndexBuffer8 *pBuffer,
    UINT Data
    )
{
    pBuffer->Common = /* initial refcount */ 1 | D3DCOMMON_TYPE_INDEXBUFFER;
    pBuffer->Data = Data;
    ((D3DResource*)pBuffer)->Lock = 0;
}

extern "C"
VOID WINAPI XGSetPaletteHeader(
    D3DPALETTESIZE Size, 
    IDirect3DPalette8 *pPalette,
    UINT Data
    )
{
    pPalette->Common  = /* initial refcount */ 1 | D3DCOMMON_TYPE_PALETTE 
                                                 | D3DCOMMON_VIDEOMEMORY
                                                 | D3DPALETTE_COMMON_VIDEOMEMORY;
    pPalette->Common |= Size << D3DPALETTE_COMMON_PALETTESIZE_SHIFT;
    pPalette->Data = Data;
    ((D3DResource*)pPalette)->Lock = 0;
}

extern "C"
VOID WINAPI XGSetPushBufferHeader(
    UINT Size,
    BOOL RunUsingCpuCopy,
    IDirect3DPushBuffer8 *pPushBuffer,
    UINT Data
    )
{
    pPushBuffer->Common = /* initial refcount */ 1 | D3DCOMMON_TYPE_PUSHBUFFER;

    if (RunUsingCpuCopy)
    {
        pPushBuffer->Common |= D3DPUSHBUFFER_RUN_USING_CPU_COPY;
    }

    pPushBuffer->AllocationSize = Size;
    pPushBuffer->Data = Data;
    pPushBuffer->Size = Size;
    pPushBuffer->Lock = 0;
}

extern "C"
VOID WINAPI XGSetFixupHeader(
    UINT Size,
    IDirect3DFixup8 *pFixup,
    UINT Data
    )
{
    pFixup->Common = /* initial refcount */ 1 | D3DCOMMON_TYPE_FIXUP;
    pFixup->Data = Data;
    pFixup->Size = Size;
    pFixup->Lock = 0;
}

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\misc\surfacetofile.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surfacetofile.cpp
 *  Content:    Utility function to dump surface contents to a .bmp file
 *
 ****************************************************************************/

#if XBOX
    #include "xgrphseg.h"   
    #include "xtl.h"
    
#else
    #include "windows.h"
    #include "d3d8-xbox.h"
#endif

#include "stdio.h"
#include "xgraphics.h"
#include "debug.h"

namespace XGRAPHICS
{

// only define the following structs if they haven't already been defined in
// another header file.
#ifndef BI_RGB

#pragma pack (push, 2)

typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;

typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;

/* constants for the biCompression field */
#define BI_RGB        0L
#define BI_RLE8       1L
#define BI_RLE4       2L
#ifndef BI_BITFIELDS
#define BI_BITFIELDS  3L
#endif  // BI_BITFIELDS
#define BI_JPEG       4L
#define BI_PNG        5L

#pragma pack (pop)

#endif  // defined BI_RGB

extern "C"
HRESULT WINAPI XGWriteSurfaceToFile(IDirect3DSurface8 *pSurf, const char *cPath)
{
    // Write an image to disk in .bmp format
    
    // find out about the surface
    D3DSURFACE_DESC SurfDesc;
    pSurf->GetDesc(&SurfDesc);

    DWORD ImageSize = SurfDesc.Width * SurfDesc.Height * 3;
    
    BITMAPFILEHEADER fileheader;
    BITMAPINFOHEADER bmiheader;
    D3DLOCKED_RECT BBLock;
    INT row, col;

    // Only handle X8R8G8B8 and R5G6B5 formats
    switch(SurfDesc.Format)
    {
    case D3DFMT_LIN_X8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_X1R5G5B5:
        break;  // valid format

    default:
        DXGRIP("WriteSurfaceToFile: Unsupported format\n");
        return E_FAIL;
    }
    
    bmiheader.biBitCount = 24;
    bmiheader.biCompression = BI_RGB;
    bmiheader.biSize = sizeof(BITMAPINFOHEADER);
    bmiheader.biWidth = SurfDesc.Width;
    bmiheader.biHeight = SurfDesc.Height;
    bmiheader.biPlanes = 1;
    bmiheader.biSizeImage = ImageSize;
    bmiheader.biXPelsPerMeter = 0;
    bmiheader.biYPelsPerMeter = 0;
    bmiheader.biClrUsed = 0;
    bmiheader.biClrImportant = 0;

    fileheader.bfType = 0x4d42;
    fileheader.bfSize = sizeof(BITMAPFILEHEADER) +
                        sizeof(BITMAPINFOHEADER) +
                        bmiheader.biSizeImage;
    fileheader.bfReserved1 = 0;
    fileheader.bfReserved2 = 0;
    fileheader.bfOffBits = sizeof(BITMAPFILEHEADER) +
                           sizeof(BITMAPINFOHEADER);


    // open the file and write the image
    DWORD BytesWritten;
    
    HANDLE hFile = INVALID_HANDLE_VALUE;

    hFile = CreateFile(cPath,
                       GENERIC_WRITE, 
                       0, 
                       NULL, 
                       CREATE_ALWAYS, 
                       0, 
                       NULL);

    if(INVALID_HANDLE_VALUE == hFile)
    {
        char buf[256];
        sprintf(buf, "Unable to open file (%s):  error %x\n", cPath, GetLastError());
        DXGRIP(buf);
        return E_FAIL;
    }
    
    WriteFile(hFile, &fileheader, sizeof(BITMAPFILEHEADER), &BytesWritten, NULL);
    WriteFile(hFile, &bmiheader, sizeof(BITMAPINFOHEADER), &BytesWritten, NULL);
    // lock the surface so it can be read
    if(FAILED(pSurf->LockRect(&BBLock, NULL, D3DLOCK_READONLY | D3DLOCK_TILED)))
    {
        DXGRIP("WriteSurfaceToFile: Could not lock surface\n");
        return E_FAIL;
    }

    // temporary buffer - first attempt to allocate a full-size buffer
    #define STACKBUFSIZE (512)
    BYTE stackpixbuf[STACKBUFSIZE];
    DWORD bytecount=0;
    DWORD tmpbufsize;
    BYTE *heapbuffer = new BYTE[ImageSize];
    BYTE *pixbuf;
    if(heapbuffer)
    {
        // successfully allocated full-size buffer, use it
        pixbuf = heapbuffer;
        tmpbufsize = ImageSize;
    }
    else
    {
        // couldn't allocate big buffer so use small buffer on the stack
        // (much slower)
        pixbuf = stackpixbuf;
        tmpbufsize = STACKBUFSIZE;
    }

    WORD *psrc16;
    DWORD *psrc;
    switch(SurfDesc.Format)
    {
    case D3DFMT_LIN_X8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        // convert from 32-bit to 24-bit
        for(row=SurfDesc.Height-1; row >= 0; row--)
        {
            psrc = (DWORD*)((BYTE*)BBLock.pBits + row*BBLock.Pitch);
            for(col=0; col < (INT)SurfDesc.Width; col++)
            {
                pixbuf[bytecount++] = (BYTE)((*psrc )      & 0xff);
                pixbuf[bytecount++] = (BYTE)((*psrc >>  8) & 0xff);
                pixbuf[bytecount++] = (BYTE)((*psrc >> 16) & 0xff);
                psrc++;
                if(bytecount >= (tmpbufsize-2))
                {
                    WriteFile(hFile, pixbuf, bytecount, &BytesWritten, NULL);
                    bytecount=0;
                }
            }
        }
        WriteFile(hFile, pixbuf, bytecount, &BytesWritten, NULL);
        bytecount=0;
        break;
    case D3DFMT_LIN_R5G6B5:
        // convert from 16-bit (565) to 24-bit (888)
        for(row=SurfDesc.Height-1; row >= 0; row--)
        {
            psrc16 = (WORD*)((BYTE*)BBLock.pBits + row*BBLock.Pitch);
            for(col=0; col < (INT)SurfDesc.Width; col++)
            {
                pixbuf[bytecount++] = (BYTE)((*psrc16 <<  3) & 0xf8);
                pixbuf[bytecount++] = (BYTE)((*psrc16 >>  3) & 0xfc);
                pixbuf[bytecount++] = (BYTE)((*psrc16 >>  8) & 0xf8);
                psrc16++;
                if(bytecount >= (tmpbufsize-2))
                {
                    WriteFile(hFile, pixbuf, bytecount, &BytesWritten, NULL);
                    bytecount=0;
                }
            }
        }
        WriteFile(hFile, pixbuf, bytecount, &BytesWritten, NULL);
        bytecount=0;
        break;
    
    case D3DFMT_LIN_X1R5G5B5:
        // convert from 16-bit (555) to 24-bit (888)
        for(row=SurfDesc.Height-1; row >= 0; row--)
        {
            psrc16 = (WORD*)((BYTE*)BBLock.pBits + row*BBLock.Pitch);
            for(col=0; col < (INT)SurfDesc.Width; col++)
            {
                pixbuf[bytecount++] = (BYTE)((*psrc16 <<  3) & 0xf8);
                pixbuf[bytecount++] = (BYTE)((*psrc16 >>  2) & 0xf8);
                pixbuf[bytecount++] = (BYTE)((*psrc16 >>  7) & 0xf8);
                psrc16++;
                if(bytecount >= (tmpbufsize-2))
                {
                    WriteFile(hFile, pixbuf, bytecount, &BytesWritten, NULL);
                    bytecount=0;
                }
            }
        }
        WriteFile(hFile, pixbuf, bytecount, &BytesWritten, NULL);
        bytecount=0;
        break;
    }

    pSurf->UnlockRect();
    
    CloseHandle(hFile); // finished writing image
    
    if(heapbuffer)
        delete [] heapbuffer; // finished with temporary buffer
    
    return S_OK;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\math\xgmath.cpp ===
#if XBOX
#define _USE_XGMATH
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8-xbox.h>
#endif

#include <xgmath.h>
#include <debug.h>

namespace XGRAPHICS
{

#pragma warning(disable:4035)

#define EPSILON 0.00001f

//
// WithinEpsilon - Are two values within EPSILON of each other?
//

static inline BOOL
WithinEpsilon(float a, float b)
{
    float f = a - b;
    return -EPSILON <= f && f <= EPSILON;
}


//
// sincosf - Compute the sin and cos of an angle at the same time
//

static inline void
sincosf(float angle, float *psin, float *pcos)
{
#ifdef _X86_
#define fsincos __asm _emit 0xd9 __asm _emit 0xfb
    __asm {
        mov eax, psin
        mov edx, pcos
        fld angle
        fsincos
        fstp DWORD ptr [edx]
        fstp DWORD ptr [eax]
    }
#undef fsincos
#else //!_X86_
    *psin = sinf(angle);
    *pcos = cosf(angle);
#endif //!_X86_
}


//--------------------------
// 2D Vector
//--------------------------

extern "C"
XGVECTOR2* WINAPI XGVec2Normalize
    ( XGVECTOR2 *pOut, const XGVECTOR2 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = XGVec2LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
    }

    return pOut;
}

extern "C"
XGVECTOR2* WINAPI XGVec2Hermite
    ( XGVECTOR2 *pOut, const XGVECTOR2 *pV1, const XGVECTOR2 *pT1,
      const XGVECTOR2 *pV2, const XGVECTOR2 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    return pOut;
}

extern "C"
XGVECTOR2* WINAPI XGVec2CatmullRom
    ( XGVECTOR2 *pOut, const XGVECTOR2 *pV0, const XGVECTOR2 *pV1,
      const XGVECTOR2 *pV2, const XGVECTOR2 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    return pOut;
}

extern "C"
XGVECTOR2* WINAPI XGVec2BaryCentric
    ( XGVECTOR2 *pOut, const XGVECTOR2 *pV1, const XGVECTOR2 *pV2,
      XGVECTOR2 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    return pOut;
}

extern "C"
XGVECTOR4* WINAPI XGVec2Transform
    ( XGVECTOR4 *pOut, const XGVECTOR2 *pV, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
    if ((ULONG_PTR)pM & 0xF)
    {
        DXGRIP("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif

#ifdef _X86_
    __asm {
        mov     eax, pV
        mov     ecx, pM
        movss   xmm2, [eax]             // pV->x
        shufps  xmm2, xmm2, 0           // Fill xmm2 with x
        mulps   xmm2, [ecx]             // x*pM->_11, x*pM->_12, x*pM->_13, x*pM->_14

        movss   xmm1, [eax+4]           // pV->y
        shufps  xmm1, xmm1, 0           // Fill xmm1 with y
        mulps   xmm1, [ecx+16]          // y*pM->_21, y*pM->_22, y*pM->_23, y*pM->_24

        mov     eax,  pOut
        addps   xmm2, [ecx + 48]        // Add the last row of the matrix
        addps   xmm2, xmm1
        movups  [eax], xmm2             // Output result
    }
#else // !_X86_
    XGVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

extern "C"
XGVECTOR2* WINAPI XGVec2TransformCoord
    ( XGVECTOR2 *pOut, const XGVECTOR2 *pV, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
    if ((ULONG_PTR)pM & 0xF)
    {
        DXGRIP("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif

    float w;

#ifdef _X86_

    __asm {
        mov     eax, pV
        mov     ecx, pM
        movss   xmm2, [eax]             // pV->x
        shufps  xmm2, xmm2, 0           // Fill xmm2 with x
        mulps   xmm2, [ecx]             // x*pM->_11, x*pM->_12, x*pM->_13, x*pM->_14

        movss   xmm1, [eax+4]           // pV->y
        shufps  xmm1, xmm1, 0           // Fill xmm1 with y
        mulps   xmm1, [ecx+16]          // y*pM->_21, y*pM->_22, y*pM->_23, y*pM->_24

        mov     eax,  pOut
        addps   xmm2, [ecx + 48]        // Add the last row of the matrix
        addps   xmm2, xmm1

        movlps  [eax], xmm2
        shufps  xmm2, xmm2, 0FFh        // Fill xmm2 with w
        movss   [w], xmm2
    }

#else // !_X86_
    XGVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pM->_42;
    w   = pV->x * pM->_14 + pV->y * pM->_24 + pM->_44;

    *pOut = *((XGVECTOR2 *) &v);
#endif // !_X86_

    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

extern "C"
XGVECTOR2* WINAPI XGVec2TransformNormal
    ( XGVECTOR2 *pOut, const XGVECTOR2 *pV, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
    if ((ULONG_PTR)pM & 0xF)
    {
        DXGRIP("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif

#ifdef _X86_
    __asm {
        mov     eax, pV
        movss   xmm2, [eax]             // pV->x
        mov     ecx, pM
        shufps  xmm2, xmm2, 0           // Fill xmm2 with x
        mulps   xmm2, [ecx]             // x*pM->_11, x*pM->_12, x*pM->_13, x*pM->_14

        movss   xmm1, [eax+4]           // pV->y
        shufps  xmm1, xmm1, 0           // Fill xmm1 with y
        mulps   xmm1, [ecx+16]          // y*pM->_21, y*pM->_22, y*pM->_23, y*pM->_24

        mov     eax,  pOut
        addps   xmm2, xmm1
        movlps  [eax], xmm2             // Output result
    }
#else // !_X86_

    XGVECTOR2 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21;
    v.y = pV->x * pM->_12 + pV->y * pM->_22;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 3D Vector
//--------------------------

extern "C"
XGVECTOR3* WINAPI XGVec3Normalize
    ( XGVECTOR3 *pOut, const XGVECTOR3 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = XGVec3LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
    }

    return pOut;
}

extern "C"
XGVECTOR3* WINAPI XGVec3Hermite
    ( XGVECTOR3 *pOut, const XGVECTOR3 *pV1, const XGVECTOR3 *pT1,
      const XGVECTOR3 *pV2, const XGVECTOR3 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    return pOut;
}

extern "C"
XGVECTOR3* WINAPI XGVec3CatmullRom
    ( XGVECTOR3 *pOut, const XGVECTOR3 *pV0, const XGVECTOR3 *pV1,
      const XGVECTOR3 *pV2, const XGVECTOR3 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    pOut->z = 0.5f * (sV0 * pV0->z + sV1 * pV1->z + sV2 * pV2->z + sV3 * pV3->z);
    return pOut;
}

extern "C"
XGVECTOR3* WINAPI XGVec3BaryCentric
    ( XGVECTOR3 *pOut, const XGVECTOR3 *pV1, const XGVECTOR3 *pV2,
      const XGVECTOR3 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    return pOut;
}

extern "C"
XGVECTOR4* WINAPI XGVec3Transform
    ( XGVECTOR4 *pOut, const XGVECTOR3 *pV, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
    if ((ULONG_PTR)pM & 0xF)
    {
        DXGRIP("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif

#ifdef _X86_
    __asm {
        mov     eax, pV
        mov     ecx, pM
        movss   xmm2, [eax]             // pV->x
        shufps  xmm2, xmm2, 0           // Fill xmm2 with x
        mulps   xmm2, [ecx]             // x*pM->_11, x*pM->_12, x*pM->_13, x*pM->_14

        movss   xmm1, [eax+4]           // pV->y
        shufps  xmm1, xmm1, 0           // Fill xmm1 with y
        mulps   xmm1, [ecx+16]          // y*pM->_21, y*pM->_22, y*pM->_23, y*pM->_24

        movss   xmm3, [eax+8]
        shufps  xmm3, xmm3, 0           // Fill xmm3 with z
        mulps   xmm3, [ecx+32]          // z*pM->_31, z*pM->_32, z*pM->_33, z*pM->_34

        addps   xmm2, [ecx + 48]        // Add the last row of the matrix
        mov     eax,  pOut
        addps   xmm2, xmm1
        addps   xmm2, xmm3
        movups  [eax], xmm2             // Output result
    }
#else // !_X86_
    XGVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

extern "C"
XGVECTOR3* WINAPI XGVec3TransformCoord
    ( XGVECTOR3 *pOut, const XGVECTOR3 *pV, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
    if ((ULONG_PTR)pM & 0xF)
    {
        DXGRIP("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif

    float w;

#ifdef _X86_
    __asm {
        mov     eax, pV
        mov     ecx, pM
        movss   xmm2, [eax]             // pV->x
        shufps  xmm2, xmm2, 0           // Fill xmm2 with x
        mulps   xmm2, [ecx]             // x*pM->_11, x*pM->_12, x*pM->_13, x*pM->_14

        movss   xmm1, [eax+4]           // pV->y
        shufps  xmm1, xmm1, 0           // Fill xmm1 with y
        mulps   xmm1, [ecx+16]          // y*pM->_21, y*pM->_22, y*pM->_23, y*pM->_24

        movss   xmm3, [eax+8]
        shufps  xmm3, xmm3, 0           // Fill xmm3 with z
        mulps   xmm3, [ecx+32]          // z*pM->_31, z*pM->_32, z*pM->_33, z*pM->_34

        addps   xmm2, [ecx + 48]        // Add the last row of the matrix
        mov     eax,  pOut
        addps   xmm2, xmm1
        addps   xmm2, xmm3

        movlps  [eax], xmm2             // Move pOut x and y
        shufps  xmm2, xmm2, 0FEh
        movss   [eax + 8], xmm2         // Move pOut z

        shufps  xmm2, xmm2, 0FFh
        movss   [w], xmm2               // Move w
    }
#else // !_X86_
    XGVECTOR3 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    w   = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
#endif // !_X86_

    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

extern "C"
XGVECTOR3* WINAPI XGVec3TransformNormal
    ( XGVECTOR3 *pOut, const XGVECTOR3 *pV, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
    if ((ULONG_PTR)pM & 0xF)
    {
        DXGRIP("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif

#ifdef _X86_
    __asm {
        mov     eax, pV
        movss   xmm2, [eax]             // pV->x
        mov     ecx, pM
        shufps  xmm2, xmm2, 0           // Fill xmm2 with x
        mulps   xmm2, [ecx]             // x*pM->_11, x*pM->_12, x*pM->_13, x*pM->_14

        movss   xmm1, [eax+4]           // pV->y
        shufps  xmm1, xmm1, 0           // Fill xmm1 with y
        mulps   xmm1, [ecx+16]          // y*pM->_21, y*pM->_22, y*pM->_23, y*pM->_24

        movss   xmm3, [eax+8]           // pV->z
        shufps  xmm3, xmm3, 0           // Fill xmm3 with z
        mulps   xmm3, [ecx+32]          // z*pM->_31, z*pM->_32, z*pM->_33, z*pM->_34

        addps   xmm2, xmm1
        mov     eax,  pOut
        addps   xmm2, xmm3
        movlps  [eax], xmm2             // Output x and y of the result
        movhlps xmm2, xmm2
        movss   [eax+8], xmm2           // Output z of the result
    }
#else // !_X86_
    XGVECTOR3 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


extern "C"
XGVECTOR3* WINAPI XGVec3Project
    ( XGVECTOR3 *pOut, const XGVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const XGMATRIX *pProjection, const XGMATRIX *pView, const XGMATRIX *pWorld)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    XGMATRIX mat;
    const XGMATRIX *pMat = &mat;

    switch(((NULL != pWorld) << 2) | ((NULL != pView) << 1) | (NULL != pProjection))
    {
    case 0: // ---
        XGMatrixIdentity(&mat);
        break;

    case 1: // --P
        pMat = pProjection;
        break;

    case 2: // -V-
        pMat = pView;
        break;

    case 3: // -VP
        XGMatrixMultiply(&mat, pView, pProjection);
        break;

    case 4: // W--
        pMat = pWorld;
        break;

    case 5: // W-P
        XGMatrixMultiply(&mat, pWorld, pProjection);
        break;

    case 6: // WV-
        XGMatrixMultiply(&mat, pWorld, pView);
        break;

    case 7: // WVP
        XGMatrixMultiply(&mat, pWorld, pView);
        XGMatrixMultiply(&mat, &mat, pProjection);
        break;
    }


    XGVec3TransformCoord(pOut, pV, pMat);

    if(pViewport)
    {
        pOut->x = ( pOut->x + 1.0f) * 0.5f * (float) pViewport->Width  + (float) pViewport->X;
        pOut->y = (-pOut->y + 1.0f) * 0.5f * (float) pViewport->Height + (float) pViewport->Y;
        pOut->z = pOut->z * (pViewport->MaxZ - pViewport->MinZ) +  pViewport->MinZ;
    }

    return pOut;
}


extern "C"
XGVECTOR3* WINAPI XGVec3Unproject
    ( XGVECTOR3 *pOut, const XGVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const XGMATRIX *pProjection, const XGMATRIX *pView, const XGMATRIX *pWorld)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    XGMATRIX mat;

    switch(((NULL != pWorld) << 2) | ((NULL != pView) << 1) | (NULL != pProjection))
    {
    case 0: // ---
        XGMatrixIdentity(&mat);
        break;

    case 1: // --P
        XGMatrixInverse(&mat, NULL, pProjection);
        break;

    case 2: // -V-
        XGMatrixInverse(&mat, NULL, pView);
        break;

    case 3: // -VP
        XGMatrixMultiply(&mat, pView, pProjection);
        XGMatrixInverse(&mat, NULL, &mat);
        break;

    case 4: // W--
        XGMatrixInverse(&mat, NULL, pWorld);
        break;

    case 5: // W-P
        XGMatrixMultiply(&mat, pWorld, pProjection);
        XGMatrixInverse(&mat, NULL, &mat);
        break;

    case 6: // WV-
        XGMatrixMultiply(&mat, pWorld, pView);
        XGMatrixInverse(&mat, NULL, &mat);
        break;

    case 7: // WVP
        XGMatrixMultiply(&mat, pWorld, pView);
        XGMatrixMultiply(&mat, &mat, pProjection);
        XGMatrixInverse(&mat, NULL, &mat);
        break;
    }


    if(pViewport)
    {
        pOut->x = (pV->x - (float) pViewport->X) / (float) pViewport->Width * 2.0f - 1.0f;
        pOut->y = -((pV->y - (float) pViewport->Y) / (float) pViewport->Height * 2.0f - 1.0f);
        pOut->z = (pV->z - pViewport->MinZ) / (pViewport->MaxZ - pViewport->MinZ);

        XGVec3TransformCoord(pOut, pOut, &mat);
    }
    else
    {
        XGVec3TransformCoord(pOut, pV, &mat);
    }

    return pOut;
}



//--------------------------
// 4D Vector
//--------------------------

extern "C"
XGVECTOR4* WINAPI XGVec4Cross
    ( XGVECTOR4 *pOut, const XGVECTOR4 *pV1, const XGVECTOR4 *pV2,
      const XGVECTOR4 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    XGVECTOR4 v;

    v.x = pV1->y * (pV2->z * pV3->w - pV3->z * pV2->w) -
          pV1->z * (pV2->y * pV3->w - pV3->y * pV2->w) +
          pV1->w * (pV2->y * pV3->z - pV3->y * pV2->z);

    v.y = pV1->x * (pV3->z * pV2->w - pV2->z * pV3->w) -
          pV1->z * (pV3->x * pV2->w - pV2->x * pV3->w) +
          pV1->w * (pV3->x * pV2->z - pV2->x * pV3->z);

    v.z = pV1->x * (pV2->y * pV3->w - pV3->y * pV2->w) -
          pV1->y * (pV2->x * pV3->w - pV3->x * pV2->w) +
          pV1->w * (pV2->x * pV3->y - pV3->x * pV2->y);

    v.w = pV1->x * (pV3->y * pV2->z - pV2->y * pV3->z) -
          pV1->y * (pV3->x * pV2->z - pV2->x * pV3->z) +
          pV1->z * (pV3->x * pV2->y - pV2->x * pV3->y);

    *pOut = v;
    return pOut;
}

extern "C"
XGVECTOR4* WINAPI XGVec4Normalize
    ( XGVECTOR4 *pOut, const XGVECTOR4 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = XGVec4LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

extern "C"
XGVECTOR4* WINAPI XGVec4Hermite
    ( XGVECTOR4 *pOut, const XGVECTOR4 *pV1, const XGVECTOR4 *pT1,
      const XGVECTOR4 *pV2, const XGVECTOR4 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    pOut->w = sV1 * pV1->w + sT1 * pT1->w + sV2 * pV2->w + sT2 * pT2->w;
    return pOut;
}

extern "C"
XGVECTOR4* WINAPI XGVec4CatmullRom
    ( XGVECTOR4 *pOut, const XGVECTOR4 *pV0, const XGVECTOR4 *pV1,
      const XGVECTOR4 *pV2, const XGVECTOR4 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    pOut->z = 0.5f * (sV0 * pV0->z + sV1 * pV1->z + sV2 * pV2->z + sV3 * pV3->z);
    pOut->w = 0.5f * (sV0 * pV0->w + sV1 * pV1->w + sV2 * pV2->w + sV3 * pV3->w);
    return pOut;
}

extern "C"
XGVECTOR4* WINAPI XGVec4BaryCentric
    ( XGVECTOR4 *pOut, const XGVECTOR4 *pV1, const XGVECTOR4 *pV2,
      const XGVECTOR4 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    pOut->w = pV1->w + f * (pV2->w - pV1->w) + g * (pV3->w - pV1->w);
    return pOut;
}

extern "C"
XGVECTOR4* WINAPI XGVec4Transform
    ( XGVECTOR4 *pOut, const XGVECTOR4 *pV, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
    if ((ULONG_PTR)pM & 0xF)
    {
        DXGRIP("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif

#ifdef _X86_
    __asm {
        mov     eax, pV
        movups  xmm2, [eax]             // pV->x
        mov     eax, pM
        movaps  xmm1, xmm2              // pV->x
        shufps  xmm2, xmm2, 0           // Fill xmm2 with x
        mulps   xmm2, [eax]             // x*pM->_11, x*pM->_12, x*pM->_13, x*pM->_14

        movaps  xmm3, xmm1
        shufps  xmm1, xmm1, 55h         // Fill xmm1 with y
        mulps   xmm1, [eax+16]          // y*pM->_21, y*pM->_22, y*pM->_23, y*pM->_24

        movaps  xmm4, xmm3
        shufps  xmm3, xmm3, 0AAh        // Fill xmm3 with z
        mulps   xmm3, [eax+32]          // z*pM->_31, z*pM->_32, z*pM->_33, z*pM->_34

        shufps  xmm4, xmm4, 0FFh        // Fill xmm3 with w
        mulps   xmm4, [eax+48]          // w*pM->_41, w*pM->_42, w*pM->_43, w*pM->_44

        mov     eax,  pOut
        addps   xmm2, xmm1
        addps   xmm2, xmm3
        addps   xmm2, xmm4
        movups  [eax], xmm2             // Output result
    }
#else // !_X86_
    XGVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pV->w * pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pV->w * pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pV->w * pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pV->w * pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 4D Matrix
//--------------------------

extern "C"
float WINAPI XGMatrixfDeterminant
    ( const XGMATRIX *pM )
{
#if DBG
    if(!pM)
        return 0.0f;
#endif

    return (pM->_11 * (pM->_22 * (pM->_33 * pM->_44 - pM->_43 * pM->_34) -
                       pM->_23 * (pM->_32 * pM->_44 - pM->_42 * pM->_34) +
                       pM->_24 * (pM->_32 * pM->_43 - pM->_42 * pM->_33)))

         - (pM->_12 * (pM->_21 * (pM->_33 * pM->_44 - pM->_43 * pM->_34) -
                       pM->_23 * (pM->_31 * pM->_44 - pM->_41 * pM->_34) +
                       pM->_24 * (pM->_31 * pM->_43 - pM->_41 * pM->_33)))

         + (pM->_13 * (pM->_21 * (pM->_32 * pM->_44 - pM->_42 * pM->_34) -
                       pM->_22 * (pM->_31 * pM->_44 - pM->_41 * pM->_34) +
                       pM->_24 * (pM->_31 * pM->_42 - pM->_41 * pM->_32)))

         - (pM->_14 * (pM->_21 * (pM->_32 * pM->_43 - pM->_42 * pM->_33) -
                       pM->_22 * (pM->_31 * pM->_43 - pM->_41 * pM->_33) +
                       pM->_23 * (pM->_31 * pM->_42 - pM->_41 * pM->_32)));
}


extern "C"
XGMATRIX* WINAPI XGMatrixMultiply
    ( XGMATRIX *pOut, const XGMATRIX *pM1, const XGMATRIX *pM2 )
{
#if DBG
    if(!pOut || !pM1 || !pM2)
        return NULL;
    
    if ((ULONG_PTR)pOut & 0xF ||
        (ULONG_PTR)pM1 & 0xF ||
        (ULONG_PTR)pM2 & 0xF)
    {
        DXGRIP("Matrix must be 16-byte aligned");
        return NULL;
    }
#endif // DBG
    __asm
    {
        mov     eax, pM1
        mov     ecx, pM2

        // Result will be in xmm2, xmm3, xmm4, xmm5

        movaps  xmm2, [eax]                 
        shufps  xmm2, xmm2, 0               
        mulps   xmm2, [ecx]             // a11*b11, a11*b12, a11*b13, a11*b14

        movaps  xmm1, [eax]
        shufps  xmm1, xmm1, 55h
        mulps   xmm1, [ecx+16]          // a12*b21, a12*b22, a12*b23, a12*b24

        movaps  xmm0, [eax]
        shufps  xmm0, xmm0, 0AAh
        mulps   xmm0, [ecx+32]          // a13*b31, a13*b32, a13*b33, a13*b34

        addps   xmm2, xmm1

        movaps  xmm1, [eax]
        shufps  xmm1, xmm1, 0FFh
        mulps   xmm1, [ecx+48]          // a14*b41, a14*b42, a14*b43, a14*b44

        addps   xmm2, xmm0              

        movaps  xmm3, [eax+16]          // Start computing 2 row of the result
        shufps  xmm3, xmm3, 0

        addps   xmm2, xmm1              // 1 row of the result

        mulps   xmm3, [ecx]

        movaps  xmm1, [eax+16]
        shufps  xmm1, xmm1, 55h
        mulps   xmm1, [ecx+16]

        movaps  xmm0, [eax+16]
        shufps  xmm0, xmm0, 0AAh
        mulps   xmm0, [ecx+32]

        addps   xmm3, xmm1

        movaps  xmm1, [eax+16]
        shufps  xmm1, xmm1, 0FFh
        mulps   xmm1, [ecx+48]

        addps   xmm3, xmm0              

        movaps  xmm4, [eax+32]          // Start computing 3 row of the result
        shufps  xmm4, xmm4, 0
        
        addps   xmm3, xmm1              // 2 row of the result

        mulps   xmm4, [ecx]

        movaps  xmm1, [eax+32]
        shufps  xmm1, xmm1, 55h
        mulps   xmm1, [ecx+16]

        movaps  xmm0, [eax+32]
        shufps  xmm0, xmm0, 0AAh
        mulps   xmm0, [ecx+32]

        addps   xmm4, xmm1

        movaps  xmm1, [eax+32]
        shufps  xmm1, xmm1, 0FFh
        mulps   xmm1, [ecx+48]

        addps   xmm4, xmm0

        movaps  xmm5, [eax+48]          // Start computing 4 row of the result
        shufps  xmm5, xmm5, 0
        
        addps   xmm4, xmm1              // 3 row of the result

        mulps   xmm5, [ecx]

        movaps  xmm1, [eax+48]
        shufps  xmm1, xmm1, 55h
        mulps   xmm1, [ecx+16]

        movaps  xmm0, [eax+48]
        shufps  xmm0, xmm0, 0AAh
        mulps   xmm0, [ecx+32]

        addps   xmm5, xmm1

        movaps  xmm1, [eax+48]
        shufps  xmm1, xmm1, 0FFh
        mulps   xmm1, [ecx+48]

        mov     ecx, pOut
        addps   xmm5, xmm0

        addps   xmm5, xmm1              // 4 row of the result

        movaps  [ecx   ], xmm2
        movaps  [ecx+16], xmm3
        movaps  [ecx+32], xmm4
        movaps  [ecx+48], xmm5
    }
    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixTranspose
    ( XGMATRIX *pOut, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    __asm {
        mov       ecx, pM
        mov       eax, pOut

        movaps    xmm0, [ecx]
        movaps    xmm2, [ecx+16]
        movaps    xmm3, [ecx+32]
        movaps    xmm5, [ecx+48]

        movaps    xmm1, xmm0
        movaps    xmm4, xmm3

        unpcklps  xmm0, xmm2
        unpckhps  xmm1, xmm2
        unpcklps  xmm3, xmm5
        unpckhps  xmm4, xmm5

        movlps    [eax], xmm0
        movlps    [eax+8], xmm3
        movhps    [eax+16], xmm0
        movhps    [eax+24], xmm3
        movlps    [eax+32], xmm1
        movlps    [eax+40], xmm4
        movhps    [eax+48], xmm1
        movhps    [eax+56], xmm4
    }
}

extern "C"
XGMATRIX* WINAPI XGMatrixInverse
    ( XGMATRIX *pOut, float *pfDeterminant, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    // XXXlorenmcq - The code was designed to work on a processor with more
    //  than 4 general-purpose registers.  Is there a more optimal way of
    //  doing this on X86?

    float fX00, fX01, fX02;
    float fX10, fX11, fX12;
    float fX20, fX21, fX22;
    float fX30, fX31, fX32;
    float fY01, fY02, fY03, fY12, fY13, fY23;
    float fZ02, fZ03, fZ12, fZ13, fZ22, fZ23, fZ32, fZ33;

#define fX03 fX01
#define fX13 fX11
#define fX23 fX21
#define fX33 fX31
#define fZ00 fX02
#define fZ10 fX12
#define fZ20 fX22
#define fZ30 fX32
#define fZ01 fX03
#define fZ11 fX13
#define fZ21 fX23
#define fZ31 fX33
#define fDet fY01
#define fRcp fY02

    // read 1st two columns of matrix
    fX00 = pM->_11;
    fX01 = pM->_12;
    fX10 = pM->_21;
    fX11 = pM->_22;
    fX20 = pM->_31;
    fX21 = pM->_32;
    fX30 = pM->_41;
    fX31 = pM->_42;

    // compute all six 2x2 determinants of 1st two columns
    fY01 = fX00 * fX11 - fX10 * fX01;
    fY02 = fX00 * fX21 - fX20 * fX01;
    fY03 = fX00 * fX31 - fX30 * fX01;
    fY12 = fX10 * fX21 - fX20 * fX11;
    fY13 = fX10 * fX31 - fX30 * fX11;
    fY23 = fX20 * fX31 - fX30 * fX21;

    // read 2nd two columns of matrix
    fX02 = pM->_13;
    fX03 = pM->_14;
    fX12 = pM->_23;
    fX13 = pM->_24;
    fX22 = pM->_33;
    fX23 = pM->_34;
    fX32 = pM->_43;
    fX33 = pM->_44;

    // compute all 3x3 cofactors for 2nd two columns
    fZ33 = fX02 * fY12 - fX12 * fY02 + fX22 * fY01;
    fZ23 = fX12 * fY03 - fX32 * fY01 - fX02 * fY13;
    fZ13 = fX02 * fY23 - fX22 * fY03 + fX32 * fY02;
    fZ03 = fX22 * fY13 - fX32 * fY12 - fX12 * fY23;
    fZ32 = fX13 * fY02 - fX23 * fY01 - fX03 * fY12;
    fZ22 = fX03 * fY13 - fX13 * fY03 + fX33 * fY01;
    fZ12 = fX23 * fY03 - fX33 * fY02 - fX03 * fY23;
    fZ02 = fX13 * fY23 - fX23 * fY13 + fX33 * fY12;

    // compute all six 2x2 determinants of 2nd two columns
    fY01 = fX02 * fX13 - fX12 * fX03;
    fY02 = fX02 * fX23 - fX22 * fX03;
    fY03 = fX02 * fX33 - fX32 * fX03;
    fY12 = fX12 * fX23 - fX22 * fX13;
    fY13 = fX12 * fX33 - fX32 * fX13;
    fY23 = fX22 * fX33 - fX32 * fX23;

    // read 1st two columns of matrix
    fX00 = pM->_11;
    fX01 = pM->_12;
    fX10 = pM->_21;
    fX11 = pM->_22;
    fX20 = pM->_31;
    fX21 = pM->_32;
    fX30 = pM->_41;
    fX31 = pM->_42;

    // compute all 3x3 cofactors for 1st two columns
    fZ30 = fX11 * fY02 - fX21 * fY01 - fX01 * fY12;
    fZ20 = fX01 * fY13 - fX11 * fY03 + fX31 * fY01;
    fZ10 = fX21 * fY03 - fX31 * fY02 - fX01 * fY23;
    fZ00 = fX11 * fY23 - fX21 * fY13 + fX31 * fY12;
    fZ31 = fX00 * fY12 - fX10 * fY02 + fX20 * fY01;
    fZ21 = fX10 * fY03 - fX30 * fY01 - fX00 * fY13;
    fZ11 = fX00 * fY23 - fX20 * fY03 + fX30 * fY02;
    fZ01 = fX20 * fY13 - fX30 * fY12 - fX10 * fY23;

    // compute 4x4 determinant & its reciprocal
    fDet = fX30 * fZ30 + fX20 * fZ20 + fX10 * fZ10 + fX00 * fZ00;

    if(pfDeterminant)
        *pfDeterminant = fDet;

    fRcp = 1.0f / fDet;

    if(!_finite(fRcp))
        return NULL;


    // multiply all 3x3 cofactors by reciprocal & transpose
    pOut->_11 = fZ00 * fRcp;
    pOut->_12 = fZ10 * fRcp;
    pOut->_13 = fZ20 * fRcp;
    pOut->_14 = fZ30 * fRcp;
    pOut->_21 = fZ01 * fRcp;
    pOut->_22 = fZ11 * fRcp;
    pOut->_23 = fZ21 * fRcp;
    pOut->_24 = fZ31 * fRcp;
    pOut->_31 = fZ02 * fRcp;
    pOut->_32 = fZ12 * fRcp;
    pOut->_33 = fZ22 * fRcp;
    pOut->_34 = fZ32 * fRcp;
    pOut->_41 = fZ03 * fRcp;
    pOut->_42 = fZ13 * fRcp;
    pOut->_43 = fZ23 * fRcp;
    pOut->_44 = fZ33 * fRcp;

    return pOut;
}



extern "C"
XGMATRIX* WINAPI XGMatrixScaling
    ( XGMATRIX *pOut, float sx, float sy, float sz )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 =
    pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

    pOut->_11 = sx;
    pOut->_22 = sy;
    pOut->_33 = sz;
    pOut->_44 = 1.0f;
    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixTranslation
    ( XGMATRIX *pOut, float x, float y, float z )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 = 0.0f;

    pOut->_11 = pOut->_22 = pOut->_33 = pOut->_44 = 1.0f;

    pOut->_41 = x;
    pOut->_42 = y;
    pOut->_43 = z;
    return pOut;
}


extern "C"
XGMATRIX* WINAPI XGMatrixRotationX
    ( XGMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 = 1.0f; pOut->_12 = 0.0f; pOut->_13 = 0.0f; pOut->_14 = 0.0f;
    pOut->_21 = 0.0f; pOut->_22 =    c; pOut->_23 =    s; pOut->_24 = 0.0f;
    pOut->_31 = 0.0f; pOut->_32 =   -s; pOut->_33 =    c; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixRotationY
    ( XGMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 =    c; pOut->_12 = 0.0f; pOut->_13 =   -s; pOut->_14 = 0.0f;
    pOut->_21 = 0.0f; pOut->_22 = 1.0f; pOut->_23 = 0.0f; pOut->_24 = 0.0f;
    pOut->_31 =    s; pOut->_32 = 0.0f; pOut->_33 =    c; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixRotationZ
    ( XGMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 =    c; pOut->_12 =    s; pOut->_13 = 0.0f; pOut->_14 = 0.0f;
    pOut->_21 =   -s; pOut->_22 =    c; pOut->_23 = 0.0f; pOut->_24 = 0.0f;
    pOut->_31 = 0.0f; pOut->_32 = 0.0f; pOut->_33 = 1.0f; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixRotationAxis
    ( XGMATRIX *pOut, const XGVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);
    float c1 = 1 - c;

    XGVECTOR3 v = *pV;
    XGVec3Normalize(&v, &v);

    float xyc1 = v.x * v.y * c1;
    float yzc1 = v.y * v.z * c1;
    float zxc1 = v.z * v.x * c1;

    pOut->_11 = v.x * v.x * c1 + c;
    pOut->_12 = xyc1 + v.z * s;
    pOut->_13 = zxc1 - v.y * s;
    pOut->_14 = 0.0f;

    pOut->_21 = xyc1 - v.z * s;
    pOut->_22 = v.y * v.y * c1 + c;
    pOut->_23 = yzc1 + v.x * s;
    pOut->_24 = 0.0f;

    pOut->_31 = zxc1 + v.y * s;
    pOut->_32 = yzc1 - v.x * s;
    pOut->_33 = v.z * v.z * c1 + c;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixRotationQuaternion
    ( XGMATRIX *pOut, const XGQUATERNION *pQ)
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float x2 = pQ->x + pQ->x;
    float y2 = pQ->y + pQ->y;
    float z2 = pQ->z + pQ->z;

    float wx2 = pQ->w * x2;
    float wy2 = pQ->w * y2;
    float wz2 = pQ->w * z2;
    float xx2 = pQ->x * x2;
    float xy2 = pQ->x * y2;
    float xz2 = pQ->x * z2;
    float yy2 = pQ->y * y2;
    float yz2 = pQ->y * z2;
    float zz2 = pQ->z * z2;

    pOut->_11 = 1.0f - yy2 - zz2;
    pOut->_12 = xy2 + wz2;
    pOut->_13 = xz2 - wy2;
    pOut->_14 = 0.0f;

    pOut->_21 = xy2 - wz2;
    pOut->_22 = 1.0f - xx2 - zz2;
    pOut->_23 = yz2 + wx2;
    pOut->_24 = 0.0f;

    pOut->_31 = xz2 + wy2;
    pOut->_32 = yz2 - wx2;
    pOut->_33 = 1.0f - xx2 - yy2;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixRotationYawPitchRoll
    ( XGMATRIX *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    XGQUATERNION q;

    XGQuaternionRotationYawPitchRoll(&q, yaw, pitch, roll);
    XGMatrixRotationQuaternion(pOut, &q);

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixTransformation
    ( XGMATRIX *pOut, const XGVECTOR3 *pScalingCenter,
      const XGQUATERNION *pScalingRotation, const XGVECTOR3 *pScaling,
      const XGVECTOR3 *pRotationCenter, const XGQUATERNION *pRotation,
      const XGVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    XGMATRIX matS, matR, matRI;

    if (pScaling)
    {
        if (pScalingRotation)
        {
            matS._12 = matS._13 = matS._14 =
            matS._21 = matS._23 = matS._24 =
            matS._31 = matS._32 = matS._34 =
            matS._41 = matS._42 = matS._43 = 0.0f;

            matS._11 = pScaling->x;
            matS._22 = pScaling->y;
            matS._33 = pScaling->z;
            matS._44 = 1.0f;

            XGMatrixRotationQuaternion(&matR, pScalingRotation);


            if (pScalingCenter)
            {
                // SC-1, SR-1, S, SR, SC
                XGMatrixTranspose(&matRI, &matR);
                XGMatrixIdentity(pOut);

                pOut->_41 -= pScalingCenter->x;
                pOut->_42 -= pScalingCenter->y;
                pOut->_43 -= pScalingCenter->z;

                XGMatrixMultiply(pOut, pOut, &matRI);
                XGMatrixMultiply(pOut, pOut, &matS);
                XGMatrixMultiply(pOut, pOut, &matR);

                pOut->_41 += pScalingCenter->x;
                pOut->_42 += pScalingCenter->y;
                pOut->_43 += pScalingCenter->z;
            }
            else
            {
                // SR-1, S, SR
                XGMatrixTranspose(pOut, &matR);
                XGMatrixMultiply(pOut, pOut, &matS);
                XGMatrixMultiply(pOut, pOut, &matR);
            }
        }
        else
        {
            // S
            pOut->_12 = pOut->_13 = pOut->_14 =
            pOut->_21 = pOut->_23 = pOut->_24 =
            pOut->_31 = pOut->_32 = pOut->_34 =
            pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

            pOut->_11 = pScaling->x;
            pOut->_22 = pScaling->y;
            pOut->_33 = pScaling->z;
            pOut->_44 = 1.0f;
        }

    }
    else
    {
        XGMatrixIdentity(pOut);
    }

    if (pRotation)
    {
        XGMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->_41 -= pRotationCenter->x;
            pOut->_42 -= pRotationCenter->y;
            pOut->_43 -= pRotationCenter->z;

            XGMatrixMultiply(pOut, pOut, &matR);

            pOut->_41 += pRotationCenter->x;
            pOut->_42 += pRotationCenter->y;
            pOut->_43 += pRotationCenter->z;
        }
        else
        {
            // R
            XGMatrixMultiply(pOut, pOut, &matR);
        }
    }

    if (pTranslation)
    {
        // T
        pOut->_41 += pTranslation->x;
        pOut->_42 += pTranslation->y;
        pOut->_43 += pTranslation->z;
    }

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixAffineTransformation
    ( XGMATRIX *pOut, float Scaling, const XGVECTOR3 *pRotationCenter,
      const XGQUATERNION *pRotation, const XGVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    // S
    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 =
    pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

    pOut->_11 = Scaling;
    pOut->_22 = Scaling;
    pOut->_33 = Scaling;
    pOut->_44 = 1.0f;


    if (pRotation)
    {
        XGMATRIX matR;
        XGMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->_41 -= pRotationCenter->x;
            pOut->_42 -= pRotationCenter->y;
            pOut->_43 -= pRotationCenter->z;

            XGMatrixMultiply(pOut, pOut, &matR);

            pOut->_41 += pRotationCenter->x;
            pOut->_42 += pRotationCenter->y;
            pOut->_43 += pRotationCenter->z;
        }
        else
        {
            // R
            XGMatrixMultiply(pOut, pOut, &matR);
        }
    }


    if (pTranslation)
    {
        // T
        pOut->_41 += pTranslation->x;
        pOut->_42 += pTranslation->y;
        pOut->_43 += pTranslation->z;
    }

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixLookAtRH
    ( XGMATRIX *pOut, const XGVECTOR3 *pEye, const XGVECTOR3 *pAt,
      const XGVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    XGVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (-Z)
    XGVec3Subtract(&ZAxis, pEye, pAt);
    XGVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    XGVec3Cross(&XAxis, pUp, &ZAxis);
    XGVec3Normalize(&XAxis, &XAxis);
    XGVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->_11 = XAxis.x;
    pOut->_21 = XAxis.y;
    pOut->_31 = XAxis.z;
    pOut->_41 = -XGVec3Dot(&XAxis, pEye);

    pOut->_12 = YAxis.x;
    pOut->_22 = YAxis.y;
    pOut->_32 = YAxis.z;
    pOut->_42 = -XGVec3Dot(&YAxis, pEye);

    pOut->_13 = ZAxis.x;
    pOut->_23 = ZAxis.y;
    pOut->_33 = ZAxis.z;
    pOut->_43 = -XGVec3Dot(&ZAxis, pEye);

    pOut->_14 = 0.0f;
    pOut->_24 = 0.0f;
    pOut->_34 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixLookAtLH
    ( XGMATRIX *pOut, const XGVECTOR3 *pEye, const XGVECTOR3 *pAt,
      const XGVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    XGVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (+Z)
    XGVec3Subtract(&ZAxis, pAt, pEye);
    XGVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    XGVec3Cross(&XAxis, pUp, &ZAxis);
    XGVec3Normalize(&XAxis, &XAxis);
    XGVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->_11 = XAxis.x;
    pOut->_21 = XAxis.y;
    pOut->_31 = XAxis.z;
    pOut->_41 = -XGVec3Dot(&XAxis, pEye);

    pOut->_12 = YAxis.x;
    pOut->_22 = YAxis.y;
    pOut->_32 = YAxis.z;
    pOut->_42 = -XGVec3Dot(&YAxis, pEye);

    pOut->_13 = ZAxis.x;
    pOut->_23 = ZAxis.y;
    pOut->_33 = ZAxis.z;
    pOut->_43 = -XGVec3Dot(&ZAxis, pEye);

    pOut->_14 = 0.0f;
    pOut->_24 = 0.0f;
    pOut->_34 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixPerspectiveRH
    ( XGMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f * zn / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixPerspectiveLH
    ( XGMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f * zn / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixPerspectiveFovRH
    ( XGMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = h / aspect;

    pOut->_11 = w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixPerspectiveFovLH
    ( XGMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = h / aspect;

    pOut->_11 = w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixPerspectiveOffCenterRH
    ( XGMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * zn * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = (l + r) * wInv;
    pOut->_32 = (t + b) * hInv;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixPerspectiveOffCenterLH
    ( XGMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * zn * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = -(l + r) * wInv;
    pOut->_32 = -(t + b) * hInv;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixOrthoRH
    ( XGMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zn - zf);
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixOrthoLH
    ( XGMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zf - zn);
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixOrthoOffCenterRH
    ( XGMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zn - zf);
    pOut->_34 = 0.0f;

    pOut->_41 = -(l + r) * wInv;
    pOut->_42 = -(t + b) * hInv;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixOrthoOffCenterLH
    ( XGMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zf - zn);
    pOut->_34 = 0.0f;

    pOut->_41 = -(l + r) * wInv;
    pOut->_42 = -(t + b) * hInv;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

extern "C"
XGMATRIX* WINAPI XGMatrixShadow
    ( XGMATRIX *pOut, const XGVECTOR4 *pLight,
      const XGPLANE *pPlane )
{
#if DBG
    if(!pOut || !pLight || !pPlane)
        return NULL;
#endif

    XGPLANE p;
    XGPlaneNormalize(&p, pPlane);
    float dot = XGPlaneDot(&p, pLight);
    p = -p;

    pOut->_11 = p.a * pLight->x + dot;
    pOut->_21 = p.b * pLight->x;
    pOut->_31 = p.c * pLight->x;
    pOut->_41 = p.d * pLight->x;

    pOut->_12 = p.a * pLight->y;
    pOut->_22 = p.b * pLight->y + dot;
    pOut->_32 = p.c * pLight->y;
    pOut->_42 = p.d * pLight->y;

    pOut->_13 = p.a * pLight->z;
    pOut->_23 = p.b * pLight->z;
    pOut->_33 = p.c * pLight->z + dot;
    pOut->_43 = p.d * pLight->z;

    pOut->_14 = p.a * pLight->w;
    pOut->_24 = p.b * pLight->w;
    pOut->_34 = p.c * pLight->w;
    pOut->_44 = p.d * pLight->w + dot;

    return pOut;
}


extern "C"
XGMATRIX* WINAPI XGMatrixReflect
    ( XGMATRIX *pOut, const XGPLANE *pPlane )
{
#if DBG
    if(!pOut || !pPlane)
        return NULL;
#endif

    XGPLANE p;
    XGPlaneNormalize(&p, pPlane);

    float fa = -2.0f * p.a;
    float fb = -2.0f * p.b;
    float fc = -2.0f * p.c;

    pOut->_11 = fa * p.a + 1.0f;
    pOut->_12 = fb * p.a;
    pOut->_13 = fc * p.a;
    pOut->_14 = 0.0f;

    pOut->_21 = fa * p.b;
    pOut->_22 = fb * p.b + 1.0f;
    pOut->_23 = fc * p.b;
    pOut->_24 = 0.0f;

    pOut->_31 = fa * p.c;
    pOut->_32 = fb * p.c;
    pOut->_33 = fc * p.c + 1.0f;
    pOut->_34 = 0.0f;

    pOut->_41 = fa * p.d;
    pOut->_42 = fb * p.d;
    pOut->_43 = fc * p.d;
    pOut->_44 = 1.0f;

    return pOut;
}


//--------------------------
// Quaternion
//--------------------------

extern "C"
void WINAPI XGQuaternionToAxisAngle
    ( const XGQUATERNION *pQ, XGVECTOR3 *pAxis, float *pAngle )
{
#if DBG
    if(!pQ)
        return;
#endif

    // expects unit quaternions!
	// q = cos(A/2), sin(A/2) * v

    float lsq = XGQuaternionLengthSq(pQ);

    if(lsq > EPSILON * EPSILON)
    {
        if(pAxis)
        {
            float scale = 1.0f / sqrtf(lsq);
            pAxis->x = pQ->x * scale;
            pAxis->y = pQ->y * scale;
            pAxis->z = pQ->z * scale;
        }

        if(pAngle)
            *pAngle = 2.0f * acosf(pQ->w);

    }
    else
    {
        if(pAxis)
        {
            pAxis->x = 1.0;
            pAxis->y = 0.0;
            pAxis->z = 0.0;
        }

        if(pAngle)
            *pAngle = 0.0f;
    }
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionRotationMatrix
    ( XGQUATERNION *pOut, const XGMATRIX *pM)
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    float w2 = pM->_11 + pM->_22 + pM->_33; // 4w2 - 1

    if(w2 > 0.0f)
    {
        pOut->w = 0.5f * sqrtf(w2 + 1.0f);
        float wInv = 0.25f / pOut->w;

        pOut->x = (pM->_23 - pM->_32) * wInv; // 4xw / 4w
        pOut->y = (pM->_31 - pM->_13) * wInv; // 4yw / 4w
        pOut->z = (pM->_12 - pM->_21) * wInv; // 4zw / 4w
    }
    else
    {
        const UINT next[3] = { 1, 2, 0 };
        float *pf = (float *) pOut;
        float n2[3];
        UINT i, j, k;

        n2[0] =   pM->_11 - pM->_22 - pM->_33; // 4x2 - 1
        n2[1] = - pM->_11 + pM->_22 - pM->_33; // 4y2 - 1
        n2[2] = - pM->_11 - pM->_22 + pM->_33; // 4z2 - 1

        i = (n2[0] >= n2[1]) ? 0 : 1;
        i = (n2[i] >= n2[2]) ? i : 2;

        j = next[i];
        k = next[j];

        pf[i] = 0.5f * sqrtf(n2[i] + 1.0f); // x
        float nInv = 0.25f / pf[i];

        pf[j] = (pM->m[i][j] + pM->m[j][i]) * nInv; // 4yx / 4x
        pf[k] = (pM->m[k][i] + pM->m[i][k]) * nInv; // 4zx / 4x
        pf[3] = (pM->m[j][k] - pM->m[k][j]) * nInv; // 4wz / 4x
    }

    return pOut;
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionRotationAxis
    ( XGQUATERNION *pOut, const XGVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    XGVECTOR3 v;
    XGVec3Normalize(&v, pV);

    float s;
    sincosf(0.5f * angle, &s, &pOut->w);

    pOut->x = v.x * s;
    pOut->y = v.y * s;
    pOut->z = v.z * s;

    return pOut;
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionRotationYawPitchRoll
    ( XGQUATERNION *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    //  Roll first, about axis the object is facing, then
    //  pitch upward, then yaw to face into the new heading

    float SR, CR, SP, CP, SY, CY;

    sincosf(0.5f * roll,  &SR, &CR);
    sincosf(0.5f * pitch, &SP, &CP);
    sincosf(0.5f * yaw,   &SY, &CY);

    pOut->x = CY*SP*CR + SY*CP*SR;
    pOut->y = SY*CP*CR - CY*SP*SR;
    pOut->z = CY*CP*SR - SY*SP*CR;
    pOut->w = CY*CP*CR + SY*SP*SR;

    return pOut;
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionMultiply
    ( XGQUATERNION *pOut, const XGQUATERNION *pQ1,
      const XGQUATERNION *pQ2 )
{
    const UINT n = 0x80000000; 

#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif

    __asm {
        movss   xmm0, [n]
        mov     ecx, pQ1
        movups  xmm1, [ecx]
        mov     edx, pQ2

        movaps  xmm3, xmm1
        movss   xmm2, [edx+12]
        shufps  xmm2, xmm2, 0
        mulps   xmm3, xmm2

        shufps  xmm0, xmm0, 0x11
        movaps  xmm4, xmm1
        shufps  xmm4, xmm4, 0x1B
        movss   xmm2, [edx]
        shufps  xmm2, xmm2, 0
        mulps   xmm4, xmm2
        xorps   xmm4, xmm0
        addps   xmm3, xmm4

        shufps  xmm0, xmm0, 0x50
        movaps  xmm4, xmm1
        shufps  xmm4, xmm4, 0x4E
        movss   xmm2, [edx+4]
        shufps  xmm2, xmm2, 0
        mulps   xmm4, xmm2
        xorps   xmm4, xmm0
        addps   xmm3, xmm4
        
        shufps  xmm0, xmm0, 0x82
        movaps  xmm4, xmm1
        shufps  xmm4, xmm4, 0xB1
        movss   xmm2, [edx+8]
        shufps  xmm2, xmm2, 0
        mulps   xmm4, xmm2
        xorps   xmm4, xmm0
        addps   xmm3, xmm4

        mov     eax, pOut
        movups  [eax], xmm3
    }
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionNormalize
    ( XGQUATERNION *pOut, const XGQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = XGQuaternionLengthSq(pQ);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pQ)
            *pOut = *pQ;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pQ / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionInverse
    ( XGQUATERNION *pOut, const XGQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = XGQuaternionLengthSq(pQ);

    if(f > EPSILON*EPSILON)
    {
        XGQuaternionConjugate(pOut, pQ);

        if(!WithinEpsilon(f, 1.0f))
            *pOut /= f;
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionLn
    ( XGQUATERNION *pOut, const XGQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects unit quaternions!
    // q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)

    float theta, s;

    if(pQ->w < 1.0f)
    {
        theta = acosf(pQ->w);
        s = sinf(theta);

        if(!WithinEpsilon(s, 0.0f))
        {
            float scale = theta / s;
            pOut->x = pQ->x * scale;
            pOut->y = pQ->y * scale;
            pOut->z = pQ->z * scale;
            pOut->w = 0.0f;
        }
        else
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
            pOut->w = 0.0f;
        }
    }
    else
    {
        pOut->x = pQ->x;
        pOut->y = pQ->y;
        pOut->z = pQ->z;
        pOut->w = 0.0f;
    }

    return pOut;
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionExp
    ( XGQUATERNION *pOut, const XGQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects pure quaternions! (w == 0)
    // q = (0, theta * v) ; exp(q) = (cos(theta), sin(theta) * v)

    float theta, s;

    theta = sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z);
    sincosf(theta, &s, &pOut->w);

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ)
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
        }
    }
    else
    {
        s /= theta;

        pOut->x = pQ->x * s;
        pOut->y = pQ->y * s;
        pOut->z = pQ->z * s;
    }

    return pOut;
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionSlerp
    ( XGQUATERNION *pOut, const XGQUATERNION *pQ1,
      const XGQUATERNION *pQ2, float b )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif

    // expects unit quaternions!
    float a, c, flip, s, omega, sInv;

    a = 1.0f - b;
    c = XGQuaternionDot(pQ1, pQ2);
    flip = (c >= 0.0f) ? 1.0f : -1.0f;
    c *= flip;

	if(1.0f - c > EPSILON) {
        s = sqrtf(1.0f - c * c);
 		omega = atan2f(s, c);
 		sInv = 1.0f / s;

 		a = sinf(a * omega) * sInv;
 		b = sinf(b * omega) * sInv;
 	}

    b *= flip;

    __asm {
        movss   xmm0, a
        shufps  xmm0, xmm0, 0
        mov     edx, pQ1
        movups  xmm1, [edx]
        mulps   xmm1, xmm0

        movss   xmm0, b
        shufps  xmm0, xmm0, 0
        mov     edx, pQ2
        movups  xmm2, [edx]
        mulps   xmm2, xmm0

        addps   xmm1, xmm2

        mov     eax, pOut
        movups  [eax], xmm1
    }
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionSquad
    ( XGQUATERNION *pOut, const XGQUATERNION *pQ1,
      const XGQUATERNION *pQ2, const XGQUATERNION *pQ3,
      const XGQUATERNION *pQ4, float t )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3 || !pQ4)
        return NULL;
#endif

    // expects unit quaternions!
    XGQUATERNION QA, QB;

    XGQuaternionSlerp(&QA, pQ1, pQ4, t);
    XGQuaternionSlerp(&QB, pQ2, pQ3, t);
    XGQuaternionSlerp(pOut, &QA, &QB, 2.0f * t * (1.0f - t));

    return pOut;
}

extern "C"
XGQUATERNION* WINAPI XGQuaternionBaryCentric
    ( XGQUATERNION *pOut, const XGQUATERNION *pQ1,
      const XGQUATERNION *pQ2, const XGQUATERNION *pQ3,
      float f, float g )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3)
        return NULL;
#endif

    // expects unit quaternions!
    XGQUATERNION QA, QB;
    float s = f + g;

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ1)
            *pOut = *pQ1;
    }
    else
    {
        XGQuaternionSlerp(&QA, pQ1, pQ2, s);
        XGQuaternionSlerp(&QB, pQ1, pQ3, s);
        XGQuaternionSlerp(pOut, &QA, &QB, g / s);
    }

    return pOut;
}

//--------------------------
// Plane
//--------------------------

extern "C"
XGPLANE* WINAPI XGPlaneNormalize
    ( XGPLANE *pOut, const XGPLANE *pP )
{
#if DBG
    if(!pOut || !pP)
        return NULL;
#endif

    float f = pP->a * pP->a + pP->b * pP->b + pP->c * pP->c;

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pP)
            *pOut = *pP;
    }
    else if(f > EPSILON * EPSILON)
    {
        float fInv = 1.0f / sqrtf(f);

        pOut->a = pP->a * fInv;
        pOut->b = pP->b * fInv;
        pOut->c = pP->c * fInv;
        pOut->d = pP->d * fInv;
    }
    else
    {
        pOut->a = 0.0f;
        pOut->b = 0.0f;
        pOut->c = 0.0f;
        pOut->d = 0.0f;
    }

    return pOut;
}

extern "C"
XGVECTOR3* WINAPI XGPlaneIntersectLine
    ( XGVECTOR3 *pOut, const XGPLANE *pP, const XGVECTOR3 *pV1,
      const XGVECTOR3 *pV2)
{
#if DBG
    if(!pOut || !pP || !pV1 || !pV2)
        return NULL;
#endif

    float d =  XGPlaneDotNormal(pP, pV1) - XGPlaneDotNormal(pP, pV2);

    if(d == 0.0f)
        return NULL;

    float f = XGPlaneDotCoord(pP, pV1) / d;

    if(!_finite(f))
        return NULL;

    XGVec3Lerp(pOut, pV1, pV2, f);
    return pOut;
}

extern "C"
XGPLANE* WINAPI XGPlaneFromPointNormal
    ( XGPLANE *pOut, const XGVECTOR3 *pPoint, const XGVECTOR3 *pNormal)
{
#if DBG
    if(!pOut || !pPoint || !pNormal)
        return NULL;
#endif

    pOut->a = pNormal->x;
    pOut->b = pNormal->y;
    pOut->c = pNormal->z;
    pOut->d = -XGVec3Dot(pPoint, pNormal);
    return pOut;
}

extern "C"
XGPLANE* WINAPI XGPlaneFromPoints
    ( XGPLANE *pOut, const XGVECTOR3 *pV1, const XGVECTOR3 *pV2,
      const XGVECTOR3 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    XGVECTOR3 V12 = *pV1 - *pV2;
    XGVECTOR3 V13 = *pV1 - *pV3;

    XGVec3Cross((XGVECTOR3 *) pOut, &V12, &V13);
    XGVec3Normalize((XGVECTOR3 *) pOut, (XGVECTOR3 *) pOut);

    pOut->d = -XGPlaneDotNormal(pOut, pV1);
    return pOut;
}

extern "C"
XGPLANE* WINAPI XGPlaneTransform
    ( XGPLANE *pOut, const XGPLANE *pP, const XGMATRIX *pM )
{
#if DBG
    if(!pOut || !pP || !pM)
        return NULL;
#endif

    XGPLANE P;
    XGPlaneNormalize(&P, pP);

    XGVECTOR3 V(-P.a * P.d, -P.b * P.d, -P.c * P.d);
    XGVec3TransformCoord(&V, &V, pM);

    XGVec3TransformNormal((XGVECTOR3 *) pOut, (const XGVECTOR3 *) &P, pM);
    XGVec3Normalize((XGVECTOR3 *) pOut, (const XGVECTOR3 *) pOut);

    pOut->d = -XGPlaneDotNormal(pOut, &V);
    return pOut;
}


//--------------------------
// Color
//--------------------------

extern "C"
XGCOLOR* WINAPI XGColorAdjustSaturation
    (XGCOLOR *pOut, const XGCOLOR *pC, float s)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    // Approximate values for each component's contribution to luminance.
    // (Based upon the NTSC standard described in the comp.graphics.algorithms
    // colorspace FAQ)
    float grey = pC->r * 0.2125f + pC->g * 0.7154f + pC->b * 0.0721f;

    pOut->r = grey + s * (pC->r - grey);
    pOut->g = grey + s * (pC->g - grey);
    pOut->b = grey + s * (pC->b - grey);
    pOut->a = pC->a;
    return pOut;
}

extern "C"
XGCOLOR* WINAPI XGColorAdjustContrast
    (XGCOLOR *pOut, const XGCOLOR *pC, float c)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 0.5f + c * (pC->r - 0.5f);
    pOut->g = 0.5f + c * (pC->g - 0.5f);
    pOut->b = 0.5f + c * (pC->b - 0.5f);
    pOut->a = pC->a;
    return pOut;
}

#pragma warning(default:4035)

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\misc\debug.cpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.cpp
 *  Content:    implementation for debug stuff.
 *
 ***************************************************************************/

#if XBOX
#include "xgrphseg.h"
#include "xtl.h"
#else
#include "windows.h"
#include "d3d8-xbox.h"
#endif

#include "stdio.h"
#include "xgraphics.h"
#include "debug.h"

namespace XGRAPHICS
{

#if DBG

VOID DXGRIP(PCHAR Format, ...)
{
    CHAR string[MAX_PATH];
    va_list arglist;

    va_start(arglist, Format);
    _vsnprintf(string, sizeof(string), Format, arglist);
    va_end(arglist);

#if XBOX
    XDebugError("D3D", string);
#else
    OutputDebugStringA(string);
    __asm int 3;
#endif
}

void DPF3(const char* message, va_list list)
{
    char buf[500];
    _vsnprintf(buf, sizeof(buf)-1, message, list);
    buf[sizeof(buf)-1] = '\0';
    OutputDebugStringA(buf);
    Sleep(1);
}

void DPF2(const char* message,...)
{
	va_list list;
	va_start(list, message );
	DPF3(message, list);
	va_end(list);
}

void DPF(int level,const char* message,...)
{
    va_list list;
    va_start(list, message );
    DPF3(message, list);
    va_end(list);
}

#endif

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\misc\header.h ===
namespace XGRAPHICS
{

#define FMT_RENDERTARGET 0x80
#define FMT_DEPTHBUFFER 0x40
#define FMT_BITSPERPIXEL 0x3c
#define FMT_LINEAR 0x02
#define FMT_SWIZZLED 0x01

#define FMT_32BPP 0x20
#define FMT_16BPP 0x10
#define FMT_8BPP 0x08
#define FMT_4BPP 0x04

D3DCONST BYTE g_TextureFormat[] =
{
    FMT_8BPP  |                    FMT_SWIZZLED,  // 0x00 D3DFMT_L8                   
    FMT_8BPP  |                    FMT_SWIZZLED,  // 0x01 D3DFMT_AL8                  
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x02 D3DFMT_A1R5G5B5             
    FMT_16BPP | FMT_RENDERTARGET | FMT_SWIZZLED,  // 0x03 D3DFMT_X1R5G5B5             
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x04 D3DFMT_A4R4G4B4             
    FMT_16BPP | FMT_RENDERTARGET | FMT_SWIZZLED,  // 0x05 D3DFMT_R5G6B5               
    FMT_32BPP | FMT_RENDERTARGET | FMT_SWIZZLED,  // 0x06 D3DFMT_A8R8G8B8             
    FMT_32BPP | FMT_RENDERTARGET | FMT_SWIZZLED,  // 0x07 D3DFMT_X8R8G8B8/D3DFMT_X8L8V8U8
    0,                                            // 0x08
    0,                                            // 0x09
    0,                                            // 0x0A
    FMT_8BPP  |                    FMT_SWIZZLED,  // 0x0B D3DFMT_P8                   
    FMT_4BPP,                                     // 0x0C D3DFMT_DXT1                 
    0,                                            // 0x0D
    FMT_8BPP,                                     // 0x0E D3DFMT_DXT2/D3DFMT_DXT3
    FMT_8BPP,                                     // 0x0F D3DFMT_DXT4/D3DFMT_DXT5
    FMT_16BPP |                    FMT_LINEAR,    // 0x10 D3DFMT_LIN_A1R5G5B5         
    FMT_16BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x11 D3DFMT_LIN_R5G6B5           
    FMT_32BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x12 D3DFMT_LIN_A8R8G8B8         
    FMT_8BPP  |                    FMT_LINEAR,    // 0x13 D3DFMT_LIN_L8               
    0,                                            // 0x14
    0,                                            // 0x15
    FMT_16BPP |                    FMT_LINEAR,    // 0x16 D3DFMT_LIN_R8B8             
    FMT_16BPP |                    FMT_LINEAR,    // 0x17 D3DFMT_LIN_G8B8             
    0,                                            // 0x18
    FMT_8BPP  |                    FMT_SWIZZLED,  // 0x19 D3DFMT_A8                   
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x1A D3DFMT_A8L8                 
    FMT_8BPP  |                    FMT_LINEAR,    // 0x1B D3DFMT_LIN_AL8              
    FMT_16BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x1C D3DFMT_LIN_X1R5G5B5         
    FMT_16BPP |                    FMT_LINEAR,    // 0x1D D3DFMT_LIN_A4R4G4B4         
    FMT_32BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x1E D3DFMT_LIN_X8R8G8B8         
    FMT_8BPP  |                    FMT_LINEAR,    // 0x1F D3DFMT_LIN_A8               
    FMT_16BPP |                    FMT_LINEAR,    // 0x20 D3DFMT_LIN_A8L8             
    0,                                            // 0x21
    0,                                            // 0x22
    0,                                            // 0x23
    FMT_32BPP,                                    // 0x24 D3DFMT_UYVY                 
    FMT_32BPP,                                    // 0x25 D3DFMT_YUY2                 
    0,                                            // 0x26
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x27 D3DFMT_R6G5B5/D3DFMT_L6V5U5
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x28 D3DFMT_G8B8/D3DFMT_V8U8
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x29 D3DFMT_R8B8                 
    FMT_32BPP | FMT_DEPTHBUFFER |  FMT_SWIZZLED,  // 0x2A D3DFMT_D24S8                
    FMT_32BPP | FMT_DEPTHBUFFER |  FMT_SWIZZLED,  // 0x2B D3DFMT_F24S8                
    FMT_16BPP | FMT_DEPTHBUFFER |  FMT_SWIZZLED,  // 0x2C D3DFMT_D16_LOCKABLE/D3DFMT_D16
    FMT_16BPP | FMT_DEPTHBUFFER |  FMT_SWIZZLED,  // 0x2D D3DFMT_F16                  
    FMT_32BPP | FMT_DEPTHBUFFER |  FMT_LINEAR,    // 0x2E D3DFMT_LIN_D24S8            
    FMT_32BPP | FMT_DEPTHBUFFER |  FMT_LINEAR,    // 0x2F D3DFMT_LIN_F24S8            
    FMT_16BPP | FMT_DEPTHBUFFER |  FMT_LINEAR,    // 0x30 D3DFMT_LIN_D16              
    FMT_16BPP | FMT_DEPTHBUFFER |  FMT_LINEAR,    // 0x31 D3DFMT_LIN_F16              
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x32 D3DFMT_L16                  
    FMT_32BPP |                    FMT_SWIZZLED,  // 0x33 D3DFMT_V16U16               
    0,                                            // 0x34
    FMT_16BPP |                    FMT_LINEAR,    // 0x35 D3DFMT_LIN_L16              
    0,                                            // 0x36
    FMT_16BPP |                    FMT_LINEAR,    // 0x37 D3DFMT_LIN_R6G5B5           
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x38 D3DFMT_R5G5B5A1             
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x39 D3DFMT_R4G4B4A4             
    FMT_32BPP |                    FMT_SWIZZLED,  // 0x3A D3DFMT_A8B8G8R8/D3DFMT_Q8W8V8U8             
    FMT_32BPP |                    FMT_SWIZZLED,  // 0x3B D3DFMT_B8G8R8A8             
    FMT_32BPP |                    FMT_SWIZZLED,  // 0x3C D3DFMT_R8G8B8A8             
    FMT_16BPP |                    FMT_LINEAR,    // 0x3D D3DFMT_LIN_R5G5B5A1         
    FMT_16BPP |                    FMT_LINEAR,    // 0x3E D3DFMT_LIN_R4G4B4A4         
    FMT_32BPP |                    FMT_LINEAR,    // 0x3F D3DFMT_LIN_A8B8G8R8         
    FMT_32BPP |                    FMT_LINEAR,    // 0x40 D3DFMT_LIN_B8G8R8A8         
    FMT_32BPP |                    FMT_LINEAR,    // 0x41 D3DFMT_LIN_R8G8B8A8         
};

inline bool IsSwizzledD3DFORMAT(
    D3DFORMAT Format
    )
{
    return g_TextureFormat[Format] & FMT_SWIZZLED;
}

inline bool IsCompressedD3DFORMAT(
    DWORD Format
    )
{
    switch(Format)
    {
    case D3DFMT_DXT1:
    case D3DFMT_DXT2:  // DXT3
    case D3DFMT_DXT4:  // DXT4
        return true;
    }

    return false;
}

inline BOOL IsValidDepthBufferD3DFORMAT(
    DWORD Format
    )
{
    return g_TextureFormat[Format] & FMT_DEPTHBUFFER;
}

inline DWORD BitsPerPixelOfD3DFORMAT(
    DWORD Format
    )
{
    return g_TextureFormat[Format] & FMT_BITSPERPIXEL;
}

#pragma warning (disable: 4035)
inline DWORD __fastcall Log2(
    DWORD Value
    )
{
    __asm { bsf eax,[Value] }
}
#pragma warning (default: 4035)

inline DWORD MinimumTextureSizeOfD3DFORMAT(
    DWORD Format
    )
{
    return IsCompressedD3DFORMAT(Format) ? 2 : 0;
}

inline DWORD CalcPitch(
    DWORD Width,
    DWORD TexelSize
    )
{
    return (Width * TexelSize / 8 + D3DTEXTURE_PITCH_ALIGNMENT - 1) &
            ~(D3DTEXTURE_PITCH_ALIGNMENT - 1);
}

inline DWORD PitchFromSize(
    DWORD Size
    )
{
    return (((Size & D3DSIZE_PITCH_MASK) >> D3DSIZE_PITCH_SHIFT) + 1) * D3DTEXTURE_PITCH_ALIGNMENT;
}

//------------------------------------------------------------------------------
// Encodes the Format and Size parameters for a surface and returns the number
// of bytes required to the data for the surface.  
//
DWORD EncodeFormat(
    DWORD Width,
    DWORD Height,
    DWORD Depth,
    DWORD Levels,
    D3DFORMAT D3DFormat,
    DWORD Pitch,
    bool isCubeMap,  
    bool isVolume,
    DWORD *pFormat,
    DWORD *pSize
    );

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\misc\writexpr.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       writexpr.cpp
 *  Content:    Utility function to dump a single texture or surface to 
 *              a packed resource file (.xpr)
 *
 ****************************************************************************/

#if XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8-xbox.h>
#endif

#include <stdio.h>
#include <xgraphics.h>
#include <debug.h>
#include "header.h"

namespace XGRAPHICS
{

#define AGP_FRAME_BUFFER_HIGH_NIBBLE    0xF0000000

extern "C"
HRESULT 
WINAPI XGWriteSurfaceOrTextureToXPR(IDirect3DResource8 *pResource, 
                                    const char *cPath, 
                                    BOOL bWriteSurfaceAsTexture)
{
    DWORD temp, Type, Width, Height, Depth, Levels, Pitch, Dimension;
    D3DFORMAT Format;
    bool isInVideoMemory, isCubeMap, isVolume;
    D3DPixelContainer *pContainer = (D3DPixelContainer *)pResource;
    BYTE chunk[2048];   // used to write a chunk of the image

    // check for proper resource type
    Type = pContainer->Common & D3DCOMMON_TYPE_MASK;
    if((Type != D3DCOMMON_TYPE_TEXTURE) && (Type != D3DCOMMON_TYPE_SURFACE))
    {
        DXGRIP("ERROR: Invalid resource type in XGWriteSurfaceOrTextureToXPR\n");
        return E_FAIL;
    }

    Format = (D3DFORMAT)(((pContainer->Format) & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT);
    Dimension = ((pContainer->Format) & D3DFORMAT_DIMENSION_MASK) >> D3DFORMAT_DIMENSION_SHIFT;
    if((pContainer->Format) & D3DFORMAT_CUBEMAP)
        isCubeMap = TRUE;
    else
        isCubeMap = FALSE;

    if((Dimension == 3) && !isCubeMap)
        isVolume = TRUE;
    else
        isVolume = FALSE;
    
    isInVideoMemory = TRUE;

    DWORD dwBytesPerPixel = (g_TextureFormat[Format] & FMT_BITSPERPIXEL)/8;
    
    if(pContainer->Size == 0)
    {
        // swizzled texture or surface
        Levels = ((pContainer->Format) & D3DFORMAT_MIPMAP_MASK) >> D3DFORMAT_MIPMAP_SHIFT;
        Width  = 1 << ((pContainer->Format & D3DFORMAT_USIZE_MASK) >> D3DFORMAT_USIZE_SHIFT);
        Height = 1 << ((pContainer->Format & D3DFORMAT_VSIZE_MASK) >> D3DFORMAT_VSIZE_SHIFT);
        Depth  = 1 << ((pContainer->Format & D3DFORMAT_PSIZE_MASK) >> D3DFORMAT_PSIZE_SHIFT);
    }
    else
    {
        // linear texture or surface
        Levels = 1;
        Width = ((pContainer->Size) & D3DSIZE_WIDTH_MASK) + 1;
        Height = (((pContainer->Size) & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1;
        Depth = 1;
    }
    Pitch = 0;
    
    int dwResourceBytes = EncodeFormat(Width, 
                                       Height, 
                                       Depth, 
                                       Levels, 
                                       Format, 
                                       Pitch, 
                                       isCubeMap, 
                                       isVolume, 
                                       &temp, 
                                       &temp);
    
    // open the file and write out the data
    DWORD BytesWritten;
    
    HANDLE hFile = INVALID_HANDLE_VALUE;

    hFile = CreateFile(cPath,
                       GENERIC_WRITE, 
                       0, 
                       NULL, 
                       CREATE_ALWAYS, 
                       0, 
                       NULL);

    if(INVALID_HANDLE_VALUE == hFile)
    {
        char buf[256];
        sprintf(buf, "Unable to open file (%s):  error %x\n", cPath, GetLastError());
        DXGRIP(buf);
        return E_FAIL;
    }
    
    DWORD dwVal;

    // write the xpr header
    XPR_HEADER xprh;
    xprh.dwMagic = XPR_MAGIC_VALUE;
    xprh.dwTotalSize = dwResourceBytes + 2048;
    xprh.dwHeaderSize = 2048;

    WriteFile(hFile, &xprh, 3*sizeof(DWORD), &BytesWritten, NULL);
    
    DWORD Common = pContainer->Common;
    if((Type == D3DCOMMON_TYPE_SURFACE) && bWriteSurfaceAsTexture)
    {
        // clear type bits
        Common &= ~D3DCOMMON_TYPE_MASK;
        // set type as texture
        Common |= D3DCOMMON_TYPE_TEXTURE;
    }
    // clear the D3DCREATED bit
    Common &= ~D3DCOMMON_D3DCREATED;
    // write common field
    WriteFile(hFile, &Common, sizeof(DWORD), &BytesWritten, NULL);
    
    // write data field
    dwVal = 0;
    WriteFile(hFile, &dwVal, sizeof(DWORD), &BytesWritten, NULL);

    // write lock field
    dwVal = 1;
    WriteFile(hFile, &dwVal, sizeof(DWORD), &BytesWritten, NULL);
    
    // write Format and Size fields
    WriteFile(hFile, &(pContainer->Format), 2*sizeof(DWORD), &BytesWritten, NULL);

    // construct a virtual address pointer to the bits
    BYTE *pBits;
    D3DLOCKED_RECT lr;
    ((IDirect3DSurface8 *)pResource)->LockRect(&lr, NULL, D3DLOCK_TILED);
    pBits = (BYTE *)lr.pBits;

    if((Type == D3DCOMMON_TYPE_TEXTURE) || bWriteSurfaceAsTexture)
    {
        // write end-of-resources marker
        dwVal = 0xffffffff;
        WriteFile(hFile, &dwVal, sizeof(DWORD), &BytesWritten, NULL);
        // pad header to 2048
        WriteFile(hFile, chunk, 2048-9*sizeof(DWORD), &BytesWritten, NULL);
    }
    else
    {
        // write parent field
        dwVal = 0;
        WriteFile(hFile, &dwVal, sizeof(DWORD), &BytesWritten, NULL);
        // write end-of-resources marker
        dwVal = 0xffffffff;
        WriteFile(hFile, &dwVal, sizeof(DWORD), &BytesWritten, NULL);
        // pad header to 2048
        WriteFile(hFile, chunk, 2048-10*sizeof(DWORD), &BytesWritten, NULL);
    }
    while(dwResourceBytes > 0)
    {
        DWORD chunksize;
        chunksize = min(2048, dwResourceBytes);
        memcpy(chunk, pBits, chunksize);
        WriteFile(hFile, chunk, chunksize, &BytesWritten, NULL);
        dwResourceBytes -= chunksize;
        pBits += chunksize;
    }
    ((IDirect3DSurface8 *)pResource)->UnlockRect(); // finished with bits
    
    CloseHandle(hFile); // finished writing resource


    return S_OK;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\pushbuffer\sources.inc ===
MAJORCOMP=directx
MINORCOMP=d3d

TARGETNAME=pushbuffer$(D)

TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES);..\..\inc

SOURCES=\
    pushbuffer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\cd3dxstack.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       stacks.cpp
//  Content:    Stacks
//
///////////////////////////////////////////////////////////////////////////

#include "pchshadeasm.h"

namespace XGRAPHICS {

//----------------------------------------------------------------------------
// XAsmCD3DXDwStack - DWORD stack
//----------------------------------------------------------------------------


XAsmCD3DXDwStack::XAsmCD3DXDwStack()
{
    m_pdw = NULL;
    m_cdw = 0;
    m_cdwLim = 0;
    m_hr = S_OK;
}

XAsmCD3DXDwStack::~XAsmCD3DXDwStack()
{
    if(m_pdw)
        delete [] m_pdw;
}

HRESULT
XAsmCD3DXDwStack::Push(DWORD dw)
{
    if(m_cdw == m_cdwLim)
    {
        DWORD *pdw;
        
        if(!(pdw = new DWORD[m_cdwLim + 16]))
            return m_hr = E_OUTOFMEMORY;

        if(m_pdw)
        {
            memcpy(pdw, m_pdw, m_cdw * sizeof(DWORD));
            delete [] m_pdw;
        }

        m_pdw = pdw;
        m_cdwLim += 16;
    }

    m_pdw[m_cdw++] = dw;
    return S_OK;
}

HRESULT
XAsmCD3DXDwStack::Pop(DWORD *pdw)
{
    if(m_cdw == 0)
    {
        if(pdw)
            *pdw = 0;
		DXGRIP("Stack Empty");
        return m_hr = E_FAIL;
    }

    m_cdw--;

    if(pdw)
        *pdw = m_pdw[m_cdw];

    return S_OK;
}

HRESULT
XAsmCD3DXDwStack::GetLastError()
{
    HRESULT hr = m_hr;
    m_hr = S_OK;
    return hr;
}


//----------------------------------------------------------------------------
// XAsmCD3DXSzStack - String stack
//----------------------------------------------------------------------------

XAsmCD3DXSzStack::XAsmCD3DXSzStack()
{
    m_ppsz = NULL;
    m_cpsz = 0;
    m_cpszLim = 0;
    m_hr = S_OK;
}

XAsmCD3DXSzStack::~XAsmCD3DXSzStack()
{
    if(m_ppsz)
    {
        for(UINT ipsz = 0; ipsz < m_cpsz; ipsz++)
        {
            if(m_ppsz[ipsz])
                delete [] m_ppsz[ipsz];
        }

        delete [] m_ppsz;
    }
}

HRESULT
XAsmCD3DXSzStack::Push(char *psz)
{
    if(m_cpsz == m_cpszLim)
    {
        char **ppsz;
        
        if(!(ppsz = new char* [m_cpszLim + 16]))
            return m_hr = E_OUTOFMEMORY;

        if(m_ppsz)
        {
            memcpy(ppsz, m_ppsz, m_cpsz * sizeof(char *));
            delete [] m_ppsz;
        }

        m_ppsz = ppsz;
        m_cpszLim += 16;
    }

    if(psz)
    {
        UINT cch;
        char *pszCopy;

        cch = strlen(psz);

        if(!(pszCopy = new char[cch + 1]))
            return m_hr = E_OUTOFMEMORY;

        memcpy(pszCopy, psz, cch * sizeof(char));
        pszCopy[cch] = 0;

        m_ppsz[m_cpsz++] = pszCopy;
    }
    else
    {
        m_ppsz[m_cpsz++] = NULL;
    }

    return S_OK;
}

HRESULT
XAsmCD3DXSzStack::Pop(char **ppsz)
{
    if(m_cpsz == 0)
    {
        if(ppsz)
            *ppsz = NULL;

        DXGRIP("Stack Empty");
        return m_hr = E_FAIL;
    }

    m_cpsz--;

    if(ppsz)
        *ppsz = m_ppsz[m_cpsz];

    return S_OK;
}

HRESULT
XAsmCD3DXSzStack::GetLastError()
{
    HRESULT hr = m_hr;
    m_hr = S_OK;
    return hr;
}

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\cd3dxassembler.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////

#include "pchshadeasm.h"

// #include "d3dhal.h"

namespace XGRAPHICS {

	inline int Isspace(int ch) {
        return isspace(ch) || ch == '\x1a';
	}

enum
{
    P_SHADER_0,
    P_SHADER_1,
    P_SHADER_2,
    P_SHADER_3,
    P_VERSION_0,
    P_VERSION_1,
    P_VERSION_XVS,
    P_VERSION_XVSW,
    P_VERSION_XVSS,
    P_VERSION_XPS,
    P_BODY_0,
    P_BODY_1,
    P_CONSTANTS_0,
    P_CONSTANTS_1,
    P_CONSTANT_0,
    P_STATEMENTS_0,
    P_STATEMENTS_1,
    P_STATEMENT_0,
    P_STATEMENT_1,
    P_STATEMENT_2,
    P_STATEMENT_3,
    P_STATEMENT_4,
    P_STATEMENT_5,
    P_STATEMENT_6,
    P_STATEMENT_7,
    P_DST_0,
    P_DST_1,
    P_SRC_0,
    P_SRC_1,
    P_SRC_2,
    P_SRC2_0,
    P_SRC2_1,
    P_REG_0,
    P_REG_1,
    P_REG_2,
    P_OFFSET_0,
    P_OFFSET_1,
    P_OFFSET_2,
    P_OFFSET_3,
    P_OFFSET_4,
    P_OFFSET_5,
    P_OFFSET_6,
    P_OFFSET_7,
    P_OFFSET_8,
    P_OFFSET_9,
    P_OFFSET_10,
    P_OFFSET_11,
    P_OP0_0,
    P_OP0_1,
    P_OP1_0,
    P_OP1_1,
    P_OP2_0,
    P_OP2_1,
    P_OP3_0,
    P_OP3_1,
    P_OP4_0,
    P_OP4_1,
    P_OP5_0,
    P_OP5_1,
    P_OP6_0,
    P_OP6_1,
    P_OP7_0,
    P_OP7_1,
    P_VAL_0,
    P_VAL_1,
    P_VAL_2,
    P_VAL_3,
    P_VAL_4,
    P_VAL_5,
    P_ID,
    P_NUM,
    P_FLT
};

#define Prod(n) \
    CD3DXAssembler::s_pAsm->Production(n)

#define d3dxasm_lex \
    CD3DXAssembler::s_pAsm->Token

#define d3dxasm_error \
    CD3DXAssembler::s_pAsm->YYError

#define lint
#pragma warning(disable : 4242)
#include "shadeasm.h"
#pragma warning(default : 4242)

#define FOURCC_LINE  MAKEFOURCC('L', 'I', 'N', 'E')
#define FOURCC_FILE  MAKEFOURCC('F', 'I', 'L', 'E')
#define FOURCC_TEXT  MAKEFOURCC('T', 'E', 'X', 'T')



//----------------------------------------------------------------------------
// CD3DXAssembler
//----------------------------------------------------------------------------

#define SHADER_VALIDATOR_LOG_ERRORS  0x1

#if 0
typedef HRESULT (WINAPI* LPVALIDATEPIXELSHADER)(DWORD*, D3DCAPS8*, DWORD, char**);
typedef HRESULT (WINAPI* LPVALIDATEVERTEXSHADER)(DWORD*, DWORD*, D3DCAPS8*, DWORD, char**);
#endif

CD3DXAssembler* CD3DXAssembler::s_pAsm = NULL;


CD3DXAssembler::CD3DXAssembler()
{
    s_pAsm = this;

    m_bFail  = FALSE;
    m_cbConst = 0;
    m_cbCode = 0;
	m_pErrorLog = 0;
}


CD3DXAssembler::~CD3DXAssembler()
{
}


HRESULT
CD3DXAssembler::Assemble(LPCVOID pv, UINT cb, LPCSTR pszFile, UINT iLine,
    DWORD dwFlags, LPXGBUFFER *ppConst, LPXGBUFFER *ppCode,
    XD3DXErrorLog* pErrorLog, LPDWORD pShaderType)
{
    HRESULT hr;

    XGBuffer *pConst;
    XGBuffer *pCode;

	m_pErrorLog = pErrorLog;

    if(ppConst)
        *ppConst = NULL;

    if(ppCode)
        *ppCode = NULL;

    if(!pv || !cb)
    {
        DPF(0, "Could not read data from source");
        return D3DERR_INVALIDCALL;
    }

    m_pchSource = (char *) pv;
    m_pchLine   = m_pchSource;
    m_pch       = m_pchSource;
    m_pchLim    = m_pchSource + cb;
    m_iLine     = iLine ? iLine : 1;
    m_iLineNextToken = m_iLine;

    m_bPixel    = FALSE;
    m_bDebug    = dwFlags != 0;
    m_bScreenSpace = FALSE;
    m_dwVersion = 0;


    if(pszFile)
    {
        strcpy(m_szFile, pszFile);
    }
    else
    {
        m_szFile[0] = 0;
        UpdateDebugText();
    }

    m_iLineDebug = 0;
    m_szFileDebug[0] = 0;



    if(yyparse())
        m_bFail = TRUE;




    // Constants
    if(!m_bFail && ppConst && !m_bPixel)
    {
        hr = XGBufferCreate(m_cbConst, &pConst);
		if(FAILED(hr)){
			return hr;
		}

        BYTE *pbConst = (BYTE *) pConst->GetBufferPointer();

        while(m_cbConst)
        {
            m_cbConst -= sizeof(DWORD);
            m_Const.Pop((DWORD *) (pbConst + m_cbConst));
        }

        *ppConst = pConst;
    }


    // Compiled code
    if(!m_bFail && ppCode)
    {
#ifdef WRITE_COMMENT
        const char szComment[] = "D3DX8 Shader Assembler Version 0.91";
        UINT cdwComment = (sizeof(szComment) + 3) >> 2;
        UINT cbComment = cdwComment << 2;

        UINT cbObj = 3 * sizeof(DWORD) + m_cbCode + cbComment;
#else
		UINT cbObj = 2 * sizeof(DWORD) + m_cbCode; // Version, code, end
#endif

        if(m_bPixel)
            cbObj += m_cbConst;

        hr = XGBufferCreate(cbObj, &pCode);
		if(FAILED(hr)){
			return hr;
		}

        BYTE *pbObj = (BYTE *) pCode->GetBufferPointer();

        *((DWORD *) (pbObj + 0 * sizeof(DWORD))) = m_dwVersion;
#ifdef WRITE_COMMENT
        *((DWORD *) (pbObj + 1 * sizeof(DWORD))) = D3DSHADER_COMMENT(cdwComment);
        memset( pbObj + 2 * sizeof(DWORD), 0x0, cbComment );
        memcpy( pbObj + 2 * sizeof(DWORD), szComment, sizeof(szComment) );
#endif
        *((DWORD *) (pbObj + cbObj - sizeof(DWORD))) = 0x0000FFFF;
        pbObj = pbObj + cbObj - 2 * sizeof(DWORD);

        while(m_cbCode)
        {
            m_Code.Pop((DWORD *) pbObj);

            pbObj  -= sizeof(DWORD);
            m_cbCode -= sizeof(DWORD);
        }

        if(m_bPixel)
        {
            while(m_cbConst)
            {
                m_Const.Pop((DWORD *) pbObj);

                pbObj -= sizeof(DWORD);
                m_cbConst -= sizeof(DWORD);
            }
        }


        *ppCode = pCode;
    }


#if 0 // TODO: Implement this
    if(!m_bFail && !(dwFlags & D3DXASM_SKIPVALIDATION))
    {
        HINSTANCE hD3D8;

        if((hD3D8 = (HINSTANCE) GetModuleHandle("d3d8.dll")) ||
           (hD3D8 = (HINSTANCE) LoadLibrary("d3d8.dll")))
        {
            char *psz = NULL;
            char **ppsz = ppErrors ? &psz : NULL;
            DWORD dwLog = ppErrors ? SHADER_VALIDATOR_LOG_ERRORS : 0;


            if(m_bPixel)
            {
                LPVALIDATEPIXELSHADER pfnPS;

                if((pfnPS = (LPVALIDATEPIXELSHADER) GetProcAddress(hD3D8, "ValidatePixelShader")))
                    hr = pfnPS((DWORD *) pCode->GetBufferPointer(), NULL, dwLog, ppsz);
            }
            else
            {
                LPVALIDATEVERTEXSHADER pfnVS;

                if((pfnVS = (LPVALIDATEVERTEXSHADER) GetProcAddress(hD3D8, "ValidateVertexShader")))
                    hr = pfnVS((DWORD *) pCode->GetBufferPointer(), NULL, NULL, dwLog, ppsz);
            }

            if(FAILED(hr))
                m_bFail = TRUE;


            if(psz)
            {
                m_Errors.Push(psz);

                m_cErrors++;
                m_cbErrors += strlen(psz) + 1;

                HeapFree(GetProcessHeap(), 0, psz);
            }
        }
    }
#endif // if 0
    
    if(m_bFail)
    {
        DPF(0, "Error assembling shader");
        return D3DXERR_INVALIDDATA;
    }

    if(pShaderType){
        DWORD shaderType;
        if(m_bPixel){
            shaderType = SASMT_PIXELSHADER;
        }
        else {
            if(m_bStateShader){
                shaderType = SASMT_VERTEXSTATESHADER;
            }
            else if(m_bWritable){
                shaderType = SASMT_READWRITE_VERTEXSHADER;
            }
            else{
                shaderType = SASMT_VERTEXSHADER;
            }
        }
        *pShaderType = shaderType;
    }

    return S_OK;
}


int
CD3DXAssembler::Token()
{
    char *pch;
    SIZE_T cch;

    while(m_pch < m_pchLim)
    {
        char ch = *m_pch;

        if(ch == '\n')
        {
            // newline
            m_pch++;
            m_pchLine = m_pch;
            m_iLineNextToken++;
        }
        else if(Isspace(ch))
        {
            // whitespace
            m_pch++;
        }
        else if(ch == '#' && m_pch == m_pchLine)
        {
            // preprocessor directive
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);

            if(m_pch - pch > 5 && !memcmp(pch, "#line", 5))
            {
                // Skip #line
                for(; pch < m_pch && !Isspace(*pch); pch++);

                // Skip whitespace
                for(; pch < m_pch && Isspace(*pch); pch++);
                char *pchNum = pch;

                // Line number
                for(; pch < m_pch && !Isspace(*pch); pch++);
                char *pchNumLim = pch;

                // Beginning of file name
                for(; pch < m_pch && *pch != '"'; pch++);
                char *pchFile = pch;

                if(pch < m_pch)
                    pch++;

                // End of file name
                for(; pch < m_pch && *pch != '"'; pch++);
                char *pchFileLim = pch;


                char sz[256];

                SIZE_T cchNum = pchNumLim - pchNum;
                SIZE_T cchFile = pchFileLim - pchFile;

                if(cchNum >= sizeof(sz))
                    cchNum = sizeof(sz) - 1;

                if(cchFile >= sizeof(m_szFile))
                    cchFile = sizeof(m_szFile) - 1;

                if(cchNum)
                {
                    memcpy(sz, pchNum, cchNum);
                    sz[cchNum] = 0;
                    m_iLineNextToken = atoi(sz) - 1; // -1 because we add one when we see the '\n' at the end of the #line directive.
                }

                if(cchFile > 1)
                {
                    // Copy filename, removing double backslashes
                    pchFile++;
                    pch = m_szFile;

                    while(pchFile < pchFileLim)
                    {
                        *pch = *pchFile++;

                        if(*pch == '\\' && pchFile < pchFileLim && *pchFile == '\\')
                            pchFile++;

                        pch++;
                    }

                    *pch = 0;
                }
            }
            else if(m_pch - pch > 7 && !memcmp(pch, "#pragma", 7))
            {
                pch += 7;
                while(Isspace(*pch) && pch < m_pch){
                    pch++;
                }
                if(m_pch - pch > 11 && !memcmp(pch, "screenspace", 11))
                {
                    m_bScreenSpace = TRUE;
                }
                else {
                    m_iLine = m_iLineNextToken;
                    Error(false, WARNING_ASM_UNKNOWN_PRAGMA, "unknown pragma");
                }
            }
            else
            {
                m_iLine = m_iLineNextToken;
                Error(true, ERROR_ASM_UNSUPPORTED_PREPROCESSOR_DIRECTIVE, "preprocessor directives are not supported.");
            }
        }
        else if((ch == ';') || (ch == '/' && m_pch + 1 < m_pchLim && m_pch[1] == '/'))
        {
            // comment
            for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);
        }
        else if(isalpha(ch))
        {
            m_iLine = m_iLineNextToken;
            // keyword / identifier
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && (isalnum(*m_pch) || '_' == *m_pch
                || ('-' == *m_pch && *pch == 'c' && m_pch == pch + 1) // allow negative c registers to be written as 'c-3'
                ); m_pch++);

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            if(!lstrcmpiA(m_szTok, "vs" )) return T_VS;
            if(!lstrcmpiA(m_szTok, "xvs" )) return T_XVS;
            if(!lstrcmpiA(m_szTok, "xvsw" )) return T_XVSW;
            if(!lstrcmpiA(m_szTok, "xvss" )) return T_XVSS;
            if(!lstrcmpiA(m_szTok, "ps" )) return T_PS;
            if(!lstrcmpiA(m_szTok, "xps" )) return T_XPS;
            if(!lstrcmpiA(m_szTok, "def")) return T_DEF;

            return DecodeOpcode();
        }
        else if(isdigit(ch))
        {
            m_iLine = m_iLineNextToken;
            // number / float
            pch = m_pch;
            int nToken = T_NUM;

            for(m_pch++; m_pch < m_pchLim; m_pch++)
            {
                if(isdigit(*m_pch))
                    continue;

                if(m_dwVersion && ((*m_pch == '.') || *m_pch == 'e') ||
                   ((*m_pch == '+' || *m_pch == '-') && *(m_pch - 1) == 'e'))
                {
                    nToken = T_FLT;
                    continue;
                }

                break;
            }

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            if(m_dwVersion && (m_pch < m_pchLim) && (*m_pch == 'f'))
            {
                nToken = T_FLT;
                m_pch++;
            }

            return nToken;
        }
        else
        {
            m_iLine = m_iLineNextToken;
            // other character
            m_pch++;
            return ch;
        }
    }


    if(m_pch == m_pchLim)
    {
        m_pch++;
        return T_EOF;
    }

    return -1;
}


void
CD3DXAssembler::Production(UINT nProduction)
{
    char *psz;
    FLOAT f;
    DWORD dw;
    DWORD dwOpcode, dwShiftSat;
    DWORD dwParam, dwParam2, dwParam3, dwParam4;
    DWORD dwParam5, dwParam6, dwParam7;
    D3DXVECTOR4 v;
    int o1, o2;
    DWORD sum;


    switch(nProduction)
    {
    case P_SHADER_0:
    case P_SHADER_1:
        break;

    case P_VERSION_0:
        m_Number.Pop(&dwParam2);
        m_Number.Pop(&dwParam);

        if((dwParam | dwParam2) & ~0xff)
        {
            Error(true, ERROR_ASM_INVALID_VERSION, "invalid version");
            break;
        }

        m_bPixel    = FALSE;
		m_bXbox		= FALSE;
		m_bWritable = FALSE;
		m_bStateShader = FALSE;
        m_dwVersion = D3DVS_VERSION(dwParam, dwParam2);
        break;

    case P_VERSION_1:
        m_Number.Pop(&dwParam2);
        m_Number.Pop(&dwParam);

        if((dwParam | dwParam2) & ~0xff)
        {
            Error(true, ERROR_ASM_INVALID_VERSION, "invalid version");
            break;
        }

        m_bPixel    = TRUE;
		m_bXbox		= FALSE;
		m_bWritable = FALSE;
		m_bStateShader = FALSE;
        m_dwVersion = D3DPS_VERSION(dwParam, dwParam2);
        break;

    case P_VERSION_XPS:
        m_Number.Pop(&dwParam2);
        m_Number.Pop(&dwParam);

        if((dwParam | dwParam2) & ~0xff)
        {
            Error(true, ERROR_ASM_INVALID_VERSION, "invalid version");
            break;
        }

        m_bPixel    = TRUE;
		m_bXbox		= TRUE;
		m_bWritable = FALSE;
		m_bStateShader = FALSE;
        m_dwVersion = D3DPS_VERSION(dwParam, dwParam2+10);
        break;

    case P_VERSION_XVS: 
        m_Number.Pop(&dwParam2);
        m_Number.Pop(&dwParam);

        if((dwParam | dwParam2) & ~0xff)
        {
            Error(true, ERROR_ASM_INVALID_VERSION, "invalid version");
            break;
        }

        m_bPixel    = FALSE;
		m_bXbox		= TRUE;
		m_bWritable = FALSE;
		m_bStateShader = FALSE;
        m_dwVersion = D3DVS_VERSION(dwParam, dwParam2);
        break;

    case P_VERSION_XVSW:
        m_Number.Pop(&dwParam2);
        m_Number.Pop(&dwParam);

        if((dwParam | dwParam2) & ~0xff)
        {
            Error(true, ERROR_ASM_INVALID_VERSION, "invalid version");
            break;
        }

        m_bPixel    = FALSE;
		m_bXbox		= TRUE;
		m_bWritable = TRUE;
		m_bStateShader = FALSE;
        m_dwVersion = D3DVS_VERSION(dwParam, dwParam2);
        break;

    case P_VERSION_XVSS:
        m_Number.Pop(&dwParam2);
        m_Number.Pop(&dwParam);

        if((dwParam | dwParam2) & ~0xff)
        {
            Error(true, ERROR_ASM_INVALID_VERSION, "invalid version");
            break;
        }

        m_bPixel    = FALSE;
 		m_bXbox		= TRUE;
		m_bWritable = TRUE;
		m_bStateShader = TRUE;
       m_dwVersion = D3DVS_VERSION(dwParam, dwParam2);
        break;

    case P_BODY_0:
    case P_BODY_1:
        break;

    case P_CONSTANTS_0:
    case P_CONSTANTS_1:
        break;

    case P_CONSTANT_0:
        m_Param.Pop(&dwParam);

        m_Float.Pop((DWORD *) &v.w);
        m_Float.Pop((DWORD *) &v.z);
        m_Float.Pop((DWORD *) &v.y);
        m_Float.Pop((DWORD *) &v.x);

        SetConstant(dwParam, &v);
        break;

    case P_STATEMENTS_0:
    case P_STATEMENTS_1:
        break;

    case P_STATEMENT_0:
        m_Opcode.Pop(&dwShiftSat);
        m_Opcode.Pop(&dwOpcode);

        m_Code.Push(dwOpcode);
        m_cbCode += sizeof(DWORD);
        break;

    case P_STATEMENT_1:
        m_Param.Pop(&dwParam);
        m_Opcode.Pop(&dwShiftSat);
        m_Opcode.Pop(&dwOpcode);

        m_Code.Push(dwOpcode);
        m_Code.Push(dwParam | dwShiftSat);
        m_cbCode += 2 * sizeof(DWORD);
        break;

    case P_STATEMENT_2:
        m_Param.Pop(&dwParam2);
        m_Param.Pop(&dwParam);
        m_Opcode.Pop(&dwShiftSat);
        m_Opcode.Pop(&dwOpcode);

        m_Code.Push(dwOpcode);
        m_Code.Push(dwParam | dwShiftSat);
        m_Code.Push(dwParam2);
        m_cbCode += 3 * sizeof(DWORD);
        break;

    case P_STATEMENT_3:
        m_Param.Pop(&dwParam3);
        m_Param.Pop(&dwParam2);
        m_Param.Pop(&dwParam);
        m_Opcode.Pop(&dwShiftSat);
        m_Opcode.Pop(&dwOpcode);

        // Emulate SUB instruction for vertex shaders
        if(!m_bPixel && (D3DSIO_SUB == (dwOpcode & D3DSI_OPCODE_MASK)))
        {
            dwOpcode = (dwOpcode & ~D3DSI_OPCODE_MASK) | D3DSIO_ADD;
            dwParam3 ^= D3DSPSM_NEG;
        }

        m_Code.Push(dwOpcode);
        m_Code.Push(dwParam | dwShiftSat);
        m_Code.Push(dwParam2);
        m_Code.Push(dwParam3);
        m_cbCode += 4 * sizeof(DWORD);
        break;

    case P_STATEMENT_4:
        m_Param.Pop(&dwParam4);
        m_Param.Pop(&dwParam3);
        m_Param.Pop(&dwParam2);
        m_Param.Pop(&dwParam);
        m_Opcode.Pop(&dwShiftSat);
        m_Opcode.Pop(&dwOpcode);

        m_Code.Push(dwOpcode);
        m_Code.Push(dwParam | dwShiftSat);
        m_Code.Push(dwParam2);
        m_Code.Push(dwParam3);
        m_Code.Push(dwParam4);
        m_cbCode += 5 * sizeof(DWORD);
        break;


    case P_STATEMENT_5:
        m_Param.Pop(&dwParam7);
        m_Param.Pop(&dwParam6);
        m_Param.Pop(&dwParam5);
        m_Param.Pop(&dwParam4);
        m_Param.Pop(&dwParam3);
        m_Param.Pop(&dwParam2);
        m_Param.Pop(&dwParam);
        m_Opcode.Pop(&dwShiftSat);
        m_Opcode.Pop(&dwOpcode);

        m_Code.Push(dwOpcode);
        m_Code.Push(dwParam | dwShiftSat);
        m_Code.Push(dwParam2);
        m_Code.Push(dwParam3);
        m_Code.Push(dwParam4);
        m_Code.Push(dwParam5);
        m_Code.Push(dwParam6);
        m_Code.Push(dwParam7);
        m_cbCode += 8 * sizeof(DWORD);
        break;


    case P_STATEMENT_6:
        m_Param.Pop(&dwParam6);
        m_Param.Pop(&dwParam5);
        m_Param.Pop(&dwParam4);
        m_Param.Pop(&dwParam3);
        m_Param.Pop(&dwParam2);
        m_Param.Pop(&dwParam);
        m_Opcode.Pop(&dwShiftSat);
        m_Opcode.Pop(&dwOpcode);

        m_Code.Push(dwOpcode);
        m_Code.Push(dwParam | dwShiftSat);
        m_Code.Push(dwParam2);
        m_Code.Push(dwParam3);
        m_Code.Push(dwParam4);
        m_Code.Push(dwParam5);
        m_Code.Push(dwParam6);
        m_cbCode += 7 * sizeof(DWORD);
        break;


    case P_STATEMENT_7:
        m_Param.Pop(&dwParam7);
        m_Param.Pop(&dwParam6);
        m_Param.Pop(&dwParam5);
        m_Param.Pop(&dwParam4);
        m_Param.Pop(&dwParam3);
        m_Param.Pop(&dwParam2);
        m_Param.Pop(&dwParam);
        m_Opcode.Pop(&dwShiftSat);
        m_Opcode.Pop(&dwOpcode);

        m_Code.Push(dwOpcode);
        m_Code.Push(dwParam | dwShiftSat);
        m_Code.Push(dwParam2);
        m_Code.Push(dwParam3);
        m_Code.Push(dwParam4);
        m_Code.Push(dwParam5);
        m_Code.Push(dwParam6);
        m_Code.Push(dwParam7);
        m_cbCode += 8 * sizeof(DWORD);
        break;


    case P_DST_0:
        m_Param.Pop(&dwParam);
        dwParam |= D3DSP_WRITEMASK_ALL;
        ValidateDstRegister(dwParam);
        m_Param.Push(dwParam);
        break;

    case P_DST_1:
        m_Id.Pop(&psz);
        m_Param.Pop(&dwParam);
        dwParam = (dwParam & ~D3DSP_WRITEMASK_ALL) | DecodeMask(psz);
        ValidateDstRegister(dwParam);
        m_Param.Push(dwParam);
        delete [] psz;
        break;

    case P_SRC_0:
        m_Param.Pop(&dwParam);
        ValidateSrcRegister(dwParam);
        m_Param.Push(dwParam);
        break;

    case P_SRC_1:
        m_Param.Pop(&dwParam);

        switch(dwParam & D3DSP_SRCMOD_MASK)
        {
        case D3DSPSM_NONE:
            dwParam = (dwParam & ~D3DSP_SRCMOD_MASK) | D3DSPSM_NEG;
            break;

        case D3DSPSM_BIAS:
            dwParam = (dwParam & ~D3DSP_SRCMOD_MASK) | D3DSPSM_BIASNEG;
            break;

        case D3DSPSM_SIGN:
            dwParam = (dwParam & ~D3DSP_SRCMOD_MASK) | D3DSPSM_SIGNNEG;
            break;
        }

        ValidateSrcRegister(dwParam);
        m_Param.Push(dwParam);
        break;

    case P_SRC_2:
        m_Number.Pop(&dw);
        m_Param.Pop(&dwParam);

        if(!m_bPixel)
            Error(true, ERROR_ASM_COMPLEMENT_NOT_SUPPORTED, "complement not supported in vertex shaders");
        else if(D3DSPSM_NONE != (dwParam & D3DSP_SRCMOD_MASK))
            Error(true, ERROR_ASM_COMPLEMENT_CANNOT_BE_USED_WITH_OTHER_MODIFIERS, "complement cannot be used with other modifiers");

        dwParam = (dwParam & ~D3DSP_SRCMOD_MASK) | D3DSPSM_COMP;
        ValidateSrcRegister(dwParam);
        m_Param.Push(dwParam);
        break;

    case P_SRC2_0:
        m_Param.Pop(&dwParam);
        m_Param.Push((dwParam & ~D3DVS_SWIZZLE_MASK) | D3DVS_NOSWIZZLE);
        break;

    case P_SRC2_1:
        m_Id.Pop(&psz);
        m_Param.Pop(&dwParam);
        m_Param.Push((dwParam & ~D3DVS_SWIZZLE_MASK) | DecodeSwizzle(psz));
        delete [] psz;
        break;

    case P_REG_0:
        m_Id.Pop(&psz);
        m_Param.Push(DecodeRegister(psz, 0, FALSE) | (1 << 31));
        delete [] psz;
        break;

    case P_REG_1:
        m_Id.Pop(&psz);
        m_Param.Pop(&dw);
        m_Param.Push(DecodeRegister(psz, dw, TRUE) | (1 << 31));
        delete [] psz;
        break;

    case P_REG_2:
        char combine[1024], *psz2;
        m_Id.Pop(&psz2);
        m_Param.Pop(&dw);
        m_Id.Pop(&psz);
        sprintf(combine, "%s%d_%s", psz, dw, psz2);
        m_Param.Push(DecodeRegister(combine, 0, FALSE) | (1 << 31));
        delete [] psz;
        break;

    case P_OFFSET_0:
        m_Param.Pop(&dw);

        if(m_bPixel)
            Error(true, ERROR_ASM_SYNTAX_ERROR, "syntax error");
        else if(dw != (D3DSPR_ADDR | D3DVS_X_X | D3DVS_Y_X | D3DVS_Z_X | D3DVS_W_X | (1 << 31)))
            Error(true, ERROR_ASM_ILLEGAL_REGISTER_IN_INDEX_EXPRESSION, "illegal register in index expression");

        m_Param.Push(D3DVS_ADDRMODE_RELATIVE);
        break;

    case P_OFFSET_1:
        m_Number.Pop(&dw);
        m_Param.Push(dw & D3DSP_REGNUM_MASK);
        break;

    case P_OFFSET_2:
        m_Param.Pop(&dwParam);
        m_Param.Pop(&dw);

        if(m_bPixel)
            Error(true, ERROR_ASM_SYNTAX_ERROR, "syntax error");
        else if(dw != (D3DSPR_ADDR | D3DVS_X_X | D3DVS_Y_X | D3DVS_Z_X | D3DVS_W_X | (1 << 31)))
            Error(true, ERROR_ASM_ILLEGAL_REGISTER_IN_INDEX_EXPRESSION, "illegal register in index expression");
        else if(dwParam & D3DVS_ADDRMODE_RELATIVE)
            Error(true, ERROR_ASM_A0_X_CAN_ONLY_APPEAR_ONCE_IN_AN_INDEX_EXPRESSION, "a0.x can only appear once in an index expression");

        m_Param.Push(dwParam | D3DVS_ADDRMODE_RELATIVE);
        break;

    case P_OFFSET_3:
        m_Number.Pop(&dw);
        m_Param.Pop(&dwParam);
        m_Param.Push((dwParam & ~D3DSP_REGNUM_MASK) | ((dwParam + dw) & D3DSP_REGNUM_MASK));
        break;

    case P_OFFSET_4:
		// Just like P_OFFSET_2, but with a negative offset.
		// example: c[A0.x-12]
        m_Param.Pop(&dwParam);
        m_Param.Pop(&dw);

        if(m_bPixel)
            Error(true, ERROR_ASM_SYNTAX_ERROR, "syntax error");
        else if(dw != (D3DSPR_ADDR | D3DVS_X_X | D3DVS_Y_X | D3DVS_Z_X | D3DVS_W_X | (1 << 31)))
            Error(true, ERROR_ASM_ILLEGAL_REGISTER_IN_INDEX_EXPRESSION, "illegal register in index expression");
        else if(dwParam & D3DVS_ADDRMODE_RELATIVE)
            Error(true, ERROR_ASM_A0_X_CAN_ONLY_APPEAR_ONCE_IN_AN_INDEX_EXPRESSION, "a0.x can only appear once in an index expression");

		// Negate existing offset
		{
			int offset = (dwParam & D3DSP_REGNUM_MASK);
			offset = -offset;
			dwParam = (dwParam & ~D3DSP_REGNUM_MASK)
				| (offset & D3DSP_REGNUM_MASK);
		}

        m_Param.Push(dwParam | D3DVS_ADDRMODE_RELATIVE);
        break;

    case P_OFFSET_5:
        // Like 1, but with a negative offset
        // example: c[-5]
        m_Number.Pop(&dw);
		// Negate existing offset
		{
			int offset = (dw & D3DSP_REGNUM_MASK);
			offset = -offset;
			dw = (dw & ~D3DSP_REGNUM_MASK)
				| (offset & D3DSP_REGNUM_MASK);
		}
        m_Param.Push(dw & D3DSP_REGNUM_MASK);
        break;

    case P_OFFSET_6:
        break;

    case P_OFFSET_7:
        m_Param.Pop(&dwParam);
        m_Param.Pop(&dw);

        if((dwParam & D3DVS_ADDRMODE_RELATIVE) &&
           (dw      & D3DVS_ADDRMODE_RELATIVE))
            Error(true, ERROR_ASM_A0_X_CAN_ONLY_APPEAR_ONCE_IN_AN_INDEX_EXPRESSION, "a0.x can only appear once in an index expression");
        
        // find sum of offsets
        o1 = dwParam & D3DSP_REGNUM_MASK;
        if(o1 & 0x800)
            o1 |= 0xfffff000;

        o2 = dw & D3DSP_REGNUM_MASK;
        if(o2 & 0x800)
            o2 |= 0xfffff000;

        sum = (o1 + o2) & D3DSP_REGNUM_MASK;
        if((dwParam & D3DVS_ADDRMODE_RELATIVE) ||
           (dw      & D3DVS_ADDRMODE_RELATIVE))
            sum |= D3DVS_ADDRMODE_RELATIVE;

        m_Param.Push(sum);
        break;

    case P_OFFSET_8:
        m_Param.Pop(&dwParam);
        m_Param.Pop(&dw);

        if((dwParam & D3DVS_ADDRMODE_RELATIVE) &&
           (dw      & D3DVS_ADDRMODE_RELATIVE))
            Error(true, ERROR_ASM_A0_X_CAN_ONLY_APPEAR_ONCE_IN_AN_INDEX_EXPRESSION, "a0.x can only appear once in an index expression");
        
        if(dwParam & D3DVS_ADDRMODE_RELATIVE)
            Error(true, ERROR_ASM_A0_X_CANT_BE_NEGATED, "a0.x can't be negated");
        
        // find sum of offsets
        int o1, o2;
        o1 = dwParam & D3DSP_REGNUM_MASK;
        if(o1 & 0x800)
            o1 |= 0xfffff000;

        o2 = dw & D3DSP_REGNUM_MASK;
        if(o2 & 0x800)
            o2 |= 0xfffff000;

        DWORD sum;
        sum = (o2 - o1) & D3DSP_REGNUM_MASK;
        if((dwParam & D3DVS_ADDRMODE_RELATIVE) ||
           (dw      & D3DVS_ADDRMODE_RELATIVE))
            sum |= D3DVS_ADDRMODE_RELATIVE;

        m_Param.Push(sum);
        break;

    case P_OFFSET_9:
        m_Number.Pop(&dw);
        m_Param.Pop(&dwParam);
        if(dwParam & D3DVS_ADDRMODE_RELATIVE)
            Error(true, ERROR_ASM_A0_X_CANT_BE_NEGATED, "a0.x can't be negated");
        
        m_Param.Push((dwParam & ~D3DSP_REGNUM_MASK) | ((dw - dwParam) & D3DSP_REGNUM_MASK));
        break;

    case P_OFFSET_10:
        m_Number.Pop(&dw);
        m_Param.Pop(&dwParam);
        m_Param.Push((dwParam & ~D3DSP_REGNUM_MASK) | ((-(int)dw + dwParam) & D3DSP_REGNUM_MASK));
        break;

    case P_OFFSET_11:
        m_Number.Pop(&dw);
        m_Param.Pop(&dwParam);
        if(dwParam & D3DVS_ADDRMODE_RELATIVE)
            Error(true, ERROR_ASM_A0_X_CANT_BE_NEGATED, "a0.x can't be negated");
        
        m_Param.Push((dwParam & ~D3DSP_REGNUM_MASK) | ((-(int)dw - dwParam) & D3DSP_REGNUM_MASK));
        break;

    case P_OP0_0:
    case P_OP1_0:
    case P_OP2_0:
    case P_OP3_0:
    case P_OP4_0:
    case P_OP5_0:
    case P_OP6_0:
    case P_OP7_0:
        m_Opcode.Push(m_dwOpcode);
        m_Opcode.Push(m_dwShiftSat);

        UpdateDebugFileLine();
        break;

    case P_OP0_1:
    case P_OP1_1:
    case P_OP2_1:
    case P_OP3_1:
    case P_OP4_1:
    case P_OP5_1:
    case P_OP6_1:
    case P_OP7_1:
        if(!m_bPixel && !m_bXbox){
            Error(true, ERROR_ASM_INVALID_INSTRUCTION_COMBINATION, "Instruction combination is not allowed in a vs shader. Use xvs instead.");
            m_Opcode.Push(m_dwOpcode);
        }
        else {
            m_Opcode.Push(m_dwOpcode | D3DSI_COISSUE);
        }
        m_Opcode.Push(m_dwShiftSat);

        UpdateDebugFileLine();
        break;

    case P_VAL_0:
    case P_VAL_1:
        m_Number.Pop(&dw);
        f = (FLOAT) dw;
        m_Float.Push(*((DWORD *) &f));
        break;

    case P_VAL_2:
        m_Number.Pop(&dw);
        f = -((FLOAT) dw);
        m_Float.Push(*((DWORD *) &f));
        break;

    case P_VAL_3:
    case P_VAL_4:
        break;

    case P_VAL_5:
        m_Float.Pop((DWORD *) &f);
        f = -f;
        m_Float.Push(*((DWORD *) &f));
        break;

    case P_ID:
        m_Id.Push(m_szTok);
        break;

    case P_NUM:
        m_Number.Push(atoi(m_szTok));
        break;

    case P_FLT:
        sscanf(m_szTok, "%f", &f);
        m_Float.Push(*((DWORD *) &f));
        break;
    }


    if(FAILED(m_Id    .GetLastError()) ||
       FAILED(m_Number.GetLastError()) ||
       FAILED(m_Param .GetLastError()) ||
       FAILED(m_Code  .GetLastError()) ||
       FAILED(m_Float .GetLastError()))
    {
        Error(true, ERROR_ASM_INTERNAL_ASSEMBLER_ERROR, "Internal assembler error! %d", __LINE__);
    }
}


void
CD3DXAssembler::YYError(char *szFormat, ...)
{
	va_list ap;
	va_start(ap, szFormat);
    // Special case a missing version statement
    if(m_dwVersion == 0){
        Error(true, ERROR_ASM_EXPECTED_VERSION, "Expected a version statement ('ps', 'xps', 'vs', 'xvs', 'xvss', or 'xvsw').");
        return;
    }
	Error2(true, ERROR_ASM_SYNTAX_ERROR, szFormat, ap);
	va_end(ap);
}

void
CD3DXAssembler::Error(bool error, DWORD code, LPCSTR szFormat, ...)
{
	va_list ap;
	va_start(ap, szFormat);
	Error2(error, code, szFormat, ap);
	va_end(ap);
}

void
CD3DXAssembler::Error2(bool error, DWORD code, LPCSTR szFormat, va_list list)
{
	if(m_pErrorLog){
		char szA[512];

		_vsnprintf(szA, sizeof(szA), szFormat, list);
		szA[sizeof(szA)-1] = '\0';

		m_pErrorLog->Log(error, code, m_szFile, m_iLine, szA);
	}
    m_bFail = TRUE;
}

int
CD3DXAssembler::DecodeOpcode()
{
    char sz[16];

    int   nTok        = T_ID;
    DWORD dwOpcode    = 0;
    DWORD dwShiftSat  = 0;

    char *psz         = m_szTok;
    char *pszOp       = NULL;
    char *pszOpLim    = NULL;
    char *pszShift    = NULL;
    char *pszShiftLim = NULL;


    // Parse string
    pszOp = psz;
    for(; *psz && *psz != '_'; psz++);
    pszOpLim = psz;

    if(*psz)
    {
        pszShift = ++psz;
        for(; *psz && *psz != '_'; psz++);
        pszShiftLim = psz;
    }

    if(*psz)
        return T_ID;    // only one destination modifier allowed

    // Validate opcode
    SIZE_T cchOp = pszOpLim - pszOp;

    if(cchOp > sizeof(sz) - 1)
        return T_ID;

    memcpy(sz, pszOp, cchOp);
    sz[cchOp] = 0;


    // Common opodes
    if     (!lstrcmpiA(sz, "nop"))  { dwOpcode = D3DSIO_NOP;  nTok = T_OP0; }
    else if(!lstrcmpiA(sz, "mov"))  { dwOpcode = D3DSIO_MOV;  nTok = T_OP2; }
    else if(!lstrcmpiA(sz, "add"))  { dwOpcode = D3DSIO_ADD;  nTok = T_OP3; }
    else if(!lstrcmpiA(sz, "sub"))  { dwOpcode = D3DSIO_SUB;  nTok = T_OP3; }
    else if(!lstrcmpiA(sz, "mad"))  { dwOpcode = D3DSIO_MAD;  nTok = T_OP4; }
    else if(!lstrcmpiA(sz, "mul"))  { dwOpcode = D3DSIO_MUL;  nTok = T_OP3; }
    else if(!lstrcmpiA(sz, "dp3"))  { dwOpcode = D3DSIO_DP3;  nTok = T_OP3; }
    else if(!lstrcmpiA(sz, "dp4"))  { dwOpcode = D3DSIO_DP4;  nTok = T_OP3; }


    // Pixel shader opcodes
    if((T_ID == nTok) && m_bPixel)
    {
        if     (!lstrcmpiA(sz, "lrp"         ))  { dwOpcode = D3DSIO_LRP;          nTok = T_OP4; }
        else if(!lstrcmpiA(sz, "cnd"         ))  { dwOpcode = D3DSIO_CND;          nTok = T_OP4; }
        else if(!lstrcmpiA(sz, "texcoord"    ))  { dwOpcode = D3DSIO_TEXCOORD;     nTok = T_OP1; }
        else if(!lstrcmpiA(sz, "texkill"     ))  { dwOpcode = D3DSIO_TEXKILL;      nTok = T_OP1; }
        else if(!lstrcmpiA(sz, "tex"         ))  { dwOpcode = D3DSIO_TEX;          nTok = T_OP1; }
        else if(!lstrcmpiA(sz, "texbem"      ))  { dwOpcode = D3DSIO_TEXBEM;       nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texbeml"     ))  { dwOpcode = D3DSIO_TEXBEML;      nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texreg2ar"   ))  { dwOpcode = D3DSIO_TEXREG2AR;    nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texreg2gb"   ))  { dwOpcode = D3DSIO_TEXREG2GB;    nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texm3x2pad"  ))  { dwOpcode = D3DSIO_TEXM3x2PAD;   nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texm3x2tex"  ))  { dwOpcode = D3DSIO_TEXM3x2TEX;   nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texm3x3pad"  ))  { dwOpcode = D3DSIO_TEXM3x3PAD;   nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texm3x3tex"  ))  { dwOpcode = D3DSIO_TEXM3x3TEX;   nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texm3x3diff" ))  { dwOpcode = D3DSIO_TEXM3x3DIFF;  nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texm3x3spec" ))  { dwOpcode = D3DSIO_TEXM3x3SPEC;  nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "texm3x3vspec"))  { dwOpcode = D3DSIO_TEXM3x3VSPEC; nTok = T_OP2; }
#ifdef XBOX_EXTENSIONS
        else if(!lstrcmpiA(sz, "xmma" )) { dwOpcode = D3DSIO_XMMA;  nTok = T_OP7; }
        else if(!lstrcmpiA(sz, "xmmc" )) { dwOpcode = D3DSIO_XMMC;  nTok = T_OP7; }
        else if(!lstrcmpiA(sz, "xdm"  )) { dwOpcode = D3DSIO_XDM;   nTok = T_OP6; }
        else if(!lstrcmpiA(sz, "xdd"  )) { dwOpcode = D3DSIO_XDD;   nTok = T_OP6; }
        else if(!lstrcmpiA(sz, "xfc"  )) { dwOpcode = D3DSIO_XFC;   nTok = T_OP5; }
        else if(!lstrcmpiA(sz, "texm3x2depth"))  { dwOpcode = D3DSIO_TEXM3x2DEPTH; nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texbrdf"))       { dwOpcode = D3DSIO_TEXBRDF;      nTok = T_OP1; }
#endif
#if 0 // not implemented for now
        else if(!lstrcmpiA(sz, "texdp3"))        { dwOpcode = D3DSIO_TEXDP3;       nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "texreg2rgb"))    { dwOpcode = D3DSIO_TEXREG2RGB;   nTok = T_OP2; }
#endif // 0
    }


    // Vertex shader opcodes
    if((T_ID == nTok) && !m_bPixel)
    {
        if     (!lstrcmpiA(sz, "rcp"))  { dwOpcode = D3DSIO_RCP;  nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "rsq"))  { dwOpcode = D3DSIO_RSQ;  nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "min"))  { dwOpcode = D3DSIO_MIN;  nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "max"))  { dwOpcode = D3DSIO_MAX;  nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "slt"))  { dwOpcode = D3DSIO_SLT;  nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "sge"))  { dwOpcode = D3DSIO_SGE;  nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "exp"))  { dwOpcode = D3DSIO_EXP;  nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "log"))  { dwOpcode = D3DSIO_LOG;  nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "lit"))  { dwOpcode = D3DSIO_LIT;  nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "dst"))  { dwOpcode = D3DSIO_DST;  nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "frc"))  { dwOpcode = D3DSIO_FRC;  nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "m4x4")) { dwOpcode = D3DSIO_M4x4; nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "m4x3")) { dwOpcode = D3DSIO_M4x3; nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "m3x4")) { dwOpcode = D3DSIO_M3x4; nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "m3x3")) { dwOpcode = D3DSIO_M3x3; nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "m3x2")) { dwOpcode = D3DSIO_M3x2; nTok = T_OP3; }
        else if(!lstrcmpiA(sz, "expp")) { dwOpcode = D3DSIO_EXPP; nTok = T_OP2; }
        else if(!lstrcmpiA(sz, "logp")) { dwOpcode = D3DSIO_LOGP; nTok = T_OP2; }
#ifdef XBOX_EXTENSIONS
		else if(m_bXbox){
			if(!lstrcmpiA(sz, "dph")) { dwOpcode = D3DSIO_DPH; nTok = T_OP3; }
			else if(!lstrcmpiA(sz, "rcc")) { dwOpcode = D3DSIO_RCC; nTok = T_OP2; }
		}
#endif // XBOX_EXTENSIONS
	}

    if(T_ID == nTok)
        return T_ID;



    // Validate shift
    if(pszShift)
    {
        if(m_bPixel)
        {
            SIZE_T cchShift = pszShiftLim - pszShift;

            if(cchShift > sizeof(sz) - 1)
                return T_ID;

            memcpy(sz, pszShift, cchShift);
            sz[cchShift] = 0;


            if     (!lstrcmpiA(sz, "x4")) dwShiftSat = (( 2) << D3DSP_DSTSHIFT_SHIFT) & D3DSP_DSTSHIFT_MASK;
            else if(!lstrcmpiA(sz, "x2")) dwShiftSat = (( 1) << D3DSP_DSTSHIFT_SHIFT) & D3DSP_DSTSHIFT_MASK;
            else if(!lstrcmpiA(sz, "d2")) dwShiftSat = ((-1) << D3DSP_DSTSHIFT_SHIFT) & D3DSP_DSTSHIFT_MASK;
            else if(!lstrcmpiA(sz, "bias")) dwShiftSat = D3DSPDM_BIAS;
            else if(!lstrcmpiA(sz, "bx2")) 
            {
                dwShiftSat = (( 1) << D3DSP_DSTSHIFT_SHIFT) & D3DSP_DSTSHIFT_MASK;
                dwShiftSat |= D3DSPDM_BIAS;
            }
            else return T_ID;
        }
        else
        {
            return T_ID;
        }
    }
    
    m_dwOpcode   = dwOpcode;
    m_dwShiftSat = dwShiftSat;

    return nTok;
}



DWORD
CD3DXAssembler::DecodeMask(char *psz)
{
    DWORD dwMask  = 0;
    DWORD dwShift = 0;
    DWORD dwComp;
    DWORD dwCompLast;

    if(!psz || !*psz)
        return D3DSP_WRITEMASK_ALL;

    for(char *pszT = psz; *pszT; pszT++)
    {
        switch(*pszT)
        {
        case 'x':
        case 'r':
            dwComp = 0;
            dwMask |= D3DSP_WRITEMASK_0;
            break;

        case 'y':
        case 'g':
            dwComp = 1;
            dwMask |= D3DSP_WRITEMASK_1;
            break;

        case 'z':
        case 'b':
            dwComp = 2;
            dwMask |= D3DSP_WRITEMASK_2;
            break;

        case 'w':
        case 'a':
            dwComp = 3;
            dwMask |= D3DSP_WRITEMASK_3;
            break;

        default:
            goto LFail;
        }


        if(pszT != psz && dwComp <= dwCompLast)
            goto LFail;

        dwCompLast = dwComp;
    }

    return dwMask;

LFail:
    Error(true, ERROR_ASM_INVALID_MASK, "invalid mask '%s'", psz);
    m_bFail = TRUE;
    return 0;
}



DWORD
CD3DXAssembler::DecodeSwizzle(char *psz)
{
    DWORD dwSrc = 0;
    DWORD dwDst = 0;
    DWORD dwSwizzle = 0;
    char *pszT = psz;

    if(!psz || !*psz)
        return D3DVS_NOSWIZZLE;

    for(dwDst = 0; dwDst < 4; dwDst++)
    {
//        dwSrc = dwDst;  // default is no swizzle
        if(*pszT)
        {
            switch(*pszT)
            {
            case 'x':
            case 'r':
                dwSrc = 0;
                break;

            case 'y':
            case 'g':
                dwSrc = 1;
                break;

            case 'z':
            case 'b':
                dwSrc = 2;
                break;

            case 'w':
            case 'a':
                dwSrc = 3;
                break;

            default:
                goto LFail;
            }

            pszT++;
        }

        dwSwizzle |= dwSrc << (D3DVS_SWIZZLE_SHIFT + 2 * dwDst);
    }

    if(*pszT)
        goto LFail;

    return dwSwizzle;

LFail:
    Error(true, ERROR_ASM_INVALID_SWIZZLE, "invalid swizzle '%s'", psz);
    m_bFail = TRUE;
    return 0;
}




DWORD
CD3DXAssembler::DecodeRegister(char *psz, DWORD dwAddr, BOOL bIndex)
{
    char chNum;
    char *pszNum;
    char *pszEnd;

    for(pszNum = psz;    *pszNum && isalpha(*pszNum); pszNum++);
    for(pszEnd = pszNum;
        *pszEnd && (isdigit(*pszEnd)
            || (*pszEnd == '-' && *psz == 'c' && pszEnd == pszNum) // Allow c-3
            );
        pszEnd++);

    BOOL bNum = *pszNum != 0;
    DWORD dwBias = 0;


    if(m_bPixel && ('_' == *pszEnd))
    {
        if(!lstrcmpiA(pszEnd, "_bias"))
        {
            dwBias = D3DSPSM_BIAS;
            pszEnd += 5;
        }
        else if(!lstrcmpiA(pszEnd, "_bx2") || !lstrcmpiA(pszEnd, "_sgn"))
        {
            dwBias = D3DSPSM_SIGN;
            pszEnd += 4;
        }
        else if(!lstrcmpiA(pszEnd, "_sat"))
        {
            dwBias = D3DSPSM_SAT;
            pszEnd += 4;
        }
        // handle dot-mapping modifiers for texture stage inputs
        else if(!lstrcmpiA(pszEnd, "_sign1"))
        {
            dwBias = D3DSPSM_SIGN;
            pszEnd += 5;
        }
        else if(!lstrcmpiA(pszEnd, "_sign2"))
        {
            dwBias = D3DSPSM_NEG;
            pszEnd += 6;
        }
        else if(!lstrcmpiA(pszEnd, "_sign3"))
        {
            dwBias = D3DSPSM_BIAS;
            pszEnd += 6;
        }
        else if(!lstrcmpiA(pszEnd, "_hl"))
        {
            dwBias = D3DSPSM_BIASNEG;
            pszEnd += 3;
        }
        else if(!lstrcmpiA(pszEnd, "_hemi1"))
        {
            dwBias = D3DSPSM_SIGNNEG;
            pszEnd += 6;
        }
        else if(!lstrcmpiA(pszEnd, "_hemi2"))
        {
            dwBias = D3DSPSM_COMP;
            pszEnd += 6;
        }
        else if(!lstrcmpiA(pszEnd, "_hemi3"))
        {
            dwBias = D3DSPSM_SAT;
            pszEnd += 6;
        }
    }


    if(!*pszEnd)
    {
        if(!bIndex)
        {
            int iNum = atoi(pszNum);
            dwAddr = iNum & D3DSP_REGNUM_MASK;
            chNum = *pszNum;
            *pszNum = 0;

            if(m_bPixel)
            {
                if(!lstrcmpiA(psz, "v") && bNum)
                {
                    if(0 <= iNum && iNum < D3DPS_INPUTREG_MAX_DX8)
                        return D3DSPR_INPUT | dwAddr | dwBias;
                }
                else if(!lstrcmpiA(psz, "r") && bNum)
                {
                    if(0 <= iNum && iNum < D3DPS_TEMPREG_MAX_DX8)
                        return D3DSPR_TEMP | dwAddr | dwBias;
                }
                else if(!lstrcmpiA(psz, "c") && bNum)
                {
                    if(0 <= iNum && iNum < D3DPS_CONSTREG_MAX_DX8)
                        return D3DSPR_CONST | dwAddr | dwBias;
                }
                else if(!lstrcmpiA(psz, "t") && bNum)
                {
                    if(0 <= iNum && iNum < D3DPS_TEXTUREREG_MAX_DX8)
                        return D3DSPR_TEXTURE | dwAddr | dwBias;
                }
                else if((!lstrcmpiA(psz, "zero")) || (!lstrcmpiA(psz, "discard")))
                {
                    return D3DSPR_TEMP | 2 | dwBias;    // zero/discard is R2
                }
                else if(!lstrcmpiA(psz, "fog"))
                {
                    return D3DSPR_TEMP | 3 | dwBias;    // fog is R3
                }
                else if(!lstrcmpiA(psz, "prod"))
                {
                    return D3DSPR_INPUT | 3 | dwBias;    // prod is V3
                }
                else if(!lstrcmpiA(psz, "sum"))
                {
                    return D3DSPR_INPUT | 2 | dwBias;    // sum is V2
                }
            }
            else
            {
                if(!lstrcmpiA(psz, "oPos") && !bNum)
                {
                    return D3DSPR_RASTOUT | D3DSRO_POSITION;
                }
                else if(!lstrcmpiA(psz, "oPts") && !bNum)
                {
                    return D3DSPR_RASTOUT | D3DSRO_POINT_SIZE;
                }
                else if(!lstrcmpiA(psz, "oFog") && !bNum)
                {
                    return D3DSPR_RASTOUT | D3DSRO_FOG;
                }
                else if(!lstrcmpiA(psz, "v") && bNum)
                {
                    if(0 <= iNum && iNum < D3DVS_INPUTREG_MAX_V1_1)
                        return D3DSPR_INPUT | dwAddr;
                }
                else if(!lstrcmpiA(psz, "r") && bNum)
                {
                    if(0 <= iNum && iNum < (m_bXbox ? 13 : D3DVS_TEMPREG_MAX_V1_1))
                        return D3DSPR_TEMP | dwAddr;
                }
                else if(!lstrcmpiA(psz, "c") && bNum)
                {
                    // Limit constants to 0..191 for normal shaders, -192..191 for xbox shaders
 					int cregMin = m_bXbox ? -192 : 0;
                    int cregMax = 192;
                    if(cregMin <= iNum && iNum < cregMax) {
                        return D3DSPR_CONST | dwAddr;
                    }
                }
                else if(!lstrcmpiA(psz, "a") && bNum)
                {
                    if(0 <= iNum && iNum < D3DVS_ADDRREG_MAX_V1_1)
                        return D3DSPR_ADDR | dwAddr;
                }
                else if(!lstrcmpiA(psz, "oD") && bNum)
                {
					int dwOutRegMax = m_bXbox ? 2 : D3DVS_ATTROUTREG_MAX_V1_1;
                    if(0 <= iNum && iNum < dwOutRegMax)
                        return D3DSPR_ATTROUT | dwAddr;
                }
                else if(!lstrcmpiA(psz, "oB") && bNum)
                {
					int dwOutRegMax = m_bXbox ? 2 : 0;
                    if(0 <= iNum && iNum < dwOutRegMax)
                        return D3DSPR_ATTROUT | 0x100 | dwAddr;
                }
                else if(!lstrcmpiA(psz, "oT") && bNum)
                {
                    if(0 <= iNum && iNum < D3DVS_TCRDOUTREG_MAX_V1_1)
                        return D3DSPR_TEXCRDOUT | dwAddr;
                }
            }

            *pszNum = chNum;
        }
        else
        {
            if(m_bPixel)
            {
                if(!lstrcmpiA(psz, "c") && !bNum)
                {
                    if((dwAddr & D3DSP_REGNUM_MASK) < D3DPS_CONSTREG_MAX_DX8)
                        return D3DSPR_CONST | dwAddr | dwBias;
                }
            }
            else
            {
                if(!lstrcmpiA(psz, "c") && !bNum)
                    return D3DSPR_CONST | dwAddr;
            }
        }
    }

    if(!bIndex)
    {
        Error(true, ERROR_ASM_INVALID_REGISTER, "invalid register '%s'", psz);
    }
    else
    {
        if(dwAddr & D3DVS_ADDRMODE_RELATIVE)
            Error(true, ERROR_ASM_INVALID_REGISTER, "invalid register '%s[a0.x + %d]'", psz, dwAddr & D3DSP_REGNUM_MASK);
        else
            Error(true, ERROR_ASM_INVALID_REGISTER, "invalid register '%s[%d]'", psz, dwAddr & D3DSP_REGNUM_MASK);
    }

    m_bFail = TRUE;
    return 0;
}


void
CD3DXAssembler::ValidateDstRegister(DWORD dwReg)
{
    if(dwReg & D3DSP_SRCMOD_MASK)
    {
        Error(true, ERROR_ASM_SOURCE_MODIFIERS_NOT_ALLOWED_ON_DESTINATION_REGISTERS, "source modifiers are not allowed on destination registers");
        goto LFail;
    }


    if(m_bPixel)
    {
        switch(dwReg & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP:
        case D3DSPR_INPUT:
        case D3DSPR_TEXTURE:
            break;

        default:
            Error(true, ERROR_ASM_INVALID_DESTINATION_REGISTER, "invalid destination register");
            goto LFail;
        }

        // Only valid masks: RGBA, RGB, A
        switch(dwReg & D3DSP_WRITEMASK_ALL)
        {
        case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3:
        case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2:
        case D3DSP_WRITEMASK_3:
            break;

        default:
            Error(true, ERROR_ASM_INVALID_WRITE_MASK, "invalid write mask");
            goto LFail;
        }
    }
    else
    {
        bool ok = false;
		switch(dwReg & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP:
            // Don't allow r12 to be used as a destination register.
            // r12 is valid as a source register for xbox, which is why it's allowed to get this far.
            if ((dwReg & D3DSP_REGNUM_MASK)  >= D3DVS_TEMPREG_MAX_V1_1){
                ok = FALSE;
            }
            else {
                ok = TRUE;
            }
            break;
        case D3DSPR_ADDR:
			ok = true;
            break;
        case D3DSPR_RASTOUT:
        case D3DSPR_ATTROUT:
        case D3DSPR_TEXCRDOUT:
			ok = ! m_bStateShader;
            break;

        case D3DSPR_CONST:
			ok = m_bWritable != FALSE;
            if(ok && (dwReg & D3DVS_ADDRMODE_RELATIVE)){
			    Error(true, ERROR_ASM_INVALID_DESTINATION_REGISTER, "Can't use A0.x within a destination register.");
                goto LFail;
            }
			break;
		}
		if(!ok){
			Error(true, ERROR_ASM_INVALID_DESTINATION_REGISTER, "invalid destination register");
            goto LFail;
        }
    }

    return;

LFail:
    m_bFail = TRUE;
    return;
}


void
CD3DXAssembler::ValidateSrcRegister(DWORD dwReg)
{
    if(m_bPixel)
    {
        switch(dwReg & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP:
        case D3DSPR_INPUT:
        case D3DSPR_CONST:
        case D3DSPR_TEXTURE:
            break;

        default:
            Error(true, ERROR_ASM_INVALID_SOURCE_REGISTER, "invalid source register");
            goto LFail;
        }

        // Only valid swizzles: RGBA, AAAA, RGBB, BBBB
        switch(dwReg & D3DVS_SWIZZLE_MASK)
        {
        case D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W:
        case D3DVS_X_W | D3DVS_Y_W | D3DVS_Z_W | D3DVS_W_W:
        case D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_Z:
        case D3DVS_X_Z | D3DVS_Y_Z | D3DVS_Z_Z | D3DVS_W_Z:
            break;

        default:
            Error(true, ERROR_ASM_INVALID_SWIZZLE, "invalid swizzle");
            goto LFail;
        }

    }
    else
    {
        switch(dwReg & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP:
        case D3DSPR_INPUT:
        case D3DSPR_CONST:
        case D3DSPR_ADDR:
            break;

        default:
            Error(true, ERROR_ASM_INVALID_SOURCE_REGISTER, "invalid source register");
            goto LFail;
        }
    }

    return;

LFail:
    m_bFail = TRUE;
    return;
}


void
CD3DXAssembler::SetConstant(DWORD dwReg, D3DXVECTOR4* pVec)
{
    if(D3DSPR_CONST != (dwReg & D3DSP_REGTYPE_MASK))
        goto LFail;

    if(dwReg & D3DVS_ADDRMODE_RELATIVE)
        goto LFail;

    if(m_bPixel)
    {
        m_cbConst += 6 * sizeof(DWORD);

        m_Const.Push( D3DSIO_DEF );
        m_Const.Push(dwReg | D3DSP_WRITEMASK_ALL);
    }
    else
    {
        m_cbConst += 5 * sizeof(DWORD);

        m_Const.Push(D3DVSD_CONST( dwReg & D3DSP_REGNUM_MASK, 1 ));
    }

    m_Const.Push(*((DWORD *) &pVec->x));
    m_Const.Push(*((DWORD *) &pVec->y));
    m_Const.Push(*((DWORD *) &pVec->z));
    m_Const.Push(*((DWORD *) &pVec->w));

    return;

LFail:
    Error(true, ERROR_ASM_INVALID_CONSTANT, "invalid constant");
    m_bFail = TRUE;
    return;
}



void
CD3DXAssembler::UpdateDebugText()
{
    if(!m_bDebug)
        return;

    char *pch = m_pchSource;
    UINT_PTR cch = m_pchLim - pch;

    m_Code.Push(D3DSHADER_COMMENT(((cch + 3) >> 2) + 1));
    m_Code.Push(FOURCC_TEXT);
    m_cbCode += 2 * sizeof(DWORD);

    while(cch >= sizeof(DWORD))
    {
        m_Code.Push(*((DWORD *) pch));
        m_cbCode += sizeof(DWORD);

        pch += sizeof(DWORD);
        cch -= sizeof(DWORD);
    }

    if(cch)
    {
        DWORD dw = 0;
        memcpy(&dw, pch, cch);

        m_Code.Push(dw);
        m_cbCode += sizeof(DWORD);
    }

    if(cch == sizeof(DWORD))
    {
        m_Code.Push(0);
        m_cbCode += sizeof(DWORD);
    }
}


void
CD3DXAssembler::UpdateDebugFileLine()
{
    if(!m_bDebug)
    {
        m_iLineDebug = m_iLine;
        return;
    }

    // Update file name, if needed
    if(strcmp(m_szFileDebug, m_szFile))
    {
        char *pch = m_szFile;
        UINT cch = strlen(pch) + 1;

        m_Code.Push(D3DSHADER_COMMENT(((cch + 3) >> 2) + 1));
        m_Code.Push(FOURCC_FILE);
        m_cbCode += 2 * sizeof(DWORD);

        while(cch >= sizeof(DWORD))
        {
            m_Code.Push(*((DWORD *) pch));
            m_cbCode += sizeof(DWORD);

            pch += sizeof(DWORD);
            cch -= sizeof(DWORD);
        }

        if(cch)
        {
            DWORD dw = 0;
            memcpy(&dw, pch, cch);

            m_Code.Push(dw);
            m_cbCode += sizeof(DWORD);
        }

        strcpy(m_szFileDebug, m_szFile);
    }

    // Update line number, if needed
    if(m_iLineDebug != m_iLineNextToken)
    {
        m_Code.Push(D3DSHADER_COMMENT(2));
        m_Code.Push(FOURCC_LINE);
        m_Code.Push((DWORD) m_iLineNextToken);
        m_cbCode += 3 * sizeof(DWORD);

        m_iLineDebug = m_iLineNextToken;
    }
}

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\cd3dxassembler.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       compiler.h
//  Content:    Vertex Shader compiler
//
///////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
// CD3DXAssembler
//----------------------------------------------------------------------------

namespace XGRAPHICS {

class CD3DXAssembler
{
public: // So we don't have to declare a ton of friend functions

    XAsmCD3DXSzStack m_Id;
    XAsmCD3DXDwStack m_Number;
    XAsmCD3DXDwStack m_Float;
    XAsmCD3DXDwStack m_Param;
    XAsmCD3DXDwStack m_Opcode;
    XAsmCD3DXDwStack m_Const;
    XAsmCD3DXDwStack m_Code;

	XD3DXErrorLog* m_pErrorLog;
    BOOL  m_bFail;
    UINT  m_cbConst;
    UINT  m_cbCode;

    BOOL  m_bPixel;
	BOOL  m_bXbox;
	BOOL  m_bWritable;
	BOOL  m_bStateShader;
    BOOL  m_bScreenSpace; // For vertex shaders, whether or not to append postfix instructions.
    BOOL  m_bDebug;
    DWORD m_dwVersion;

    char* m_pchSource;
    char* m_pchLine;
    char* m_pch;
    char* m_pchLim;

    char  m_szTok[256];
    DWORD m_dwOpcode;
    DWORD m_dwShiftSat;

    UINT  m_iLineNextToken;
    UINT  m_iLine;
    char  m_szFile[256];

    UINT  m_iLineDebug;
    char  m_szFileDebug[256];

public:
    static CD3DXAssembler* s_pAsm;

public:
    CD3DXAssembler();
   ~CD3DXAssembler();

    HRESULT Assemble(LPCVOID pv, UINT cb, LPCSTR szFile, 
        UINT uLine, DWORD dwFlags, LPXGBUFFER* ppConstants, 
        LPXGBUFFER* ppCode, XD3DXErrorLog* pErrorLog,
        LPDWORD pShaderType);

    int  Token();
    void Production(UINT nProduction);
    void Error(bool error, DWORD code, LPCSTR psz, ...);
    void YYError(char *psz, ...);
    void Error2(bool error, DWORD code, LPCSTR psz, va_list list);

    int   DecodeOpcode();
    DWORD DecodeMask(char *psz);
    DWORD DecodeSwizzle(char *psz);
    DWORD DecodeRegister(char *psz, DWORD dwAddr, BOOL bIndex);

    void ValidateDstRegister(DWORD dwReg);
    void ValidateSrcRegister(DWORD dwReg);

    void SetConstant(DWORD dwReg, D3DXVECTOR4* pVec);

    void UpdateDebugText();
    void UpdateDebugFileLine();
};

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\cd3dxstack.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       stacks.h
//  Content:    Stacks
//
///////////////////////////////////////////////////////////////////////////

namespace XGRAPHICS {

//----------------------------------------------------------------------------
// XAsmCD3DXDwStack
//----------------------------------------------------------------------------


class XAsmCD3DXDwStack
{
    DWORD *m_pdw;

    UINT m_cdw;
    UINT m_cdwLim;

    HRESULT m_hr;

public:
    XAsmCD3DXDwStack();
    ~XAsmCD3DXDwStack();

    HRESULT Push(DWORD dw);
    HRESULT Pop (DWORD *pdw);

    HRESULT GetLastError();
};


//----------------------------------------------------------------------------
// XAsmCD3DXSzStack
//----------------------------------------------------------------------------

class XAsmCD3DXSzStack
{
    char **m_ppsz;
    UINT m_cpsz;
    UINT m_cpszLim;
    HRESULT m_hr;

public:
    XAsmCD3DXSzStack();
    ~XAsmCD3DXSzStack();

    HRESULT Push(char *psz);
    HRESULT Pop (char **ppsz);

    HRESULT GetLastError();
};

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\pushbuffer\pushbuffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pushbuffer.c
 *  Content:    push buffer compiler.
 *
 ****************************************************************************/

#if XBOX
    #include "xtl.h"
#else 
    #include "windows.h"
    #include "d3d8-xbox.h"
#endif

#include "xgraphics.h"
#include "debug.h"

namespace XGRAPHICS
{

// PUSHBUFFER_RETURN_RESERVE is the number of bytes reserved by D3D at
// the end of the push-buffer for the return-JUMP instruction:

#define PUSHBUFFER_RETURN_RESERVE 4

// ARRAY_ELEMENT16_BATCH is the maximum number of dwords that can be
// encoded by D3DPUSH_ENCODE:

#define ARRAY_ELEMENT16_BATCH 2047

#define D3DPUSH_ARRAY_ELEMENT16         0x00001800
#define D3DPUSH_ARRAY_ELEMENT32         0x00001808
#define D3DPUSH_NO_OPERATION            0x00000100

//------------------------------------------------------------------------------
// XGCompileDrawIndexedVertices

extern "C"
HRESULT WINAPI XGCompileDrawIndexedVertices(
    void *pBuffer,
    DWORD *pSize, // In-out
    D3DPRIMITIVETYPE PrimitiveType,
    UINT VertexCount,
    CONST WORD *pIndexData
    )
{
    BOOL writeBuffer = FALSE;
    DWORD* pPush = NULL;
    DWORD countCopy = VertexCount;
    CONST WORD *pDataCopy = pIndexData;

    for (DWORD loop = 0; loop < 2; loop++)
    {
        DWORD slots = 0;
    
        if (writeBuffer)
        {
            pPush[0] = D3DPUSH_ENCODE(D3DPUSH_SET_BEGIN_END, 1);
            pPush[1] = PrimitiveType;
        }
        pPush += 2;
        slots += 1;
    
        while (VertexCount > 2 * ARRAY_ELEMENT16_BATCH)
        {
            if (writeBuffer)
            {
                pPush[0] = D3DPUSH_NOINCREMENT_FLAG
                         | D3DPUSH_ENCODE(D3DPUSH_ARRAY_ELEMENT16, ARRAY_ELEMENT16_BATCH);
        
                memcpy(pPush + 1, pIndexData, ARRAY_ELEMENT16_BATCH * sizeof(DWORD));
            }
    
            pIndexData += 2 * ARRAY_ELEMENT16_BATCH;
            VertexCount -= 2 * ARRAY_ELEMENT16_BATCH;
    
            pPush += ARRAY_ELEMENT16_BATCH + 1;
            slots += ARRAY_ELEMENT16_BATCH;
        }
    
        // Note that it's okay if we send an Element16 command with zero entries
        // (for the case where the vertex count given to us is less than 3):
    
        DWORD arrayCount = VertexCount >> 1;
        if (writeBuffer)
        {
            pPush[0] = D3DPUSH_NOINCREMENT_FLAG 
                     | D3DPUSH_ENCODE(D3DPUSH_ARRAY_ELEMENT16, arrayCount);
        
            memcpy(pPush + 1, pIndexData, arrayCount * sizeof(DWORD));
        }
    
        pIndexData += 2 * arrayCount;

        pPush += arrayCount + 1;
        slots += arrayCount;
    
        // Handle the last odd index.  Since we only have one index left, we
        // obviously can't whack ELEMENT16, since that takes pairs of indices...
    
        if (VertexCount & 1)
        {
            if (writeBuffer)
            {
                pPush[0] = D3DPUSH_ENCODE(D3DPUSH_ARRAY_ELEMENT32, 1);
                pPush[1] = (DWORD) (*pIndexData);
            }
    
            pPush += 2;
            slots += 1;
        }
    
        if (writeBuffer)
        {
            pPush[0] = D3DPUSH_ENCODE(D3DPUSH_SET_BEGIN_END, 1);
            pPush[1] = 0;
        }

        pPush += 2;
        slots += 1;

        // 'totalSlots' is the total number of instruction pairs (offset, value)
        // that fit in the GPU's read-ahead FIFO cache.
        //
        // (1024 + 32) should be the same as PUSHER_MINIMUM_RUN_OFFSET:
    
        const INT totalSlots = (1024 + 32)/8;
        INT nops = totalSlots - slots;
        if (nops > 0)
        {
            // We need to stick in some NOPs so that the GPU read-ahead hasn't
            // already read the return-JUMP before we've had a chance to
            // do its fixup:

            if (writeBuffer)
            {
                pPush[0] = D3DPUSH_NOINCREMENT_FLAG
                         | D3DPUSH_ENCODE(D3DPUSH_NO_OPERATION, nops);
                ZeroMemory(pPush + 1, nops * sizeof(DWORD));
            }
    
            pPush += nops + 1;
            slots += nops;
        }

        if (slots < totalSlots)
            DXGRIP("Invalid internal padding");

        if (loop == 0)
        {
            DWORD sizeNeeded = (DWORD) pPush + PUSHBUFFER_RETURN_RESERVE;
            DWORD givenSize = *pSize;

            *pSize = sizeNeeded;

            if (pBuffer == NULL)
                return S_OK;

            if (givenSize < sizeNeeded)
                return D3DERR_BUFFERTOOSMALL;

            writeBuffer = TRUE;

            pPush = (DWORD*) pBuffer;
            VertexCount = countCopy;
            pIndexData = pDataCopy;
        }
    }

    return S_OK;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\errorcodes.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// Error codes for localization of the shader assembler error messages.
///////////////////////////////////////////////////////////////////////////////

// Preprocessor error codes

#define ERROR_UNKNOWNPREPROCESSORDIRECTIVE 1
#define ERROR_ERRORDIRECTIVE 2
#define ERROR_SYMBOLEXPECTED 3
#define ERROR_SYMBOLALREADYDEFINED 4
#define ERROR_CANTOPENFILE 5
#define ERROR_TOOMANYLEVELSOFINCLUDE 6
#define ERROR_MISSINGRESOLVER 7
#define ERROR_FILENAMENOTQUOTED 8
#define ERROR_FILENAMEMISSING 9
#define ERROR_INCLUDENAMETOOLONG 10
#define ERROR_EXPANDEDMACROTOOLONG 11
#define ERROR_SOURCELINETOOLONG 12
#define ERROR_EXPECTEDMACRONAME 13
#define ERROR_EXPECTEDENDM 14
#define ERROR_MACROARGUMENTSYNTAX 15
#define ERROR_EXPECTEDMACROPARAMETER 16
#define ERROR_TOOMANYLEVELSOFIF 17
#define ERROR_UNEXPECTEDELSE 18
#define ERROR_UNEXPECTEDENDIF 19
#define ERROR_EXPECTEDENDIF 20
#define ERROR_DONTHANDLEIF 21
#define ERROR_DONTHANDLEELIF 22
#define ERROR_UNTERMINATED_C_STYLE_COMMENT 23
#define ERROR_EXPECTED_CLOSE_PAREN 24
#define ERROR_EXPECTEDOPENBRACE 25
#define ERROR_EXPECTEDCLOSEBRACE 26
#define ERROR_BADENUM 27


// Assember error codes

#define WARNING_ASM_UNKNOWN_PRAGMA 100
#define ERROR_ASM_UNSUPPORTED_PREPROCESSOR_DIRECTIVE 101
#define ERROR_ASM_INVALID_VERSION 102
#define ERROR_ASM_COMPLEMENT_NOT_SUPPORTED 103
#define ERROR_ASM_COMPLEMENT_CANNOT_BE_USED_WITH_OTHER_MODIFIERS 104
#define ERROR_ASM_VALIDATOR_ERROR 105
#define ERROR_ASM_SYNTAX_ERROR 106
#define ERROR_ASM_ILLEGAL_REGISTER_IN_INDEX_EXPRESSION 107
#define ERROR_ASM_A0_X_CAN_ONLY_APPEAR_ONCE_IN_AN_INDEX_EXPRESSION 108
#define ERROR_ASM_INTERNAL_ASSEMBLER_ERROR 109
#define ERROR_ASM_INVALID_MASK 110
#define ERROR_ASM_INVALID_SWIZZLE 111
#define ERROR_ASM_INVALID_REGISTER 112
#define ERROR_ASM_SOURCE_MODIFIERS_NOT_ALLOWED_ON_DESTINATION_REGISTERS 113
#define ERROR_ASM_INVALID_DESTINATION_REGISTER 114
#define ERROR_ASM_INVALID_WRITE_MASK 115
#define ERROR_ASM_INVALID_SOURCE_REGISTER 116
#define ERROR_ASM_INVALID_CONSTANT 117
#define ERROR_ASM_EXPECTED_VERSION 118
#define ERROR_ASM_INVALID_INSTRUCTION_COMBINATION 119
#define ERROR_ASM_INVALID_INSTRUCTION 120
#define ERROR_ASM_OPTIMIZER_INTERNAL_ERROR 121
#define ERROR_INPUT_MICROCODE_FORMAT 122
#define ERROR_ASM_CANT_PAIR_OPCODES 123
#define ERROR_ASM_CANT_PAIR_INPUTS 124
#define ERROR_ASM_CANT_PAIR_INPUT_SWIZZLES 125
#define ERROR_ASM_CANT_PAIR_OUTPUTS 126
#define ERROR_ASM_A0_X_CANT_BE_NEGATED 127
// DX8 Token to Microcode compiler

#define ERROR_TOOMANYINSTRUCTIONS 600
#define ERROR_NOTEMPORARYREGISERAVAILABLE 601
#define WARNING_UNSUPPORTEDMACRO 602
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\api.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       api.cpp
//  Content:    The public api functions for the shadeasm library
//					Includes most vertex shader code
//
///////////////////////////////////////////////////////////////////////////
#include "pchshadeasm.h"

namespace XGRAPHICS
{

// Local Debug flags
#ifdef DBG

//#define DBG_REORDERER
//#define DBG_STRIPPER
//#define DBG_PRINT_PRE_OPTIMIZED
//#define DBG_PRINT_OPTIMIZED
//#define DBG_PAIRER
//#define DBG_RENAMER
//#define DBG_VERIFIER
//#define DBG_SPLICER

//#define VERIFY_EACH_STEP // Slow, but helps debug optimizer bugs

//#define DISABLE_STRIPPER
//#define DISABLE_RENAMER
//#define DISABLE_REORDERER
//#define DISABLE_PEEPHOLE
//#define DISABLE_PAIRER1
//#define DISABLE_PAIRER2
//#define DISABLE_VERIFIER

// Fine grain control of Reorderer
//#define DISABLE_MOVE_AND_PAIR
//#define DISABLE_MOVES_TOWARDS_BEGINNING
//#define DISABLE_MOVES_TOWARDS_BEGINNING_AFTER_MOVE_NUMBER 7
//#define DISABLE_PAIRS_AFTER_PAIR_NUMBER 7

#endif

#define DISABLE_TREE_PRINT 

// To keep the Xbox non-debug runtime small, we don't include the verifier or the validator.

#if defined(XBOX) && !defined(DBG)
#define DISABLE_VERIFIER
#define DISABLE_VALIDATOR
#endif



HRESULT D3DTokensToUCode (const DWORD* pTokens, D3DVertexShaderProgram* pProg, XD3DXErrorLog* pErrorLog);


#ifndef DISABLE_VERIFIER
bool Verify(class VerTable* pa, class VerTable* pb, XD3DXErrorLog* pErrorLog);
bool Verify(class VerTable* pa, D3DVertexShaderProgram * pb, const char* ptitle);
bool Verify(D3DVertexShaderProgram * pa, D3DVertexShaderProgram * pb, XD3DXErrorLog* pErrorLog);
#else
#define Verify(pa,pb,pc) (true)
#endif

#define E_OPTIMIZER_FAILED -4123
#define E_ASSEMBLER_FAILED -4124 

#ifdef VERIFY_EACH_STEP
#define VerifyStep(pa,pb,pc) (pa ? (Verify(pa,pb,pc) ? S_OK : E_OPTIMIZER_FAILED) : S_OK)
#else
#define VerifyStep(pa,pb,pc) (S_OK)
#endif


// Forward reference to some debug helpers
#ifdef DBG
void DPF2(const char* message,...);

void Print(D3DVsInstruction& instruction);
void Print(DWORD shaderType, D3DVertexShaderProgram& program);
void PrintInstruction(int address, const D3DVsInstruction* pI);
void PrintInstruction(int address, const D3DVertexShaderProgram* pUcode);
#endif

bool Pairable(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b);
bool ForcedPair(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b,
                DWORD* pReason);

// ignoring swizzle, which compontents of the input arguments are used
// by this opcode?
// Results is a 3 character array, where results[0] = arg a's mask,
// Mask bit order is the same as the output mask
void ComputePostSwizzleUseMasks(const D3DVsInstruction* pI, UCHAR* results);
void ComputeEffectiveSwizzles(const D3DVsInstruction* a, char* pSwizzles);
bool MergeSwizzles(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b);
bool SwapAC(D3DVsInstruction* pOut, const D3DVsInstruction* pIn);
void StripMacInstruction(D3DVsInstruction* pI);
UCHAR ComputeEffectiveReadMask(const D3DVsInstruction* a, int channel);


struct PaddedUCode {
    DWORD padding;  // Should be zero.
    D3DVsInstruction ucode;
};

bool Epsilon(float a, float b, float e) {
	if(((a - b) < e) && ((a - b) > -e)) 
		return true;
	else
		return false;
}
// Thunks

extern "C" 
ULONG   WINAPI XGBuffer_AddRef(XGBuffer *pThis){
    pThis->refCount += 1;
    return pThis->refCount;
}

extern "C" 
ULONG   WINAPI XGBuffer_Release(XGBuffer *pThis){
    ULONG cRef = pThis->refCount;
    pThis->refCount -= 1;

    if (cRef == 1){
        delete pThis->pData;
        delete pThis;
    }

    return cRef-1;
}

extern "C" 
LPVOID WINAPI XGBuffer_GetBufferPointer(XGBuffer *pThis){
    return pThis->pData;
}

extern "C" 
DWORD WINAPI XGBuffer_GetBufferSize(XGBuffer *pThis){
    return pThis->size;
}

extern "C" 
HRESULT WINAPI XGBufferCreate(DWORD numBytes, LPXGBUFFER* ppBuffer){
    LPXGBUFFER pBuffer = new XGBuffer();
    if(!pBuffer){
        return E_OUTOFMEMORY;
    }
    pBuffer->refCount = 1;
    pBuffer->pData = new char[numBytes];
    pBuffer->size = numBytes;
    if(! pBuffer->pData){
        delete pBuffer;
        return E_OUTOFMEMORY;
    }
    *ppBuffer = pBuffer;
    return S_OK;
}

// class Buffer

Buffer::Buffer(){
    m_size = 0;
    m_buf = 0;
    m_used = 0;
}

Buffer::~Buffer(){
    delete [] m_buf;
}

HRESULT Buffer::Initialize(DWORD size){
    m_used = 0;
    return GrowTo(size);
}

HRESULT Buffer::GrowTo(DWORD size){
    HRESULT hr = S_OK;
    if(size + 1 > m_size){
        size += 4*1024;
        char* newBuf = new char[size];
        if(!newBuf){
            SETERROR(hr, E_OUTOFMEMORY);
        }
        else{
            memcpy(newBuf,m_buf, m_used);
            delete [] m_buf;
            m_buf = newBuf;
            m_size = size;
            m_buf[m_used] = 0;
        }
    }
    return hr;
}

HRESULT Buffer::Printf(const char* msg,...){
    HRESULT hr = S_OK;
    if(m_size - m_used < 1000){
        hr = GrowTo(m_size + 2000);
    }
    if(SUCCEEDED(hr)){
        va_list list;
        va_start(list, msg );
        m_used += _vsnprintf(m_buf + m_used, m_size - m_used, msg, list);
        va_end(list);
    }
    return hr;
}

HRESULT Buffer::Append(LPCVOID data, DWORD length){
    HRESULT hr = GrowTo(m_used + length);
    if(SUCCEEDED(hr)){
        memcpy(m_buf + m_used, data, length);
        m_used += length;
        m_buf[m_used] = '\0';
    }
    return hr;
}

HRESULT Buffer::Append(char c){
    return Append(&c, sizeof(char));
}

HRESULT Buffer::Append(const char* c){
    return Append(c, strlen(c));
}

HRESULT Buffer::Append(Buffer& buffer){
    return Append(buffer.GetText(), buffer.GetUsed());
}


char* Buffer::GetText(){
    return m_buf;
}

char* Buffer::GetTextEnd(){
    return m_buf + m_used;
}

DWORD Buffer::GetUsed(){
    return m_used;
}

void Buffer::Clear(){
    m_used = 0;
    if(m_buf){
        m_buf[0] = 0;
    }
}

static const bool kMacUsesA[] = {
    false, // MAC_NOP        0x00
    true, // MAC_MOV        0x01
    true, // MAC_MUL        0x02
    true, // MAC_ADD        0x03
    true, // MAC_MAD        0x04
    true, // MAC_DP3        0x05
    true, // MAC_DPH        0x06
    true, // MAC_DP4        0x07
    true, // MAC_DST        0x08
    true, // MAC_MIN        0x09
    true, // MAC_MAX        0x0a
    true, // MAC_SLT        0x0b
    true, // MAC_SGE        0x0c
    true, // MAC_ARL        0x0d
    false, // dummy 0xe
    false, // dummy 0xf
};

static const bool kMacUsesB[] = {
    false, // MAC_NOP        0x00
    false, // MAC_MOV        0x01
    true,  // MAC_MUL        0x02
    false, // MAC_ADD        0x03
    true,  // MAC_MAD        0x04
    true,  // MAC_DP3        0x05
    true,  // MAC_DPH        0x06
    true,  // MAC_DP4        0x07
    true,  // MAC_DST        0x08
    true,  // MAC_MIN        0x09
    true,  // MAC_MAX        0x0a
    true,  // MAC_SLT        0x0b
    true,  // MAC_SGE        0x0c
    false, // MAC_ARL        0x0d
    false, // dummy 0xe
    false, // dummy 0xf
};

static const bool kMacUsesC[] = {
    false, // MAC_NOP        0x00
    false, // MAC_MOV        0x01
    false, // MAC_MUL        0x02
    true,  // MAC_ADD        0x03
    true,  // MAC_MAD        0x04
    false, // MAC_DP3        0x05
    false, // MAC_DPH        0x06
    false, // MAC_DP4        0x07
    false, // MAC_DST        0x08
    false, // MAC_MIN        0x09
    false, // MAC_MAX        0x0a
    false, // MAC_SLT        0x0b
    false, // MAC_SGE        0x0c
    false, // MAC_ARL        0x0d
    false, // dummy 0xe
    false, // dummy 0xf
};

// Note that this is at the microcode level, not the DX8 level.
// The microcode uses component x for scalar operations, not component w
// as you might expect. (DX8's assembler forces the operation to be .xxxx, .yyyy. .zzzz, or .wwww,
// which masks this difference.)

const UCHAR kMACInputRegFixedComponentUse[16][3] = {
                   //       a---- b---- c----
    {0x0,0x0,0x0}, // 0 NOP
    {0x0,0x0,0x0}, // 1 MOV  
    {0x0,0x0,0x0}, // 3 MUL  
    {0x0,0x0,0x0}, // 4 ADD  
    {0x0,0x0,0x0}, // 5 MAD  
    {0xe,0xe,0x0}, // 6 DP3  xyz   xyz 
    {0xe,0xf,0x0}, // 7 DPH  xyz   xyzw
    {0xf,0xf,0x0}, // 8 DP4  xyzw  xyzw
    {0x6,0x5,0x0}, // 9 DST   yz    y w
    {0x0,0x0,0x0}, // a MIN  
    {0x0,0x0,0x0}, // b MAX  
    {0x0,0x0,0x0}, // c SLT  
    {0x0,0x0,0x0}, // d SGE  
    {0x8,0x0,0x0}, // d ARL  x     <--- yes, x and not w
    {0x0,0x0,0x0}, // e unknown
    {0x0,0x0,0x0}, // f unknown
};

const UCHAR kMACInputRegColumnatedComponentUse[16][3] = {
                   //       a---- b---- c----
    {0x0,0x0,0x0}, // 0 NOP
    {0xf,0x0,0x0}, // 1 MOV  xyzw
    {0xf,0xf,0x0}, // 3 MUL  xyzw  xyzw
    {0xf,0x0,0xf}, // 4 ADD  xyzw        xyzw
    {0xf,0xf,0xf}, // 5 MAD  xyzw  xyzw  xyzw
    {0x0,0x0,0x0}, // 6 DP3   
    {0x0,0x0,0x0}, // 7 DPH  
    {0x0,0x0,0x0}, // 8 DP4  
    {0x0,0x0,0x0}, // 9 DST  
    {0xf,0xf,0x0}, // a MIN  xyzw  xyzw
    {0xf,0xf,0x0}, // b MAX  xyzw  xyzw
    {0xf,0xf,0x0}, // c SLT  xyzw  xyzw
    {0xf,0xf,0x0}, // d SGE  xyzw  xyzw
    {0x0,0x0,0x0}, // d ARL  
    {0x0,0x0,0x0}, // e unknown
    {0x0,0x0,0x0}, // f unknown
};

// Note that this is at the microcode level, not the DX8 level.
// The microcode uses component x for scalar operations, not component w
// as you might expect. (DX8's assembler forces the operation to be .xxxx, .yyyy. .zzzz, or .wwww,
// which masks this difference.)

const UCHAR kILUInputRegFixedComponentUse[8][3] = {
                   //       a---- b---- c----
    {0x0,0x0,0x0}, // 0 NOP
    {0x0,0x0,0x0}, // 0 MOV              
    {0x0,0x0,0x8}, // 0 RCP              x       <--- yes, x and not w
    {0x0,0x0,0x8}, // 0 RCC              x
    {0x0,0x0,0x8}, // 0 RSQ              x
    {0x0,0x0,0x8}, // 0 EXP              x
    {0x0,0x0,0x8}, // 0 LOG              x
    {0x0,0x0,0xd}, // 0 LIT              xy w
};

const UCHAR kILUInputRegColumnatedComponentUse[8][3] = {
                   //       a---- b---- c----
    {0x0,0x0,0x0}, // 0 NOP
    {0x0,0x0,0xf}, // 0 MOV              xyzw
    {0x0,0x0,0x0}, // 0 RCP               
    {0x0,0x0,0x0}, // 0 RCC               
    {0x0,0x0,0x0}, // 0 RSQ               
    {0x0,0x0,0x0}, // 0 EXP               
    {0x0,0x0,0x0}, // 0 LOG               
    {0x0,0x0,0x0}, // 0 LIT               
};

static const char* kOutNames[] = {"oPos",
    "o1?", "o2?",
    "oD0", "oD1",
    "oFog", "oPts",
    "oB0", "oB1",
    "oT0", "oT1", "oT2", "oT3", "???"
};

struct OutPair {
    unsigned char m; // Mask
    unsigned char r; // register
    bool used;
};

void ExpandRegisterOutputMasks(OutPair* masks, const D3DVsInstruction* a);






//verifier: double-checks that the optimizers didn't break something
//The code can also be used to compare two vertex shaders for similarity.
//Basically, it builds a tree of all calculations performed in the shader,
//and includes code to compare two trees.
//Several more optimizations could be performed in the future, using these tree structures

#ifndef DISABLE_VERIFIER

//verifier debug-code
#ifdef DBG_VERIFIER
#define VER_ERR(_a_) do { DPF2##_a_ ; DPF2("\n"); _asm {int 3}; } while(0)
#define VER_MSG(_a_) do { DPF2##_a_ ; DPF2("\n"); } while(0)
#else
#ifdef DBG
#define VER_ERR(_a_) do { DPF2##_a_ ; DPF2("\n"); } while (0)
#define VER_MSG(_a_) do { } while (0)
#else
#define VER_ERR(_a_) do { } while (0)
#define VER_MSG(_a_) do { } while (0)
#endif
#endif

#define VER_NUM_REG ((REG_ARL * 4) + 2) //all regs, ARL, constlist
#define VER_NUM_CONSTS (96 * 2 * 4)

typedef int VerReg; //range from (0 to ARL * 4), inclusive

enum VerOpcode {
    VEROP_NOP =0,
    VEROP_MOV  ,
    VEROP_MUL ,
    VEROP_ADD ,
    VEROP_MAD ,
    VEROP_DP3 ,
    VEROP_DPH ,
    VEROP_DP4 ,
    VEROP_DST , //should not be used. Use dstx, dsty, dstz, dstw, or simplify to (ONE,MUL,MOV,MOV)
    VEROP_MIN ,
    VEROP_MAX ,
    VEROP_SLT ,
    VEROP_SGE ,
    VEROP_ARL ,
    VEROP_UNU1,
    VEROP_UNU2,
    VEROP_NOPX, //nop* == nop
    VEROP_NOPY, 
    VEROP_NOPZ, 
    VEROP_NOPW,
    VEROP_IMVX, //imv* == mov
    VEROP_IMVY, 
    VEROP_IMVZ, 
    VEROP_IMVW,
    VEROP_RCPX, //all destination registers equal ("X" form used for all calculations)
    VEROP_RCPY, 
    VEROP_RCPZ, 
    VEROP_RCPW,
    VEROP_RCCX, 
    VEROP_RCCY, 
    VEROP_RCCZ, 
    VEROP_RCCW,
    VEROP_RSQX, 
    VEROP_RSQY, 
    VEROP_RSQZ, 
    VEROP_RSQW,
    VEROP_EXPX, //destination registers not equal. Some duplicates exist (LOGW == ONE)
    VEROP_EXPY, 
    VEROP_EXPZ, 
    VEROP_EXPW,
    VEROP_LOGX, 
    VEROP_LOGY, 
    VEROP_LOGZ, 
    VEROP_LOGW,
    VEROP_LITX, 
    VEROP_LITY, 
    VEROP_LITZ, 
    VEROP_LITW,
    VEROP_DSTX, //The MAC exception: the 4 outputs involve different calculations...
    VEROP_DSTY, 
    VEROP_DSTZ, 
    VEROP_DSTW,
    VEROP_INVL,
    VEROP_ZERO,
    VEROP_ONE ,

    VEROP_FORCE_DWORD = 0x7fffffff
}; // enum VerOpcode

#ifdef DBG
void PrintVerOpcode(VerOpcode o) {
    switch (o) {
    case VEROP_NOP : DPF2("VEROP_NOP "); break;
    case VEROP_MOV : DPF2("VEROP_MOV "); break;
    case VEROP_MUL : DPF2("VEROP_MUL "); break;
    case VEROP_ADD : DPF2("VEROP_ADD "); break;
    case VEROP_MAD : DPF2("VEROP_MAD "); break;
    case VEROP_DP3 : DPF2("VEROP_DP3 "); break;
    case VEROP_DPH : DPF2("VEROP_DPH "); break;
    case VEROP_DP4 : DPF2("VEROP_DP4 "); break;
    case VEROP_DST : DPF2("VEROP_DST "); break;
    case VEROP_MIN : DPF2("VEROP_MIN "); break;
    case VEROP_MAX : DPF2("VEROP_MAX "); break;
    case VEROP_SLT : DPF2("VEROP_SLT "); break;
    case VEROP_SGE : DPF2("VEROP_SGE "); break;
    case VEROP_ARL : DPF2("VEROP_ARL "); break;
    case VEROP_UNU1: DPF2("VEROP_UNU1"); break;
    case VEROP_UNU2: DPF2("VEROP_UNU2"); break;
    case VEROP_NOPX: DPF2("VEROP_NOPX"); break;
    case VEROP_NOPY: DPF2("VEROP_NOPY"); break;
    case VEROP_NOPZ: DPF2("VEROP_NOPZ"); break;
    case VEROP_NOPW: DPF2("VEROP_NOPW"); break;
    case VEROP_IMVX: DPF2("VEROP_IMVX"); break;
    case VEROP_IMVY: DPF2("VEROP_IMVY"); break;
    case VEROP_IMVZ: DPF2("VEROP_IMVZ"); break;
    case VEROP_IMVW: DPF2("VEROP_IMVW"); break;
    case VEROP_RCPX: DPF2("VEROP_RCPX"); break;
    case VEROP_RCPY: DPF2("VEROP_RCPY"); break;
    case VEROP_RCPZ: DPF2("VEROP_RCPZ"); break;
    case VEROP_RCPW: DPF2("VEROP_RCPW"); break;
    case VEROP_RCCX: DPF2("VEROP_RCCX"); break;
    case VEROP_RCCY: DPF2("VEROP_RCCY"); break;
    case VEROP_RCCZ: DPF2("VEROP_RCCZ"); break;
    case VEROP_RCCW: DPF2("VEROP_RCCW"); break;
    case VEROP_RSQX: DPF2("VEROP_RSQX"); break;
    case VEROP_RSQY: DPF2("VEROP_RSQY"); break;
    case VEROP_RSQZ: DPF2("VEROP_RSQZ"); break;
    case VEROP_RSQW: DPF2("VEROP_RSQW"); break;
    case VEROP_EXPX: DPF2("VEROP_EXPX"); break;
    case VEROP_EXPY: DPF2("VEROP_EXPY"); break;
    case VEROP_EXPZ: DPF2("VEROP_EXPZ"); break;
    case VEROP_EXPW: DPF2("VEROP_EXPW"); break;
    case VEROP_LOGX: DPF2("VEROP_LOGX"); break;
    case VEROP_LOGY: DPF2("VEROP_LOGY"); break;
    case VEROP_LOGZ: DPF2("VEROP_LOGZ"); break;
    case VEROP_LOGW: DPF2("VEROP_LOGW"); break;
    case VEROP_LITX: DPF2("VEROP_LITX"); break;
    case VEROP_LITY: DPF2("VEROP_LITY"); break;
    case VEROP_LITZ: DPF2("VEROP_LITZ"); break;
    case VEROP_LITW: DPF2("VEROP_LITW"); break;
    case VEROP_DSTX: DPF2("VEROP_DSTX"); break;
    case VEROP_DSTY: DPF2("VEROP_DSTY"); break;
    case VEROP_DSTZ: DPF2("VEROP_DSTZ"); break;
    case VEROP_DSTW: DPF2("VEROP_DSTW"); break;
    case VEROP_INVL: DPF2("VEROP_INVL"); break;
    case VEROP_ZERO: DPF2("VEROP_ZERO"); break;
    case VEROP_ONE : DPF2("VEROP_ONE "); break;

    }
}
#endif

int VerOpParamCount(VerOpcode op) {
    switch (op) {
    case VEROP_NOP:
    case VEROP_NOPX: case VEROP_NOPY: case VEROP_NOPZ: case VEROP_NOPW:
    case VEROP_ZERO:
    case VEROP_ONE:
        return 0;

    case VEROP_MOV:
    case VEROP_IMVX: case VEROP_IMVY: case VEROP_IMVZ: case VEROP_IMVW:
        return 1;

    case VEROP_ADD:
    case VEROP_MUL:
        return 2;

    case VEROP_MAD:
        return 3;

    case VEROP_SLT:
    case VEROP_SGE:
    case VEROP_MIN:
    case VEROP_MAX:
        return 2;

    case VEROP_DP3:
        return 6;

    case VEROP_DPH:
        return 7;

    case VEROP_DP4:
        return 8;

    case VEROP_DSTX:
        return 0;
    case VEROP_DSTY:
        return 2;
    case VEROP_DSTZ:
    case VEROP_DSTW:
        return 1;

    
    case VEROP_EXPX:
    case VEROP_EXPY:
    case VEROP_EXPZ:
        return 1;
    case VEROP_EXPW:
        return 0;

    case VEROP_LITX:
        return 0;
    case VEROP_LITY:
        return 1; //x
    case VEROP_LITZ:
        return 3; //x,y,w
    case VEROP_LITW:
        return 0;

    case VEROP_LOGX:
    case VEROP_LOGY:
    case VEROP_LOGZ:
        return 1;
    case VEROP_LOGW:
        return 0;


    case VEROP_RCPX: case VEROP_RCPY: case VEROP_RCPZ: case VEROP_RCPW:
    case VEROP_RSQX: case VEROP_RSQY: case VEROP_RSQZ: case VEROP_RSQW:
    case VEROP_RCCX: case VEROP_RCCY: case VEROP_RCCZ: case VEROP_RCCW:
        return 1;

    case VEROP_DST:
        VER_ERR(("OpParamCount: DST performs different calculations for each output param. Use DST* instead."));
        return 0;

    default:
        VER_ERR(("OpParamCount: invalid op: %d", op));
        return 0;
    }
}

//contains calculations for all constant registers. 
//A new list is created when a constant is written in a shader program
class VerConstTableList {
public:
    class VerTable* mpData;
    VerConstTableList* mpNext;
    VerConstTableList():mpData(0),mpNext(0){}
    bool SetData(VerTable*ptable);
    ~VerConstTableList();
};

//just a single-linked list used in class VerOp, to keep track of similar operations
class VerOpList {
public:
    class VerOp* mpData;
    VerOpList* mpNext;
    VerOpList():mpData(0),mpNext(0){}

	//add more data just after this list node
    void SetData(VerOp*pOp) {
        VerOpList *pl = mpNext;
        mpNext = new VerOpList;
        if(mpNext) {
            mpNext->mpNext = pl;
            mpNext->mpData = pOp;
        }
        else {
            mpNext = pl; //yikes, tiny allocation failed!
        }

    }

	//find data "pOp" in this element, or after this element, in the list
	//return true if it is found, false if not.
    bool FindData(VerOp*pOp) {
        for(VerOpList* pl = this; pl; pl = pl->mpNext) {
            if(pl->mpData == pOp) {
                return true;
            }
        }
        return false;
    }

	//delete the entire list
    ~VerOpList() {
        delete mpNext;
    }
};


//VerOp: a "branch" in the opration tree. Keeps track of parameters to the operation performed, the type of operation, etc
class VerOp {
private:
    VerOp():mRefCount(0),mNumParams(0),mpParams(0),mpSame(0) {} //yes, private. Use Copy, MakeOp, or MakeEmptyOp to create a new op.
    int mRefCount;
    ~VerOp(){ Cleanup(); }
    //cleanup
    void Cleanup(); //cleans up all pointers & stuff inside of this VerOp.

public:
    int AddRef() { return ++mRefCount; } 
    int Release() { 
        if(!--mRefCount) {
            delete this;
            return 0;
        }
        return mRefCount;
    }

    //data
    VerOpcode mOp; //the operation performed
    int mNumParams; //number of params used in the operation
    class VerNode* mpParams; //pointer to array of params
    
    //creation
    static VerOp* MakeOpV(VerOpcode op, int numparams, class VerNode** ppv); //same as below, except pass a pointer to array of numparams VerNode*'s.
    static VerOp* MakeOp(VerOpcode op, int numparams, ...); //Create a new VerOp, passing the specified number of VerNode* for the ...'s. Return NULL if no mem.
    static VerOp* MakeEmptyOp(VerOpcode op, int numparams = -1); //create a new empty VerOp. NULL if no mem.
    VerOp* Copy(); //AddRefs this, returns this. This should be called when a node is duplicated, so we don't end up with duplicate trees.
    VerOp* CopyTree(); //create a duplicate of this VerOp. Returns pointer to the new VerOp, or NULL if no memory
    
    VerOpList* mpSame; //list of ops that are the same as this one. Note: this is used and clobbered by Verify()
};

typedef bool (*VERNODEFUNC)(VerNode*);

//VerNode: holds the state of a register at a given time. 
//These correspond to parameters used in VerOps

class VerNode {
public:
    bool mbHasReg;   //if this register is either untouched, or has been the destination of only a MOV
    bool mbHasOp;    //if this register contains the result of an opration
    bool mbHasTable; //true if the register uses a0.x after a constant has been written
    bool mbNegated;  
    VerReg mReg;	//uses a slight variation of the register enumeration: multiply the enum value by 4, and add 0 for .x, 1 for .y, etc.
    class VerOp*    mpOp; //null if mbHasOp is false

    class VerTable* mpTable; //if table exists, arl is also required.
    class VerNode*  mpArl;   //pointer to a0.x, if it is used in the contents of this register

    VerNode():mbHasReg(false),mbHasOp(false),mbHasTable(false), mbNegated(false), 
        mReg(-1), mpOp(NULL), mpTable(NULL), mpArl(NULL)
    {
    }

    ~VerNode() { Cleanup(); }
    
	//duplicate the contents of another VerNode into the current one 
    bool CopyFrom(VerNode* p)
    {
        Cleanup();
        mbHasOp = p->mbHasOp;
        mbHasReg = p->mbHasReg;
        mbHasTable = p->mbHasTable;
        mpTable = p->mpTable;
        mbNegated = p->mbNegated;
        mReg = p->mReg;
        if(mbHasOp) {
            mpOp = p->mpOp->Copy();
            if(mpOp ==  NULL) {
                VER_ERR(("VerNode::CopyFrom: mpOp->Copy failed."));
                mbHasOp = false;
                Cleanup();
                return false;
            } 
        } else {
            mpOp = NULL; //should be null anyway...
        }
        if(mbHasTable) {
            mpArl = p->mpArl->Copy();
        }
        return true;
    }
    
	//create a new VerNode that is a duplicate of "this"
    VerNode* Copy() 
    {
        VerNode* p = new VerNode;
        if(p == NULL) {
            VER_ERR(("VerNode::Copy: couldn't create new node!"));
            return NULL;
        }
        if(false == p->CopyFrom(this)) {
            VER_ERR(("VerNode::Copy: CopyFrom(this) failed!"));
            delete p;
            return NULL;
        }
        return p;
    }
    
	//create a new node, point it to the VerOp provided
	//note: the verop is assumed to have just been created, so we don't add-ref it here
    static VerNode* EncaseOpWithNode(VerOp* pop) {
        VerNode* p = new VerNode;
        if(!p) {
            VER_ERR(("VerNode::EncaseOpWithNode: new VerNode returned NULL!"));
            return NULL;
        }
        if(pop) {
            p->mbHasOp = true;
            p->mpOp = pop;
        } else {
            VER_MSG(("VerNode: EncaseOpWithNode was passed a NULL VerOp*!"));
            //nothing. Already initialized to NULL...
        }
        return p;
    }

	//let "this" use the VerOp provided. AddRef the verop, since others are using it already
    void UseOp(VerOp* pop) { 
        Cleanup();
        mbHasOp = true;
        mpOp = pop;
        if(pop) pop->AddRef();
    }

    void Cleanup() 
    {
        if(mbHasOp) {
            if(mpOp) mpOp->Release();
            mpOp = NULL;
            mbHasOp = false;
        }
        
        if(mbHasTable) {
            //Tables are global, and are freed at the end of verification, 
            //so that we only need one table if no constant registers are 
            //written to. However, mpArl is unique to this VerNode, so delete it.
            delete mpArl;
        } 
        
        mbHasReg = mbHasOp = mbHasTable = mbNegated = false;
        mReg = -1;
        mpOp = NULL;
        mpTable = NULL;
        mpArl = NULL;
    }

	//some puny validation code, to make sure the verifier didn't mess up
    bool TinyValidate()
    {
        if(mbHasReg && (mReg == -1 || (mReg >= REG_R0 * 4 && mReg < REG_R15 * 4 + 4))) {
            return false;
        }
        if(mbHasOp && (mpOp->mOp == VEROP_NOPX || mpOp->mOp == VEROP_NOP)) {
            return false;
        }
        return true;
    }
};


bool BreakUpMad(VerNode* pn) //breaks up MAD instruction into MUL + ADD. Returns true if any were changed.
{
    if(!pn->mbHasOp) return false;

    if(pn->mpOp->mOp == VEROP_MAD) {
        if(pn->mpOp->mNumParams != 3) {
            VER_ERR(("mad with %d params???", pn->mpOp->mNumParams));
            return false;
        }
        
        //create the MUL op, using params 0 and 1
        VerOp* pop = VerOp::MakeOp(VEROP_MUL, 2, &pn->mpOp->mpParams[0], &pn->mpOp->mpParams[1]);
        VerNode* pmulnode;
        if(!pop) {
            VER_ERR(("BreakUpMad: MakeOp returned NULL!"));
            return false;
        }
        pmulnode = VerNode::EncaseOpWithNode(pop); //encase the mul Op with a Node so it can be used in other Ops
        if(!pmulnode) {
            pop->Release();
            VER_ERR(("BreakUpMad: EncaseOpWithNode returned NULL!"));
            return false;
        }
        
        //make the add node, adding param2 to results of the mul
        pop = VerOp::MakeOp(VEROP_ADD, 2, pmulnode, &pn->mpOp->mpParams[2]);
        delete pmulnode;  //makeop makes a copy of the params... we don't need pmulnode any more.
        
        if(!pop) {
            VER_ERR(("BreakUpMad: MakeOp returned NULL!"));
            return false;
        }
        
        pn->mpOp->Release();
        pn->mpOp = pop; 
        return true;
    }
    return false;
}

//delete the "buddies" list, of a VerNode. 
//Call this if the node ever changes...
bool ClobberSameList(VerNode* pn) 
{
    if(!pn->mbHasOp) return false;

    if(pn->mpOp->mpSame) {
        delete pn->mpOp->mpSame;
        pn->mpOp->mpSame = 0;
        return true;
    }
    return false;
}

//create a VerOp, retrieving the parameters using an array of their addresses
VerOp* VerOp::MakeOpV(VerOpcode op, int numparams, VerNode** ppv) 
{
    VerOp* p = MakeEmptyOp(op, numparams);
    if(p == NULL) {
        VER_ERR(("VerOp::MakeOpV : MakeEmptyOp failed!"));
        return p;
    }
    
    int i;

    for(i = 0; i < p->mNumParams; i++) {
        if(false == p->mpParams[i].CopyFrom(*ppv++)) {
            VER_ERR(("VerOp::MakeOpV : CopyFrom failed!"));
            for(i--; i >= 0; i--) {
                p->mpParams[i].Cleanup();
            }
            p->mNumParams = 0;
            p->Release();
            return NULL;
        }
    }
    return p;
}

//see MakeOpV
VerOp* VerOp::MakeOp(VerOpcode op, int numparams, ...) //all params after op should be VerNode*'s.
{
    VerOp* p;
    p = MakeOpV(op, numparams, (VerNode**)((&numparams) + 1) );
    if(!p) {
        VER_ERR(("VerOp::MakeOp: MakeOpV failed!"));
    }
    return p;
}

//allocate an empty VerOp
VerOp* VerOp::MakeEmptyOp(VerOpcode op, int numparams) 
{
    int c;
    VerOp* p = new VerOp;
    if(p == NULL) {
        VER_ERR(("VerOp::MakeEmptyOp: new VerOp failed!"));
        return NULL;
    }
    p->AddRef();
    if(numparams == -1) {
        c = VerOpParamCount(op);
    } else {
        c = numparams;
    }
    p->mpParams = new VerNode[c];
    if(!p->mpParams) { 
        VER_ERR(("VerOp::MakeEmptyOp: new VerNode[%d] failed", c));
        p->Release(); 
        return NULL; 
    }
    p->mOp = op;
    p->mNumParams = c;
    return p;
}

//duplicate a VerOp and all parameters used by it (not recursive though)
//this isn't used, but could be useful...
VerOp* VerOp::CopyTree()
{
    int i;
    VerOp* p = MakeEmptyOp(mOp, mNumParams);
    if(!p) {
        VER_ERR(("VerOp::Copy: MakeEmptyOp(%d, %d) returned NULL!", mOp, mNumParams));
        return NULL;
    }
    for(i = 0; i < p->mNumParams; i++) {
        if(false == p->mpParams[i].CopyFrom(&mpParams[i])) {
            VER_ERR(("VerOp::Copy: CopyFrom failed!"));
            for(i--; i >= 0; i--) {
                p->mpParams[i].Cleanup();
            }
            p->Release();
            return NULL;
        }
    }
    return p;
}

//The majority of the time that you want to "copy" a VerOp, the original won't be changing, so
//a simple "addref" will do. If you need to duplicate a VerOp and its parameters, use CopyTree above
VerOp* VerOp::Copy() 
{
    AddRef();
    return this;
}

void VerOp::Cleanup() 
{
    int i;
    for(i = 0; i < mNumParams; i++) {
        mpParams[i].Cleanup();
    }
    mNumParams = 0;
    mOp = VEROP_INVL;
    delete[] mpParams;
    mpParams = NULL;
    delete mpSame;
    mpSame = NULL;

}

class VerTable {
private:
    VerTable(){}; //yes, private. Use MakeTable to create a VerTable.

	//call f() for all VerNodes in the tree. 
	//Recursive.
    bool Propegate2(VERNODEFUNC f, VerNode* pn, void* p) 
    {
        bool ret = false;
        int i;
        VerOpList* pv = *((VerOpList**)p);
        if(pv == 0) {
            pv = new VerOpList;
            if(!pv) return false;
        }
    

        if(pn->mbHasOp) {
            if(pv->FindData(pn->mpOp)) return ret;
            pv->SetData(pn->mpOp);
            for(i = 0; i < pn->mpOp->mNumParams; i++) {
                ret |= Propegate2(f, &pn->mpOp->mpParams[i], &pv);
            }
        }

        ret |= f(pn);

        if(*((VerOpList**)p) == 0) {
            delete pv;
        }
        
        return ret;
    }

public:
    ~VerTable(){ Cleanup(); }
    int mNodeCount;
    VerNode* mpNodes;

	//call f() once for every VerNode in all trees in the table
    bool Propegate(VERNODEFUNC f) 
    {
        int i;
        int j = 0; //used for scratch space by propegate2
        bool br = false;
        for(i = 0; i < mNodeCount; i++) {
            br |= Propegate2(f, &mpNodes[i], &j);
        }
        return br;
    }

	//create a table to keep track of "count" registers (192 constants * 4 elements = 368)
    static VerTable* MakeTable(int count) 
    {
        VerTable* pt = new VerTable;
        if(!pt) {
            VER_ERR(("VerTable::MakeTable: new VerTable failed!"));
            return NULL;
        }
        pt->mpNodes = new VerNode[count];
        if(!pt->mpNodes) { 
            VER_ERR(("VerTable::MakeTable: new VerNode[%d] failed!", count));
            delete pt; 
            return NULL; 
        }
        pt->mNodeCount = count;
        return pt;
    }
    
	//copy the array of registers pointed to by psrc into the table.
    //passing NULL of psrc will just initialize table element i to i.
    bool InitTable(VerNode* psrc = NULL) 
    {
        int i;
        if(psrc == NULL) {
            for(i = 0; i < mNodeCount; i++) {
                mpNodes[i].mbHasReg = true;
                mpNodes[i].mReg = i;
            }
            return true;
        } 
        else { //we have something to init from
            for(i = 0; i < mNodeCount; i++) {
                if(false == mpNodes[i].CopyFrom(psrc + i)) {
                    VER_ERR(("VerTable::InitTable(%p): CopyFrom(scr + %d) failed", psrc, i));
                    return false;
                }
            }
            return true;
        }
    }

    void Cleanup() 
    {
        delete[] mpNodes;
        mNodeCount = 0;
        mpNodes = 0;
    }

	//build a VerTable that contains all calculations performed in the vertex shader pointed to by pcode
    static HRESULT BuildTable(D3DVertexShaderProgram*pcode, VerConstTableList** ppc, VerTable** ppOutTable) //build a table & constant list. To delete it, use delete.
    {
        VerTable* pt = NULL;        //pointer to the table
        VerConstTableList* pc = NULL;  //holds the base of the constant list
        VerConstTableList* pc2 = NULL; //pointer to most-recently added constant table
        bool br;
        int ret;
        int i = 0;
        HRESULT hr = S_OK;

        if(!ppOutTable) { VER_ERR(("Called BuildTable with NULL ppOutTable")); return E_FAIL; }
        if(!ppc)        { VER_ERR(("Called BuildTable with NULL ppc"));        return E_FAIL; }
        *ppOutTable = NULL;
        *ppc = NULL;

        pt = VerTable::MakeTable(VER_NUM_REG);
        if(!pt) {
            hr = E_OUTOFMEMORY;
            VER_ERR(("BuildTable: pt = MakeTable(%d) failed", VER_NUM_REG));
            goto cleanup;
        }

        br = pt->InitTable();
        if(!br) {
            hr = E_OUTOFMEMORY;
            VER_ERR(("BuildTable: pt->InitTable() failed"));
            goto cleanup;
        }

        pc = pc2 = new VerConstTableList;
        if(!pc) {
            hr = E_OUTOFMEMORY;
            VER_ERR(("BuildTable: new VerConstTableList failed"));
            goto cleanup;
        }

        if(!pc->SetData(pt)) {
            hr = E_OUTOFMEMORY;
            VER_ERR(("BuildTable: pc->SetData(pt) failed"));
            goto cleanup;
        }

        do {
            ret = pt->Interpret(&pcode->ucode[i], pc2->mpData);
            if(ret == 1) {
                if(!pc2->SetData(pt)) {
                    hr = E_OUTOFMEMORY;
                    VER_ERR(("BuildTable: pc2->SetData(pt) failed"));
                    goto cleanup;
                }
                pc2 = pc2->mpNext;
            } else if (ret == -1) {
                hr = E_OUTOFMEMORY;
                VER_ERR(("BuildTable: Interpret ran out of memory"));
                goto cleanup;
            } else if (ret == E_ASSEMBLER_FAILED) {
                hr = ret;
                goto cleanup;
            }
        } while ((++i < pcode->length) && !(pcode->ucode[i].eos));

        if(SUCCEEDED(hr)) {
            *ppc = pc;
            *ppOutTable = pt;
        }
        return hr;

//code will only get here if something went wrong
cleanup:
        VER_MSG(("deleting pt."));
        delete pt;
        VER_MSG(("deleting pc."));
        delete pc;
        *ppc = NULL;
        return hr;
    }


	//interpret a vertex shader instruction, and modify the tree to store its operation appropriately
	//LastConstData contains a pointer to the last known state of all constant registers
    int Interpret(D3DVsInstruction*pcode, VerTable* LastConstData) //-1 if error. 0 if good. 1 if wrote to a constant register.
    {
        VerNode a[3][4];   //input (from a, b, c ... swizzled & negated appropriately). These are copied to the params of Out, then deleted.
        VerOp*  pOutOp[2][4] = {0}; //Output from the two operations. This is copied to the appropriate output registers, then deleted.
        VerNode Out[2][4]; //node form of OutOp. Note: Mov writes directly to Out. If OutOp is NULL, it is not used when creating Out.
        VerNode*pOutArl = 0; //if ARL instruction is encountered, this receives the new ARL, and holds it until the end...
        bool br = false;        
        bool WrittenToConstant = false;
        int iIluOutReg;
        int rwm;

#ifdef DBG
        char* ErrStr;
#define SetErrStr(a) ErrStr = a
#else
#define SetErrStr(a)
#endif

        int iin[3];
        switch (pcode->amx) {
        case MX_R:
            //ainput is register
            iin[0] = (pcode->arr == 12) ? REG_oPos : (REG_R0 + pcode->arr); //r12 is mapped to oPos. 
            break;
        case MX_V:
            iin[0] = REG_V0 + pcode->va;  //ainput is input
            break;
        case MX_C:
            iin[0] = REG_C0 + pcode->ca;  //ainput is constant
            //deal with ARL stuff later
            break;
        default:
            VER_ERR(("Unknown amx: %d", pcode->amx));
            break;
        }
        switch (pcode->bmx) {
        case MX_R:
            //binput is register
            iin[1] = (pcode->brr == 12) ? REG_oPos : (REG_R0 + pcode->brr); //r12 is mapped to oPos
            break;
        case MX_V:
            iin[1] = REG_V0 + pcode->va;   //binput is input
            break;
        case MX_C:
            iin[1] = REG_C0 + pcode->ca;   //binput is constant
            //deal with ARL stuff later
            break;
        default:
            VER_ERR(("Unknown bmx: %d", pcode->bmx));
            break;
        }
        switch (pcode->cmx) {
        case MX_R:
            //cinput is register
            iin[2] = (pcode->crr == 12) ? REG_oPos : (REG_R0 + pcode->crr); //r12 is mapped to oPos
            break;
        case MX_V:
            iin[2] = REG_V0 + pcode->va;
            break;
        case MX_C:
            iin[2] = REG_C0 + pcode->ca;
            //deal with ARL stuff later
            break;
        default:
            VER_ERR(("Unknown cmx: %d", pcode->cmx));
            break;
        }
    
        //copy the state of the input to our temp buffers. code->**s takes care of swizzling
        br = true;
        br &= a[0][0].CopyFrom(&mpNodes[iin[0] * 4 + pcode->axs]);
        br &= a[0][1].CopyFrom(&mpNodes[iin[0] * 4 + pcode->ays]);
        br &= a[0][2].CopyFrom(&mpNodes[iin[0] * 4 + pcode->azs]);
        br &= a[0][3].CopyFrom(&mpNodes[iin[0] * 4 + pcode->aws]);
        br &= a[1][0].CopyFrom(&mpNodes[iin[1] * 4 + pcode->bxs]);
        br &= a[1][1].CopyFrom(&mpNodes[iin[1] * 4 + pcode->bys]);
        br &= a[1][2].CopyFrom(&mpNodes[iin[1] * 4 + pcode->bzs]);
        br &= a[1][3].CopyFrom(&mpNodes[iin[1] * 4 + pcode->bws]);
        br &= a[2][0].CopyFrom(&mpNodes[iin[2] * 4 + pcode->cxs]);
        br &= a[2][1].CopyFrom(&mpNodes[iin[2] * 4 + pcode->cys]);
        br &= a[2][2].CopyFrom(&mpNodes[iin[2] * 4 + pcode->czs]);
        br &= a[2][3].CopyFrom(&mpNodes[iin[2] * 4 + pcode->cws]);
        if(!br) {
            VER_ERR(("Interpret: one of the calls to a[*][*].CopyFrom failed!"));
            return -1;
        }


        int i;

        //if we're doing indexed stuff, link to the table and the ARL register
        if(pcode->cin) {
            if(pcode->amx == MX_C) {
                for(i = 0; i < 4; i++) {
                    a[0][i].Cleanup(); //get rid of any operation fluff, since we don't know what constant to read from
                    a[0][i].mbHasTable = true;
                    a[0][i].mpTable = LastConstData;
                    a[0][i].mpArl = mpNodes[REG_ARL * 4].Copy();
                    a[0][i].mbHasReg = true;
                    if(NULL == a[0][i].mpArl) {
                        VER_ERR(("a[0][%d].mpArl is null after mpNodes[REG_ARL*4].Copy!"));
                        return -1;
                    }
                }
                a[0][0].mReg = pcode->ca * 4 + pcode->axs; //isn't a valid VerOpcode, but works as an index instead...
                a[0][1].mReg = pcode->ca * 4 + pcode->ays; //isn't a valid VerOpcode, but works as an index instead...
                a[0][2].mReg = pcode->ca * 4 + pcode->azs; //isn't a valid VerOpcode, but works as an index instead...
                a[0][3].mReg = pcode->ca * 4 + pcode->aws; //isn't a valid VerOpcode, but works as an index instead...
            }
            if(pcode->bmx == MX_C) {
                for(i = 0; i < 4; i++) {
                    a[1][i].Cleanup(); //get rid of any operation fluff, since we don't know what constant to read from
                    a[1][i].mbHasTable = true;
                    a[1][i].mpTable = LastConstData;
                    a[1][i].mpArl = mpNodes[REG_ARL * 4].Copy();
                    a[1][i].mbHasReg = true;
                    if(NULL == a[1][i].mpArl) {

                        VER_ERR(("a[1][%d].mpArl is null after mpNodes[REG_ARL*4].Copy!"));
                        return -1;
                    }
                }
                a[1][0].mReg = pcode->ca * 4 + pcode->bxs; //isn't a valid VerOpcode, but works as an index instead...
                a[1][1].mReg = pcode->ca * 4 + pcode->bys; //isn't a valid VerOpcode, but works as an index instead...
                a[1][2].mReg = pcode->ca * 4 + pcode->bzs; //isn't a valid VerOpcode, but works as an index instead...
                a[1][3].mReg = pcode->ca * 4 + pcode->bws; //isn't a valid VerOpcode, but works as an index instead...
            }
            if(pcode->cmx == MX_C) {
                for(i = 0; i < 4; i++) {
                    a[2][i].Cleanup(); //get rid of any operation fluff, since we don't know what constant to read from
                    a[2][i].mbHasTable = true;
                    a[2][i].mpTable = LastConstData;
                    a[2][i].mpArl = mpNodes[REG_ARL * 4].Copy();
                    a[2][i].mbHasReg = true;
                    if(NULL == a[2][i].mpArl) {

                        VER_ERR(("a[2][%d].mpArl is null after mpNodes[REG_ARL*4].Copy() !"));
                        return -1;
                    }
                }
                a[2][0].mReg = pcode->ca * 4 + pcode->cxs; //isn't a valid VerOpcode, but works as an index instead...
                a[2][1].mReg = pcode->ca * 4 + pcode->cys; //isn't a valid VerOpcode, but works as an index instead...
                a[2][2].mReg = pcode->ca * 4 + pcode->czs; //isn't a valid VerOpcode, but works as an index instead...
                a[2][3].mReg = pcode->ca * 4 + pcode->cws; //isn't a valid VerOpcode, but works as an index instead...
            }
        }

        //if negated, negate the negated flag
        for(i = 0; i < 4; i++) {
            if(pcode->ane) {                //if the input is negated
                a[0][i].mbNegated ^= true; //swap the "negated" flag
            }
            if(pcode->bne) {                //if the input is negated
                a[1][i].mbNegated ^= true; //swap the "negated" flag
            }
            if(pcode->cne) {                //if the input is negated
                a[2][i].mbNegated ^= true; //swap the "negated" flag
            }
        }

        //look at the MAC opcode... create the approptate output branches
        switch(pcode->mac) {
        case MAC_NOP:
            pOutOp[0][0] = VerOp::MakeOp(VEROP_NOP, 0);
            if(!pOutOp[0][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_NOP,0) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[0][i] = pOutOp[0][0]->Copy();
            }
            break;
        case MAC_MOV:
            for(i = 0; i < 4; i++) {
                if(!Out[0][i].CopyFrom(&a[0][i])) {
                    SetErrStr("Interpret: CopyFrom for Mov instruction failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_MUL:
            for(i = 0; i < 4; i++) {
                pOutOp[0][i] = VerOp::MakeOp(VEROP_MUL, 2, &a[0][i], &a[1][i]);
                if(!pOutOp[0][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_MUL,2) failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_ADD:
            for(i = 0; i < 4; i++) {
                pOutOp[0][i] = VerOp::MakeOp(VEROP_ADD, 2, &a[0][i], &a[2][i]);
                if(!pOutOp[0][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_ADD,2) failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_MAD:
            for(i = 0; i < 4; i++) {
                pOutOp[0][i] = VerOp::MakeOp(VEROP_MAD, 3, &a[0][i], &a[1][i], &a[2][i]);
                if(!pOutOp[0][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_MAD,3) failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_DP3:
            pOutOp[0][0] = VerOp::MakeOp(VEROP_DP3, 6, &a[0][0], &a[1][0], &a[0][1], &a[1][1], &a[0][2], &a[1][2]);
            if(!pOutOp[0][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_DP3,6) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[0][i] = pOutOp[0][0]->Copy();
            }
            break;
        case MAC_DPH:
            pOutOp[0][0] = VerOp::MakeOp(VEROP_DPH, 7, &a[0][0], &a[1][0], &a[0][1], &a[1][1], &a[0][2], &a[1][2], &a[1][3]);
            if(!pOutOp[0][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_DPH,7) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[0][i] = pOutOp[0][0]->Copy();
            }
            break;
        case MAC_DP4:
            pOutOp[0][0] = VerOp::MakeOp(VEROP_DP4, 8, &a[0][0], &a[1][0], &a[0][1], &a[1][1], &a[0][2], &a[1][2], &a[0][3], &a[1][3]);
            if(!pOutOp[0][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_DP4,8) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[0][i] = pOutOp[0][0]->Copy();
            }
            break;
        case MAC_DST:
            pOutOp[0][0] = VerOp::MakeOp(VEROP_DSTX, 0);
            pOutOp[0][1] = VerOp::MakeOp(VEROP_DSTY, 2, &a[0][1], &a[1][1]);
            pOutOp[0][2] = VerOp::MakeOp(VEROP_DSTZ, 1, &a[0][2]);
            pOutOp[0][3] = VerOp::MakeOp(VEROP_DSTW, 1, &a[1][3]);
            for(i = 0; i < 4; i++) {
                if(!pOutOp[0][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_DST,*) failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_MIN:
            for(i = 0; i < 4; i++) {
                pOutOp[0][i] = VerOp::MakeOp(VEROP_MIN, 2, &a[0][i], &a[1][i]);
                if(!pOutOp[0][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_MIN,2) failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_MAX:
            for(i = 0; i < 4; i++) {
                pOutOp[0][i] = VerOp::MakeOp(VEROP_MAX, 2, &a[0][i], &a[1][i]);
                if(!pOutOp[0][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_MAX,2) failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_SLT:
            for(i = 0; i < 4; i++) {
                pOutOp[0][i] = VerOp::MakeOp(VEROP_SLT, 2, &a[0][i], &a[1][i]);
                if(!pOutOp[0][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_SLT,2) failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_SGE:
            for(i = 0; i < 4; i++) {
                pOutOp[0][i] = VerOp::MakeOp(VEROP_SGE, 2, &a[0][i], &a[1][i]);
                if(!pOutOp[0][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_SGE,2) failed");
                    goto cleanupbad;
                }
            }
            break;
        case MAC_ARL:
            pOutOp[0][0] = VerOp::MakeOp(VEROP_NOP, 0);
            if(!pOutOp[0][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_NOP,0) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[0][i] = pOutOp[0][0]->Copy();
            }

            //WEIRDNESS: write to arl in the table here. (Must occur after ARL is read from, above)
            if(false == mpNodes[REG_ARL * 4].CopyFrom(&a[0][0])) { // read from 'x' channel of input
                SetErrStr("CopyFrom, for ARL instruction failed");
                goto cleanupbad;
            }

            break;
        default:
            //unknown mac instruction
            SetErrStr("unknown mac instruction");
            break;
        }

        //look at the ILU instruction... create the appropriate output branch...
        switch(pcode->ilu) {
        case ILU_NOP:
            pOutOp[1][0] = VerOp::MakeOp(VEROP_NOPX, 0); 
            if(!pOutOp[1][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_NOPX,0) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[1][i] = pOutOp[1][0]->Copy();
            }
            break;
        case ILU_MOV:
            for(i = 0; i < 4; i++) {
                if(!Out[1][i].CopyFrom(&a[2][i])) {
                    SetErrStr("Interpret: CopyFrom, for IMV failed");
                    goto cleanupbad;
                }
            }
            break;
        case ILU_RCP:
            pOutOp[1][0] = VerOp::MakeOp((VerOpcode)(VEROP_RCPX), 1, &a[2][0]);
            if(!pOutOp[1][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_RCPX,1) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[1][i] = pOutOp[1][0]->Copy();
            }
            break;
        case ILU_RCC:
            pOutOp[1][0] = VerOp::MakeOp((VerOpcode)(VEROP_RCCX), 1, &a[2][0]);
            if(!pOutOp[1][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_RCCX,1) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[1][i] = pOutOp[1][0]->Copy();
            }
            break;
        case ILU_RSQ:
            pOutOp[1][0] = VerOp::MakeOp((VerOpcode)(VEROP_RSQX), 1, &a[2][0]);
            if(!pOutOp[1][0]) {
                SetErrStr("Interpret: VerOp::MakeOp(VEROP_RSQX,1) failed");
                goto cleanupbad;
            }
            for(i = 1; i < 4; i++) {
                pOutOp[1][i] = pOutOp[1][0]->Copy();
            }
            break;
        case ILU_EXP:
            for(i = 0; i < 4; i++) {
                pOutOp[1][i] = VerOp::MakeOp((VerOpcode)(VEROP_EXPX + i), 1, &a[2][0]);
                if(!pOutOp[1][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_EXP,1) failed");
                    goto cleanupbad;
                }
            }
            break;
        case ILU_LOG:
            for(i = 0; i < 4; i++) {
                pOutOp[1][i] = VerOp::MakeOp((VerOpcode)(VEROP_LOGX + i), 1, &a[2][0]);
                if(!pOutOp[1][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_LOG,1) failed");
                    goto cleanupbad;
                }
            }
            break;
        case ILU_LIT:
            pOutOp[1][0] = VerOp::MakeOp(VEROP_LITX, 0);
            pOutOp[1][1] = VerOp::MakeOp(VEROP_LITY, 1, &a[2][0]); //x
            pOutOp[1][2] = VerOp::MakeOp(VEROP_LITZ, 3, &a[2][0], &a[2][1], &a[2][3]); //x, y, w
            pOutOp[1][3] = VerOp::MakeOp(VEROP_LITW, 0);
            for(i = 0; i < 4; i++) {
                if(!pOutOp[1][i]) {
                    SetErrStr("Interpret: VerOp::MakeOp(VEROP_LIT,*) failed");
                    goto cleanupbad;
                }
            }

            break;
        default:
            SetErrStr("unknown ilu instruction");
            break;
        }
        //all done with calculating instructions!
        //Now, build Out[0] and Out[1]. Only use OutOp if it isn't NULL!

        for(i = 0; i < 4; i++) {
            if(pOutOp[0][i]) {
                Out[0][i].UseOp(pOutOp[0][i]);
                pOutOp[0][i]->Release();
            } //else {} nothing. MOVs leave the OutOp as NULL, but modify Out directly.
            if(pOutOp[1][i]) {
                Out[1][i].UseOp(pOutOp[1][i]);
                pOutOp[1][i]->Release();
            } //else {} nothing. MOVs leave the OutOp as NULL, but modify Out directly.

        }

        //Out[0] contains results from the MAC instruction, Out[1] contains results from ILU. Now, update the register table...
        //if MAC != NOP, ILU writes to r1. 
        //if rw == 1 and MAC != NOP, and ILU != NOP, the MAC instruction is ignored.
        //if rw == 1, MAC != NOP, ILU == NOP, MAC writes to 1.

        rwm = pcode->rwm;
        iIluOutReg = (pcode->mac != 0) ? REG_R1 : (REG_R0 + pcode->rw);
        if(pcode->rw == 1 && pcode->mac != 0 && pcode->ilu != 0 && pcode->swm != 0) rwm = 0; //if ilu & mac conflict, ilu wins; mac writes nothing.


        for(i = 0; i < 4; i++) {
            //write to primary register
            if(rwm & (1 << (3 - i))) {
                if(!mpNodes[(REG_R0 + pcode->rw) * 4 + i].CopyFrom(&Out[0][i])) {
                        VER_ERR(("CopyFrom to Write to primary register failed. "));
                        return -1;
                }

                if(!mpNodes[(REG_R0 + pcode->rw) * 4 + i].TinyValidate()) {
                    return E_ASSEMBLER_FAILED;
                }
            }
            //write to secondary register
            if(pcode->swm & (1 << (3 - i))) {
                if(!mpNodes[(iIluOutReg) * 4 + i].CopyFrom(&Out[1][i])) {
                        VER_ERR(("CopyFrom to Write to ilu (or secondary) register failed. "));
                        return -1;
                }

                if(!mpNodes[(iIluOutReg) * 4 + i].TinyValidate()) {
                    return E_ASSEMBLER_FAILED;
                }
            }
            //write to output/constant register
            if(pcode->owm & (1 << (3 - i))) {
                if(pcode->oc & 0x100) {
                    //output register
                    if(!mpNodes[(REG_O0 + (pcode->oc & 0xff)) * 4 + i].CopyFrom(&Out[pcode->om][i])) {
                        VER_ERR(("CopyFrom to Write to output register failed. "));
                        return -1;
                    }

                    if(!mpNodes[(REG_O0 + (pcode->oc & 0xff)) * 4 + i].TinyValidate()) {
                        return E_ASSEMBLER_FAILED;
                    }
                } else {
                    //constant register!
                    br = true; //we have written to a constant!
                    if(!mpNodes[(REG_C0 + (pcode->oc & 0xff)) * 4 + i].CopyFrom(&Out[pcode->om][i])) {
                        VER_ERR(("CopyFrom to Write to constant register failed. "));
                        return -1;
                    }

                    if(!mpNodes[(REG_C0 + (pcode->oc & 0xff)) * 4 + i].TinyValidate()) {
                        return E_ASSEMBLER_FAILED;
                    }
                }
            }
        }

		//return 1 if we wrote to a constant, 0 if we didn't, or something else something bad happened
        return br ? 1 : 0;

cleanupbad:
        //this cleans up the ops that were created, since they won't be destroyed by c++ unless they're part of a node...
        VER_ERR((ErrStr));
        for(i = 0; i < 4; i++) {
            pOutOp[0][i]->Release();
            pOutOp[1][i]->Release();
        }
        return -1;

    }
};

//compare two VerNodes
//return true if they do the same thing, false if they're different
bool Compare(VerNode* pa, VerNode* pb)
{
#ifdef DBG_VERIFIER
#define Dif(_a_) do { VER_MSG(_a_); return false; } while (0)
#else
#define Dif(_a_) do { return false; } while (0)
#endif
    int i;
    if(pb->mbHasOp != pa->mbHasOp) Dif(("mbHasOp"));
    if(pb->mbHasReg != pa->mbHasReg) Dif(("mbHasReg"));
    if(pb->mbHasTable != pa->mbHasTable) Dif(("mbHasTable"));
    if(pb->mbNegated != pa->mbNegated) Dif(("mbNegated")); //bugbug: for later, the ZERO op won't matter if it's negated.

    if(pb->mbHasReg) {
        if(pb->mReg != pa->mReg) Dif(("mReg"));
    }
    if(pb->mbHasOp) {
        if(pb->mpOp == pa->mpOp) { //pointer to the same op...
        } else if(pa->mpOp->mpSame && pa->mpOp->mpSame->FindData(pb->mpOp)) {
        } else {
            if(pb->mpOp->mOp != pa->mpOp->mOp) {
                if(pb->mpOp->mOp == VEROP_MAD) (BreakUpMad(pb));
                if(pa->mpOp->mOp == VEROP_MAD) (BreakUpMad(pa));
                if(pb->mpOp->mOp != pa->mpOp->mOp) {
                    Dif(("mOp")); //bugbug:? make sure MADs are broken up first, and maybe DP*s.
                }
            }
            if(pb->mpOp->mNumParams != pa->mpOp->mNumParams) Dif(("mNumParams"));
            if(pb->mpOp->mOp == VEROP_ADD || pb->mpOp->mOp == VEROP_MUL || pb->mpOp->mOp == VEROP_MAX || pb->mpOp->mOp == VEROP_MIN) {
                //deal with the associative law in addition, mul, min, max...
                //bugbug: this only works if adding 2 things together. (add with >= 3 inputs will require more code when that is implimented)
                if(!Compare(&pa->mpOp->mpParams[0], &pb->mpOp->mpParams[0])) {
                    if(!Compare(&pa->mpOp->mpParams[1], &pb->mpOp->mpParams[0])) Dif(("%d: b[0] != a[1]", pb->mpOp->mOp));
                    if(!Compare(&pa->mpOp->mpParams[0], &pb->mpOp->mpParams[1])) Dif(("%d: b[1] != a[0]", pb->mpOp->mOp));
                } else {
                    if(!Compare(&pa->mpOp->mpParams[1], &pb->mpOp->mpParams[1])) Dif(("%d: b[1] != a[1]", pb->mpOp->mOp));
                }
            } else {
                for(i = 0; i < pb->mpOp->mNumParams; i++) {
                    if(!Compare(&pa->mpOp->mpParams[i], &pb->mpOp->mpParams[i])) Dif(("param check"));
                }
            }

            //ops are the same! add them to their list of "same buddies"
            if(!pa->mpOp->mpSame) {
                pa->mpOp->mpSame = new VerOpList; //bugbug: if allocation fails, it won't matter too much, but could slow things down a bit. This function has no way to return errors though.
                if(pa->mpOp->mpSame) pa->mpOp->mpSame->mpData = pb->mpOp;
            } else {
                pa->mpOp->mpSame->SetData(pb->mpOp);
            }
            if(!pb->mpOp->mpSame) {
                pb->mpOp->mpSame = new VerOpList;
                if(pb->mpOp->mpSame) pb->mpOp->mpSame->mpData = pa->mpOp;
            } else {
                pb->mpOp->mpSame->SetData(pa->mpOp);
            }
        }
    }
    if(pb->mbHasTable) {
        VER_MSG(("checking ARL"));
        if(!Compare(pa->mpArl, pb->mpArl)) Dif(("arl check"));

        if(pb->mpTable != pa->mpTable) {
            if(pb->mpTable->mNodeCount != pa->mpTable->mNodeCount) Dif(("table->mNodeCount"));
            for(i = (pb->mReg & 3); i < pb->mpTable->mNodeCount; i += 4) { //check only elements that could be used here.
                if(!Compare(&pa->mpTable->mpNodes[i], &pb->mpTable->mpNodes[i])) Dif(("table check"));
            }               
        } else { 
            //table pointers are the same - no point in checking individual elements...
        }
    }
    return true;
}

//update the table of constant registers to hold the most recent values
//keep the old tables around: if a0.x was previously used in an instruction, the VerNode that 
//is used in that instruction points to the state of the constant registers at that time. This 
//is used to prevent "aliasing" problems in the optimizers
bool VerConstTableList::SetData(VerTable*ptable) //returns false if allocations failed, true if worked
{ 
    bool br;
    if(mpData == 0) {
        mpData = VerTable::MakeTable(VER_NUM_CONSTS);
        if(!mpData) {
            VER_ERR(("VerConstTableList::SetData: MakeTable failed!"));
            return false;
        }
        br = mpData->VerTable::InitTable(&ptable->mpNodes[REG_C0 * 4]);       
        if(br == false) {
            VER_ERR(("VerConstTableList::SetData: InitTable failed"));
            return false;
        }
        
    } else {
        VerConstTableList* pc = this;
        while(pc->mpNext) { pc = pc->mpNext; }
        pc->mpNext = new VerConstTableList;
        if(!pc->mpNext) {
            VER_ERR(("VerConstTableList::SetData: new VerConstTableList failed"));
            return false;
        }
        br = pc->mpNext->SetData(ptable);
        if(br == false) {
            VER_ERR(("VerConstTableList::SetData failed"));
            return false;
        }
    }
    return true;
}

VerConstTableList::~VerConstTableList() {
    delete mpNext;
    mpNext = 0;
    delete mpData;
    mpData = 0;
}

//VERIFY! returns true if the two tables are the same, false if not.
bool Verify(VerTable* pa, VerTable* pb, XD3DXErrorLog* pErrorLog) 
{
    if(!pa || !pb) {
        VER_ERR(("Verify was passed null table pointers"));
        return false;
    }

    int i;

    //bugbug: Merge multiple Add, Mul, Min, Max ops together, to appropriately deal with commutitive/associative laws

    //verify output registers
    for(i = REG_O0 * 4; i < REG_O15 * 4 + 4; i++) {
        if(!Compare(&pa->mpNodes[i], &pb->mpNodes[i])) {
            char buf[100];
            int index = (i >> 2) - REG_O0;
            sprintf(buf, "Output register %s o[%d][%d] didn't match!", kOutNames[index], index, i & 3);
            if(pErrorLog){
                pErrorLog->Log(true, 1, 0, 0, buf);
            }
            VER_ERR((buf));
            return false;
        } else {
//          VER_MSG(("compare worked!"));
        }
    }
    //verify constant registers
    for(i = REG_C0 * 4; i < REG_C0 * 4 + VER_NUM_CONSTS; i++) {
        if(!Compare(&pa->mpNodes[i], &pb->mpNodes[i])) {
            char buf[100];
            sprintf(buf, "Constant register[%d][%d] didn't match!", (i >> 2) - REG_C0, i & 3);
            if(pErrorLog){
                pErrorLog->Log(true, 2, 0, 0, buf);
            }
            VER_ERR((buf));
            return false;
        }
    }
    //we don't care about r0-r15, or v* registers, since they either aren't used at the end of a shader, or never change

    return true;
}

//build a table for the vertex shader pb, compare it with table pa
bool Verify(VerTable* pa, D3DVertexShaderProgram * pb, const char* title) 
{
    VerConstTableList* pbc = 0;
    VerTable* pbt = 0;
    bool br = false;
    HRESULT hr = S_OK;

    hr = VerTable::BuildTable(pb, &pbc, &pbt);
    if(!pbt || FAILED(hr)) {
        if(hr == E_ASSEMBLER_FAILED) {
            VER_ERR(("It looks like %s broke something", title));
        } else {
            VER_ERR(("Verify: BuildTable failed"));
        }
        br = false;
        goto cleanup;
    }

    br = Verify(pa, pbt, NULL);
    if(!br) {
        VER_ERR(("It looks like %s broke something", title));
    } else {
        VER_MSG(("%s worked!", title));
    }

cleanup:
    pa->Propegate(ClobberSameList);
    delete pbt;
    delete pbc;

    return br;
}

//create tables for vertex shaders pa and pb. Compare the tables, delete them.
//returns true if the two D3DVertexShaderPrograms do the same thing, false otherwise
bool Verify(D3DVertexShaderProgram * pa, D3DVertexShaderProgram * pb, XD3DXErrorLog* pErrorLog) 
{
    VerConstTableList* pc[2] = {0, 0};
    VerTable* pt[2] = {0, 0};
    bool br = false;
    HRESULT hr = S_OK;

    hr = VerTable::BuildTable(pa, &pc[0], &pt[0]);
    if(SUCCEEDED(hr)) {
        hr = VerTable::BuildTable(pb, &pc[1], &pt[1]);
    }

    if(!pt[0] || !pt[1]) {
        if(hr == E_ASSEMBLER_FAILED) {
            VER_ERR(("Assembler failed. (bad value in register)"));
        }
        VER_ERR(("BuildTable failed. pt[0]:%p t[1]:%p  c[0]:%p, c[1]:%p", pt[0],pt[1],pc[0],pc[1]));
        goto cleanup;
    }
    
    br = Verify(pt[0], pt[1], pErrorLog);

cleanup:
    delete pt[0];
    delete pt[1];
    delete pc[0];
    delete pc[1];

    return br;
}

#endif //ndef DISABLE_VERIFIER






enum StallType {
	eNone               = ' ',  //no stall
	eRegInit            = 'A',  //stall from using a temp register too early
	eBypass             = 'B',  //bypass was used - can cause small shadow-stalls if a stall occurs next
	eStandard           = 'C',  //stall from trying to read something that isn't ready (pipeline issue)
	eShadow             = 'D',  //stall from reading a register that was written to in a stalling instruction after 1 or 2 instructions
	eStandardAndShadow  = 'E',  //stall from standard + using a stalled register
	eBypassAndShadow    = 'F',  //bypass used, shadow also occurred
	eStandardAndBypShad = 'G',  //stall, plus shadow from "... bypass, stall, ..."
	eArl                = 'H',  //stall from using a0.x right after it is written
	eArlShadow          = 'I',  //stall from using a0.x right after it is written + a shadow
	eXOutputsIsXCycles  = 'J',  //stall from other area of gpu
	eSingleThreaded     = 'K',  //stall from other area of gpu
	eSmallShader        = 'L'   //stall from 
};



const char* StallDescription[] = {
	"register initialization (first two instructions only)",
	"bypass (no stall)",
	"standard stall",
	"shadow-stall from using a register two instructions after it stalled",
	"standard stall plus shadow-stall from using a register the instruction after it stalled",
	"bypass plus shadow-stall from using a register the instruction after it stalled",
	"stall from stalling immediately after using a bypass",
	"stall from using a0.x the instruction after writing to it",
	"stall from using a0.x the instruction after writing to it stalled",
	"writing to X output registers causes a shader to take X cycles to execute",
	"18-cycle stall for using xvsw or xvss",
	"stall for shaders smaller than 2.5 cycles",
};

// Low level simulator.

class TLEngineSim{
public:
    TLEngineSim(){
    }

    ~TLEngineSim(){
    }


    HRESULT Initialize(DWORD shaderType, int NumInst){
        isMultiThreaded = SASMT_SHADERTYPE(shaderType) == SASMT_VERTEXSHADER;
        HRESULT hr = Clear(NumInst);
        return hr;
    }

    HRESULT Clear(int NumInst){
        HRESULT hr = S_OK;
        
        {
            for(int i = 0; i < 2; i++){
                c[i] = -6;
            }
        }

		for(int i = 0; i < 16; i++) {
			OutRegWritten[i] = false;
		}

        STscoreboard.Clear();
		scoreboard.Clear(NumInst);
        currentCycle = 0;
        return hr;
    }

    HRESULT Do(const D3DVsInstruction* pI, float& stall, StallType& reason) {
		reason = eNone;
        HRESULT hr = S_OK;
		if(isMultiThreaded) {
			float realStall = CalculateRealStall(pI, reason);
			currentCycle += realStall;
			if(realStall > .19) {
				//DoOut always calls StartNewInstruction. 
				//This call here is to eliminate a duplicate shadow in the following case:
				//dp4 r2, v0, v0  
				//dp4 r2, r2, r2   //stall
				//dp4 oPos, r2, r2 //shadow + stall
				//mul oD0, r2, r2  //this doesn't shadow on the hardware.
				scoreboard.StartNewInstruction();
			}
			hr = DoOut(pI, reason);
			currentCycle += 0.5f;
			stall = realStall;
			return hr;
		} else {
			DWORD realStall = CalculateRealStall(pI, reason);
			currentCycle += realStall;
			hr = STDoOut(pI);
			if(isMultiThreaded){
	            currentCycle += .5;
				stall = realStall / 3;
			}
			else {
	            currentCycle += 1;
				stall = (float)realStall;
			}
			return hr;
		}
    }

    bool IsStall(const D3DVsInstruction* pI){
		StallType dummyreason = eNone;
        return CalculateStall(pI, dummyreason) > 0;
    }

    float CalculateStall(const D3DVsInstruction* pI, StallType& reason){
        float stall = CalculateRealStall(pI, reason);
        return stall;
    }

	float CalculateFinalStall(StallType& reason)
	{
		if(isMultiThreaded) {
			int i;
			float numregswritten = 0;
			float stall = 0;
			reason = eNone;

			for (i = 0; i < 16; i++) {
				if(OutRegWritten[i]) {
					numregswritten += 1.0;
				}
			}
			if(numregswritten > currentCycle) {
				stall = numregswritten - currentCycle;
				reason = eXOutputsIsXCycles;
			}

			if(currentCycle < 2.2) {
				float newstall = 2.2 - currentCycle;
				if(stall < newstall) {
					stall = newstall;
					reason = eSmallShader;
				}
			}

			return stall;

		}
		else {
			reason = eSingleThreaded;
			return 18.0f;
		}
	}

    // Which type of bypass 
    enum OpType {
        eALU,
        eMLU,
        eILU,
		eARL,
        eOther // Includes NOPs
    };
    OpType MacOpType(const D3DVsInstruction* pI){
        static const OpType kOpType[] = {
            eOther,  // MAC_NOP
            eMLU,  // MAC_MOV
            eMLU,  // MAC_MUL
            eALU,   // MAC_ADD
            eALU,   // MAC_MAD
            eALU,   // MAC_DP3
            eALU,   // MAC_DPH
            eALU,   // MAC_DP4
            eMLU,  // MAC_DST
            eMLU,  // MAC_MIN
            eMLU,  // MAC_MAX
            eMLU,  // MAC_SLT
            eMLU,  // MAC_SGE
            eOther,  // MAC_ARL
            eOther,  // ?0xe Unused
            eOther   // ?0xf Unused
        };

		if(pI->ilu) {
			return eALU; //if ILU is active, MLU operations don't write to output until ILU is finished.
		} else {
			return kOpType[pI->mac];
		}
    }

    OpType ILUOpType(const D3DVsInstruction* pI){
        static const OpType kOpType[] = {
            eOther,   // ILU_NOP
            eILU,   // ILU_MOV
            eILU,   // ILU_RCP
            eILU,   // ILU_RCC
            eILU,   // ILU_RSQ
            eILU,   // ILU_EXP
            eILU,   // ILU_LOG
            eILU,   // ILU_LIT
        };
        return kOpType[pI->ilu];
    }

private:

    float CalculateRealStall(const D3DVsInstruction* pI, StallType& reason){
		reason = eNone;
        HRESULT hr = S_OK;
        
        // From emperical evidence on an NV20 we know that the stall is determined
        // by the time taken to fetch the A, B, and C
        // arguments, independent of whether the arguments are used by the opcodes.
        //
        // However, we also have been told (but haven't verified this) that the
        // bypass logic tracks which components have been read and written.
        //
        // That's why we compute the use masks here.
        //
        // See the Understanding the Xbox Vertex Shader Processor whitepaper for
        // details.
        
		//if the multi-threaded scoreboard is causing problems, change this to, "if (0)".
		if(isMultiThreaded) {

			float stall = 0.0f;
			UCHAR useMasks[3];
			for(int i = 0; i < 3; i++){
				useMasks[i] = ComputeEffectiveReadMask(pI, i);
			}
        
			float aready, bready, cready;
			StallType StallReason = eNone;

			aready = AReady(pI, useMasks[0], currentCycle, StallReason);
			reason = StallReason;
			stall = aready;

			bready = BReady(pI, useMasks[1], currentCycle, StallReason);
			if(bready > stall || reason == eNone) {
				reason = StallReason;
				stall = bready;
			}

			cready = CReady(pI, useMasks[2], currentCycle, StallReason);
			if(cready > stall || reason == eNone) {
				reason = StallReason;
				stall = cready;
			}

			return stall;
		} else {

			DWORD stall;
			UCHAR useMasks[3];
			for(int i = 0; i < 3; i++){
				useMasks[i] = ComputeEffectiveReadMask(pI, i);
			}
        
			int stallInc = isMultiThreaded ? 3 : 1;
			// We know we never stall more than five cycles....
			for(stall = 0; stall < 5; stall+= stallInc){
				if(STAReady(pI, useMasks[0], currentCycle + stall)
					&& STBReady(pI, useMasks[1], currentCycle + stall)
					&& STCReady(pI, useMasks[2], currentCycle + stall)) {
					break;
				}
			}
        
			return stall;
		}
    }

    DWORD STAReady(const D3DVsInstruction* pI, UCHAR useMask, int cycle){
        return STMuxReady(pI, pI->amx, pI->arr, pI->ane, pI->axs, pI->ays, pI->azs, pI->aws, 0, useMask, cycle);
    }
    DWORD STBReady(const D3DVsInstruction* pI, UCHAR useMask, int cycle){
        return STMuxReady(pI, pI->bmx, pI->brr, pI->bne, pI->bxs, pI->bys, pI->bzs, pI->bws, 1, useMask, cycle);
    }
    DWORD STCReady(const D3DVsInstruction* pI, UCHAR useMask, int cycle){
        return STMuxReady(pI, pI->cmx, pI->crr, pI->cne, pI->cxs, pI->cys, pI->czs, pI->cws, 2, useMask, cycle);
    }

    float AReady(const D3DVsInstruction* pI, UCHAR useMask, float cycle, StallType& reason){
        return MuxReady(pI, pI->amx, pI->arr, pI->ane, pI->axs, pI->ays, pI->azs, pI->aws, 0, useMask, cycle, reason);
    }
    float BReady(const D3DVsInstruction* pI, UCHAR useMask, float cycle, StallType& reason){
        return MuxReady(pI, pI->bmx, pI->brr, pI->bne, pI->bxs, pI->bys, pI->bzs, pI->bws, 1, useMask, cycle, reason);
    }
    float CReady(const D3DVsInstruction* pI, UCHAR useMask, float cycle, StallType& reason){
        return MuxReady(pI, pI->cmx, pI->crr, pI->cne, pI->cxs, pI->cys, pI->czs, pI->cws, 2, useMask, cycle, reason);
    }
    // Constant registers are divided into two banks

    static bool Bank(DWORD address){
        return (address >> 2) & 1;
    }

    HRESULT STDoOut(const D3DVsInstruction* pI){
        HRESULT hr = S_OK;
        if(pI->rwm){
            if(pI->rw >= 12){
                SETERROR(hr, E_FAIL);
            }
            STscoreboard.Start(MacOpType(pI), pI->rw, pI->rwm, currentCycle);
        }
        if(pI->swm){
            DWORD ilu_rw = (pI->mac && pI->ilu) ? 1 : pI->rw;
            STscoreboard.Start(ILUOpType(pI), ilu_rw, pI->swm, currentCycle);
        }
        if(pI->owm){
            bool oc_output = (pI->oc & 0x0100) != 0;
            DWORD oc_index = pI->oc & 0xff;
            if(oc_output){
                if(oc_index == 0){ // oPos is shadowed as r[12]
					//this block changed 23 Aug 2001 - to allow mac writes to oPos to use the MLU bypass in the simulation
                    if(pI->om == 0) { //if MAC writes to oPos
						STscoreboard.Start(MacOpType(pI), 12, pI->owm, currentCycle);
					} else { //if ILU writes to oPos
						STscoreboard.Start(ILUOpType(pI), 12, pI->owm, currentCycle);
					}
                }
            }
            else {
                if(oc_index >= 192){
                    SETERROR(hr, E_FAIL);
                }
                else {
                    c[Bank(oc_index)] = true;
                }
            }
        }
        return hr;
    }

	bool OutRegWritten[16];

	HRESULT DoOut(const D3DVsInstruction* pI, StallType reason){
        HRESULT hr = S_OK;

		scoreboard.StartNewInstruction();

        if(pI->rwm){
            if(pI->rw >= 12){
                SETERROR(hr, E_FAIL);
            }
            scoreboard.Start(MacOpType(pI), pI->rw, pI->rwm, currentCycle, reason);
        }
        if(pI->swm){
            DWORD ilu_rw = (pI->mac && pI->ilu) ? 1 : pI->rw;
            scoreboard.Start(ILUOpType(pI), ilu_rw, pI->swm, currentCycle, reason);
        }
        if(pI->owm){
            bool oc_output = (pI->oc & 0x0100) != 0;
            DWORD oc_index = pI->oc & 0xff;
            if(oc_output){
				OutRegWritten[oc_index] = true;
                if(oc_index == 0){ // oPos is shadowed as r[12]
                    if(pI->om == 0) { //if MAC writes to oPos
						scoreboard.Start(MacOpType(pI), 12, pI->owm, currentCycle, reason);
					} else { //if ILU writes to oPos
						scoreboard.Start(ILUOpType(pI), 12, pI->owm, currentCycle, reason);
					}
                }
            }
        }

		if(pI->mac == 13) {
			scoreboard.Start(eARL, 13, 1, currentCycle, reason); //for the .16-cycle arl stall
		}

        return hr;
    }

    bool STMuxReady(const D3DVsInstruction* pI,
        DWORD mx, UCHAR rr, DWORD ne, DWORD xs, DWORD ys, 
        DWORD zs, DWORD ws, UCHAR muxIndex, UCHAR useMask, int cycle){
        // we don't care about ne at all
        switch(mx){
        case MX_R:
            {
                // See how many cycles until we're ready
                return STRegReady(pI, muxIndex, rr, useMask, cycle);
            }
        case MX_V:
            return true; // reading from inputs doesn't stall.
        case MX_C:
            {
                int age = cycle - c[Bank(pI->crr)];
                return age >= 6;
            }
        default:
            return true;
        }
    }

	float MuxReady(const D3DVsInstruction* pI,
        DWORD mx, UCHAR rr, DWORD ne, DWORD xs, DWORD ys, 
        DWORD zs, DWORD ws, UCHAR muxIndex, UCHAR useMask, float cycle, StallType& reason){
		
		reason = eNone;
        // we don't care about ne at all
        switch(mx){
        case MX_R:
            {
                // See how many cycles until we're ready
                return RegReady(pI, muxIndex, rr, useMask, cycle, reason);
            }
        case MX_V:
            return 0.0f; // reading from inputs doesn't stall.
        case MX_C:
			//reading from constants doesn't stall unless you just wrote to a0.x

			if(pI->cin) {
				return scoreboard.Ready(13, 0 /*, cycle*/, false, reason);
			}
            return 0.0f; 

        default:
            return 0.0f; //???
        }
    }

    bool STRegReady(const D3DVsInstruction* pI, UCHAR muxIndex, UCHAR rr, UCHAR useMask, int cycle){
        for(int c = 0; c < 4; c++){
            UCHAR cMask = 1 << c;
            if(useMask & cMask){
                if( STscoreboard.Ready(rr, c, cycle)) {
                    continue; // No stall from this component
                }
                else if (STscoreboard.TakeBypass(pI, muxIndex, rr, cMask, cycle))
                {
                    continue; // Bypass worked
                }
                return false; // not ready
            }
        }
        return true;
    }

	float RegReady(const D3DVsInstruction* pI, UCHAR muxIndex, UCHAR rr, UCHAR useMask, float cycle, StallType& reason){
		reason = eNone;
		float stall = 0.0f;
        for(int c = 0; c < 4; c++){
            UCHAR cMask = 1 << c;
            if(useMask & cMask){
				bool IsAluCInput;
				if(muxIndex == 2 && !pI->ilu) {
					IsAluCInput = true;
				} else {
					IsAluCInput = false;
				}

				StallType tempreason = eNone;
				float whenready = scoreboard.Ready(rr, c /*,cycle*/, IsAluCInput, tempreason);
				if(stall <= whenready) {
					stall = whenready;
					reason = tempreason;
				}
            }
        }
        return stall;
    }


//    bool isVertexShader;
//    bool isReadWriteShader;
    bool isMultiThreaded;

    float currentCycle; // In cycles, what cycle we're currently on. Starts at zero

    int c[2]; // For vertex state shaders and read/write vertex shaders
                // c[0] means constants in bank 0 (c[0]..c[3], etc.)
                // c[1] means constants in bank 1 (c[4]..c[7], etc.)

    // for calculating bypass.

    struct STRegScoreboard {
        int resultCycle[13][4];
        OpType resultOpType[13][4];
        void Clear() {
            for(int i = 0; i < 13;i++){
                for(int j = 0; j < 4; j++){
                    resultCycle[i][j] = -6;
                    resultOpType[i][j] = eOther;
                }
            }
        }

        void Start(OpType opType, UCHAR r, UCHAR useMask, int cycle){
            for(int c = 0; c < 4;c++){
                if((1 << c) & useMask){
                    resultCycle[r][c] = cycle + 6;
                    resultOpType[r][c] = opType;
                }
            }
        }

        bool Ready(UCHAR r, int c, int cycle){
            return resultCycle[r][c] <= cycle;
        }

        bool TakeBypass(const D3DVsInstruction* pI, DWORD muxIndex, UCHAR r, UCHAR useMask, int cycle){
            bool bTakeBypass = false;
            for(int c = 0; c < 4; c++){
                if((1 << c) & useMask){
                    // Is it 3 cycles since the operation occured
                    if(cycle != resultCycle[r][c] - 3){
                        return false; // Nope, not the bypass cycle
                    }
                    // MLU bypass
                    if(resultOpType[r][c] == eMLU){
                        bTakeBypass = true;
                        continue;
                    }
                    // Thes other two bypasses are for the C input of ADD and MAD only
                    if(muxIndex != 2){
                        return false;
                    }
                    if(pI->mac != MAC_ADD && pI->mac != MAC_MAD){
                        return false;
                    }

                    if(pI->ilu ){
                        // Check whether the ILU instruction actually uses this component
                        // before bailing.
                        UCHAR useMasks[3];
                        D3DVsInstruction test = *pI;
                        StripMacInstruction(&test);
                        ComputePostSwizzleUseMasks(&test, useMasks);
                        if(useMasks[2] & (1 << c)){
                            // Need to wait for ILU instruction, even if mac instruction's OK
                            return false;
                        }
                    }

                    // ALU bypass
                    if(resultOpType[r][c] == eALU && muxIndex == 2){
                        bTakeBypass = true;
                        continue;
                    }
                    // ILU bypass
                    if(resultOpType[r][c] == eILU && muxIndex == 2){
                        bTakeBypass = true;
                        continue;
                    }
                    return false;
                }
            }
            return bTakeBypass;
        }
    };

    STRegScoreboard STscoreboard;


    struct RegScoreboard {
        float resultCycle       [14][4];     //stall if used by MLU or ILU
        float resultCycleAlu    [14][4];  //stall if used by ALU's second input
        float resultNextCycle   [14][4]; //stall if used in the next instruction 
        float resultNextCycleAlu[14][4]; //stall if used in the next instruction's Alu (note: usually the same as NextCycle non-alu) 

		StallType resultReason       [14][4];
		StallType resultReasonAlu    [14][4];
		StallType resultNextReason   [14][4];
		StallType resultNextReasonAlu[14][4];

		int numCycles;

        void Clear(int NumCycles) {
            for(int i = 0; i < 13;i++){
                for(int j = 0; j < 4; j++){
                    resultCycle       [i][j] = 2.5f; //the first instruction, temp registers stall 2.5 cycles (if you read them uninitialized)
                    resultCycleAlu    [i][j] = 2.5f; 
					//If you write a temp register in the first inst, then read it in the second, it stalls about 1.5
					//However, if it stalls in this manner, it will remove any stall in the next instruction
                    resultNextCycle   [i][j] = 1.5f; 
                    resultNextCycleAlu[i][j] = 1.5f;
					resultReason       [i][j] = eRegInit;
					resultReasonAlu    [i][j] = eRegInit;
					resultNextReason   [i][j] = eRegInit;
					resultNextReasonAlu[i][j] = eRegInit;

                }
            }
			resultCycle[13][0] = 0.0f;
			resultReason[13][0] = eNone;
			numCycles = NumCycles;
        }

		void StartNewInstruction()
		{
			resultCycle[13][0] = 0.0f;
			resultReason[13][0] = eNone;
			
            for(int i = 0; i < 14;i++){
                for(int j = 0; j < 4; j++){
					resultCycle[i][j] = resultNextCycle[i][j];
					resultReason[i][j] = resultNextReason[i][j];
					resultCycleAlu[i][j] = resultNextCycleAlu[i][j];
					resultReasonAlu[i][j] = resultNextReasonAlu[i][j];

                    resultNextCycle   [i][j] = 0.0f;
                    resultNextCycleAlu[i][j] = 0.0f;
					resultNextReason   [i][j] = eNone;
					resultNextReasonAlu[i][j] = eNone;
				}
			}
		}

        void Start(OpType opType, UCHAR r, UCHAR useMask, float cycle, StallType reason){
			//reason == reason the current instruction stalled / didn't stall
			//opType: if eMLU, it can use the MLU bypass
			//r: the particular register being written
			//usemask: xyzw components of the register being written
			//cycle: the current cycle of the program.
			
			//a0.x's stall and shadow are smaller than everything else's, so deal with that seperately.
			int c; 
			if(r == 13) {
				float a0xstall = 0.17f;
				StallType a0xreason = eArl;
				
				if(reason == eStandard || reason == eStandardAndShadow || reason == eStandardAndBypShad) {
					//a0.x's shadow only appears in larger shaders, when writing to a0.x stalls after the third instruction.
					//its shadow also does not occur in the second instruction, like standard stall's shadows do.
					if(numCycles > 10 && cycle > 2) {
						a0xstall = 0.33f;
					}
					StallType a0xreason = eArlShadow;
				}

				resultCycle[r][0] = a0xstall;
				resultReason[r][0] = a0xreason;
				resultCycleAlu[r][0] = a0xstall;
				resultReasonAlu[r][0] = a0xreason;

				resultNextCycle[r][0]    = 0.0f;
				resultNextReason[r][0]   = eNone;
				resultNextCycleAlu[r][0] = 0.0f;
				resultNextReasonAlu[r][0] = eNone;
				return;
			}

            for(c = 0; c < 4;c++){
                if((1 << c) & useMask){

					switch (reason) 
					{
					case eRegInit:  //doesn't cuase any further problems, and does eliminate any future initialization issues
						resultNextCycle[r][c]    = 0.0f;
						resultNextReason[r][c]   = eNone;
						resultNextCycleAlu[r][c] = 0.0f;
						resultNextReasonAlu[r][c] = eNone;
						resultCycle[r][c]    = 0.0f;
						resultReason[r][c]   = eBypass;
						resultCycleAlu[r][c] = 0.0f;
						resultReasonAlu[r][c] = eBypass;
						break;

					case eNone:      //no stall or bypass
					case eShadow:    //we just dealt with a shadow, but no normal stalls. Continue as normal.
					case eArl:       //a0.x stalled, but that won't cause shadow-stalls though
					case eArlShadow: //a0.x stalled & dropped a shadow, but that won't cause shadow-stalls though

						if(opType == eMLU) { //(mac instructions that only use the mlu)

							resultNextCycle[r][c]    = 0.0f;
							resultNextReason[r][c]   = eNone;
							resultNextCycleAlu[r][c] = 0.0f;
							resultNextReasonAlu[r][c] = eNone;

							//if we just waited for register initialization, we don't have to worry about it again.
							//If the register hasn't been initialized by hardware yet, we can't make that stall go away.

							if(resultReason[r][c] != eRegInit && reason != eRegInit) {
								resultCycle[r][c]    = 0.0f;
								resultCycleAlu[r][c] = 0.0f;
								resultReason[r][c]   = eBypass;
								resultReasonAlu[r][c] = eBypass;

							} else {
								//Registers suffering from initialization stalls don't cause shadows.
								//In fact, if a register stalls from both initialization and normal stall, 
								//  it casts a 0.1 cycle anti-shadow. I'm not sure how to deal with that 
								//  though, and it is somewhat minor in a situation that should be avoided anyway...
								//Nothing can change how long register initialization takes though
							}

						} else //(ilu) or (mac instruction that uses alu)
						{
							resultNextCycle[r][c]    = 0.0f;
							resultNextReason[r][c]   = eNone;
							resultNextCycleAlu[r][c] = 0.0f;
							resultNextReasonAlu[r][c] = eNone;
							
							if(resultReason[r][c] != eRegInit && reason != eRegInit) {
								resultCycle[r][c]    = 0.5f;
								resultReason[r][c]   = eStandard;
								resultCycleAlu[r][c] = 0.0f;
								resultReasonAlu[r][c] = eBypass;
							}
						}
						break;


					case eStandard:
					case eStandardAndShadow:
					case eStandardAndBypShad:
						//can cast lots of different shadows

						{
							float twoshadow = 0.4f;
							if((numCycles < 10) || (cycle < 4)) twoshadow = 0.2f;

							resultNextCycle[r][c]    = twoshadow;
							resultNextReason[r][c]   = eShadow;
							resultNextCycleAlu[r][c] = twoshadow;
							resultNextReasonAlu[r][c] = eShadow;
						}

						if(opType == eMLU) { //(mac instructions that only use the mlu)

							if(resultReason[r][c] != eRegInit) 
							{
								//... stall, bypass, ...

								//the rule: if three-instruction group starts on the third, fifth, or seventh cycle, the stall is only .2.
								//"fifth" being one-based, not zero-based. Meaning, cycle == 2.0 on the previous instruction, so
								//3.0 for the current instruction (hence, 2, 3, 4)...

								if(Epsilon(cycle, 2, .3f) || Epsilon(cycle, 3, .3f) || Epsilon(cycle, 4, .3f) || (numCycles >= 5 && numCycles <= 9)) 
								{
									resultCycle[r][c] = 0.2f;
									resultReason[r][c] = eBypassAndShadow;
									resultCycleAlu[r][c] = 0.2f;
									resultReasonAlu[r][c] = eBypassAndShadow;
								} else {
									resultCycle[r][c] = 0.5f;
									resultReason[r][c] = eBypassAndShadow;
									resultCycleAlu[r][c] = 0.5f;
									resultReasonAlu[r][c] = eBypassAndShadow;
								}
							}
						} 
						else { //ALU, MLU+ALU, or ILU instructions 

							if(resultReason[r][c] != eRegInit) {

								//if next inst is ALU-only,
								//   ... stall, bypass, ...
								//else
								//   ... stall, stall, ...
								//

								if(Epsilon(cycle, 2, .3f) || Epsilon(cycle, 3, .3f) || Epsilon(cycle, 4, .3f) || (numCycles >= 5 && numCycles <= 9)) 
								{
									resultCycleAlu[r][c] = 0.2f;
									resultReasonAlu[r][c] = eBypassAndShadow;
								} else {
									resultCycleAlu[r][c] = 0.5f;
									resultReasonAlu[r][c] = eBypassAndShadow;
								}

								if(numCycles < 10) {
									resultCycle[r][c]    = 0.5f;
									resultReason[r][c]   = eStandard;
								} else if (Epsilon(cycle, 2, .3f) || Epsilon(cycle, 3, .3f)) {
									resultCycle[r][c]    = 1.3f;
									resultReason[r][c]   = eStandardAndShadow;									
								} else {
									resultCycle[r][c]    = 1.05f;
									resultReason[r][c]   = eStandardAndShadow;									
								}
							}
						}

						break;

					case eBypass:
					case eBypassAndShadow:
						//mostly normal, unless a stall occurs

						if(opType == eMLU) { //(mac instructions that only use the mlu)

							//... bypass, bypass, ...

							//we can't stall, and bypasses don't case shadows unless followed by a stall
							resultNextCycle[r][c]    = 0.0f;
							resultNextReason[r][c]   = eNone;
							resultNextCycleAlu[r][c] = 0.0f;
							resultNextReasonAlu[r][c] = eNone;

							if(resultReason[r][c]  != eRegInit) {
								resultCycle[r][c]    = 0.0f;
								resultReason[r][c]   = eBypass;
								resultCycleAlu[r][c] = 0.0f;
								resultReasonAlu[r][c] = eBypass;

							}

						} else { //ALU, MLU+ALU, or ILU instructions.
							//if next inst is ALU only, 
							// ... bypass, bypass ...
							//else
							// ... bypass, stall ...

							resultNextCycle[r][c]    = 0.0f;
							resultNextReason[r][c]   = eNone;
							resultNextCycleAlu[r][c] = 0.0f;
							resultNextReasonAlu[r][c] = eNone;

							if(resultReason[r][c] != eRegInit) {

								if(Epsilon(cycle, 1, .3f)) {
									resultCycle[r][c]    = 0.6f;
									resultReason[r][c]   = eStandardAndBypShad;
								} else if (Epsilon(cycle, 3, .3f) || Epsilon(cycle, 3.5, .3f)) {
									resultCycle[r][c]    = 0.72f;
									resultReason[r][c]   = eStandardAndBypShad;
								} else {
									resultCycle[r][c]    = 0.83f;
									resultReason[r][c]   = eStandardAndBypShad;
								}

								resultCycleAlu[r][c] = 0.0f;
								resultReasonAlu[r][c] = eBypass;
							}
						}

						break;
					}
                }
            }
        }

        float Ready(UCHAR r, int c, /*int cycle,*/ bool IsAluCInput, StallType& reason){
			float stall;
			if(IsAluCInput) {
				reason = resultReasonAlu[r][c];
				stall  = resultCycleAlu[r][c];
			} else {
				reason = resultReason[r][c];
				stall  = resultCycle[r][c];
			}
			return stall;
        }


    };

    RegScoreboard scoreboard;


};


// Dead code stripper

class DeadCodeStripper {
    struct RegMask {
        UCHAR reg;
        UCHAR mask;
    };
    struct OutRegMaskSet {
        UCHAR CombinedWriteMask() const { return o.mask | r.mask | s.mask; }
        UCHAR MacWriteMask() const { return r.mask | ( outIsMac ? o.mask : 0); }
        UCHAR IluWriteMask() const { return s.mask | (!outIsMac ? o.mask : 0); }
        bool outIsMac;
        RegMask o;
        RegMask r; // mac (also ARL)
        RegMask s; // ilu
    };
    struct InRegMaskSet {
        RegMask a;
        RegMask b;
        RegMask c;
        RegMask a0; // Index register
    };
    struct FullRegMaskSet {
        InRegMaskSet in;
        OutRegMaskSet out;
    };

public:
    DeadCodeStripper(){
    }
    
    ~DeadCodeStripper(){
    }
    
    HRESULT Run(DWORD shaderType, D3DVertexShaderProgram* ucode){
        HRESULT hr = S_OK;
        hr = InitRegisters(shaderType);

        // Copy the ucode program backwards into a temporary buffer,
        // skipping instructions with no effect, and narrowing masks
        // as we go.
        D3DVsInstruction* temp = new D3DVsInstruction[MAX_MICROCODE_LENGTH];
		if(temp == NULL) {
			return E_OUTOFMEMORY;
		}
        D3DVsInstruction* pIn = & ucode->ucode[ucode->length - 1];
        D3DVsInstruction* pOut = temp;
        D3DVsInstruction* pInEnd = & ucode->ucode[-1];
        for(;pIn > pInEnd && SUCCEEDED(hr); pIn--){
#ifdef DBG_STRIPPER
            DPF2("%d: ", pIn - pInEnd + 1);
            Print(*pIn);
#endif
            hr = ProcessInstruction(pIn,pOut);
        }
        if(SUCCEEDED(hr)){
            // Copy the stripped program backwards into the original program
            DWORD newLength = pOut - temp;
            for(DWORD i = 0; i < newLength; i++){
                ucode->ucode[i] = temp[newLength - (i+1)];
            }
            ucode->length = newLength;
        }
#ifdef DBG_STRIPPER
        if(SUCCEEDED(hr)){
            DPF2("Post-stripped code\n");
            Print(shaderType, *ucode);
        }
#endif
        delete [] temp;
        return hr;
    }

    HRESULT ProcessInstruction(const D3DVsInstruction* pIn, D3DVsInstruction*& pOut){
        HRESULT hr = S_OK;
        D3DVsInstruction temp = *pIn;
        FullRegMaskSet masks;
        memset(&masks,0,sizeof(masks));
        hr = CalcOutputMasks(temp, masks.out);
#ifdef DBG_STRIPPER
            PrintOutMasks("initial out", masks.out);
#endif
        if(SUCCEEDED(hr)){
            hr = NarrowOutputMasks(temp, masks.out);
        }
#ifdef DBG_STRIPPER
            PrintOutMasks("after NarrowOutputMasks out", masks.out);
#endif
        if(SUCCEEDED(hr)){
            hr = UpdateCode(temp, masks.out);
        }
        if(SUCCEEDED(hr)){
            hr = RemoveNullMoves(temp);
        }

#ifdef DBG_STRIPPER
        if(SUCCEEDED(hr)){
            DPF2("updated: ");
            Print(temp);
        }
#endif
        if(SUCCEEDED(hr)){
            if(! IsNOP(temp) && masks.out.CombinedWriteMask() ) {
                hr = CalcInputMasks(temp, masks.out, masks.in);
                // We're moving backwards in time, so we record the outputs before the inputs.
                // This is important when the same register is used for both input and output.
                if(SUCCEEDED(hr)){
                    hr = RecordOutputMasks(temp, masks.out);
                }
                if(SUCCEEDED(hr)){
                    hr = RecordInputMasks(temp, masks.in);
                }
                if(SUCCEEDED(hr) && (temp.ilu || temp.mac)){
                    *pOut++ = temp;
                }
            }
            else {
#ifdef DBG_STRIPPER
                DPF2("Removing dead code instruction\n");
#endif
            }
        }
        return hr;
    }

    // Is the temp-register mac portion of this instruction is a mov of a register to itself
    static bool IsMacMovRegNOP(const D3DVsInstruction& code){
        return code.mac == MAC_MOV
            && code.amx == MX_R
            && code.rwm
            && code.arr == code.rw
            && ! code.ane
            && (! (code.rwm & 8) || code.axs == CSW_X)
            && (! (code.rwm & 4) || code.ays == CSW_Y)
            && (! (code.rwm & 2) || code.azs == CSW_Z)
            && (! (code.rwm & 1) || code.aws == CSW_W)
            ;
    }

    // Is the output-register mac portion of this instruction is a mov of a constant to itself
    static bool IsMacMovConstNOP(const D3DVsInstruction& code){
        // TODO: Check for mov oPos,r12
        return code.mac == MAC_MOV
            && code.amx == MX_C
            && ! code.cin
            && code.owm && code.om == OM_MAC && (code.oc & 0x100) == 0 // writing to constant register
            && (code.oc & 0xff) == code.ca // reading & writing from same constant register
            && ! code.ane
            && (! (code.owm & 8) || code.axs == CSW_X)
            && (! (code.owm & 4) || code.ays == CSW_Y)
            && (! (code.owm & 2) || code.azs == CSW_Z)
            && (! (code.owm & 1) || code.aws == CSW_W)
            ;
    }

    // Is the temp-register ilu portion of this instruction is a mov of a register to itself
    static bool IsIluMovRegNOP(const D3DVsInstruction& code){
        return code.ilu == ILU_MOV
            && code.cmx == MX_R
            && code.swm
            && ((code.crr == code.rw && ! code.mac) || (code.mac && code.crr == 1))
            && ! code.cne
            && (! (code.swm & 8) || code.cxs == CSW_X)
            && (! (code.swm & 4) || code.cys == CSW_Y)
            && (! (code.swm & 2) || code.czs == CSW_Z)
            && (! (code.swm & 1) || code.cws == CSW_W)
            ;
    }

    // Is the output-register ilu portion of this instruction is a mov of a constant to itself
    static bool IsIluMovConstNOP(const D3DVsInstruction& code){
        // TODO: Check for mov oPos,r12
        return code.ilu == ILU_MOV
            && code.cmx == MX_C
            && ! code.cin
            && code.owm && code.om == OM_ILU && (code.oc & 0x100) == 0 // writing to constant register
            && (code.oc & 0xff) == code.ca // reading & writing from same constant register
            && ! code.cne
            && (! (code.owm & 8) || code.cxs == CSW_X)
            && (! (code.owm & 4) || code.cys == CSW_Y)
            && (! (code.owm & 2) || code.czs == CSW_Z)
            && (! (code.owm & 1) || code.cws == CSW_W)
            ;
    }

    static HRESULT RemoveNullMoves(D3DVsInstruction& code){
        if(IsMacMovRegNOP(code)){
            code.rwm = 0;
        }
        if(IsMacMovConstNOP(code)){
            code.owm = 0;
        }
        if(IsIluMovRegNOP(code)){
            code.swm = 0;
        }
        if(IsIluMovConstNOP(code)){
            code.owm = 0;
        }
        
        return S_OK;
    }
    
    static bool IsNOP(const D3DVsInstruction& code){
        bool macIsNOP = code.mac == 0;
        bool iluIsNOP = code.ilu == 0;
        if(!macIsNOP){
            macIsNOP = ((! (code.om == OM_MAC && code.owm)) && IsMacMovRegNOP(code))
                   || ((! code.rwm) && IsMacMovConstNOP(code));
        }
        if(macIsNOP && !iluIsNOP){
            iluIsNOP = ((! (code.om == OM_ILU && code.owm)) && IsIluMovRegNOP(code))
                   || ((! code.swm) && IsIluMovConstNOP(code));
        }
        if (macIsNOP && iluIsNOP){
            return true;
        }
        return false;
    }

    static HRESULT CalcOutputMasks(const D3DVsInstruction& code, OutRegMaskSet& out){
        HRESULT hr = S_OK;
        memset(&out,0,sizeof(out));
        if(code.mac){
            // MAC output masks
            if(code.mac == MAC_ARL){
                out.r.mask = 8; // Just x register.
                out.r.reg = REG_ARL;
            }
            if(code.rwm) {
                out.r.mask = code.rwm;
                out.r.reg = REG_R0 + code.rw;
            }
            if(code.om == OM_MAC && code.owm){
                out.outIsMac = true;
                out.o.mask = code.owm;
                out.o.reg = (code.oc & 0x100) ? REG_O0 + (code.oc & 0xff) : REG_C0 + (code.oc & 0xff);
            }
        }
        
        if(SUCCEEDED(hr)){
            if(code.ilu){
                if(code.om == OM_ILU && code.owm){
                    out.outIsMac = false;
                    out.o.mask = code.owm;
                    out.o.reg = (code.oc & 0x100) ? REG_O0 + (code.oc & 0xff) : REG_C0 + (code.oc & 0xff);
                }
                if(code.swm) {
                    out.s.mask = code.swm;
                    if(code.mac){
                        out.s.reg = REG_R1;
                    }
                    else {
                        out.s.reg = REG_R0 + code.rw;
                    }
                }
            }
        }
        return hr;
    }

    static HRESULT UpdateCode(D3DVsInstruction& code, const OutRegMaskSet& out){
        HRESULT hr = S_OK;

        bool oldMac = code.mac != 0;
        
        if(code.mac){
            if(!out.MacWriteMask()){
                code.mac = 0;
                code.rwm = 0;
                if(code.om == OM_MAC){
                    code.owm = 0;
                    code.oc = 0x1ff;
                }
            }
            else {
                // MAC output masks
                if(code.mac == MAC_ARL){
                    // do nothing
                }
                if(code.om == OM_MAC && code.owm){
                    code.owm = out.o.mask;
                }
                if(code.rwm) {
                    code.rwm = out.r.mask;
                }
            }
        }
        
        if(SUCCEEDED(hr)){
            if(code.ilu){
                if(!out.IluWriteMask()){
                    code.ilu = 0;
                    code.swm = 0;
                    if(code.om == OM_ILU){
                        code.owm = 0;
                        code.oc = 0x1ff;
                    }
                }
                else {
                    if(code.om == OM_ILU && code.owm){
                        code.owm = out.o.mask;
                    }
                    if(code.swm) {
                        code.swm = out.s.mask;
                        // Check for special case - was paired instruction,
                        // but is now not a paired instruction, so we're now
                        // responsible for setting rw to 1.
                        if(oldMac && ! code.mac){
                            code.rw = 1;
                        }
                    }
                }
            }
        }
        return hr;
    }

    // See also CVSInstruction::CalculateComponentReadMasks

    static HRESULT CalcInputMasks(const D3DVsInstruction& code, const OutRegMaskSet& out, InRegMaskSet& in){
        HRESULT hr = S_OK;

        in.a0.reg = REG_ZER; //unused enumeration

        UCHAR aMask = 0;
        UCHAR bMask = 0;
        UCHAR cMask = 0;
        switch(code.mac){
        case MAC_NOP:
            // nothing to do
            break;

            // Passthru - read what they write
        case MAC_MOV:
            aMask = out.MacWriteMask();
            break;
        case MAC_MUL:
        case MAC_MIN:
        case MAC_MAX:
        case MAC_SLT:
        case MAC_SGE:
            aMask =
                bMask = out.MacWriteMask();
            break;
        case MAC_ADD:
            aMask =
                cMask = out.MacWriteMask();
            break;
        case MAC_MAD:
            aMask =
                bMask =
                cMask = out.MacWriteMask();
            break;

        case MAC_DP3:
            aMask = 0xe; // xyz
            bMask = 0xe; // xyz
            break;
        case MAC_DPH:
            aMask = 0xe; // xyz
            bMask = 0xf; // xyzw
            break;
        case MAC_DP4:
            aMask = 0xf; // xyzw
            bMask = 0xf; // xyzw
            break;
        case MAC_DST:
            aMask = 0x6; //  yz
            bMask = 0x5; //  y w
            break;

        case MAC_ARL:
            aMask = 0x8; // x
            break;
        default:
            DXGRIP("Unknown MAC opcode");
            SETERROR(hr, E_FAIL);
            break;
        }

        switch(code.ilu){
        case ILU_NOP:
            break;
        case ILU_MOV:
            cMask |= out.IluWriteMask();
            break;
        case ILU_RCP:
        case ILU_RCC:
        case ILU_RSQ:
        case ILU_EXP:
        case ILU_LOG:
            cMask |= 0x8; // x , yes x not w
            break;
        case ILU_LIT:
            cMask |= 0xd; // xy w
            break;
        default:
            DXGRIP("Unknown ILU opcode");
            SETERROR(hr, E_FAIL);
            break;
        }

        // aMask, bMask, and cMask are the post-swizzle masks. Un-swizzle them
        if(SUCCEEDED(hr)){
            hr = UnswizzleMask(in.a.mask, aMask, code.axs, code.ays, code.azs, code.aws);
        }
        if(SUCCEEDED(hr)){
            hr = UnswizzleMask(in.b.mask, bMask, code.bxs, code.bys, code.bzs, code.bws);
        }
        if(SUCCEEDED(hr)){
            hr = UnswizzleMask(in.c.mask, cMask, code.cxs, code.cys, code.czs, code.cws);
        }

        if(SUCCEEDED(hr)){
            hr = CalcInputReg(aMask, in, in.a.reg, code, code.arr, code.amx);
        }
        if(SUCCEEDED(hr)){
            hr = CalcInputReg(bMask, in, in.b.reg, code, code.brr, code.bmx);
        }
        if(SUCCEEDED(hr)){
            hr = CalcInputReg(cMask, in, in.c.reg, code, code.crr, code.cmx);
        }
        return hr;
    }

    static HRESULT UnswizzleMask(UCHAR& mask, UCHAR swizMask,
        WORD xs,  WORD ys, WORD zs,  WORD ws)
    {
        HRESULT hr = S_OK;
        // Mask means "reads this component. bit 0 == w, 1 = z, 2 = y, 3 = x"
        // swizzle s# means "the component # comes from this other component (0 = take source from X)
        // So identity swizzle is xs = 0, ys = 1, zs = 2, ws = 3
        UCHAR useX = (swizMask & 8) >> 3;
        UCHAR useY = (swizMask & 4) >> 2;
        UCHAR useZ = (swizMask & 2) >> 1;
        UCHAR useW = (swizMask & 1) >> 0;
        mask =
            (useX << (3-xs)) |  // If we use X, then where does X come from
            (useY << (3-ys)) |  // If we use Y, then where does Y come from
            (useZ << (3-zs)) |  // If we use Z, then where does Z come from
            (useW << (3-ws));   // If we use W, then where does W come from

        return hr;
    }

    static HRESULT CalcInputReg(UCHAR operationMask, InRegMaskSet& masks, UCHAR& reg,
        const D3DVsInstruction& code, WORD rr, WORD mx)
    {
        HRESULT hr = S_OK;
        if(operationMask){
            switch(mx){
            case MX_R:
                reg = REG_R0 + rr;
                break;
            case MX_V:
                reg = REG_V0 + code.va;
                break;
            case MX_C:
                reg = REG_C0 + code.ca;
                if(code.cin){
                    masks.a0.reg = REG_ARL;
                    masks.a0.mask = 8;// Just X
                }
                break;
            default:
                DXGRIP("Unexpected mx");
                break;
            }
        }
        else {
            reg = REG_ZER; // This input register is not used.
        }
        return hr;
    }

    HRESULT NarrowOutputMasks(const D3DVsInstruction& code, OutRegMaskSet& out){
        HRESULT hr = S_OK;

        // Narrow input masks based on computed 

        if(code.mac){
            // MAC instruction
            hr = NarrowOutputMask(code, out.r);
            if(SUCCEEDED(hr)){
                if(out.outIsMac){
                    hr = NarrowOutputMask(code, out.o);
                }
            }
        }
        if(SUCCEEDED(hr)){
            if(code.ilu){
                hr = NarrowOutputMask(code, out.s);
            }
            if(SUCCEEDED(hr)){
                if(!out.outIsMac){
                    hr = NarrowOutputMask(code, out.o);
                }
            }
        }

        return hr;
    }


    HRESULT NarrowOutputMask(const D3DVsInstruction& code, RegMask& mask){
        HRESULT hr = S_OK;
        // Working backwards in time
        // if code writes to a register that's in the written state, that's dead code
        // because nobody reads the value before it's overwritten.

        if(mask.reg >= REG_C0 && mask.reg < REG_C0+192){
            // This register might have been read by a later a0.x read.
            // Need to track a0.x reads at a finer granularity
            mask.mask &= ( m_anyPRRead | (0xf & (~ m_regLastWritten[mask.reg])) );
        }
        else {
            mask.mask &= ( 0xf & (~ m_regLastWritten[mask.reg]) );
        }

        // if code writes to a temp register (including ARL) that's in the unused state,
        // that's dead code because nobody reads the result.

        if(mask.reg >= REG_R0 && mask.reg <= REG_R11 || mask.reg == REG_ARL){
            mask.mask &= (0xf &  m_regUsed[mask.reg]);
        }
        return hr;
    }

    HRESULT RecordOutputMasks(const D3DVsInstruction& code, const OutRegMaskSet& out){
        HRESULT hr = S_OK;
        if(code.mac){
            hr = RecordOutputMask(code, out.r);
            if(SUCCEEDED(hr)){
                if(out.outIsMac){
                    hr = RecordOutputMask(code, out.o);
                }
            }
        }
        if(SUCCEEDED(hr)){
            if(code.ilu){
                hr = RecordOutputMask(code, out.s);
            }
            if(SUCCEEDED(hr)){
                if(!out.outIsMac){
                    hr = RecordOutputMask(code, out.o);
                }
            }
        }
        return hr;
    }

#ifdef DBG_STRIPPER
    void PrintMask(const char* label, const RegMask& mask){
        char regName;
        int regOffset;
        if(mask.reg >= REG_V0 && mask.reg <= REG_V15){
            regName = 'v';
            regOffset = mask.reg - REG_V0;
        }
        else if(mask.reg >= REG_O0 && mask.reg <= REG_O15){
            regName = 'o';
            regOffset = mask.reg - REG_O0;
        }
        else if(mask.reg >= REG_C0 && mask.reg < REG_C0+192){
            regName = 'c';
            regOffset = mask.reg - REG_C0 - 96;
        }
        else if(mask.reg >= REG_R0 &&mask.reg <= REG_R15){
            regName = 'r';
            regOffset = mask.reg - REG_R0;
        }
        else if(mask.reg == REG_ARL){
            regName = 'a';
            regOffset = mask.reg - REG_ARL;
        }
        else {
            regName = '?';
            regOffset = mask.reg - REG_ZER;
        }
        static const char* kDecodeOutputMask[16] = {
            "____", // 0
            "   w", // 1
            "  z ", // 2
            "  zw", // 3
            " y  ", // 4
            " y w", // 5
            " yz ", // 6
            " yzw", // 7
            "x   ", // 8
            "x  w", // 9
            "x z ", // a
            "x zw", // b
            "xy  ", // c
            "xy w", // d
            "xyz ", // e
            "xyzw"  // f
        };

        DPF2("%s %c[%3d] = 0x%x %s\n", label, regName, regOffset, mask.mask, kDecodeOutputMask[mask.mask]);
    }
    void PrintOutMasks(const char* label, const OutRegMaskSet& maskSet){
        DPF2("%s:\n", label);
        if(maskSet.r.reg){
            PrintMask(" .r",maskSet.r);
        }
        if(maskSet.s.reg){
            PrintMask(" .s",maskSet.s);
        }
        if(maskSet.o.reg){
            PrintMask(maskSet.outIsMac ? " .o[OM_MAC]" : ".o[OM_ILU]", maskSet.o );
        }
    }
#endif

    HRESULT RecordOutputMask(const D3DVsInstruction& code, const RegMask& mask){
        HRESULT hr = S_OK;
#ifdef DBG_STRIPPER
        PrintMask("out", mask);
#endif
        m_regUsed[mask.reg] |= mask.mask;
        m_regLastWritten[mask.reg] |= mask.mask;
        if(mask.reg == REG_oPos){ // Writing to REG_oPos also writes to temporary register 12
            m_regUsed[REG_R12] |= mask.mask;
            m_regLastWritten[REG_R12] |= mask.mask;
        }
        return hr;
    }

    HRESULT RecordInputMasks(const D3DVsInstruction& code, const InRegMaskSet& in){
        HRESULT hr = S_OK;
        hr = RecordInputMask(code, in.a, "a");
        if(SUCCEEDED(hr)){
            hr = RecordInputMask(code, in.b, "b");
        }
        if(SUCCEEDED(hr)){
            hr = RecordInputMask(code, in.c, "c");
        }
        if(SUCCEEDED(hr)){
            hr = RecordInputMask(code, in.a0, "a0");
        }
        return hr;
    }

    HRESULT RecordInputMask(const D3DVsInstruction& code, const RegMask& mask,
                            const char* name)
    {
        HRESULT hr = S_OK;
        if(mask.reg != REG_ZER){
#ifdef DBG_STRIPPER
            PrintMask(name, mask);
#endif
            if(code.cin && mask.reg >= REG_C0 && mask.reg < REG_C0 + 192) {
#ifdef DBG_STRIPPER
                DPF2(" +a0.x. Dirtying all c registers.\n");
#endif
                // An indexed read could be reading from any c register
                // so dirty them all.
                m_anyPRRead |= mask.mask;
            }
            else {
                m_regUsed[mask.reg] |= mask.mask;
                m_regLastWritten[mask.reg] &= ~mask.mask;
                // A read of R12 counts as a read of o[0], too
                if(mask.reg == REG_R12){
                    m_regUsed[REG_oPos] |= mask.mask;
                    m_regLastWritten[REG_oPos] &= ~mask.mask;
                }
            }
        }
        return hr;
    }

    HRESULT InitRegisters(DWORD shaderType){
        HRESULT hr = S_OK;
        m_shaderType = shaderType;
        memset(m_regUsed,0,sizeof(m_regUsed));
        memset(m_regLastWritten,0,sizeof(m_regLastWritten));
        if(SASMT_SHADERTYPE(shaderType) != SASMT_VERTEXSHADER) {
            // Mark all the constant registers as read, because
            // the CPU can read the constant registers after the
            // shader runs.
            // Not sure if it makes a difference to avoid
            // doing this for normal Vertex Shaders. But we
            // have to do it for shaders that can write to constant registers.
            
            for(int i = REG_C0; i < REG_C0 + 192; i++){
                m_regUsed[i] = 0xf;
            }
        }
        m_anyPRRead = 0;
        return hr;
    }
private:
    // Track the usage of a register backwards from the future to the past.
    // All registers start out unused
    // reading from a register sets bits in m_regUsed, and clears bits from m_regLastWritten
    // writing to a register sets bits in both m_regUsed and m_regLastWritten
    // Working backwards in time, if code writes to a temp register that's in the unused or written state,
    // that's dead code.
    // if code writes to an out or const register that's in the written state, that's dead code.
    // Unify all registers into one big happy address space, use Register_t to address them
    UCHAR m_regUsed[256];
    UCHAR m_regLastWritten[256];
    UCHAR m_anyPRRead; // Tracks reads using a0.x
    DWORD m_shaderType;
};

//----------- Reorderer ----------------------
//
// Attempt to reorder instructions to reduce stalls.
//
// This version does not rename registers.

class Reorderer {
private:
    class RegSet {
    public:
        RegSet(){
        }
        
        void Clear(){
            memset(r, 0, sizeof(r));
            memset(c, 0, sizeof(c));
            memset(o, 0, sizeof(o));
            a0x = 0;
            anyCReg = 0;
        }

        bool DirtyConflict(const RegSet* r2) const{
            return DirtyConflictTest(r, r2->r, sizeof(r))
                || DirtyConflictTest(c, r2->c, sizeof(c))
                || DirtyConflictTest(o, r2->o, sizeof(o))
                || (a0x && r2->a0x); 
        }

        bool DirtyConflictTest(const UCHAR* a, const UCHAR* b, DWORD size) const{
            for(DWORD i = 0; i < size; i++){
                if(a[i] & b[i]){
                    return true;
                }
            }
            return false;
        }

        // Dirty the registers that are affected by this microcode instruction

        HRESULT DirtyOut(D3DVsInstruction* pI){
            HRESULT hr = S_OK;
            if(pI->mac == MAC_ARL){
                a0x = true;
            }
            if(pI->rwm){
                if(pI->rw > 11){
                    SETERROR(hr, E_FAIL);
                }
                else {
                    r[pI->rw] |= pI->rwm;
                }
            }
            if(pI->swm){
                // When this is a double opcode, and the ilu is writing to
                // a register, then the register has to be 1.
                DWORD ilu_rw = (pI->mac && pI->ilu) ? 1 : pI->rw;
                r[ilu_rw] |= pI->swm;
            }
            if(pI->owm){
                bool oc_output = (pI->oc & 0x0100) != 0;
                DWORD oc_index = pI->oc & 0xff;
                if(oc_output){
                    if(oc_index >= sizeof(o)){
                        SETERROR(hr, E_FAIL);
                    }
                    else {
                        o[oc_index] = pI->owm;
                        if(oc_index == 0){ // oPos is shadowed as r[12]
                            r[12] |= pI->owm;
                        }
                    }
                }
                else {
                    if(oc_index >= 192){
                        SETERROR(hr, E_FAIL);
                    }
                    else {
                        c[oc_index] |= pI->owm;
                        anyCReg |= pI->owm;
                    }
                }
            }
            return hr;
        }

        // Is this instruction reading from any dirty registers?

        bool IsReadDirty(D3DVsInstruction* pI){
            HRESULT hr = S_OK;
            bool dirty = false;
            bool macDirty = false;
            if(pI->mac){
                hr = DoMac(pI, macDirty);
            }
            bool iluDirty = false;
            if(SUCCEEDED(hr)){
                if(pI->ilu){
                    hr = DoILU(pI, iluDirty);
                }
            }
            bool a0Dirty = a0x && pI->cin;
            if(SUCCEEDED(hr)){
                dirty = macDirty || iluDirty || a0Dirty;
            }
            return dirty;
        }

    private:


        bool ADirty(const D3DVsInstruction* pI, UCHAR usedMask){
            return MuxReadDirty(pI, pI->amx, pI->arr, pI->ane, pI->axs, pI->ays, pI->azs, pI->aws, usedMask);
        }
        bool BDirty(const D3DVsInstruction* pI, UCHAR usedMask){
            return MuxReadDirty(pI, pI->bmx, pI->brr, pI->bne, pI->bxs, pI->bys, pI->bzs, pI->bws, usedMask);
        }
        bool CDirty(const D3DVsInstruction* pI, UCHAR usedMask){
            return MuxReadDirty(pI, pI->cmx, pI->crr, pI->cne, pI->cxs, pI->cys, pI->czs, pI->cws, usedMask);
        }

        bool MuxReadDirty(const D3DVsInstruction* pI,
            DWORD mx, DWORD rr, DWORD ne, DWORD xs, DWORD ys, 
            DWORD zs, DWORD ws, UCHAR usedMask){
            // we don't care about ne at all
            HRESULT hr = S_OK;
            bool dirty = false;
            UCHAR usedMask2 = 0;
            if(usedMask & 8) { // x
                usedMask2 = (1<<(3-xs));
            }
            if(usedMask & 4) { // y
                usedMask2 |= (1<<(3-ys));
            }
            if(usedMask & 2) { // z
                usedMask2 |= (1<<(3-zs));
            }
            if(usedMask & 1) { // w
                usedMask2 |= (1<<(3-ws));
            }
            usedMask = usedMask2;
            
            switch(mx){
            case MX_R:
                if(r[rr] & usedMask){
                    dirty = true;
                }
                break;
            case MX_V:
                break; // no way to write to V, so always clean.
            case MX_C:
                if(c[pI->ca] & usedMask){
                    dirty = true;
                }
                if(pI->cin){ // c[a0.x] 
                    if(anyCReg & usedMask){
                        dirty = true; // If we've written to any c register, we might be reading it now.
                    }
                }
                break;
            default:
                SETERROR(hr, E_FAIL);
                break;
            }
            return dirty;
        }
        HRESULT DoMac(const D3DVsInstruction* pI, bool& dirty){
            HRESULT hr = S_OK;
            UCHAR usedMask = pI->rwm | pI->owm;
            switch(pI->mac){
                // No-op
            case MAC_NOP:
                break;
                // One argument - A
            case MAC_ARL:
                dirty = ADirty(pI, 8); // Just uses the x component
                break;
            case MAC_MOV:
                dirty = ADirty(pI, usedMask);
                break;
            case MAC_ADD:
                dirty = ADirty(pI, usedMask);
                dirty = dirty || CDirty(pI, usedMask);
                break;
            case MAC_MAD:
                dirty = ADirty(pI, usedMask);
                dirty = dirty || BDirty(pI, usedMask);
                dirty = dirty || CDirty(pI, usedMask);
                break;
            case MAC_MUL:
            case MAC_MIN:
            case MAC_MAX:
            case MAC_SLT:
            case MAC_SGE:
                dirty = ADirty(pI, usedMask) || BDirty(pI, usedMask);
                break;
            case MAC_DP3: // Uses xyz from source
                dirty = ADirty(pI, 0xe) || BDirty(pI, 0xe);
                break;
            case MAC_DPH: // Uses xyz for a, xyzw for b
                dirty = ADirty(pI, 0xe) || BDirty(pI, 0xf);
                break;
            case MAC_DP4:
                dirty = ADirty(pI, 0xf) || BDirty(pI, 0xf);
                break;
            case MAC_DST:
                dirty = ADirty(pI, 0x6) || BDirty(pI, 0x5);
                break;
            default:
                // Unknown opcode
                SETERROR(hr, E_FAIL);
                break;
            }
            return hr;
        }

        HRESULT DoILU(const D3DVsInstruction* pI, bool& dirty){
            HRESULT hr = S_OK;
            UCHAR usedMask = pI->swm | pI->owm;
            switch(pI->ilu){
            case ILU_NOP:
                break;
            case ILU_MOV:
                dirty = CDirty(pI, usedMask);
                break;
            case ILU_RCP:
            case ILU_RCC:
            case ILU_RSQ:
            case ILU_EXP:
            case ILU_LOG:
                dirty = CDirty(pI, 0x8); // x
                break;
            case ILU_LIT:
                dirty = CDirty(pI, 0xd); // xy w
                break;
            default:
                SETERROR(hr, E_FAIL);
                break;
            }
            return hr;
        }

        // A set bit means this register was written to.
        // bit 0 = w, bit 1 = z, bit 2 = y, bit 3 = x 
        UCHAR r[13]; // r12 is a way of reading from oPos
        UCHAR c[192]; // c registers
        UCHAR o[16]; // o registers
        UCHAR a0x;  // a0.x register
        UCHAR anyCReg; // Used for read/write dirty when a0.x is used
    };

public:

#ifndef DISABLE_VERIFIER
    VerTable* pPreOptimizedTable;
#endif

    Reorderer(){
    }

    HRESULT Run(DWORD shaderType, D3DVertexShaderProgram* ucode){
#ifdef DISABLE_MOVES_TOWARDS_BEGINNING_AFTER_MOVE_NUMBER
        static int gMoveCount;
#endif
#ifdef DISABLE_PAIRS_AFTER_PAIR_NUMBER
        static int gPairCount;
#endif
        HRESULT hr = S_OK;
        m_ucode = ucode;
        hr = m_sim.Initialize(shaderType, ucode->length);
        bool tryPairingAgain = false;
        if(SUCCEEDED(hr)){
            for(int pc = 0; pc < m_ucode->length - 1 && SUCCEEDED(hr); pc++){
                D3DVsInstruction* pI = &m_ucode->ucode[pc];
                if(m_sim.IsStall(pI)){
                    // Look thru rest of instruction stream to see if we can
                    // find an instruction to put here.
#ifndef DISABLE_MOVES_TOWARDS_BEGINNING
                    int pc2;
                    if(FindInstruction(pc,&pc2)){
#ifdef DISABLE_MOVES_TOWARDS_BEGINNING_AFTER_MOVE_NUMBER
                        if(gMoveCount <= DISABLE_MOVES_TOWARDS_BEGINNING_AFTER_MOVE_NUMBER){
                            DPF2("move-towards-beginning #%d\n", gMoveCount);
                            hr = MoveInstruction(pc,pc2);
                        }
                        else {
                        DPF2("Skipping disabled move-towards-beginning #%d\n", gMoveCount);
                        }
                        gMoveCount++;
#else
                        hr = MoveInstruction(pc,pc2);
#endif
                    }
#endif // DISABLE_MOVES_TOWARDS_BEGINNING
                }

                // Look to see if this instruction can be paired with another instruction
                if(SUCCEEDED(hr)){
#ifndef DISABLE_MOVE_AND_PAIR
                    int pc3;
                    D3DVsInstruction pair;
                    if(FindPairableInstruction(pc,&pc3, &pair)){
                        if(m_sim.IsStall(&pair)){
                            // Look thru rest of instruction stream to see if we can
                            // find an instruction to put here.
                            int pc2;
                            if(FindInstruction(pc,&pc2)){
#ifdef DISABLE_MOVES_TOWARDS_BEGINNING_AFTER_MOVE_NUMBER
                                if(gMoveCount <= DISABLE_MOVES_TOWARDS_BEGINNING_AFTER_MOVE_NUMBER){
                                    DPF2("move-towards-beginning #%d\n", gMoveCount);
                                    hr = MoveInstruction(pc,pc2);
                                }
                                else {
                                    DPF2("Skipping disabled move-towards-beginning #%d\n", gMoveCount);
                                }
                                gMoveCount++;
#else
                                hr = MoveInstruction(pc,pc2);
#endif
                                tryPairingAgain = true;
                                goto skipPair;
                            }
                        }
#ifdef DISABLE_PAIRS_AFTER_PAIR_NUMBER
                                if(gPairCount <= DISABLE_PAIRS_AFTER_PAIR_NUMBER){
                                    DPF2("pairs #%d\n", gPairCount);
                                    hr = PairInstructions(pc, pc3, &pair);
                                }
                                else {
                                    DPF2("Skipping disabled pair #%d\n", gPairCount);
                                }
                                gPairCount++;
#else
                        hr = PairInstructions(pc, pc3, &pair);
#endif
skipPair:;
                    }
#endif // DISABLE_MOVE_AND_PAIR
                }
                
                if(SUCCEEDED(hr)){
                    float stall; // dummy arg
					StallType reason = eNone;
                    hr = m_sim.Do(pI, stall, reason);
                }
            }
        }

        if(SUCCEEDED(hr) && tryPairingAgain){
            // It's better to be paired than to be stall free, because
            // a pair saves an instruction slot. Go back through the
            // code and see if there is anything left to pair
            hr = m_sim.Initialize(shaderType, m_ucode->length);
            if(SUCCEEDED(hr)){
                for(int pc = 0; pc < m_ucode->length - 1 && SUCCEEDED(hr); pc++){
#ifndef DISABLE_MOVE_AND_PAIR
                    int pc2;
                    D3DVsInstruction pair;
                    if(FindPairableInstruction(pc,&pc2, &pair)){
#ifdef DISABLE_PAIRS_AFTER_PAIR_NUMBER
                        if(gPairCount <= DISABLE_PAIRS_AFTER_PAIR_NUMBER){
                            DPF2("pairs #%d\n", gPairCount);
                            hr = PairInstructions(pc, pc2, &pair);
                        }
                        else {
                            DPF2("Skipping disabled pair #%d\n", gPairCount);
                        }
                        gPairCount++;
#else
                        hr = PairInstructions(pc, pc2, &pair);
#endif
                    }
#endif // DISABLE_MOVE_AND_PAIR
                }
            }
        }
        
        return hr;
    }
private:

    // Move an instruction frome one location to another

    HRESULT MoveInstruction(int pc, int pc2){
        HRESULT hr = S_OK;
        ASSERT(pc != pc2);
        if(pc2 < pc){
#ifdef DBG_REORDERER
            DPF2("moving %d towards the end, to %d, to avoid stall.\n", pc2, pc);
            for(int ii = pc2; ii <= pc; ii++){
                PrintInstruction(ii, m_ucode);
            }
#endif
            // Bring the candidate towards end
            D3DVsInstruction temp = m_ucode->ucode[pc2];
            for(int i = pc2; i < pc; i++){
                m_ucode->ucode[i] = m_ucode->ucode[i+1];
            }
            m_ucode->ucode[pc] = temp;
        }
        else {
#ifdef DBG_REORDERER
            DPF2("moving %d towards the beginning, to %d, to avoid stall.\n", pc2, pc);
            for(int ii = pc; ii <= pc2; ii++){
                PrintInstruction(ii, m_ucode);
            }
#endif
            // Bring the candidate forward
            D3DVsInstruction temp = m_ucode->ucode[pc2];
            for(int i = pc2; i > pc; i--){
                m_ucode->ucode[i] = m_ucode->ucode[i-1];
            }
            m_ucode->ucode[pc] = temp;
        }
        if(SUCCEEDED(hr)){
#ifndef DISABLE_VERIFIER
            hr = VerifyStep(pPreOptimizedTable, m_ucode, "Reorderer0");
#endif
        }
        return hr;
    }

    HRESULT PairInstructions(int pc, int pc3, const D3DVsInstruction* pPair){
        HRESULT hr = S_OK;
#ifdef DBG_REORDERER
        DPF2("moving %d to pair with %d. Now there are %d instructions\n", pc3, pc, m_ucode->length-1);
        int pcLow = pc3 < pc ? pc3 : pc;
        int pcHigh = pc3 < pc ? pc : pc3;
        for(int ii = pcLow; ii <= pcHigh; ii++){
            PrintInstruction(ii, m_ucode);
        }
        PrintInstruction(pc, pPair);
#endif
        m_ucode->ucode[pc] = *pPair;
        // remove paired instruction
        int i;
        for(i = pc3 + 1; i < m_ucode->length; i++){
            m_ucode->ucode[i-1] = m_ucode->ucode[i];
        }
        m_ucode->length--;
        if(SUCCEEDED(hr)){
#ifndef DISABLE_VERIFIER
            hr = VerifyStep(pPreOptimizedTable, m_ucode, "Reorderer1");
#endif
        }
        return hr;
    }

    // Find an instruction that can be moved forward into a stall slot.
    // In order to be moved, an instruction has to:
    // (a) Not stall
    // (b) Not read any output computed in the region between pc and pc2
    // (c) Not write to a register that's read or written between pc and pc2

    bool FindInstruction(int pc, int* p_pc2){
        RegSet r;
        r.Clear();
        r.DirtyOut(&m_ucode->ucode[pc]);
        for(int pc2 = pc+1;
            pc2 < m_ucode->length;
            pc2++){
            if( !r.IsReadDirty(&m_ucode->ucode[pc2]) // Condition (b)
                && !m_sim.IsStall(&m_ucode->ucode[pc2])
                && OKToMoveConditionC(&r, pc, pc2) ){ // Condition (a)
                *p_pc2 = pc2;
                return true;
            }
            r.DirtyOut(&m_ucode->ucode[pc2]);
        }
        return false;
    }

    bool OKToMoveConditionC(const RegSet* r, int pc, int pc2) const{
        // Now Check condition (c) - pc2 doesn't write to a register that's used
        // between pc and pc2
        RegSet r2;
        r2.Clear();
        r2.DirtyOut(&m_ucode->ucode[pc2]);
        if(r->DirtyConflict(&r2)){ // pc2-write-everything-else-write conflict
            return false;
        }
        for(int pc3 = pc; pc3 < pc2; pc3++){
            if(r2.IsReadDirty(&m_ucode->ucode[pc3])){ // pc2-Write-pc3-read conflict
                return false;
            }
        }
        return true;
    }

    bool FindPairableInstruction(int pc, int* p_pc2, D3DVsInstruction* pPair){
        RegSet r;
        r.Clear();
        r.DirtyOut(&m_ucode->ucode[pc]);
        for(int pc2 = pc+1;
            pc2 < m_ucode->length;
            pc2++){
            if( !r.IsReadDirty(&m_ucode->ucode[pc2])
                && Pairable(pPair, &m_ucode->ucode[pc], &m_ucode->ucode[pc2])
                && OKToMoveConditionC(&r,pc,pc2) )
            {
                *p_pc2 = pc2;
                return true;
            }
            r.DirtyOut(&m_ucode->ucode[pc2]);
        }
        return false;
    }

    D3DVertexShaderProgram* m_ucode;
    TLEngineSim m_sim;
};

//----------- Microcode disassembler utility -----------

class InstructionDisassembler {
public:
    InstructionDisassembler(){
    }
    ~InstructionDisassembler(){
    }

    HRESULT Disassemble(const D3DVsInstruction* pI, char* outBuf, DWORD outLength){
        HRESULT hr = S_OK;
        Buffer buf;
        hr = buf.Initialize(100);
        if(SUCCEEDED(hr)){
            hr = Disassemble(pI, buf);
        }
        if(SUCCEEDED(hr)){
            DWORD size = min(outLength-1,buf.GetUsed());
            memcpy(outBuf, buf.GetText(), size);
            outBuf[size] = '\0';
        }
        return hr;
    }
    HRESULT Disassemble(const D3DVsInstruction* pI, Buffer& out){
        m_pOut = &out;
        HRESULT hr = S_OK;
        // Each microcode instruction disassembles into up to three
        // normal instructions, depending upon how many outputs it generates
        bool bIsFirstInstruction = true;
        static const char* kIndent = "\r\n                 +   ";

        // nop

        if(SUCCEEDED(hr) && !pI->mac && !pI->ilu){
            hr = Disassemble(pI, false, false);
            bIsFirstInstruction = false;
        }

        // mac register instruction (or ARL instruction.)

        if(SUCCEEDED(hr) && (pI->mac && (pI->rwm || pI->mac == MAC_ARL))){
            hr = Disassemble(pI, false, false);
            bIsFirstInstruction = false;
        }

        // mac owm instruction

        if(SUCCEEDED(hr) && (pI->mac && pI->owm && pI->om == OM_MAC)){
            if(!bIsFirstInstruction){
                out.Append(kIndent);
            }
            hr = Disassemble(pI, false, true);
            bIsFirstInstruction = false;
        }
            
        // ilu register instruction

        if(SUCCEEDED(hr) && (pI->ilu && pI->swm)){
            if(!bIsFirstInstruction){
                out.Append(kIndent);
            }
            hr = Disassemble(pI, true, false);
            bIsFirstInstruction = false;
        }

        // ilu owm instruction

        if(SUCCEEDED(hr) && (pI->ilu && pI->owm && pI->om == OM_ILU)){
            if(!bIsFirstInstruction){
                out.Append(kIndent);
            }
            hr = Disassemble(pI, true, true);
            bIsFirstInstruction = false;
        }

        if(SUCCEEDED(hr)){
            if(pI->eos){
                hr = m_pOut->Printf("%s// end", kIndent); //todo: backspace a few times?
            }
        }
        return hr;
    }

private:

    HRESULT Disassemble(const D3DVsInstruction* pI, bool bDoILU, bool bDoOWM){
        HRESULT hr = S_OK;

        if(SUCCEEDED(hr)){
            static const char* iluOps[] = { //      inversion unit operation                    
                "nop",  //  0x0         
                "mov",  //  0x1                 
                "rcp",  //  0x2                 
                "rcc",  //  0x3                 
                "rsq",  //  0x4                 
                "expp", //  0x5                 
                "logp", //  0x6                 
                "lit",  //  0x7
            };
                            
            static const char* macOps[] = { //      multiply / add operation                    
                "nop",  //      0x0                 
                "mov",  //      0x1                 
                "mul",  //      0x2                 
                "add",  //      0x3                 
                "mad",  //      0x4                 
                "dp3",  //      0x5                 
                "dph",  //      0x6                 
                "dp4",  //      0x7                 
                "dst",  //      0x8                 
                "min",  //      0x9                 
                "max",  //      0xA                 
                "slt",  //      0xB                 
                "sge",  //      0xC                 
                "mov",  //      0xD
                "??e",
                "??f",
            };

            hr = m_pOut->Printf("%s ",
                bDoILU ? iluOps[pI->ilu] : macOps[pI->mac]);

        }
        if(SUCCEEDED(hr)){
            hr = ParseOut(pI, bDoILU, bDoOWM);       
        }
        static const UCHAR iluArgMask[] = {
            0x0, // nop
            0x4, // mov
            0x4, // rcp
            0x4, // rcc
            0x4, // rsq
            0x4, // exp
            0x4, // log
            0x4, // lit
        };

        static const UCHAR macArgMask[] = {
            0x0, // nop
            0x1, // mov
            0x3, // mul
            0x5, // add
            0x7, // mad
            0x3, // dp3
            0x3, // dph
            0x3, // dp4
            0x3, // dst
            0x3, // min
            0x3, // max
            0x3, // slt
            0x3, // sge
            0x1, // arl
            0x0, // ??e
            0x0, // ??f
        };

        UCHAR argMask = bDoILU ? iluArgMask[pI->ilu] : macArgMask[pI->mac];

        static const bool kExpandXChannel[] = {
            false, // nop
            false, // mov
            true, // rcp
            true, // rcc
            true, // rsq
            true, // exp
            true, // log
            false, // lit
        };
        bool bExpandXChannel = bDoILU && kExpandXChannel[pI->ilu];

        if(SUCCEEDED(hr)){
            if(argMask & 1) {
                hr = ParseMux('a', 
                    pI->amx,        /* 1:26 a mux (NA,r0,v,c) */
                    pI->arr,        /* 1:28 a register read */
                    pI->aws,        /* 2:00 a w swizzle */
                    pI->azs,        /* 2:02 a z swizzle */
                    pI->ays,        /* 2:04 a y swizzle */
                    pI->axs,        /* 2:06 a x swizzle */
                    pI->ane,        /* 2:08 a negate */
                    pI, false);
            }
        }
        if(SUCCEEDED(hr)){
            if(argMask & 2) {
                hr = ParseMux('b', 
                    pI->bmx,        /* 1:11 b mux (NA,r1,v,c) */
                    pI->brr,        /* 1:13 b register read */
                    pI->bws,        /* 1:17 b w swizzle */
                    pI->bzs,        /* 1:19 b z swizzle */
                    pI->bys,        /* 1:21 b y swizzle */
                    pI->bxs,        /* 1:23 b x swizzle */
                    pI->bne,        /* 1:25 b negate */
                    pI, false);
            }
        }
        if(SUCCEEDED(hr)){
            if(argMask & 4) {
                hr = ParseMux('c', 
                    pI->cmx,        /* 0:28 c mux (NA,r1,v,c) */
                    pI->crr,        /* 0:30 c register read */
                    pI->cws,        /* 1:02 c w swizzle */
                    pI->czs,        /* 1:04 c z swizzle */
                    pI->cys,        /* 1:06 c y swizzle */
                    pI->cxs,        /* 1:08 c x swizzle */
                    pI->cne,        /* 1:10 c negate */
                    pI, bExpandXChannel);
            }
        }
        return hr;
    }

    static const char* RegisterWriteMask(DWORD m){
        const char* masks[] = {
            ".null",
            ".w",
            ".z",
            ".zw",
            ".y",
            ".yw",
            ".yz",
            ".yzw",
            ".x",
            ".xw",
            ".xz",
            ".xzw",
            ".xy",
            ".xyw",
            ".xyz",
            "", // all
            "error"
        };
        if(m>15){
            m=16;
        }
        return masks[m];
    }

    HRESULT ParseOut(const D3DVsInstruction* pI, bool bDoILU, bool bDoOWM)
    {
        HRESULT hr = S_OK;
        // Do register write
        if(! bDoILU && ! bDoOWM && pI->rwm){
            hr = m_pOut->Printf("r%d%s", pI->rw, RegisterWriteMask(pI->rwm));
        }
        if(SUCCEEDED(hr) && ! bDoILU && pI->mac == MAC_ARL){
            hr = m_pOut->Printf("a0.x");
        }
        if(SUCCEEDED(hr) && bDoILU && ! bDoOWM && pI->swm){
            // When this is a double opcode, and the ilu is writing to
            // a register, then the register has to be 1.
            DWORD ilu_rw = (pI->mac && pI->ilu) ? 1 : pI->rw;
            hr = m_pOut->Printf("r%d%s", ilu_rw, RegisterWriteMask(pI->swm));
        }
        if(SUCCEEDED(hr) && bDoOWM && pI->owm && ((pI->om == OM_ILU) == bDoILU)){
            bool oc_output = (pI->oc & 0x0100) != 0;
            DWORD oc_index = pI->oc & 0xff;
            if(oc_output){
                if(oc_index > 12){
                    oc_index = 13;
                }
                hr = m_pOut->Printf("%s%s", kOutNames[oc_index], RegisterWriteMask(pI->owm));
            }
            else {
                hr = m_pOut->Printf("c%d%s", oc_index-96, RegisterWriteMask(pI->owm));
            }
        }
        return hr;
    }

    HRESULT ParseMux(char /* mux */, int mx, int rr, int ws, int zs, int ys, int xs, int ne,
        const D3DVsInstruction* pI, bool bExpandXChannel){
        static const char s[] = "xyzw"; // Swizzle
        static const char m[] = "?rvc";
        HRESULT hr = m_pOut->Append(", ");
        if(SUCCEEDED(hr)){
            if(ne){
                hr = m_pOut->Append('-');
            }
            if(mx == 1){
                hr = m_pOut->Printf("r");
            }
            else {
                hr = m_pOut->Printf("%c", m[mx]);
            }
        }
        if(SUCCEEDED(hr)){
            switch(mx){
            default:
            case 0:
                hr = m_pOut->Printf("error");
                break;
            case 1:
                hr = m_pOut->Printf("%d", rr);
                break;
            case 2:
                hr = m_pOut->Printf("%d", pI->va);
                break;
            case 3:
                {
                    int userReg = pI->ca-96;
                    if(pI->cin){
                        hr = m_pOut->Printf("[a0.x");
                        if(SUCCEEDED(hr)){
                            if(userReg < 0){
                                hr = m_pOut->Printf("%d", userReg);
                            }
                            else if(userReg > 0){
                                hr = m_pOut->Printf("+%d", userReg);
                            }
                        }
                        if(SUCCEEDED(hr)){
                            hr = m_pOut->Printf("]");
                        }
                    }
                    else {
                        hr = m_pOut->Printf("%d", userReg);
                    }
                }
                break;
            }
        }
        if(SUCCEEDED(hr)){
            if(bExpandXChannel){ // To convert microcode-level rules back into assembly-language-level rules
                ys = xs;
                zs = xs;
                ws = xs;
            }
            if(xs == 0 && ys == 1 && zs == 2 && ws == 3){
                // Do nothing
            }
            else if(xs == ys && ys == zs  && zs == ws){
                hr = m_pOut->Printf(".%c", s[xs]);
            }
            else if(ys == zs && zs == ws){
                hr = m_pOut->Printf(".%c%c", s[xs], s[ys]);
            }
            else if(zs == ws){
                hr = m_pOut->Printf(".%c%c%c", s[xs], s[ys], s[zs]);
            }
            else {
                hr = m_pOut->Printf(".%c%c%c%c", s[xs], s[ys], s[zs], s[ws]);
            }
        }
        return hr;
    }

    Buffer* m_pOut;
};

extern "C" 
HRESULT WINAPI DisassembleInstruction(const D3DVsInstruction* pI, char* outBuf, DWORD outLength){
    InstructionDisassembler d;
    return d.Disassemble(pI, outBuf, outLength);
}

HRESULT DisassembleInstruction(const D3DVsInstruction* pI, Buffer& buffer){
    InstructionDisassembler d;
    return d.Disassemble(pI, buffer);
}

#ifdef DBG
void PrintInstruction(int address, const D3DVsInstruction* pI){
    Buffer outBuf;
    outBuf.Initialize(200);
    InstructionDisassembler d;
    d.Disassemble(pI, outBuf);
    DPF2("%d: %s\n", address, outBuf.GetText());
}

void PrintInstruction(int address, const D3DVertexShaderProgram* pUcode){
    PrintInstruction(address, &pUcode->ucode[address]);
}

#endif

//---------- Renamer ------------------

// Tries to free up R1 for ILU operations
//
// Theory of Operation:
//
// Go through the code, treating each write of a temporary register as a unique "value".
// Because of masked writes, at any one time a temp register can contain data from up to four
// values, one value in each component.
//
// Then, go through the code again, looking at how the instructions read data from temporary
// registers. Assign values to "VRegisters", based upon whether or not the code
// reads data from multiple "values" at once.
//
// Re-assign the mapping from VRegisters to temporary registers so that R1 is used as
// often as possible for ILU operations.Depending upon which ILU instructions are being used,
// up to four VRegisters can be assigned to R1 at once.
//
// Emit the new code, using the new temporary registers.

// Swizzle renaming is buggy - disable until we have a better verifier.
// (See bug 3038 for a test case.)

#define DISABLE_SWIZZLE_RENAMING

class Renamer {
    // A Value is a single computed temporary register component.
    // The first value computed
    // by a program is value 1, the next is value 2, and so on.
    // 0 is the NULL value

    typedef WORD Value;
    typedef WORD VReg;

    // Annotations to the microcode instructions. There is one of these
    // records allocated for each microcode instruction.
    struct PRegSet {
        Value in[3][4];   // [abc = 012] [wzyx = 0123]
        Value rw;         // What value the mlu writes, if any
        Value sw;         // What value the ilu writes, if any
    };

    struct ValueInfo {
        WORD first; // First instruction that this value is used (where it's created)
        WORD last;  // last instruction that register is used (last time it's read, or when created if never read)
        UCHAR reg;  // Which register this was originally
        UCHAR mask; // which compontents of this register were written by this value
        VReg owner;
        Value next; // Next value in this virtual register. 0 at end of chain
    };

    struct VRegInfo {
        WORD first;         // First instruction where this virtual register is used.
        WORD last;          // Last instruction where this virtual register is used.
        Value headValue;    // Head Value for this virtual register. (A linked list)
        UCHAR mask;         // Which components of a register are use by this value;
        UCHAR reg;          // Which register this was originally
        bool prefersR1;     // Prefers R1 because of an unpaired ilu swm instruction.
        bool requiresR1;    // Requires R1, because already has a paired ilu swm instruction in it.
        bool cantBeR1;      // Can't be R1 because is used in a paired mac instruction.
        bool fixedComponents; // Component are fixed, can't be swizzled.
        UCHAR newReg;       // Post-register-assignment register
        UCHAR sw[4];        // sw[wzyx = 0123] is the mapping for component. Uses CSW_X..CSW_W codes
                             
    };

    PRegSet* m_pRegSet;

    ValueInfo* m_pValueInfo;
    Value m_valueCount;

    VRegInfo* m_pVregInfo;
    VReg m_vregCount;

    UCHAR m_renameRegRotor; // Where to start searching from

    D3DVertexShaderProgram* m_pUcode;

public:
    Renamer(){
    }

    HRESULT Run(DWORD shaderType, D3DVertexShaderProgram* ucode){
        HRESULT hr = S_OK;
        // First, is it worth renaming
        bool somethingToDo;
        hr = EligableInstructions(ucode, &somethingToDo);
        if(SUCCEEDED(hr) ){
            if(somethingToDo){
                hr = Rename(ucode);
            }
            else {
#ifdef DBG_RENAMER
                DPF2("Renamer thinks there's nothing to do.\n");
#endif
            }
        }
        return hr;
    }

private:

    HRESULT EligableInstructions(const D3DVertexShaderProgram* ucode, bool* pSomethingToDo){
        bool somethingToDo = false;
        for(int i = 0; i < ucode->length; i++){
            const D3DVsInstruction* pI = ucode->ucode + i;
            if(!pI->mac && pI->ilu && pI->swm && pI->rw != 1){
                somethingToDo = true;
                break;
            }
			//make renamer work if an alu instruction writes to r1. This will allow movs to be paired more easily in some cases.
			if(pI->mac && !pI->ilu && pI->rwm && pI->rw == 1){
				somethingToDo = true;
				break;
			}
        }
        *pSomethingToDo = somethingToDo;
        return S_OK;
    }

    HRESULT Rename(D3DVertexShaderProgram* ucode){
        HRESULT hr = S_OK;
        m_pUcode = ucode;
        D3DVertexShaderProgram* p2 = 0;
        m_pRegSet = 0;
        m_pValueInfo = 0;
        m_valueCount = 0;
        m_pVregInfo = 0;
        m_vregCount = 0;
        m_renameRegRotor = 0;

        if(SUCCEEDED(hr)){
            p2 = new D3DVertexShaderProgram;
            if(!p2){
                SETERROR(hr,E_OUTOFMEMORY);
            }
        }
        if(SUCCEEDED(hr)){
            m_pRegSet = new PRegSet[ucode->length];
            if(!m_pRegSet){
                SETERROR(hr,E_FAIL);
            }
            for(int i = 0; i < ucode->length; i++){
                memset(&m_pRegSet[i], 0, sizeof(PRegSet));
            }
        }
        if(SUCCEEDED(hr)){
            // Can't write more than two values per instruction, and Value #0 is reserved
            int valueTotalCount = 2*ucode->length + 1;
            m_pValueInfo = new ValueInfo[valueTotalCount];
            if(!m_pValueInfo){
                SETERROR(hr,E_FAIL);
            }
            for(int i = 0; i < valueTotalCount; i++){
                memset(&m_pValueInfo[i], 0, sizeof(ValueInfo));
            }
        }
        if(SUCCEEDED(hr)){
            // No more than two vregisters per instruction, and vregister #0 is reserved
            int vregTotalCount = 2*ucode->length + 1;
            m_pVregInfo = new VRegInfo[vregTotalCount];
            if(!m_pVregInfo){
                SETERROR(hr,E_FAIL);
            }
            for(int i = 0; i < vregTotalCount; i++){
                memset(&m_pVregInfo[i], 0, sizeof(VRegInfo));
            }
        }
        if(SUCCEEDED(hr)){
            hr = MapRegisterUse();
        }
        // Now that we know the lifetime of each register,
        // remap the registers to maximize potential parallelism
        if(SUCCEEDED(hr)){
            HRESULT hr2 = RemapVRegs();
#ifdef DBG_RENAMER
            DumpRegisterUse();
#endif
            // If we fail to remap, then don't report an error, just don't modify the code
            if(SUCCEEDED(hr2)){
                hr = RemapCode();
#ifdef DBG_RENAMER
                DumpNewCode();
#endif
            }
        }
        delete [] m_pRegSet;
        m_pRegSet = 0;
        delete [] m_pValueInfo;
        m_pValueInfo = 0;
        delete [] m_pVregInfo;
        m_pVregInfo = 0;
        delete p2;
        return hr;
    }

#ifdef DBG_RENAMER

    void DumpRegisterUse(){
        InstructionDisassembler d;
        Buffer b;
        b.Initialize(1024);
        {
            for(int i = 0; i < m_pUcode->length; i++){
                b.Printf("%3d: ", i);
                d.Disassemble(&m_pUcode->ucode[i], b);
                DPF2("%s\n", b.GetText());
                b.Clear();
                for(int inr = 0; inr < 3; inr++){
                    Value* v = m_pRegSet[i].in[inr];
                    VReg vr = 0;
                    for(int iv = 0; iv < 4; iv++){
                        if(v[iv]){
                            vr = m_pValueInfo[v[iv]].owner;
                            break;
                        }
                    }
                    if(vr){
                        b.Printf("       %c: %3d.x %3d.y %3d.z %3d.w [%d]", 'a'+inr, v[3], v[2], v[1], v[0], vr);
                        DPF2("%s\n", b.GetText());
                        b.Clear();
                    }
                }
                if(m_pRegSet[i].rw || m_pRegSet[i].sw){
                    b.Printf("      rw: %3d sw: %3d", m_pRegSet[i].rw,  m_pRegSet[i].sw);
                    DPF2("%s\n", b.GetText());
                    b.Clear();
                }
            }
        }
        {
            DPF2("---- Values ---\n");
            DPF2(" id   vreg fir-las nex reg[comp]\n");
            // Start at 1 because that's the first Value
            for(int i = 1; i < m_valueCount; i++){
                ValueInfo* pV = &m_pValueInfo[i];
                DPF2("%3d: [%3d] %3d-%3d %3d %sr%d[%c%c%c%c]\n",
                    i,
                    pV->owner,
                    pV->first, pV->last,
                    pV->next,
                    pV->reg >= 10 ? "" : " ",
                    pV->reg,
                    pV->mask & 8 ? 'x' : ' ',
                    pV->mask & 4 ? 'y' : ' ',
                    pV->mask & 2 ? 'z' : ' ',
                    pV->mask & 1 ? 'w' : ' '
                    );
            }
        }
        {
            DPF2("---- VRegisters ---\n");
            // Start at 1 because that's the first VReg
            DPF2(" id  fir-las hea reg[comp] new[swiz] (attribs)\n"); 

            for(int i = 1; i < m_vregCount; i++){
                VRegInfo* pV = &m_pVregInfo[i];
                if(pV->headValue) {
                    static const char kSwiz[4] = {'x','y','z','w'};
                    DPF2("%3d: %3d-%3d %3d %sr%d[%c%c%c%c] -> %sr%d[%c%c%c%c] %s %s %s %s\n",
                        i,
                        pV->first, pV->last,
                        pV->headValue,
                        pV->reg >= 10 ? "" : " ",
                        pV->reg,
                        pV->mask & 8 ? 'x' : ' ',
                        pV->mask & 4 ? 'y' : ' ',
                        pV->mask & 2 ? 'z' : ' ',
                        pV->mask & 1 ? 'w' : ' ',
                        pV->newReg >= 10 ? "" : " ",
                        pV->newReg,
                        pV->mask & 8 ? kSwiz[pV->sw[3]] : ' ',
                        pV->mask & 4 ? kSwiz[pV->sw[2]] : ' ',
                        pV->mask & 2 ? kSwiz[pV->sw[1]] : ' ',
                        pV->mask & 1 ? kSwiz[pV->sw[0]] : ' ',
                        pV->prefersR1 ? "prefers r1" : "",
                        pV->requiresR1 ? "requires r1" : "",
                        pV->cantBeR1 ? "can't be r1" : "",
                        pV->fixedComponents ? "fixed" : ""
                        );
                }
            }
        }
    }

    void DumpNewCode(){
        DPF2("--- New Code ---\n");
        InstructionDisassembler d;
        Buffer b;
        b.Initialize(1024);
        {
            for(int i = 0; i < m_pUcode->length; i++){
                b.Printf("%3d: ", i);
                d.Disassemble(&m_pUcode->ucode[i], b);
                DPF2("%s\n", b.GetText());
                b.Clear();
            }
        }
    }

#endif

    HRESULT MapRegisterUse(){
        HRESULT hr = true;
        Value currentReg[16*4]; // [reg][0..3 == wzyx]
        m_valueCount = 1; // One-based
        m_vregCount = 1; // One-based

        // Clear current register set
        memset(currentReg,0,sizeof(currentReg));
        // Simulate
        WORD length = (WORD) m_pUcode->length;
        for(WORD i = 0; i < length; i++){
            const D3DVsInstruction* pI = m_pUcode->ucode + i;
            
            // Update input
            UCHAR inMasks[3];
            ComputePostSwizzleUseMasks(pI, inMasks);
            
            UpdateInput(inMasks[0], pI->amx, pI->arr, pI->axs, pI->ays, pI->azs, pI->aws, m_pRegSet[i].in[0], currentReg, i);
            UpdateInput(inMasks[1], pI->bmx, pI->brr, pI->bxs, pI->bys, pI->bzs, pI->bws, m_pRegSet[i].in[1], currentReg, i);
            UpdateInput(inMasks[2], pI->cmx, pI->crr, pI->cxs, pI->cys, pI->czs, pI->cws, m_pRegSet[i].in[2], currentReg, i);

            // Update output

            if(pI->rwm){
                UpdateOutput(pI->rwm, pI->rw, & m_pRegSet[i].rw, currentReg, i, true);
            }
            if(pI->swm){
                UCHAR reg = pI->mac ? 1 : pI->rw; // Any MAC instruction at all forces swm to write to r1
                UpdateOutput(pI->swm, reg, & m_pRegSet[i].sw, currentReg, i, false);
            }            
        }
        return hr;
    }

    void UpdateInput(UCHAR inMask, UCHAR mx, UCHAR rr, UCHAR xs, UCHAR ys, UCHAR zs, UCHAR ws, Value* prr,
        const Value* currentReg, WORD pc){
        if(inMask && mx == MX_R){ // Reading from a register
            {
                const Value* v = currentReg + rr * 4;
                for(int j = 0; j < 4; j++){
                    if(inMask & (1 << j)){
                        // We use the value in the ith component, w = 0. Where did that value come from?
                        int source; // Swizzle mask value: 0 = X .. 3 = W
                        switch(j){
                        case 0: source = ws; break;
                        case 1: source = zs; break;
                        case 2: source = ys; break;
                        case 3: source = xs; break;
                        }

                        Value v2 = v[3-source];
                        ValueInfo* pV2 = &m_pValueInfo[v2];
                        pV2->last = pc; // This register was used here
                        m_pVregInfo[pV2->owner].last = pc;
                        prr[j] = v2;
                    }
                    else {
                        prr[j] = 0; // Not used in this instruction
                    }
                }
            }
            // Do we need to combine virtual registers together?
            VReg winner = 0;
            int i;
            for(i = 0; i < 4; i++){
                Value v = prr[i];
                if(v) {
                    VReg vreg = m_pValueInfo[v].owner;
                    if(!winner || vreg < winner){
                        winner = vreg;
                    }
                }
            }
            for(i = 0; i < 4; i++){
                Value v = prr[i];
                if(v) {
                    VReg vreg = m_pValueInfo[v].owner;
                    if(winner != vreg){
                        // Move all of the loser's Values over to the winner
                        VRegInfo* pWinner = &m_pVregInfo[winner];
                        VRegInfo* pLoser = &m_pVregInfo[vreg];
                        if(! pLoser->first) {
                            continue; // We've alreadly cleaned out this register.
                        }
#ifdef DBG_RENAMER
                        DPF2("Merging vreg %d into vreg %d at instruction %d\n", vreg, winner, pc);
#endif
                        // Merge the loser's values with the winner's values
                        Value winnerVal = pWinner->headValue;
                        Value loserVal = pLoser->headValue;
                        bool firstTime = true;
                        Value tailVal = 0;
                        // Merge two linked lists, keep sorted
                        // (Also update the headValue of the loser)
                        while(winnerVal || loserVal){
                            // Which value is numericly smaller?
                            if(! winnerVal || (winnerVal && loserVal && loserVal < winnerVal)){
                                // Link the next loserVal into the list
                                if(firstTime){
                                    pWinner->headValue = loserVal;
                                }
                                if(tailVal){
                                    m_pValueInfo[tailVal].next = loserVal;
                                }
                                m_pValueInfo[loserVal].owner = winner;
                                tailVal = loserVal;
                                loserVal = m_pValueInfo[loserVal].next;
                            }
                            else {
                                // Link the next winnerVal ino the list
                                if(tailVal){
                                    m_pValueInfo[tailVal].next = winnerVal;
                                }
                                tailVal = winnerVal;
                                ASSERT(winnerVal);
                                winnerVal = m_pValueInfo[winnerVal].next;
                            }
                            firstTime = false;
                        }
                        if(tailVal){
                            m_pValueInfo[tailVal].next = 0;
                        }

                        // Update winner info
                        pWinner->first = min(pWinner->first, pLoser->first);
                        pWinner->last = max(pWinner->last, pLoser->last);
                        pWinner->mask = pWinner->mask | pLoser->mask;
                        // pWinner->reg is the same as pLoser->reg
                        pWinner->prefersR1 = pWinner->prefersR1 || pLoser->prefersR1;
                        pWinner->requiresR1 = pWinner->requiresR1 || pLoser->requiresR1;
                        pWinner->cantBeR1 = pWinner->cantBeR1 || pLoser->cantBeR1;
                        pWinner->fixedComponents = pWinner->fixedComponents || pLoser->fixedComponents;
                        
                        // Clear out loser's registers
                        memset(pLoser, 0, sizeof(VRegInfo));
                    }
                }
            }
        }
    }

    void UpdateOutput(UCHAR outMask, UCHAR rw, Value* prw,
        Value* currentReg, WORD pc, bool isMac){
        WORD vid = m_valueCount++;
        Value* v = currentReg + rw * 4;
        for(int j = 0; j < 4; j++){
            if(outMask & (1 << j)){
                v[j] = vid;
            }
        }
        VReg vr =  m_vregCount++;
        *prw = vid;
        ValueInfo* pV = &m_pValueInfo[vid];
        pV->first = pc;
        pV->last = pc;
        pV->reg = rw;
        pV->mask = outMask;
        pV->owner = vr;
        // pV->next = 0; // Already zero

        VRegInfo* pVr = &m_pVregInfo[vr];
        pVr->first = pc;
        pVr->last = pc;
        pVr->headValue = vid;
        pVr->mask = outMask;
        pVr->reg = rw;
        // pVr->prefersR1 = 0; // Already zero
        // pVr->requiresR1 = 0; // Already zero
        // pVr->cantBeR1 = 0; // Already zero
        // pVr->fixedComponents = 0; // Already zero

        // Don't set up remapping info here.
        UpdateComponentUse(vr, pc, outMask, isMac);
    }

    void UpdateComponentUse(VReg vreg, WORD pc, UCHAR outMask, bool isMac){
        // Which output components can't be moved to other
        // channels by swizzleing the inputs?
        // w = 1 .. x == 8
        static const UCHAR kFixedILUOutputs[8] = {
            0x0,   // ILU_NOP
            0x0,   // ILU_MOV
            0x0,   // ILU_RCP
            0x0,   // ILU_RCC
            0x0,   // ILU_RSQ
            0xf,   // ILU_EXP
            0xf,   // ILU_LOG
            0x0,   // ILU_LIT
        };
        static const UCHAR kFixedMACOutputs[16] = {
            0x0,   // MAC_NOP
            0x0,   // MAC_MOV
            0x0,   // MAC_MUL
            0x0,   // MAC_ADD
            0x0,   // MAC_MAD
            0x0,   // MAC_DP3
            0x0,   // MAC_DPH
            0x0,   // MAC_DP4
            0xf,   // MAC_DST
            0x0,   // MAC_MIN
            0x0,   // MAC_MAX
            0x0,   // MAC_SLT
            0x0,   // MAC_SGE
            0x0,   // MAC_ARL
            0x0,   // 0xe
            0x0,   // 0xf
        };

        D3DVsInstruction* pI = & m_pUcode->ucode[pc];
        VRegInfo * pVr = &m_pVregInfo[vreg];
        WORD ilu = pI->ilu;
        if(! isMac && ilu && pI->swm){
            pVr->prefersR1 = true;
            if(pI->mac){
                pVr->requiresR1 = true;
            }
        }
        if(isMac && ilu && pI->rwm){
            pVr->cantBeR1 = true;
        }

#ifdef DISABLE_SWIZZLE_RENAMING
        pVr->fixedComponents = true;
#else
        pVr->fixedComponents = 0 != (kFixedILUOutputs[ilu] | kFixedMACOutputs[pI->mac]);
#endif
    }
    
    // The policy for mapping:
    // Go through the instructions, in order.
    // When a new vreg starts, pick a reg for it from the free registers.
    //
    // (2) 
    HRESULT RemapVRegs(){
        HRESULT hr = S_OK;
        VReg regs[64]; // Active Vreg-to-temp-reg assignments
        memset(regs,0,sizeof(regs));
        for(WORD pc = 0; pc < m_pUcode->length && SUCCEEDED(hr); pc++){
            PRegSet *pRegSet = &m_pRegSet[pc];
            hr = RemapVRegs2Start(pRegSet->rw, regs, pc);
            if(SUCCEEDED(hr)){
                hr = RemapVRegs2Start(pRegSet->sw, regs, pc);
            }
            if(SUCCEEDED(hr)){
                for(int op = 0; op < 3 && SUCCEEDED(hr); op++){
                    hr = RemapVRegs2End(pRegSet->in[op], regs, pc);
                }
            }
        }
        return hr;
    }
    
    HRESULT RemapVRegs2Start(Value v, VReg* pRegs, WORD pc){
        if(v){
            VReg vreg = m_pValueInfo[v].owner;
            VRegInfo* pVr = &m_pVregInfo[vreg];
            if(pVr->first == pc){ // First use of this VReg, assign a register
                if(pVr->prefersR1 && ! pVr->cantBeR1){
                    if(IsRegFree(pRegs, 1, vreg)){
                        return AssignReg(pRegs, 1, vreg);
                    }
                    else {
                        if(pVr->requiresR1){
#ifdef DBG_RENAMER
                            DPF2("Instruction at %d requires r1, but can't get it.\n", pc);
#endif
                            return E_FAIL;
                        }
                        return AssignFreeReg(pRegs,vreg, false);
                    }
                }
                else {
                    return AssignFreeReg(pRegs,vreg, pVr->cantBeR1);
                }
            }
        }
        return S_OK;
    }
    
    bool IsRegFree(const VReg* pRegs, UCHAR reg, VReg vreg){
        const VReg* pComponents = pRegs + reg * 4;
        VRegInfo* pVr = &m_pVregInfo[vreg];
        WORD mask = pVr->mask;
        if ( pVr->fixedComponents ){
            // See if the specific components in the mask are free in this register.
            for(int i = 0; i < 4; i++){
                if( (1 << i) & mask ) {
                    if(pComponents[i]){
                        // This component is in use
                        return false;
                    }
                }
            }
            return true;
        }
        else {
            // Count how many components are free, needed
            UCHAR free = 0;
            UCHAR needed = 0;
            for(int i = 0; i < 4; i++){
                if( (1 << i) & mask ) {
                    needed++;
                }
                if( ! pComponents[i]){
                    free++;
                }
            }
            if(free < needed){
                return false;
            }
            return true;
        }
    }
    
    HRESULT AssignReg(VReg* pRegs, UCHAR reg, VReg vreg){
        VReg* pComponents = pRegs + reg * 4;
        VRegInfo* pVr = &m_pVregInfo[vreg];
        WORD mask = pVr->mask;
        {
            // See if the specific components in the mask are free in this register.
            for(int i = 0; i < 4; i++){
                if( (1 << i) & mask ) {
                    if(pComponents[i]){
                        // This component is in use
                        goto trySwizzled;
                    }
                    pComponents[i] = vreg; // Mark this component as being assigned
                    pVr->newReg = reg;
                    pVr->sw[i] = 3-i; // Convert component index to swizzle constant
                }
            }
#ifdef DBG_RENAMER
            PrintRegisterMove(vreg);
#endif
            return S_OK;
        }
trySwizzled: ;
        if ( pVr->fixedComponents ) {
            return E_FAIL;
        }
        else {
            // Count how many components are free, needed
            UCHAR component = 0;
            for(int i = 0; i < 4; i++){
                if( (1 << i) & mask ) {
                    // TODO - we know that (because of EXPP being used for frac)
                    // R1.Y is the most valuable component. So try to assign it last.
                    
                    while(pComponents[component] && component < 4){
                        component++;
                    }
                    if(component >= 4){
                        // No free components
                        return E_FAIL;
                    }
                    pComponents[component] = vreg; // Mark this component as being assigned
                    pVr->newReg = reg;
                    pVr->sw[i] = 3-component; // Convert component index to swizzle constant
                }
            }
#ifdef DBG_RENAMER
            PrintRegisterMove(vreg);
#endif
            return S_OK;
        }
    }

#ifdef DBG_RENAMER
    void PrintRegisterMove(VReg vreg){
        const VRegInfo* pVr = &m_pVregInfo[vreg];
        if(pVr->reg != pVr->newReg){
            DPF2("Moving vreg %d r%d to r%d.\n", vreg, pVr->reg, pVr->newReg);
        }
        if ( pVr->mask & 1 && pVr->sw[0] != CSW_W
           || pVr->mask & 2 && pVr->sw[1] != CSW_Z
           || pVr->mask & 4 && pVr->sw[2] != CSW_Y
           || pVr->mask & 8 && pVr->sw[3] != CSW_X){
            static const char kSwizzle[4] = {'x','y','z','w'};
            DPF2(" swizzleing vreg %d r%d[%c%c%c%c].\n", vreg, pVr->newReg,
                pVr->mask & 1 ? kSwizzle[pVr->sw[3]] : ' ', // component 3 == x
                pVr->mask & 2 ? kSwizzle[pVr->sw[2]] : ' ',
                pVr->mask & 4 ? kSwizzle[pVr->sw[1]] : ' ',
                pVr->mask & 8 ? kSwizzle[pVr->sw[0]] : ' '
                );
        }
    }
#endif

    HRESULT AssignFreeReg(VReg* pRegs, VReg vreg, bool cantBeR1){
        // To increase the chances of being able to move instructions around,
        // we rotate the register we start searching at.
        // (This really scrambles the code!)
        
        VRegInfo* pVr = &m_pVregInfo[vreg];
// #define TRY_TO_KEEP_OLD_ASSIGNMENTS
#define USE_ROTOR

#ifdef TRY_TO_KEEP_OLD_ASSIGNMENTS
        if(pVr->reg != 1 && IsRegFree(pRegs, pVr->reg, vreg)){
            return AssignReg(pRegs, pVr->reg, vreg);
        }
#endif
        // Find first free reg - assign R1 last
        static const UCHAR kRegOrder[] = {0,2,3,4,5,6,7,8,9,10,11};
#ifdef USE_ROTOR
        m_renameRegRotor++;
        if(m_renameRegRotor >= sizeof(kRegOrder)) {
                m_renameRegRotor = m_renameRegRotor - sizeof(kRegOrder);
        }
#endif
        for(int i = 0; i < sizeof(kRegOrder); i++){
            int i2 = m_renameRegRotor + i;
            if(i2 >= sizeof(kRegOrder)) {
                i2 = i2 - sizeof(kRegOrder);
            }
            UCHAR reg = kRegOrder[i2];
            if(IsRegFree(pRegs, reg, vreg)){
                return AssignReg(pRegs, reg, vreg);
            }
        }
        // Finally, try R1
        if(!cantBeR1 && IsRegFree(pRegs, 1, vreg)){
            return AssignReg(pRegs, 1, vreg);
        }
        // Out of ideas.
        return E_FAIL;
    }
    
    HRESULT RemapVRegs2End(Value* pInRegComponents, VReg* pRegs, WORD pc){
        VReg vreg = 0;
        for(int c = 0; c < 4; c++){
            Value v = pInRegComponents[c];
            if(v){
                vreg = m_pValueInfo[v].owner;
            }
        }
        if(vreg){
            VRegInfo* pVr = &m_pVregInfo[vreg];
            if(pVr->last == pc){ // End of use of register, clear out pRegs
                UCHAR mask = pVr->mask;
                VReg* pRegBase = &pRegs[pVr->newReg * 4];
                for(int c = 0; c < 4; c++){
                    if((1 << c) & mask){
                        int newc = 3 - pVr->sw[c];
#ifdef DBG_RENAMER
                        // It can be blank if has already been cleared, but
                        // it better not be assigned to another register!
                        if(pRegBase[newc] && pRegBase[newc] != vreg){
                            DebugBreak();
                        }
#endif
                        pRegBase[newc] = 0;
                    }
                }
            }
        }
        return S_OK;
    }
    
    HRESULT RemapCode(){
        HRESULT hr = S_OK;
        for(int i = 0; i < m_pUcode->length; i++){
            D3DVsInstruction* pI = &m_pUcode->ucode[i];
            PRegSet* pRegSet = &m_pRegSet[i];
            // Remap input registers
            for(int j = 0; j < 3; j++){
                Value v = 0;
                for(int k = 0; k < 4; k++){
                    Value v2 = pRegSet->in[j][k];
                    if(v2){
                        v = v2;
                        break;
                    }
                }

                if(v){
                    VReg vreg = m_pValueInfo[v].owner;
                    ASSERT(vreg);
                    VRegInfo* pVr = &m_pVregInfo[vreg];
                    ASSERT(pVr->first <= i && i <= pVr->last);
                    switch(j){
                    case 0:
                        pI->arr = pVr->newReg;
#ifndef DISABLE_SWIZZLE_RENAMING
                        pI->aws = pVr->sw[3 - pI->aws];
                        pI->azs = pVr->sw[3 - pI->azs];
                        pI->ays = pVr->sw[3 - pI->ays];
                        pI->axs = pVr->sw[3 - pI->axs];
#endif
                        break;
                    case 1:
                        pI->brr = pVr->newReg;
#ifndef DISABLE_SWIZZLE_RENAMING
                        pI->bws = pVr->sw[3 - pI->bws];
                        pI->bzs = pVr->sw[3 - pI->bzs];
                        pI->bys = pVr->sw[3 - pI->bys];
                        pI->bxs = pVr->sw[3 - pI->bxs];
#endif
                        break;
                    case 2:
                        pI->crr = pVr->newReg;
#ifndef DISABLE_SWIZZLE_RENAMING
                        pI->cws = pVr->sw[3 - pI->cws];
                        pI->czs = pVr->sw[3 - pI->czs];
                        pI->cys = pVr->sw[3 - pI->cys];
                        pI->cxs = pVr->sw[3 - pI->cxs];
#endif
                        break;
                    }
                }
            }

            // Remap the output registers
            if(pRegSet->rw){
                VReg vreg = m_pValueInfo[pRegSet->rw].owner;
                ASSERT(vreg);
                VRegInfo* pVr = &m_pVregInfo[vreg];
                ASSERT(pVr->first <= i && i <= pVr->last);
                pI->rw = pVr->newReg;
                pI->rwm = CalcSwizzledWriteMask(pI->rwm, pVr);
            }
            if(pRegSet->sw){
                VReg vreg = m_pValueInfo[pRegSet->sw].owner;
                ASSERT(vreg);
                VRegInfo* pVr = &m_pVregInfo[vreg];
                ASSERT(pVr->first <= i && i <= pVr->last);
                if(!pI->mac){
                    pI->rw = pVr->newReg;
                }
                pI->swm = CalcSwizzledWriteMask(pI->swm, pVr);
            }
        }
        return hr;
    }
    
    UCHAR CalcSwizzledWriteMask(UCHAR mask, const VRegInfo* pVr){
        UCHAR result = 0;
        const UCHAR* pSw = pVr->sw;
        for(int c = 0; c < 4; c++){
            if(mask & (1 << c)){
                result |= 1 << (3 - pSw[c]);
            }
        }
        return result;
    }
};



void ConvertPackedDWordsToUCode(const DWORD* pIn, D3DVsInstruction* pucode){
    memset(pucode,0,sizeof(D3DVsInstruction));
    DWORD x = *pIn++;
    DWORD y = *pIn++;
    DWORD z = *pIn++;
    DWORD w = *pIn++;
    // Word X -- ignore
    // Word Y
	pucode->aws = (y >> 0);
	pucode->azs = (y >> 2);
    pucode->aws = (y >> 0);
    pucode->azs = (y >> 2);
    pucode->ays = (y >> 4);
    pucode->axs = (y >> 6);
    pucode->ane = (y >> 8);
    pucode->va  = (y >> 9);
    pucode->ca  = (y >>13);
    pucode->mac = (y >>21);
    pucode->ilu = (y >>25);
    //Word Z
    pucode->crr = ((0xc & (z << 2)) | ((w >> 30) & 0x3));
    pucode->cws = (z >> 2);
    pucode->czs = (z >> 4);
    pucode->cys = (z >> 6);
    pucode->cxs = (z >> 8);
    pucode->cne = (z >>10);
    pucode->bmx = (z >>11);
    pucode->brr = (z >>13);
    pucode->bws = (z >>17);
    pucode->bzs = (z >>19);
    pucode->bys = (z >>21);
    pucode->bxs = (z >>23);
    pucode->bne = (z >>25);
    pucode->amx = (z >>26);
    pucode->arr = (z >>28);

    //Word W
    pucode->eos = (w >> 0);
    pucode->cin = (w >> 1);
    pucode->om  = (w >> 2);
    pucode->oc  = (w >> 3);
    pucode->owm = (w >>12);
    pucode->swm = (w >>16);
    pucode->rw  = (w >>20);
    pucode->rwm = (w >>24);
    pucode->cmx = (w >>28);
} 
 
// This is exported, but isn't documented. It's exported so the xsdasm program can
// easily disassemble the vertex shader.

extern "C" HRESULT DisassembleVertexShader(LPCVOID pUcode, DWORD length, LPXGBUFFER* pDisassembly);

HRESULT DisassembleVertexShader(LPCVOID pUcode, DWORD length, LPXGBUFFER* pDisassembly){
    HRESULT hr = S_OK;
    // Check header
    if ( length < 4 || ! pUcode) {
        SETERROR(hr, E_FAIL);
    }
    WORD shaderLength = 0;
    DWORD shaderType;
    if(SUCCEEDED(hr)){
        switch(* (WORD*) pUcode){
        case 0x2078:
            shaderType = SASMT_VERTEXSHADER;
            break;
        case 0x7778:
            shaderType = SASMT_READWRITE_VERTEXSHADER;
            break;
        case 0x7378:
            shaderType = SASMT_VERTEXSTATESHADER;
            break;
        default:
            SETERROR(hr, E_FAIL); // Unknown shader type
        }
    }
    if(SUCCEEDED(hr)){
        shaderLength = * (WORD*) (((CHAR*) pUcode) + 2);
        if ( 4 + shaderLength * sizeof(PaddedUCode) != length){
            SETERROR(hr, E_FAIL);
        }
    }
    Buffer buf;
    if(SUCCEEDED(hr)){
        hr = buf.Initialize(100+40*shaderLength);
    }
    TLEngineSim sim;
    if(SUCCEEDED(hr)){
        hr = sim.Initialize(shaderType, shaderLength);
    }
    if(SUCCEEDED(hr)){
		DWORD* pI = (DWORD*) (((CHAR*) pUcode) + 4);
		float stall;
		StallType reason = eNone;
		for(WORD i = 0; SUCCEEDED(hr) && i < shaderLength; i++){
			reason = eNone;
            D3DVsInstruction ucode;
            ConvertPackedDWordsToUCode(pI + i * 4, &ucode);
            sim.Do(&ucode, stall, reason);
			if(SASMT_SHADERTYPE(shaderType) == SASMT_VERTEXSHADER)
				buf.Printf("%d: (%c %.2f) ", i, char(reason), stall + .5);
			else
				buf.Printf("%d: (%d) ", i, (int)(stall + 1.1));
            hr = DisassembleInstruction(&ucode, buf);
            buf.Append("\n");
       }
	   stall = sim.CalculateFinalStall(reason);
	   if(stall) {
		   buf.Printf("Final Stall: %c %.2f \n", char(reason), stall);
	   }
    }

    if(SUCCEEDED(hr) && pDisassembly){
        hr = XGBufferCreateFromBuffer(&buf, pDisassembly);
    }

    return hr;
}

#ifdef DBG
void Print(D3DVsInstruction& instruction){
    char buf[100];
    DisassembleInstruction(&instruction, buf, sizeof(buf));
    DPF2("%s\n", buf);
}

void Print(DWORD shaderType, D3DVertexShaderProgram& program){
    Buffer buf;
    HRESULT hr = buf.Initialize(100);
    DPF2("; Program has %d instructions\n", program.length);
    TLEngineSim sim;
    sim.Initialize(shaderType, program.length);
    float stall;
	StallType reason = eNone;
    for(int i = 0; i < program.length && SUCCEEDED(hr); i++){
        buf.Clear();
        hr = DisassembleInstruction(&program.ucode[i], buf);
        sim.Do(&program.ucode[i], stall, reason);
        DPF2("%3d: (%c %.2f) %s\n", i, stall, char(reason), buf.GetText()); 
    }
	stall = sim.CalculateFinalStall(reason);
	if(stall) {
		DPF2("; Final Stall: %c %.2f\n", char(reason), stall);
	}
    DPF2("; ---------\n");
}

#endif

//----------- end of Microcode disassembler ------------

// We're assured that the first op is a mac and the second is an ilu
bool InputsConflict_MAC_ILU(const D3DVsInstruction* mac, const D3DVsInstruction* ilu){

    bool macUsesA = kMacUsesA[mac->mac];
    bool macUsesB = kMacUsesB[mac->mac];
    bool macUsesC = kMacUsesC[mac->mac];
    if(macUsesC && ilu->ilu){
        if(mac->cmx != ilu->cmx){
            return true;
        }
        switch(ilu->cmx){
        case MX_R:
            if(mac->crr != ilu->crr){
                return true;
            }
            break;
        case MX_V:
            if(mac->va != ilu->va ){
                return true;
            }
            break;
        case MX_C:
            if(mac->ca != ilu->ca) {
                return true;
            }
            break;
        default:
            return true;
        }
        // Same inputs, but the swizzle or negate might be different
        if(mac->cne != ilu->cne){
            return true;
        }
        // Check if the effective swizzle is different
        char macSwizzles[12];
        char iluSwizzles[12];
        ComputeEffectiveSwizzles(mac,macSwizzles);
        ComputeEffectiveSwizzles(ilu,iluSwizzles);
        for(int i = 8; i < 12; i++){ // Just check C register
            char ms = macSwizzles[i];
            char is = iluSwizzles[i];
            if( ms != -1 && is != -1 && ms != is ) {
                return true; // Incompatable
            }
        }
    }
    switch(ilu->cmx){
    case MX_V:
        if((macUsesA && (mac->amx == MX_V))
            || (macUsesB && (mac->bmx == MX_V))){
            if(mac->va != ilu->va){
                return true;
            }
        }
        break;
    case MX_C:
        if((macUsesA && (mac->amx == MX_C))
            || (macUsesB && (mac->bmx == MX_C))){
            if(mac->ca != ilu->ca || mac->cin != ilu->cin){
                return true;
            }
        }

    default:
        break;
    }
    return false;
}

bool OutputsConflict_MAC_ILU(const D3DVsInstruction* mac, const D3DVsInstruction* ilu){

    if(ilu->swm){
       if(ilu->rw != 1){
            return true; // Can't be paired, ilu has to write to r1.
        }
    }

    // See Xbox OS bug 2378.
    // It appears that, when pairing instructions, the mac
    // instruction can't write to r1, even if
    // the ILU instruction is not writing to the r registers.
    // For example, the following instruction pair doesn't seem
    // to work, because r1 doesn't seem to be written.
    // sge r1.x,v0,c0.wyzw : mov o[0],v0

    if(mac->rwm){
        if(mac->rw == 1){
            return true; 
        }
    }
	/* //jgould, commented 12 July 2001. This code is unneeded, since the conditions are a subset of the above
    if(mac->rwm && ilu->swm) {
        if(mac->rw == 1 && (mac->rwm & ilu->swm)){
            return true; // Collision - both writing to same part of r1.
                         // ilu will win, but that may not be what the user intended.
        }
    }
	*/
    if(mac->owm && ilu->owm){
        return true; // Only one can write to output
    }
    return false;
}

// Does b depend upon the outputs of a?
bool InputOutputDependency(const D3DVsInstruction* a, const D3DVsInstruction* b){
    // Which output channels does A use
    OutPair outMasks[2];
    ExpandRegisterOutputMasks(outMasks, a);
    // Which input chanels does b use?
    bool aWritesToConst = (a->owm != 0) && ((a->oc & 0x100) == 0);
    bool aWritesToOut = (a->owm != 0) && ((a->oc & 0x100) != 0);
    bool bUsesA = kMacUsesA[b->mac];
    bool bUsesB = kMacUsesB[b->mac];
    bool bUsesC = b->ilu || kMacUsesC[b->mac];
    DWORD baMask = bUsesA ? (1<<(3-b->axs))|(1<<(3-b->ays))|(1<<(3-b->azs))|(1<<(3-b->aws)) : 0;
    DWORD bbMask = bUsesB ? (1<<(3-b->bxs))|(1<<(3-b->bys))|(1<<(3-b->bzs))|(1<<(3-b->bws)) : 0;
    DWORD bcMask = bUsesC ? (1<<(3-b->cxs))|(1<<(3-b->cys))|(1<<(3-b->czs))|(1<<(3-b->cws)) : 0;
    bool bBUsesConst = (bUsesA && b->amx == MX_C)
        || (bUsesB && b->bmx == MX_C)
        || (bUsesC && b->cmx == MX_C);

    for(int i = 0; i < 2; i++){
        if(outMasks[i].used){
            if(bUsesA && b->amx == MX_R && b->arr == outMasks[i].r && (baMask & outMasks[i].m)){
                return true;
            }
            if(bUsesB && b->bmx == MX_R && b->brr == outMasks[i].r && (bbMask & outMasks[i].m)){
                return true;
            }
            if(bUsesC && b->cmx == MX_R && b->crr == outMasks[i].r && (bcMask & outMasks[i].m)){
                return true;
            }
        }
    }
    if(aWritesToConst && bBUsesConst && ((b->ca == a->oc) || b->cin)) {
        return true;
    }
    if(aWritesToOut){
        // Check for the special case of writing to o[oPos] and reading from R12
        if(a->oc == 0x100){ // o[oPos]
            if(bUsesA && b->amx == MX_R && b->arr == 12 && (baMask & a->owm)){
                return true;
            }
            if(bUsesB && b->bmx == MX_R && b->brr == 12 && (bbMask & a->owm)){
                return true;
            }
            if(bUsesC && b->cmx == MX_R && b->crr == 12 && (bcMask & a->owm)){
                return true;
            }
        }
    }
    if(a->mac == MAC_ARL && bBUsesConst && b->cin){
        return true;
    }
    return false;
}

bool ConvertToImv(D3DVsInstruction* ucode, const D3DVsInstruction* mov){
    if(mov->mac != MAC_MOV){
        return false;
    }
    if(mov->ilu){
        return false;
    }
    ucode->mac = MAC_NOP;
    ucode->ilu = ILU_MOV; // A move
    ucode->ca  = mov->ca;
    ucode->va  = mov->va;
    ucode->ane = 0;
    ucode->axs = CSW_X;
    ucode->ays = CSW_Y;
    ucode->azs = CSW_Z;
    ucode->aws = CSW_W;
    ucode->amx = MX_R;
    ucode->arr = 0;
    ucode->bne = 0;
    ucode->bxs = CSW_X;
    ucode->bys = CSW_Y;
    ucode->bzs = CSW_Z;
    ucode->bws = CSW_W;
    ucode->bmx = MX_R;
    ucode->brr = 0;
    ucode->cne = mov->ane;
    ucode->cxs = mov->axs;
    ucode->cys = mov->ays;
    ucode->czs = mov->azs;
    ucode->cws = mov->aws;
    ucode->cmx = mov->amx;
    ucode->crr = mov->arr;
    ucode->rw  = mov->rw;
    ucode->rwm = 0;
    ucode->oc  = mov->oc;
    ucode->om  = mov->owm ? OM_ILU : OM_MAC;
    ucode->eos = mov->eos;
    ucode->cin = mov->cin;
    ucode->swm = mov->rwm;
    ucode->owm = mov->owm;
    return true;
}

bool SwapAC(D3DVsInstruction* pOut, const D3DVsInstruction* pIn){
    bool swapable = pIn->mac == MAC_ADD && ! pIn->ilu;
    if(swapable){
        *pOut = *pIn;
        pOut->amx = pIn->cmx;
        pOut->ane = pIn->cne;
        pOut->arr = pIn->crr;
        pOut->axs = pIn->cxs;
        pOut->ays = pIn->cys;
        pOut->azs = pIn->czs;
        pOut->aws = pIn->cws;

        pOut->cmx = pIn->amx;
        pOut->cne = pIn->ane;
        pOut->crr = pIn->arr;
        pOut->cxs = pIn->axs;
        pOut->cys = pIn->ays;
        pOut->czs = pIn->azs;
        pOut->cws = pIn->aws;
    }
    return swapable;
}

void StripMacInstruction(D3DVsInstruction* pI){
    if(pI->mac){
        if(pI->swm){
            pI->rw = 1;
            pI->rwm = pI->swm;
        }
        else {
            pI->rw = 0;
            pI->rwm = 0;
        }
        pI->mac = 0;
        pI->amx = MX_V;
        pI->arr = 0;
        pI->ane = 0;
        pI->axs = 0;
        pI->ays = 0;
        pI->azs = 0;
        pI->aws = 0;
        pI->bmx = MX_V;
        pI->brr = 0;
        pI->bne = 0;
        pI->bxs = 0;
        pI->bys = 0;
        pI->bzs = 0;
        pI->bws = 0;
    }
}

// pair is guaranteed to not be equal a or b.

bool Pairable(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b){
    // If there is a dependency between the output of a and
    // the input of b, then the instructions can't be paired
    if(InputOutputDependency(a,b)){
        return false;
    }

    DWORD dummyReason;

    if(ForcedPair(pair,a,b, &dummyReason)){
        return true;
    }
    // Special case ADD instructions - see if they're pairable with their arguments reversed
    D3DVsInstruction temp;
    if(SwapAC(&temp,a)){
        if(ForcedPair(pair,&temp,b, &dummyReason)){
            return true;
        }
    }
    else if(SwapAC(&temp,b)){
        if(ForcedPair(pair,a,&temp, &dummyReason)){
            return true;
        }
    }
    return false;
}

HRESULT PeepholeOptimize(DWORD shaderType, D3DVertexShaderProgram* program){
    HRESULT hr = S_OK;

    // in-place optimizations
    {
        TLEngineSim sim;
        hr = sim.Initialize(shaderType, program->length);
        if(SUCCEEDED(hr)){
            for(int pc = 0; pc < program->length && SUCCEEDED(hr); pc++){
                D3DVsInstruction* pI = &program->ucode[pc];
                // The second argument of an ADD instruction doesn't stall,
                // so sometimes swapping the two arguments is faster
                D3DVsInstruction temp;
                if(SwapAC(&temp, pI)){
					StallType dummysr = eNone;
                    if(sim.CalculateStall(pI, dummysr) > sim.CalculateStall(&temp, dummysr)){
                        *pI = temp;
                    }
                }
                float stall; // dummy arg
				StallType reason = eNone;
                hr = sim.Do(pI, stall, reason);
            }
        }
    }
    return hr;
}

HRESULT EstimateCycles(DWORD shaderType, D3DVertexShaderProgram* ucode, float* pCycles){
    HRESULT hr = S_OK;
    TLEngineSim sim;
    float cycles = 0;
    float stall;
    hr = sim.Initialize(shaderType, ucode->length);
    if(SUCCEEDED(hr)){
        stall = 0;
		StallType reason = eNone;
        for(int ip = 0; ip < ucode->length && SUCCEEDED(hr); ip++){
            hr = sim.Do(&ucode->ucode[ip], stall, reason);
            
			if(SASMT_SHADERTYPE(shaderType)==SASMT_VERTEXSHADER) {
				cycles += stall + 0.5;
			} else {
				cycles += stall + 1;
			}
        }

		cycles += sim.CalculateFinalStall(reason);
    }
    if(SUCCEEDED(hr)){
        *pCycles = cycles;
    }

    return hr;
}

/* Super-obscure feature.
 *
 * If we have two instructions in a row that
 * compute the same result, but one instruction
 * writes to an output register, and the
 * other instruction writes to a temporary register,
 * then we can combine those two instructions into one instruction.
 * op o[0].x,...
 * op r#.x,...
 * can be combined into one instruction.
 *
 *
 */

bool PairableMasks1(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b){
    // Do they have the same opcode?
    // ToDo - extend to handle cases where a is already paired and b is compatable.
    bool macOpSame = a->mac == b->mac;
    bool iluOpSame = a->ilu == b->ilu;
    if( ! (macOpSame && iluOpSame) ) {
        return false;
    }

    // Same inputs? TODO - don't look at unused inputs
    bool aSame = a->amx == b->amx && a->ane == b->ane && a->arr == b->arr
        && a->aws == b->aws && a->axs == b->axs && a->ays == b->ays && a->azs == b->azs;
    bool bSame = a->bmx == b->bmx && a->bne == b->bne && a->brr == b->brr
        && a->bws == b->bws && a->bxs == b->bxs && a->bys == b->bys && a->bzs == b->bzs;
    bool cSame = a->cmx == b->cmx && a->cne == b->cne && a->crr == b->crr
        && a->cws == b->cws && a->cxs == b->cxs && a->cys == b->cys && a->czs == b->czs;

    if (! (aSame && bSame && cSame) ){
        return false;
    }

    if ( ! ( a->ca == b->ca && a->va == b->va && a->cin == b->cin ) ) {
        return false;
    }

    // Is there an input-output dependency between a and b? (Does b use the result of a?
    if(InputOutputDependency(a,b)){
        return false;
    }

    // Same calculation, where does the result go?
    bool aUsesReg = (a->rwm || a->swm);
    bool bUsesReg = (b->rwm || b->swm);
    // If this isn't a reg vs. oc situation, then don't pair them.
    // If the user has global optimization turned on, then the
    // PairableMasks3 optimization will handle this case.
    // If the user doesn't have global optimization turned on,
    // then let them live with this code.
    
    if(aUsesReg && bUsesReg || a->owm && b->owm){
        return false;
    }

    // OK it's mergable, so merge it.
    *pair = *a;
    pair->rwm |= b->rwm;
    pair->swm |= b->swm;
    if(bUsesReg && ! aUsesReg){
        pair->rw = b->rw;
    }
    pair->owm |= b->owm;
    if(b->owm && !a->owm){
        pair->oc = b->oc;
        pair->om = b->om;
    }
    return true;

}

bool NullSwizzle(DWORD rwm, DWORD ne, DWORD xs, DWORD ys, DWORD zs, DWORD ws){
    return (! ne)
        && (! (rwm & 1) || ws == CSW_W)
        && (! (rwm & 2) || zs == CSW_Z)
        && (! (rwm & 4) || ys == CSW_Y)
        && (! (rwm & 8) || xs == CSW_X);
}

bool ReadsFromConst(const D3DVsInstruction* pI){
    return kMacUsesA[pI->mac] && pI->amx == MX_C
        || kMacUsesB[pI->mac] && pI->bmx == MX_C
        || kMacUsesC[pI->mac] && pI->cmx == MX_C
        || pI->ilu && pI->cmx == MX_C;
}

bool CompatableConstUsage(const D3DVsInstruction* pA, const D3DVsInstruction* pB){
    // Quick return
    if ( pA->ca == pB->ca && pA->cin == pB->cin){
        return true;
    }

    if (! (ReadsFromConst(pA) && ReadsFromConst(pB)) ){
        return true; 
    }

    return false;
}

/*
 * Alternately, if we have an instruction that writes to a temporary register,
 * and the next instruction is a mov that doesn't swizzle or negate, and just
 * copies the temporary register to an output register, then we can pair that
 * too.
 */

bool PairableMasks2(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b){
    // Is the first instruction a register output instruction
    // Is the second instruction a MOV from the same register to an output reg?
    // TODO: Currently a must be a mac instruction - but paired and ilu instructions
    // should be checked, too.
    bool pairable = ! a->owm
        && a->rwm 
        // b is a simple, non-swizzleing, non-negating move
        && b->mac == MAC_MOV
        && ! b->ilu
        && b->amx == MX_R
        && b->arr == a->rw
        && NullSwizzle(b->owm, b->ane, b->axs, b->ays, b->azs, b->aws)
        && b->om == OM_MAC
        && (b->owm & (~ (a->rwm))) == 0 // It only reads data that was written by A
        && b->owm
        && ! b->rwm
        && ! b->swm
        && CompatableConstUsage(a, b);

    if(pairable){

        // OK it's mergable, so merge it.
        *pair = *a;
        pair->owm = b->owm;
        pair->om = b->om;
        pair->oc = b->oc;
    }

    return pairable;
}

/*
 * If we have two instructions that
 * 1) have the same opcodes
 * 2) take compatable arguments
 * 3) write to compatable output registers
 * 4) don't have input/output dependencies 
 *
 * then they can be merged together.
 *
 * An example would be:
 *
 * add r0.x,r1.x,r2.x
 * add oPos.y,r1.y,r2.y
 *
 * This can be combined into
 * add {r0.x,oPos.y},r1.xy,r2.xy
 *
 * A simpler example would be:
 *
 * mov r0.y,r1.x
 * mov r0.x,r1.y
 *
 * Which would become
 *
 * mov r0.xy,r1.yx
 *
 */

// Are two operends reading data from the same sources (not counting swizzle)?

bool SourcesEqual(DWORD a_mx, DWORD a_rr, DWORD a_ne, const D3DVsInstruction* a,
                  DWORD b_mx, DWORD b_rr, DWORD b_ne, const D3DVsInstruction* b){
    return a_mx == b_mx && a_ne == b_ne &&
        ((a_mx == MX_R && a_rr == b_rr)
        || (a_mx == MX_V && a->va == b->va)
        || (a_mx == MX_C && a->ca == b->ca && a->cin == b->cin));
}

// ignoring swizzle, which compontents of the input arguments are used
// by this opcode?
// Results is a 3 character array, where results[0] = arg a's mask,
// Mask bit order is the same as the output mask

void ComputePostSwizzleUseMasks(const D3DVsInstruction* pI, UCHAR* results){
    UCHAR aMask = 0;
    UCHAR bMask = 0;
    UCHAR cMask = 0;

    UCHAR macMask = pI->rwm | ((pI->om == OM_MAC) ? pI->owm : 0);
    UCHAR iluMask = pI->swm | ((pI->om == OM_ILU) ? pI->owm : 0);

    for(int a = 0; a < 3; a++){
        results[a] =
              kMACInputRegFixedComponentUse[pI->mac][a]
            | kILUInputRegFixedComponentUse[pI->ilu][a]
            | (macMask & kMACInputRegColumnatedComponentUse[pI->mac][a])
            | (iluMask & kILUInputRegColumnatedComponentUse[pI->ilu][a]);
    }
}

void ComputeEffectiveSwizzle(UCHAR mask, UCHAR xs, UCHAR ys, UCHAR zs, UCHAR ws, char* pSwizzles){
    pSwizzles[0] = (mask & 1) ? (char) ws : -1; // We read W from where?
    pSwizzles[1] = (mask & 2) ? (char) zs : -1;
    pSwizzles[2] = (mask & 4) ? (char) ys : -1;
    pSwizzles[3] = (mask & 8) ? (char) xs : -1;
}

void ComputeEffectiveSwizzles(const D3DVsInstruction* a, char* pSwizzles){
    UCHAR masks[3];
    ComputePostSwizzleUseMasks(a, masks);
    ComputeEffectiveSwizzle(masks[0], a->axs, a->ays, a->azs, a->aws, pSwizzles);
    ComputeEffectiveSwizzle(masks[1], a->bxs, a->bys, a->bzs, a->bws, pSwizzles+4);
    ComputeEffectiveSwizzle(masks[2], a->cxs, a->cys, a->czs, a->cws, pSwizzles+8);
}

UCHAR ComputeEffectiveReadMask(UCHAR xs, UCHAR ys, UCHAR zs, UCHAR ws){
    return 1 << (3-xs) | 1 << (3-ys) | 1 << (3-zs) | 1 << (3-ws);
}

UCHAR ComputeEffectiveReadMask(const D3DVsInstruction* a, int channel){
    switch(channel){
    case 0: return ComputeEffectiveReadMask(a->axs, a->ays, a->azs, a->aws);
    case 1: return ComputeEffectiveReadMask(a->bxs, a->bys, a->bzs, a->bws);
    case 2: return ComputeEffectiveReadMask(a->cxs, a->cys, a->czs, a->cws);
    default:
        return 0;
    }
}
    
// Look at four swizzles, pick the last one that's defined
// If they're all undefined, use the default Undef.
//
// The idea here is to generate masks that look good when printed,
// e.g. .w instead of .xxxw (given that w is defined and the other fields aren't)

bool CanUseXYZW(const char* pSwizzleRun){
    const char kXYZW[4] = {CSW_W, CSW_Z, CSW_Y, CSW_X};
    for(int i = 0; i < 4; i++){
        if(pSwizzleRun[i] != -1 && pSwizzleRun[i] != kXYZW[i]){
            return false;
        }
    }
    return true;
}

char PickDefault(const char* pSwizzleRun){
    // First check if the .xyzw swizzle pattern would work
    if(CanUseXYZW(pSwizzleRun)){
        return -1;
    }

    // Otherwise, find last element that's used, so we get a pattern like
    // .w

    for(int i = 0; i < 4; i++){
        if(pSwizzleRun[i] != -1){
            return pSwizzleRun[i];
        }
    }

    // Shouldn't get here.
    return -1;
}

DWORD ChooseBestSwizzle(char swizzle, char defaultSw, char defaultDefault){
    if ( swizzle == -1 ) {
        swizzle = defaultSw;
    }
    if ( swizzle == -1 ) {
        swizzle = defaultDefault;
    }
    return (DWORD) swizzle;
}

void SetSwizzles(D3DVsInstruction* pI, const char* pSwizzles){
    char defaultSw = PickDefault(&pSwizzles[0]);
    pI->aws = ChooseBestSwizzle(pSwizzles[0], defaultSw, CSW_W);
    pI->azs = ChooseBestSwizzle(pSwizzles[1], defaultSw, CSW_Z);
    pI->ays = ChooseBestSwizzle(pSwizzles[2], defaultSw, CSW_Y);
    pI->axs = ChooseBestSwizzle(pSwizzles[3], defaultSw, CSW_X);
    
    defaultSw = PickDefault(&pSwizzles[4]);
    pI->bws = ChooseBestSwizzle(pSwizzles[4], defaultSw, CSW_W);
    pI->bzs = ChooseBestSwizzle(pSwizzles[5], defaultSw, CSW_Z);
    pI->bys = ChooseBestSwizzle(pSwizzles[6], defaultSw, CSW_Y);
    pI->bxs = ChooseBestSwizzle(pSwizzles[7], defaultSw, CSW_X);

    defaultSw = PickDefault(&pSwizzles[8]);
    pI->cws = ChooseBestSwizzle(pSwizzles[8], defaultSw, CSW_W);
    pI->czs = ChooseBestSwizzle(pSwizzles[9], defaultSw, CSW_Z);
    pI->cys = ChooseBestSwizzle(pSwizzles[10], defaultSw, CSW_Y);
    pI->cxs = ChooseBestSwizzle(pSwizzles[11], defaultSw, CSW_X);
}

bool PairableMasks3(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b){
    // Do they have the same opcode?
    // ToDo - extend to handle cases where a is already paired and b is compatable.
    bool macOpSame = a->mac == b->mac;
    bool iluOpSame = a->ilu == b->ilu;
    if( ! (macOpSame && iluOpSame) ) {
        return false;
    }

    // Do they have the same input sources
    // Swizzle can be different - we'll check that later
    if ( ! ( SourcesEqual(a->amx, a->arr, a->ane, a, b->amx, b->arr, b->ane, b)
          && SourcesEqual(a->bmx, a->brr, a->bne, a, b->bmx, b->brr, b->bne, b)
          && SourcesEqual(a->cmx, a->crr, a->cne, a, b->cmx, b->crr, b->cne, b) ) ){
        return false;
    }

    // Is there an input-output dependency between a and b? (Does b use the result of a?
    if(InputOutputDependency(a,b)){
        return false;
    }

    // Do they have compatable outputs?

    bool aUsesReg = (a->rwm || a->swm);
    bool bUsesReg = (b->rwm || b->swm);
    if(aUsesReg && bUsesReg && a->rw != b->rw){
        return false;
    }
    if(a->owm && b->owm && a->oc != b->oc){
        return false;
    }

    // Everything's OK except perhaps the swizzles.
    // Start the merge.
    *pair = *a;

    if(! MergeSwizzles(pair,a, b) ){
        return false;
    }

    pair->rwm |= b->rwm;
    pair->swm |= b->swm;
    if(bUsesReg && ! aUsesReg){
        pair->rw = b->rw;
    }
    pair->owm |= b->owm;
    if(b->owm && !a->owm){
        pair->oc = b->oc;
        pair->om = b->om;
    }

    return true;
}

bool MergeSwizzles(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b){
    char aSwizzles[12];
    char bSwizzles[12];
    char abSwizzles[12];

    ComputeEffectiveSwizzles(a,aSwizzles);
    ComputeEffectiveSwizzles(b,bSwizzles);

    // Are the swizzles incompatable?
    for(int i = 0; i < 12; i++){
        char as = aSwizzles[i];
        char bs = bSwizzles[i];
        if( as != -1 && bs != -1 && as != bs ) {
            return false; // Incompatable
        }
        abSwizzles[i] = as != -1 ? as : bs;
    }

    // Merge swizzles
    SetSwizzles(pair, abSwizzles);
    return true;
}

// A should always be the first instruction in the sequence for PairableMasks to work
// correctly.
bool PairableMasks(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b){
    return PairableMasks1(pair, a, b) || PairableMasks2(pair, a, b);
}

HRESULT PeepholePairOutputMasks(D3DVertexShaderProgram* program){
    HRESULT hr = S_OK;

    // Look to see if any microcode can be paired
    DWORD outPC = 0;
    // The pairing optimization
    for(int pc = 0; pc < program->length; pc++, outPC++){
        // Do the pairing optimization
        D3DVsInstruction pair;
        if((pc < program->length-1)
            && PairableMasks(&pair, &program->ucode[pc], &program->ucode[pc+1]))
        {
#ifdef DBG_PAIRER
            DPF2("PeepholePairOutputMasks: pairing %d with %d.\n", pc, pc+1);
            PrintInstruction(pc, program);
            PrintInstruction(pc+1, program);
            PrintInstruction(pc, &pair);
#endif
            program->ucode[outPC] = pair;
            pc++;
        }
        else {
            program->ucode[outPC] = program->ucode[pc];
        }
    }
    program->length = outPC;
    return S_OK;
}

bool MacUsesMX(const D3DVsInstruction* a, DWORD mxVal){
    return (kMacUsesA[a->mac] && a->amx == mxVal)
        || (kMacUsesB[a->mac] && a->bmx == mxVal)
        || (kMacUsesC[a->mac] && a->cmx == mxVal);
}

bool IluUsesMX(const D3DVsInstruction* a, DWORD mxVal){
    return a->ilu && a->cmx == mxVal;
}

bool UsesMX(const D3DVsInstruction* a, DWORD mxVal){
    return MacUsesMX(a, mxVal) || IluUsesMX(a, mxVal);
}

bool UsesCA(const D3DVsInstruction* a){
    return UsesMX(a, MX_C);
}

bool UsesVA(const D3DVsInstruction* a){
    return UsesMX(a, MX_V);
}

bool PairableMulAdd(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b)
{
    if ( ! (a->mac == MAC_MUL
        && ! a->ilu
        && b->mac == MAC_ADD
        && ! b->ilu
        && a->rwm
        && ! a->owm
        && b->rwm == a->rwm
        && b->rw == a->rw
        && ! (b->owm & ~ b->rwm) // If b outputs to owm, it does so using a subset of rwm
        ) ){
        return false;
    }
    // We know that a is a MUL that outputs to a register, and b is an ADD that
    // outputs to the same register.

    // Now does b input from a's register?
    bool bUsesAOpr = b->amx == MX_R && b->arr == a->rw;
    bool bUsesCOpr = b->cmx == MX_R && b->crr == a->rw;
    if(! (bUsesAOpr ^ bUsesCOpr) ) {
        return false; // One or the other, but not both.
    }

    // Are the swizzles compatable?
    if( bUsesAOpr && ! NullSwizzle(b->rwm, b->ane, b->axs, b->ays, b->azs, b->aws) ){
        return false;
    }
    if( bUsesCOpr && ! NullSwizzle(b->rwm, b->cne, b->cxs, b->cys, b->czs, b->cws) ){
        return false;
    }

    // Are the uses of the va and ca registers compatable?
    bool aUsesVA = UsesVA(a);
    bool bUsesVA = UsesVA(b);
    bool aUsesCA = UsesCA(a);
    bool bUsesCA = UsesCA(b);
    if( aUsesVA && bUsesVA && a->va != b->va){
        return false;
    }

    if(aUsesCA && bUsesCA && a->ca != b->ca){
        return false;
    }
    
    // OK, pair em up!

    *pair = *a;
    pair->mac = MAC_MAD;
    if(bUsesVA){
        pair->va = b->va;
    }
    if(bUsesCA){
        pair->ca = b->ca;
    }
    if(bUsesAOpr){
        // b uses the A operend for the register that's being MAC-ed to, so
        // copy the C register (that's the one that's being added.)
        pair->cmx = b->cmx;
        pair->cne = b->cne;
        pair->crr = b->crr;
        pair->cxs = b->cxs;
        pair->cys = b->cys;
        pair->czs = b->czs;
        pair->cws = b->cws;
    }

    if(bUsesCOpr){
        // b uses the C operend for the register that's being MAC-ed to, so
        // copy the A register (that's the one that's being added.)
        pair->cmx = b->amx;
        pair->cne = b->ane;
        pair->crr = b->arr;
        pair->cxs = b->axs;
        pair->cys = b->ays;
        pair->czs = b->azs;
        pair->cws = b->aws;
    }

    // Copy b's om
    pair->om = b->om;
    pair->owm = b->owm;
    pair->oc = b->oc;

    return true;
}

// a and b are guarenteed to be sequential instructions

bool SequentialPairable(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b)
{
    return Pairable(pair, a, b)
        || PairableMasks(pair, a, b) 
        || PairableMulAdd(pair, a, b)
        || PairableMasks3(pair, a, b);
}

// Force two instructions together, as-is, without re-arrainging instructions

bool UsesA(const D3DVsInstruction* a){
    return kMacUsesA[a->mac];
}

bool UsesB(const D3DVsInstruction* a){
    return kMacUsesB[a->mac];
}

bool UsesC(const D3DVsInstruction* a){
    return kMacUsesC[a->mac] || a->ilu;
}

void ExpandRegisterOutputMasks(OutPair* masks, const D3DVsInstruction* a){
    masks[0].m = (unsigned char) a->rwm;
    masks[0].r = (unsigned char) a->rw;
    masks[0].used = a->rwm && a->mac;
    masks[1].m = (unsigned char) a->swm;
    // 7 is traditionally the default don't-care value. No known reason.
    masks[1].r = (unsigned char) (a->ilu ? (a->mac ? 1 : a->rw): 7);   //r7
    masks[1].used = a->swm && a->ilu;
}

bool SetRegisterOutputMasks(D3DVsInstruction* a, const OutPair* masks){
    // Check to make sure that the resulting masks are expressible
    // If both mac and ilu write to registers, 
    // then mac can't write to r1, and ilu must write to r1.
    if(masks[0].used && masks[1].used){
        if(masks[0].r == 1 || masks[1].r != 1){
            return false;
        }
    }
    a->rwm = masks[0].m;
    a->swm = masks[1].m;
    a->rw = masks[0].used ? masks[0].r : masks[1].r; 
    
    return true;
}

bool MergeRegisterOutputMasks(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b)
{
    OutPair ma[2];
    OutPair mb[2];
    OutPair mp[2];
    ExpandRegisterOutputMasks(ma, a);
    ExpandRegisterOutputMasks(mb, b);
    
    // Merge
    for(int i = 0; i < 2; i++){
        mp[i] = ma[i];
        if(ma[i].used && mb[i].used ) {
            if( ma[i].r != mb[i].r) {
                // Incompatable register use
                return false;
            }
            if( ma[i].m != mb[i].m){
                // incompatable mask use
                return false;
            }
        }
        // if we get here then either ma or mb is used, but not both. We've
        // already stored the ma values, so replace them with the mb values if mb is used
        if(mb[i].used){
            mp[i] = mb[i];
        }
    }

    // If there is both a mac and an ilu instruction,
    if(pair->mac && pair->ilu){
        // if the ilu instruction uses a register,
        // then it must use r1.
        if(mp[1].used && mp[1].r != 1){
            return false;
        }
        // if the mac instruction uses a register,
        // then it must not use r1.
        if(mp[0].used && mp[0].r == 1){
            return false;
        }
    }

    return SetRegisterOutputMasks(pair, mp);
}


bool ForcedPair2(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b,
                 DWORD* pReason)
{
    // Assemble the parts
    *pair = *a;

    // merge mac
    if(b->mac){
        if(a->mac && a->mac != b->mac){
            *pReason = ERROR_ASM_CANT_PAIR_OPCODES;
            return false;
        }
        pair->mac = b->mac;
    }

    // merge ilu
    if(b->ilu){
        if(a->ilu && a->ilu != b->ilu){
            *pReason = ERROR_ASM_CANT_PAIR_OPCODES;
            return false;
        }
        pair->ilu = b->ilu;
    }


    // Merge input a
    if(UsesA(b)){
        if(UsesA(a)){
            if(b->amx != a->amx){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
            if(b->ane != a->ane){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
            if(b->amx == MX_R && b->arr != a->arr){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
        }
        pair->amx = b->amx;
        pair->ane = b->ane;
        pair->arr = b->arr;
    }

    // Merge input b
    if(UsesB(b)){
        if(UsesB(a)){
            if(b->bmx != a->bmx){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
            if(b->bne != a->bne){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
            if(b->bmx == MX_R && b->brr != a->brr){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
        }
        pair->bmx = b->bmx;
        pair->bne = b->bne;
        pair->brr = b->brr;
    }

    // Merge input c
    if(UsesC(b)){
        if(UsesC(a)){
            if(b->cmx != a->cmx){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
            if(b->cne != a->cne){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
            if(b->cmx == MX_R && b->crr != a->crr){
                *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
                return false;
            }
        }
        pair->cmx = b->cmx;
        pair->cne = b->cne;
        pair->crr = b->crr;
    }

    if(!MergeSwizzles(pair, a, b)){
        *pReason = ERROR_ASM_CANT_PAIR_INPUT_SWIZZLES;
        return false;
    }

    // ca, cin

    if(UsesCA(b)){
        if(UsesCA(a) && (a->ca != b->ca || a->cin != b->cin)){
            *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
            return false;
        }
        else {
            pair->ca = b->ca;
            pair->cin = b->cin;
        }
    }

    // va
    if(UsesVA(b)){
        if(UsesVA(a) && (a->va != b->va)){
            *pReason = ERROR_ASM_CANT_PAIR_INPUTS;
            return false;
        }
        else {
            pair->va = b->va;
        }
    }

    // om, owm, oc
    if(b->owm){
        if(a->owm && (b->om != a->om || b->owm != a->owm || b->oc != a->oc)){
            *pReason = ERROR_ASM_CANT_PAIR_OUTPUTS;
            return false;
        }
        else {
            pair->owm = b->owm;
            pair->om = b->om;
            pair->oc = b->oc;
        }
    }

    // rwm, swm, rw

    if(!MergeRegisterOutputMasks(pair, a, b)){
        *pReason = ERROR_ASM_CANT_PAIR_OUTPUTS;
        return false;
    }
    return true;
}

bool ForcedPair(D3DVsInstruction* pair, const D3DVsInstruction* a, const D3DVsInstruction* b,
                DWORD* pReason)
{
    DWORD dummyReason;
    if( ForcedPair2(pair, a, b, pReason)){
        return true;
    }

    // TODO: we might not want to pair two moves, 
	//because it wastes a potential ILU instruction

    // See if first instruction can be turned into an IMV
    D3DVsInstruction dummy;
    if(ConvertToImv(&dummy,a)){
        if(ForcedPair2(pair,&dummy, b, &dummyReason)){
            return true;
        }
    }

    // See if second instruction can be turned into an IMV
    if(ConvertToImv(&dummy,b)){
        if(ForcedPair2(pair, a, &dummy, &dummyReason)){
            return true;
        }
    }

    return false;
}

// Just combine R1 ILU instructions

HRESULT PeepholePair1(D3DVertexShaderProgram* program){
    HRESULT hr = S_OK;

    // Look to see if any microcode can be paired
    DWORD outPC = 0;
    // The pairing optimization
    for(int pc = 0; pc < program->length; pc++, outPC++){
        // Do the pairing optimization
        D3DVsInstruction pair;
        D3DVsInstruction a = program->ucode[pc];
        while((pc < program->length-1)
            && Pairable(&pair, &a, &program->ucode[pc+1]))
        {
#ifdef DBG_PAIRER
            DPF2("PeepholePair1: pairing %d with %d.\n", pc, pc+1);
            PrintInstruction(pc, program);
            PrintInstruction(pc+1, program);
            PrintInstruction(pc, &pair);
#endif
            a = pair;
            pc++;
        }
        program->ucode[outPC] = a;
    }
    program->length = outPC;
    return S_OK;
}

HRESULT PeepholePair2(D3DVertexShaderProgram* program){
    HRESULT hr = S_OK;

    // Look to see if any microcode can be paired
    DWORD outPC = 0;
    // The pairing optimization
    for(int pc = 0; pc < program->length; pc++, outPC++){
        // Do the pairing optimization
        D3DVsInstruction pair;
        D3DVsInstruction a = program->ucode[pc];
        while((pc < program->length-1)
            && SequentialPairable(&pair, &a, &program->ucode[pc+1]))
        {
#ifdef DBG_PAIRER
            DPF2("PeepholePair2: pairing %d with %d.\n", pc, pc+1);
            PrintInstruction(pc, program);
            PrintInstruction(pc+1, program);
            PrintInstruction(pc, &pair);
#endif
            a = pair;
            pc++;
        }
        program->ucode[outPC] = a;
    }
    program->length = outPC;
    return S_OK;
}


HRESULT ListD3DTokens(Buffer* pBuffer, const DWORD* tokens, DWORD length){
    HRESULT hr = S_OK;
    for(DWORD i = 0; i < length && SUCCEEDED(hr); i++){
        hr = pBuffer->Printf("%d: %08x\n", i, tokens[i]);
    }
    return hr;
}

class MyErrorLog : public XD3DXErrorLog {
public:
    MyErrorLog(){
        m_buffer = NULL;
        m_defaultFileName = NULL;
    }

    ~MyErrorLog(){
        delete m_buffer;
    }

    HRESULT Initialize(const char* defaultFileName){
        HRESULT hr = S_OK;
        m_buffer = new Buffer();
        if(!m_buffer){
            SETERROR(hr, E_OUTOFMEMORY);
        }
        if(SUCCEEDED(hr)){
            hr = m_buffer->Initialize(1024);
        }
        m_defaultFileName = defaultFileName;
        return hr;
    }

    virtual HRESULT Log(bool error, DWORD errorCode, LPCSTR filePath, DWORD line, LPCSTR message){
        HRESULT hr = S_OK;
        const char* messageType = error ? "error" : "warning";

        if(!filePath){
            filePath = m_defaultFileName;
        }
        if(!line){
            line = 1;
        }

#ifdef DBG
        DWORD startOffset = m_buffer->GetUsed();
#endif
        hr = m_buffer->Printf("%s(%d) : %s V%d: %s\n",
            filePath, line, messageType, errorCode, message);
#ifdef DBG
        const char* msg = m_buffer->GetText() + startOffset;
        DPF2("%s",msg);
#endif
        return hr;
    }
    Buffer* m_buffer;
    const char* m_defaultFileName;
};

HRESULT XGBufferCreateFromBuffer(Buffer* pBuf, LPXGBUFFER* ppXGBuf){
    HRESULT hr = S_OK;
    if(pBuf && ppXGBuf){
        // Create the listing object.
        DWORD size = pBuf->GetUsed();
        hr = XGBufferCreate(size, ppXGBuf);
        if(SUCCEEDED(hr)){
            PVOID newData = (*ppXGBuf)->GetBufferPointer();
            memcpy(newData, pBuf->GetText(), size);
//			((char*)newData)[size] = '\0';
        }
    }
    return hr;
}

extern "C" HRESULT XGOptimizeVertexShader(bool optimize, bool globalOptimize, bool verifyOptimizer, 
	DWORD shaderType, D3DVertexShaderProgram* ucode)
{

	HRESULT hr = S_OK;

#ifndef DISABLE_VERIFIER
    VerTable* pPreOptimizedTable = 0;
    VerConstTableList* pPreOptimizedConsts = 0;

    if(SUCCEEDED(hr)){
        if(verifyOptimizer && (optimize || globalOptimize)){
            hr = VerTable::BuildTable(ucode, &pPreOptimizedConsts, &pPreOptimizedTable);
            if(!pPreOptimizedTable) {
                VER_ERR(("Couldn't create PreOptimizedTable for verifier"));
            }
        }
    }
#endif

    int preOptimizationLength;

#ifdef VERIFY_EACH_STEP
    int passNumber = 0;
#endif
    do {
#ifdef VERIFY_EACH_STEP
        DPF2("Optimization pass %d\n", passNumber);
        ++passNumber;
#endif
        preOptimizationLength = ucode->length;
        if(SUCCEEDED(hr)){
            if(optimize){
                // Allow this even when global optimization is
                // turned off. Otherwise people can't hand-optimize
                // their code.

                hr = PeepholePairOutputMasks(ucode);
                if(SUCCEEDED(hr)){
#ifndef DISABLE_VERIFIER
                    hr = VerifyStep(pPreOptimizedTable, ucode, "PeepholePairOutputMasks");
#endif
                }
            }
        }

        // We run the dead code stripper after the PeepholePairOutputMasks because some
        // of the PeepholePairOutputMasks optimizations can generate dead code. Specificly:
        //     mul r1, v0, v0
        //     mov oPos, r1
        // becomes
        //     mul {r1,oPos},v0,v0
        //
        // And if r1 isn't used anywhere else, it is dead code that can be stripped.

        if(SUCCEEDED(hr)){
            if(globalOptimize){
#ifndef DISABLE_STRIPPER
                DeadCodeStripper d;
                hr = d.Run(shaderType, ucode);
                if(SUCCEEDED(hr)){
                    hr = VerifyStep(pPreOptimizedTable, ucode, "DeadCodeStripper");
                }
#endif
            }
        }
        if(SUCCEEDED(hr)){
            if(globalOptimize){
#ifndef DISABLE_RENAMER
                Renamer r;
                hr = r.Run(shaderType, ucode);

                if(SUCCEEDED(hr)){
                    hr = VerifyStep(pPreOptimizedTable, ucode, "Renamer");
                }
#endif
            }
        }
        if(SUCCEEDED(hr)){
            if(globalOptimize){
#ifndef DISABLE_REORDERER
                Reorderer r;
#ifndef DISABLE_VERIFIER
                r.pPreOptimizedTable = pPreOptimizedTable;
#endif
                hr = r.Run(shaderType, ucode);
                if(SUCCEEDED(hr)){
                    hr = VerifyStep(pPreOptimizedTable, ucode, "Reorderer");
                }
#endif
            }
        }
        if(SUCCEEDED(hr)){
            if(globalOptimize){
#ifndef DISABLE_PEEPHOLE
                hr = PeepholeOptimize(shaderType, ucode);

                if(SUCCEEDED(hr)){
#ifndef DISABLE_VERIFIER
                    hr = VerifyStep(pPreOptimizedTable, ucode, "PeepholeOptimize");
#endif
                }
#endif
            }
        }
        if(SUCCEEDED(hr)){
            if(optimize){
#ifndef DISABLE_PAIRER1
                hr = PeepholePair1(ucode);

                if(SUCCEEDED(hr)){
#ifndef DISABLE_VERIFIER
                    hr = VerifyStep(pPreOptimizedTable, ucode, "PeepholePair1");
#endif
                }
#endif
            }
        }
        if(SUCCEEDED(hr)){
            if(globalOptimize){
#ifndef DISABLE_PAIRER2
                hr = PeepholePair2(ucode);

                if(SUCCEEDED(hr)){
#ifndef DISABLE_VERIFIER
                    hr = VerifyStep(pPreOptimizedTable, ucode, "PeepholePair2");
#endif
                }
#endif // DISABLE_PAIRER2
            }
        }

        // If the number of instructions went down, try optimizing everything again,
        // because there may be more dead code, which in turn could allow more
        // pairing, and so on.
    } while(SUCCEEDED(hr) && globalOptimize && ucode->length < preOptimizationLength);

#if !defined(DISABLE_VERIFIER) && ! defined(VERIFY_EACH_STEP)
    // Check if the whole optimization succeeded
    if(SUCCEEDED(hr)){
        if((globalOptimize || optimize) && pPreOptimizedTable){
            if ( ! Verify(pPreOptimizedTable, ucode, "the optimizer") ){
                hr = E_OPTIMIZER_FAILED;
            }
        }
    }
#endif

    #ifndef DISABLE_VERIFIER
        delete pPreOptimizedTable;
        delete pPreOptimizedConsts;
    #endif

	return hr;
}


class Assembler {
public:
    static HRESULT ConvertMicrocodeToVsInstructions(bool bScreenSpace, DWORD srcDataLen, LPCVOID srcData,
        D3DVertexShaderProgram* ucode, DWORD* pShaderType, XD3DXErrorLog* pErrorLog)
    {
        HRESULT hr = S_OK;
        if(srcDataLen < 4){
            pErrorLog->Log(true, ERROR_INPUT_MICROCODE_FORMAT, NULL,1,"Invalid input microcode size.");
            hr = E_FAIL;
        }
        *pShaderType = XGSUCode_GetVertexShaderType(srcData);
        if(*pShaderType == SASMT_INVALIDSHADER){
            pErrorLog->Log(true, ERROR_INPUT_MICROCODE_FORMAT, NULL,1,"Invalid input microcode shader type.");
            hr = E_FAIL;
        }

        WORD numInstructions = 0;
        if(SUCCEEDED(hr)){
            numInstructions = ((WORD*) srcData)[1];
            if(numInstructions*sizeof(PaddedUCode) + 4 != srcDataLen){
                pErrorLog->Log(true, ERROR_INPUT_MICROCODE_FORMAT, NULL,1,"Invalid input microcode size.");
                hr = E_FAIL;
            }
        }
        int totalInstructions = numInstructions;
        if(!bScreenSpace){
            totalInstructions += 2; // For conversion to screen space
        }
        if(SUCCEEDED(hr)){
            if(totalInstructions > MAX_MICROCODE_LENGTH){
                pErrorLog->Log(true, ERROR_INPUT_MICROCODE_FORMAT, NULL,1,"Input microcode has too many instructions.");
                hr = E_FAIL;
            }
        }
        if(SUCCEEDED(hr)){
            ucode->length = numInstructions;
            for(int i = 0; i < numInstructions; i++){
                ConvertPackedDWordsToUCode((DWORD*) ((char*) srcData + i*sizeof(PaddedUCode) + 4),
                    &ucode->ucode[i]);
                ucode->ucode[i].eos = 0;
            }
        }
        if(SUCCEEDED(hr)){
            if(!bScreenSpace){
                static const DWORD kStandardPostfix[] = {
                    0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
                    0x00000000, 0x0087601b, 0xc400286c, 0x3070e800
                };
                ConvertPackedDWordsToUCode(kStandardPostfix,
                    &ucode->ucode[ucode->length++]);
                ConvertPackedDWordsToUCode(kStandardPostfix+4,
                    &ucode->ucode[ucode->length++]);
            }
        }
        return hr;
    }
	



private:
    HRESULT ConvertMicrocodeToVsInstructions(D3DVertexShaderProgram* ucode, DWORD* pShaderType, XD3DXErrorLog* pErrorLog){
        return ConvertMicrocodeToVsInstructions(m_bInputMicrocodeIsScreenSpace, m_SrcDataLen,
            m_pSrcData, ucode, pShaderType, pErrorLog);
    }


    void SetToNOP(D3DVsInstruction* pI){
        memset(pI, 0, sizeof(D3DVsInstruction));
    }


    HRESULT InstructionsToMicrocode(bool optimize, bool globalOptimize, bool verifyOptimizer,
                                    DWORD shaderType, 
                                    D3DVertexShaderProgram* ucode,
                                    Buffer* pListing,
                                    XD3DXErrorLog* pErrorLog){
        HRESULT hr = S_OK;
        DWORD instructions = 0;
            
        if(m_bInputMicrocode){
            hr = ConvertMicrocodeToVsInstructions(ucode, &shaderType, pErrorLog);
            instructions = ucode->length;
        }
        else {
            if(! SASMT_ISSCREENSPACE(shaderType) && SASMT_SHADERTYPE(shaderType) != SASMT_VERTEXSTATESHADER){
                static const DWORD kStandardPostfix[] = {
                    0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
                    0x00000000, 0x0087601b, 0xc400286c, 0x3070e800 ////must not have the eof flag... optimizers might move the instruction without removing the eof
                };
				ucode->ucode[ucode->length].eos = 0;
                ConvertPackedDWordsToUCode(kStandardPostfix,
                    &ucode->ucode[ucode->length++]);
                ConvertPackedDWordsToUCode(kStandardPostfix+4,
                    &ucode->ucode[ucode->length++]);
            }

			instructions = ucode->length;
		}

        DWORD preOptLength = ucode->length;
        float preOptCycles;
        if(SUCCEEDED(hr)){
            if(pListing){
                hr = pListing->Printf("// instructions: %d\r\n", instructions);
                if(SUCCEEDED(hr)){
                    hr = EstimateCycles(shaderType, ucode, &preOptCycles);
                }
            }
        }
    #ifdef DBG_PRINT_PRE_OPTIMIZED
        if(SUCCEEDED(hr)){
            Print(shaderType, *ucode);
        }
    #endif


		hr = XGOptimizeVertexShader(optimize, globalOptimize, verifyOptimizer, shaderType, ucode);

        // Generate the listing

        if(SUCCEEDED(hr)){
            if(pListing){
                switch(SASMT_SHADERTYPE(shaderType)){
                case SASMT_VERTEXSTATESHADER:
                    hr = pListing->Append("xvss.1.1\r\n");
                    break;
                case SASMT_READWRITE_VERTEXSHADER:
                    hr = pListing->Append("xvsw.1.1\r\n#pragma screenspace\r\n");
                    break;
                case SASMT_VERTEXSHADER:
                default:
                    hr = pListing->Append("xvs.1.1\r\n#pragma screenspace\r\n");
                    break;
                }
                if(SUCCEEDED(hr)){
                    hr = pListing->Append("/*slot stall */\r\n");
                }
                if(SUCCEEDED(hr)){
                    InstructionDisassembler dis;
                    TLEngineSim sim;
                    hr = sim.Initialize(shaderType, ucode->length);
					bool usedreasons[256] = {false};
                    for(int i = 0;i < ucode->length && SUCCEEDED(hr); i++){
                        float stall = 0;
						StallType reason = eNone;
                        const D3DVsInstruction* pI = &ucode->ucode[i];
                        hr = sim.Do(pI, stall, reason);
                        if(SUCCEEDED(hr)){
                            if(stall || (reason != ' ')){
								hr = pListing->Printf("/* %3d %c %.2f */  ", i, char(reason), stall);
								usedreasons[reason] = true;
								usedreasons[0] = true;
                            }
                            else { 
								hr = pListing->Printf("/* %3d        */  ", i);
                            }
                        }
                        if(SUCCEEDED(hr)){
                            hr = dis.Disassemble(pI, *pListing);
                        }
                        if(SUCCEEDED(hr)){
                            hr = pListing->Append("\r\n");
                        }
                    }
                    float stall;
					StallType reason = eNone;

					stall = sim.CalculateFinalStall(reason);
					if(stall) {
						hr = pListing->Printf("/* Final Stall: %c %.2f */ \r\n", char(reason), stall);
					}

					if(usedreasons[0] == true) {
						pListing->Printf("\r\nStall Types:\r\n");
						for(i = 1; i < 255; i++) {
							if((i != ' ') && (usedreasons[i])) {
								pListing->Printf("%c: %s\r\n", i, StallDescription[i - 'A']);
							}
						}
						pListing->Printf("\r\n");
					}

                }
            }
        }

        DWORD postOptLength = ucode->length;
        float postOptCycles;
        if(SUCCEEDED(hr)){
            if(pListing ){


                if(optimize){
                    hr = EstimateCycles(shaderType, ucode, &postOptCycles);
                    double cpi = instructions ? 
                        ((float) postOptCycles) / (instructions ): 0.f;
                    if(SUCCEEDED(hr)){
                        int deltaLength = preOptLength - postOptLength;
                        float deltaCycles = preOptCycles - postOptCycles;
                        hr = pListing->Printf("//    microcode: %d slots, %g cycles, cpi = %g\r\n",
                            postOptLength, (float)(postOptCycles), cpi);  
                        if(SUCCEEDED(hr)) {
                            hr = pListing->Printf("// Optimization saved %d slots, %g cycles.\r\n",
                                deltaLength, (float)(deltaCycles));
                        }
                    }
                }
                else {
                    double cpi = instructions ? 
                        ((float) preOptCycles) / (instructions ) : 0.f;
                        hr = pListing->Printf("//    microcode: %d slots, %g cycles, cpi = %g\r\n",
                            preOptLength, (float)preOptCycles, cpi);    
                }

            }
        }
        if(SUCCEEDED(hr)){
            if(ucode->length > 136){
                char buf[256];
                sprintf(buf, "Too many microcode instructions: %d. Max is 136.",
                    ucode->length);
                pErrorLog->Log(true, ERROR_TOOMANYINSTRUCTIONS, NULL, 0, buf);
                SETERROR(hr, E_FAIL);
            }
        }
        if(SUCCEEDED(hr)){
            if(ucode->length){
                ucode->ucode[ucode->length-1].eos = 1; // Last instruction
            }
        }

        if(hr == E_OPTIMIZER_FAILED){
            pErrorLog->Log(true,ERROR_ASM_OPTIMIZER_INTERNAL_ERROR,NULL,1,"Internal vertex shader optimizer error. Disable optimizations and try again.");
            hr = E_FAIL; // E_OPTIMIZER_FAILED is an internal failure code, don't want it getting out.
        }
        if(hr == E_ASSEMBLER_FAILED){
            pErrorLog->Log(true,ERROR_ASM_INTERNAL_ASSEMBLER_ERROR,NULL,1,"Read from uninitialized register. Turn on validator and try again.");
            hr = E_FAIL; // E_ASSEMBLER_FAILED is an internal failure code, don't want it getting out.
        }

        return hr;
    }

    HRESULT CompileVertexShaderToUCode(bool optimize, bool globalOptimize, bool verifyOptimizer,
                                       DWORD shaderType,
                                 LPXGBUFFER pTokenizedShader, 
                                 LPXGBUFFER* ppCompiledShader,
                                 Buffer* pListing,
                                 XD3DXErrorLog* pErrorLog)
    {
        HRESULT hr = S_OK;

        D3DVertexShaderProgram* pUcode = new D3DVertexShaderProgram;
        if(!pUcode){
            SETERROR(hr,E_OUTOFMEMORY);
        }

        if(SUCCEEDED(hr)){
            if(!m_bInputMicrocode){
                DWORD* pTokens = (DWORD*) pTokenizedShader->GetBufferPointer();
                DWORD tokenCount = pTokenizedShader->GetBufferSize() / sizeof(DWORD);
				hr = D3DTokensToUCode(pTokens, pUcode, pErrorLog);
            }
        }


        if(SUCCEEDED(hr)){
            hr = InstructionsToMicrocode(optimize, globalOptimize, verifyOptimizer, shaderType,
                pUcode, pListing, pErrorLog);
        }



    #ifdef DBG_PRINT_OPTIMIZED
        Print(shaderType, *pUcode);
    #endif
        if(SUCCEEDED(hr)) {
            // Return the microcode in a buffer

            // Format of vertex shader microcode is (little endian):
            // Byte offset
            //   0..1   WORD - magic number describing type of shader:
            //                 0x2078 - ordinary vertex shader
            //                 0x7778 - read/write vertex shader
            //                 0x7378 - vertex state shader
            //   2..3   WORD - length of shader, in instructions, ranges from 1 to 136
            //   4..end the shader microcode.

            DWORD headerSize = sizeof(WORD) + sizeof(WORD);
            DWORD ucodeSize = sizeof(PaddedUCode) * pUcode->length;
            DWORD size = headerSize + ucodeSize;

            LPXGBUFFER pCompiledShader;
            hr = XGBufferCreate(size, &pCompiledShader);

            if(SUCCEEDED(hr)){
                unsigned char* pC = (unsigned char*) pCompiledShader->GetBufferPointer();
                static const char kShaderTypes[3][2]
                    = {{'x',' '}, // ordinary vertex shader
                       {'x','w'}, // read/write vertex shader
                       {'x','s'}  // vertex state shader
                    };
                int shaderTypeIndex = 0;
                int shaderTypeIgnoringScreenspace = SASMT_SHADERTYPE(shaderType);
                if(shaderTypeIgnoringScreenspace == SASMT_READWRITE_VERTEXSHADER){
                    shaderTypeIndex = 1;
                }
                if(shaderTypeIgnoringScreenspace == SASMT_VERTEXSTATESHADER){
                    shaderTypeIndex = 2;
                }
                const char* pHeader = kShaderTypes[shaderTypeIndex];
                memcpy(pC, pHeader, 2);
                WORD numInstructions = pUcode->length;

                memcpy(pC + 2, &numInstructions, sizeof(numInstructions));
                DWORD* pOutCode = (DWORD*) (pC + headerSize);
                const D3DVsInstruction* pI = pUcode->ucode;
                for(int i = 0; i < pUcode->length; i++, pI++){
                    *pOutCode++ = PGM_UWORDX(pI);
                    *pOutCode++ = PGM_UWORDY(pI);
                    *pOutCode++ = PGM_UWORDZ(pI);
                    *pOutCode++ = PGM_UWORDW(pI);
                }
                *ppCompiledShader = pCompiledShader;
            }
        }

        delete pUcode;

        return hr;
    }

    HRESULT CompileShaderToUCode(bool optimize, bool globalOptimize, bool verifyOptimizer,
                                 DWORD shaderType,
                                 LPXGBUFFER pTokenizedShader, 
                                 LPXGBUFFER* ppCompiledShader,
                                 Buffer* pListing,
                                 XD3DXErrorLog* pErrorLog)
    {
        ASSERT(pTokenizedShader || m_bInputMicrocode);
        ASSERT(ppCompiledShader);
        // OK, what kind of shader is this?
        if((shaderType & 0xff) == SASMT_PIXELSHADER){
            return CompilePixelShaderToUCode(optimize, shaderType, pTokenizedShader, ppCompiledShader, pListing, pErrorLog);
        }
        else {
            return CompileVertexShaderToUCode(optimize, globalOptimize, verifyOptimizer,
                shaderType, pTokenizedShader, ppCompiledShader, pListing, pErrorLog);
        }
    }

    HRESULT StripDebugInfo(LPXGBUFFER pBuffer){
        HRESULT hr = S_OK;

        // We strip the debug info out in-place, and fix up the
        // size of the pBuffer after the fact. We can get away with this because
        // it's a private API

        const DWORD* pSource = (const DWORD*) pBuffer->GetBufferPointer();
        const DWORD* pSrcEnd = (const DWORD*) ((char*) pBuffer->GetBufferPointer() 
            + pBuffer->GetBufferSize());
        DWORD* pDest = (DWORD*) pBuffer->GetBufferPointer();
        bool bDone = false;

        // header
        *pDest++ = *pSource++;

        while(pSource < pSrcEnd && !bDone){
            DWORD token = *pSource++;
            DWORD opCode = token & D3DSI_OPCODE_MASK;
            switch (opCode){
                // No operands, no result
                case D3DSIO_NOP:
                    *pDest++ = token;
                    break;
                    // One operand
                case D3DSIO_TEXCOORD:
                case D3DSIO_TEXKILL:
                case D3DSIO_TEX:
    #if 0 // Not on XBOX
                case D3DSIO_TEXREG2AB:
                case D3DSIO_TEXREG2GR:
    #endif
                    // One total args
                    *pDest++ = token;
                    *pDest++ = *pSource++;
                    break;
                // One operand, one result
                case D3DSIO_EXP:
                case D3DSIO_EXPP:
                case D3DSIO_FRC:
                case D3DSIO_LIT:
                case D3DSIO_LOG:
                case D3DSIO_LOGP:
                case D3DSIO_MOV:
                case D3DSIO_RCC:
                case D3DSIO_RCP:
                case D3DSIO_RSQ:

                // Two operands, no results
                case D3DSIO_TEXBEM:
                case D3DSIO_TEXBEML:
                case D3DSIO_TEXM3x2PAD:
                case D3DSIO_TEXM3x2TEX:
                case D3DSIO_TEXM3x3PAD:
                case D3DSIO_TEXM3x3TEX:
                case D3DSIO_TEXM3x3DIFF:
                case D3DSIO_TEXM3x3VSPEC:

                    // Two total args
                    *pDest++ = token;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    break;

                // Two operands, one result
                case D3DSIO_ADD:
                case D3DSIO_DP3:
                case D3DSIO_DP4:
                case D3DSIO_DPH:
                case D3DSIO_DST:
                case D3DSIO_M3x2:
                case D3DSIO_M3x3:
                case D3DSIO_M3x4:
                case D3DSIO_M4x3:
                case D3DSIO_M4x4:
                case D3DSIO_MAX:
                case D3DSIO_MIN:
                case D3DSIO_MUL:
                case D3DSIO_SGE:
                case D3DSIO_SLT:
                case D3DSIO_SUB:
                    // Three operends, no result
                case D3DSIO_TEXM3x3SPEC:
                    *pDest++ = token;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    break;
                // Three operands, one result
                case D3DSIO_CND:
                case D3DSIO_LRP:
                case D3DSIO_MAD:
                    *pDest++ = token;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    break;
                    // Six total args
                case D3DSIO_XDM: // Four ops, two results
                case D3DSIO_XDD: // Four ops, two results
                    *pDest++ = token;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    break;
                    // Seven total args
                case D3DSIO_XMMA: // Four ops, Three results
                case D3DSIO_XMMC: // Four ops, Three results
                case D3DSIO_XFC:  // Seven operands, zero results
                    *pDest++ = token;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    *pDest++ = *pSource++;
                    break;
                case D3DSIO_COMMENT:
                    {
                        DWORD numDWORDs = (token & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
                        pSource += numDWORDs;
                    }
                    break;
                case D3DSIO_END:
                    *pDest++ = token;
                    bDone = TRUE;
                    break;
                default:
                    // unhandled instruction
    #ifdef DBG
                    DPF2("Unknown opcode (%d)", token & D3DSI_OPCODE_MASK);
    #endif
                    DXGRIP("Unknown opcode");
                    break;
            }  // switch
        }

        pBuffer->size = ((char*) pDest) - (char*) pBuffer->GetBufferPointer();
        return hr;
    }

public:
    HRESULT WINAPI
    AssembleShader(
      LPCSTR pSourceFileName,
      LPCVOID pSrcData,
      UINT SrcDataLen,
      DWORD Flags,
      LPXGBUFFER* ppConstants,
      LPXGBUFFER* ppCompiledShader,
      LPXGBUFFER* ppErrorLog,
      LPXGBUFFER* ppListing,
      SASM_ResolverCallback pResolver,
      LPVOID pResolverUserData,
      LPDWORD pShaderType
      )
    {
        HRESULT hr = S_OK;

        static const char* kDefaultSourceFileName = "";

        if ( ! pSourceFileName ) {  // Simplifies developer's lives by handleing an empty file name.
            pSourceFileName = kDefaultSourceFileName;
        }
        m_pSourceFileName = pSourceFileName;
        m_pSrcData = pSrcData;
        m_SrcDataLen = SrcDataLen;
        
        bool debug = (Flags & SASM_DEBUG) != 0;
        bool optimize = (Flags & SASM_DONOTOPTIMIZE) == 0;
        bool verifyOptimizer = (Flags & SASM_VERIFY_OPTIMIZATIONS) != 0;
        bool globalOptimize = optimize && ((Flags & SASM_DISABLE_GLOBAL_OPTIMIZATIONS) == 0);
        bool validate = (Flags & SASM_SKIPVALIDATION) == 0;
        bool listing = ppListing != 0;
        bool inputTokens = 0 != (Flags & (SASM_INPUT_PIXELSHADER_TOKENS
                | SASM_INPUT_VERTEXSHADER_TOKENS
                | SASM_INPUT_READWRITE_VERTEXSHADER_TOKENS
                | SASM_INPUT_VERTEXSTATESHADER_TOKENS));
        m_bInputMicrocode = 0 != (Flags & (SASM_INPUT_MICROCODE
                | SASM_INPUT_SCREENSPACE_MICROCODE));
        bool outputShaderTokens = (Flags & SASM_OUTPUTTOKENS) != 0;
        bool preprocessOnly = (Flags & SASM_PREPROCESSONLY) != 0;
        bool skipPreprocessor = (Flags & SASM_SKIPPREPROCESSOR) != 0;
        bool isXboxShader = false;

        DWORD shaderType = 0;
        if(inputTokens){
            if((Flags & SASM_INPUT_PIXELSHADER_TOKENS) != 0){
                shaderType = SASMT_PIXELSHADER;
            }
            else if((Flags & SASM_INPUT_VERTEXSHADER_TOKENS) != 0){
                shaderType = SASMT_VERTEXSHADER;
            }
            else if((Flags & SASM_INPUT_READWRITE_VERTEXSHADER_TOKENS) != 0){
                shaderType = SASMT_READWRITE_VERTEXSHADER;
            }
            else if((Flags & SASM_INPUT_VERTEXSTATESHADER_TOKENS) != 0){
                shaderType = SASMT_VERTEXSTATESHADER;
            }
            if((Flags & SASM_INPUT_SCREENSPACE_VERTEXSHADER_TOKENS) != 0){
                shaderType |= SASMT_SCREENSPACE;
            }
            if((Flags & SASM_INPUT_NONXBOX_TOKENS) == 0){
                isXboxShader = true;
            }
        }
 
        m_bInputMicrocodeIsScreenSpace = false;
        if(m_bInputMicrocode){
            shaderType = SASMT_VERTEXSHADER;
            if((Flags & SASM_INPUT_SCREENSPACE_MICROCODE) != 0){
                m_bInputMicrocodeIsScreenSpace = true;
                shaderType |= SASMT_SCREENSPACE;
            }
            outputShaderTokens = false;
            validate = false;
            preprocessOnly = false;
            debug = false;
            skipPreprocessor = true;
        }

        // An error log
        MyErrorLog errorLog;
        hr = errorLog.Initialize(pSourceFileName);

        // Preprocessor
        LPXGBUFFER pPreProcessedSource = NULL;

        if(!(inputTokens || m_bInputMicrocode)){
            if ( skipPreprocessor ) {
                if(SUCCEEDED(hr)){
                    hr = XGBufferCreate(SrcDataLen, &pPreProcessedSource);
                    if(SUCCEEDED(hr)){
                        memcpy(pPreProcessedSource->GetBufferPointer(), pSrcData, SrcDataLen);
                    }
                }
            }
            else {
                XGBuffer inputHelper; // A dummy XGBuffer
                inputHelper.refCount = 5000; // To make sure nobody tries to delete it.
                inputHelper.pData = (LPVOID) pSrcData;
                inputHelper.size = SrcDataLen;

                if(SUCCEEDED(hr)){
                    hr = XGPreprocess(pSourceFileName,
                               pResolver,
                               pResolverUserData,
                               &inputHelper,
                               &pPreProcessedSource,
                               &errorLog);
                }
            }

            if(preprocessOnly){
                if(SUCCEEDED(hr)){
                    if(ppCompiledShader){
                        *ppCompiledShader = pPreProcessedSource;
                    }
                }
            }
        }

        // We will post-process the compiled code, to convert it from
        // opcodes to microcode. so pass in our own buffer to catch
        // the compiled code.
        
        LPXGBUFFER pTokenizedShader = 0;
        LPXGBUFFER* ppTokenizedShader = 0;
        if(!preprocessOnly){
            if( ppCompiledShader) {
                *ppCompiledShader = NULL;
                ppTokenizedShader = &pTokenizedShader;
            }

            if(SUCCEEDED(hr) && !(inputTokens||m_bInputMicrocode)){
                CD3DXAssembler assembler;
                DWORD dwFlags = 0;
                dwFlags |= 1; // Turn on debugging always. No specific constant for this
                hr = assembler.Assemble(pPreProcessedSource->GetBufferPointer(),
                    pPreProcessedSource->GetBufferSize(),
                    pSourceFileName, 0, dwFlags,
                    ppConstants, ppTokenizedShader, &errorLog, &shaderType);
                if(SUCCEEDED(hr)){
                    if(assembler.m_bScreenSpace){
                        shaderType |= SASMT_SCREENSPACE;
                    }
                    if(pShaderType){
                        *pShaderType = shaderType;
                    }
                    if(assembler.m_bXbox){
                        isXboxShader = true;
                    }
               }
            }

            if(SUCCEEDED(hr) && inputTokens){
                // Copy the input tokens to the output tokens
                ppTokenizedShader = &pTokenizedShader;
                hr = XGBufferCreate(SrcDataLen, ppTokenizedShader);
                if(SUCCEEDED(hr)){
                    memcpy((*ppTokenizedShader)->GetBufferPointer(), pSrcData, SrcDataLen);
                }
            }

#ifndef DISABLE_VALIDATOR
            if(SUCCEEDED(hr) && validate){
                if(SASMT_SHADERTYPE(shaderType) == SASMT_PIXELSHADER){
                    hr = ValidatePixelShader((DWORD*) pTokenizedShader->GetBufferPointer(),
                        NULL, 0, &errorLog);
                }
                else {
                    DWORD* pDeclaration = 0;
                    DWORD flags = 0;
                    if(isXboxShader) {
                        flags |= VSF_XBOXEXTENSIONS;
                    }
                    switch(SASMT_SHADERTYPE(shaderType)){
                    case SASMT_VERTEXSHADER:
                        // Nothing special
                        break;
                    case SASMT_READWRITE_VERTEXSHADER:
                        flags |= VSF_READWRITESHADER;
                        break;
                    case SASMT_VERTEXSTATESHADER:
                        flags |= VSF_READWRITESHADER | VSF_STATESHADER;
                        break;
                    default: DXGRIP("Unknown shader type.");
                        break;
                    }

                    hr = ValidateVertexShader((DWORD*) pTokenizedShader->GetBufferPointer(),
                        pDeclaration,
                        NULL, flags, &errorLog);
                }
            }
#endif // ndef DISABLE_VALIDATOR

            if(SUCCEEDED(hr) && outputShaderTokens && !debug){
                // Strip the debugging information out of the shader tokens.
                hr = StripDebugInfo(pTokenizedShader);
            }

            Buffer* pListBuffer = NULL;
            if(listing){
                pListBuffer = new Buffer;
                if ( ! pListBuffer ) {
                    SETERROR(hr, E_OUTOFMEMORY);
                }
                if(SUCCEEDED(hr)){
                    hr = pListBuffer->Initialize(20000);
                }
            }

            if(SUCCEEDED(hr) ){
                if(pListBuffer){
                    hr = pListBuffer->Printf("// Xbox Shader Assembler %s\r\n", VER_PRODUCTVERSION_STR);
                }
                if ( SUCCEEDED(hr) && pTokenizedShader && ppCompiledShader) {
                    if(SUCCEEDED(hr)){
                        if(outputShaderTokens){
                            if(ppCompiledShader){
                                *ppCompiledShader = pTokenizedShader;
                                pTokenizedShader->AddRef();
                            }
                            if(pListBuffer){
                                hr = ListD3DTokens(pListBuffer, (DWORD*) pTokenizedShader->GetBufferPointer(),
                                    pTokenizedShader->GetBufferSize() / sizeof(DWORD));
                            }
                        }
                    }
                }
            }

            if(SUCCEEDED(hr) && !outputShaderTokens){
                hr = CompileShaderToUCode(optimize, globalOptimize, verifyOptimizer, shaderType, pTokenizedShader, ppCompiledShader,
                    pListBuffer, &errorLog );
            }

            RELEASE(pPreProcessedSource);
            RELEASE(pTokenizedShader);

            if(SUCCEEDED(hr) && ppListing){
                hr = XGBufferCreateFromBuffer(pListBuffer, ppListing);
            }
            delete pListBuffer;
        }

        // We always want to create the error log, even if there's already an error.
        if(ppErrorLog) {
            HRESULT hr2 = XGBufferCreateFromBuffer(errorLog.m_buffer, ppErrorLog);
            if(SUCCEEDED(hr)){ // If we failed, and we aren't in an error state, report it.
                hr = hr2;      
            }
        }

        return hr;
    }
private:
    bool m_bInputMicrocode;
    bool m_bInputMicrocodeIsScreenSpace;
    LPCSTR m_pSourceFileName;
    LPCVOID m_pSrcData;
    UINT m_SrcDataLen;
};

extern "C" 
HRESULT WINAPI
XGAssembleShader(
  LPCSTR pSourceFileName,
  LPCVOID pSrcData,
  UINT SrcDataLen,
  DWORD Flags,
  LPXGBUFFER* ppConstants,
  LPXGBUFFER* ppCompiledShader,
  LPXGBUFFER* ppErrorLog,
  LPXGBUFFER* ppListing,
  SASM_ResolverCallback pResolver,
  LPVOID pResolverUserData,
  LPDWORD pShaderType
  )
{
    Assembler a;
    return a.AssembleShader(pSourceFileName, pSrcData, SrcDataLen, Flags,
        ppConstants, ppCompiledShader, ppErrorLog, ppListing, pResolver,
        pResolverUserData, pShaderType);
}

extern "C"
DWORD WINAPI XGSUCode_GetVertexShaderType(LPCVOID pMicrocode ){
    DWORD shaderType;
    WORD cookie = *(const WORD*) pMicrocode;
    switch(cookie){
    case 0x2078: // ordinary vertex shader
        shaderType = SASMT_VERTEXSHADER;
        break;
    case 0x7778: // read/write vertex shader
        shaderType = SASMT_READWRITE_VERTEXSHADER;
        break;
    case 0x7378: // vertex state shader
        shaderType = SASMT_VERTEXSTATESHADER;
        break;
    default:
        shaderType = SASMT_INVALIDSHADER;
        break;
    }
    return shaderType;
}

extern "C"
DWORD WINAPI XGSUCode_GetVertexShaderLength(LPCVOID pMicrocode ){
    return *(const WORD*) (((const UCHAR*) pMicrocode) + 2);
}

extern "C"
HRESULT WINAPI XGSUCode_CompareVertexShaders(LPCVOID pMicrocodeA, LPCVOID pMicrocodeB,
                                             LPXGBUFFER* ppErrorLog){
    HRESULT hr = S_OK;
    MyErrorLog errorLog;    
    D3DVertexShaderProgram* pA = 0;
    D3DVertexShaderProgram* pB = 0;

    hr = errorLog.Initialize("");
    if(SUCCEEDED(hr)){
        pA = new D3DVertexShaderProgram;
        if(!pA){
            hr = E_OUTOFMEMORY;
        }
    }
    if(SUCCEEDED(hr)){
        pB = new D3DVertexShaderProgram;
        if(!pB){
            hr = E_OUTOFMEMORY;
        }
    }
    DWORD shaderTypeA;
    DWORD shaderTypeB;
    if(SUCCEEDED(hr)){
        hr = Assembler::ConvertMicrocodeToVsInstructions(true, XGSUCode_GetVertexShaderLength(pMicrocodeA),
            pMicrocodeA, pA, &shaderTypeA, &errorLog);
    }
    if(SUCCEEDED(hr)){
        hr = Assembler::ConvertMicrocodeToVsInstructions(true, XGSUCode_GetVertexShaderLength(pMicrocodeA),
            pMicrocodeA, pA, &shaderTypeB, &errorLog);
    }
    if(SUCCEEDED(hr)){
        if(shaderTypeA != shaderTypeB){
            errorLog.Log(true, 0,0,0, "The two shaders are of different types.");
            hr = E_FAIL;
        }
    }
    if(SUCCEEDED(hr)){
        bool result = Verify(pA, pB, &errorLog);
        if(!result){
            hr = E_FAIL;
        }
    }
    // We always want to create the error log, even if there's already an error.
    if(ppErrorLog) {
        HRESULT hr2 = XGBufferCreateFromBuffer(errorLog.m_buffer, ppErrorLog);
        if(SUCCEEDED(hr)){ // If we failed, and we aren't in an error state, report it.
            hr = hr2;      
        }
    }
    delete pB;
    delete pA;
    return hr;

}

DWORD BASE_REG(DWORD type)
{
    switch (type  & D3DSP_REGTYPE_MASK)
    {
    case D3DSPR_INPUT:
        return REG_V0;
    case D3DSPR_RASTOUT:
        if ((type & D3DSP_REGNUM_MASK )==0) {
            return REG_O0;
        } else {
            return REG_O4;
        }
    case D3DSPR_ATTROUT:
        if(type & 0x100){
            return REG_oB0;
        }
        return REG_oD0; 
    case D3DSPR_TEXCRDOUT:
        return REG_oT0; 
    case D3DSPR_ADDR:
        return REG_ARL;
    case D3DSPR_CONST:
        return REG_C0;
    case D3DSPR_TEMP:
        return REG_R0;
    default:
        return REG_ZER; //unused register enumeration
    }
}

//re-number a dx8-style constant register number (-96 to 95) to the gpu's registers: 0 to 95
//question: wouldn't it just be easier to just always add 96? is there a case where that wouldn't work?
int MapDX8ToUcode(DWORD reg){
    if(reg <= 95){
        reg += 96;
    }
    else {
        reg = 96 - (0xfff & (~reg + 1));
    }
    return reg;
}

//input: D3d token. Output: enumerated register number
Register_t GetEnumeratedReg(DWORD token) 
{
    DWORD final;
    if ((token & D3DSP_REGTYPE_MASK) == D3DSPR_RASTOUT) {
        // psz, fog, pts
        if ((token & D3DSP_REGNUM_MASK) == 0) {
            final = REG_O0;
        } else {
            final = REG_O4;
        }
        final += (DWORD)(token & D3DSP_REGNUM_MASK);
    } else {
        // everything else
        final = BASE_REG(token);
		if(1) { // ! (token & D3DVS_ADDRESSMODE_MASK) ){
            if( final == REG_C0){
			    final += (DWORD)MapDX8ToUcode((token & D3DSP_REGNUM_MASK));
            }
            else {
                if(final == REG_oB0){ // We use 0x100 as a flag, so mask it off
                    final += (DWORD)(token & 0x01);
                }
                else {
                    final += (DWORD)(token & D3DSP_REGNUM_MASK);
                }
            }
		}
	}
    return (Register_t)final;
}

//return true if the input (which contains something from the register enumeration is of the approprate type of registers)
bool IsTempReg(Register_t reg) {
	return reg >= REG_R0 && reg <= REG_R15;
}
bool IsConstantReg(Register_t reg) {
	return reg >= REG_C0 && reg <= REG_C95 + 96;
}
bool IsInputReg(Register_t reg) {
	return reg >= REG_V0 && reg <= REG_V15;
}
bool IsOutputReg(Register_t reg) {
	return reg >= REG_O0 && reg <= REG_O15;
}

//mark as used the appropriate components of temporary registers (r0, etc)
void MarkAsUsed(DWORD token, char * pHasBeenWritten) {
	if(IsTempReg(GetEnumeratedReg(token))) {
		pHasBeenWritten[token & D3DSP_REGNUM_MASK] |= (token & D3DSP_WRITEMASK_ALL) >> 16;
	}
}

//return true if Y has been used. "c" is an element from the array passed to MarkAsUsed above
bool HasYBeenUsed(char c) {
	return (c & (D3DSP_WRITEMASK_1 >> 16))? true : false;
}
bool HasZBeenUsed(char c) {
	return (c & (D3DSP_WRITEMASK_2 >> 16))? true : false;
}

//return true if the instruction is a Scalar ILU instruction (something that reads from only .x / .w)
bool IsScalarIluInstruction(int inst) {
	switch(inst) {
	case ILU_RCP:
	case ILU_RCC:
	case ILU_RSQ:
	case ILU_EXP:
	case ILU_LOG:
		return true;
	default: 
		return false;
	}

}

//this + TempTokens is used to deal with the ugly macros, like m3x4 and frc
#define TOKEN_RETURN 0xFFFD

//convert d3d tokens to semi-final vertex shader code
//input: pTokens, pErrorLog.   Output: pProg, pErrorLog
HRESULT D3DTokensToUCode (const DWORD* pTokens, D3DVertexShaderProgram* pProg, XD3DXErrorLog* pErrorLog)
{
	char bHasBeenWritten[12] = {0};

	pTokens++;

	HRESULT hr= S_OK;
	if (!pTokens || !pProg) return E_POINTER;

	int i = 0; //index into instructions
	D3DVsInstruction* inst;
	D3DVsInstruction* lastinst = &pProg->ucode[0];

	int inputs = 0;
	int outputs = 0;

	//initially clean up the program's instructions in case we forget something later...
	memset(pProg->ucode, 0, sizeof(pProg->ucode));
	bool bDone = false;
	bool bPair;

	DWORD TempTokens[33]; //used to build new d3d tokens from the macro instructions (D3DSIO_M3x2, FRC, etc)

	//holds the line number and file name of the source of each d3d token
	DWORD       dwLineNumber = 0;
	const char* pFileName = 0;

	//start parsing!
	while(!bDone) {
		bPair =		false;

		outputs = 0;
		//inst points to current VsInstruction 
		inst = &pProg->ucode[i];

			inst->mac = MAC_NOP;
			inst->ilu = ILU_NOP;
			inst->ca  = 0;
			inst->va  = 0;
			inst->ane = 0;
			inst->axs = CSW_X;
			inst->ays = CSW_Y;
			inst->azs = CSW_Z;
			inst->aws = CSW_W;
			inst->amx = MX_V;
			inst->arr = 0;
			inst->bne = 0;
			inst->bxs = CSW_X;
			inst->bys = CSW_Y;
			inst->bzs = CSW_Z;
			inst->bws = CSW_W;
			inst->bmx = MX_V;
			inst->brr = 0;
			inst->cne = 0;
			inst->cxs = CSW_X;
			inst->cys = CSW_Y;
			inst->czs = CSW_Z;
			inst->cws = CSW_W;
			inst->cmx = MX_V;
			inst->crr = 0;
			inst->rw  = 7;      //r7
			inst->rwm = 0;
			inst->oc  = 0x1ff;
			inst->om  = OM_MAC;
			inst->eos = 0;
			inst->cin = 0;
			inst->swm = 0;
			inst->owm = 0; 


		if(*pTokens & D3DSI_COISSUE) {
			bPair = true; //paired at the end of this loop
		}

		int iRepeat = 0; //used in matrix macro instructions - holds the number of times to repeat the dp? instruction
		DWORD op = 0;	 //used in matrix macro instructions - holds the appropriate dp? instruction to generate

		//get instruction...
		switch (pTokens[0] & D3DSI_OPCODE_MASK) 
		{
		case D3DSIO_MOV: 
			inputs = 1;
			if(((pTokens[1] & D3DSP_REGTYPE_MASK) == D3DSPR_ADDR) && ((pTokens[1]&D3DSP_REGNUM_MASK) == 0)) {
				inst->mac = MAC_ARL; 
				outputs = 3;
			} else {
				inst->mac = MAC_MOV; 
				outputs = 1;
			}
			break;
		case D3DSIO_NOP: inst->mac = MAC_NOP; outputs = 0; inputs = 0; break;
		case D3DSIO_ADD: inst->mac = MAC_ADD; outputs = 1; inputs = 5; break;
		case D3DSIO_SUB: inst->mac = MAC_ADD; outputs = 1; inputs = 5; inst->cne = true; break;
		case D3DSIO_MAD: inst->mac = MAC_MAD; outputs = 1; inputs = 7; break;
		case D3DSIO_MUL: inst->mac = MAC_MUL; outputs = 1; inputs = 3; break;
		case D3DSIO_MAX: inst->mac = MAC_MAX; outputs = 1; inputs = 3; break;
		case D3DSIO_MIN: inst->mac = MAC_MIN; outputs = 1; inputs = 3; break;
		case D3DSIO_SGE: inst->mac = MAC_SGE; outputs = 1; inputs = 3; break;
		case D3DSIO_SLT: inst->mac = MAC_SLT; outputs = 1; inputs = 3; break;
		case D3DSIO_DP3: inst->mac = MAC_DP3; outputs = 1; inputs = 3; break;
		case D3DSIO_DP4: inst->mac = MAC_DP4; outputs = 1; inputs = 3; break;
		case D3DSIO_DPH: inst->mac = MAC_DPH; outputs = 1; inputs = 3; break;
		case D3DSIO_DST: inst->mac = MAC_DST; outputs = 1; inputs = 3; break;

		case D3DSIO_RCP : inst->ilu = ILU_RCP; outputs = 2; inputs = 4; break;
		case D3DSIO_RCC : inst->ilu = ILU_RCC; outputs = 2; inputs = 4; break;
		case D3DSIO_RSQ : inst->ilu = ILU_RSQ; outputs = 2; inputs = 4; break;
		case D3DSIO_EXPP: inst->ilu = ILU_EXP; outputs = 2; inputs = 4; break;
		case D3DSIO_LOGP: inst->ilu = ILU_LOG; outputs = 2; inputs = 4; break;
		case D3DSIO_LIT : inst->ilu = ILU_LIT; outputs = 2; inputs = 4; break;

		//careful: don't switch the order of these matrix macro tokens within this switch statement!
		case D3DSIO_M4x4:
			if(!op) op = D3DSIO_DP4;
			//fall through
		case D3DSIO_M3x4:
			if(!op) op = D3DSIO_DP3;
			iRepeat++; 
			//fall through
		case D3DSIO_M4x3:
			if(!op) op = D3DSIO_DP4;
			//fall through
		case D3DSIO_M3x3:
			if(!op) op = D3DSIO_DP3;
			iRepeat++; 
			//fall through
		case D3DSIO_M3x2:
			if(!op) op = D3DSIO_DP3;
			iRepeat += 2; 
			{
				int iT = 0;
				iT++; //version

				for(int j = 0; j < iRepeat; j++) {
					TempTokens[iT++] = op; //dp*

					if(!(pTokens[1] & (~D3DSP_WRITEMASK_ALL | (D3DSP_WRITEMASK_0 << j)))) {
						iT--;
						continue;
					} else {
						//output, masked appropriately (.x in first instruction, .y in second, .z in third, etc)
						TempTokens[iT++] = pTokens[1] & (~D3DSP_WRITEMASK_ALL | (D3DSP_WRITEMASK_0 << j));
					}

					//input 1 stays the same...
					TempTokens[iT++] = pTokens[2];

					//input 2 gets the register number incremened. (Mask is 0xfff, any overflow is handled later) 
					TempTokens[iT++] = pTokens[3] + j;
					if(((pTokens[3] + j + 96) & 0xff) >= 192) {
						pErrorLog->Log(true, ERROR_ASM_INVALID_REGISTER, pFileName, dwLineNumber, "matrix macro expands to use out-of-range constant register (c96, etc)");
					}

				}
				TempTokens[iT++] = TOKEN_RETURN;

				D3DVertexShaderProgram TempProg;

				//call recursively. 
				//This call will process the 2-4 DP* instructions just produced, then return
				D3DTokensToUCode(TempTokens, &TempProg, pErrorLog);
				//copy newly formed instructions to the real VsInstructions array
				for(j = 0; j < iRepeat; j++) {
					pProg->ucode[i + j] = TempProg.ucode[j];
				}

				MarkAsUsed(pTokens[1], bHasBeenWritten);
			}

			i += iRepeat;
			pTokens += 4;
			continue;

		//exp and log macros
		case D3DSIO_EXP :
		case D3DSIO_LOG : 
			{
				if ((pTokens[0] & D3DSI_OPCODE_MASK) == D3DSIO_EXP) {
					pErrorLog->Log(false, WARNING_UNSUPPORTEDMACRO, pFileName, dwLineNumber, "Xbox's EXP macro is no more accurate than EXPP, and it is slower. Consider just using EXPP, or writing your own implementation if you need greater accuracy.");
				} else {
					pErrorLog->Log(false, WARNING_UNSUPPORTEDMACRO, pFileName, dwLineNumber, "Xbox's LOG macro is no more accurate than LOGP, and it is slower. Consider just using LOGP, or writing your own implementation if you need greater accuracy.");
				}

				//produce: 
				//	expp temp.z, input
				//	mov out.mask, temp.zzzz		

				MarkAsUsed(pTokens[1], bHasBeenWritten);
					
				int temp;
				for(temp = 0; temp < 12; temp++) {
					if(!HasZBeenUsed(bHasBeenWritten[temp])) break;
				}
				if(temp == 12) {
					pErrorLog->Log(true, ERROR_NOTEMPORARYREGISERAVAILABLE,
                        pFileName, dwLineNumber, "No temporary register available for EXP / LOG macro.");
                    return E_FAIL;			
				}
				int iT = 0;
				iT++; //header

				TempTokens[iT++] = (pTokens[0] & D3DSI_OPCODE_MASK) == D3DSIO_EXP ? D3DSIO_EXPP : D3DSIO_LOGP; 
				TempTokens[iT++] = D3DSPR_TEMP | temp | D3DSP_WRITEMASK_2;
				TempTokens[iT++] = pTokens[2];
				
				TempTokens[iT++] = D3DSIO_MOV;
				TempTokens[iT++] = pTokens[1];
				TempTokens[iT++] = D3DSPR_TEMP | temp | D3DVS_X_Z | D3DVS_Y_Z | D3DVS_Z_Z | D3DVS_W_Z;

				TempTokens[iT++] = TOKEN_RETURN;
				D3DVertexShaderProgram TempProg;

				D3DTokensToUCode(TempTokens, &TempProg, pErrorLog);
				//copy instructions created back to the real VsInstructions array
				for(int j = 0; j < 2; j++) {
					pProg->ucode[i + j] = TempProg.ucode[j];
				}

				i += 2;
				pTokens += 3;
				continue;

			}
		//frc macro
		case D3DSIO_FRC :
			{
				MarkAsUsed(pTokens[1], bHasBeenWritten);
					
				int temp;
				for(temp = 0; temp < 12; temp++) {
					if(!HasYBeenUsed(bHasBeenWritten[temp])) break;
				}
				if(temp == 12) {
					pErrorLog->Log(true, ERROR_NOTEMPORARYREGISERAVAILABLE,
                        pFileName, dwLineNumber, "No temporary register available for FRC macro.");
                    return E_FAIL;			
				}
				
				//.xy case:
				//  expp temp.y, input.x
				//  expp out.y, input.y
				//  mov out.x, temp.y

				//.y case:
				//  expp out.y, input.y

				if((!(pTokens[1] & D3DSP_WRITEMASK_1)) || (pTokens[1] & (D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3))) {
	                pErrorLog->Log(true, ERROR_ASM_INVALID_WRITE_MASK, pFileName,dwLineNumber, "FRC: only valid outputs masks are .xy or .y");
					return E_FAIL;
				}

				int iT = 0;
				int NumInstructions;

				iT++; //version?

				if (!(pTokens[1] & D3DSP_WRITEMASK_0)) {
					NumInstructions = 1;
					TempTokens[iT++] = D3DSIO_EXPP;
					TempTokens[iT++] = pTokens[1];
					int swy = (pTokens[2] & (3 << (D3DVS_SWIZZLE_SHIFT + 2))) >> 2;
					TempTokens[iT++] = (pTokens[2] & ~D3DVS_SWIZZLE_MASK) | (swy) | (swy << 2) | (swy << 4) | (swy << 6);
				} else {
					NumInstructions = 3;
					//we're doing .xy. Build the appropriate instructions.
					TempTokens[iT++] = D3DSIO_EXPP; 
					TempTokens[iT++] = D3DSPR_TEMP | temp | D3DSP_WRITEMASK_1;
					int swx = (pTokens[2] & (3 << (D3DVS_SWIZZLE_SHIFT)));
					TempTokens[iT++] = (pTokens[2] & ~D3DVS_SWIZZLE_MASK) | (swx) | (swx << 2) | (swx << 4) | (swx << 6);

					TempTokens[iT++] = D3DSIO_EXPP;
					TempTokens[iT++] = (pTokens[1] & (~D3DSP_WRITEMASK_ALL)) | D3DSP_WRITEMASK_1;
					int swy = (pTokens[2] & (3 << (D3DVS_SWIZZLE_SHIFT + 2))) >> 2;
					TempTokens[iT++] = (pTokens[2] & ~D3DVS_SWIZZLE_MASK) | (swy) | (swy << 2) | (swy << 4) | (swy << 6);

					TempTokens[iT++] = D3DSIO_MOV;
					TempTokens[iT++] = (pTokens[1] & (~D3DSP_WRITEMASK_ALL)) | D3DSP_WRITEMASK_0;
					TempTokens[iT++] = D3DSPR_TEMP | temp | D3DVS_X_Y | D3DVS_Y_Y | D3DVS_Z_Y | D3DVS_W_Y;
				}

				TempTokens[iT++] = TOKEN_RETURN;

				//recursively call this function, passing the four instructions we just built:
				//expp, expp, mov, return.
				//when it hits the return, we just need to increment things appropraitely.
				D3DVertexShaderProgram TempProg;

				D3DTokensToUCode(TempTokens, &TempProg, pErrorLog);
				//copy instructions created back to the real VsInstructions array
				for(int j = 0; j < NumInstructions; j++) {
					pProg->ucode[i + j] = TempProg.ucode[j];
				}

				i += NumInstructions;
				pTokens += 3;
				continue;

			}

		//token comments: we can extract the file name and line number from these
		case D3DSIO_COMMENT:
			{
				const DWORD* pComment = &pTokens[1];
				switch(*(pComment++))
				{
				case MAKEFOURCC('F','I','L','E'):
	                pFileName = (const char*)pComment;
					break;
				case MAKEFOURCC('L','I','N','E'):
	                dwLineNumber = *pComment;
					break;
				}
	
				pTokens += 1 + ((pTokens[0] & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT);
				continue;
			}

		//this is used to return from a recursive call to this function by the macro tokens, like M4x4
		case TOKEN_RETURN:
			return -7; //return an arbitrary number to make compiler happy

		//used to mark the end of d3d vertex shader tokens
		case D3DSIO_END:

			bDone = true;
			pProg->length = i;
			continue; //break to beginning of loop - we're done!
		}


		pTokens++; //if there is output, then this points to the output token... otherwise, input or next instruction

		//outputs == 0: an instruction like NOP that performs no output
		//outputs == 1: a MAC instruction
		//outputs == 2: an ILU instruction
		//outputs == 3: ARL (mov a0.x), which doesn't do traditional output in the hardware, though d3d tokens think it does
		if(outputs == 3) {
			pTokens++;   //we already parsed the output token above, so ignore it now...
			outputs = 0; 
		} 

		if(outputs) {
			DWORD token = *pTokens;

			Register_t t = GetEnumeratedReg(*pTokens);
			if(IsTempReg(t)) {
				MarkAsUsed(pTokens[0], bHasBeenWritten);
				inst->rw = t - REG_R0;
				int mask = (token & D3DSP_WRITEMASK_ALL) >> 16;
				int mask2 = ((mask & 1) << 3) | ((mask & 2) << 1) | ((mask & 4) >> 1) | ((mask & 8) >> 3);
				if(outputs == 1) {
					inst->rwm = mask2;
				} else {
					inst->swm = mask2;
				}
			} else {
				int mask = (token & D3DSP_WRITEMASK_ALL) >> 16;
				int mask2 = ((mask & 1) << 3) | ((mask & 2) << 1) | ((mask & 4) >> 1) | ((mask & 8) >> 3);
				inst->owm = mask2;
				inst->om = outputs - 1; //set output mux to 0 for MAC instruction, 1 for ILU
				if(IsConstantReg(t)) {
					inst->oc = t - REG_C0;
					if(token & D3DVS_ADDRESSMODE_MASK) inst->cin = true;
				} else {
					inst->oc = 0x100 | (t - REG_O0);
				}
			}

			pTokens++;
		}

	//parse input
		DWORD token = *pTokens;

		//if input uses A
		if(inputs & 1) {
			token = *pTokens;
			Register_t t = GetEnumeratedReg(token);

			//set A mux to pick the right input
			if(IsTempReg(t)) {
				inst->amx = 1;
				inst->arr = t - REG_R0;
			} else if (IsConstantReg(t)) {
				if(token & D3DVS_ADDRESSMODE_MASK) {
					inst->cin = true;
				}
				inst->amx = 3;
				inst->ca = t - REG_C0;
			} else /* if (IsInputReg(t)) */ {
				inst->amx = 2;
				inst->va = t - REG_V0;
			}

			//negated?
			inst->ane = (((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT) ? true : false);

			//swizzle
			inst->aws = (token >> (D3DVS_SWIZZLE_SHIFT + 6)) & 3;
			inst->azs = (token >> (D3DVS_SWIZZLE_SHIFT + 4)) & 3;
			inst->ays = (token >> (D3DVS_SWIZZLE_SHIFT + 2)) & 3;
			inst->axs = (token >> (D3DVS_SWIZZLE_SHIFT + 0)) & 3;

			pTokens++;
		} else {
			inst->amx = 2; //read from v0
		}
		
		//if input uses B
		if(inputs & 2) {
			token = *pTokens;
			Register_t t = GetEnumeratedReg(token);

			//set B mux to pick the right input
			if(IsTempReg(t)) {
				inst->bmx = 1;
				inst->brr = t - REG_R0;
			} else if (IsConstantReg(t)) {
				if(token & D3DVS_ADDRESSMODE_MASK) {
					inst->cin = true;
				}
				inst->bmx = 3;
				inst->ca = t - REG_C0;
			} else /* if (IsInputReg(t)) */ {
				inst->bmx = 2;
				inst->va = t - REG_V0;
			}

			//negated?
			inst->bne = (((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT) ? true : false);

			//swizzle
			inst->bws = (token >> (D3DVS_SWIZZLE_SHIFT + 6)) & 3;
			inst->bzs = (token >> (D3DVS_SWIZZLE_SHIFT + 4)) & 3;
			inst->bys = (token >> (D3DVS_SWIZZLE_SHIFT + 2)) & 3;
			inst->bxs = (token >> (D3DVS_SWIZZLE_SHIFT + 0)) & 3;

			pTokens++;
		} else {
			inst->bmx = 2; //read from v0
		}

		//if input uses C
		if(inputs & 4) {
			token = *pTokens;
			Register_t t = GetEnumeratedReg(token);

			//set C mux to pick the right input
			if(IsTempReg(t)) {
				inst->cmx = 1;
				inst->crr = t - REG_R0;
			} else if (IsConstantReg(t)) {
				if(token & D3DVS_ADDRESSMODE_MASK) {
					inst->cin = true;
				}
				inst->cmx = 3;
				inst->ca = t - REG_C0;
			} else /* if (IsInputReg(t)) */ {
				inst->cmx = 2;
				inst->va = t - REG_V0;
			}

			//negated? (^= is used to accomidate the SUB instruction)
			inst->cne ^= (((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT) ? true : false);


			//swizzle
			if(IsScalarIluInstruction(inst->ilu)) {
				inst->cws = (token >> (D3DVS_SWIZZLE_SHIFT + 6)) & 3; //grab from w
				inst->czs = (token >> (D3DVS_SWIZZLE_SHIFT + 6)) & 3;
				inst->cys = (token >> (D3DVS_SWIZZLE_SHIFT + 6)) & 3;
				inst->cxs = (token >> (D3DVS_SWIZZLE_SHIFT + 6)) & 3;
			} else {
				inst->cws = (token >> (D3DVS_SWIZZLE_SHIFT + 6)) & 3;
				inst->czs = (token >> (D3DVS_SWIZZLE_SHIFT + 4)) & 3;
				inst->cys = (token >> (D3DVS_SWIZZLE_SHIFT + 2)) & 3;
				inst->cxs = (token >> (D3DVS_SWIZZLE_SHIFT + 0)) & 3;
			}

			pTokens++;
		} else {
			inst->cmx = 2; //read from v0
		}

		//if we were supposed to pair this instruction with the previous one
		if(bPair){
            if(i == 0){
                pErrorLog->Log(true, ERROR_ASM_INVALID_INSTRUCTION_COMBINATION,
                    pFileName,dwLineNumber, "Can't pair first instruction.");
                hr = E_FAIL;
            }
            else {
                D3DVsInstruction pair;
                DWORD reason = 0;
				//try to force the two instructions to pair
                if(ForcedPair(&pair, &pProg->ucode[i-1], &pProg->ucode[i], &reason)){
                    pProg->ucode[i-1] = pair;
                    i--;
                }
                else {
                    const char* kReasons[] = {"Invalid instruction combination. Opcodes can't be combined.",
                        "Invalid instruction combination. Inputs can't be combined.",
                        "Invalid instruction combination. Input swizzles can't be combined.",
                        "Invalid instruction combination. Outputs can't be combined.",
                        "Invalid instruction combination."
                    };
                    int reasonIndex = reason - ERROR_ASM_CANT_PAIR_OPCODES;
                    if(reasonIndex < 0 || reasonIndex > 4) {
                        reasonIndex = 4;
                    }
                    pErrorLog->Log(true, reason, pFileName,dwLineNumber, kReasons[reasonIndex]);
                    hr = E_FAIL;
                }
            }
        }

		//move to next instruction
		lastinst = inst;
		i++;

	}; //END token will break out

	return hr; 
}


//splice together shaders in the ppShaderArray, return it in *pNewShader.
//return value will be S_OK unless out of memory, or S_FALSE if *pcbNewShaderBufferSize is too small
extern "C" 
HRESULT WINAPI XGSpliceVertexShaders (
/*				OUT  */ DWORD*   pNewShader,			  //pointer to buffer to fill with output
/*	OPTIONAL IN OUT  */ DWORD*   pcbNewShaderBufferSize, //How many bytes long the shader buffer is
/* 	OPTIONAL	OUT  */ DWORD*   pNewInstructionCount,   //how many instrucitons are in the newly-spliced shader
/*      IN*/ CONST DWORD* CONST* ppShaderArray,          //arrray of pointers to shaders to splice together
/*			 IN      */ DWORD    NumShaders,             //num of shaders in ppShaderArray
/*			 IN      */ BOOL     bOptimizeResults        //TRUE to optimize, FALSE to not optimize
)
{
	DWORD i;     //shader index
	int d = 1; //index into pNewShader. (start after the header)
	DWORD InstructionCount = 0;
	HRESULT hr = S_OK;

	if(DBG_CHECK(1)) {
		DWORD i = 0;
		if(NumShaders <= 0) {
			DXGRIP("XGSpliceVertexShaders: Must provide at least 1 shader to splice");
		}
		if(!ppShaderArray) {
			DXGRIP("XGSpliceVertexShaders: ppShaderArray must not be NULL");
		}

		for(i = 0; i < NumShaders; i++) {
			if(!ppShaderArray[i]) {
				DXGRIP("XGSpliceVertexShaders: one of the shader pointers is NULL!");
			}
			if(ppShaderArray[i] == pNewShader && i != 0) {
				DXGRIP("XGSpliceVertexShaders: destination shader may not be used as one of the source shaders, except the first");
			}
		}
		WORD ShaderType = *(WORD*)(ppShaderArray[0]);
		if(ShaderType != 0x2078 && ShaderType != 0x7778 && ShaderType != 0x7378) {
			DXGRIP("XGSpliceVertexShaders: Unknown Shader Type. Uninitialized data? did assembly fail?");
		}
		for(i = 0; i < NumShaders; i++) {
			if(*(WORD*)ppShaderArray[i] != ShaderType) {
				DXGRIP("XGSpliceVertexShaders: two or more source shaders are of different types");
			}
		}
	}

	if(pcbNewShaderBufferSize != NULL) {
		DWORD ByteCount = 4;
		for(i = 0; i < NumShaders; i++) {
			ByteCount += 16 * ((WORD*)(ppShaderArray[i]))[1];
		}
		if(ByteCount > *pcbNewShaderBufferSize) {
			*pcbNewShaderBufferSize = ByteCount;
			return S_FALSE;
		}
	}

	if(DBG_CHECK(pNewShader == NULL)) {
		if(pcbNewShaderBufferSize == NULL) {
			DXGRIP("XGSpliceVertexShaders: if pNewShader is NULL, pcbNewShaderBufferSize can't be. Both are NULL.");
		} else {
			DXGRIP("XGSpliceVertexShaders: pNewShader is NULL, but pcbNewShaderBufferSize is pointing to a valid buffer size");
		}
	}

	WORD OldHeader = (WORD)ppShaderArray[0][0]; //store the type info of the shader

	for(i = 0; i < NumShaders; i++) {
		WORD NumInstructions = ((WORD*)(ppShaderArray[i]))[1]; //extract the size: The second WORD of the header
		memcpy(&pNewShader[d], &ppShaderArray[i][1], NumInstructions * 16); //copy instructions, start reading after the header
		d += NumInstructions * 4; //4 == sizeof(instruction) / sizeof(DWORD)
		InstructionCount += NumInstructions;
		pNewShader[d-1] &= ~0x00000001; //clear "end-of-shader" flag
		if(DBG_CHECK(((InstructionCount > 136) && !bOptimizeResults) || (InstructionCount > 272))) {
			DXGRIP("XGSpliceVertexShaders: Resulting vertex shader is too large! Must be <= 136 instructions");
		}
	}


#ifdef DBG_SPLICER
	HANDLE hPre = CreateFile("t:\\pre.xvu", GENERIC_WRITE |GENERIC_READ,0,0,CREATE_ALWAYS,0,0);
	HANDLE hPost = CreateFile("t:\\Post.xvu", GENERIC_WRITE |GENERIC_READ,0,0,CREATE_ALWAYS,0,0);
	DWORD blah;
	WriteFile(hPre, pNewShader, d*4, &blah,0);
#endif

	if(bOptimizeResults) {
		//get the shader into D3DVertexShaderProgram format: remove spacer dword and reorder the bits appropriately
		for(i = 0; i < InstructionCount; i++) {
			//note: ins is required, since when i == 0, 1, or 2, input overlaps output.
			D3DVsInstruction ins;
			ConvertPackedDWordsToUCode(&pNewShader[i * 4 + 1], &ins);
			*(D3DVsInstruction*)&pNewShader[i * 3 + 1] = ins;
		}

		pNewShader[0] = InstructionCount; //set up the dword array like a D3DShaderProgram structure...

		//optimize, don't verify
		HRESULT hr = XGOptimizeVertexShader(true, true, false, XGSUCode_GetVertexShaderType(&OldHeader), (D3DVertexShaderProgram*)&pNewShader[0]);

		InstructionCount = pNewShader[0]; //get new instruction count
		d = InstructionCount * 4 + 1;    //change index into dword array to hold the number of dwords we're now using

		//put the shader back into the hardware's format
        for(i = InstructionCount - 1; i != 0-1; i--){
			//note: ins is required because when i == 0, 1, or 2, input overlaps output
			//also, we must go backwards so we don't overwrite our input before we've read it
			D3DVsInstruction ins = *(D3DVsInstruction*)&pNewShader[i * 3 + 1];
			D3DVsInstruction*pd=&ins;
			pNewShader[1 + i * 4] = PGM_UWORDX(pd);
			pNewShader[2 + i * 4] = PGM_UWORDY(pd);
			pNewShader[3 + i * 4] = PGM_UWORDZ(pd);
			pNewShader[4 + i * 4] = PGM_UWORDW(pd);
		}
	}

	if(!FAILED(hr)) {
		pNewShader[0] = (InstructionCount << 16) | ((DWORD)OldHeader);
		pNewShader[d-1] |= 0x00000001; //set "end-of-shader" flag
	}

#ifdef DBG_SPLICER
	WriteFile(hPost, pNewShader, d*4, &blah,0);
	CloseHandle(hPre); 
	CloseHandle(hPost);
#endif

	if(pNewInstructionCount != NULL) {
		*pNewInstructionCount = InstructionCount;
	}

	//we will only fail in low-mem situations when optimizing
	return hr;
}








#ifdef DBG

// This is a hack so that users get a reasonable error message when they
// link with D3D8XD and don't link with XGraphicsD. It could be defined
// in any source file that's included in the XGraphics library.

extern "C" {
    DWORD you_must_also_link_with_xgraphicsd_lib;
};

#endif
} // namespace XGRAPHICS

#ifndef DISABLE_TREE_PRINT
//the following functions are used when debugging the optimizers, using msdev's watch window, to print out a tree to the debug window. 
//Msdev doesn't like them being in the D3D namespace though...
void _D3DPrintTree(XGRAPHICS::VerNode*pn, int tab)
{
    if(pn == NULL) { XGRAPHICS::DPF2("PrintTree: NULL\n"); return; }
    char spaces[1024]={0};
    int i;
    for(i = 0; i < tab; i++) { spaces[i] = ' '; }
    char xyzw[4] = {'x','y','z','w'};

    if(pn->mbNegated) {
        XGRAPHICS::DPF2("%s- \n", spaces);
    }
    if(pn->mbHasReg) {
        if(pn->mbHasTable) {
            XGRAPHICS::DPF2("%s C[%d + a0.x]\n", spaces, pn->mReg-96);
        } else {
            if(pn->mReg < 0x40) {
                XGRAPHICS::DPF2("%s Reg: V%d.%c\n", spaces, pn->mReg/4, xyzw[pn->mReg&3]);
            } else if (pn->mReg < 0x80) {
                XGRAPHICS::DPF2("%s Reg: O%d.%c\n", spaces, pn->mReg/4 - 16, xyzw[pn->mReg&3]);
            } else if (pn->mReg < 0x380) {
                XGRAPHICS::DPF2("%s Reg: C%d.%c\n", spaces, pn->mReg/4 - 32, xyzw[pn->mReg&3]);
            } else {
                XGRAPHICS::DPF2("%s Reg: R%d.%c\n", spaces, pn->mReg/4 - 0xe0, xyzw[pn->mReg&3]);
            }
        }
    }
    if(pn->mbHasTable) {
        XGRAPHICS::DPF2("%s TABLE.\n", spaces);
        _D3DPrintTree(pn->mpArl, tab + 4);
    }
    if(pn->mbHasOp) {
        XGRAPHICS::DPF2("%s ", spaces); XGRAPHICS::PrintVerOpcode(pn->mpOp->mOp); XGRAPHICS::DPF2("\n");
        for(i = 0; i < pn->mpOp->mNumParams; i++) {
            _D3DPrintTree(&pn->mpOp->mpParams[i], tab + 3);
        }
    }
}

void _D3DDebugSpewNewLine(){
    XGRAPHICS::DPF2("\n");
}
#endif //ndef DISABLE_TREE_PRINT


// Used to track down a build issue - I beleive that the windows tools may be being built against
// older versions of the xgraphics library. This should help ensure that the code is built
// against a consistent version.

extern "C" const char* XGraphicsBuildVersion() {
    return VER_PRODUCTVERSION_STR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\pixelshader.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:       api.cpp
//  Content:    The public api functions for the shadeasm library
//
///////////////////////////////////////////////////////////////////////////

#include "pchshadeasm.h"

namespace XGRAPHICS
{

void PrintPixelShaderDef(D3DPIXELSHADERDEF *pPSD, Buffer* pListing);

#define D3DSP_WRITEMASK_RGBA (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3)
#define D3DSP_WRITEMASK_RGB (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2)
#define D3DSP_WRITEMASK_A (D3DSP_WRITEMASK_3)
#define D3DSP_WRITEMASK_SHIFT 16

#define MAX_SHADER_STAGES               4
#define MAX_COMBINER_STAGES             8
#define MAX_CONSTANTS                   16
#define PSHAD_MAX_ARGS_PER_INSTRUCTION  7
#define PSHADER_UNUSED                  0
#define CONSTANT_UNUSED                 0xffffffff
#define PSHAD_COLOR 0
#define PSHAD_ALPHA 1

D3DPIXELSHADERDEF          *g_pPSD;     // pointer to output storage
DWORD                       g_dwStage;  // current combiner stage
DWORD                       g_constMapping[MAX_COMBINER_STAGES+1][2];
DWORD                       g_D3DConstants[MAX_CONSTANTS];
XD3DXErrorLog*              g_pErrorLog;

int NumSrcRegs[] = {
     0, // D3DSIO_NOP
     1, // D3DSIO_MOV
     2, // D3DSIO_ADD
     2, // D3DSIO_SUB
     3, // D3DSIO_MAD
     2, // D3DSIO_MUL
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     2, // D3DSIO_DP3
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     3, // D3DSIO_LRP
     3, // D3DSIO_CND
     4, // D3DSIO_XMMA
     4, // D3DSIO_XMMC
     4, // D3DSIO_XDM
     4, // D3DSIO_XDD
     7, // D3DSIO_XFC
};

int NumDstRegs[] = {
     0, // D3DSIO_NOP
     1, // D3DSIO_MOV
     1, // D3DSIO_ADD
     1, // D3DSIO_SUB
     1, // D3DSIO_MAD
     1, // D3DSIO_MUL
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     1, // D3DSIO_DP3
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     0, // Undefined for pixel shaders
     1, // D3DSIO_LRP
     1, // D3DSIO_CND
     3, // D3DSIO_XMMA
     3, // D3DSIO_XMMC
     2, // D3DSIO_XDM
     2, // D3DSIO_XDD
     0, // D3DSIO_XFC
};

DWORD D3DModToNVMod[] = {
    PS_INPUTMAPPING_SIGNED_IDENTITY,    // D3DSPSM_NONE
    PS_INPUTMAPPING_SIGNED_NEGATE,      // D3DSPSM_NEG
    PS_INPUTMAPPING_HALFBIAS_NORMAL,    // D3DSPSM_BIAS
    PS_INPUTMAPPING_HALFBIAS_NEGATE,    // D3DSPSM_BIASNEG
    PS_INPUTMAPPING_EXPAND_NORMAL,      // D3DSPSM_SIGN
    PS_INPUTMAPPING_EXPAND_NEGATE,      // D3DSPSM_SIGNNEG
    PS_INPUTMAPPING_UNSIGNED_INVERT,    // D3DSPSM_COMP
    PS_INPUTMAPPING_UNSIGNED_IDENTITY,  // D3DSPSM_SAT
    ~0,
    ~0,
    ~0,
    ~0,
    ~0,
    ~0,
    ~0,
    ~0
};

DWORD NVModToNVModInvert[] = 
{
    PS_INPUTMAPPING_UNSIGNED_INVERT,   // PS_INPUTMAPPING_UNSIGNED_IDENTITY
    PS_INPUTMAPPING_UNSIGNED_IDENTITY, // PS_INPUTMAPPING_UNSIGNED_INVERT
    PS_INPUTMAPPING_EXPAND_NORMAL,     // PS_INPUTMAPPING_EXPAND_NORMAL
    PS_INPUTMAPPING_EXPAND_NEGATE,     // PS_INPUTMAPPING_EXPAND_NEGATE
    PS_INPUTMAPPING_HALFBIAS_NORMAL,   // PS_INPUTMAPPING_HALFBIAS_NORMAL
    PS_INPUTMAPPING_HALFBIAS_NEGATE,   // PS_INPUTMAPPING_HALFBIAS_NEGATE
    PS_INPUTMAPPING_UNSIGNED_INVERT,   // PS_INPUTMAPPING_SIGNED_IDENTITY
    PS_INPUTMAPPING_SIGNED_NEGATE      // PS_INPUTMAPPING_SIGNED_NEGATE
};

DWORD TypeOffsetToCombinerReg[][4] = 
{
    {0xC, 0xD, 0x0, 0x3}, // D3DSPR_TEMP
    {0x4, 0x5, 0xe, 0xf}, // D3DSPR_INPUT
    {0x1, 0x2, 0x0, 0x0}, // D3DSPR_CONST
    {0x8, 0x9, 0xA, 0xB}, // D3DSPR_TEXTURE
    {0x0, 0x0, 0x0, 0x0}, // Unused type for pixel shaders
    {0x0, 0x0, 0x0, 0x0}  // Unused type for pixel shaders
};

DWORD D3DOpToTexMode[] =
{
    PS_TEXTUREMODES_PASSTHRU,             //D3DSIO_TEXCOORD
    PS_TEXTUREMODES_CLIPPLANE,            //D3DSIO_TEXKILL
    PS_TEXTUREMODES_PROJECT2D,            //D3DSIO_TEX
    PS_TEXTUREMODES_BUMPENVMAP,           //D3DSIO_TEXBEM
    PS_TEXTUREMODES_BUMPENVMAP_LUM,       //D3DSIO_TEXBEML
    PS_TEXTUREMODES_DPNDNT_AR,            //D3DSIO_TEXREG2AR
    PS_TEXTUREMODES_DPNDNT_GB,            //D3DSIO_TEXREG2GB
    PS_TEXTUREMODES_DOTPRODUCT,           //D3DSIO_TEXM3x2PAD
    PS_TEXTUREMODES_DOT_ST,               //D3DSIO_TEXM3x2TEX
    PS_TEXTUREMODES_DOTPRODUCT,           //D3DSIO_TEXM3x3PAD
    PS_TEXTUREMODES_DOT_STR_3D,           //D3DSIO_TEXM3x3TEX
    PS_TEXTUREMODES_DOT_RFLCT_DIFF,       //D3DSIO_TEXM3x3DIFF
    PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST, //D3DSIO_TEXM3x3SPEC
    PS_TEXTUREMODES_DOT_RFLCT_SPEC,       //D3DSIO_TEXM3x3VSPEC
};

int NumTexArgs[] = 
{
    1, // D3DSIO_TEXCOORD:
    1, // D3DSIO_TEXKILL:
    1, // D3DSIO_TEX:
    2, // D3DSIO_TEXBEM:
    2, // D3DSIO_TEXBEML:
    2, // D3DSIO_TEXREG2AR:
    2, // D3DSIO_TEXREG2GB:
    2, // D3DSIO_TEXM3x2PAD:
    2, // D3DSIO_TEXM3x2TEX:
    2, // D3DSIO_TEXM3x3PAD:
    2, // D3DSIO_TEXM3x3TEX:
    2, // D3DSIO_TEXM3x3DIFF:
    3, // D3DSIO_TEXM3x3SPEC:
    2  // D3DSIO_TEXM3x3VSPEC:
};

DWORD RGBSwizzleToChannel(DWORD swiz)
{
    if(swiz == D3DSP_REPLICATEALPHA)
        return PS_CHANNEL_ALPHA;
    else
        return PS_CHANNEL_RGB;
}

DWORD AlphaSwizzleToChannel(DWORD swiz)
{
    if((swiz & (3L << (D3DSP_SWIZZLE_SHIFT + 6))) == (2L << (D3DSP_SWIZZLE_SHIFT + 6)))    // blue replicated to alpha?
        return PS_CHANNEL_BLUE;
    else
        return PS_CHANNEL_ALPHA;
}

#define PSHAD_INSTRUCTION_ARGS DWORD stage, DWORD color, DWORD *outputmap, DWORD *dst, DWORD *src, DWORD *swizzle, DWORD *inputmod, DWORD *mask

void InstructionMOV(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),                 // A is src operand
            PS_REGISTER_ONE | PS_CHANNEL_RGB,                                       // B is 1
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,  // C is 0
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB); // D is 0
    
        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            dst[0],
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            outputmap[0] | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]),                 // A is src operand
            PS_REGISTER_ONE | PS_CHANNEL_ALPHA,                                       // B is 1
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,  // C is 0
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA); // D is 0
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            dst[0],
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
}

void InstructionMUL(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),                 // A is src operand 0
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),                 // B is src operand 1
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,  // C is 0
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB); // D is 0

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            dst[0],
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            outputmap[0] | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]),                 // A is src operand 0
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]),                 // B is src operand 1
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,  // C is 0
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA); // D is 0
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            dst[0],
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
}

void InstructionDP3(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),                 // A is src operand 0
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),                 // B is src operand 1
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,  // C is 0
            PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB); // D is 0

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            dst[0],
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            outputmap[0] | 
            PS_COMBINEROUTPUT_AB_DOT_PRODUCT | 
            PS_COMBINEROUTPUT_CD_MULTIPLY | 
            PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        // copy dot product to alpha channel
        g_pPSD->PSRGBOutputs[stage] |= PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA << 12;
    }
}

void InstructionADD(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),                 // A is src operand 0
            PS_REGISTER_ONE | PS_CHANNEL_RGB,                                       // B is 1
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),                 // C is src operand 1
            PS_REGISTER_ONE | PS_CHANNEL_RGB);                                      // D is 1

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]),               // A is src operand 0
            PS_REGISTER_ONE | PS_CHANNEL_ALPHA,                                     // B is 1
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]),               // C is src operand 1
            PS_REGISTER_ONE | PS_CHANNEL_ALPHA);                                    // D is 1
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
}

void InstructionSUB(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),                 // A is src operand 0
            PS_REGISTER_ONE | PS_CHANNEL_RGB,                                       // B is 1
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),                 // C is src operand 1
            PS_REGISTER_NEGATIVE_ONE | PS_CHANNEL_RGB);                             // D is -1

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]),               // A is src operand 0
            PS_REGISTER_ONE | PS_CHANNEL_ALPHA,                                     // B is 1
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]),               // C is src operand 1
            PS_REGISTER_NEGATIVE_ONE | PS_CHANNEL_ALPHA);                           // D is -1
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
}

void InstructionMAD(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),                 // A is src operand 0
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),                 // B is src operand 1
            PS_REGISTER_ONE | PS_CHANNEL_RGB,                                       // C is 1
            src[2] | inputmod[2] | RGBSwizzleToChannel(swizzle[2]));                // D is src operand 2

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]),               // A is src operand 0
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]),               // B is src operand 1
            PS_REGISTER_ONE | PS_CHANNEL_ALPHA,                                     // C is 1
            src[2] | inputmod[2] | AlphaSwizzleToChannel(swizzle[2]));              // D is src operand 2
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
}

void InstructionLRP(PSHAD_INSTRUCTION_ARGS) 
{
    if((inputmod[0] != PS_INPUTMAPPING_UNSIGNED_INVERT) &&
       (inputmod[0] != PS_INPUTMAPPING_UNSIGNED_IDENTITY))
        inputmod[0] = PS_INPUTMAPPING_UNSIGNED_IDENTITY;   // force interpolant to be unsigned

    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),                 // A is src operand 0
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),                 // B is src operand 1
            src[2] | inputmod[2] | RGBSwizzleToChannel(swizzle[2]),                 // C is src operand 2
            src[0] | NVModToNVModInvert[inputmod[0]>>5] | RGBSwizzleToChannel(swizzle[0])); // D is -src operand 0

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]),               // A is src operand 0
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]),               // B is src operand 1
            src[2] | inputmod[2] | AlphaSwizzleToChannel(swizzle[2]),               // C is src operand 2
            src[0] | NVModToNVModInvert[inputmod[0]>>5] | AlphaSwizzleToChannel(swizzle[0])); // D is -src operand 0
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
}

void InstructionCND(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[2] | inputmod[2] | RGBSwizzleToChannel(swizzle[2]),                 // A is src operand 2
            PS_REGISTER_ONE | PS_CHANNEL_RGB,                                       // B is 1
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),                 // C is src operand 1
            PS_REGISTER_ONE | PS_CHANNEL_RGB);                                      // D is 1

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[2] | inputmod[2] | AlphaSwizzleToChannel(swizzle[2]),               // A is src operand 2
            PS_REGISTER_ONE | PS_CHANNEL_ALPHA,                                     // B is 1
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]),               // C is src operand 1
            PS_REGISTER_ONE | PS_CHANNEL_ALPHA);                                    // D is 1
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            dst[0],
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_MUX);
    }
}

#define EXTENDED_INSTRUCTION(summux, abdot, cddot, dst2) \
    if(color == PSHAD_COLOR) \
    { \
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS( \
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]), \
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]), \
            src[2] | inputmod[2] | RGBSwizzleToChannel(swizzle[2]), \
            src[3] | inputmod[3] | RGBSwizzleToChannel(swizzle[3])); \
 \
        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS( \
            dst[0], \
            dst[1], \
            dst2, \
            outputmap[0] | abdot | cddot | summux); \
    } \
    else \
    { \
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS( \
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]), \
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]), \
            src[2] | inputmod[2] | AlphaSwizzleToChannel(swizzle[2]), \
            src[3] | inputmod[3] | AlphaSwizzleToChannel(swizzle[3])); \
     \
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS( \
            dst[0], \
            dst[1], \
            dst2, \
            outputmap[0] | summux); \
        if((abdot == PS_COMBINEROUTPUT_AB_DOT_PRODUCT) && (mask[0] & D3DSP_WRITEMASK_A))\
            g_pPSD->PSRGBOutputs[stage] |= PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA << 12; \
        if((cddot == PS_COMBINEROUTPUT_CD_DOT_PRODUCT) && (mask[1] & D3DSP_WRITEMASK_A))\
            g_pPSD->PSRGBOutputs[stage] |= PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA << 12; \
    }

void InstructionXMMA(PSHAD_INSTRUCTION_ARGS) 
{
    EXTENDED_INSTRUCTION(PS_COMBINEROUTPUT_AB_CD_SUM, 
                         PS_COMBINEROUTPUT_AB_MULTIPLY, 
                         PS_COMBINEROUTPUT_CD_MULTIPLY,
                         dst[2])
}

void InstructionXMMC(PSHAD_INSTRUCTION_ARGS) 
{
    EXTENDED_INSTRUCTION(PS_COMBINEROUTPUT_AB_CD_MUX, 
                         PS_COMBINEROUTPUT_AB_MULTIPLY, 
                         PS_COMBINEROUTPUT_CD_MULTIPLY,
                         dst[2])
}

void InstructionXDM(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),
            src[2] | inputmod[2] | RGBSwizzleToChannel(swizzle[2]),
            src[3] | inputmod[3] | RGBSwizzleToChannel(swizzle[3]));

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            dst[0],
            dst[1],
            PS_REGISTER_DISCARD,
            outputmap[0] | PS_COMBINEROUTPUT_AB_DOT_PRODUCT | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]),
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]),
            src[2] | inputmod[2] | AlphaSwizzleToChannel(swizzle[2]),
            src[3] | inputmod[3] | AlphaSwizzleToChannel(swizzle[3]));
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            dst[1],
            PS_REGISTER_DISCARD,
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_SUM);
            
        g_pPSD->PSRGBOutputs[stage] |= PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA << 12;
    }
}

void InstructionXDD(PSHAD_INSTRUCTION_ARGS) 
{
    if(color == PSHAD_COLOR)
    {
        g_pPSD->PSRGBInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),
            src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),
            src[2] | inputmod[2] | RGBSwizzleToChannel(swizzle[2]),
            src[3] | inputmod[3] | RGBSwizzleToChannel(swizzle[3]));

        g_pPSD->PSRGBOutputs[stage] = PS_COMBINEROUTPUTS(
            dst[0],
            dst[1],
            PS_REGISTER_DISCARD,
            outputmap[0] | PS_COMBINEROUTPUT_AB_DOT_PRODUCT | PS_COMBINEROUTPUT_CD_DOT_PRODUCT | PS_COMBINEROUTPUT_AB_CD_SUM);
    }
    else
    {
        g_pPSD->PSAlphaInputs[stage] = PS_COMBINERINPUTS(
            src[0] | inputmod[0] | AlphaSwizzleToChannel(swizzle[0]),
            src[1] | inputmod[1] | AlphaSwizzleToChannel(swizzle[1]),
            src[2] | inputmod[2] | AlphaSwizzleToChannel(swizzle[2]),
            src[3] | inputmod[3] | AlphaSwizzleToChannel(swizzle[3]));
    
        g_pPSD->PSAlphaOutputs[stage] = PS_COMBINEROUTPUTS(
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            outputmap[0] | PS_COMBINEROUTPUT_AB_CD_SUM);
        
        g_pPSD->PSRGBOutputs[stage] |= PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA << 12;
        g_pPSD->PSRGBOutputs[stage] |= PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA << 12;
    }
}

void InstructionXFC(PSHAD_INSTRUCTION_ARGS) 
{
    g_pPSD->PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
        src[0] | inputmod[0] | RGBSwizzleToChannel(swizzle[0]),
        src[1] | inputmod[1] | RGBSwizzleToChannel(swizzle[1]),
        src[2] | inputmod[2] | RGBSwizzleToChannel(swizzle[2]),
        src[3] | inputmod[3] | RGBSwizzleToChannel(swizzle[3]));

    g_pPSD->PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
        src[4] | inputmod[4] | RGBSwizzleToChannel(swizzle[4]),
        src[5] | inputmod[5] | RGBSwizzleToChannel(swizzle[5]),
        src[6] | inputmod[6] | RGBSwizzleToChannel(swizzle[6]),
        PS_FINALCOMBINERSETTING_CLAMP_SUM);

}

void (*PSInstructionLUT[])(PSHAD_INSTRUCTION_ARGS) = 
{
    0,                            // D3DSIO_NOP
    InstructionMOV,               // D3DSIO_MOV
    InstructionADD,               // D3DSIO_ADD
    InstructionSUB,               // D3DSIO_SUB
    InstructionMAD,               // D3DSIO_MAD
    InstructionMUL,               // D3DSIO_MUL
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    InstructionDP3,               // D3DSIO_DP3
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    0,                            // Undefined for pixel shaders
    InstructionLRP,               // D3DSIO_LRP
    InstructionCND,               // D3DSIO_CND
    InstructionXMMA,              // D3DSIO_XMMA
    InstructionXMMC,              // D3DSIO_XMMC
    InstructionXDM,               // D3DSIO_XDM
    InstructionXDD,               // D3DSIO_XDD
    InstructionXFC,               // D3DSIO_XFC
};

DWORD ShiftAndBiasToMap(DWORD shift, DWORD bias)
{
    if(bias)
    {
        switch((DSTSHIFT)shift)
        {
        case DSTSHIFT_NONE:
            return PS_COMBINEROUTPUT_BIAS;
        case DSTSHIFT_X2:
            return PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS;
        default:
            // output error here
            return PS_COMBINEROUTPUT_IDENTITY;
        }
    }
    switch(shift) // no bias
    {
    case DSTSHIFT_NONE:
        return PS_COMBINEROUTPUT_IDENTITY;
    case DSTSHIFT_X2:
        return PS_COMBINEROUTPUT_SHIFTLEFT_1;
    case DSTSHIFT_X4:
        return PS_COMBINEROUTPUT_SHIFTLEFT_2;
    case DSTSHIFT_D2:
        return PS_COMBINEROUTPUT_SHIFTRIGHT_1;
    default:
        // output error here
        return PS_COMBINEROUTPUT_IDENTITY;
    }
}

// Decode the destination register token
DWORD DSTdecode(DWORD *dstreg, DWORD *outputmap, DWORD *colormask, DWORD op)
{
    DWORD type = (op & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT;
    DWORD offset = op & D3DSP_REGNUM_MASK;
    DWORD shift = ((op & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT) & 0xf;
    DWORD dstmod = (op & D3DSP_DSTMOD_MASK) >> D3DSP_DSTMOD_SHIFT;

    *outputmap = ShiftAndBiasToMap(shift, dstmod);
    *dstreg = TypeOffsetToCombinerReg[type][offset];

    *colormask = op & D3DSP_WRITEMASK_ALL;

    return TRUE;
}

// Decode the source register token
DWORD SRCdecode(DWORD *src, DWORD *swizzle, DWORD *mod, DWORD op, DWORD IsFC)
{
    DWORD type = (op & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT; // const reg, texture reg, etc
    DWORD regnum = op & D3DSP_REGNUM_MASK;   // which reg number within a type set is it?
    DWORD offset = regnum;                   // save this, we may have to remap it later
    
    *swizzle = (op & D3DSP_SWIZZLE_MASK);

    if ((op & D3DSP_REGTYPE_MASK) == D3DSPR_CONST) 
    {
        if (regnum >= MAX_CONSTANTS) 
        {
            g_pErrorLog->Log(TRUE, ERROR_ASM_INVALID_SOURCE_REGISTER, 
                           NULL, 0, "Invalid constant source register.\n");
            return FALSE;
        }

        if(IsFC)
        {
            if((g_constMapping[8][0] == CONSTANT_UNUSED) ||
               (g_constMapping[8][0] == offset))
            {
                g_constMapping[8][0] = offset;
                regnum = 0; // register is now constant 0
                g_pPSD->PSFinalCombinerConstant0 = g_D3DConstants[offset];
            } 
            else if((g_constMapping[8][1] == CONSTANT_UNUSED) ||
                    (g_constMapping[8][1] == offset))
            {
                g_constMapping[8][1] = offset;
                regnum = 1; // register is now constant 1
                g_pPSD->PSFinalCombinerConstant1 = g_D3DConstants[offset];
            }
            else 
            {
                g_pErrorLog->Log(TRUE, ERROR_ASM_INVALID_CONSTANT, 
                               NULL, 0, "More than 2 constants used in final combiner.\n");
                return FALSE;
            }
        }
        else
        {
            if((g_constMapping[g_dwStage][0] == CONSTANT_UNUSED) ||
               (g_constMapping[g_dwStage][0] == offset))
            {
                g_constMapping[g_dwStage][0] = offset;
                regnum = 0; // register is now constant 0
                g_pPSD->PSConstant0[g_dwStage] = g_D3DConstants[offset];
            } 
            else if((g_constMapping[g_dwStage][1] == CONSTANT_UNUSED) ||
                    (g_constMapping[g_dwStage][1] == offset))
            {
                g_constMapping[g_dwStage][1] = offset;
                regnum = 1; // register is now constant 1
                g_pPSD->PSConstant1[g_dwStage] = g_D3DConstants[offset];
            }
            else 
            {
                char buf[256];
                sprintf(buf, "More than 2 constants used in stage %d.\n", g_dwStage);
                g_pErrorLog->Log(TRUE, ERROR_ASM_INVALID_CONSTANT, 
                               NULL, 0, buf);

                return FALSE;
            }
        }
    }

    *src = TypeOffsetToCombinerReg[type][regnum];
    *mod = D3DModToNVMod[(op & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT];
    
    // default mod for final combiner is UNSIGNED_IDENTITY (SIGNED_IDENTITY invalid)
    if(IsFC && (*mod == PS_INPUTMAPPING_SIGNED_IDENTITY))
        *mod = PS_INPUTMAPPING_UNSIGNED_IDENTITY;
    
    return TRUE;
}


HRESULT CompilePixelShaderToUCode(bool optimize, DWORD shaderType,
							 LPXGBUFFER pTokenizedShader, 
							 LPXGBUFFER* ppCompiledShader,
							 Buffer* pListing,
                             XD3DXErrorLog* pErrorLog)
{
	LPXGBUFFER pCompiledShader; // Output buffer
	
    g_pErrorLog = pErrorLog;    // make it global

    if(FAILED(XGBufferCreate(sizeof(D3DPIXELSHADERDEF), &pCompiledShader)))
    {
        g_pErrorLog->Log(TRUE, ERROR_ASM_INTERNAL_ASSEMBLER_ERROR, 
                       NULL, 0, "Unable to create output buffer.\n");
		return E_OUTOFMEMORY;
    }
	
    *ppCompiledShader = pCompiledShader;
    g_pPSD = (D3DPIXELSHADERDEF *)pCompiledShader->GetBufferPointer();
    memset(g_pPSD, 0x0, sizeof(D3DPIXELSHADERDEF));     // zero out the structure
    
    DWORD dwCodeSize = pTokenizedShader->GetBufferSize();
	DWORD *pCode = (DWORD *)pTokenizedShader->GetBufferPointer();
    DWORD op, opcode;
    DWORD texturesUsed = 0;
    g_dwStage = 0;                  // stage being built

    DWORD mask[PSHAD_MAX_ARGS_PER_INSTRUCTION];
    DWORD dst[PSHAD_MAX_ARGS_PER_INSTRUCTION];
    DWORD src[PSHAD_MAX_ARGS_PER_INSTRUCTION];
    DWORD swizzle[PSHAD_MAX_ARGS_PER_INSTRUCTION];
    DWORD inputmod[PSHAD_MAX_ARGS_PER_INSTRUCTION];
    DWORD outputmap[PSHAD_MAX_ARGS_PER_INSTRUCTION];

    DWORD texturemode[MAX_SHADER_STAGES];
    DWORD otherreg[MAX_SHADER_STAGES];
    DWORD dotmap[MAX_SHADER_STAGES];
    DWORD shaderstage = 0;
    DWORD docoissue;

    // initialize constant mapping
    DWORD i;
    for (i=0; i<(MAX_COMBINER_STAGES+1); i++) 
        g_constMapping[i][0] = g_constMapping[i][1] = CONSTANT_UNUSED;

    for(i=0; i<MAX_CONSTANTS; i++)
        g_D3DConstants[i] = 0;

    // initialize texturemodes
    for(i=0; i<MAX_SHADER_STAGES; i++)
    {
        texturemode[i] = PS_TEXTUREMODES_NONE;
        otherreg[i] = 0;
        dotmap[i] = PS_DOTMAPPING_ZERO_TO_ONE;
    }

    pCode++;    // skip version info

    for(UINT xx=0; xx<dwCodeSize; xx += sizeof(DWORD))
    {
        // step through tokens
        
        
        op = *pCode++;
        opcode = op & D3DSI_OPCODE_MASK;
        docoissue = (op & D3DSI_COISSUE);

        if(opcode == D3DSIO_END) // End of tokens
        {
            break;
        }
        else if(opcode == D3DSIO_NOP) // no-op
        {   // do nothing
        }
        else if(opcode == D3DSIO_COMMENT) // comment
        {
            INT cmtsize = (op & D3DSI_COMMENTSIZE_MASK) >> 
                          D3DSI_COMMENTSIZE_SHIFT;
            // skip comment DWORDs
            while(cmtsize-- > 0)
                pCode++;
        }
        else if(opcode == D3DSIO_DEF)
        {
            // get destination register
            op = *pCode++;
            // components are in RGBA order
            DWORD constant = op & D3DSP_REGNUM_MASK;
            g_D3DConstants[constant] = (DWORD)(((*(FLOAT*)pCode++) * 255.0f) + 0.5f) & 0xff;
            g_D3DConstants[constant] <<= 8;
            g_D3DConstants[constant] |= (DWORD)(((*(FLOAT*)pCode++) * 255.0f) + 0.5f) & 0xff;
            g_D3DConstants[constant] <<= 8;
            g_D3DConstants[constant] |= (DWORD)(((*(FLOAT*)pCode++) * 255.0f) + 0.5f) & 0xff;
            DWORD alpha = (DWORD)(((*(FLOAT*)pCode++) * 255.0f) + 0.5f) & 0xff;
            g_D3DConstants[constant] |= alpha << 24;
        }
        else if((opcode < D3DSIO_TEXCOORD) || (opcode == D3DSIO_CND) ||
                ((opcode >= D3DSIO_XMMA) && (opcode <= D3DSIO_XFC)))
        {
            // store the opcode offset for lookups
            DWORD opoffset;
            if(opcode == D3DSIO_CND)
                opoffset = D3DSIO_LRP+1;
            else if((opcode >= D3DSIO_XMMA) && (opcode <= D3DSIO_XFC))
                opoffset = opcode - D3DSIO_XMMA+D3DSIO_LRP+2;
            else
                opoffset = opcode;

            // It's a standard instruction
			if (docoissue) 
            {
				// They are issuing a color op and an alpha op in parallel.
				// Decrease stage count to match last instruction and check consistency.
				g_dwStage--; 
            }

            
            int i;
            BOOL bWritesToAlpha = FALSE, bWritesToRGB = FALSE;

            for (i=0; i < NumDstRegs[opoffset]; i++) 
            {
                op = *pCode++;
                if (!DSTdecode(&(dst[i]), &(outputmap[i]), &(mask[i]), op)) 
                    return E_FAIL; // error message already logged
                if(mask[i] & D3DSP_WRITEMASK_RGB) bWritesToRGB = TRUE;
                if(mask[i] & D3DSP_WRITEMASK_A) bWritesToAlpha = TRUE;
            }
            // default dst values for XFC instruction (no dst param)
            DWORD IsFC = FALSE;
            if(i==0)
            {
                dst[0] = PS_REGISTER_ZERO;
                outputmap[0] = 0;
                mask[0] = D3DSP_WRITEMASK_RGB;
                IsFC = TRUE;
                bWritesToRGB = TRUE;
            }

            for (i=0; i < NumSrcRegs[opoffset]; i++) 
            {
                op = *pCode++;
                if (!SRCdecode(&src[i], &swizzle[i], &inputmod[i], op, IsFC)) 
                    return E_FAIL; // error message already logged
            }

            if (bWritesToRGB) 
            {
				(*PSInstructionLUT[opoffset])(g_dwStage, PSHAD_COLOR, outputmap, dst, src, swizzle, inputmod, mask);
			}
			if (bWritesToAlpha) 
            {
				(*PSInstructionLUT[opoffset])(g_dwStage, PSHAD_ALPHA, outputmap, dst, src, swizzle, inputmod, mask);
			}
            if(opcode != D3DSIO_XFC)    // XFC doesn't use a combiner stage
                g_dwStage++;
        }
        else if((opcode <= D3DSIO_TEXM3x3VSPEC) ||
                (opcode == D3DSIO_TEXM3x2DEPTH) ||
                (opcode == D3DSIO_TEXBRDF))
        {
            // It's a texture addressing instruction
            DWORD dstoffset, srcoffset;
            DWORD srcmod = 0;

            // make texture opcodes relative to D3DSIO_TEXCOORD
            opcode -= D3DSIO_TEXCOORD;

            // Get destination register offset
            op = *pCode++;
            dstoffset = op & D3DSP_REGNUM_MASK;

            // determine number of arguments
            int TexArgCount;
            if(opcode == (D3DSIO_TEXM3x2DEPTH-D3DSIO_TEXCOORD))
                TexArgCount = 2;
            else if(opcode == (D3DSIO_TEXBRDF-D3DSIO_TEXCOORD))
                TexArgCount = 1;
            else
                TexArgCount = NumTexArgs[opcode];

            if (TexArgCount >= 2) 
            {
                op = *pCode++;
                srcoffset = op & D3DSP_REGNUM_MASK;
                srcmod = op & D3DSP_SRCMOD_MASK;
            } 
            else 
            {
                srcoffset = PSHADER_UNUSED;
            }

            // Last register is always redundant
            if (TexArgCount >= 3) 
                op = *pCode++;

            if (dstoffset >= MAX_SHADER_STAGES) 
            {
                // destination register exceeds the available texture registers
                // error here
                g_pErrorLog->Log(TRUE, ERROR_ASM_INVALID_DESTINATION_REGISTER, 
                               NULL, 0, "Invalid texture destination register.\n");
                return E_FAIL;
            }

            switch(opcode)
            {
            case D3DSIO_TEXM3x2DEPTH-D3DSIO_TEXCOORD:
                texturemode[dstoffset] = PS_TEXTUREMODES_DOT_ZW;
                break;
            case D3DSIO_TEXBRDF-D3DSIO_TEXCOORD:
                texturemode[dstoffset] = PS_TEXTUREMODES_BRDF;
                break;
            default:
                texturemode[dstoffset] = D3DOpToTexMode[opcode];
                break;
            }
            otherreg[dstoffset] = srcoffset;
            switch(srcmod)
            {
            case D3DSPSM_NONE:    dotmap[dstoffset] = PS_DOTMAPPING_ZERO_TO_ONE; break;
            case D3DSPSM_SIGN:    dotmap[dstoffset] = PS_DOTMAPPING_MINUS1_TO_1_D3D; break;
            case D3DSPSM_NEG:     dotmap[dstoffset] = PS_DOTMAPPING_MINUS1_TO_1_GL; break;
            case D3DSPSM_BIAS:    dotmap[dstoffset] = PS_DOTMAPPING_MINUS1_TO_1; break;
            case D3DSPSM_BIASNEG: dotmap[dstoffset] = PS_DOTMAPPING_HILO_1; break;
            case D3DSPSM_SIGNNEG: dotmap[dstoffset] = PS_DOTMAPPING_HILO_HEMISPHERE_D3D; break;
            case D3DSPSM_COMP:    dotmap[dstoffset] = PS_DOTMAPPING_HILO_HEMISPHERE_GL; break;
            case D3DSPSM_SAT:     dotmap[dstoffset] = PS_DOTMAPPING_HILO_HEMISPHERE; break;
            }
            shaderstage++;
        }
        else
        {
            // Unknown instruction
            g_pErrorLog->Log(TRUE, ERROR_ASM_INVALID_INSTRUCTION, 
                           NULL, 0, "Unrecognized Instruction.\n");
            return E_FAIL;
        }
    }

    // set shader registers and global combiner registers
    g_pPSD->PSTextureModes = PS_TEXTUREMODES(
        texturemode[0],
        texturemode[1],
        texturemode[2],
        texturemode[3]);
    g_pPSD->PSInputTexture = PS_INPUTTEXTURE(
        otherreg[0],
        otherreg[1],
        otherreg[2],
        otherreg[3]);
    g_pPSD->PSDotMapping = PS_DOTMAPPING(dotmap[0], dotmap[1], dotmap[2], dotmap[3]);
    
    g_pPSD->PSCombinerCount = PS_COMBINERCOUNT(
        g_dwStage,
        PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);

    // set the D3D constant register mapping
    g_pPSD->PSC0Mapping = PS_CONSTANTMAPPING(g_constMapping[0][0], g_constMapping[1][0], \
                                             g_constMapping[2][0], g_constMapping[3][0], \
                                             g_constMapping[4][0], g_constMapping[5][0], \
                                             g_constMapping[6][0], g_constMapping[7][0]);
    g_pPSD->PSC1Mapping = PS_CONSTANTMAPPING(g_constMapping[0][1], g_constMapping[1][1], \
                                             g_constMapping[2][1], g_constMapping[3][1], \
                                             g_constMapping[4][1], g_constMapping[5][1], \
                                             g_constMapping[6][1], g_constMapping[7][1]);
    g_pPSD->PSFinalCombinerConstants = PS_FINALCOMBINERCONSTANTS(
        g_constMapping[8][0], g_constMapping[8][1], PS_GLOBALFLAGS_TEXMODE_ADJUST);

    // print listing if requested
    if(pListing)
        PrintPixelShaderDef(g_pPSD, pListing);

    return S_OK;
}



char *ccf0[] =
{
    "PS_COMBINERCOUNT_MUX_LSB",
    "PS_COMBINERCOUNT_MUX_MSB",
};
    
char *ccf1[] =
{
    "PS_COMBINERCOUNT_SAME_C0",
    "PS_COMBINERCOUNT_UNIQUE_C0",
};
    
char *ccf2[] =
{
    "PS_COMBINERCOUNT_SAME_C1",
    "PS_COMBINERCOUNT_UNIQUE_C1",
};

char *tm[] =
{
    "PS_TEXTUREMODES_NONE",
    "PS_TEXTUREMODES_PROJECT2D",
    "PS_TEXTUREMODES_PROJECT3D",
    "PS_TEXTUREMODES_CUBEMAP",
    "PS_TEXTUREMODES_PASSTHRU",
    "PS_TEXTUREMODES_CLIPPLANE",
    "PS_TEXTUREMODES_BUMPENVMAP",
    "PS_TEXTUREMODES_BUMPENVMAP_LUM",
    "PS_TEXTUREMODES_BRDF",
    "PS_TEXTUREMODES_DOT_ST",
    "PS_TEXTUREMODES_DOT_ZW",
    "PS_TEXTUREMODES_DOT_RFLCT_DIFF",
    "PS_TEXTUREMODES_DOT_RFLCT_SPEC",
    "PS_TEXTUREMODES_DOT_STR_3D",
    "PS_TEXTUREMODES_DOT_STR_CUBE",
    "PS_TEXTUREMODES_DPNDNT_AR",
    "PS_TEXTUREMODES_DPNDNT_GB",
    "PS_TEXTUREMODES_DOTPRODUCT",
    "PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
};

char *dm[] =
{
    "PS_DOTMAPPING_ZERO_TO_ONE",
    "PS_DOTMAPPING_MINUS1_TO_1_D3D",
    "PS_DOTMAPPING_MINUS1_TO_1_GL",
    "PS_DOTMAPPING_MINUS1_TO_1",
    "PS_DOTMAPPING_HILO_1",
    "PS_DOTMAPPING_HILO_HEMISPHERE_D3D",
    "PS_DOTMAPPING_HILO_HEMISPHERE_GL",
    "PS_DOTMAPPING_HILO_HEMISPHERE",
};

char *cms[] =
{
    "PS_COMPAREMODE_S_LT",
    "PS_COMPAREMODE_S_GE",
};
    
char *cmt[] =
{
    "PS_COMPAREMODE_T_LT",
    "PS_COMPAREMODE_T_GE",
};
    
char *cmr[] =
{
    "PS_COMPAREMODE_R_LT",
    "PS_COMPAREMODE_R_GE",
};
    
char *cmq[] =
{
    "PS_COMPAREMODE_Q_LT",
    "PS_COMPAREMODE_Q_GE",
};

char *inmap[] =
{
    "PS_INPUTMAPPING_UNSIGNED_IDENTITY",
    "PS_INPUTMAPPING_UNSIGNED_INVERT",
    "PS_INPUTMAPPING_EXPAND_NORMAL",
    "PS_INPUTMAPPING_EXPAND_NEGATE",
    "PS_INPUTMAPPING_HALFBIAS_NORMAL",
    "PS_INPUTMAPPING_HALFBIAS_NEGATE",
    "PS_INPUTMAPPING_SIGNED_IDENTITY",
    "PS_INPUTMAPPING_SIGNED_NEGATE",
};

char *inreg[] =
{
    "PS_REGISTER_ZERO",
    "PS_REGISTER_C0",
    "PS_REGISTER_C1",
    "PS_REGISTER_FOG",
    "PS_REGISTER_V0",
    "PS_REGISTER_V1",
    "INVALID",
    "INVALID",
    "PS_REGISTER_T0",
    "PS_REGISTER_T1",
    "PS_REGISTER_T2",
    "PS_REGISTER_T3",
    "PS_REGISTER_R0",
    "PS_REGISTER_R1",
    "PS_REGISTER_V1R0_SUM",
    "PS_REGISTER_EF_PROD",
};

char *outreg[] =
{
    "PS_REGISTER_DISCARD",
    "PS_REGISTER_C0",
    "PS_REGISTER_C1",
    "PS_REGISTER_FOG",
    "PS_REGISTER_V0",
    "PS_REGISTER_V1",
    "INVALID",
    "INVALID",
    "PS_REGISTER_T0",
    "PS_REGISTER_T1",
    "PS_REGISTER_T2",
    "PS_REGISTER_T3",
    "PS_REGISTER_R0",
    "PS_REGISTER_R1",
    "PS_REGISTER_V1R0_SUM",
    "PS_REGISTER_EF_PROD",
};

char *chanrgb[] =
{
    "PS_CHANNEL_RGB",
    "PS_CHANNEL_ALPHA",
};

char *chanalpha[] =
{
    "PS_CHANNEL_BLUE",
    "PS_CHANNEL_ALPHA",
};
    
char *outmap[] =
{
    "PS_COMBINEROUTPUT_IDENTITY",
    "PS_COMBINEROUTPUT_BIAS",
    "PS_COMBINEROUTPUT_SHIFTLEFT_1",
    "PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS",
    "PS_COMBINEROUTPUT_SHIFTLEFT_2",
    "INVALID",
    "PS_COMBINEROUTPUT_SHIFTRIGHT_1",
    "INVALID",
};
    
char *abmult[] =
{
    "PS_COMBINEROUTPUT_AB_MULTIPLY",
    "PS_COMBINEROUTPUT_AB_DOT_PRODUCT",
};

char *cdmult[] =
{
    "PS_COMBINEROUTPUT_CD_MULTIPLY",
    "PS_COMBINEROUTPUT_CD_DOT_PRODUCT",
};

char *muxsum[] =
{
    "PS_COMBINEROUTPUT_AB_CD_SUM",
    "PS_COMBINEROUTPUT_AB_CD_MUX",
};

#define ENUMVAL(val, upper, lower) ((val >> lower) & ((2 << (upper-lower))-1))
#define ENUMNAME(val, upper, lower, array) array[ENUMVAL(val, upper, lower)]


void PrintPixelShaderDef(D3DPIXELSHADERDEF *pPSD, Buffer* pListing)
{
    pListing->Printf("D3DPIXELSHADERDEF psd;\n");
    pListing->Printf("ZeroMemory(&psd, sizeof(psd));\n");
    pListing->Printf("psd.PSCombinerCount=PS_COMBINERCOUNT(\n");
    DWORD stagecount = ENUMVAL(pPSD->PSCombinerCount, 3, 0);
    pListing->Printf("    %d,\n", stagecount);
    pListing->Printf("    %s | %s | %s);\n", ENUMNAME(pPSD->PSCombinerCount,  8,  8, ccf0),
                                   ENUMNAME(pPSD->PSCombinerCount, 12, 12, ccf1),
                                   ENUMNAME(pPSD->PSCombinerCount, 16, 16, ccf2));
    
    pListing->Printf("psd.PSTextureModes=PS_TEXTUREMODES(\n");
    pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSTextureModes,  4,  0, tm));
    pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSTextureModes,  9,  5, tm));
    pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSTextureModes, 14, 10, tm));
    pListing->Printf("    %s);\n", ENUMNAME(pPSD->PSTextureModes, 19, 15, tm));

    pListing->Printf("psd.PSInputTexture=PS_INPUTTEXTURE(%d,%d,%d,%d);\n", 
           0,
           0,
           ENUMVAL(pPSD->PSInputTexture, 16, 16),
           ENUMVAL(pPSD->PSInputTexture, 21, 20));

    pListing->Printf("psd.PSDotMapping=PS_DOTMAPPING(\n");
    pListing->Printf("    0,\n");
    pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSDotMapping,  2,  0, dm));
    pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSDotMapping,  6,  4, dm));
    pListing->Printf("    %s);\n", ENUMNAME(pPSD->PSDotMapping, 10,  8, dm));

    pListing->Printf("psd.PSCompareMode=PS_COMPAREMODE(\n");
    pListing->Printf("    %s | %s | %s | %s,\n",
           ENUMNAME(pPSD->PSCompareMode,  0,  0, cms),
           ENUMNAME(pPSD->PSCompareMode,  1,  1, cmt),
           ENUMNAME(pPSD->PSCompareMode,  2,  2, cmr),
           ENUMNAME(pPSD->PSCompareMode,  3,  3, cmq));
    pListing->Printf("    %s | %s | %s | %s,\n",
           ENUMNAME(pPSD->PSCompareMode,  4,  4, cms),
           ENUMNAME(pPSD->PSCompareMode,  5,  5, cmt),
           ENUMNAME(pPSD->PSCompareMode,  6,  6, cmr),
           ENUMNAME(pPSD->PSCompareMode,  7,  7, cmq));
    pListing->Printf("    %s | %s | %s | %s,\n",
           ENUMNAME(pPSD->PSCompareMode,  8,  8, cms),
           ENUMNAME(pPSD->PSCompareMode,  9,  9, cmt),
           ENUMNAME(pPSD->PSCompareMode, 10, 10, cmr),
           ENUMNAME(pPSD->PSCompareMode, 11, 11, cmq));
    pListing->Printf("    %s | %s | %s | %s);\n",
           ENUMNAME(pPSD->PSCompareMode, 12, 12, cms),
           ENUMNAME(pPSD->PSCompareMode, 13, 13, cmt),
           ENUMNAME(pPSD->PSCompareMode, 14, 14, cmr),
           ENUMNAME(pPSD->PSCompareMode, 15, 15, cmq));

    for(UINT i=0; i<stagecount; i++)
    {
        pListing->Printf("\n//------------- Stage %d -------------\n", i);
        pListing->Printf("psd.PSRGBInputs[%d]=PS_COMBINERINPUTS(\n", i);
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSRGBInputs[i], 27, 24, inreg),
            ENUMNAME(pPSD->PSRGBInputs[i], 28, 28, chanrgb),
            ENUMNAME(pPSD->PSRGBInputs[i], 31, 29, inmap));
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSRGBInputs[i], 19, 16, inreg),
            ENUMNAME(pPSD->PSRGBInputs[i], 20, 20, chanrgb),
            ENUMNAME(pPSD->PSRGBInputs[i], 23, 21, inmap));
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSRGBInputs[i], 11,  8, inreg),
            ENUMNAME(pPSD->PSRGBInputs[i], 12, 12, chanrgb),
            ENUMNAME(pPSD->PSRGBInputs[i], 15, 13, inmap));
        pListing->Printf("    %s | %s | %s);\n", 
            ENUMNAME(pPSD->PSRGBInputs[i],  3,  0, inreg),
            ENUMNAME(pPSD->PSRGBInputs[i],  4,  4, chanrgb),
            ENUMNAME(pPSD->PSRGBInputs[i],  7,  5, inmap));
        
        pListing->Printf("psd.PSAlphaInputs[%d]=PS_COMBINERINPUTS(\n", i);
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSAlphaInputs[i], 27, 24, inreg),
            ENUMNAME(pPSD->PSAlphaInputs[i], 28, 28, chanalpha),
            ENUMNAME(pPSD->PSAlphaInputs[i], 31, 29, inmap));
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSAlphaInputs[i], 19, 16, inreg),
            ENUMNAME(pPSD->PSAlphaInputs[i], 20, 20, chanalpha),
            ENUMNAME(pPSD->PSAlphaInputs[i], 23, 21, inmap));
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSAlphaInputs[i], 11,  8, inreg),
            ENUMNAME(pPSD->PSAlphaInputs[i], 12, 12, chanalpha),
            ENUMNAME(pPSD->PSAlphaInputs[i], 15, 13, inmap));
        pListing->Printf("    %s | %s | %s);\n", 
            ENUMNAME(pPSD->PSAlphaInputs[i],  3,  0, inreg),
            ENUMNAME(pPSD->PSAlphaInputs[i],  4,  4, chanalpha),
            ENUMNAME(pPSD->PSAlphaInputs[i],  7,  5, inmap));

        pListing->Printf("psd.PSRGBOutputs[%d]=PS_COMBINEROUTPUTS(\n", i);
        pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSRGBOutputs[i],  7,  4, outreg));
        pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSRGBOutputs[i],  3,  0, outreg));
        pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSRGBOutputs[i], 11,  8, outreg));
        pListing->Printf("    %s | %s | %s | %s",
               ENUMNAME(pPSD->PSRGBOutputs[i], 17, 15, outmap),
               ENUMNAME(pPSD->PSRGBOutputs[i], 13, 13, abmult),
               ENUMNAME(pPSD->PSRGBOutputs[i], 12, 12, cdmult),
               ENUMNAME(pPSD->PSRGBOutputs[i], 14, 14, muxsum));
        if(ENUMVAL(pPSD->PSRGBOutputs[i], 19, 19))
            pListing->Printf(" | PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA");
        if(ENUMVAL(pPSD->PSRGBOutputs[i], 18, 18))
            pListing->Printf(" | PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA");
        pListing->Printf(");\n");

        pListing->Printf("psd.PSAlphaOutputs[%d]=PS_COMBINEROUTPUTS(\n", i);
        pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSAlphaOutputs[i],  7,  4, outreg));
        pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSAlphaOutputs[i],  3,  0, outreg));
        pListing->Printf("    %s,\n", ENUMNAME(pPSD->PSAlphaOutputs[i], 11,  8, outreg));
        pListing->Printf("    %s | %s | %s | %s);\n",
               ENUMNAME(pPSD->PSAlphaOutputs[i], 17, 15, outmap),
               ENUMNAME(pPSD->PSAlphaOutputs[i], 13, 13, abmult),
               ENUMNAME(pPSD->PSAlphaOutputs[i], 12, 12, cdmult),
               ENUMNAME(pPSD->PSAlphaOutputs[i], 14, 14, muxsum));
        pListing->Printf("psd.PSConstant0[%d] = 0x%08x;\n", i, pPSD->PSConstant0[i]);
        pListing->Printf("psd.PSConstant1[%d] = 0x%08x;\n", i, pPSD->PSConstant1[i]);
    }

    // only print info on final combiner if it has been set
    if((pPSD->PSFinalCombinerInputsABCD | pPSD->PSFinalCombinerInputsEFG) != 0)
    {
        pListing->Printf("\n//------------- FinalCombiner -------------\n", i);
        pListing->Printf("psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(\n");
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 27, 24, inreg),
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 28, 28, chanrgb),
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 31, 29, inmap));
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 19, 16, inreg),
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 20, 20, chanrgb),
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 23, 21, inmap));
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 11,  8, inreg),
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 12, 12, chanrgb),
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD, 15, 13, inmap));
        pListing->Printf("    %s | %s | %s);\n", 
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD,  3,  0, inreg),
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD,  4,  4, chanrgb),
            ENUMNAME(pPSD->PSFinalCombinerInputsABCD,  7,  5, inmap));
        
        pListing->Printf("psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(\n");
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 27, 24, inreg),
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 28, 28, chanrgb),
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 31, 29, inmap));
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 19, 16, inreg),
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 20, 20, chanrgb),
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 23, 21, inmap));
        pListing->Printf("    %s | %s | %s,\n", 
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 11,  8, inreg),
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 12, 12, chanrgb),
            ENUMNAME(pPSD->PSFinalCombinerInputsEFG, 15, 13, inmap));
        
        if(ENUMVAL(pPSD->PSFinalCombinerInputsEFG, 7, 7))
            pListing->Printf("    PS_FINALCOMBINERSETTING_CLAMP_SUM");
        else
            pListing->Printf("    0");
        
        if(ENUMVAL(pPSD->PSFinalCombinerInputsEFG, 6, 6))
            pListing->Printf(" | PS_FINALCOMBINERSETTING_COMPLEMENT_V1");
        else
            pListing->Printf(" | 0");
        
        if(ENUMVAL(pPSD->PSFinalCombinerInputsEFG, 5, 5))
            pListing->Printf(" | PS_FINALCOMBINERSETTING_COMPLEMENT_R0);");
        else
            pListing->Printf(" | 0);\n");
        
        pListing->Printf("psd.PSFinalCombinerConstant0 = 0x%08x;\n", pPSD->PSFinalCombinerConstant0);
        pListing->Printf("psd.PSFinalCombinerConstant1 = 0x%08x;\n", pPSD->PSFinalCombinerConstant1);
    }
        
    pListing->Printf("\n");
    pListing->Printf("psd.PSC0Mapping = 0x%08x;\n", pPSD->PSC0Mapping);
    pListing->Printf("psd.PSC1Mapping = 0x%08x;\n", pPSD->PSC1Mapping);
    pListing->Printf("psd.PSFinalCombinerConstants = 0x%08x;\n", pPSD->PSFinalCombinerConstants);
}


} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\preprocessor.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////

// Poor man's C Preprocessor, with a few extensions to support vertex shader
// assembly language.
//
//
// Features:
//
// #ifdef FOO
// #ifndef FOO
// #else
// #endif
//
// #include "foo"
// #define FOO BAR
// #define FOO(X) ...
// #pragma FOO
// #undef FOO
// #error message
//
// NVASM style macros

#include "pchshadeasm.h"

// File-specific debugging hooks

#ifdef DBG
// #define DBG_PRINT_PREPROCESSED
#endif

namespace XGRAPHICS {

#define MAXLINE 300
#define MAX_INCLUDE_LEVELS 17
#define MAX_IF_LEVELS 20

#define TOKEN_SYMBOL 0
#define TOKEN_WS 1
#define TOKEN_OTHER 2
#define TOKEN_INT 3
#define TOKEN_EOS 4

static char* Copy(LPCSTR s){
	DWORD size = strlen(s);
	char* result = new char[size+1];
	if(result){
		memcpy(result,s,size+1);
	}
	return result;
}

class PreProcessor {
    // A simple struct for tokens

    class Token {
    public:
        DWORD type;
        const char* token;
        DWORD length;

        bool IsEqual(DWORD type, const char* s, DWORD length){
            return type == this->type && length == this->length &&
                strncmp(s,this->token,length) == 0;
        }
        bool IsEqual(char c){
            return type == TOKEN_OTHER && length == 1 &&
                token[0] == c;
        }
    };

    class Map;
    class Stack;

public:
	PreProcessor(){
        InEnum = false;
	}

	~PreProcessor(){
	}

	HRESULT Initialize(LPCSTR pSourceFileName,
		SASM_ResolverCallback pResolver,
		LPVOID pResolverUserData,
		LPXGBUFFER  pInput,
		LPXGBUFFER* pOutput,
		XD3DXErrorLog* pErrorLog)
	{
		HRESULT hr = S_OK;
		if(SUCCEEDED(hr)){
			hr = defines.Initialize(53);
		}
		if(SUCCEEDED(hr)){
			hr = macros.Initialize(20);
		}
        if(SUCCEEDED(hr)){
            hr = lineBuf.Initialize(MAXLINE);
        }
		if(SUCCEEDED(hr)){
			this->pResolver = pResolver;
			this->pResolverUserData = pResolverUserData;
			this->pBaseInput = pInput;
			this->pOutput = pOutput;
			this->pErrorLog = pErrorLog;
			currentIncludeLevel = 0;
			this->pInput = &fileStack[0];
			this->bAngleBracketsAreQuotes = false;
			strncpy(m_currentOutputFileName, pSourceFileName, sizeof(m_currentOutputFileName));
			m_currentOutputLine = 1;
			hr = this->pInput->Initialize(pBaseInput, pSourceFileName);
		}
		return hr;
	}

	HRESULT Preprocess(){
		HRESULT hr = S_OK;
		if(SUCCEEDED(hr)){
            bool moreWork = true;
			while(moreWork && SUCCEEDED(hr)){
                hr = MoreWorkToDo(moreWork);
                if(SUCCEEDED(hr)){
                    if(moreWork){
				        hr = DoLine(NULL);
                    }
                }
			}
		}
		if(SUCCEEDED(hr)){
			hr = XGBufferCreateFromBuffer(&outputBuffer,pOutput);
		}
		return hr;
	}
private:

	HRESULT MoreWorkToDo(bool& moreWork){
        HRESULT hr = S_OK;
		while( pInput->IsEOF() && SUCCEEDED(hr)) {
            if(pInput->InsideIfElse()){
                Error(true, ERROR_EXPECTEDENDIF, "Expected an #endif");
			    SETERROR(hr, E_FAIL);
                break;
            }
			if(currentIncludeLevel == 0){
				moreWork = false; // We're done
                return hr;
			}
			pInput--;
			currentIncludeLevel--;
		}
        moreWork = true;
		return hr;
	}

	bool InEnum;
    bool gotEnumOpen;
    bool gotEnumClose;
    int  EnumVal;


    HRESULT DoLine(char *pLine){
        HRESULT hr;
        if(pLine != NULL){
            hr = S_OK;
            lineBuf.Clear();
            lineBuf.Append(pLine);
        }
        else
            hr = FindLine(lineBuf);
		
		if(SUCCEEDED(hr)){
			const char* pDirective = FindDirective(lineBuf);
			if(pDirective){
				hr = DoDirective(pDirective);
			}
            else if(!pInput->IsActive()){
                // Do nothing
            }
            else {
                bool foundDecl = false;
                if(SUCCEEDED(hr)){
                    hr = CheckForMacroDeclaration(lineBuf, &foundDecl);
                }
                if(!foundDecl){

                    // keep a copy of lineBuf
                    Buffer oldLineBuf;
                    if(SUCCEEDED(hr)){
                        hr = oldLineBuf.Initialize(0);
                    }
                    if(SUCCEEDED(hr)){
                        hr = oldLineBuf.Append(lineBuf);
                    }

                    // First, define-macro-expand the line.
                    // Then check if it uses NVASM-macros.
                    // If it does, then expand them. As
                    // part of expanding the NVASM-macros,
                    // CheckForMacroUse will define-macro-expand
                    // the expanded NVASM-macro.
                   
                    if(SUCCEEDED(hr)){
				        hr = MacroExpand(lineBuf);
                    }

                    if(SUCCEEDED(hr)){
                        hr = CheckForMacroUse(lineBuf);
                    }
				    
                    if(SUCCEEDED(hr)){
                        if(strcmp(oldLineBuf.GetText(), lineBuf.GetText()) == 0){
                            // line not modified, process it
                            if(SUCCEEDED(hr)){
                                if(InEnum){
                                    // process part of an enum
                                    hr = DoEnumLine(lineBuf);
                                }
                                else{
                                    hr = CheckForEnum(lineBuf, &foundDecl);
                                    if(!foundDecl){
                                        // output if not modified 
                                        if(SUCCEEDED(hr)){
                                            hr = lineBuf.Append("\r\n");
                                        }
                                        if(SUCCEEDED(hr)){
                                            hr = Output(lineBuf);
                                        }
                                    }
                                }
                            }
                        }
                        else{
                            // modified, keep trying until no expansions can be done
                            // process one line at a time
                            char *pStart, *pEnd;
                            oldLineBuf.Clear(); // use as temp storage
                            if(SUCCEEDED(hr)){
                                hr = oldLineBuf.Append(lineBuf);
                            }
                            pEnd = oldLineBuf.GetText();
                            while(1){
                                pStart = pEnd;
                                while((*pEnd != '\0') && (*pEnd != '\n'))
                                    pEnd++;
                                if(*pEnd == '\0'){
                                    DoLine(pStart);
                                    break;
                                }
                                else{
                                    *pEnd = '\0';
                                    DoLine(pStart);
                                    pEnd++;
                                }
                            }
                        }
                    }
                }
			}
		}
		return hr;
	}

    HRESULT CheckForMacroDeclaration(Buffer& buffer, bool* pFoundDecl){
        HRESULT hr = S_OK;
        const char* p = buffer.GetText();
        Token token;
        bool foundDecl = false;
        if(SUCCEEDED(hr)){
            hr = GetToken(token, p, true);
        }
        if(SUCCEEDED(hr)){
            static const char kMacro[] = "macro";
            static const char kEndM[] = "endm";
            
            if(token.type == TOKEN_SYMBOL &&
                token.length == sizeof(kMacro)-1 &&
                strncmp(token.token, kMacro, sizeof(kMacro)-1) == 0){
                // This is a macro declaration.
                foundDecl = true;
                if(SUCCEEDED(hr)){
                    Token name;
                    hr = GetToken(name, p, true);
                    if(SUCCEEDED(hr)){
                        if(token.type == TOKEN_SYMBOL){
                            // Is this already defined?
                            if(macros.Lookup(name.token, name.length)){
                                // Already defined. Issue a warning
                                Error(false, ERROR_SYMBOLALREADYDEFINED,"This macro is already defined");
                                macros.Remove(name.token, name.length);
                            }
                            Buffer body;
                            bool dontDefineMacro = false;
                            if(SUCCEEDED(hr)){
                                hr = body.Initialize(400);
                            }
                            // After the macro name comes the argument list
                            if(SUCCEEDED(hr)){
                                hr = SkipWS(p); 
                            }
                            // Check for syntactic correctness
                            bool isLegal = false;
                            if(SUCCEEDED(hr)){
                                hr = IsLegalMacroDeclaration(p, NULL, &isLegal);
                            }
                            if(!isLegal){
                                dontDefineMacro = true;
                            }
                            if(SUCCEEDED(hr)){
                                hr = body.Append(p);
                            }
                            if(SUCCEEDED(hr)){ // Use a null to seperate the argument list from the body
                                hr = body.Append('\0');
                            }
                            // Now collect lines of input until we get an endm
                            Buffer tempBuf;
                            if(SUCCEEDED(hr)){
                                hr = tempBuf.Initialize(400);
                            }
                            bool endOfMacro = false;
                            if(SUCCEEDED(hr)){
                                bool firstLine = true;
                                Token endm;
                                do {
                                    if (pInput->IsEOF()){
                                        Error(true, ERROR_EXPECTEDENDM, "Expected endm before end of file.");
                                        break;
                                    }
                                    hr = FindLine(tempBuf);
                                    if(SUCCEEDED(hr)){
                                        const char* p = tempBuf.GetText();
                                        hr = GetToken(endm, p, true);
                                    }
                                    if(SUCCEEDED(hr)){
                                        if(endm.IsEqual(TOKEN_SYMBOL, kEndM, sizeof(kEndM)-1)){
                                            endOfMacro = true;
                                        }
                                    }
                                    if(SUCCEEDED(hr)){
                                        if(!endOfMacro){
                                            if(firstLine){
                                                firstLine = false;
                                            }
                                            else {
                                                body.Append("\n"); // Just newline, not \r\n
                                            }
                                            body.Append(tempBuf);
                                        }
                                    }
                                } while(SUCCEEDED(hr) && ! endOfMacro);
                            }
                            if(SUCCEEDED(hr) && endOfMacro && ! dontDefineMacro){
                                bool isLegal;
                                hr = IsLegalMacroDeclaration(p, body.GetText(), &isLegal);
                                if(SUCCEEDED(hr) && isLegal){
                                    hr = macros.Add(name.token, name.length, body.GetText(), body.GetUsed());
                                }
                            }
                        }
                        else {
                            Error(true,ERROR_EXPECTEDMACRONAME, "Expected macro name");
                        }
                        if(SUCCEEDED(hr)){
                            // We have parsed the macro, so output
                        }
                    }
                }
            }
        }
        
        *pFoundDecl = foundDecl;
        return hr;
    }

    
    HRESULT CheckForEnum(Buffer& buffer, bool* pFoundEnum){
        HRESULT hr;
        Token token;
        const char* p = buffer.GetText();
        hr = GetToken(token, p, true);
        if(SUCCEEDED(hr)){
            static const char kEnum[] = "enum";
            
            if(token.IsEqual(TOKEN_SYMBOL, kEnum, sizeof(kEnum)-1)){
                // This is an enum.
                InEnum = true;
                gotEnumOpen = false;
                gotEnumClose = false;
                EnumVal = -1;  // first entry defaults to 0 (enumval incremented before use)
                *pFoundEnum = true;
            }
        }
        return S_OK;
    }

    HRESULT DoEnumLine(Buffer& buffer){
        Token token;
        HRESULT hr;

        // Process each line of the enum
        const char* p;
        p = buffer.GetText();
        hr = GetToken(token, p, true);
        if(SUCCEEDED(hr)){
            if(token.IsEqual('{'))
                gotEnumOpen = true;
            else{
                if(!gotEnumOpen){
                    Error(true, ERROR_EXPECTEDOPENBRACE, "Missing open brace in enum.");
                    InEnum=false;
                    return E_FAIL;
                }
                if(token.IsEqual('}')){
                    gotEnumClose = true;
                    InEnum = false;
                }
                else{
                    // must be a symbol definition
                    // make sure we got a symbol
                    if(token.type != TOKEN_SYMBOL){
                        Error(true, ERROR_BADENUM, "Syntax error in enum.");
                        InEnum=false;
                        return E_FAIL;
                    }
                    Token nextTok;
                    hr = GetToken(nextTok, p, true);
                    if(SUCCEEDED(hr)){
                        if(nextTok.IsEqual('=')){
                            hr = GetToken(nextTok, p, true);
                            if(SUCCEEDED(hr)){
                                if(nextTok.type != TOKEN_INT){
                                    Error(true, ERROR_BADENUM, "Syntax error in enum.");
                                    InEnum=false;
                                    return E_FAIL;
                                }
                                EnumVal = atoi(nextTok.token);
                                hr = GetToken(nextTok, p, true);
                            }
                        }
                        else{
                            if(!nextTok.IsEqual(',') && (nextTok.type != TOKEN_EOS)){
                                Error(true, ERROR_BADENUM, "Syntax error in enum.");
                                InEnum=false;
                                return E_FAIL;
                            }
                            EnumVal++;
                        }
                    }
                    // add the define
                    char buf[256];
                    sprintf(buf+1, "%d", EnumVal);
                    buf[0] = '\0';
                    hr = defines.Add(token.token, token.length, buf, strlen(buf+1)+1);
                }
            }
        }
        return hr;
    }

    HRESULT IsLegalDefineArgList(const char* argList, bool* pIsLegal){
        bool isLegal = true;
        Token token;
        HRESULT hr = S_OK;
        Map args;
        hr = args.Initialize(10);
        if(*argList == '('){
            argList++;
        }
        else {
            Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected '('.");
            isLegal = false;
        }
        if(SUCCEEDED(hr) && isLegal){
            do {
                hr = GetToken(token, argList, true);
                if(SUCCEEDED(hr)){
                    if(token.type == TOKEN_SYMBOL){
                        if(args.Lookup(token.token, token.length)){
                            Error(true, ERROR_MACROARGUMENTSYNTAX, "Duplicate argument name.");
                            isLegal = false;
                            break;
                        }
                        hr = args.Add(token.token, token.length, "*", 1);
                    }
                    else if(token.type == TOKEN_EOS){
                        break;
                    }
                    else if(token.IsEqual(')')){
                        break;
                    }
                    else {
                        Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected argument name.");
                        isLegal = false;
                        break;
                    }
                }
                hr = GetToken(token, argList, true);
                if(SUCCEEDED(hr)){
                    if(token.IsEqual(',')){
                        // don't have to do anything
                    }
                    else if(token.IsEqual(')')){
                        break;
                    }
                    else {
                         Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected ',' or ')'.");
                        isLegal = false;
                        break;
                    }
                }
            } while(SUCCEEDED(hr));
        }
        if(pIsLegal){
            *pIsLegal = isLegal;
        }
        return hr;
    }

    HRESULT IsLegalMacroDeclaration(const char* argList, const char* body, bool* pIsLegal){
        bool isLegal = true;
        Token token;
        HRESULT hr = S_OK;
        Map args;
        hr = args.Initialize(10);
        if(SUCCEEDED(hr)){
            do {
                hr = GetToken(token, argList, true);
                if(SUCCEEDED(hr)){
                    if(token.type == TOKEN_SYMBOL){
                        if(args.Lookup(token.token, token.length)){
                            Error(true, ERROR_MACROARGUMENTSYNTAX, "Duplicate argument name.");
                            isLegal = false;
                            break;
                        }
                        hr = args.Add(token.token, token.length, "*", 1);
                    }
                    else if(token.type == TOKEN_EOS){
                        break;
                    }
                    else {
                        Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected argument name.");
                        isLegal = false;
                        break;
                    }
                }
                hr = GetToken(token, argList, true);
                if(SUCCEEDED(hr)){
                    if(token.IsEqual(',')){
                        // don't have to do anything
                    }
                    else if(token.type == TOKEN_EOS){
                        break;
                    }
                    else {
                        Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected comma.");
                        isLegal = false;
                        break;
                    }
                }
            } while(SUCCEEDED(hr));
        }
        
        // Now check the body to see that it has legal parmeters
        if(isLegal && body){
            const char* bodyp = body;
            do {
                Token bodyToken;
                hr = GetToken(bodyToken, bodyp, false);
                if(SUCCEEDED(hr)){
                    if(bodyToken.type == TOKEN_EOS){
                        break;
                    }
                    if(bodyToken.IsEqual('%')){
                        // It's a macro argument use.
                        hr = GetToken(bodyToken, bodyp, false);
                        if(SUCCEEDED(hr)){
                            if(bodyToken.type != TOKEN_SYMBOL){
                                Error(true,ERROR_EXPECTEDMACROPARAMETER, "Expected macro parameter.");
                                isLegal = false;
                                continue;
                            }
                            bool isIncDec = false;
                            if(bodyToken.IsEqual(TOKEN_SYMBOL, "inc", 3)){
                                isIncDec = true;
                            }
                            else if(bodyToken.IsEqual(TOKEN_SYMBOL, "dec", 3)){
                                isIncDec = true;
                            }
                            if(isIncDec){
                                bool isLegalIncDec = false;
                                hr = CheckLegalIncDecUse(args, bodyp, &isLegalIncDec);
                                if(SUCCEEDED(hr)){
                                    if(!isLegalIncDec){
                                        isLegal = false;
                                    }
                                }
                            }
                            else{
                                const char* val = args.Lookup(bodyToken.token, bodyToken.length);
                                if(val){
                                    // Nothing to do
                                }
                                else {
                                    Error(true,ERROR_EXPECTEDMACROPARAMETER, "Expected macro parameter name.");
                                    isLegal = false;
                                }
                            }
                        }
                    }
                    else {
                        // nothing to do
                    }
                }
            } while(SUCCEEDED(hr) && isLegal);
        }
        
        if(SUCCEEDED(hr)){
            *pIsLegal = isLegal;
        }
        return hr;
    }

    HRESULT CheckLegalIncDecUse(Map& args, const char*& bodyp, bool* pIsLegal){
        HRESULT hr = S_OK;
        // Syntax is '(' lots of stuff, nested correctly,  ')'
        Token token;
        bool isLegal = true;
        hr = GetIncDecArgList(token,bodyp);
        if(SUCCEEDED(hr)){
            if(token.type == TOKEN_SYMBOL){
                // now search through the contents, checking that all
                // the %foo symbols are known.
                do {
                    const char* p = token.token;
                    Token element;
                    hr = GetToken(element, p, true);
                    if(SUCCEEDED(hr)){
                        if(element.type == TOKEN_EOS){
                            break;
                        }
                        else if (element.IsEqual('%')){
                            hr = GetToken(token,bodyp, true);
                            if(SUCCEEDED(hr)){
                                if(token.type != TOKEN_SYMBOL){
                                    Error(true,ERROR_MACROARGUMENTSYNTAX,"Expected macro parameter");
                                    isLegal = false;
                                }
                                else {
                                    if(args.Lookup(token.token, token.length) == NULL){
                                        Error(true,ERROR_MACROARGUMENTSYNTAX,"Expected macro parameter");
                                        isLegal = false;
                                    }
                                }
                            }
                            
                        }
                        else {
                            // nothing to do
                        }
                    }
                } while(SUCCEEDED(hr) && isLegal);
            }
            else {
                Error(true,ERROR_MACROARGUMENTSYNTAX,"Expected an argument enclosed in parentheses");
                isLegal = false;
            }
        }
        if(pIsLegal){
            *pIsLegal = isLegal;
        }
        return hr;
    }

    HRESULT CheckForMacroUse(Buffer& buffer){
        HRESULT hr = S_OK;
        const char* p = buffer.GetText();
        Token token;
        if(SUCCEEDED(hr)){
            hr = GetToken(token, p, true);
        }
        if(SUCCEEDED(hr)){
            if(token.type == TOKEN_SYMBOL){
                const char* body = macros.Lookup(token.token, token.length);
                if(body){
                    Map args;
                    hr = args.Initialize(10);
                    const char* argp = body;
                    const char* bodyp = argp + strlen(argp) + 1;
                    bool argParseOK = true;
                    if(SUCCEEDED(hr)){
                        do {
                            Token argToken;
                            hr = GetToken(argToken, argp, true);
                            if(SUCCEEDED(hr)){
                                hr = GetMacroArgToken(token, p);
                            }
                            if(SUCCEEDED(hr)){
                                if(argToken.type == TOKEN_EOS && token.type != TOKEN_EOS){
                                    Error(true, ERROR_MACROARGUMENTSYNTAX, "Too many arguments");
                                    argParseOK = false;
                                }
                                else if(argToken.type != TOKEN_EOS && token.type == TOKEN_EOS){
                                    Error(true, ERROR_MACROARGUMENTSYNTAX, "Too few arguments");
                                    argParseOK = false;
                                }
                                else if(argToken.type == TOKEN_OTHER){
                                    if(token.type == TOKEN_OTHER
                                        && token.type == TOKEN_OTHER && argToken.token[0] == token.token[0]){
                                        // Good, we matched a comma
                                    }
                                    else {
                                        Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected a comma.");
                                        argParseOK = false;
                                    }
                                }
                                else if(argToken.type == TOKEN_EOS && token.type == TOKEN_EOS){
                                    break; // We're done with parsing the args
                                }
                                else if(argToken.type == TOKEN_SYMBOL && token.type == TOKEN_SYMBOL){
                                    hr = args.Add(argToken.token, argToken.length, token.token, token.length);
                                }
                                else {
                                    Error(true, ERROR_MACROARGUMENTSYNTAX, "Unexpected symbol.");
                                    argParseOK = false;
                                }
                            }
                        } while(SUCCEEDED(hr) && argParseOK);
                    }
                    if(SUCCEEDED(hr)){
                        if(argParseOK){
                            buffer.Clear();
                            hr = ProcessMacroBody(buffer, bodyp, args);
                            if(SUCCEEDED(hr)){
				                hr = MacroExpand(lineBuf);
                            }
                        }
                    }
                }
            }
        }
        return hr;
    }

    HRESULT ProcessMacroBody(Buffer& buffer, const char*& bodyp, Map& args){
        HRESULT hr = S_OK;
        // Output the macro body, substituting symbols as we go
        do {
            Token bodyToken;
            hr = GetToken(bodyToken, bodyp, false);
            if(SUCCEEDED(hr)){
                if(bodyToken.type == TOKEN_EOS){
                    break;
                }
                if(bodyToken.IsEqual('%')){
                    // It's a macro argument use.
                    hr = GetToken(bodyToken, bodyp, false);
                    if(SUCCEEDED(hr)){
                        if(bodyToken.type != TOKEN_SYMBOL){
                            Error(true,ERROR_EXPECTEDMACROPARAMETER, "Expected macro parameter.");
                            buffer.Append("%");
                            buffer.Append(bodyToken.token, bodyToken.length);
                            continue;
                        }
                        if(bodyToken.IsEqual(TOKEN_SYMBOL, "inc", 3)){
                            hr = ProcessIncDec(buffer, bodyp, args, 1);
                        }
                        else if(bodyToken.IsEqual(TOKEN_SYMBOL, "dec", 3)){
                            hr = ProcessIncDec(buffer, bodyp, args, -1);
                        }
                        else{
                            const char* val = args.Lookup(bodyToken.token, bodyToken.length);
                            if(val){
                                buffer.Append(val);
                            }
                            else {
                                Error(true,ERROR_EXPECTEDMACROPARAMETER, "Expected macro parameter.");
                            }
                        }
                    }
                }
                else {
                    buffer.Append(bodyToken.token, bodyToken.length);
                }
            }
        } while(SUCCEEDED(hr));
        return hr;
    }

    HRESULT ProcessIncDec(Buffer& buffer, const char*& bodyp, Map& args, int sign){
        HRESULT hr = S_OK;
        Token argList;
        hr = GetIncDecArgList(argList, bodyp);
        bool goodUse = true;
        Buffer incDecBuf;
        if(SUCCEEDED(hr)){
            hr = incDecBuf.Initialize(100);
        }
        if(SUCCEEDED(hr)){
            if(argList.type != TOKEN_SYMBOL){
                Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected parenthesized expression.");
                goodUse = false;
            }
            else {
                Buffer incDecInputBuf;
                hr = incDecInputBuf.Initialize(100);
                if(SUCCEEDED(hr)){
                    hr = incDecInputBuf.Append(argList.token, argList.length);
                }
                if(SUCCEEDED(hr)){
                    const char* inP = incDecInputBuf.GetText();
                    hr = ProcessMacroBody(incDecBuf, inP, args);
                }
            }
        }
        if(SUCCEEDED(hr) && goodUse){
            // Now we inc/dec

            const char* incDecBufP = incDecBuf.GetText(); 
            // If this is an explicit register number, increment it or decrement it
            Token prefix;
            Token op;
            Token number;
            hr = FindNumber(prefix, op, number, incDecBufP);
            if(SUCCEEDED(hr)){
                if(number.type == TOKEN_SYMBOL && number.length > 0){
                    // OK, we found a number.
                    int num = atoi(number.token);
                    char opc = op.token ? *op.token : '+';
                    // Normalize: subtracting becomes adding.
                    if(opc == '-'){
                        opc = '+';
                        num = -num;
                    }

                    int newNum = num + sign;

                    // At this point opc is '+'
                    // Normalize: adding a negative number becomes subtracting a positive number.
                    if(newNum < 0){
                        opc = '-';
                        newNum = -newNum;
                    }

                    char newNumber[12]; // enough space for -2000000000 
                    _itoa(newNum, newNumber, 10);
                    if(SUCCEEDED(hr)){
                        hr = buffer.Append(prefix.token, prefix.length); // Stuff before number
                    }

                    if(SUCCEEDED(hr)){
                        if(op.token ) { // the a0.x +/- # case
                            if ( newNum == 0) {
                            // output nothing
                            }
                            else {
                                hr = buffer.Append(opc);
                                if(SUCCEEDED(hr)){
                                    buffer.Append(newNumber);
                                }
                            }
                        }
                        else {
                            // The c# case
                            if( opc == '-'){
                                buffer.Append(opc);
                            }
                            buffer.Append(newNumber);
                        }
                    }

                    if(SUCCEEDED(hr)){
                        hr = buffer.Append(incDecBufP);
                    }
                }
                else {
                    // Wacky innermost constant mode.
                    const char* incDecBufStart = incDecBuf.GetText();
                    incDecBufP = incDecBufStart;
                    hr = FindInnermostItem(number, incDecBufP);
                    if(SUCCEEDED(hr)){
                        if(number.type == TOKEN_SYMBOL){
                            // OK, we found an innermost item.
                            hr = buffer.Append(incDecBufStart,incDecBufP - incDecBufStart); // Stuff before end of inner
                            if(SUCCEEDED(hr)){
                                hr = buffer.Append(sign >= 0 ? '+' : '-');
                            }
                            if(SUCCEEDED(hr)){
                                hr = buffer.Append('1');
                            }
                            if(SUCCEEDED(hr)){
                                hr = buffer.Append(incDecBufP);
                            }
                        }
                        else {
                            // Give up
                            Error(true, ERROR_MACROARGUMENTSYNTAX, "Couldn't find object to increment/decrement");
                            goodUse = false;
                        }
                    }
                }
            }
        }
        return S_OK;
    }
    
    HRESULT FindInnermostItem(Token& token, const char*& p){
        HRESULT hr = S_OK;
        char c;
        bool foundInner = false;
        while((c = *p) != '\0'){
            if(c == '(' || c == '['){
                token.token = p+1;
            }
            else if(c == ')' || c == ']'){
                token.type = TOKEN_SYMBOL;
                token.length = (p-token.token)-1;
                foundInner = true;
                break;
            }
            p++;
        }
        if(!foundInner){
            token.token = 0;
            token.length = 0;
            token.type = TOKEN_OTHER;
        }
        return hr;
    }

    HRESULT FindNumber(Token& prefix, Token& op, Token& number, const char*& p){
        HRESULT hr = S_OK;

        // Looking for <prefix> {+ | -} <num> <text>
        // Where text can contain a0.x
        // and num can start with a -

        char c;
        bool foundNum = false;
        op.type = 0;
        op.token = 0;
        op.length = 0;

        prefix.type = 0;
        prefix.token = p;
        prefix.length = 0;

        number.type = 0;
        number.token = 0;
        number.length = 0;

        enum State { ePrefix, ePlus, eMinus, eNumber, eDone };
        State state = ePrefix;
        
        bool foundA0x = false;

        while((c = *p) != '\0' && state != eDone){
            switch(state) {
            case ePrefix:
                {
                    if(c == 'a' && p[1] == '0' && p[2] == '.' && p[3] == 'x'){
                        // Skip over a0.x string
                        p += 3; // depends upon the p++ below.
                        foundA0x = true;
                    }
                    else if ( c == '+' && foundA0x ){
                        state = ePlus;
                        op.type = TOKEN_OTHER;
                        op.token = p;
                        op.length = 1;
                    }
                    else if ( c == '-'){
                        if(!foundA0x){
                            state = eNumber;
                            number.type = TOKEN_SYMBOL;
                            number.token = p;
                            number.length = 1;
                        }
                        else {
                            state = eMinus;
                            op.type = TOKEN_OTHER;
                            op.token = p;
                            op.length = 1;
                        }
                    }
                    else if ( c >= '0' && c <= '9' ){
                        state = eNumber;
                        number.type = TOKEN_SYMBOL;
                        number.token = p;
                        number.length = 1;
                    }
                    p++;
                    if(state == ePrefix){
                        prefix.length = p - prefix.token;
                    }
                }
                break;
            case eMinus:
            case ePlus:
                {
                    if(c == ' ' || c == '\t' || c == '\x1a'){
                        // do nothing
                    }
                    else if ( c == '-' || c >= '0' && c <= '9' ){
                        state = eNumber;
                        number.type = TOKEN_SYMBOL;
                        number.token = p;
                        number.length = 1;
                    }
                    else {
                        state = ePrefix;
                    }
                    p++;
                    if(state == ePrefix){
                        prefix.length = p - prefix.token;
                    }
                }
                break;
            case eNumber:
                {
                    if(c >= '0' && c <= '9'){
                       p++;
                       number.length++;
                    }
                    else {
                        state = eDone;
                    }
                }
                break;
            }
        }
        return hr;
    }

    const char* FindDirective(Buffer& buffer){
        const char* s = buffer.GetText();
        const char* sEnd = buffer.GetTextEnd();
        for(;s < sEnd; s++){
            if( *s == '#'){
                return s+1;
            }
            if( *s == ' ' || *s == '\t' || *s == '\x1a'){
                continue;
            }
            return NULL;
        }
        return NULL;
    }

	HRESULT DoDirective(const char* pDirective){
		HRESULT hr = S_OK;
		// Which directive is it?
		const char kInclude[] = "include";
		const char kDefine[] = "define";
        const char kPragma[] = "pragma";
        const char kUndef[] = "undef";
        const char kError[] = "error";
        const char kIf[] = "if";
        const char kIfdef[] = "ifdef";
        const char kIfndef[] = "ifndef";
        const char kElse[] = "else";
        const char kElif[] = "elif";
        const char kEndif[] = "endif";

        Token token;
        hr = GetToken(token, pDirective, true);
        if(SUCCEEDED(hr)){
            if(token.type != TOKEN_SYMBOL){
                Error(true, ERROR_UNKNOWNPREPROCESSORDIRECTIVE,"Unknown preprocessor directive");
 			    SETERROR(hr, E_FAIL);
		    }
        }

        if(SUCCEEDED(hr)){
            if( pInput->IsActive() ) {
		        if(token.length == sizeof(kInclude)-1
                    && strncmp(token.token, kInclude, sizeof(kInclude)-1) == 0){
			        hr = DoInclude(pDirective);
		        }
		        else if(token.length == sizeof(kDefine)-1
                    && strncmp(token.token, kDefine, sizeof(kDefine)-1) == 0){
			        hr = DoDefine(pDirective);
		        }
		        else if(token.length == sizeof(kPragma)-1
                    && strncmp(token.token, kPragma, sizeof(kPragma)-1) == 0){
			        hr = DoPragma(pDirective);
		        }
		        else if(token.length == sizeof(kUndef)-1
                    && strncmp(token.token, kUndef, sizeof(kUndef)-1) == 0){
			        hr = DoUndef(pDirective);
		        }
		        else if(token.length == sizeof(kError)-1
                    && strncmp(token.token, kError, sizeof(kError)-1) == 0){
			        hr = DoError(pDirective);
		        }
		        else if(token.length == sizeof(kIf)-1
                    && strncmp(token.token, kIf, sizeof(kIf)-1) == 0){
			        hr = DoIf(pDirective);
		        }
		        else if(token.length == sizeof(kIfdef)-1
                    && strncmp(token.token, kIfdef, sizeof(kIfdef)-1) == 0){
			        hr = DoIfdef(pDirective, true);
		        }
		        else if(token.length == sizeof(kIfndef)-1
                    && strncmp(token.token, kIfndef, sizeof(kIfndef)-1) == 0){
			        hr = DoIfdef(pDirective, false);
		        }
		        else if(token.length == sizeof(kElif)-1
                    && strncmp(token.token, kElif, sizeof(kElif)-1) == 0){
			        hr = DoElif(pDirective);
		        }
		        else if(token.length == sizeof(kElse)-1
                    && strncmp(token.token, kElse, sizeof(kElse)-1) == 0){
			        hr = DoElse(pDirective);
		        }
		        else if(token.length == sizeof(kEndif)-1
                    && strncmp(token.token, kEndif, sizeof(kEndif)-1) == 0){
			        hr = DoEndif(pDirective);
		        }
		        else {
			        // Unknown directive
			        Error(true, ERROR_UNKNOWNPREPROCESSORDIRECTIVE,"Unknown preprocessor directive"); 
			        SETERROR(hr, E_FAIL);
		        }
            }
            else {
                // inactive - just handle ifdefs
		        if(token.length == sizeof(kIf)-1
                    && strncmp(token.token, kIf, sizeof(kIf)-1) == 0){
			        hr = DoIf(pDirective);
		        }
		        else if(token.length == sizeof(kIfdef)-1
                    && strncmp(token.token, kIfdef, sizeof(kIfdef)-1) == 0){
			        hr = DoIfdef(pDirective, true);
		        }
		        else if(token.length == sizeof(kIfndef)-1
                    && strncmp(token.token, kIfndef, sizeof(kIfndef)-1) == 0){
			        hr = DoIfdef(pDirective, false);
		        }
		        else if(token.length == sizeof(kElif)-1
                    && strncmp(token.token, kElif, sizeof(kElif)-1) == 0){
			        hr = DoElif(pDirective);
		        }
		        else if(token.length == sizeof(kElse)-1
                    && strncmp(token.token, kElse, sizeof(kElse)-1) == 0){
			        hr = DoElse(pDirective);
		        }
		        else if(token.length == sizeof(kEndif)-1
                    && strncmp(token.token, kEndif, sizeof(kEndif)-1) == 0){
			        hr = DoEndif(pDirective);
		        }
            }
        }
		return hr;
	}

    HRESULT DoIf(const char* args){
        HRESULT hr = S_OK;
        if(pInput->IsActive()){
            Error(true, ERROR_DONTHANDLEIF, "#if is not supported.");
        }
        else {
            // allow this if it's #ifdefed out.
            hr = pInput->PushActiveLevel(false);
        }
        return hr;
    }

    HRESULT DoElif(const char* args){
        HRESULT hr = S_OK;
        if(pInput->IsActive()){
            Error(true, ERROR_DONTHANDLEIF, "#elif is not supported.");
        }
        else {
            // allow this if it's #ifdefed out. Doesn't change state.
        }
        return hr;
    }

    HRESULT DoIfdef(const char* args, bool ifdef /* true == ifdef, false == ifndef */){
		HRESULT hr = S_OK;
  		const char* p = args;
		Token token;
        bool defined = false;
		if(SUCCEEDED(hr)){
			hr = GetToken(token, p, true);
		}
		if(SUCCEEDED(hr)){
			if(token.type != TOKEN_SYMBOL){
				// Expected a symbol
				Error(true, ERROR_SYMBOLEXPECTED,"symbol expected");
				SETERROR(hr, E_FAIL);
			}
		}
		if(SUCCEEDED(hr)){
			if(defines.Lookup(token.token, token.length)){
				defined = true;
			}
		}
		if(SUCCEEDED(hr)){
            hr = pInput->PushActiveLevel(defined == ifdef);
            if(FAILED(hr)){
                Error(true, ERROR_TOOMANYLEVELSOFIF, "Too many nested levels of #ifdef/#ifndef in this file.");
            }
        }
 		return hr;
    }

    HRESULT DoElse(const char* args){
        HRESULT hr = S_OK;
        // ANSI compatability weenies would check to make sure that there are no tokens here.
        hr = pInput->ElseActiveLevel();
        if(FAILED(hr)){
            Error(true, ERROR_UNEXPECTEDELSE, "Unexpected #else");
        }
        return hr;
    }

    HRESULT DoEndif(const char* args){
        HRESULT hr = S_OK;
        // ANSI compatability weenies would check to make sure that there are no tokens here.
        hr = pInput->PopActiveLevel();
        if(FAILED(hr)){
            Error(true, ERROR_UNEXPECTEDENDIF, "Unexpected #endif");
        }
        return hr;
    }

    HRESULT DoError(const char* errorArgs){
        Error(true, ERROR_ERRORDIRECTIVE, errorArgs);
 		return E_FAIL;
    }

    HRESULT DoPragma(const char* pragmaArgs){
        // Just macro-expand and write out as-is
		HRESULT hr = MacroExpand(lineBuf);
		if(SUCCEEDED(hr)){
 			hr = Output(lineBuf);
		}
		return hr;
    }

	HRESULT DoDefine(const char* defineArgs){
		HRESULT hr = S_OK;
		const char* p = defineArgs;

		// Looking for a token, some white space, and then the rest of the line
		Token name;
		if(SUCCEEDED(hr)){
			hr = GetToken(name, p, true);
		}
		if(SUCCEEDED(hr)){
			if(name.type != TOKEN_SYMBOL){
				// Expected a symbol
				Error(true, ERROR_SYMBOLEXPECTED,"symbol expected");
				SETERROR(hr, E_FAIL);
			}
		}
		if(SUCCEEDED(hr)){
			// Is this already defined?
			if(defines.Lookup(name.token, name.length)){
				// Already defined. Just a warning (or should it be an error?)
				Error(false, ERROR_SYMBOLALREADYDEFINED,"This symbol is already defined");
				hr = DoUndef2(name.token, name.length);
			}
		}

        Buffer body;
        if(SUCCEEDED(hr)){
            hr = body.Initialize(400);
        }
		if(*p == '('){
			// #define with arguments
            const char* argListStart = p;
            Token t;
            do {
                hr = GetToken(t, p, true);
            } while ( SUCCEEDED(hr) &&
                ! (t.IsEqual(')') || t.type == TOKEN_EOS));
            if(SUCCEEDED(hr)){
                if(t.type == TOKEN_EOS){
                    Error(true,ERROR_EXPECTED_CLOSE_PAREN, "Expected ')'.");
				    SETERROR(hr, E_FAIL);
                }
            }
            if(SUCCEEDED(hr)){
                hr = body.Append(argListStart, p - argListStart);
            }
            if(SUCCEEDED(hr)){ // Use a null to seperate the argument list from the body
                hr = body.Append('\0');
            }
            // Append the rest of the macro
            if(SUCCEEDED(hr)){
                hr = SkipWS(p);
            }
            if(SUCCEEDED(hr)){
                hr = body.Append(p);
            }
            if(SUCCEEDED(hr)){
                bool isLegal;
                hr = IsLegalDefineArgList(body.GetText(), &isLegal);
                if(SUCCEEDED(hr) && isLegal){
                    hr = defines.Add(name.token, name.length, body.GetText(), body.GetUsed());
                }
            }
 		}
        else {
            // ordinary #define without arguments
            if(SUCCEEDED(hr)){
                hr = body.Append('\0'); // means no args
            }
            if(SUCCEEDED(hr)){
                hr = SkipWS(p);
            }
            if(SUCCEEDED(hr)){
                hr = body.Append(p);
            }
		    if(SUCCEEDED(hr)){
			    hr = defines.Add(name.token, name.length, body.GetText(), body.GetUsed());
		    }
        }
		return hr;
	}

	HRESULT DoUndef(const char* defineArgs){
		// Looking for a token
		const char* p = defineArgs;
		HRESULT hr = S_OK;
		Token key;
		if(SUCCEEDED(hr)){
			hr = GetToken(key, p, true);
		}
		if(SUCCEEDED(hr)){
			if(key.type != TOKEN_SYMBOL){
				// Expected a symbol
				Error(true, ERROR_SYMBOLEXPECTED,"symbol expected");
				SETERROR(hr, E_FAIL);
			}
		}
		if(SUCCEEDED(hr)){
            hr = DoUndef2(key.token, key.length);
		}
        return hr;
    }

    HRESULT DoUndef2(const char* key, DWORD keySize){
        defines.Remove(key, keySize);
        return S_OK;
    }

	static HRESULT SkipWS(const char*& p){
		HRESULT hr = S_OK;
		char c;
		while((c = *p) != '\0'){
            if(c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '\x1a'){
				p++;
			}
			else {
				break;
			}
		}
		return hr;
	}

	// Returns start and length of token.
	// Skips any preceeding white space

	static HRESULT GetToken(Token& token, const char*& p, bool skipWS){
		HRESULT hr = S_OK;
		if(skipWS){
			hr = SkipWS(p);
		}
		if(SUCCEEDED(hr)){
			token.token = p;
			// Find end of token
			char c = *p;
			if(c != '\0') {
				if ((c >= 'A' && c <= 'Z')
					|| (c >= 'a' && c <= 'z')
					|| (c == '_'))
				{
					// It's a symbol
					token.type = TOKEN_SYMBOL;
					while((c = *p) != '\0'){
						if((c >= 'A' && c <= 'Z')
							|| (c >= 'a' && c <= 'z')
							|| (c >= '0' && c <= '9')
							|| (c == '_'))
						{
							p++;
						}
						else {
							break;
						}
					}
				}
                else if ( c == ' ' || c == '\t' || c == '\x1a'){
					token.type = TOKEN_WS;
					while((c = *p) != '\0'){
                        if(c == ' ' || c == '\t' || c == '\x1a')
						{
							p++;
						}
						else {
							break;
						}
					}
				}
                else if ((c == '-') ||
                         (c == '+') ||
                         ((c >= '0') && (c <= '9')))
                {
                    // It's an integer
                    p++;
                    token.type = TOKEN_INT;
					while((c = *p) != '\0'){
						if((c >= '0' && c <= '9'))
							p++;
						else
							break;
					}
                }
                else {
					token.type = TOKEN_OTHER;
					p++; // Everything else is just a single character
				}
			}
            else {
                token.type = TOKEN_EOS;
            }
		}
		token.length = p - token.token;
		return hr;
	}

    static HRESULT GetDefineMacroArgToken(Token& token, const char*& p){
		HRESULT hr = S_OK;
		hr = SkipWS(p);
		if(SUCCEEDED(hr)){
			token.token = p;
			// Find end of token
			char c = *p;
			if(c != '\0') {
				if (c == ',' || c == ')')
				{
                    token.type = TOKEN_OTHER;
                    p++;
                }
                else {
					// It's a symbol
					token.type = TOKEN_SYMBOL;
                    int nestingLevel = 0;
					while((c = *p) != '\0' && (nestingLevel > 0 || !(c == ',' || c == ')'))){
                        switch(c){
                        case '(':
                            nestingLevel++;
                            break;
                        case ')':
                            nestingLevel--;
                            break;
                        default:
                            break;
                        }
                        p++;
                    }
				}
			}
            else {
                token.type = TOKEN_EOS;
            }
		}
		token.length = p - token.token;
		return hr;
	}

    static HRESULT GetMacroArgToken(Token& token, const char*& p){
		HRESULT hr = S_OK;
		hr = SkipWS(p);
		if(SUCCEEDED(hr)){
			token.token = p;
			// Find end of token
			char c = *p;
			if(c != '\0') {
				if (c == ',')
				{
                    token.type = TOKEN_OTHER;
                    p++;
                }
                else {
					// It's a symbol
					token.type = TOKEN_SYMBOL;
                    int nestingLevel = 0;
					while((c = *p) != '\0' && (nestingLevel > 0 || c != ',')){
                        switch(c){
                        case '(':
                            nestingLevel++;
                            break;
                        case ')':
                            nestingLevel--;
                            break;
                        default:
                            break;
                        }
                        p++;
                    }
				}
			}
            else {
                token.type = TOKEN_EOS;
            }
		}
		token.length = p - token.token;
		return hr;
	}

    static HRESULT GetIncDecArgList(Token& token, const char*& p){
        HRESULT hr = S_OK;
        hr = SkipWS(p);
        if(SUCCEEDED(hr)){
            token.token = p;
            // Find end of token
            char c = *p;
            if(c != '\0') {
                if (c == '('){
                    // It's a symbol
                    token.type = TOKEN_SYMBOL;
                    token.token = ++p;
                    int nestingLevel = 1;
                    while((c = *p) != '\0'){
                        switch(c){
                        case '(':
                            nestingLevel++;
                            break;
                        case ')':
                            nestingLevel--;
                            break;
                        default:
                            break;
                        }
                        if(nestingLevel == 0){
                            token.length = p - token.token;
                            p++; // eat closing paren too.
                            break;
                        }
                        p++;
                    }
                    if(nestingLevel){
                        token.type = TOKEN_OTHER;
                        token.length = 0;
                        token.token = 0;
                    }
                }
                else {
                    {
                        token.type = TOKEN_OTHER;
                        token.length = 0;
                        token.token = 0;
                    }
                }
            }
            else {
                token.type = TOKEN_EOS;
                token.length = 0;
                token.token = 0;
            }
        }
        return hr;
    }

	HRESULT DoInclude(const char* includeArgs0){
		HRESULT hr = S_OK;
		if(currentIncludeLevel >= MAX_INCLUDE_LEVELS-1){
			// Nested too deeply
			Error(true, ERROR_TOOMANYLEVELSOFINCLUDE,"Too many levels of include directives. Maximum of %d levels allowed.", MAX_INCLUDE_LEVELS);
			SETERROR(hr,E_FAIL);
		}

		if(SUCCEEDED(hr) && ! pResolver ) {
			// No file factory, so can't include anything.
			Error(true, ERROR_MISSINGRESOLVER,"Can't process #include because no resolver object was supplied to preprocessor function");
			SETERROR(hr,E_FAIL);
		}

		// Macroexpand the arguments

		Buffer argBuf;
		const char* includeArgs = 0;

		DWORD argLength = strlen(includeArgs0);
		hr = argBuf.Initialize(argLength);
		if(SUCCEEDED(hr)){
			hr = argBuf.Append(includeArgs0,argLength);
		}
		if(SUCCEEDED(hr)){
			bAngleBracketsAreQuotes = true;
			hr = MacroExpand(argBuf);
			bAngleBracketsAreQuotes = false;
		}
		if(SUCCEEDED(hr)){
			includeArgs = argBuf.GetText();
		}

		char filePath[MAX_PATH];
		BOOL isSystem;
		if(SUCCEEDED(hr)){
			hr = GetFilePath(includeArgs,filePath, sizeof(filePath), &isSystem);
		}
		if(SUCCEEDED(hr)){
			XGBuffer* pIncludeFile;
			char resolvedPath[MAX_PATH];
			hr = (*pResolver)(pResolverUserData, isSystem, pInput->m_fileName, filePath,
				resolvedPath, sizeof(resolvedPath), &pIncludeFile);
			if(SUCCEEDED(hr)){
				currentIncludeLevel++;
				pInput++;
				hr = pInput->Initialize(pIncludeFile, resolvedPath);
				pIncludeFile->Release(); // pInput is holding onto it now.
			}
			else {
				Error(true, ERROR_CANTOPENFILE, "Couldn't open include file.");
			}
		}
		return hr;
	}

	HRESULT GetFilePath(const char* includeArgs, char* filePath, DWORD filePathLength,
		BOOL* isSystem){
		// skip white space, looking for '"' or "<"
		const char* s = includeArgs;
		const char* filePathStart = 0;
		char c;
		while((c = *s++)){
            if(c == ' ' || c == '\t' || c == '\x1a'){
				continue;
			}
			else if(c == '"'){
				// Match double quotes
				*isSystem = FALSE;
				filePathStart = s;
				while((c = *s++)){
					if(c == '"'){
						goto maybeGood;
					}
				}
			}
			else if(c == '<'){
				*isSystem = TRUE;
				// Match angle brackets
				filePathStart = s;
				while((c = *s++)){
					if(c == '>'){
						goto maybeGood;
					}
				}
			}
			else {
				// Bad character, expected '<' or '"'
				Error(true, ERROR_FILENAMENOTQUOTED,"File names have to be quoted with <...> or \"...\"");
				return E_FAIL;
			}
		}
		Error(true, ERROR_FILENAMEMISSING,"Expected file name");
		return E_FAIL;

maybeGood:
		DWORD length = s - filePathStart;
		if(length > filePathLength){
			// Too long.
			Error(true, ERROR_INCLUDENAMETOOLONG,"Include file name too long.");
			return E_FAIL;
		}
		// OK
		memcpy(filePath,filePathStart,length-1);
		filePath[length-1] = '\0';
		return S_OK;
	}

	HRESULT MacroExpand(Buffer& b){
        HRESULT hr = S_OK;

        Map alreadyUsedMap;

        if(SUCCEEDED(hr)){
            hr = alreadyUsedMap.Initialize(10);
        }
        if(SUCCEEDED(hr)){
            hr = MacroExpand(b, alreadyUsedMap);
        }
        return hr;
     }

    HRESULT MacroExpand(Buffer& buf, Map& alreadyUsed){
        HRESULT hr = S_OK;
        Buffer out;
        if(SUCCEEDED(hr)){
            hr = out.Initialize(buf.GetUsed());
        }
        const char* in = buf.GetText();
        const char* inEnd = in + strlen(in);
        Buffer argExpandBuf;
        if(SUCCEEDED(hr)){
            hr = argExpandBuf.Initialize(10);
        }
		enum QuoteStateMachine {
			eNormal,
			eInsideQuotedString,
			eBackslash
		};
		QuoteStateMachine state = eNormal;
		char endQuote;
        while(SUCCEEDED(hr) && in < inEnd){
            Token token;
            hr = GetToken(token, in, false);
            if ( SUCCEEDED(hr)){
				switch(state){
				case eNormal:
					{
						if(token.type == TOKEN_SYMBOL){
							const char* value = defines.Lookup(token.token, token.length);
							if(value){
								if(! alreadyUsed.Lookup(token.token, token.length)){
									// It's a macro. Expand it here
									alreadyUsed.Add(token.token, token.length,"*",1);
									argExpandBuf.Clear();
									if(value[0] == '\0'){
										// A #define macro without arguments
										hr = argExpandBuf.Append(value+1);
									}
									else {
										hr = ExpandDefineMacroWithArgs(in, argExpandBuf, value);
									}
									if(SUCCEEDED(hr)){
										hr = MacroExpand(argExpandBuf,alreadyUsed);
									}
									alreadyUsed.Remove(token.token, token.length);
									if(SUCCEEDED(hr)){
										hr = out.Append(argExpandBuf);
									}
									if(FAILED(hr)){
										// Expanded line is too big for buffer.
										Error(true, ERROR_EXPANDEDMACROTOOLONG,"Expanded macro too long.");
									}
									continue;
								}
							}
						}
						else if(token.IsEqual('\'')){
							state = eInsideQuotedString;
							endQuote = '\'';
						}
						else if(token.IsEqual('"')){
							state = eInsideQuotedString;
							endQuote = '\"';
						}
						else if(bAngleBracketsAreQuotes &&
							token.IsEqual('<')){
							state = eInsideQuotedString;
							endQuote = '>';
						}
					}
					break;
				case eInsideQuotedString:
					{
						if(token.IsEqual('\\')){
							state = eBackslash;
						}
						else if(token.IsEqual(endQuote)){
							state = eNormal;
							endQuote = 0;
						}
					}
					break;
				case eBackslash:
					{
						state = eInsideQuotedString;
					}
					break;
				}
			}
			if(SUCCEEDED(hr)){
				// copy token to output
				hr = out.Append(token.token, token.length);
				if(FAILED(hr)) {
					// Expanded line is too big for buffer.
					Error(true, ERROR_EXPANDEDMACROTOOLONG,"Expanded macro too long.");
				}
				continue;
			}
		}
		if(SUCCEEDED(hr)){
			buf.Clear();
			buf.Append(out);
		}
		return hr;
	}

    HRESULT ExpandDefineMacroWithArgs(const char*& p, Buffer& buffer, const char* body){
        HRESULT hr = S_OK;
        // Match ( foo, bar, baz ) against ( sdfsdfs , sdfsdfs, sdfsdfs )
        Map args;
        hr = args.Initialize(10);
        const char* argp = body;
        const char* bodyp = argp + strlen(argp) + 1;
        bool argParseOK = true;
        bool bLookingForOpenParen = true;
        bool bMacroArgsComplete = false;
        if(SUCCEEDED(hr)){
            do {
                Token argToken; // from argument list
                Token token; // from input
                hr = GetToken(argToken, argp, true);
                if(SUCCEEDED(hr)){
                    if(bLookingForOpenParen){
                        // Handle first token, which is an open paren,
                        // specially. Otherwise GetMacroArgToken
                        // will grab the whole argument list as a single
                        // token.
                        bLookingForOpenParen = false;
                        hr = GetToken(token, p, true);
                        if(! token.IsEqual('(') ){
                            Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected '('");
                            argParseOK = false;
                        }
                    }
                    else {
                        if(bMacroArgsComplete){
                            token.type = TOKEN_EOS;
                        }
                        else {
                            hr = GetDefineMacroArgToken(token, p);
                        }
                    }
                }
                if(SUCCEEDED(hr) && argParseOK){
                    if(argToken.type == TOKEN_EOS && token.type != TOKEN_EOS){
                        Error(true, ERROR_MACROARGUMENTSYNTAX, "Too many arguments");
                        argParseOK = false;
                    }
                    else if(argToken.type != TOKEN_EOS && token.type == TOKEN_EOS){
                        Error(true, ERROR_MACROARGUMENTSYNTAX, "Too few arguments");
                        argParseOK = false;
                    }
                    else if(argToken.type == TOKEN_OTHER){
                        if(token.type == TOKEN_OTHER && argToken.token[0] == token.token[0]){
                            // Good, we matched an open-paren, comma or a close-paren
                            if(argToken.IsEqual(')')){
                                bMacroArgsComplete = true;
                            }
                        }
                        else {
                            Error(true, ERROR_MACROARGUMENTSYNTAX, "Expected a comma or a close paren.");
                            argParseOK = false;
                        }
                    }
                    else if(argToken.type == TOKEN_EOS && token.type == TOKEN_EOS){
                        break; // We're done with parsing the args
                    }
                    else if(argToken.type == TOKEN_SYMBOL && token.type == TOKEN_SYMBOL){
                        hr = args.Add(argToken.token, argToken.length, token.token, token.length);
                    }
                    else {
                        Error(true, ERROR_MACROARGUMENTSYNTAX, "Unexpected symbol.");
                        argParseOK = false;
                    }
                }
            } while(SUCCEEDED(hr) && argParseOK);
        }
        if(SUCCEEDED(hr)){
            if(argParseOK){
                buffer.Clear();
                hr = ProcessDefineMacroBody(buffer, bodyp, args);
            }
        }
        return hr;
    }

    HRESULT ProcessDefineMacroBody(Buffer& buffer, const char*& bodyp, Map& args){
        HRESULT hr = S_OK;
        // Output the define macro body, substituting symbols as we go
        do {
            Token bodyToken;
            hr = GetToken(bodyToken, bodyp, false);
            if(SUCCEEDED(hr)){
                if(bodyToken.type == TOKEN_EOS){
                    break;
                }
                if(bodyToken.type == TOKEN_SYMBOL){
                    const char* val = args.Lookup(bodyToken.token, bodyToken.length);
                    if(val){
                        hr = buffer.Append(val);
                        continue;
                    }
                }
                hr = buffer.Append(bodyToken.token, bodyToken.length);
            }
        } while(SUCCEEDED(hr));
        return hr;
    }

    void FormatAsStringConstant(LPSTR out, DWORD outSize, LPCSTR in){
		if(outSize == 0){
			return;
		}
		LPSTR outEnd = out + outSize;
		while(out < outEnd){
			char c = *in++;
			if(!c) {
				break;
			}
			if(c == '\\' || c == '"'){
				if(out + 1 >= outEnd) {
					break; // No room
				}
				*out++ = '\\';
			}
			*out++ = c;
		}
		if(out < outEnd){
			*out++ = 0;
		}
	}

	HRESULT Output(Buffer& buf){
		HRESULT hr = S_OK;
		
		// Do we need to emit "#line" information?

		bool needLine = false;
		bool needFile = false;

		if(strcmp(m_currentOutputFileName, pInput->m_fileName) != 0){
			strncpy(m_currentOutputFileName, pInput->m_fileName, sizeof(m_currentOutputFileName));
			needFile = true;
			needLine = true;
		}
		if(m_currentOutputLine != pInput->m_currentLine){
			m_currentOutputLine = pInput->m_currentLine;
			needLine = true;
		}
		if(SUCCEEDED(hr)) {
			if(needLine ) {
				if( needFile){
					char fileBuf[MAX_PATH * 2];
					FormatAsStringConstant(fileBuf, sizeof(fileBuf), m_currentOutputFileName);
					hr = OutputF("#line %d \"%s\"\n", m_currentOutputLine, m_currentOutputFileName);
				}
				else {
					hr = OutputF("#line %d\n", m_currentOutputLine);
				}
			}
		}
        if(SUCCEEDED(hr)){
            // Output the line. If this is a multi-line line, output a
            // #line directive every line, to make error reporting work correctly
            const char* pStart = buf.GetText();
            const char* p = pStart;
            bool firstLine = true;
            while(SUCCEEDED(hr) && *p){
                while(*p && *p != '\n'){
                    p++;
                }
                if(*p == '\n'){
                    ++p;
                    if(firstLine){
                        firstLine = false;
                    }
                    else{
                        hr = OutputF("#line %d\n", m_currentOutputLine);
                    }
                    hr = Output3(pStart, p-pStart);
                    pStart = p;
                }
            }
            if(SUCCEEDED(hr)){
                m_currentOutputLine++;
            }
            if(SUCCEEDED(hr)){
                if(pStart != p){ // Some text at the end that wasn't terminated with a \r\n
                    hr = Output3(pStart, p-pStart);
                    if(SUCCEEDED(hr)){
                        hr = Output2("\r\n");
                    }
                    if(SUCCEEDED(hr)){
                        m_currentOutputLine++;
                    }
                }
            }
        }
        return hr;
    }

	HRESULT OutputF(const char* szFormat, ...){
		char buf[256];
		va_list list;
		va_start(list, szFormat);
		_vsnprintf(buf, sizeof(buf), szFormat, list);
		buf[sizeof(buf)-1] = '\0';
		va_end(list);
		return Output2(buf);
	}

	HRESULT Output2(const char* s){
		return Output3(s, strlen(s));
	}

	HRESULT Output3(const char* s, size_t size){
#if !defined(XBOX) && defined(DBG_PRINT_PREPROCESSED)
        char buf[1000];
        memcpy(buf,s,size);
        buf[size] = 0;
		DPF(1,"%s", buf);
#endif
		return outputBuffer.Append(s, size);
	}

	HRESULT FindLine(Buffer& lineBuf){
		HRESULT hr = S_OK;
        lineBuf.Clear();
        if(! pInput->IsEOF()){
            hr = FindSingleLine(lineBuf);
        }
        return hr;
    }

	// A GetC that filters out backslash-escaped end-of-lines
	int FilteredGetC(){
		int c;
		for(;;) {
			c = pInput->GetC();
			if(c == '\\'){
				if(pInput->GuessC('\r')){
					pInput->GuessC('\n');
					continue;
				}
				else if(pInput->GuessC('\n')){
					continue;
				}
			}
			break;
		}
		return c;
	}

	bool FilteredGuessC(int guess){
		int c = FilteredGetC();
		bool result = c == guess;
		if(!result){
			pInput->UnGetC(c);
		}
		return result;
	}
		
	HRESULT FindSingleLine(Buffer& lineBuf){
		HRESULT hr = S_OK;
		while(! pInput->IsEOF() && SUCCEEDED(hr)){
			int c = FilteredGetC();
			if ( c == -1 ) {
				// EOF
				break;
			}
			switch(c){
			case '\r':
				{
					pInput->GuessC('\n'); // DOS style eol
					return S_OK;
				}
			case '\n':
				{
					// Unix style eol
					return S_OK;
				}
			case ';':
				{	// Assembler style comment
					// (If we could disable this, then
					// this preprocessor would handle C code, too.)
					// Skip until end of line
					SkipToEndOfLine();
					// that's a whole line
					return S_OK;
				}
				break;
			case '/':
				{
					int c2 = FilteredGetC();
					switch(c2){
					case '/': // C++ style comment
						{
					        SkipToEndOfLine();
							return S_OK;
						}
					case '*':
						{
							// Start of C style comment
							for(;;){
								if(pInput->IsEOF()){
									// This comment ran off the end of the file.
									Error(true, ERROR_UNTERMINATED_C_STYLE_COMMENT,
                                        "Un-terminated C-style comment. Expected \"*/\".");
									return E_FAIL;
								}
                                if(FilteredGetC() == '*'){
                                    if(FilteredGuessC('/')){
									    break;
                                    }
								}
							}
			                hr = lineBuf.Append(' '); // C-style comments turn into single spaces.
						}
						break;
					default:
						{
							pInput->UnGetC(c2); // Not a comment after all
							hr = lineBuf.Append((char) c);
						}
					}
				} // End of forward slash processing
				break;
			default:
				{
					hr = lineBuf.Append((char) c);
				}
			}
		}
        if(FAILED(hr)){
            Error(true, ERROR_SOURCELINETOOLONG, "Source line too long.");
        }
		// Ran off the end of the input buffer, treat as normal end-of-line
		return hr;
	}

    void SkipToEndOfLine(){
        int c2;
		while((c2 = FilteredGetC()) != -1){
            if(c2 == '\r' || c2 == '\n'){
                if(c2 == '\r'){
			        FilteredGuessC('\n');
		        }
                break;
            }
		}
    }

	void Error(bool error, DWORD code, const char* szFormat,...){
		if(pErrorLog){
			char szA[512];

			va_list ap;
			va_start(ap, szFormat);
			_vsnprintf(szA, sizeof(szA), szFormat, ap);
			szA[sizeof(szA)-1] = '\0';
			va_end(ap);
			
			pErrorLog->Log(error, code + 2000, pInput->m_fileName, pInput->m_currentLine, szA);
		}
	}

	// Nested classes

	// Holds macro definitions

	class Map {
	public:
		Map(){
			table = 0;
			tableSize = 0;
		}
		~Map(){
			Cleanup();
		}

		void Cleanup(){
			for(DWORD i = 0; i < tableSize; i++){
				Entry* pEntry = table[i];
				delete pEntry;
			}
			delete [] table;
			table = 0;
			tableSize = 0;
		}

		HRESULT Initialize(DWORD initialTableSize){
			Cleanup();
            tableSize = initialTableSize;
			table = new PENTRY[tableSize];
			if(!table){
                tableSize = 0;
				return E_OUTOFMEMORY;
			}
			memset(table,0, sizeof(Entry*) * tableSize);
			return S_OK;
		}

		HRESULT Add(const char* key, DWORD keySize,
			const char* value, DWORD valueSize){
			if(Lookup(key,keySize) || ! table){
				return E_FAIL;
			}
			DWORD hash = Hash(key, keySize);
			Entry** ppEntry = &table[hash % tableSize];
			PENTRY entry = new Entry();
			HRESULT hr = entry->Initialize(key, keySize, value, valueSize);
			if(SUCCEEDED(hr)){
				if(! *ppEntry){
					*ppEntry = entry;
				}
				else{
					entry->next = *ppEntry;
					*ppEntry = entry;
				}
			}
			return hr;
		}

		const char* Lookup(const char* key, DWORD keySize){
			if(!table){
				return NULL;
			}
            DWORD hash = Hash(key, keySize);
			Entry* pEntry = table[hash % tableSize];
			while(pEntry){
				if(pEntry->keySize == keySize){
					if(strncmp(key, pEntry->key, keySize)==0){
						return pEntry->value;
					}
				}
				pEntry = pEntry->next;
			}
			return NULL;
		}

        void Remove(const char* key, DWORD keySize){
			if(!table){
				return;
			}
			DWORD hash = Hash(key, keySize);
            DWORD hashIndex = hash % tableSize;
			Entry* pEntry = table[hashIndex];
            Entry* pPrev = NULL;
			while(pEntry){
				if(pEntry->keySize == keySize){
					if(strncmp(key, pEntry->key, keySize)==0){
                        if(pPrev){
                            pPrev->next = pEntry->next;
                        }
                        else {
                            table[hashIndex] = pEntry->next;
                        }
                        pEntry->next = NULL; // Break association so pEntry's destructor
                                             // doesn't delete the rest of the chain
                        delete pEntry;
						return;
					}
				}
                pPrev = pEntry;
				pEntry = pEntry->next;
			}
		}

	private:


		// This hash function was originally developed for the Visual Basic 7
		// StringPool class.

		DWORD Hash(const char* key, DWORD keySize)
		{
		    const BYTE *pb = (const BYTE *)key;
		    const BYTE *pbEnd = pb + keySize;

		    DWORD hash = 0;

		    while (pb != pbEnd)
		    {
		        BYTE b = *pb++;
		        hash = _lrotl(hash, 1) + b * 0x10204081;
		    }

		    return hash;
		}

		class Entry {
		public:
			Entry(){
				next = 0;
				key = 0;
				value = 0;
			}

			~Entry(){
				Clean();
			}

			void Clean(){
				delete next; next = 0;
				delete [] key; key = 0;
				delete [] value; value = 0;
			}

			HRESULT Initialize(const char* key, DWORD keySize,
				const char* value, DWORD valueSize){
				Clean();
				HRESULT hr = Copy(this->key, key, keySize);
				this->keySize = keySize;
				if(SUCCEEDED(hr)){
					hr = Copy(this->value, value, valueSize);
				}
				return hr;
			}

			HRESULT Copy(char*& dest, const char* source, DWORD sourceSize){
				dest = new char[sourceSize+1];
				if(!dest){
					return E_OUTOFMEMORY;
				}
				memcpy(dest,source,sourceSize);
				dest[sourceSize] = '\0';
				return S_OK;
			}

			Entry* next;
			char* key;
			DWORD keySize;
			char* value;
		};

		typedef Entry* PENTRY;

		PENTRY* table;
		DWORD tableSize;
	};

	// Makes it easy to handle input.

#define kNoLevel (~0)

	class InputBuffer {
	public:
		InputBuffer(){
			this->pReadFile = 0;
			isEOF = true;
			validSize = 0;
			readIndex = 0;
			unGetCMode = false;
			m_fileName = NULL;
		}

		// Can be called multiple times. Closes old file each time
		HRESULT Initialize(LPXGBUFFER pReadFile, LPCSTR fileName){

			// Close old file if it's still open
			Close();

			this->pReadFile = pReadFile;
			pReadFile->AddRef();
			buffer = pReadFile->GetBufferPointer();
			validSize = pReadFile->GetBufferSize();
			readIndex = 0;
			isEOF = false;
			unGetCMode = false;
			m_fileName = Copy(fileName);
			m_currentLine = 1;
			isEOL = false;
			wasEOL = false;
            ifLevel = kNoLevel;
            isActive = true;
			return S_OK;
		}

		~InputBuffer(){
			Close();
			delete [] m_fileName;
		}

		int GetC() {
			int c;
			wasEOL = isEOL;
			if(isEOL){
				m_currentLine++;
				isEOL = false;
			}
			if(! unGetCMode && readIndex < validSize){
				c = ((unsigned char*) buffer)[readIndex++];
			}
			else {
				c = FullGetC();
			}
			if(c == '\n'){
				isEOL = true;
			}
			return c;
		}

		int PeekC(){
			int c = GetC();
			if(c != -1){
				UnGetC(c);
			}
			return c;
		}

		bool GuessC(char guess){
			int c = GetC();
			bool result = c == guess;
			if( ! result ) {
				UnGetC(c);
			}
			return result;
		}

		void UnGetC(int c){
			if(c != -1){
				unGetCMode = true;
				unGetCChar = (char) c;
				isEOL = wasEOL;
				if(wasEOL){
					m_currentLine--;
				}
			}
		}

		inline bool IsEOF() {
			return ! unGetCMode && isEOF;
		}

        bool IsActive(){
            return isActive;
        }

        void ComputeActive(){
            bool active = true;
            if(ifLevel != kNoLevel){
                for(DWORD i = 0; i <= ifLevel; i++){
                    if(!ifActive[i]){
                        active = false;
                        break;
                    }
                }
            }
            isActive = active;
        }

        HRESULT PushActiveLevel(bool isActive){
            HRESULT hr = S_OK;
            if(ifLevel == kNoLevel){
                ifLevel = 0;
            }
            else if(ifLevel >= MAX_IF_LEVELS-1){
                hr = E_FAIL;
            }
            else {
                ifLevel++;
            }
            if(SUCCEEDED(hr)){
                ifActive[ifLevel] = isActive;
                seenElse[ifLevel] = false;
                ComputeActive();
            }
            return hr;
        }

        HRESULT ElseActiveLevel(){
            HRESULT hr = S_OK;
            if(ifLevel == kNoLevel){
                hr = E_FAIL;
            }
            if(SUCCEEDED(hr)){
                if(seenElse[ifLevel]){
                    hr = E_FAIL;
                }
            }
            if(SUCCEEDED(hr)){
                seenElse[ifLevel] = true;
                ifActive[ifLevel] = ! ifActive[ifLevel];
                ComputeActive();
            }
            return hr;
        }

        HRESULT PopActiveLevel(){
            HRESULT hr = S_OK;
            if(ifLevel == kNoLevel){
                hr = E_FAIL;
            }
            else if(ifLevel == 0){
                ifLevel = kNoLevel;
            }
            else {
                ifLevel--;
            }
            if(SUCCEEDED(hr)){
                ComputeActive();
            }
            return hr;
        }

        DWORD InsideIfElse(){
            return ifLevel != kNoLevel;
        }

	private:
		void Close(){
			if(!isEOF){
				if(pReadFile){
					pReadFile->Release();
                    pReadFile = 0;
				}
			}
			isEOF = true;
		}

		int FullGetC(){
			if(unGetCMode){
				unGetCMode = false;
				return unGetCChar;
			}
			if(readIndex < validSize){
				return ((unsigned char*) buffer)[readIndex++];
			}
			if(isEOF){
				return -1;
			}
			Close();
			return -1;
		}

		LPXGBUFFER pReadFile;
		LPCVOID buffer;
		DWORD validSize;
		DWORD readIndex;
		bool isEOF;
		bool unGetCMode;
		char unGetCChar;
		bool isEOL; // Current character is EOL
		bool wasEOL; // Last character read was EOL character

        bool isActive; // true means we should process input
        DWORD ifLevel; // how deeply we're nested into ifdefs
        bool ifActive[MAX_IF_LEVELS];
        bool seenElse[MAX_IF_LEVELS];
	public:
		DWORD m_currentLine;
		char* m_fileName;
	};

	// Instance variables

	Buffer lineBuf;

	SASM_ResolverCallback pResolver;
	LPVOID pResolverUserData;
	LPXGBUFFER  pBaseInput;
	Buffer outputBuffer;
	LPXGBUFFER* pOutput;
	XD3DXErrorLog* pErrorLog;

	char* pDst;

	InputBuffer* pInput;
	DWORD currentIncludeLevel;
	InputBuffer fileStack[MAX_INCLUDE_LEVELS];

	Map defines;
    Map macros; // NVASM style macros

	// For #file and #line directive generation
	char m_currentOutputFileName[MAX_PATH];
	DWORD m_currentOutputLine;

	bool bAngleBracketsAreQuotes; // For processing #include directives
};

HRESULT
XGPreprocess(LPCSTR pSourceFileName,
	SASM_ResolverCallback pResolver,
	LPVOID pResolverUserData,
	LPXGBUFFER  pInput,
	LPXGBUFFER* pOutput,
	XD3DXErrorLog* pErrorLog)
{
	HRESULT hr = S_OK;
	PreProcessor* p = new PreProcessor();
	if ( ! p ){
		hr = E_OUTOFMEMORY;
	}
	if ( SUCCEEDED(hr) ){
		hr = p->Initialize(pSourceFileName, pResolver, pResolverUserData,
			pInput, pOutput, pErrorLog);
	}
	if ( SUCCEEDED(hr) ){
		hr = p->Preprocess();
	}
	delete p;
	return hr;
}

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\microcodeformat.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// Microcode structures, enumerations, and macros, for the xbox vertex shader
///////////////////////////////////////////////////////////////////////////////

#define MAC_NOP        0x00
#define MAC_MOV        0x01
#define MAC_MUL        0x02
#define MAC_ADD        0x03
#define MAC_MAD        0x04
#define MAC_DP3        0x05
#define MAC_DPH        0x06
#define MAC_DP4        0x07
#define MAC_DST        0x08
#define MAC_MIN        0x09
#define MAC_MAX        0x0a
#define MAC_SLT        0x0b
#define MAC_SGE        0x0c
#define MAC_ARL        0x0d

#define ILU_NOP        0x00
#define ILU_MOV        0x01
#define ILU_RCP        0x02
#define ILU_RCC        0x03
#define ILU_RSQ        0x04
#define ILU_EXP        0x05
#define ILU_LOG        0x06
#define ILU_LIT        0x07

#define CSW_X                     0x00  // take swizzled source from x
#define CSW_Y                     0x01  // ...from y
#define CSW_Z                     0x02  // ...from z
#define CSW_W                     0x03  // ...from w

#define MX_M                      0     // mux select
#define MX_R                      1     // mux select scratch (a.k.a. temporary) register
#define MX_V                      2     // mux select input (a.k.a. vertex attribute) register
#define MX_C                      3     // mux select context (a.k.a. parameter/constant) register
#define MX_O                      MX_M

#define OM_MAC                    0x00  // output mux selects value produced by MLU/ALU
#define OM_ILU                    0x01  // output mux selects value produced by ILU

typedef struct _D3DVsInstruction {
    unsigned long eos:1;        /* 0:00 last instruction */
    unsigned long cin:1;        /* 0:01 ctx indexed address */
    unsigned long  om:1;        /* 0:02 output mux */
    unsigned long  oc:9;        /* 0:03 output write control */
    unsigned long owm:4;        /* 0:12 output write mask */
    unsigned long swm:4;        /* 0:16 secondary register write mask */
    unsigned long  rw:4;        /* 0:20 register write */
    unsigned long rwm:4;        /* 0:24 primary register write mask */
    unsigned long cmx:2;        /* 0:28 c mux (NA,r1,v,c) */
    unsigned long crr:4;        /* 0:30 c register read */
    unsigned long cws:2;        /* 1:02 c w swizzle */
    unsigned long czs:2;        /* 1:04 c z swizzle */
    unsigned long cys:2;        /* 1:06 c y swizzle */
    unsigned long cxs:2;        /* 1:08 c x swizzle */
    unsigned long cne:1;        /* 1:10 c negate */
    unsigned long bmx:2;        /* 1:11 b mux (NA,r1,v,c) */
    unsigned long brr:4;        /* 1:13 b register read */
    unsigned long bws:2;        /* 1:17 b w swizzle */
    unsigned long bzs:2;        /* 1:19 b z swizzle */
    unsigned long bys:2;        /* 1:21 b y swizzle */
    unsigned long bxs:2;        /* 1:23 b x swizzle */
    unsigned long bne:1;        /* 1:25 b negate */
    unsigned long amx:2;        /* 1:26 a mux (NA,r0,v,c) */
    unsigned long arr:4;        /* 1:28 a register read */
    unsigned long aws:2;        /* 2:00 a w swizzle */
    unsigned long azs:2;        /* 2:02 a z swizzle */
    unsigned long ays:2;        /* 2:04 a y swizzle */
    unsigned long axs:2;        /* 2:06 a x swizzle */
    unsigned long ane:1;        /* 2:08 a negate */
    unsigned long  va:4;        /* 2:09 ibuffer address */
    unsigned long  ca:8;        /* 2:13 ctx address */
    unsigned long mac:4;        /* 2:21 MLU/ALU op */
    unsigned long ilu:3;        /* 2:25 ILU op */
} D3DVsInstruction;


#define MAX_MICROCODE_LENGTH (136*3)

// a program that's been fully compiled and assembled into kelvin microcode
typedef struct _D3DVertexShaderProgram {
    long length;
    D3DVsInstruction ucode[MAX_MICROCODE_LENGTH];
} D3DVertexShaderProgram, *PD3DVertexShaderProgram;


#define PGM_UWORDW(pucode) ((pucode->eos << 0) |\
                            (pucode->cin << 1) |\
                            (pucode->om  << 2) |\
                            (pucode->oc  << 3) |\
                            (pucode->owm <<12) |\
                            (pucode->swm <<16) |\
                            (pucode->rw  <<20) |\
                            (pucode->rwm <<24) |\
                            (pucode->cmx <<28) |\
                            (pucode->crr <<30))

#define PGM_UWORDZ(pucode) ((pucode->crr >> 2) |\
                            (pucode->cws << 2) |\
                            (pucode->czs << 4) |\
                            (pucode->cys << 6) |\
                            (pucode->cxs << 8) |\
                            (pucode->cne <<10) |\
                            (pucode->bmx <<11) |\
                            (pucode->brr <<13) |\
                            (pucode->bws <<17) |\
                            (pucode->bzs <<19) |\
                            (pucode->bys <<21) |\
                            (pucode->bxs <<23) |\
                            (pucode->bne <<25) |\
                            (pucode->amx <<26) |\
                            (pucode->arr <<28))

#define PGM_UWORDY(pucode) ((pucode->aws << 0) |\
                            (pucode->azs << 2) |\
                            (pucode->ays << 4) |\
                            (pucode->axs << 6) |\
                            (pucode->ane << 8) |\
                            (pucode->va  << 9) |\
                            (pucode->ca  <<13) |\
                            (pucode->mac <<21) |\
                            (pucode->ilu <<25))

#define PGM_UWORDX(pucode) 0


//internal register enumeration

#pragma warning(disable:4244)
typedef enum Register_Enum {

    REG_V0 = 0,   REG_V_OPOS = 0,  
	REG_V1 = 1,   REG_V_WGHT = 1,
    REG_V2 = 2,   REG_V_NRML = 2,  
	REG_V3 = 3,   REG_V_COL0 = 3,
    REG_V4 = 4,   REG_V_COL1 = 4,  
	REG_V5 = 5,   REG_V_FOGC = 5,
    REG_V6 = 6,                    
	REG_V7 = 7,
    REG_V8 = 8,   REG_V_TEX0 = 8,  
	REG_V9 = 9,   REG_V_TEX1 = 9,
    REG_V10 = 10, REG_V_TEX2 = 10, 
	REG_V11 = 11, REG_V_TEX3 = 11,
    REG_V12 = 12, REG_V_TEX4 = 12, 
	REG_V13 = 13, REG_V_TEX5 = 13,
    REG_V14 = 14, REG_V_TEX6 = 14, 
	REG_V15 = 15, REG_V_TEX7 = 15,

    REG_O0 = 16,  REG_oPos = REG_O0,
    REG_O1 = 17,  
    REG_O2 = 18,  
    REG_O3 = 19,  REG_oD0  = REG_O3,
    REG_O4 = 20,  REG_oD1  = REG_O4,
    REG_O5 = 21,  REG_oFog = REG_O5,
    REG_O6 = 22,  REG_oPts = REG_O6,
    REG_O7 = 23,  REG_oB0  = REG_O7,
    REG_O8 = 24,  REG_oB1  = REG_O8,
    REG_O9 = 25,  REG_oT0  = REG_O9,
    REG_O10 = 26, REG_oT1  = REG_O10,
    REG_O11 = 27, REG_oT2  = REG_O11,
    REG_O12 = 28, REG_oT3  = REG_O12,
    REG_O13 = 29, REG_oT4  = REG_O13,
    REG_O14 = 30, REG_oT5  = REG_O14,
    REG_O15 = 31, REG_oT6  = REG_O15,

	//note: REG_C0 corresponds with c-96, REG_C95 is c-1, etc. 
	//todo: We don't really need these...
    REG_C0 = 32,   
	/*REG_C1 = 33,   REG_C2 = 34,   REG_C3 = 35,
    REG_C4 = 36,   REG_C5 = 37,   REG_C6 = 38,   REG_C7 = 39,
    REG_C8 = 40,   REG_C9 = 41,   REG_C10 = 42,  REG_C11 = 43,
    REG_C12 = 44,  REG_C13 = 45,  REG_C14 = 46,  REG_C15 = 47,
    REG_C16 = 48,  REG_C17 = 49,  REG_C18 = 50,  REG_C19 = 51,
    REG_C20 = 52,  REG_C21 = 53,  REG_C22 = 54,  REG_C23 = 55,
    REG_C24 = 56,  REG_C25 = 57,  REG_C26 = 58,  REG_C27 = 59,
    REG_C28 = 60,  REG_C29 = 61,  REG_C30 = 62,  REG_C31 = 63,
    REG_C32 = 64,  REG_C33 = 65,  REG_C34 = 66,  REG_C35 = 67,
    REG_C36 = 68,  REG_C37 = 69,  REG_C38 = 70,  REG_C39 = 71,
    REG_C40 = 72,  REG_C41 = 73,  REG_C42 = 74,  REG_C43 = 75,
    REG_C44 = 76,  REG_C45 = 77,  REG_C46 = 78,  REG_C47 = 79,
    REG_C48 = 80,  REG_C49 = 81,  REG_C50 = 82,  REG_C51 = 83,
    REG_C52 = 84,  REG_C53 = 85,  REG_C54 = 86,  REG_C55 = 87,
    REG_C56 = 88,  REG_C57 = 89,  REG_C58 = 90,  REG_C59 = 91,
    REG_C60 = 92,  REG_C61 = 93,  REG_C62 = 94,  REG_C63 = 95,
    REG_C64 = 96,  REG_C65 = 97,  REG_C66 = 98,  REG_C67 = 99,
    REG_C68 = 100, REG_C69 = 101, REG_C70 = 102, REG_C71 = 103,
    REG_C72 = 104, REG_C73 = 105, REG_C74 = 106, REG_C75 = 107,
    REG_C76 = 108, REG_C77 = 109, REG_C78 = 110, REG_C79 = 111,
    REG_C80 = 112, REG_C81 = 113, REG_C82 = 114, REG_C83 = 115,
    REG_C84 = 116, REG_C85 = 117, REG_C86 = 118, REG_C87 = 119,
    REG_C88 = 120, REG_C89 = 121, REG_C90 = 122, REG_C91 = 123,
    REG_C92 = 124, REG_C93 = 125, REG_C94 = 126, */REG_C95 = 127,
	// Also 128..223

    REG_R0 = 128+96,  REG_R1 = 129+96,  REG_R2 = 130+96,  REG_R3 = 131+96,
    REG_R4 = 132+96,  REG_R5 = 133+96,  REG_R6 = 134+96,  REG_R7 = 135+96,
    REG_R8 = 136+96,  REG_R9 = 137+96,  REG_R10 = 138+96, REG_R11 = 139+96,
	
	//the following aren't valid, but are used for spacing...
    REG_R12 = 140+96, REG_R13 = 141+96, REG_R14 = 142+96, REG_R15 = 143+96,

    REG_ARL = 144+96,

    REG_ZER = 145+96,

} Register_t;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\pchshadeasm.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////

//
// D3DX core precompiled header
//

#ifndef __PCHCORE_H__
#define __PCHCORE_H__

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>

#ifdef XBOX
#include <xgrphseg.h>
#include <xtl.h>
#include <xboxverp.h>
#else
#include "windows.h"
#include "d3d8-xbox.h"
#include "../../../private/inc/xboxverp.h"

#endif // XBOX

#ifndef __D3DX8MATH_H__

typedef struct D3DXVECTOR4
{
    FLOAT x, y, z, w;
} D3DXVECTOR4, *LPD3DXVECTOR4;

#endif

#include "xgraphics.h"
#include "debug.h"

#include "microcodeformat.h"

namespace XGRAPHICS {

struct XD3DXErrorLog {
    virtual HRESULT Log(bool error, DWORD errorCode, LPCSTR filePath, DWORD line, LPCSTR message) = 0;
};

class Buffer {
    DWORD m_size;
    char* m_buf;
    DWORD m_used;

public:
    Buffer();
    ~Buffer();
    HRESULT Initialize(DWORD size);
    HRESULT GrowTo(DWORD size);
    HRESULT Printf(const char* msg,...);
    HRESULT Append(LPCVOID data, DWORD length);
    HRESULT Append(char c);
    HRESULT Append(const char* c);
    HRESULT Append(Buffer& buffer);
    char* GetText();
    char* GetTextEnd();
    DWORD GetUsed();
    void Clear();
};

// A Constructor for XGBUFFER that copies data from a Buffer object

HRESULT XGBufferCreateFromBuffer(Buffer* pBuf, LPXGBUFFER* ppXGBuf);


HRESULT
XGPreprocess(LPCSTR pSourceFileName,
    SASM_ResolverCallback pResolver,
    LPVOID pResolverUserData,
    LPXGBUFFER  pInput,
    LPXGBUFFER* pOutput,
    XD3DXErrorLog* pErrorLog);

} // namespace XGRAPHICS

#include "CD3DXStack.h"
#include "CD3DXAssembler.h"

namespace XGRAPHICS {

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)

// Uncomment this if you want to break into the debugger when an error occurs
// #define BREAK_ON_ERROR

#if defined(DBG) && defined(BREAK_ON_ERROR)
#define SETERROR(HR,CODE) \
    do { \
if(FAILED((HR) = (CODE))){ \
            DebugBreak(); \
        } \
    } while(0)
#else
#define SETERROR(HR,CODE) \
    ((HR) = (CODE))
#endif

// Just to get things to compile

#define D3DXASSERT(X) ASSERT(X)

#define D3DXERR_INVALIDDATA E_FAIL

#define D3DVS_TEMPREG_MAX_V1_1 12
#define D3DVS_INPUTREG_MAX_V1_1 16
#define D3DVS_ADDRREG_MAX_V1_1 1
#define D3DVS_ATTROUTREG_MAX_V1_1 2
#define D3DVS_TCRDOUTREG_MAX_V1_1 4

#ifndef MAKEFOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))


#endif

#define XBOX_EXTENSIONS

// Source operand addressing modes

typedef enum _D3DVS_ADDRESSMODE_TYPE
{
    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),   // Relative to register A0
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVS_ADDRESSMODE_TYPE;

HRESULT CompilePixelShaderToUCode(bool optimize, DWORD shaderType,
                                  LPXGBUFFER pTokenizedShader, 
                                  LPXGBUFFER* ppCompiledShader,
                                  Buffer* pListing,
                                  XD3DXErrorLog* pErrorLog);

} // namespace XGRAPHICS

// shader validator
#include "valbase.h"
#include "vshdrval.h"
#include "pshdrval.h"
#include "errorcodes.h"

#endif //__PCHCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\pshdrval.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.hpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __PSHDRVAL_HPP__
#define __PSHDRVAL_HPP__

namespace XGRAPHICS {

#define D3DSIO_TEXBEM_LEGACY    ((D3DSHADER_INSTRUCTION_OPCODE_TYPE)0xC001)
#define D3DSIO_TEXBEML_LEGACY   ((D3DSHADER_INSTRUCTION_OPCODE_TYPE)0xC002)

#define PS_INST_TOKEN_RESERVED_MASK         0xbfff0000 // bits 16-23, 24-29, 31 must be 0
#define PS_DSTPARAM_TOKEN_RESERVED_MASK     0x0000ff00 // bits 8-14 must be 0
#define PS_SRCPARAM_TOKEN_RESERVED_MASK     0x40006000 // bits 13-14, 30 must be 0

//-----------------------------------------------------------------------------
// CPSInstruction
//-----------------------------------------------------------------------------
class CPSInstruction : public CBaseInstruction
{
public:
    CPSInstruction(CPSInstruction* pPrevInst) : CBaseInstruction(pPrevInst)
    {
        m_bTexOp                    = FALSE;
        m_bTexMOp                   = FALSE;
        m_bTexOpThatReadsTexture    = FALSE;
    };

    void CalculateComponentReadMasks();

    BOOL    m_bTexOp;
    BOOL    m_bTexMOp;
    BOOL    m_bTexOpThatReadsTexture;
};

//-----------------------------------------------------------------------------
// CPShaderValidator
//-----------------------------------------------------------------------------
class CPShaderValidator : public CBaseShaderValidator
{
private:
    BOOL            m_bXbox;
    BOOL            m_bXFCUsed;
    UINT            m_TexOpCount;
    UINT            m_BlendOpCount;
    UINT            m_TotalOpCount; // not necessarily the sum of TexOpCount and BlendOpCount....
    UINT            m_TexMBaseDstReg;

    CRegisterFile*  m_pTempRegFile;    
    CRegisterFile*  m_pInputRegFile;
    CRegisterFile*  m_pConstRegFile;
    CRegisterFile*  m_pTextureRegFile;

    CBaseInstruction* AllocateNewInstruction(CBaseInstruction*pPrevInst);
    BOOL DecodeNextInstruction();
    BOOL InitValidation();
    BOOL ApplyPerInstructionRules();
    void ApplyPostInstructionsRules();
    void IsCurrInstTexOp();

    BOOL Rule_InstructionRecognized();
    BOOL Rule_InstructionSupportedByVersion();
    BOOL Rule_ValidParamCount();
    BOOL Rule_ValidSrcParams(); 
    BOOL Rule_NegateAfterSat();
    BOOL Rule_SatBeforeBiasOrComplement();
    BOOL Rule_MultipleDependentTextureReads();
    BOOL Rule_SrcNoLongerAvailable(); 
    BOOL Rule_SrcInitialized();
    BOOL Rule_ValidDstParam();
    BOOL Rule_ValidRegisterPortUsage();
    BOOL Rule_TexRegsDeclaredInOrder();
    BOOL Rule_TexOpAfterNonTexOp();
    BOOL Rule_ValidTEXM3xSequence();               // Call per instruction AND after all instructions seen
    BOOL Rule_ValidTEXM3xRegisterNumbers();
    BOOL Rule_ValidCNDInstruction();
    BOOL Rule_ValidLRPInstruction();
    BOOL Rule_ValidDEFInstruction();
    BOOL Rule_ValidDP3Instruction();
    BOOL Rule_ValidInstructionPairing();
    BOOL Rule_ValidInstructionCount();             // Call per instruction AND after all instructions seen
    BOOL Rule_R0Written();                         // Call after all instructions seen.
        
public:
    CPShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags,
        XD3DXErrorLog* pLog);
    ~CPShaderValidator();
};

HRESULT WINAPI ValidatePixelShader( const DWORD* pCode,
                                    const D3DCAPS8* pCaps,
                                    const DWORD Flags,
                                    XD3DXErrorLog* pLog);

} // namespace XGRAPHICS

#endif __PSHDRVAL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\pshdrval.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.cpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pchshadeasm.h"

namespace XGRAPHICS {


// Use these macros when looking at CPSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_PS_INST   ((CPSInstruction*)m_pCurrInst)
#define _PREV_PS_INST   (m_pCurrInst?((CPSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

//-----------------------------------------------------------------------------
// PixelShader Validation Rule Coverage
//
// Below is the list of rules in "DX8 PixelShader Version Specification",
// matched to the function(s) in this file which enforce them.
// Note that the mapping from rules to funtions can be 1->n or n->1
//
// Generic Rules
// -------------
//
// PS-G1:           Rule_R0Written
// PS-G2:           Rule_SrcInitialized
// PS-G3:           Rule_ValidDstParam
//
// TEX Op Specific Rules
// ---------------------
//
// PS-T1:           Rule_TexOpAfterNonTexOp
// PS-T2:           Rule_ValidDstParam
// PS-T3:           Rule_ValidDstParam, Rule_ValidSrcParams
// PS-T4:           Rule_TexRegsDeclaredInOrder
// PS-T5:           Rule_SrcInitialized
// PS-T6:           Rule_ValidTEXM3xSequence, Rule_ValidTEXM3xRegisterNumbers, Rule_InstructionSupportedByVersion
// PS-T7:           Rule_ValidSrcParams
//
// Co-Issue Specific Rules
// -----------------------
//
// PS-C1:           Rule_ValidInstructionPairing
// PS-C2:           Rule_ValidInstructionPairing
// PS-C3:           Rule_ValidInstructionPairing
// PS-C4:           Rule_ValidInstructionPairing
// PS-C5:           Rule_ValidInstructionPairing
//
// Instruction Specific Rules
// --------------------------
//
// PS-I1:           Rule_ValidLRPInstruction
// PS-I2:           Rule_ValidCNDInstruction
// PS-I3:           Rule_ValidDstParam
// PS-I4:           Rule_ValidDP3Instruction
// PS-I5:           Rule_ValidInstructionCount
//
// Pixel Shader Version 1.0 Rules
// ------------------------------
//
// PS.1.0-1:        InitValidation,
//                  Rule_SrcInitialized
// PS.1.0-2:        Rule_ValidInstructionPairing
// PS.1.0-3:        <empty rule>
// PS.1.0-4:        Rule_ValidInstructionCount
// PS.1.0-5:        <empty rule>

//
// Pixel Shader Version 1.1 Rules
// ------------------------------
//
// PS.1.1-1:        Rule_ValidDstParam
// PS.1.1-2:        Rule_ValidSrcParams
// PS.1.1-3:        Rule_SrcNoLongerAvailable
// PS.1.1-4:        Rule_SrcNoLongerAvailable
// PS.1.1-5:        Rule_SrcNoLongerAvailable
// PS.1.1-6:        Rule_ValidDstParam
// PS.1.1-8:        Rule_MultipleDependentTextureReads
// PS.1.1-9:        <not validated - implemented by refrast though>
//
// Pixel Shader Version 255.255 Rules
// ----------------------------------
//
// PS.255.255-1:    Rule_ValidTEXM3xSequence, Rule_ValidTEXM3xRegisterNumbers, Rule_InstructionSupportedByVersion
// PS.255.255-2:    Rule_TexOpAfterNonTexOp, Rule_TexRegsDeclaredInOrder
// PS.255.255-3:    Rule_ValidCNDInstruction
// PS.255.255-4:    <not validated - implemented by refrast though>
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CPSInstruction::CalculateComponentReadMasks()
//-----------------------------------------------------------------------------
void CPSInstruction::CalculateComponentReadMasks()
{
    BOOL bR, bG, bB, bA;

    // The only instruction that has source registers but no destination register is the 
    // XFC instruction.  If this is the XFC instruction, and the source swizzle is identity,
    // assume the read mask is rgb for all sources except G which is b.
    for( UINT i = 0; i < m_SrcParamCount; i++ )
    {
        bR=FALSE, bG=FALSE; bB=FALSE; bA=FALSE;
        if(m_DstParam[0].m_bParamUsed)
        {
            // destination is used
            if(m_DstParam[0].m_WriteMask & D3DSP_WRITEMASK_0) bR = TRUE;
            if(m_DstParam[0].m_WriteMask & D3DSP_WRITEMASK_1) bG = TRUE;
            if(m_DstParam[0].m_WriteMask & D3DSP_WRITEMASK_2) bB = TRUE;
            if(m_DstParam[0].m_WriteMask & D3DSP_WRITEMASK_3) bA = TRUE;
        }
        else
        {
            // first six xfc instruction read .rgb by default, last one reads just .b
            if(i <= 5)
                bR = bG = bB = TRUE;
            else
                bB = TRUE;
        }
        
        // DP3 instruction does not read alpha
        if(D3DSIO_DP3 == m_Type)
            bA = FALSE;

        BOOL read[4] = {FALSE, FALSE, FALSE, FALSE};
        if(bR)
            read[(m_SrcParam[i].m_SwizzleShift >> (D3DSP_SWIZZLE_SHIFT + 0)) & 0x3] = TRUE;
        if(bG)
            read[(m_SrcParam[i].m_SwizzleShift >> (D3DSP_SWIZZLE_SHIFT + 2)) & 0x3] = TRUE;
        if(bB)
            read[(m_SrcParam[i].m_SwizzleShift >> (D3DSP_SWIZZLE_SHIFT + 4)) & 0x3] = TRUE;
        if(bA)
            read[(m_SrcParam[i].m_SwizzleShift >> (D3DSP_SWIZZLE_SHIFT + 6)) & 0x3] = TRUE;
        
        m_SrcParam[i].m_ComponentReadMask = 0;
        if(read[0])
            m_SrcParam[i].m_ComponentReadMask |= D3DSP_WRITEMASK_0;
        if(read[1])
            m_SrcParam[i].m_ComponentReadMask |= D3DSP_WRITEMASK_1;
        if(read[2])
            m_SrcParam[i].m_ComponentReadMask |= D3DSP_WRITEMASK_2;
        if(read[3])
            m_SrcParam[i].m_ComponentReadMask |= D3DSP_WRITEMASK_3;
    }
}

//-----------------------------------------------------------------------------
// CPShaderValidator::CPShaderValidator
//-----------------------------------------------------------------------------
CPShaderValidator::CPShaderValidator(   const DWORD* pCode,
                                        const D3DCAPS8* pCaps,
                                        DWORD Flags,
                                        XD3DXErrorLog* pLog)
                                        : CBaseShaderValidator( pCode, pCaps, Flags, pLog )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.
    // Only set m_ReturnCode to S_OK if validation has succeeded,
    // before exiting this constructor.

    m_bXFCUsed              = FALSE;

    m_TexOpCount            = 0;
    m_BlendOpCount          = 0;
    m_TotalOpCount          = 0;
    m_TexMBaseDstReg        = 0;

    m_pTempRegFile          = NULL;
    m_pInputRegFile         = NULL;
    m_pConstRegFile         = NULL;
    m_pTextureRegFile       = NULL;

    if( !m_bBaseInitOk )
        return;

    ValidateShader(); // If successful, m_ReturnCode will be set to S_OK.
                      // Call GetStatus() on this object to determine validation outcome.
}

//-----------------------------------------------------------------------------
// CPShaderValidator::~CPShaderValidator
//-----------------------------------------------------------------------------
CPShaderValidator::~CPShaderValidator()
{
    delete m_pTempRegFile;
    delete m_pInputRegFile;
    delete m_pConstRegFile;
    delete m_pTextureRegFile;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::AllocateNewInstruction
//-----------------------------------------------------------------------------
CBaseInstruction* CPShaderValidator::AllocateNewInstruction(CBaseInstruction*pPrevInst)
{
    return new CPSInstruction((CPSInstruction*)pPrevInst);
}

//-----------------------------------------------------------------------------
// CPShaderValidator::DecodeNextInstruction
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::DecodeNextInstruction()
{
    m_pCurrInst->m_Type = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)(*m_pCurrToken & D3DSI_OPCODE_MASK);

    if( m_pCurrInst->m_Type == D3DSIO_COMMENT )
    {
        ParseCommentForAssemblerMessages(m_pCurrToken); // does not advance m_pCurrToken

        // Skip comments
        DWORD NumDWORDs = ((*m_pCurrToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
        m_pCurrToken += (NumDWORDs+1);
        return TRUE;
    }

    // If the assembler has sent us file and/or line number messages,
    // received by ParseCommentForAssemblerMesssages(),
    // then bind this information to the current instruction.
    // This info can be used in error spew to direct the shader developer
    // to exactly where a problem is located.
    m_pCurrInst->SetSpewFileNameAndLineNumber(m_pLatestSpewFileName,m_pLatestSpewLineNumber);

    if( *m_pCurrToken & D3DSI_COISSUE )
    {
        _CURR_PS_INST->m_bCoIssue = TRUE;
    }
    else
    {
        m_CycleNum++; // First cycle is 1. (co-issued instructions will have same cycle number)
    }
    _CURR_PS_INST->m_CycleNum = m_CycleNum;

    m_SpewInstructionCount++; // only used for spew, not for any limits
    m_pCurrInst->m_SpewInstructionCount = m_SpewInstructionCount;

    if( (*m_pCurrToken) & PS_INST_TOKEN_RESERVED_MASK )
    {
        Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in instruction parameter token!  Aborting validation.");
        return FALSE;
    }

    m_pCurrToken++;

    // Decode dst param
    DWORD dstCount;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
    case D3DSIO_XFC:
        dstCount = 0;
        break;
    case D3DSIO_XMMA:
    case D3DSIO_XMMC:
        dstCount = 3;
        break;
    case D3DSIO_XDM:
    case D3DSIO_XDD:
        dstCount = 2;
        break;
    default:
        dstCount = 1;
        break;
    }
    while ((*m_pCurrToken & (1L<<31)) && (dstCount-- > 0))
    {
        (m_pCurrInst->m_DstParamCount)++;
        DecodeDstParam( m_pCurrInst->m_Type, &m_pCurrInst->m_DstParam[m_pCurrInst->m_DstParamCount - 1], *m_pCurrToken );
        if( (*m_pCurrToken) & PS_DSTPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in destination parameter token!  Aborting validation.");
            return FALSE;
        }
        m_pCurrToken++;
        if( D3DSIO_DEF == m_pCurrInst->m_Type )
        {
            // Skip source params (float vector) - nothing to check
            // This is the only instruction with 4 source params,
            // and further, this is the only instruction that has
            // raw numbers as parameters.  This justifies the
            // special case treatment here - we pretend
            // D3DSIO_DEF only has a dst param (which we will check).
            m_pCurrToken += 4;
            return TRUE;
        }
    }

    // Decode src param(s)
    while (*m_pCurrToken & (1L<<31))
    {
        (m_pCurrInst->m_SrcParamCount)++;
        if( (m_pCurrInst->m_SrcParamCount + m_pCurrInst->m_DstParamCount) > SHADER_INSTRUCTION_MAX_PARAMS )
        {
            m_pCurrToken++; // eat up extra parameters and skip to next
            continue;
        }

        // Below: index is [SrcParamCount - 1] because m_SrcParam array needs 0 based index.
        DecodeSrcParam( &(m_pCurrInst->m_SrcParam[m_pCurrInst->m_SrcParamCount - 1]),*m_pCurrToken );

        if( (*m_pCurrToken) & PS_SRCPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in source %d parameter token!  Aborting validation.",
                            m_pCurrInst->m_SrcParamCount);
            return FALSE;
        }
        m_pCurrToken++;
    }

    // Figure out which components of each source operand actually need to be read,
    // taking into account destination write mask, the type of instruction, source swizzle, etc.
    m_pCurrInst->CalculateComponentReadMasks();

    // Find out if the instruction is a TexOp and/or TexMOp.  Needed by multiple validation rules.
    IsCurrInstTexOp();

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::IsCurrInstTexOp
//-----------------------------------------------------------------------------
void CPShaderValidator::IsCurrInstTexOp()
{
    DXGASSERT(m_pCurrInst);

    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3DIFF:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXM3x2DEPTH:
        _CURR_PS_INST->m_bTexMOp = TRUE;
        // fall through
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXBEM_LEGACY:
    case D3DSIO_TEXBEML_LEGACY:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXBRDF:
#if 0 // Doesn't seem to be defined in Xbox
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
#endif
        _CURR_PS_INST->m_bTexOp = TRUE;
        break;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
#if 0 // Doesn't seem to be defined in Xbox
    case D3DSIO_TEXDP3:
#endif
        _CURR_PS_INST->m_bTexOpThatReadsTexture = FALSE;
        break;
    case D3DSIO_TEX:
    case D3DSIO_TEXM3x3DIFF:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXBEM_LEGACY:
    case D3DSIO_TEXBEML_LEGACY:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXBRDF:
#if 0 // Doesn't seem to be defined in Xbox
    case D3DSIO_TEXREG2RGB:
#endif
        _CURR_PS_INST->m_bTexOpThatReadsTexture = TRUE;
        break;
    }
}

//-----------------------------------------------------------------------------
// CPShaderValidator::InitValidation
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::InitValidation()
{
    switch( m_Version >> 16 )
    {
    case 0xfffe:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****.",
                m_Version);
        return FALSE;
    case 0xffff:
        break; // pixelshader - ok.
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation.",
                m_Version);
        return FALSE;
    }

    if( m_pCaps )
    {
        if( (m_pCaps->PixelShaderVersion & 0x0000FFFF) < (m_Version & 0x0000FFFF)
            && !(m_Version == D3DPS_VERSION(0xff,0xff))) // not a 255.255 shader - that is always allowed
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Pixel shader version %d.%d is too high for device.  Maximum supported version is %d.%d. Aborting shader validation.",
                    D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version),
                    D3DSHADER_VERSION_MAJOR(m_pCaps->PixelShaderVersion),D3DSHADER_VERSION_MINOR(m_pCaps->PixelShaderVersion));
            return FALSE;
        }
    }

    switch(m_Version)
    {
    case D3DPS_VERSION(1,0):    // DX7.5
        m_pTempRegFile      = new CRegisterFile(2,TRUE,2); // #regs, bWritable, max# reads/instruction
        m_pInputRegFile     = new CRegisterFile(2,FALSE,1);
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2);
        m_pTextureRegFile   = new CRegisterFile(4,FALSE,2);
        m_bXbox             = FALSE;
        break;
    case D3DPS_VERSION(1,1):    // DX8.0
        m_pTempRegFile      = new CRegisterFile(2,TRUE,2); // #regs, bWritable, max# reads/instruction
        m_pInputRegFile     = new CRegisterFile(2,FALSE,2);
        m_pConstRegFile     = new CRegisterFile(16,FALSE,2);
        m_pTextureRegFile   = new CRegisterFile(4,TRUE,2);
        m_bXbox             = FALSE;
        break;
    case D3DPS_VERSION(1,10):   // Xbox 1.0 Pixel Shader
    case D3DPS_VERSION(1,11):   // Xbox 1.1 Pixel Shader
        m_pTempRegFile      = new CRegisterFile(4,TRUE,4); // #regs, bWritable, max# reads/instruction
        m_pInputRegFile     = new CRegisterFile(4,TRUE,4);
        m_pConstRegFile     = new CRegisterFile(16,FALSE,4);
        m_pTextureRegFile   = new CRegisterFile(4,TRUE,4);
        m_bXbox             = TRUE;
        break;
    case D3DPS_VERSION(254,254):  // Legacy shader
        m_pTempRegFile      = new CRegisterFile(2,TRUE,5); // #regs, bWritable, max# reads/instruction
        m_pInputRegFile     = new CRegisterFile(2,TRUE,5);
        m_pConstRegFile     = new CRegisterFile(2,TRUE,5);
        m_pTextureRegFile   = new CRegisterFile(8,TRUE,5); // 5 is just arbitrarily large value
        m_bXbox             = FALSE;
        break;
    case D3DPS_VERSION(255,255):
        m_pTempRegFile      = new CRegisterFile(6,TRUE,2); // #regs, bWritable, max# reads/instruction
        m_pInputRegFile     = new CRegisterFile(8,FALSE,2);
        m_pConstRegFile     = new CRegisterFile(16,FALSE,2);
        m_pTextureRegFile   = new CRegisterFile(8,TRUE,2);
        m_bXbox             = FALSE;
        break;
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: %d.%d is not a supported pixel shader version. Aborting pixel shader validation.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
        return FALSE;
    }
    if( NULL == m_pTempRegFile ||
        NULL == m_pInputRegFile ||
        NULL == m_pConstRegFile ||
        NULL == m_pTextureRegFile )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.");
        return FALSE;
    }

    // The CRegisterFile constructor assumes its registers are initialized if
    // !bWritable && NumReadPorts > 0 is passed into the constructor above.
    // This is a valid assumption in most cases - e.g. input and const register files.
    //
    // This is not a correct assumption for texture registers.  Tex ops can always write to
    // texture regsters, regardless of what bWritable is set to.  In this case, bWritable is meant
    // to indicate whether blend ops can write the register.
    //
    // We never want to assume texture registers are initialized pre-shader, so below
    // they are set to uninitialized.
    for( UINT i = 0; i < m_pTextureRegFile->GetNumRegs(); i++ )
    {
        for( UINT Component = 0; Component < 4; Component++ )
        {
            m_pTextureRegFile->m_pAccessHistory[Component][i].m_bPreShaderInitialized = FALSE;
        }
    }
    
    if(m_bXbox)
    {
        // for XBox pixel shaders, the Zero register (r2) and the fog register (r3) are pre-shader initialized
        m_pTempRegFile->m_pAccessHistory[0][2].m_bPreShaderInitialized = TRUE;
        m_pTempRegFile->m_pAccessHistory[1][2].m_bPreShaderInitialized = TRUE;
        m_pTempRegFile->m_pAccessHistory[2][2].m_bPreShaderInitialized = TRUE;
        m_pTempRegFile->m_pAccessHistory[3][2].m_bPreShaderInitialized = TRUE;
        m_pTempRegFile->m_pAccessHistory[0][3].m_bPreShaderInitialized = TRUE;
        m_pTempRegFile->m_pAccessHistory[1][3].m_bPreShaderInitialized = TRUE;
        m_pTempRegFile->m_pAccessHistory[2][3].m_bPreShaderInitialized = TRUE;
        m_pTempRegFile->m_pAccessHistory[3][3].m_bPreShaderInitialized = TRUE;
    }


    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::ApplyPerInstructionRules
//
// Returns FALSE if shader validation must terminate.
// Returns TRUE if validation may proceed to next instruction.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::ApplyPerInstructionRules()
{
    if( !   Rule_InstructionRecognized()            ) return FALSE;   // Bail completely on unrecognized instr.
    if( !   Rule_InstructionSupportedByVersion()    ) goto EXIT;
    if( !   Rule_ValidParamCount()                  ) goto EXIT;

   // Rules that examine source parameters
    if( !   Rule_ValidSrcParams()                   ) goto EXIT;
    if( !   Rule_MultipleDependentTextureReads()    ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_SrcNoLongerAvailable()             ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_SrcInitialized()                   ) goto EXIT; // needs to be before _ValidDstParam()

    if( !   Rule_ValidDstParam()                    ) goto EXIT;
    if( !   Rule_ValidRegisterPortUsage()           ) goto EXIT;
    if( !   Rule_TexRegsDeclaredInOrder()           ) goto EXIT;
    if( !   Rule_TexOpAfterNonTexOp()               ) goto EXIT;
    if( !   Rule_ValidTEXM3xSequence()              ) goto EXIT;
    if( !   Rule_ValidTEXM3xRegisterNumbers()       ) goto EXIT;
    if( !   Rule_ValidCNDInstruction()              ) goto EXIT;
    if( !   Rule_ValidLRPInstruction()              ) goto EXIT;
    if( !   Rule_ValidDEFInstruction()              ) goto EXIT;
    if( !   Rule_ValidDP3Instruction()              ) goto EXIT;
    if( !   Rule_ValidInstructionPairing()          ) goto EXIT;
    if( !   Rule_ValidInstructionCount()            ) goto EXIT;
EXIT:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::ApplyPostInstructionsRules
//-----------------------------------------------------------------------------
void CPShaderValidator::ApplyPostInstructionsRules()
{
    Rule_ValidTEXM3xSequence(); // check once more to see if shader ended dangling in mid-sequence
    Rule_ValidInstructionCount(); // see if we went over the limits
    if(!m_bXFCUsed) // r0 need not be written if XFC instruction is used
        Rule_R0Written();
}

//-----------------------------------------------------------------------------
//
// Per Instruction Rules
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_InstructionRecognized
//
// ** Rule:
// Is the instruction opcode known? (regardless of shader version)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not recognized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_InstructionRecognized()
{
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM_LEGACY:
    case D3DSIO_TEXBEML_LEGACY:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_CND:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3DIFF:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXKILL:
    case D3DSIO_END:
    case D3DSIO_NOP:
    case D3DSIO_DEF:
    case D3DSIO_XMMA:
    case D3DSIO_XMMC:
    case D3DSIO_XDM:
    case D3DSIO_XDD:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXBRDF:
#if 0 // Not on Xbox
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
#endif
    case D3DSIO_DP4:
        return TRUE; // instruction recognized - ok.

    case D3DSIO_XFC:
        m_bXFCUsed = TRUE;
        return TRUE; // instruction recognized, remember it.
    }

    // if we get here, the instruction is not recognized
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Unrecognized instruction. Aborting pixel shader validation.");
    m_ErrorCount++;
    return FALSE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_InstructionSupportedByVersion
//
// ** Rule:
// Is the instruction supported by the current pixel shader version?
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not supported by version.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_InstructionSupportedByVersion()
{
    if( D3DPS_VERSION(0xfe,0xfe) == m_Version )
    {
    // Special case - instructions used in legacy pixel processing by refdev.
    // Note that D3DSIO_TEX shows up below under 0.5 as well.

        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_TEX:
        case D3DSIO_TEXBEM_LEGACY:
        case D3DSIO_TEXBEML_LEGACY:
            return TRUE; // instruction supported - ok.
        }
    }
    else // "real" instructions
    {
        if( D3DPS_VERSION(1,0) <= m_Version ) // 1.0 and above
        {
            switch(m_pCurrInst->m_Type)
            {
            case D3DSIO_MOV:
            case D3DSIO_ADD:
            case D3DSIO_SUB:
            case D3DSIO_MUL:
            case D3DSIO_MAD:
            case D3DSIO_LRP:
            case D3DSIO_DP3:
            case D3DSIO_TEX:
            case D3DSIO_DEF:
            case D3DSIO_TEXBEM:
            case D3DSIO_TEXBEML:
            case D3DSIO_CND:
            case D3DSIO_TEXKILL:
            case D3DSIO_TEXCOORD:
            case D3DSIO_TEXM3x2PAD:
            case D3DSIO_TEXM3x2TEX:
            case D3DSIO_TEXM3x3PAD:
            case D3DSIO_TEXM3x3TEX:
            case D3DSIO_TEXM3x3SPEC:
            case D3DSIO_TEXM3x3DIFF:
            case D3DSIO_TEXM3x3VSPEC:
            case D3DSIO_TEXREG2AR:
            case D3DSIO_TEXREG2GB:
                return TRUE; // instruction supported - ok.
            }
        }
        if( D3DPS_VERSION(1,10) <= m_Version ) // 10.0 and above (Xbox)
        {
            switch(m_pCurrInst->m_Type)
            {
            case D3DSIO_XMMA:
            case D3DSIO_XMMC:
            case D3DSIO_XDM:
            case D3DSIO_XDD:
            case D3DSIO_XFC:
            case D3DSIO_TEXM3x2DEPTH:
            case D3DSIO_TEXBRDF:
                return TRUE;
            }
        }

        if( D3DPS_VERSION(255,255) == m_Version )
        {
            switch(m_pCurrInst->m_Type)
            {
            case D3DSIO_TEXM3x3DIFF:
            case D3DSIO_DP4:
                return TRUE; // instruction supported - ok.
            }
        }
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction supported - ok.
    }

    // if we get here, the instruction is not supported.
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by version %d.%d pixel shader.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
    m_ErrorCount++;
    return FALSE;  // no more checks on this instruction
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidParamCount
//
// ** Rule:
// Is the parameter count correct for the instruction?
//
// DEF is a special case that is treated as having only 1 dest parameter,
// even though there are also 4 source parameters.  The 4 source params for DEF
// are immediate float values, so there is nothing to check, and no way of
// knowing whether or not those parameter tokens were actually present in the
// token list - all the validator can do is skip over 4 DWORDS (which it does).
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when the parameter count is incorrect.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidParamCount()
{
    BOOL bBadParamCount = FALSE;

    if (m_pCurrInst->m_SrcParamCount + m_pCurrInst->m_DstParamCount > SHADER_INSTRUCTION_MAX_PARAMS)  bBadParamCount = TRUE;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_MOV:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_CND:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 3); break;
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEX:
    case D3DSIO_DEF: // we skipped the last 4 parameters (float vector) - nothing to check
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEM_LEGACY:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXBEML_LEGACY:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3DIFF:
    case D3DSIO_TEXM3x3VSPEC:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_TEXM3x3SPEC:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_XMMA:
    case D3DSIO_XMMC:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 3) || (m_pCurrInst->m_SrcParamCount != 4); break;
    case D3DSIO_XDM:
    case D3DSIO_XDD:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 2) || (m_pCurrInst->m_SrcParamCount != 4); break;
    case D3DSIO_XFC:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 7); break;
    }

    if (bBadParamCount)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid parameter count.");
        m_ErrorCount++;
        return FALSE;  // no more checks on this instruction
    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidSrcParams
//
// ** Rule:
// for each source parameter,
//      if current instruction is a texture instruction, then
//          source register type must be texture register
//          (with the exception of D3DSIO_SPEC, where Src1 must be c#), and
//          register # must be within range for texture registers, and
//          modifier must be D3DSPSM_NONE (or _SIGN for TexMatrixOps), and
//          swizzle must be D3DSP_NOSWIZZLE
//      else (non texture instruction)
//          source register type must be D3DSPR_TEMP/_INPUT/_CONST/_TEXTURE
//          register # must be within range for register type
//          modifier must be D3DSPSM_NONE/_NEG/_BIAS/_BIASNEG/_SIGN/_SIGNNEG/_COMP
//          swizzle must be D3DSP_NOSWIZZLE/_REPLICATEALPHA
//
// Note that the parameter count for D3DSIO_DEF is treated as 1
// (dest only), so this rule does nothing for it.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// Errors in any of the source parameters causes m_bSrcParamError[i]
// to be TRUE, so later rules that only apply when a particular source
// parameter was valid know whether they need to execute or not.
// e.g. Rule_SrcInitialized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidSrcParams()  // could break this down for more granularity
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        BOOL bFoundSrcError = FALSE;
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        char* SourceName[7] = {"first", "second", "third", "fourth", "fifth", "sixth", "seventh"};
        if( _CURR_PS_INST->m_bTexOp )
        {
            if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
            {
                if( D3DSIO_TEXM3x3SPEC == m_pCurrInst->m_Type && (1 == i) )
                {
                    // for _SPEC, last source parameter must be c#
                    if( D3DSPR_CONST != pSrcParam->m_RegType ||
                        D3DSP_NOSWIZZLE != pSrcParam->m_SwizzleShift ||
                        D3DSPSM_NONE != pSrcParam->m_SrcMod )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Second source parameter for texm3x3spec must be c#.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                        goto LOOP_CONTINUE;
                    }
                }
                else
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Src reg for tex ops must be TEXTURE register (%s source param).",
                                    SourceName[i]);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
            }

            UINT ValidRegNum = 0;
            switch(pSrcParam->m_RegType)
            {
            case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
            case D3DSPR_TEXTURE:    ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type (%s source param).", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
                goto LOOP_CONTINUE;
            }

            if( pSrcParam->m_RegNum >= ValidRegNum )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num %d (%s source param).  Max allowed for this type is %d.",
                        pSrcParam->m_RegNum, SourceName[i], ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch (pSrcParam->m_SwizzleShift)
            {
            case D3DSP_NOSWIZZLE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src swizzle for tex op (%s source param).", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }
        else // not a tex op
        {
            if( D3DSIO_XFC != m_pCurrInst->m_Type)
            {
                // not an xfc instruction, can't use prod or sum
                if(pSrcParam->m_RegType == D3DSPR_INPUT)
                {
                    if(pSrcParam->m_RegNum >= 2)
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid register: prod and sum can only be used with xfc instruction.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                }
            }
            else if(i>3)
            {
                // xfc instruction but not src 0 through 3, can't use prod or sum
                if(pSrcParam->m_RegType == D3DSPR_INPUT)
                {
                    if(pSrcParam->m_RegNum >= 2)
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid register: prod and sum can only be used as source registers 0 through 3 with xfc instruction.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                }
            }
            UINT ValidRegNum = 0;
            switch(pSrcParam->m_RegType)
            {
            case D3DSPR_TEMP:       ValidRegNum = m_pTempRegFile->GetNumRegs(); break;
            case D3DSPR_INPUT:      ValidRegNum = m_pInputRegFile->GetNumRegs(); break;
            case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
            case D3DSPR_TEXTURE:    ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for %s source param.", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            if( (!bFoundSrcError) && (pSrcParam->m_RegNum >= ValidRegNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num: %d for %s source param. Max allowed for this type is %d.",
                    pSrcParam->m_RegNum, SourceName[i], ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            if( D3DSIO_XFC == m_pCurrInst->m_Type)
            {
                // instruction is xfc
                switch( pSrcParam->m_SrcMod )
                {
                case D3DSPSM_NONE:
                case D3DSPSM_COMP:
                case D3DSPSM_SAT:
                    break;
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for %s source param.",
                                        SourceName[i]);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
            }
            else
            {
                // instruction is not xfc
                switch( pSrcParam->m_SrcMod )
                {
                case D3DSPSM_NONE:
                case D3DSPSM_NEG:
                case D3DSPSM_BIAS:
                case D3DSPSM_BIASNEG:
                case D3DSPSM_SIGN:
                case D3DSPSM_SIGNNEG:
                case D3DSPSM_COMP:
                case D3DSPSM_SAT:
                    break;
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for %s source param.",
                                        SourceName[i]);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
    
            }
            switch( pSrcParam->m_SwizzleShift )
            {
            case D3DSP_NOSWIZZLE:
            case D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_Z:
            case D3DSP_REPLICATEALPHA:
            case D3DVS_X_Z | D3DVS_Y_Z | D3DVS_Z_Z | D3DVS_W_Z:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src swizzle for %s source param.",
                                   SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }
LOOP_CONTINUE:
        if( bFoundSrcError )
        {
            m_bSrcParamError[i] = TRUE; // needed in Rule_SrcInitialized
        }
    }


    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_SrcNoLongerAvailable
//
// ** Rule:
// for each source parameter,
//     if it refers to a texture register then
//          for each component of the source register that needs to be read,
//              the src register cannot have been written by TEXKILL or TEXM*PAD instructions, and
//              if the instruction is a tex op then
//                  the src register cannot have been written by TEXBEM or TEXBEML
//              else
//                  the src register cannot have been read by any tex op (unless the tex op
//                          
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam(),
//                  and before Rule_SrcInitialized(),
//                  but after Rule_ValidSrcParams()
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_SrcNoLongerAvailable()
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[i] ) continue;

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                continue;

            if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
            {
                CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                if( pMostRecentWriter && pMostRecentWriter->m_pInst  )
                {
                    switch( pMostRecentWriter->m_pInst->m_Type )
                    {
                    case D3DSIO_TEXKILL:
                    case D3DSIO_TEXM3x2PAD:
                    case D3DSIO_TEXM3x3PAD:
                        AffectedComponents |= COMPONENT_MASKS[Component];
                    }
                }
            }
        }
        if( AffectedComponents )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Texture register result of TEXKILL or TEXM*PAD instructions must not be read. Affected components(*) of %s source param: %s",
                SourceName[i],MakeAffectedComponentsText(AffectedComponents));
            m_ErrorCount++;
            m_bSrcParamError[i] = TRUE;
        }

        if( _CURR_PS_INST->m_bTexOp )
        {
            AffectedComponents = 0;
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
                {
                    CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                    if( pMostRecentWriter && pMostRecentWriter->m_pInst )
                    {
                        switch( pMostRecentWriter->m_pInst->m_Type )
                        {
                        case D3DSIO_TEXBEM:
                        case D3DSIO_TEXBEML:
                            AffectedComponents |= COMPONENT_MASKS[Component];
                            break;
                        }
                    }
                }
            }
            // This is OK for Xbox
            /*
            if( AffectedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Texture register result of TEXBEM or TEXBEML instruction must not be read by TEX* instruction. Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents));
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
            }
            */
        }
        else
        {
            AffectedComponents = 0;
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
                {
                    CAccessHistoryNode* pMostRecentAccess = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentAccess;
                    if( pMostRecentAccess &&
                        pMostRecentAccess->m_pInst &&
                        pMostRecentAccess->m_bRead &&
                        ((CPSInstruction*)(pMostRecentAccess->m_pInst))->m_bTexOp )
                    {
                        AffectedComponents |= COMPONENT_MASKS[Component];
                    }
                }
            }
// This is OK for Xbox
/*
            if( AffectedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Texture register that has been read by a tex op cannot be read by a non-tex op. Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents));
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
            }
*/
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_MultipleDependentTextureReads
//
// ** Rule:
//
// Multiple dependent texture reads are disallowed.  So texture read results
// can be used as an address in a subsequent read, but the results from that
// second read cannot be used as an address in yet another subsequent read.
//
// As pseudocode:
//
// if current instruction (x) is a tex-op that reads a texture
//     for each source param of x
//         if the register is a texture register
//         and there exists a previous writer (y),
//         and y is a tex op that reads a texture
//         if there exists a souce parameter of y that was previously
//              written by an instruction that reads a texture (z)
//              SPEW(Error)
//
// NOTE that it is assumed that tex ops must write to all components, so
// only the read/write history for the R component is being checked.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam(),
//                  and Rule_SrcInitialized()
//                  but after Rule_ValidSrcParams()
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_MultipleDependentTextureReads()
{
    if( !_CURR_PS_INST->m_bTexOpThatReadsTexture )
        return TRUE;

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};

        if( m_bSrcParamError[i] ) continue;

        // Just looking at component 0 in this function because we assume tex ops write to all components.
        if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[0]) )
            continue;

        if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
            continue;

        CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[0][RegNum].m_pMostRecentWriter;
        if( (!pMostRecentWriter) || (!pMostRecentWriter->m_pInst) )
            continue;

        if(!((CPSInstruction*)(pMostRecentWriter->m_pInst))->m_bTexOp)
            continue;

        if(!((CPSInstruction*)(pMostRecentWriter->m_pInst))->m_bTexOpThatReadsTexture)
            continue;

        for( UINT j = 0; j < pMostRecentWriter->m_pInst->m_SrcParamCount; j++ )
        {
            if( D3DSPR_TEXTURE != pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegType )
                continue;

            CAccessHistoryNode* pRootInstructionHistoryNode =
                m_pTextureRegFile->m_pAccessHistory[0][pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegNum].m_pMostRecentWriter;

            CPSInstruction* pRootInstruction = pRootInstructionHistoryNode ? (CPSInstruction*)pRootInstructionHistoryNode->m_pInst : NULL;

            // no error output here because Xbox allows multiple dependent texture reads
            /*
            if( (D3DSPR_TEXTURE == pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegType)
                && pRootInstruction->m_bTexOpThatReadsTexture )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Multiple dependent texture reads are disallowed (%s source param).  Texture read results can be used as an address for subsequent read, but the results from that read cannot be used as an address in yet another subsequent read.",
                    SourceName[i]);
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
                break;
            }
            */
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_SrcInitialized
//
// ** Rule:
// for each source parameter,
//      if source is a TEMP or TEXTURE register then
//          if the source swizzle is D3DSP_NOSWIZZLE then
//              if the current instruction is DP3 (a cross component op) then
//                  the r, g and b components of of the source reg
//                  must have been previously written
//              else if there is a dest parameter, then
//                  the components in the dest parameter write mask must
//                  have been written to in the source reg. previously
//              else
//                  all components of the source must have been written
//          else if the source swizzle is _REPLICATEALPHA then
//              alpha component of reg must have been previously
//              written
//
// When checking if a component has been written previously,
// it must have been written in a previous cycle - so in the
// case of co-issued instructions, initialization of a component
// by one co-issued instruction is not available to the other for read.
//
// Note that the parameter count for D3DSIO_DEF is treated as 1
// (dest only), so this rule does nothing for it.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam().
//
// ** Returns:
// Always TRUE.
//
// NOTE: This rule also updates the access history to indicate reads of the
// affected components of each source register.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_SrcInitialized()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam[0]);

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        CRegisterFile* pRegFile = NULL;
        char* RegChar = NULL;
        DWORD UninitializedComponentsMask = 0;
        CAccessHistoryNode* pWriterInCurrCycle[4] = {0, 0, 0, 0};
        UINT NumUninitializedComponents = 0;

        if( m_bSrcParamError[i] ) continue;

        switch( pSrcParam->m_RegType )
        {
            case D3DSPR_TEMP:
                pRegFile = m_pTempRegFile;
                RegChar = "r";
                break;
            case D3DSPR_TEXTURE:
                pRegFile = m_pTextureRegFile;
                RegChar = "t";
                break;
            case D3DSPR_INPUT:
                pRegFile = m_pInputRegFile;
                RegChar = "v";
                break;
            case D3DSPR_CONST:
                pRegFile = m_pConstRegFile;
                RegChar = "c";
                break;
        }
        if( !pRegFile ) continue;

        // check for read of uninitialized components
        if( D3DSPR_TEMP == pSrcParam->m_RegType ||
            D3DSPR_TEXTURE == pSrcParam->m_RegType )
        {
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                CAccessHistoryNode* pPreviousWriter = pRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                CBaseInstruction* pCurrInst = m_pCurrInst;

                // If co-issue, find the real previous writer.
                while( pPreviousWriter
                       && ((CPSInstruction*)pPreviousWriter->m_pInst)->m_CycleNum == _CURR_PS_INST->m_CycleNum )
                {
                    pWriterInCurrCycle[Component] = pPreviousWriter; // log read just before this write for co-issue
                    pPreviousWriter = pPreviousWriter->m_pPreviousWriter;
                }

                // Even if pPreviousWriter == NULL, the component could have been initialized pre-shader.
                // So to check for initialization, we look at m_bInitialized below, rather than pPreviousWrite
                if(pPreviousWriter == NULL && !pRegFile->m_pAccessHistory[Component][RegNum].m_bPreShaderInitialized)
                {
                    NumUninitializedComponents++;
                    UninitializedComponentsMask |= COMPONENT_MASKS[Component];
                }
            }

            if( NumUninitializedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s",
                    NumUninitializedComponents > 1 ? "s" : "",
                    RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask));
                m_ErrorCount++;
            }
        }

        // Update register file to indicate READ.
        // Multiple reads of the same register component by the current instruction
        // will only be logged as one read in the access history.

        for( UINT Component = 0; Component < 4; Component++ )
        {
            #define PREV_READER(_CHAN,_REG) \
                    ((NULL == pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader) ? NULL :\
                    pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader->m_pInst)

            if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                continue;

            if( NULL != pWriterInCurrCycle[Component] )
            {
                if( !pWriterInCurrCycle[Component]->m_pPreviousReader ||
                    pWriterInCurrCycle[Component]->m_pPreviousReader->m_pInst != m_pCurrInst )
                {
                    if( !pRegFile->m_pAccessHistory[Component][RegNum].InsertReadBeforeWrite(
                                            pWriterInCurrCycle[Component], m_pCurrInst ) )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                        m_ErrorCount++;
                    }
                }
            }
            else if( PREV_READER(Component,RegNum) != m_pCurrInst )
            {
                if( !pRegFile->m_pAccessHistory[Component][RegNum].NewAccess(m_pCurrInst,FALSE) )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                    m_ErrorCount++;
                }
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidDstParam
//
// ** Rule:
// if instruction is D3DSIO_DEF, then do nothing - this case has its own separate rule
// the dst register must be writable.
// if the instruction has a dest parameter (i.e. every instruction except NOP), then
//      the dst register must be of type D3DSPR_TEMP or _TEXTURE, and
//      register # must be within range for the register type, and
//      the write mask must be: .rgba, .a or .rgb
//      if instruction is a texture instruction, then
//          the dst register must be of type D3DSPR_TEXTURE, and
//          the writemask must be D3DSP_WRITEMASK_ALL, and
//          the dst modifier must be D3DSPDM_NONE (or _SAT on version > 1.1), and
//          the dst shift must be none
//      else (non tex instruction)
//          the dst modifier must be D3DSPDM_NONE or _BIAS, and
//          dst shift must be /2, none, *2, or *4 (for v.255.255, any shift allowed) and
//          multiple dsts must not refer to the same register unless it is discard.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// NOTE: After checking the dst parameter, if no error was found,
// the write to the appropriate component(s) of the destination register
// is recorded by this function, so subsequent rules may check for previous
// write to registers.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidDstParam() // could break this down for more granularity
{
    BOOL   bFoundDstError;
    DSTPARAM* pDstParam;
    UINT RegNum;
    if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        // _DEF is a special instruction whose dest is a const register.
        // We do the checking for this in a separate function.
        // Also, we don't need to keep track of the fact that
        // this instruction wrote to a register (done below),
        // since _DEF just declares a constant.
        return TRUE;
    }

    // step through all dst params in instruction
    for(UINT di=0; di<m_pCurrInst->m_DstParamCount; di++)
    {
        pDstParam = &(m_pCurrInst->m_DstParam[di]);
        RegNum = pDstParam->m_RegNum;
        bFoundDstError = FALSE;
    
        if( pDstParam->m_bParamUsed )
        {
            UINT ValidRegNum = 0;
    
            BOOL bWritable = FALSE;
            switch( pDstParam->m_RegType )
            {
            case D3DSPR_INPUT:
                bWritable = m_pInputRegFile->IsWritable();
                ValidRegNum = m_pInputRegFile->GetNumRegs();
                if( m_bXbox )
                {
                    if(RegNum == 2) // sum not writeable
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "sum register invalid dest." );
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                    if(RegNum == 3) // prod not writeable
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "prod register invalid dest." );
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                }
                break;
    
            case D3DSPR_TEMP:
                bWritable = m_pTempRegFile->IsWritable();
                ValidRegNum = m_pTempRegFile->GetNumRegs();
                if( m_bXbox )
                {
                    if(RegNum == 3) // fog not writeable
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Fog register invalid dest." );
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                }
                break;
            case D3DSPR_TEXTURE:
                if( _CURR_PS_INST->m_bTexOp )
                    bWritable = TRUE;
                else
                    bWritable = m_pTextureRegFile->IsWritable();
    
                ValidRegNum = m_pTextureRegFile->GetNumRegs();
                break;
            }
    
            if( !bWritable || !ValidRegNum )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for dest param." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            else if( RegNum >= ValidRegNum )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dest reg num: %d. Max allowed for this reg type is %d.",
                    RegNum, ValidRegNum - 1);
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
    
            if( _CURR_PS_INST->m_bTexOp )
            {
                // check to see if r0.a is initialized by this instruction
                if((RegNum == 0) && ((D3DSIO_TEX == m_pCurrInst->m_Type) || 
                                     (D3DSIO_TEXCOORD == m_pCurrInst->m_Type)))
                {
                    // r0.a is initialized with t0.a
                    m_pTempRegFile->m_pAccessHistory[3][0].m_bPreShaderInitialized = TRUE;
                }

                if( D3DSPR_TEXTURE != pDstParam->m_RegType )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Must use texture register a dest param for tex ops." );
                    m_ErrorCount++;
                    bFoundDstError = TRUE;
                }
                if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "TEX ops must write all components." );
                    m_ErrorCount++;
                    bFoundDstError = TRUE;
                }
                switch( pDstParam->m_DstMod )
                {
                case D3DSPDM_NONE:
                    break;
    
                    // falling through
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dst modifier for tex op." );
                    m_ErrorCount++;
                    bFoundDstError = TRUE;
                }
                switch( pDstParam->m_DstShift )
                {
                case DSTSHIFT_NONE:
                    break;
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dst shift not allowed for tex op." );
                    m_ErrorCount++;
                    bFoundDstError = TRUE;
                }
            }
            else
            {
                switch( pDstParam->m_DstMod )
                {
                case D3DSPDM_NONE:
                    break;
                case D3DSPDM_BIAS:
                    if(( D3DPS_VERSION(1,0) == m_Version ) || ( D3DPS_VERSION(1,1) == m_Version ))
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid destination modifier (use xps.1.0 shader version to enable this extension)." );
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                    break;
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dst modifier." );
                    m_ErrorCount++;
                    bFoundDstError = TRUE;
                }
    
                if( D3DPS_VERSION(255,255) != m_Version )
                {
                    switch( pDstParam->m_DstShift )
                    {
                    case DSTSHIFT_NONE:
                    case DSTSHIFT_X2:
                    case DSTSHIFT_X4:
                    case DSTSHIFT_D2:
                        break;
                    default:
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dst shift." );
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                }
            }
    
            if( (D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask)
                && ((D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2) != pDstParam->m_WriteMask )
                && (D3DSP_WRITEMASK_3 != pDstParam->m_WriteMask ) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask must be .rgb, .a, or .rgba (all)." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
    
            DWORD dwWriteMask;
            if(di == 0)
            {
                // first destination parameter
                dwWriteMask = pDstParam->m_WriteMask;
            }
            else
            {
                // check against first dest writemask
                if(dwWriteMask != pDstParam->m_WriteMask)
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask must be the same for all dest registers." );
                    m_ErrorCount++;
                    bFoundDstError = TRUE;
                }

                // make sure that multiple writes are not done to the same register
                int ci;
                for(ci=di-1; ci>=0; ci--)
                {
                    DSTPARAM *pChkDstParam;
                    pChkDstParam = &(m_pCurrInst->m_DstParam[ci]);
                    if((pDstParam->m_RegType == pChkDstParam->m_RegType) &&
                       (pDstParam->m_RegNum == pChkDstParam->m_RegNum) &&
                       !((pDstParam->m_RegType == D3DSPR_TEMP) &&
                         (pDstParam->m_RegNum == 2)))
                    {
                        // dst register written multiple times and it's not discard
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest register other than discard written twice." );
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                }
            }
            // Update register file to indicate write.
            if( !bFoundDstError )
            {
                CRegisterFile* pRegFile = NULL;
                switch( pDstParam->m_RegType )
                {
                case D3DSPR_TEMP:       pRegFile = m_pTempRegFile; break;
                case D3DSPR_TEXTURE:    pRegFile = m_pTextureRegFile; break;
                }
    
                if( pRegFile )
                {
                    if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_0 )
                        pRegFile->m_pAccessHistory[0][RegNum].NewAccess(m_pCurrInst,TRUE);
    
                    if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_1 )
                        pRegFile->m_pAccessHistory[1][RegNum].NewAccess(m_pCurrInst,TRUE);
    
                    if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_2 )
                        pRegFile->m_pAccessHistory[2][RegNum].NewAccess(m_pCurrInst,TRUE);
    
                    if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_3 )
                        pRegFile->m_pAccessHistory[3][RegNum].NewAccess(m_pCurrInst,TRUE);
                }
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidRegisterPortUsage
//
// ** Rule:
// Each register class (TEMP,TEXTURE,INPUT,CONST) may only appear as parameters
// in an individual instruction up to a maximum number of times.
//
// Multiple accesses to the same register number (in the same register class)
// only count as one access.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidRegisterPortUsage()
{
    UINT TempRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT InputRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT ConstRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT TextureRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];

    UINT NumUniqueTempRegs = 0;
    UINT NumUniqueInputRegs = 0;
    UINT NumUniqueConstRegs = 0;
    UINT NumUniqueTextureRegs = 0;

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        D3DSHADER_PARAM_REGISTER_TYPE   RegType;
        UINT                            RegNum;
        UINT*                           pRegPortUsage = NULL;
        UINT*                           pNumUniqueRegs = NULL;

        if( !m_pCurrInst->m_SrcParam[i].m_bParamUsed ) continue;

        RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
        RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

        switch( RegType )
        {
        case D3DSPR_TEMP:
            pRegPortUsage = TempRegPortUsage;
            pNumUniqueRegs = &NumUniqueTempRegs;
            break;
        case D3DSPR_INPUT:
            pRegPortUsage = InputRegPortUsage;
            pNumUniqueRegs = &NumUniqueInputRegs;
            break;
        case D3DSPR_CONST:
            pRegPortUsage = ConstRegPortUsage;
            pNumUniqueRegs = &NumUniqueConstRegs;
            break;
        case D3DSPR_TEXTURE:
            pRegPortUsage = TextureRegPortUsage;
            pNumUniqueRegs = &NumUniqueTextureRegs;
            break;
        }

        if( !pRegPortUsage ) continue;

        BOOL    bRegAlreadyAccessed = FALSE;
        for( UINT j = 0; j < *pNumUniqueRegs; j++ )
        {
            if( pRegPortUsage[j] == RegNum )
            {
                bRegAlreadyAccessed = TRUE;
                break;
            }
        }
        if( !bRegAlreadyAccessed )
        {
            pRegPortUsage[*pNumUniqueRegs] = RegNum;
            (*pNumUniqueRegs)++;
        }
    }

    if( NumUniqueTempRegs > m_pTempRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Temp registers (r#) read %d times in one instruction.  Max #reads/instruction is %d.",
                        NumUniqueTempRegs,  m_pTempRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueInputRegs > m_pInputRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Input registers (v#) read %d times by instruction.  Max #reads/instruction is %d.",
                        NumUniqueInputRegs,  m_pInputRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueConstRegs > m_pConstRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Constant registers (c#) read %d times by instruction.  Max #reads/instruction is %d.",
                        NumUniqueConstRegs, m_pConstRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueTextureRegs > m_pTextureRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Texture registers (t#) read %d times by instruction.  Max #reads/instruction is %d.",
                        NumUniqueTextureRegs, m_pTextureRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_TexRegsDeclaredInOrder
//
// ** Rule:
// Tex registers must declared in increasing order.
// ex. invalid sequence:    tex t0
//                          tex t3
//                          tex t1
//
//     another invalid seq: tex t0
//                          tex t1
//                          texm3x2pad t1, t0 (t1 already declared)
//                          texm3x2pad t2, t0
//
//     valid sequence:      tex t0
//                          tex t1
//                          tex t3 (note missing t2.. OK)
//
// For v255.255, the above applies, with the following exception:
// A texture register may be redeclared only if it has not been
// previously the destination of a tex-op that did a texture lookup.
//
// ex. valid sequence:  tex         t0
//                      texcoord    t1   
//                      add         t1, t1, t0 // (note 255.255 allows tex/blend op mixing)
//                      texreg2rgb  t1, t1
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_TexRegsDeclaredInOrder()
{
    static DWORD s_TexOpRegDeclOrder; // bit flags

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_TexOpRegDeclOrder = 0;
    }
    if( !_CURR_PS_INST->m_bTexOp )
        return TRUE;

    DWORD RegNum = m_pCurrInst->m_DstParam[0].m_RegNum;
    if( (D3DSPR_TEXTURE != m_pCurrInst->m_DstParam[0].m_RegType) ||
        (RegNum > m_pTextureRegFile->GetNumRegs()) )
    {
        return TRUE;
    }

    DWORD RegMask = 1 << m_pCurrInst->m_DstParam[0].m_RegNum;
    if( RegMask & s_TexOpRegDeclOrder)
    {
        if( (D3DPS_VERSION(255,255) == m_Version) )
        {
            CAccessHistoryNode* pPrevWriter = m_pTextureRegFile->m_pAccessHistory[0][RegNum].m_pMostRecentWriter;
            DXGASSERT(pPrevWriter); // We only got here if there was a previous writer.
            if( m_pCurrInst == pPrevWriter->m_pInst ) // Already made the current inst. the most recent writer.
                pPrevWriter = pPrevWriter->m_pPreviousWriter;

            while(pPrevWriter)
            {
                if( ((CPSInstruction*)(pPrevWriter->m_pInst))->m_bTexOpThatReadsTexture ||
                     ((CPSInstruction*)(pPrevWriter->m_pInst))->m_bTexMOp )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Tex register t%d already declared either by a tex op that did a texture lookup, or by a texture matrix op.",
                                    RegNum);
                    m_ErrorCount++;
                    break;
                }
                pPrevWriter = pPrevWriter->m_pPreviousWriter;
            }
        }
        else
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Tex register t%d already declared.",
                            RegNum);
            m_ErrorCount++;
        }
    } 
    else if( s_TexOpRegDeclOrder > RegMask )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Tex registers must appear in sequence (i.e. t0 before t2 OK, but t1 before t0 not valid)." );
        m_ErrorCount++;
    }
    s_TexOpRegDeclOrder |= (1 << m_pCurrInst->m_DstParam[0].m_RegNum);
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_TexOpAfterNonTexOp
//
// ** Rule:
// Tex ops (see IsTexOp() for which instructions are considered tex ops)
// must appear before any other instruction, with the exception of DEF or NOP.
//
// This rule does not enforce anything in the case of a legacy pixel shader,
// or for version 255.255
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_TexOpAfterNonTexOp()
{
    static BOOL s_bFoundNonTexOp;
    static BOOL s_bRuleDisabled;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bFoundNonTexOp = FALSE;
        s_bRuleDisabled = ( D3DPS_VERSION(0xfe,0xfe) == m_Version ) || // Legacy pixel shader
                          ( D3DPS_VERSION(0xff,0xff) == m_Version);    // 255.255
    }

    if( s_bRuleDisabled )
        return TRUE;

    // Execute the rule.

    if( !(_CURR_PS_INST->m_bTexOp)
        && m_pCurrInst->m_Type != D3DSIO_NOP
        && m_pCurrInst->m_Type != D3DSIO_DEF)
    {
        s_bFoundNonTexOp = TRUE;
        return TRUE;
    }

    if( _CURR_PS_INST->m_bTexOp && s_bFoundNonTexOp )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Tex ops after non-tex ops." );
        m_ErrorCount++;
        s_bRuleDisabled = TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidTEXM3xSequence
//
// ** Rule:
// TEXM3x* instructions, if present in the pixel shader, must appear in
// any of the follwing sequences:
//
//      1) texm3x2pad
//      2) texm3x2tex / texdepth
//
// or   1) texm3x3pad
//      2) texm3x3pad
//      3) texm3x3tex
//
// or   1) texm3x3pad
//      2) texm3x3pad / texm3x3diff
//      3) texm3x3spec / texm3x3vspec
//
// ** When to call:
// Per instruction AND after all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidTEXM3xSequence()
{
    static UINT s_TexMSequence;
    static UINT s_LastInst;

    if( NULL == m_pCurrInst )
    {
        return TRUE;
    }

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
       s_TexMSequence = 0;
       s_LastInst = D3DSIO_NOP;
    }

    if( m_bSeenAllInstructions )
    {
        if( s_TexMSequence )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Incomplete TEXM* sequence." );
            m_ErrorCount++;
        }
        return TRUE;
    }

    // Execute the rule.

    if( _CURR_PS_INST->m_bTexMOp )
    {
        switch( m_pCurrInst->m_Type )
        {
        case D3DSIO_TEXM3x2PAD:
            if( s_TexMSequence ) goto _TexMSeqInvalid;
            m_TexMBaseDstReg = m_pCurrInst->m_DstParam[0].m_RegNum;
            s_TexMSequence = 1;
            break;
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x2DEPTH:
            // must be one 3x2PAD previous
            if ( (s_TexMSequence != 1) ||
                 (s_LastInst != D3DSIO_TEXM3x2PAD) ) goto _TexMSeqInvalid;
            s_TexMSequence = 0;
            break;
        case D3DSIO_TEXM3x3PAD:
            if (s_TexMSequence)
            {
                // if in sequence, then must be one 3x3PAD previous
                if ( (s_TexMSequence != 1) ||
                     (s_LastInst != D3DSIO_TEXM3x3PAD) ) goto _TexMSeqInvalid;
                s_TexMSequence = 2;
                break;
            }
            m_TexMBaseDstReg = m_pCurrInst->m_DstParam[0].m_RegNum;
            s_TexMSequence = 1;
            break;
        case D3DSIO_TEXM3x3TEX:
            // must be two 3x3PAD previous
            if ( (s_TexMSequence != 2) ||
                 (s_LastInst != D3DSIO_TEXM3x3PAD) ) goto _TexMSeqInvalid;
            s_TexMSequence = 0;
            break;
        case D3DSIO_TEXM3x3DIFF:
            // must be one 3x3PAD previous
            if ( (s_TexMSequence != 1) ||
                 (s_LastInst != D3DSIO_TEXM3x3PAD) ) goto _TexMSeqInvalid;
            s_TexMSequence = 2;
            break;
        case D3DSIO_TEXM3x3SPEC:
        case D3DSIO_TEXM3x3VSPEC:
            // must be at sequence 2 w/ either PAD or DIFF previous
            if ( (s_TexMSequence != 2) ||
                 ( (s_LastInst != D3DSIO_TEXM3x3PAD) &&
                   (s_LastInst != D3DSIO_TEXM3x3DIFF) ) ) goto _TexMSeqInvalid;
            s_TexMSequence = 0;
            break;
        default:
            break;
        }
        goto _TexMSeqOK;
_TexMSeqInvalid:
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid TEXM* sequence." );
        m_ErrorCount++;
    }
_TexMSeqOK:

    s_LastInst = m_pCurrInst->m_Type;
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidTEXM3xRegisterNumbers
//
// ** Rule:
// If instruction is a TEXM3x*, register numbers must be as follows:
//
//      1) texm3x2pad / texdepth        t(x), t(y1)
//      2) texm3x2tex                   t(x+1), t(y2)
//
//      1) texm3x3pad                   t(x), t(y1)
//      2) texm3x3pad                   t(x+1), t(y2)
//      3) texm3x3tex                   t(x+2), t(y3)
//
//      1) texm3x3pad                   t(x), t(y1)
//      2) texm3x3pad / texm3x3diff     t(x+1), t(y2)
//      3) texm3x3spec                  t(x+2), t(y3), c#
//
//      1) texm3x3pad                   t(x), t(y1)
//      2) texm3x3pad / texm3x3diff     t(x+1), t(y2)
//      3) texm3x3vspec                 t(x+2), t(y3)
//
//      where y1, y2, and y3 are all less than x
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidTEXM3xRegisterNumbers()
{
    #define PREV_INST_TYPE(_INST) \
                ((_INST && _INST->m_pPrevInst) ? _INST->m_pPrevInst->m_Type : D3DSIO_NOP)

    if( _CURR_PS_INST->m_bTexMOp )
    {
        DWORD DstParamR = m_pCurrInst->m_DstParam[0].m_RegNum;
        DWORD SrcParam0R = m_pCurrInst->m_SrcParam[0].m_RegNum;
        switch (m_pCurrInst->m_Type)
        {
        case D3DSIO_TEXM3x2PAD:
            break;
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x2DEPTH:
            if ( DstParamR != (m_TexMBaseDstReg + 1) )
                goto _TexMRegInvalid;
            if( SrcParam0R >= m_TexMBaseDstReg )
                goto _TexMRegInvalid;
            break;
        case D3DSIO_TEXM3x3PAD:
        {
            if ( D3DSIO_TEXM3x3PAD == PREV_INST_TYPE(m_pCurrInst) &&
                 (DstParamR != (m_TexMBaseDstReg + 1) ) )
                    goto _TexMRegInvalid;

            if ( D3DSIO_TEXM3x3PAD == PREV_INST_TYPE(m_pCurrInst) &&
                 (SrcParam0R >= m_TexMBaseDstReg ))
                    goto _TexMRegInvalid;
            break;
        }
        case D3DSIO_TEXM3x3DIFF:
            if ( DstParamR != (m_TexMBaseDstReg + 1) )
                goto _TexMRegInvalid;
            if( SrcParam0R >= m_TexMBaseDstReg )
                    goto _TexMRegInvalid;
            break;
        case D3DSIO_TEXM3x3SPEC:
            // SPEC requires second src param to be from const regs
            if ( m_pCurrInst->m_SrcParam[1].m_RegType != D3DSPR_CONST )
                goto _TexMRegInvalid;
            // fall through
        case D3DSIO_TEXM3x3TEX:
        case D3DSIO_TEXM3x3VSPEC:
            if ( DstParamR != (m_TexMBaseDstReg + 2) )
                goto _TexMRegInvalid;
            if( SrcParam0R >= m_TexMBaseDstReg )
                    goto _TexMRegInvalid;
            break;
        default:
            break;
        }
        goto _TexMRegOK;
_TexMRegInvalid:
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid TEXM* register." );
        m_ErrorCount++;
    }
_TexMRegOK:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidCNDInstruction
//
// ** Rule:
// First source for cnd instruction must be 'r0.a' (exactly).
// i.e. cnd r1, r0.a, t0, t1
//
// For v255.255, first source can be any register type/number, and
//               .a and no-swizzle are allowed.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidCNDInstruction()
{
    if( D3DSIO_CND == m_pCurrInst->m_Type )
    {
        SRCPARAM Src0 = m_pCurrInst->m_SrcParam[0];
        if( D3DPS_VERSION(255,255) == m_Version )
        {
            if( Src0.m_bParamUsed &&
                D3DSPSM_NONE == Src0.m_SrcMod &&
                ( (D3DSP_REPLICATEALPHA == Src0.m_SwizzleShift) ||
                  (D3DSP_NOSWIZZLE == Src0.m_SwizzleShift)
                )
              )
            {
                return TRUE;    // Src 0 register has no modifiers and swizzle is either .a or .rgba
            }

            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "First source register for CND instruction must be 'r0.a' or 'r0.rgba'/'r0'(no-swizzle)." );
            m_ErrorCount++;
        }
        else
        {
            if( Src0.m_bParamUsed &&
                D3DSPR_TEMP == Src0.m_RegType &&
                0 == Src0.m_RegNum &&
                D3DSP_REPLICATEALPHA == Src0.m_SwizzleShift &&
                D3DSPSM_NONE == Src0.m_SrcMod )
            {
                return TRUE;    // Src 0 is r0.a
            }

            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "First source for CND instruction must be 'r0.a'." );
            m_ErrorCount++;

        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidLRPInstruction
//
// ** Rule:
// The only valid source modifier for the src0 operand for LRP is complement
// (1-reg)
// i.e. lrp r1, 1-r0, t0, t1
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidLRPInstruction()
{
    if( D3DSIO_LRP == m_pCurrInst->m_Type )
    {
        SRCPARAM Src0 = m_pCurrInst->m_SrcParam[0];
        if( !Src0.m_bParamUsed )
            return TRUE;

        switch( Src0.m_SrcMod )
        {
        case D3DSPSM_NONE:
        case D3DSPSM_COMP:
        case D3DSPSM_SAT:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "The only valid modifiers for the first source parameter of LRP are: reg (no mod) or 1-reg (complement)." );
            m_ErrorCount++;
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidDEFInstruction
//
// ** Rule:
// For the DEF instruction, make sure the dest parameter is a valid constant,
// and it has no modifiers.
//
// NOTE that we are pretending this instruction only has a dst parameter.
// We skipped over the 4 source parameters since they are immediate floats,
// for which there is nothing that can be checked.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidDEFInstruction()
{

    static BOOL s_bDEFInstructionAllowed;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bDEFInstructionAllowed = TRUE;
    }

    if( D3DSIO_COMMENT != m_pCurrInst->m_Type &&
        D3DSIO_DEF     != m_pCurrInst->m_Type )
    {
        s_bDEFInstructionAllowed = FALSE;
    }
    else if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        if( !s_bDEFInstructionAllowed )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Const declaration (DEF) must appear before other instructions." );
            m_ErrorCount++;
        }
        DSTPARAM* pDstParam = &m_pCurrInst->m_DstParam[0];
        if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask ||
            D3DSPDM_NONE != pDstParam->m_DstMod ||
            DSTSHIFT_NONE != pDstParam->m_DstShift ||
            D3DSPR_CONST != pDstParam->m_RegType
            )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination for DEF instruction must be of the form c# (# = reg number, no modifiers)." );
            m_ErrorCount++;
        }

        // Check that the register number is in bounds
        if( D3DSPR_CONST == pDstParam->m_RegType &&
            pDstParam->m_RegNum >= m_pConstRegFile->GetNumRegs() )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid const register num: %d. Max allowed is %d.",
                        pDstParam->m_RegNum,m_pConstRegFile->GetNumRegs() - 1);
            m_ErrorCount++;

        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidDP3Instruction
//
// ** Rule:
// The .a result write mask is not valid for the DP3 instruction.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidDP3Instruction()
{
    if( D3DSIO_DP3 == m_pCurrInst->m_Type )
    {
        if( (D3DSP_WRITEMASK_ALL != m_pCurrInst->m_DstParam[0].m_WriteMask)
            && ((D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2) != m_pCurrInst->m_DstParam[0].m_WriteMask ) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask must be .rgb, or .rgba (all) for DP3." );
            m_ErrorCount++;
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidInstructionPairing
//
// ** Rule:
// - If an instruction is co-issued with another instruction,
// make sure that both do not write to any of RGB at the same time,
// and that neither instruction individually writes to all of RGBA.
//
// - Co-issue can only involve 2 instructions,
// so consecutive instructions cannot have the "+" prefix (D3DSI_COISSUE).
//
// - Co-issue of instructions only applies to pixel blend instructions (non tex-ops).
//
// - The first color blend instruction cannot have "+" (D3DSI_COISSUE) set either.
//
// - NOP may not be used in a co-issue pair.
//
// - DP3 (dot product) always uses the color/vector pipeline (even if it is not writing
// to color components). Thus:
//      - An instruction co-issued with a dot-product can only write to alpha.
//      - A dot-product that writes to alpha cannot be co-issued.
//      - Two dot-products cannot be co-issued.
//
// - For version <= 1.0, coissued instructions must write to the same register.
//
// ------------------
// examples:
//
//      valid pair:             mov r0.a, c0
//                              +add r1.rgb, v1, c1 (note dst reg #'s can be different)
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.rgb, v1, c1
//
//      another valid pair:     dp3 r0.rgb, t1, v1
//                              +mul r0.a, t0, v0
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.a, t0, t1
//
//      invalid pair:           mov r0.rgb, c0
//                              +add r0, t0, t1  (note the dst writes to rgba)
//
//      another invalid pair:   mov r1.rgb, c1
//                              +dp3 r0.a, t0, t1 (dp3 is using up color/vector pipe)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidInstructionPairing()
{
    static BOOL s_bSeenNonTexOp;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_bSeenNonTexOp = FALSE;
    }

    if( !s_bSeenNonTexOp && !_CURR_PS_INST->m_bTexOp )
    {
        // first non-tex op.  this cannot have co-issue set.
        if( _CURR_PS_INST->m_bCoIssue )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "First pixel blend instruction cannot have co-issue ('+') set; there is no previous pixel blend instruction to pair with.");
            m_ErrorCount++;
        }
        s_bSeenNonTexOp = TRUE;
    }

    if( _CURR_PS_INST->m_bTexOp && _CURR_PS_INST->m_bCoIssue )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Cannot set co-issue ('+') on a texture instruction.  Co-issue only applies to pixel blend instructions." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && m_pCurrInst->m_pPrevInst &&
        _PREV_PS_INST->m_bCoIssue )
    {
        // consecutive instructions cannot have co-issue set.
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot set co-issue ('+') on consecutive instructions." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && m_pCurrInst->m_pPrevInst &&
        (D3DSIO_NOP == m_pCurrInst->m_pPrevInst->m_Type))
    {
        // NOP cannot be part of co-issue (previous instruction found to be NOP)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst, "Nop instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && D3DSIO_NOP == m_pCurrInst->m_Type )
    {
        // NOP cannot be part of co-issue (current instruction found to be NOP)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Nop instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && !_CURR_PS_INST->m_bTexOp &&
        NULL != m_pCurrInst->m_pPrevInst && !_PREV_PS_INST->m_bTexOp &&
        !_PREV_PS_INST->m_bCoIssue )
    {
        // instruction and previous instruction are candidate for co-issue.
        // ...do further validation...
        DWORD ColorWriteMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
        DWORD CurrInstWriteMask = 0;
        DWORD PrevInstWriteMask = 0;

        if( m_pCurrInst->m_DstParam[0].m_bParamUsed )
            CurrInstWriteMask = m_pCurrInst->m_DstParam[0].m_WriteMask;
        if( m_pCurrInst->m_pPrevInst->m_DstParam[0].m_bParamUsed )
            PrevInstWriteMask = m_pCurrInst->m_pPrevInst->m_DstParam[0].m_WriteMask;

        if( D3DSIO_DP3 == m_pCurrInst->m_Type &&
            D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                "Co-issued instructions cannot both be dot-product, since each require use of the color/vector pipeline to execute." );
            m_ErrorCount++;
        }
        else if( D3DSIO_DP3 == m_pCurrInst->m_Type )
        {
            if( ColorWriteMask & PrevInstWriteMask )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components." );
                m_ErrorCount++;
            }
            if( D3DSP_WRITEMASK_3 & CurrInstWriteMask ) // alpha in addition to the implied rgb for dp3
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used." );
                m_ErrorCount++;
            }
        }
        else if( D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
        {
            if( ColorWriteMask & CurrInstWriteMask )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components." );
                m_ErrorCount++;
            }
            if( D3DSP_WRITEMASK_3 & PrevInstWriteMask ) // alpha in addition to the implied rgb for dp3
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used by the dot product." );
                m_ErrorCount++;
            }
        }
        else
        {
            if( PrevInstWriteMask == D3DSP_WRITEMASK_ALL )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Co-issued instruction cannot write all components - must write either alpha or color." );
                m_ErrorCount++;
            }
            if( CurrInstWriteMask == D3DSP_WRITEMASK_ALL )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Co-issued instruction cannot write all components - must write either alpha or color." );
                m_ErrorCount++;
            }
            if( (m_pCurrInst->m_DstParam[0].m_RegType == m_pCurrInst->m_pPrevInst->m_DstParam[0].m_RegType) &&
                (m_pCurrInst->m_DstParam[0].m_RegNum == m_pCurrInst->m_pPrevInst->m_DstParam[0].m_RegNum) &&
                ((CurrInstWriteMask & PrevInstWriteMask) != 0) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Co-issued instructions cannot both write to the same components of a register.  Affected components: %s",
                    MakeAffectedComponentsText(CurrInstWriteMask & PrevInstWriteMask)
                    );
                m_ErrorCount++;
            }
            if( (CurrInstWriteMask & ColorWriteMask) && (PrevInstWriteMask & ColorWriteMask) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions cannot both write to color components." );
                m_ErrorCount++;
            }
            if( (CurrInstWriteMask & D3DSP_WRITEMASK_3) && (PrevInstWriteMask & D3DSP_WRITEMASK_3) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions cannot both write to alpha component." );
                m_ErrorCount++;
            }
        }

        if( m_Version <= D3DPS_VERSION(1,0) )
        {
            // both co-issued instructions must write to the same register number.
            if( m_pCurrInst->m_DstParam[0].m_RegType != m_pCurrInst->m_pPrevInst->m_DstParam[0].m_RegType )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions must both write to the same register type for pixelshader version <= 1.0." );
                m_ErrorCount++;
            }
            if( (m_pCurrInst->m_DstParam[0].m_RegNum != m_pCurrInst->m_pPrevInst->m_DstParam[0].m_RegNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions must both write to the same register number for pixelshader version <= 1.0." );
                m_ErrorCount++;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_ValidInstructionCount
//
// ** Rule:
// Make sure instruction count for pixel shader version has not been exceeded.
// Separate counts are kept for texture address instructions, for
// pixel blending instructions, and for the total number of instructions.
// Note that the total may not be the sum of texture + pixel instructions.
//
// For version 1.0+, D3DSIO_TEX counts only toward the tex op limit,
// but not towards the total op count.
//
// TEXBEML takes 3 instructions.
//
// Co-issued pixel blending instructions only
// count as one instruction towards the limit.
//
// The def instruction, nop, and comments (already stripped), do not count
// toward any limits.
//
// This rule does not enforce anything in the case of a legacy pixel shader.
//
// ** When to call:
// Per instruction AND after all instructions seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_ValidInstructionCount()
{
    static UINT s_MaxTexOpCount;
    static UINT s_MaxBlendOpCount;
    static UINT s_MaxTotalOpCount;
    static BOOL s_bRuleDisabled;

    if( NULL == m_pCurrInst )
        return TRUE;

    if(( NULL == m_pCurrInst->m_pPrevInst ) &&
       ( FALSE == m_bSeenAllInstructions ))    // First instruction - initialize static vars
    {
        m_TexOpCount = 0;
        m_BlendOpCount = 0;
        s_bRuleDisabled = FALSE;

        switch(m_Version)
        {
        case D3DPS_VERSION(0x254,0x254):  // Legacy shader
            s_bRuleDisabled = TRUE;
            break;
        case D3DPS_VERSION(1,0):    // DX7.5
            s_MaxTexOpCount   = 4;
            s_MaxBlendOpCount = 8;
            s_MaxTotalOpCount = 8;
            break;
        default:
        case D3DPS_VERSION(1,1):    // DX8.0
            s_MaxTexOpCount   = 4;
            s_MaxBlendOpCount = 8;
            s_MaxTotalOpCount = 12;
            break;
        case D3DPS_VERSION(255,255):
            s_MaxTexOpCount   = 16;
            s_MaxBlendOpCount = 32;
            s_MaxTotalOpCount = 48;
            break;
        }
    }

    if( s_bRuleDisabled )
        return TRUE;

    if( m_bSeenAllInstructions )
    {
        if( m_TexOpCount > s_MaxTexOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Too many texture addressing instruction slots used: %d. Max. allowed is %d. (Note that some texture addressing instructions may use up more than one instruction slot)",
                  m_TexOpCount, s_MaxTexOpCount);
            m_ErrorCount++;
        }
        if( m_BlendOpCount > s_MaxBlendOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Too many pixel blending instruction slots used: %d. Max. allowed (counting any co-issued instructions as 1) is %d.",
                  m_BlendOpCount, s_MaxBlendOpCount);
            m_ErrorCount++;
        }
        if( !(m_TexOpCount > s_MaxTexOpCount && m_BlendOpCount > s_MaxBlendOpCount) // not already spewed avove 2 errors
            && (m_TotalOpCount > s_MaxTotalOpCount) )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Total number of instruction slots used too high: %d. Max. allowed (counting any co-issued instructions as 1) is %d.",
                  m_TotalOpCount, s_MaxTotalOpCount);
            m_ErrorCount++;
        }
        if(m_BlendOpCount == 0)
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "At least one pixel blending instruction must be used in addition to XFC.");
            m_ErrorCount++;
        }
        return TRUE;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM_LEGACY:
    case D3DSIO_TEXBEML_LEGACY:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3DIFF:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXBRDF:
#if 0 // Not on XBox
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
#endif
        m_TexOpCount++;
        m_TotalOpCount++;
        break;
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_CND:
    case D3DSIO_END:
    case D3DSIO_DP4:
    case D3DSIO_XMMA:
    case D3DSIO_XMMC:
    case D3DSIO_XDM:
    case D3DSIO_XDD:
        if( !_CURR_PS_INST->m_bCoIssue )
        {
            m_BlendOpCount++;
            m_TotalOpCount++;
        }
        break;
    case D3DSIO_NOP:
    case D3DSIO_DEF:
    case D3DSIO_XFC:
        break;
    default:
        DXGASSERT(FALSE);
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator::Rule_R0Written
//
// ** Rule:
// All components (r,g,b,a) of register R0 must have been written by the
// pixel shader.
//
// ** When to call:
// After all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator::Rule_R0Written()
{
    UINT  NumUninitializedComponents    = 0;
    DWORD UninitializedComponentsMask   = 0;

    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        if( (NULL == m_pTempRegFile->m_pAccessHistory[i][0].m_pMostRecentWriter ) &&
            (!m_pTempRegFile->m_pAccessHistory[i][0].m_bPreShaderInitialized) )
        {
            NumUninitializedComponents++;
            UninitializedComponentsMask |= COMPONENT_MASKS[i];
        }
    }
    if( NumUninitializedComponents )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s",
            NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        m_ErrorCount++;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
//
// CPShaderValidator Wrapper Functions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// ValidatePixelShaderInternal
//-----------------------------------------------------------------------------
BOOL ValidatePixelShaderInternal( const DWORD* pCode, const D3DCAPS8* pCaps, XD3DXErrorLog* pLog )
{
    CPShaderValidator Validator(pCode,pCaps, 0, pLog);
    return SUCCEEDED(Validator.GetStatus()) ? TRUE : FALSE;
}

//-----------------------------------------------------------------------------
// ValidatePixelShader
//
//-----------------------------------------------------------------------------
HRESULT WINAPI ValidatePixelShader( const DWORD* pCode,
                                    const D3DCAPS8* pCaps,
                                    const DWORD Flags,
                                    XD3DXErrorLog* pLog)
{
    CPShaderValidator Validator(pCode,pCaps,Flags, pLog);
#if 0
    if( ppBuf )
    {
        *ppBuf = (char*)HeapAlloc(GetProcessHeap(), 0, Validator.GetRequiredLogBufferSize());
        if( NULL == *ppBuf )
            OutputDebugString("Out of memory.\n");
        else
            Validator.WriteLogToBuffer(*ppBuf);
    }
#endif
    return Validator.GetStatus();
}

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\sources.inc ===
MAJORCOMP=directx
MINORCOMP=d3d

TARGETNAME=shadeasm$(D)

TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES);..;..\..\inc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pchshadeasm.h
PRECOMPILED_PCH=pchshadeasm.pch
PRECOMPILED_OBJ=pchshadeasm.obj

SOURCES =                 \
    CD3DXStack.cpp \
    CD3DXAssembler.cpp \
	preprocessor.cpp \
    api.cpp \
    valbase.cpp \
    pshdrval.cpp \
    vshdrval.cpp \
    pixelshader.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////

// stdafx.cpp : source file that includes just the standard includes
// vc7.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "pchshadeasm.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\shadeasm.h ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define yyparse d3dxasm_parse
#define yylex d3dxasm_lex
#define yyerror d3dxasm_error
#define yychar d3dxasm_char
#define yyval d3dxasm_val
#define yylval d3dxasm_lval
#define yydebug d3dxasm_debug
#define yynerrs d3dxasm_nerrs
#define yyerrflag d3dxasm_errflag
#define yyss d3dxasm_ss
#define yyssp d3dxasm_ssp
#define yyvs d3dxasm_vs
#define yyvsp d3dxasm_vsp
#define yylhs d3dxasm_lhs
#define yylen d3dxasm_len
#define yydefred d3dxasm_defred
#define yydgoto d3dxasm_dgoto
#define yysindex d3dxasm_sindex
#define yyrindex d3dxasm_rindex
#define yygindex d3dxasm_gindex
#define yytable d3dxasm_table
#define yycheck d3dxasm_check
#define yyname d3dxasm_name
#define yyrule d3dxasm_rule
#define YYPREFIX "d3dxasm_"

#define isatty _isatty
#define fileno _fileno

#define T_VS 257
#define T_XVS 258
#define T_XVSW 259
#define T_XVSS 260
#define T_PS 261
#define T_XPS 262
#define T_DEF 263
#define T_OP0 264
#define T_OP1 265
#define T_OP2 266
#define T_OP3 267
#define T_OP4 268
#define T_OP5 269
#define T_OP6 270
#define T_OP7 271
#define T_ID 272
#define T_NUM 273
#define T_FLT 274
#define T_EOF 275
#define YYERRCODE 256
short d3dxasm_lhs[] = {                                        -1,
    0,    0,    1,    1,    1,    1,    1,    1,    2,    2,
    5,    5,    6,    4,    4,    9,    9,    9,    9,    9,
    9,    9,    9,   12,   12,   14,   14,   14,   21,   21,
    7,    7,    7,   22,   22,   22,   22,   22,   22,   22,
   22,   22,   22,   22,   22,   10,   10,   11,   11,   13,
   13,   15,   15,   16,   16,   17,   17,   18,   18,   19,
   19,    8,    8,    8,    8,    8,    8,   20,    3,   23,
};
short d3dxasm_len[] = {                                         2,
    2,    3,    5,    5,    5,    5,    5,    5,    1,    2,
    1,    2,   10,    1,    2,    1,    2,    4,    6,    8,
   14,   12,   14,    1,    3,    1,    2,    3,    1,    3,
    1,    4,    6,    5,    5,    3,    1,    2,    1,    3,
    4,    3,    3,    4,    3,    1,    2,    1,    2,    1,
    2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
    2,    1,    2,    2,    1,    2,    2,    1,    1,    1,
};
short d3dxasm_defred[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   46,   48,   50,   52,   54,
   56,   58,   60,    1,    0,    0,    9,    0,    0,    0,
   16,    0,    0,    0,    0,    0,    0,    0,   69,    0,
    0,    0,    0,    0,    0,   68,    0,    0,   47,   49,
   51,   53,   55,   57,   59,   61,    2,   10,   12,   15,
    0,   17,    0,    0,    0,    0,    0,    0,    0,   26,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   27,    0,    0,    0,    0,    0,
    3,    6,    7,    8,    4,    5,   70,    0,    0,   62,
    0,   65,    0,    0,    0,    0,    0,   25,   18,    0,
    0,   28,   30,    0,    0,    0,   64,   67,   63,   66,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   45,   42,   43,
   40,    0,   19,    0,    0,    0,    0,    0,   44,   41,
    0,    0,   33,    0,    0,    0,    0,    0,   35,   34,
   20,    0,    0,    0,    0,    0,    0,    0,   13,    0,
    0,    0,    0,    0,    0,    0,   22,    0,    0,    0,
   21,   23,
};
short d3dxasm_dgoto[] = {                                       7,
    8,   26,   67,   27,   28,   29,   68,  101,   30,   31,
   32,   62,   33,   69,   34,   35,   36,   37,   38,   48,
   70,  107,  102,
};
short d3dxasm_sindex[] = {                                   -165,
  -37,   14,   28,   52,   76,   79,    0,    1, -227, -227,
 -227, -227, -227, -227, -224,    0,    0,    0,    0,    0,
    0,    0,    0,    0, -150, -202,    0,   27, -183,   27,
    0, -224, -224, -224, -224,  -13, -224, -224,    0,   82,
   83,   85,   86,   91,   92,    0,   37,   48,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   94,    0,   97,   98,   99, -224,  101,  102,  103,    0,
  105,  110, -227, -227, -227, -227, -227, -227,   16,  -11,
 -224,  -13,  -13,  -13,    0, -224, -224,  -13, -224, -224,
    0,    0,    0,    0,    0,    0,    0, -223, -223,    0,
  111,    0, -227,  -11,  -10,   -6,   63,    0,    0,  114,
  115,    0,    0,  118,  119,  120,    0,    0,    0,    0,
   16,   -2,  124,  -11,  -11,  -11,  -11,   71,  -13,  -13,
  -13,  -13, -224,  125,  -11,  -11,    2,    0,    0,    0,
    0, -224,    0,  126,  127,  128,  129,   16,    0,    0,
  -11,  -11,    0,  -13,  -13,  -13,  -13,  135,    0,    0,
    0,  136,  137,  138,   16,  -13,  -13,  -13,    0,  139,
  140,  141,  -13,  -13,  -13,  142,    0,  146,  -13,  -13,
    0,    0,
};
short d3dxasm_rindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   35, -107,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  -41,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   13,    0,    0,    0,    0,    0,    0,  -17,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -40,  -28,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  -16,    0,    0,    0,    0,    0,  -29,    0,    0,
    0,    0,    0,    0,    0,    0,   -3,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,
};
short d3dxasm_gindex[] = {                                      0,
    0,    0,    9,   12,  162,    0,   34,  -90,    0,    0,
    0,  -27,    0,   21,    0,    0,    0,    0,    0,  -51,
  241,  -25,  -44,
};
#define YYTABLESIZE 393
short d3dxasm_table[] = {                                      31,
   39,   31,   31,   31,   31,   63,   64,   65,    9,   71,
   72,   32,   37,   32,   32,   32,   32,   40,   41,   42,
   43,   44,   45,   29,   38,   29,   29,   29,  104,  108,
  134,   66,  125,  103,  124,  113,  127,   36,  126,   58,
  136,   60,  135,   25,  152,   39,  151,   46,   47,   39,
   97,   31,   39,  118,  120,   24,   24,  158,   99,   10,
   98,  115,  116,   32,   37,   61,   61,   61,   61,   25,
   61,   61,   57,   11,  169,   29,   38,   11,  123,   15,
   79,   91,   92,   93,   94,   95,   96,  100,  105,   36,
  153,    1,    2,    3,    4,    5,    6,   12,  138,  139,
  140,  141,  109,  110,  111,  147,  117,  119,  114,  149,
  150,  122,  105,   49,   50,   51,   52,   53,   54,   55,
   56,   13,   61,   61,   14,  159,  160,   73,   74,  100,
   75,   76,  105,  105,  105,  105,   77,   78,   80,   81,
   82,   83,   84,  105,  105,   86,   88,   87,   89,  143,
  144,  145,  146,   90,  121,  128,  100,  129,  130,  105,
  105,  131,  132,  133,  137,  142,   61,   14,  148,  154,
  155,  156,  157,  100,  161,  162,  163,  164,  165,  166,
  167,  168,  173,  174,  175,  179,  170,  171,  172,  180,
   59,    0,    0,  176,  177,  178,    0,    0,    0,  181,
  182,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   31,   31,   31,   31,   31,   31,   31,   31,
    0,    0,    0,   31,   32,   32,   32,   32,   32,   32,
   32,   32,    0,    0,    0,   32,   29,   29,   29,   29,
   29,   29,   29,   29,    0,    0,    0,   29,   46,   39,
   46,   39,    0,   15,   16,   17,   18,   19,   20,   21,
   22,   23,    0,    0,    0,   24,   24,   24,   24,   24,
   24,   24,   24,   24,    0,    0,    0,   24,   39,   97,
   16,   17,   18,   19,   20,   21,   22,   23,   11,   11,
   11,   11,   11,   11,   11,   11,   85,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  106,    0,    0,    0,    0,    0,  112,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  106,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  106,  106,  106,  106,    0,    0,
    0,    0,    0,    0,    0,  106,  106,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  106,  106,
};
short d3dxasm_check[] = {                                      41,
   41,   43,   44,   45,   46,   33,   34,   35,   46,   37,
   38,   41,   41,   43,   44,   45,   46,    9,   10,   11,
   12,   13,   14,   41,   41,   43,   44,   45,   40,   81,
  121,   45,   43,   45,   45,   87,   43,   41,   45,   28,
   43,   30,   45,   43,   43,  273,   45,  272,   15,  273,
  274,   93,   93,   98,   99,   43,   44,  148,   43,   46,
   45,   89,   90,   93,   93,   32,   33,   34,   35,   43,
   37,   38,  275,   46,  165,   93,   93,   43,  104,  263,
   44,   73,   74,   75,   76,   77,   78,   79,   80,   93,
  142,  257,  258,  259,  260,  261,  262,   46,  124,  125,
  126,  127,   82,   83,   84,  133,   98,   99,   88,  135,
  136,  103,  104,  264,  265,  266,  267,  268,  269,  270,
  271,   46,   89,   90,   46,  151,  152,   46,   46,  121,
   46,   46,  124,  125,  126,  127,   46,   46,   91,   46,
   44,   44,   44,  135,  136,   45,   44,   46,   44,  129,
  130,  131,  132,   44,   44,   93,  148,   44,   44,  151,
  152,   44,   44,   44,   41,   95,  133,  275,   44,   44,
   44,   44,   44,  165,  154,  155,  156,  157,   44,   44,
   44,   44,   44,   44,   44,   44,  166,  167,  168,   44,
   29,   -1,   -1,  173,  174,  175,   -1,   -1,   -1,  179,
  180,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  264,  265,  266,  267,  268,  269,  270,  271,
   -1,   -1,   -1,  275,  264,  265,  266,  267,  268,  269,
  270,  271,   -1,   -1,   -1,  275,  264,  265,  266,  267,
  268,  269,  270,  271,   -1,   -1,   -1,  275,  272,  273,
  272,  273,   -1,  263,  264,  265,  266,  267,  268,  269,
  270,  271,   -1,   -1,   -1,  275,  264,  265,  266,  267,
  268,  269,  270,  271,   -1,   -1,   -1,  275,  273,  274,
  264,  265,  266,  267,  268,  269,  270,  271,  264,  265,
  266,  267,  268,  269,  270,  271,   66,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   80,   -1,   -1,   -1,   -1,   -1,   86,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  104,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  124,  125,  126,  127,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  135,  136,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  151,  152,
};
#define YYFINAL 7
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 275
#if YYDEBUG
char *d3dxasm_name[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'('","')'",0,"'+'","','","'-'","'.'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'['",0,"']'",0,"'_'",
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,"T_VS","T_XVS","T_XVSW","T_XVSS","T_PS","T_XPS","T_DEF","T_OP0","T_OP1",
"T_OP2","T_OP3","T_OP4","T_OP5","T_OP6","T_OP7","T_ID","T_NUM","T_FLT","T_EOF",
};
char *d3dxasm_rule[] = {
"$accept : Shader",
"Shader : Version T_EOF",
"Shader : Version Body T_EOF",
"Version : T_VS '.' Num '.' Num",
"Version : T_PS '.' Num '.' Num",
"Version : T_XPS '.' Num '.' Num",
"Version : T_XVS '.' Num '.' Num",
"Version : T_XVSW '.' Num '.' Num",
"Version : T_XVSS '.' Num '.' Num",
"Body : Statements",
"Body : Constants Statements",
"Constants : Constant",
"Constants : Constant Constants",
"Constant : T_DEF Reg ',' Val ',' Val ',' Val ',' Val",
"Statements : Statement",
"Statements : Statement Statements",
"Statement : Op0",
"Statement : Op1 Dst",
"Statement : Op2 Dst ',' Src",
"Statement : Op3 Dst ',' Src ',' Src",
"Statement : Op4 Dst ',' Src ',' Src ',' Src",
"Statement : Op5 Src ',' Src ',' Src ',' Src ',' Src ',' Src ',' Src",
"Statement : Op6 Dst ',' Dst ',' Src ',' Src ',' Src ',' Src",
"Statement : Op7 Dst ',' Dst ',' Dst ',' Src ',' Src ',' Src ',' Src",
"Dst : Reg",
"Dst : Reg '.' Id",
"Src : Src2",
"Src : '-' Src2",
"Src : Num '-' Src2",
"Src2 : Reg",
"Src2 : Reg '.' Id",
"Reg : Id",
"Reg : Id '[' Offset ']'",
"Reg : Id '[' Offset ']' '_' Id",
"Offset : '(' Offset ')' '+' Offset",
"Offset : '(' Offset ')' '-' Offset",
"Offset : '(' Offset ')'",
"Offset : Src2",
"Offset : '-' Num",
"Offset : Num",
"Offset : Src2 '+' Offset",
"Offset : '-' Num '+' Offset",
"Offset : Num '+' Offset",
"Offset : Src2 '-' Offset",
"Offset : '-' Num '-' Offset",
"Offset : Num '-' Offset",
"Op0 : T_OP0",
"Op0 : '+' T_OP0",
"Op1 : T_OP1",
"Op1 : '+' T_OP1",
"Op2 : T_OP2",
"Op2 : '+' T_OP2",
"Op3 : T_OP3",
"Op3 : '+' T_OP3",
"Op4 : T_OP4",
"Op4 : '+' T_OP4",
"Op5 : T_OP5",
"Op5 : '+' T_OP5",
"Op6 : T_OP6",
"Op6 : '+' T_OP6",
"Op7 : T_OP7",
"Op7 : '+' T_OP7",
"Val : Num",
"Val : '+' Num",
"Val : '-' Num",
"Val : Flt",
"Val : '+' Flt",
"Val : '-' Flt",
"Id : T_ID",
"Num : T_NUM",
"Flt : T_FLT",
};
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;
    extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{ Prod(P_SHADER_0); }
break;
case 2:
{ Prod(P_SHADER_1); }
break;
case 3:
{ Prod(P_VERSION_0); }
break;
case 4:
{ Prod(P_VERSION_1); }
break;
case 5:
{ Prod(P_VERSION_XPS); }
break;
case 6:
{ Prod(P_VERSION_XVS); }
break;
case 7:
{ Prod(P_VERSION_XVSW); }
break;
case 8:
{ Prod(P_VERSION_XVSS); }
break;
case 9:
{ Prod(P_BODY_0); }
break;
case 10:
{ Prod(P_BODY_1); }
break;
case 11:
{ Prod(P_CONSTANTS_0); }
break;
case 12:
{ Prod(P_CONSTANTS_1); }
break;
case 13:
{ Prod(P_CONSTANT_0); }
break;
case 14:
{ Prod(P_STATEMENTS_0); }
break;
case 15:
{ Prod(P_STATEMENTS_1); }
break;
case 16:
{ Prod(P_STATEMENT_0); }
break;
case 17:
{ Prod(P_STATEMENT_1); }
break;
case 18:
{ Prod(P_STATEMENT_2); }
break;
case 19:
{ Prod(P_STATEMENT_3); }
break;
case 20:
{ Prod(P_STATEMENT_4); }
break;
case 21:
{ Prod(P_STATEMENT_5); }
break;
case 22:
{ Prod(P_STATEMENT_6); }
break;
case 23:
{ Prod(P_STATEMENT_7); }
break;
case 24:
{ Prod(P_DST_0); }
break;
case 25:
{ Prod(P_DST_1); }
break;
case 26:
{ Prod(P_SRC_0); }
break;
case 27:
{ Prod(P_SRC_1); }
break;
case 28:
{ Prod(P_SRC_2); }
break;
case 29:
{ Prod(P_SRC2_0); }
break;
case 30:
{ Prod(P_SRC2_1); }
break;
case 31:
{ Prod(P_REG_0); }
break;
case 32:
{ Prod(P_REG_1); }
break;
case 33:
{ Prod(P_REG_2); }
break;
case 34:
{ Prod(P_OFFSET_7); }
break;
case 35:
{ Prod(P_OFFSET_8); }
break;
case 36:
{ Prod(P_OFFSET_6); }
break;
case 37:
{ Prod(P_OFFSET_0); }
break;
case 38:
{ Prod(P_OFFSET_5); }
break;
case 39:
{ Prod(P_OFFSET_1); }
break;
case 40:
{ Prod(P_OFFSET_2); }
break;
case 41:
{ Prod(P_OFFSET_10); }
break;
case 42:
{ Prod(P_OFFSET_3); }
break;
case 43:
{ Prod(P_OFFSET_4); }
break;
case 44:
{ Prod(P_OFFSET_11); }
break;
case 45:
{ Prod(P_OFFSET_9); }
break;
case 46:
{ Prod(P_OP0_0); }
break;
case 47:
{ Prod(P_OP0_1); }
break;
case 48:
{ Prod(P_OP1_0); }
break;
case 49:
{ Prod(P_OP1_1); }
break;
case 50:
{ Prod(P_OP2_0); }
break;
case 51:
{ Prod(P_OP2_1); }
break;
case 52:
{ Prod(P_OP3_0); }
break;
case 53:
{ Prod(P_OP3_1); }
break;
case 54:
{ Prod(P_OP4_0); }
break;
case 55:
{ Prod(P_OP4_1); }
break;
case 56:
{ Prod(P_OP5_0); }
break;
case 57:
{ Prod(P_OP5_1); }
break;
case 58:
{ Prod(P_OP6_0); }
break;
case 59:
{ Prod(P_OP6_1); }
break;
case 60:
{ Prod(P_OP7_0); }
break;
case 61:
{ Prod(P_OP7_1); }
break;
case 62:
{ Prod(P_VAL_0); }
break;
case 63:
{ Prod(P_VAL_1); }
break;
case 64:
{ Prod(P_VAL_2); }
break;
case 65:
{ Prod(P_VAL_3); }
break;
case 66:
{ Prod(P_VAL_4); }
break;
case 67:
{ Prod(P_VAL_5); }
break;
case 68:
{ Prod(P_ID); }
break;
case 69:
{ Prod(P_NUM); }
break;
case 70:
{ Prod(P_FLT); }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\valbase.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// valbase.hpp
//
// Direct3D Reference Device - Vertex/PixelShader validation common infrastructure
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __VALBASE_HPP__
#define __VALBASE_HPP__

namespace XGRAPHICS {

#define SHADER_INSTRUCTION_MAX_PARAMS       7
#define SHADER_INSTRUCTION_MAX_DSTPARAMS    3
#define SHADER_INSTRUCTION_MAX_SRCPARAMS    7

typedef enum _SPEW_TYPE
{
    SPEW_INSTRUCTION_ERROR,
    SPEW_INSTRUCTION_WARNING,
    SPEW_GLOBAL_ERROR,
    SPEW_GLOBAL_WARNING
} SPEW_TYPE;

typedef enum _SHADER_VALIDATOR_FLAGS
{
    SHADER_VALIDATOR_LOG_ERRORS             = 0x1,
    SHADER_VALIDATOR_OPTIMIZE_WRITEMASKS    = 0x2
} SHADER_VALIDATOR_FLAGS;

typedef enum _DSTSHIFT
{
    DSTSHIFT_NONE   = 0x0,
    DSTSHIFT_X2     = 0x1,
    DSTSHIFT_X4     = 0x2,
    DSTSHIFT_X8     = 0x3,
    DSTSHIFT_D2     = 0xF,
    DSTSHIFT_D4     = 0xE,
    DSTSHIFT_D8     = 0xD
} DSTSHIFT;

const DWORD COMPONENT_MASKS[4] = {D3DSP_WRITEMASK_0, D3DSP_WRITEMASK_1, D3DSP_WRITEMASK_2, D3DSP_WRITEMASK_3};

#define REGNUM_OUT_OF_RANGE 0x12345678

//-----------------------------------------------------------------------------
// DSTPARAM - part of CBaseInstruction
//-----------------------------------------------------------------------------
class DSTPARAM
{
public:
    DSTPARAM();

    BOOL                            m_bParamUsed;   // Does instruction have dest param?
    UINT                            m_RegNum;
    DWORD                           m_WriteMask;    // writemasks (D3DSP_WRITEMASK_*)  
    D3DSHADER_PARAM_DSTMOD_TYPE     m_DstMod;       // D3DSPDM_NONE, D3DSPDM_BIAS (PShader)
    DSTSHIFT                        m_DstShift;     // _x2, _x4, etc. (PShader)
    D3DSHADER_PARAM_REGISTER_TYPE   m_RegType;      // _TEMP, _ADDRESS, etc.
};

//-----------------------------------------------------------------------------
// SRCPARAM - part of CBaseInstruction
//-----------------------------------------------------------------------------
class SRCPARAM
{
public:
    SRCPARAM();

    BOOL                            m_bParamUsed;   // Does instruction have this src param?
    UINT                            m_RegNum;
    DWORD                           m_SwizzleShift; // D3DVS_*_* (VShader), or D3DSP_NOSWIZZLE,
                                                    // D3DSP_REPLICATEALPHA (PShader)
    D3DVS_ADDRESSMODE_TYPE          m_AddressMode;  // D3DVS_ADDRMODE_ABSOLUTE / _RELATIVE (VShader)
    DWORD                           m_RelativeAddrComponent; // One of D3DSP_WRITEMASK_0, 1, 2, or 3. (VShader)
    D3DSHADER_PARAM_SRCMOD_TYPE     m_SrcMod;       // _NEG, _BIAS, etc.
    D3DSHADER_PARAM_REGISTER_TYPE   m_RegType;      // _TEMP, _CONST, etc.

    DWORD                           m_ComponentReadMask; // Which components instruction needs to read
};

//-----------------------------------------------------------------------------
// CBaseInstruction
//-----------------------------------------------------------------------------
class CBaseInstruction
{
public:
    CBaseInstruction(CBaseInstruction* pPrevInst);  // Append to linked list
    void SetSpewFileNameAndLineNumber(const char* pFileName, const DWORD* pLineNumber);
    void GetSpewFileNameAndLineNumber(const char** pFileName, DWORD* pLineNumber);
    // char* MakeInstructionLocatorString();
    virtual void CalculateComponentReadMasks() = 0; // which components to each source read?

    // Instruction Description
    D3DSHADER_INSTRUCTION_OPCODE_TYPE   m_Type;
    UINT                                m_DstParamCount;
    UINT                                m_SrcParamCount;
    CBaseInstruction*                   m_pPrevInst;
    CBaseInstruction*                   m_pNextInst;
    const DWORD*                        m_pSpewLineNumber; // points to line number embedded in shader by assembler (if present)
    const char*                         m_pSpewFileName;   // points to file name embedded in shader (if present)
    UINT                                m_SpewInstructionCount; // only used for spew, not for any limit checking
    BOOL    m_bCoIssue;
    UINT    m_CycleNum; // identical for co-issued instructions

    // Destination Parameter Description
    DSTPARAM    m_DstParam[SHADER_INSTRUCTION_MAX_DSTPARAMS];
    
    // Source Parameters
    SRCPARAM    m_SrcParam[SHADER_INSTRUCTION_MAX_SRCPARAMS];
};

//-----------------------------------------------------------------------------
// CAccessHistoryNode
//-----------------------------------------------------------------------------
class CAccessHistoryNode
{
public:
    CAccessHistoryNode(CAccessHistoryNode* pPreviousAccess, 
                       CAccessHistoryNode* pPreviousWriter,
                       CAccessHistoryNode* pPreviousReader,
                       CBaseInstruction* pInst,
                       BOOL bWrite );

    CAccessHistoryNode* m_pPreviousAccess;
    CAccessHistoryNode* m_pNextAccess;
    CAccessHistoryNode* m_pPreviousWriter;
    CAccessHistoryNode* m_pPreviousReader;
    CBaseInstruction*   m_pInst;
    BOOL m_bWrite;
    BOOL m_bRead;
};

//-----------------------------------------------------------------------------
// CAccessHistory
//-----------------------------------------------------------------------------
class CAccessHistory
{
public:
    CAccessHistory();
    ~CAccessHistory();
    CAccessHistoryNode* m_pFirstAccess;
    CAccessHistoryNode* m_pMostRecentAccess;
    CAccessHistoryNode* m_pMostRecentWriter;
    CAccessHistoryNode* m_pMostRecentReader;
    BOOL                m_bPreShaderInitialized;

    BOOL NewAccess(CBaseInstruction* pInst, BOOL bWrite );
    BOOL InsertReadBeforeWrite(CAccessHistoryNode* pWriteNode, CBaseInstruction* pInst);
};

//-----------------------------------------------------------------------------
// CRegisterFile
//-----------------------------------------------------------------------------
class CRegisterFile
{
    UINT    m_NumRegisters;
    BOOL    m_bWritable;
    UINT    m_NumReadPorts;
    BOOL    m_bInitOk;
public:
    #define NUM_COMPONENTS_IN_REGISTER  4
    CRegisterFile(UINT NumRegisters, BOOL bWritable, UINT NumReadPorts);
    ~CRegisterFile();

    inline UINT GetNumRegs() {return m_NumRegisters;};    
    inline BOOL IsWritable() {return m_bWritable;};    
    inline UINT GetNumReadPorts() {return m_NumReadPorts;};    
    inline BOOL InitOk() {return m_bInitOk;};    
    CAccessHistory*     m_pAccessHistory[NUM_COMPONENTS_IN_REGISTER];
};

//-----------------------------------------------------------------------------
// CBaseShaderValidator
//-----------------------------------------------------------------------------
class CBaseShaderValidator
{
protected:
    BOOL                        m_bBaseInitOk;
    DWORD                       m_Version;
    UINT                        m_SpewInstructionCount; // only used for spew, not for any limit checking
    CBaseInstruction*           m_pInstructionList;
    const DWORD*                m_pCurrToken;
    HRESULT                     m_ReturnCode;
    BOOL                        m_bSeenAllInstructions;
    DWORD                       m_ErrorCount;
    XD3DXErrorLog*              m_pLog;
    CBaseInstruction*           m_pCurrInst;
    UINT                        m_CycleNum;

    const D3DCAPS8*             m_pCaps;  // can be NULL if not provided.
    const DWORD*                m_pLatestSpewLineNumber; // points to latest line number sent in comment from D3DX Assembler
    const char*                 m_pLatestSpewFileName;   // points to latest file name sent in comment from D3DX Assembler

    // m_bSrcParamError needed by Rule_SrcInitialized (in both vshader and pshader)
    BOOL                        m_bSrcParamError[SHADER_INSTRUCTION_MAX_SRCPARAMS]; 

    virtual BOOL                DecodeNextInstruction() = 0;
    void                        DecodeDstParam( D3DSHADER_INSTRUCTION_OPCODE_TYPE instruction, DSTPARAM* pDstParam, DWORD Token );
    void                        DecodeSrcParam( SRCPARAM* pSrcParam, DWORD Token );
    virtual BOOL                InitValidation() = 0;
    void                        ValidateShader();
    virtual BOOL                ApplyPerInstructionRules() = 0;
    virtual void                ApplyPostInstructionsRules() = 0;
    virtual CBaseInstruction*   AllocateNewInstruction(CBaseInstruction* pPrevInst) = 0;
    void                        ParseCommentForAssemblerMessages(const DWORD* pComment);
    void                        Spew(   SPEW_TYPE SpewType, 
                                        CBaseInstruction* pInst /* can be NULL */, 
                                        const char* pszFormat, ... );
    char*                       MakeAffectedComponentsText( DWORD ComponentMask, 
                                                            BOOL bColorLabels = TRUE, 
                                                            BOOL bPositionLabels = TRUE);

public:
    CBaseShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags, XD3DXErrorLog* pLog );
    ~CBaseShaderValidator();

    HRESULT GetStatus() { return m_ReturnCode; }; 
};

} // namespace XGRAPHICS

#endif //__VALBASE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\valbase.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// valbase.cpp
//
// Direct3D Reference Device - PixelShader validation common infrastructure
//
///////////////////////////////////////////////////////////////////////////////
#include "pchshadeasm.h"

namespace XGRAPHICS {

//-----------------------------------------------------------------------------
// DSTPARAM::DSTPARAM
//-----------------------------------------------------------------------------
DSTPARAM::DSTPARAM()
{
    m_bParamUsed    = FALSE;
    m_RegNum        = (UINT)-1;
    m_WriteMask     = 0;
    m_DstMod        = D3DSPDM_NONE;
    m_DstShift      = (DSTSHIFT)-1;
    m_RegType       = (D3DSHADER_PARAM_REGISTER_TYPE)-1;
}

//-----------------------------------------------------------------------------
// SRCPARAM::SRCPARAM
//-----------------------------------------------------------------------------
SRCPARAM::SRCPARAM()
{  
    m_bParamUsed            = FALSE;
    m_RegNum                = (UINT)-1;
    m_SwizzleShift          = D3DSP_NOSWIZZLE;
    m_AddressMode           = D3DVS_ADDRMODE_ABSOLUTE;
    m_RelativeAddrComponent = 0;
    m_SrcMod                = D3DSPSM_NONE;
    m_RegType               = (D3DSHADER_PARAM_REGISTER_TYPE)-1;
    m_ComponentReadMask     = D3DSP_WRITEMASK_ALL;
}

//-----------------------------------------------------------------------------
// CBaseInstruction::CBaseInstruction
//-----------------------------------------------------------------------------
CBaseInstruction::CBaseInstruction(CBaseInstruction* pPrevInst)
{
    m_Type                  = D3DSIO_NOP;
    m_SrcParamCount         = 0;
    m_DstParamCount         = 0;
    m_pPrevInst             = pPrevInst;
    m_pNextInst             = NULL;
    m_pSpewLineNumber       = NULL;
    m_pSpewFileName         = NULL;
    m_SpewInstructionCount  = 0;
    m_CycleNum              = (UINT)-1;
    m_bCoIssue              = FALSE;

    if( pPrevInst )
    {
        pPrevInst->m_pNextInst = this;
    }
}

//-----------------------------------------------------------------------------
// CBaseInstruction::SetSpewFileNameAndLineNumber
//-----------------------------------------------------------------------------
void CBaseInstruction::SetSpewFileNameAndLineNumber(const char* pFileName, const DWORD* pLineNumber)
{
    m_pSpewFileName = pFileName;
    m_pSpewLineNumber = pLineNumber;
}

void CBaseInstruction::GetSpewFileNameAndLineNumber(const char** pFileName, DWORD* pLineNumber){
    *pFileName = m_pSpewFileName;
    *pLineNumber =  m_pSpewLineNumber ? *m_pSpewLineNumber : 1;
}

#if 0

//-----------------------------------------------------------------------------
// CBaseInstruction::MakeInstructionLocatorString
//
// Don't forget to 'delete' the string returned.
//-----------------------------------------------------------------------------
char* CBaseInstruction::MakeInstructionLocatorString()
{
    
    for(UINT Length = 128; Length < 65536; Length *= 2)
    {
        int BytesStored;
        char *pBuffer = new char[Length];

        if( !pBuffer )
        {
            DXGRIP("Out of memory.");
            return NULL;
        }

        if( m_pSpewFileName )
        {
            BytesStored = _snprintf( pBuffer, Length, "%s(%d) : ", 
                m_pSpewFileName, m_pSpewLineNumber ? *m_pSpewLineNumber : 1);
        }
        else
        {
            BytesStored = _snprintf( pBuffer, Length, "(Statement %d) ", 
                m_SpewInstructionCount );
        }


        if( BytesStored >= 0 )
            return pBuffer;

        delete [] pBuffer;
    }

    return NULL;
}
#endif // 0

//-----------------------------------------------------------------------------
// CAccessHistoryNode::CAccessHistoryNode
//-----------------------------------------------------------------------------
CAccessHistoryNode::CAccessHistoryNode( CAccessHistoryNode* pPreviousAccess, 
                                        CAccessHistoryNode* pPreviousWriter,
                                        CAccessHistoryNode* pPreviousReader,
                                        CBaseInstruction* pInst,
                                        BOOL bWrite )
{
    DXGASSERT(pInst);

    m_pNextAccess       = NULL;
    m_pPreviousAccess   = pPreviousAccess;
    if( m_pPreviousAccess )
        m_pPreviousAccess->m_pNextAccess = this;

    m_pPreviousWriter   = pPreviousWriter;
    m_pPreviousReader   = pPreviousReader;
    m_pInst             = pInst;
    m_bWrite            = bWrite;
    m_bRead             = !bWrite;
}

//-----------------------------------------------------------------------------
// CAccessHistory::CAccessHistory
//-----------------------------------------------------------------------------
CAccessHistory::CAccessHistory()
{
    m_pFirstAccess          = NULL;
    m_pMostRecentAccess     = NULL;
    m_pMostRecentWriter     = NULL;
    m_pMostRecentReader     = NULL;
    m_bPreShaderInitialized = FALSE;
}

//-----------------------------------------------------------------------------
// CAccessHistory::~CAccessHistory
//-----------------------------------------------------------------------------
CAccessHistory::~CAccessHistory()
{
    CAccessHistoryNode* pCurrNode = m_pFirstAccess;
    CAccessHistoryNode* pDeleteMe;
    while( pCurrNode )
    {
        pDeleteMe = pCurrNode;
        pCurrNode = pCurrNode->m_pNextAccess;
        delete pDeleteMe;
    }
}

//-----------------------------------------------------------------------------
// CAccessHistory::NewAccess
//-----------------------------------------------------------------------------
BOOL CAccessHistory::NewAccess(CBaseInstruction* pInst, BOOL bWrite )
{
    m_pMostRecentAccess = new CAccessHistoryNode(   m_pMostRecentAccess, 
                                                    m_pMostRecentWriter,
                                                    m_pMostRecentReader,
                                                    pInst,
                                                    bWrite );
    if( NULL == m_pMostRecentAccess )
    {
        return FALSE;   // out of memory
    }
    if( m_pFirstAccess == NULL )
    {
        m_pFirstAccess = m_pMostRecentAccess;            
    }
    if( bWrite )
    {
        m_pMostRecentWriter = m_pMostRecentAccess;
    }
    else // it is a read.
    {
        m_pMostRecentReader = m_pMostRecentAccess;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CAccessHistory::InsertReadBeforeWrite
//-----------------------------------------------------------------------------
BOOL CAccessHistory::InsertReadBeforeWrite(CAccessHistoryNode* pWriteNode, CBaseInstruction* pInst)
{
    DXGASSERT(pWriteNode && pWriteNode->m_bWrite && pInst );

    // append new node after node before pWriteNode
    CAccessHistoryNode* pReadBeforeWrite 
                        = new CAccessHistoryNode(  pWriteNode->m_pPreviousAccess, 
                                                   pWriteNode->m_pPreviousWriter,
                                                   pWriteNode->m_pPreviousReader,
                                                   pInst,
                                                   FALSE);
    if( NULL == pReadBeforeWrite )
    {
        return FALSE; // out of memory
    }

    // Patch up all the dangling pointers

    // Pointer to first access may change
    if( m_pFirstAccess == pWriteNode )
    {
        m_pFirstAccess = pReadBeforeWrite;
    }

    // Pointer to most recent reader may change
    if( m_pMostRecentReader == pWriteNode->m_pPreviousReader )
    {
        m_pMostRecentReader = pReadBeforeWrite;
    }

    // Update all m_pPreviousRead pointers that need to be updated to point to the newly
    // inserted read.
    CAccessHistoryNode* pCurrAccess = pWriteNode;
    while(pCurrAccess && 
         !(pCurrAccess->m_bRead && pCurrAccess->m_pPreviousAccess && pCurrAccess->m_pPreviousAccess->m_bRead) )
    {
        pCurrAccess->m_pPreviousReader = pReadBeforeWrite;
        pCurrAccess = pCurrAccess->m_pPreviousAccess;
    }

    // re-attach pWriteNode and the accesses linked after it back to the original list
    pWriteNode->m_pPreviousAccess = pReadBeforeWrite;
    pReadBeforeWrite->m_pNextAccess = pWriteNode;

    return TRUE;
}

//-----------------------------------------------------------------------------
// CRegisterFile::CRegisterFile
//-----------------------------------------------------------------------------
CRegisterFile::CRegisterFile(UINT NumRegisters, BOOL bWritable, UINT NumReadPorts)
{
    m_bInitOk = FALSE;
    m_NumRegisters = NumRegisters;
    m_bWritable = bWritable;
    m_NumReadPorts = NumReadPorts;

    BOOL bAssumeInitialized = (!bWritable && NumReadPorts > 0);
    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        if( m_NumRegisters )
        {
            m_pAccessHistory[i] = new CAccessHistory[m_NumRegisters];
            if( NULL == m_pAccessHistory[i] )
            {
                DXGRIP( "Direct3D Shader Validator: Out of memory.\n" );
                m_NumRegisters = 0;
                return;
            }
        }
        else {
            m_pAccessHistory[i] = NULL;
        }
        for( UINT j = 0; j < m_NumRegisters; j++ )
        {
            if( bAssumeInitialized )
                m_pAccessHistory[i][j].m_bPreShaderInitialized = TRUE;
        }
        // To get the access history for a component of a register, use:
        // m_pAccessHistory[component][register number]
    }
}

//-----------------------------------------------------------------------------
// CRegisterFile::~CRegisterFile
//-----------------------------------------------------------------------------
CRegisterFile::~CRegisterFile()
{
    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        delete [] m_pAccessHistory[i];
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::CBaseShaderValidator
//-----------------------------------------------------------------------------
CBaseShaderValidator::CBaseShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags, XD3DXErrorLog* pLog )
{
    m_ReturnCode            = E_FAIL;  // do this first.
    m_bBaseInitOk           = FALSE;

    m_pLog                  = pLog;
    if( NULL == m_pLog )
    {
        DXGRIP("D3D Shader Validator: no error log.\n");
        return;
    }

    // ----------------------------------------------------
    // Member variable initialization
    //

    m_pCaps                 = pCaps;
    m_ErrorCount            = 0;
    m_bSeenAllInstructions  = FALSE;
    m_SpewInstructionCount  = 0;
    m_pInstructionList      = NULL;
    m_pCurrInst             = NULL;
    m_pCurrToken            = pCode; // can be null - vertex shader fixed function 
    if( m_pCurrToken )
        m_Version           = *(m_pCurrToken++);
    else
        m_Version           = 0;

    m_pLatestSpewLineNumber = NULL; 
    m_pLatestSpewFileName   = NULL;
    m_CycleNum              = 0;

    for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
    {
        m_bSrcParamError[i] = FALSE;
    }

    m_bBaseInitOk           = TRUE;
    return;
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::~CBaseShaderValidator
//-----------------------------------------------------------------------------
CBaseShaderValidator::~CBaseShaderValidator()
{
    while( m_pCurrInst )    // Delete the linked list of instructions
    {
        CBaseInstruction* pDeleteMe = m_pCurrInst;
        m_pCurrInst = m_pCurrInst->m_pPrevInst;
        delete pDeleteMe;
    }
}


//-----------------------------------------------------------------------------
// CBaseShaderValidator::DecodeDstParam
//-----------------------------------------------------------------------------
void CBaseShaderValidator::DecodeDstParam( D3DSHADER_INSTRUCTION_OPCODE_TYPE instruction, DSTPARAM* pDstParam, DWORD Token )
{
    DXGASSERT(pDstParam);
    pDstParam->m_bParamUsed = TRUE;
    pDstParam->m_RegNum = Token & D3DSP_REGNUM_MASK;
    pDstParam->m_WriteMask = Token & D3DSP_WRITEMASK_ALL;
    pDstParam->m_DstMod = (D3DSHADER_PARAM_DSTMOD_TYPE)(Token & D3DSP_DSTMOD_MASK);
    pDstParam->m_DstShift = (DSTSHIFT)((Token & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT );
    pDstParam->m_RegType = (D3DSHADER_PARAM_REGISTER_TYPE)(Token & D3DSP_REGTYPE_MASK);
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::DecodeSrcParam
//-----------------------------------------------------------------------------
void CBaseShaderValidator::DecodeSrcParam( SRCPARAM* pSrcParam, DWORD Token )
{
    DXGASSERT(pSrcParam);
    pSrcParam->m_bParamUsed = TRUE;
    pSrcParam->m_RegNum = Token & D3DSP_REGNUM_MASK;
    pSrcParam->m_SwizzleShift = Token & D3DSP_SWIZZLE_MASK;
    pSrcParam->m_AddressMode = (D3DVS_ADDRESSMODE_TYPE)(Token & D3DVS_ADDRESSMODE_MASK);
    pSrcParam->m_RelativeAddrComponent = COMPONENT_MASKS[(Token >> 14) & 0x3];
    pSrcParam->m_SrcMod = (D3DSHADER_PARAM_SRCMOD_TYPE)(Token & D3DSP_SRCMOD_MASK);
    pSrcParam->m_RegType = (D3DSHADER_PARAM_REGISTER_TYPE)(Token & D3DSP_REGTYPE_MASK);
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::ValidateShader
//-----------------------------------------------------------------------------
void CBaseShaderValidator::ValidateShader()
{
    m_SpewInstructionCount++; // Consider the version token as the first
                              // statement (1) for spew counting.

    if( !InitValidation() )                 // i.e. Set up max register counts
    {
        // Returns false on:
        // 1) Unrecognized version token, 
        // 2) Pixel shader version (0xff,0xff) - in this case
        //    case InitValidation() sets m_ReturnCode to S_OK.
        //    We are just forcing validation to succeed for version (0xff,0xff)
        // 3) Vertex shader declaration validation with no shader code (fixed function).
        //    In this case InitValidation() sets m_ReturnCode as appropriate.
        return;
    }

    // Loop through all the instructions
    while( *m_pCurrToken != D3DPS_END() )
    {
        m_pCurrInst = AllocateNewInstruction(m_pCurrInst);  // New instruction in linked list
        if( NULL == m_pCurrInst )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory." );
            return;
        }
        if( NULL == m_pInstructionList )
            m_pInstructionList = m_pCurrInst;

        if( !DecodeNextInstruction() )
            return;
        
        // Skip comments
        if( m_pCurrInst->m_Type == D3DSIO_COMMENT )
        {
            CBaseInstruction* pDeleteMe = m_pCurrInst;
            m_pCurrInst = m_pCurrInst->m_pPrevInst;
            if( pDeleteMe == m_pInstructionList )
                m_pInstructionList = NULL;
            delete pDeleteMe;
            continue; 
        }

        for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
        {
            m_bSrcParamError[i] = FALSE;
        }

        // Apply all the per-instruction rules - order the rule checks sensibly.
        // Note: Rules only return FALSE if they find an error that is so severe that it is impossible to
        //       continue validation.

        if( !ApplyPerInstructionRules() )
            return;
    }

    m_bSeenAllInstructions = TRUE;

    // Apply any rules that also need to run after all instructions seen.
    // 
    // NOTE: It is possible to get here with m_pCurrInst == NULL, if there were no
    // instructions.  So any rules you add here must be able to account for that
    // possiblity.
    //
    ApplyPostInstructionsRules();

    // If no errors, then success!
    if( 0 == m_ErrorCount )
        m_ReturnCode = D3D_OK;
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::ParseCommentForAssemblerMessages
//-----------------------------------------------------------------------------
void CBaseShaderValidator::ParseCommentForAssemblerMessages(const DWORD* pComment)
{
    if( !pComment )
        return;

    // There must be at least 2 DWORDS in the comment
    if( (((*(pComment++)) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT) < 2 )
        return;

    switch(*(pComment++))
    {
    case MAKEFOURCC('F','I','L','E'):
        m_pLatestSpewFileName = (const char*)pComment;
        break;
    case MAKEFOURCC('L','I','N','E'):
        m_pLatestSpewLineNumber = pComment;
        break;
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::Spew
//-----------------------------------------------------------------------------
void CBaseShaderValidator::Spew(    SPEW_TYPE SpewType, 
                                    CBaseInstruction* pInst /* can be NULL */, 
                                    const char* pszFormat, ... )
{
    int Length = 128;
    char* pBuffer = NULL;
    va_list marker;

    if( !m_pLog )
        return;
    
    while( pBuffer == NULL )
    {
        int BytesStored = 0;
        int BytesLeft = Length;
        char *pIndex    = NULL;

        pBuffer = new char[Length];
        if( !pBuffer )
        {
            DXGRIP("Out of memory.\n");
            return;
        }
        pIndex = pBuffer;

        const char* pFileName = NULL;
        DWORD lineNumber = 0;
        // Code location text
        switch( SpewType )
        {
        case SPEW_INSTRUCTION_ERROR:
            if( pInst )
                pInst->GetSpewFileNameAndLineNumber(&pFileName, &lineNumber);
            break;
        }

        // Spew text prefix
        switch( SpewType )
        {
        case SPEW_INSTRUCTION_ERROR:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Validation Error) " );
            break;
        case SPEW_GLOBAL_ERROR:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Validation Global Error) " );
            break;
        case SPEW_INSTRUCTION_WARNING:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Validation Warning) " );
            break;
        case SPEW_GLOBAL_WARNING:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Validation Global Warning) " );
            break;
        }
        if( BytesStored < 0 ) goto OverFlow;
        BytesLeft -= BytesStored; 
        pIndex += BytesStored;

        // Formatted text
        va_start( marker, pszFormat );
        BytesStored = _vsnprintf( pIndex, BytesLeft - 1, pszFormat, marker );
        va_end( marker );

        if( BytesStored < 0 ) goto OverFlow;
        BytesLeft -= BytesStored;
        pIndex += BytesStored;

        m_pLog->Log(SpewType == SPEW_INSTRUCTION_ERROR || SpewType ==SPEW_GLOBAL_ERROR,
            ERROR_ASM_VALIDATOR_ERROR, pFileName, lineNumber, pBuffer);

        delete [] pBuffer;
        break;
OverFlow:
        delete [] pBuffer;
        pBuffer = NULL;
        Length = Length * 2;
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::MakeAffectedComponentsText
//
// Note that the string returned is STATIC.
//-----------------------------------------------------------------------------
char* CBaseShaderValidator::MakeAffectedComponentsText( DWORD ComponentMask, 
                                                        BOOL bColorLabels, 
                                                        BOOL bPositionLabels)
{
    char* ColorLabels[4] = {"R/", "G/", "B/", "A/"};
    char* PositionLabels[4] = {"X/", "Y/", "Z/", "W/"};
    char* NumericLabels[4] = {"0 ", "1 ", "2 ", "3"}; // always used
    static char s_AffectedComponents[28]; // enough to hold "*R/X/0 *G/Y/1 *B/Z/2 *A/W/3"
    UINT  LabelCount = 0;

    s_AffectedComponents[0] = '\0';

    for( UINT i = 0; i < 4; i++ )
    {
        if( COMPONENT_MASKS[i] & ComponentMask )
        {
            strcat( s_AffectedComponents, "*" );
        }
        if( bColorLabels )
            strcat( s_AffectedComponents, ColorLabels[i] );
        if( bPositionLabels )
            strcat( s_AffectedComponents, PositionLabels[i] );

        strcat( s_AffectedComponents, NumericLabels[i] ); // always used
    }
    return s_AffectedComponents;
}

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\vc6\lipovsh\stdafx.h ===
#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include "d3d8-xbox.h"
#endif

#include "xgraphics.h"

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\vc6\lipovsh\lipovsh.cpp ===
#include "stdafx.h"

#ifdef XBOX
#error lipovsh doesn't work on xbox!
#endif

void syntax() {
	printf("LipoVSH: Copyright (c) Microsoft Corperation.\n");
	printf("debugging tool to simplify a vertex shader that breaks an optimizer\n");
	printf("Syntax: LipoVsh In Out\n");
	printf("In: file that breaks the shader assembler optimizer\n");
	printf("Out: location to place the smallest version of 'In' that still breaks.\n");
}

int __cdecl main(int argc, char* argv[])
{
	HANDLE in = INVALID_HANDLE_VALUE;
	HANDLE out = INVALID_HANDLE_VALUE;
	HRESULT hr = 0;
	char*buf = 0;
	DWORD size = 0;

	if(argc != 3) {
		syntax();
		return E_FAIL;
	}

	in = CreateFile(argv[1], GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);
	if(in == INVALID_HANDLE_VALUE) {
		hr = E_FAIL;
	}
	if(SUCCEEDED(hr)) {
		out = CreateFile(argv[2], GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, 0);
		if(out == INVALID_HANDLE_VALUE) {
			hr = E_FAIL;
		}
	}
	if(SUCCEEDED(hr)) {
		size = GetFileSize(in,0);
		buf = (char*)malloc(size + 1);
		if(buf == 0) {
			hr = E_OUTOFMEMORY;
		}
	}
	if(SUCCEEDED(hr)) {
		DWORD size2;
		ReadFile(in, buf, size, &size2, 0);
		buf[size] = '\0';
		if(size2 != size) {
			hr = E_UNEXPECTED;
		}
	}

//the loop
	if(SUCCEEDED(hr)) {
		int i;
		char b;
		bool br = false;
		LPXGBUFFER blah = 0, blah2 = 0;
		LPXGBUFFER err = 0;


		if(SUCCEEDED(AssembleShader(argv[1], buf, size, SASM_VERIFY_OPTIMIZATIONS, NULL, &blah2, NULL, NULL, NULL, NULL, 0))) {
			printf("shader doesn't break with optimizer on!\n");
			hr = E_FAIL;
		}
		if(SUCCEEDED(hr) && FAILED(AssembleShader(argv[1], buf, size, SASM_DONOTOPTIMIZE, NULL, &blah, &err, NULL, NULL, NULL, 0))) {
			if(strstr((char*)XGBuffer_GetBufferPointer(err), "Too many microcode instructions")) {
			} else {
				printf("shader doesn't assemble with no optimizations !\n");
				hr = E_FAIL;
			}
			RELEASE(err);
		}
		if(SUCCEEDED(hr)) {
			for(i = size - 1; i >= 0; i--) {
				if(buf[i] == '\n') {
					b = buf[i+1];
					if(b == '\0') continue;
					buf[i+1] = ';'; //comment this line
					
					if(FAILED(AssembleShader(argv[1], buf, size, SASM_DONOTOPTIMIZE, NULL, &blah, &err, NULL, NULL, NULL, 0))) {
						if(strstr((char*)XGBuffer_GetBufferPointer(err), "Too many microcode instructions")) {
						} else {
							printf("doesn't assemble\n");
							buf[i+1] = b;
						}
					} 
					if(SUCCEEDED(AssembleShader(argv[1], buf, size, SASM_VERIFY_OPTIMIZATIONS, NULL, &blah2, NULL, NULL, NULL, NULL, 0))) {
						buf[i+1] = b;
					}

					RELEASE(err);
					RELEASE(blah);
					RELEASE(blah2);
				}
			}
		}
	}

	if(SUCCEEDED(hr)) {
		DWORD head;
		bool dontwrite = false;
		DWORD blah;
		for(head = 0; head < size; head++) {
			if(buf[head] == ';') dontwrite=true;
			if(!dontwrite) WriteFile(out, &buf[head], 1, &blah, 0);
			if(buf[head] == '\n') dontwrite=false;
		}
	}

	if(buf) free(buf);
	if(in != INVALID_HANDLE_VALUE) CloseHandle(in);
	if(out != INVALID_HANDLE_VALUE) CloseHandle(out);

	_asm {int 3};
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\vshdrval.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// vshdrval.cpp
//
// Direct3D Reference Device - VertexShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pchshadeasm.h"

namespace XGRAPHICS {


// Use these macros when looking at CVSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_VS_INST   ((CVSInstruction*)m_pCurrInst)
#define _PREV_VS_INST   (m_pCurrInst?((CVSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

//-----------------------------------------------------------------------------
// VertexShader Validation Rule Coverage
//
// Below is the list of rules in "DX8 VertexShader Version Specification",
// matched to the function(s) in this file which enforce them.
// Note that the mapping from rules to funtions can be 1->n or n->1
//
// Generic Rules
// -------------
//
// VS-G1:           Rule_oPosWritten
// VS-G2:           Rule_ValidAddressRegWrite
//
// Vertex Shader Version 1.0 Rules
// ------------------------------
//
// VS.1.0-1:        Rule_ValidAddressRegWrite
//
// Vertex Shader Version 1.1 Rules
// ------------------------------
//
// VS.1.1-1:        Rule_ValidInstructionCount
// VS.1.1-2:        Rule_ValidAddressRegWrite, Rule_ValidSrcParams
// VS.1.1-3:        Rule_ValidFRCInstruction
// VS.1.1-4:        ?
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CVSInstruction::CalculateComponentReadMasks()
//-----------------------------------------------------------------------------
void CVSInstruction::CalculateComponentReadMasks()
{
    for( UINT i = 0; i < m_SrcParamCount; i++ )
    {
        DWORD PostSwizzleComponentReadMask = 0;
        switch( m_Type )
        {
            case D3DSIO_ADD:
            case D3DSIO_FRC:
            case D3DSIO_MAD:
            case D3DSIO_MAX:
            case D3DSIO_MIN:
            case D3DSIO_MOV:
            case D3DSIO_MUL:
            case D3DSIO_SLT:
            case D3DSIO_SGE:
                PostSwizzleComponentReadMask = m_DstParam[0].m_WriteMask; // per-component ops.
                break;
            case D3DSIO_DPH: // Tricky: one operand is 3, the other is 4.
                if( 0 == i)
                    PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                else if( 1 == i) 
                    PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_DP3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_DP4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_LIT:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_DST:
                if( 0 == i )        PostSwizzleComponentReadMask = D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                else if( 1 == i )   PostSwizzleComponentReadMask = D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_EXP:
            case D3DSIO_LOG:
            case D3DSIO_EXPP:
            case D3DSIO_LOGP:
            case D3DSIO_RCC:
            case D3DSIO_RCP:
            case D3DSIO_RSQ:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_M3x2:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M3x3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M3x4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M4x3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_M4x4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_NOP:
            default:
                break;
        }

        // Now that we know which components of the source will be used by the instruction,
        // we need to figure out which components of the actual source register need to be read to provide the data,
        // taking into account source component swizzling.
        m_SrcParam[i].m_ComponentReadMask = 0;
        for( UINT j = 0; j < 4; j++ )
        {
            if( PostSwizzleComponentReadMask & COMPONENT_MASKS[j] )
                m_SrcParam[i].m_ComponentReadMask |= COMPONENT_MASKS[(m_SrcParam[i].m_SwizzleShift >> (D3DVS_SWIZZLE_SHIFT + j*2)) & 3];
        }
    }
}

//-----------------------------------------------------------------------------
// CVShaderValidator::CVShaderValidator
//-----------------------------------------------------------------------------
CVShaderValidator::CVShaderValidator( const DWORD* pCode, 
                                      const DWORD* pDecl,
                                      const D3DCAPS8* pCaps,
                                      DWORD Flags,
                                      XD3DXErrorLog* pLog) 
                                      : CBaseShaderValidator( pCode, pCaps, Flags, pLog )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.  
    // Only set m_ReturnCode to S_OK if validation has succeeded, 
    // before exiting this constructor.

    m_pDecl                     = pDecl;
    m_bFixedFunction            = pDecl && !pCode;

    m_pTempRegFile              = NULL;
    m_pInputRegFile             = NULL;
    m_pConstRegFile             = NULL;
    m_pAddrRegFile              = NULL;
    m_pTexCrdOutputRegFile      = NULL;
    m_pAttrOutputRegFile        = NULL;
    m_pRastOutputRegFile        = NULL;

    m_bXboxExtensions = (Flags & VSF_XBOXEXTENSIONS) != 0;
    m_bReadWriteShader = (Flags & VSF_READWRITESHADER) != 0;
    m_bStateShader= (Flags & VSF_STATESHADER) != 0;

    if( NULL == pCode && NULL == pDecl )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Code and declaration pointers passed into shader vertex shader validator cannot both be NULL.");
        return;
    }

    if( !m_bBaseInitOk )
        return;

    ValidateShader(); // If successful, m_ReturnCode will be set to S_OK.
                      // Call GetStatus() on this object to determine validation outcome.
}

//-----------------------------------------------------------------------------
// CVShaderValidator::~CVShaderValidator
//-----------------------------------------------------------------------------
CVShaderValidator::~CVShaderValidator()
{
    delete m_pTempRegFile;
    delete m_pInputRegFile;
    delete m_pConstRegFile;
    delete m_pAddrRegFile;
    delete m_pTexCrdOutputRegFile;
    delete m_pAttrOutputRegFile;
    delete m_pRastOutputRegFile;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::AllocateNewInstruction
//-----------------------------------------------------------------------------
CBaseInstruction* CVShaderValidator::AllocateNewInstruction(CBaseInstruction*pPrevInst)
{
    return new CVSInstruction((CVSInstruction*)pPrevInst);
}

//-----------------------------------------------------------------------------
// CVShaderValidator::DecodeNextInstruction
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::DecodeNextInstruction()
{
    m_pCurrInst->m_Type = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)(*m_pCurrToken & D3DSI_OPCODE_MASK);

    if( m_pCurrInst->m_Type == D3DSIO_COMMENT )
    {
        ParseCommentForAssemblerMessages(m_pCurrToken); // does not advance m_pCurrToken

        // Skip comments
        DWORD NumDWORDs = ((*m_pCurrToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
        m_pCurrToken += (NumDWORDs+1);
        return TRUE;
    }

    // If the assembler has sent us file and/or line number messages,
    // received by ParseCommentForAssemblerMesssages(), 
    // then bind this information to the current instruction.
    // This info can be used in error spew to direct the shader developer
    // to exactly where a problem is located.
    m_pCurrInst->SetSpewFileNameAndLineNumber(m_pLatestSpewFileName,m_pLatestSpewLineNumber);

    if( *m_pCurrToken & D3DSI_COISSUE )
    {
        m_pCurrInst->m_bCoIssue = TRUE;
    }
    else
    {
        m_CycleNum++; // First cycle is 1. (co-issued instructions will have same cycle number)
    }
    m_pCurrInst->m_CycleNum = m_CycleNum;

    m_pCurrToken++;

    m_SpewInstructionCount++; // only used for spew, not for any limits
    m_pCurrInst->m_SpewInstructionCount = m_SpewInstructionCount;

  
    // Decode dst param
    if (*m_pCurrToken & (1L<<31))
    {
        (m_pCurrInst->m_DstParamCount)++;
        DecodeDstParam( m_pCurrInst->m_Type, &m_pCurrInst->m_DstParam[0], *(m_pCurrToken++) );
    }

    // Decode src param(s)
    while (*m_pCurrToken & (1L<<31))
    {   
        (m_pCurrInst->m_SrcParamCount)++;
        if( (m_pCurrInst->m_DstParamCount + m_pCurrInst->m_SrcParamCount) > SHADER_INSTRUCTION_MAX_PARAMS )
        {
            m_pCurrToken++; // eat up extra parameters and skip to next
            continue;
        }
        
        // Below: index is [SrcParamCount - 1] because m_SrcParam array needs 0 based index.
        DecodeSrcParam( &(m_pCurrInst->m_SrcParam[m_pCurrInst->m_SrcParamCount - 1]),*(m_pCurrToken++) );
    }

    // Figure out which components of each source operand actually need to be read,
    // taking into account destination write mask, the type of instruction, source swizzle, etc.
    m_pCurrInst->CalculateComponentReadMasks();

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::InitValidation
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::InitValidation()
{
    if( m_bFixedFunction ) 
    {
        m_pTempRegFile              = new CRegisterFile(0,FALSE,0);// #regs, bWritable, max# reads/instruction
        m_pInputRegFile             = new CRegisterFile(17,FALSE,0);
        m_pConstRegFile             = new CRegisterFile(0,FALSE,0);
        m_pAddrRegFile              = new CRegisterFile(0,FALSE,0);
        m_pTexCrdOutputRegFile      = new CRegisterFile(0,FALSE,0);
        m_pAttrOutputRegFile        = new CRegisterFile(0,FALSE,0);
        m_pRastOutputRegFile        = new CRegisterFile(0,FALSE,0);
    }
    else
    {    
        if( m_pCaps )
        {
            if( (m_pCaps->VertexShaderVersion & 0x0000FFFF) < (m_Version & 0x0000FFFF) )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Vertex shader version %d.%d is too high for device. Maximum supported version is %d.%d. Aborting shader validation.",
                        D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version), 
                        D3DSHADER_VERSION_MAJOR(m_pCaps->VertexShaderVersion),D3DSHADER_VERSION_MINOR(m_pCaps->VertexShaderVersion));
                return FALSE;
            }
        }

        switch( m_Version >> 16 )
        {
        case 0xffff:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version token: 0x%x indicates a pixel shader.  Vertex shader version token must be of the form 0xfffe****.",
                    m_Version);
            return FALSE;
        case 0xfffe:
            break; // vertexshader - ok.
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x is invalid. Vertex shader version token must be of the form 0xfffe****. Aborting vertex shader validation.",
                    m_Version);
            return FALSE;
        }

        DWORD rRegCount = m_bXboxExtensions ? 13 : 12;
        DWORD cRegCount = 192; // But see GetMinRegNumber, which makes only registers 96..192 used for non-Xbox shaders
        DWORD vRegCount = m_bStateShader ? 1 : 16; // DX8 version said 17, but that's wrong
        DWORD otRegCount = m_bStateShader ? 0 : (m_bXboxExtensions ? 4 : 8);
        DWORD oaRegCount = m_bStateShader ? 0 : (m_bXboxExtensions ? 4 : 2);
        DWORD orRegCount = m_bStateShader ? 0 : 3;

        DWORD aRegCount = (m_Version == D3DVS_VERSION(1,1)) ? 1 : 0;

        BOOL cRegWritable = m_bReadWriteShader;

        BOOL outRegWritable = ! m_bStateShader;

        switch(m_Version)
        {
        case D3DVS_VERSION(1,0):    // DX8
        case D3DVS_VERSION(1,1):    // DX8
            m_pTempRegFile              = new CRegisterFile(rRegCount,TRUE,3);// #regs, bWritable, max# reads/instruction
            m_pInputRegFile             = new CRegisterFile(vRegCount,FALSE,1);
            m_pConstRegFile             = new CRegisterFile(cRegCount,cRegWritable,1);
            m_pAddrRegFile              = new CRegisterFile(aRegCount,TRUE,0);
            m_pTexCrdOutputRegFile      = new CRegisterFile(otRegCount,outRegWritable,0);
            m_pAttrOutputRegFile        = new CRegisterFile(oaRegCount,outRegWritable,0);
            m_pRastOutputRegFile        = new CRegisterFile(orRegCount,outRegWritable,0);
            break;
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: %d.%d is not a supported vertex shader version. Aborting vertex shader validation.",
                    D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
            return FALSE;
        }

    }

    if( NULL == m_pTempRegFile ||
        NULL == m_pInputRegFile ||
        NULL == m_pConstRegFile ||
        NULL == m_pAddrRegFile ||
        NULL == m_pTexCrdOutputRegFile ||
        NULL == m_pAttrOutputRegFile ||
        NULL == m_pRastOutputRegFile )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.");
        return FALSE;
    }

    ValidateDeclaration(); // no matter what happens here, we can continue checking shader code, if present.

    if( m_bFixedFunction ) // no shader code - fixed function, so we only validate declaration
    {
        if( 0 == m_ErrorCount )
            m_ReturnCode = S_OK;

        return FALSE; // returning false just makes validation stop here (not for indicating success/failure of validation)
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ValidateDeclaration
//-----------------------------------------------------------------------------
void CVShaderValidator::ValidateDeclaration()
{
    if( !m_pDecl ) // no shader declaration passed in.
        return;

    DXGASSERT(m_pInputRegFile);

    typedef struct _NORMAL_GEN {
        UINT DestReg;
        UINT SourceReg;
        UINT TokenNum;
    } NORMAL_GEN;

    const DWORD*    pCurrToken                 = m_pDecl;
    DWORD           MaxStreams                 = 0;
    UINT            TokenNum                   = 1;
    UINT            NumInputRegs               = m_pInputRegFile->GetNumRegs();
    BOOL            bInStream                  = FALSE;
    BOOL*           pVertexStreamDeclared      = NULL;
    BOOL            bInTessStream              = FALSE;
    BOOL            bTessStreamDeclared        = FALSE;
    BOOL            bAtLeastOneDataDefinition  = FALSE;
    NORMAL_GEN*     pNormalGenOperations       = new NORMAL_GEN[m_pInputRegFile->GetNumRegs()];
    UINT            NumNormalGenOperations     = 0;
    BOOL            bErrorInForLoop            = FALSE;

    if( NULL == pNormalGenOperations )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.  Aborting shader decl. validation.");
        m_ErrorCount++;
        goto Exit;
    }
                                
    DXGASSERT(m_pConstRegFile && m_pInputRegFile);

    if( m_pCaps ) // only validate stream numbers when caps present
    {
        MaxStreams = m_pCaps->MaxStreams;
        if( MaxStreams > 0 )
        {
            pVertexStreamDeclared  = new BOOL[MaxStreams];
            if( NULL == pVertexStreamDeclared )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.  Aborting shader decl. validation.");
                m_ErrorCount++;
                goto Exit;
            }

            for( UINT i = 0; i < MaxStreams; i++ )
                pVertexStreamDeclared[i] = FALSE;
        }
    }

    // The constructor for the input register file assumed that the input regs were initialized,
    // but now that we are parsing a shader declaration, 
    // we can check initialization of input registers.
    {
        for( UINT i = 0; i < 4; i++ )
        {
            for( UINT j = 0; j < m_pInputRegFile->GetNumRegs(); j++ )
                m_pInputRegFile->m_pAccessHistory[i][j].m_bPreShaderInitialized = FALSE;
        }
    }
    
    // Now parse the declaration.
    while( D3DVSD_END() != *pCurrToken )
    {
        DWORD Token             = *pCurrToken;
        switch( (Token & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT )
        {
        case D3DVSD_TOKEN_NOP:
            break;
        case D3DVSD_TOKEN_STREAM:
        {
            UINT StreamNum = (Token & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT;
            bInTessStream = (Token & D3DVSD_STREAMTESSMASK) >> D3DVSD_STREAMTESSSHIFT;
            bInStream = !bInTessStream;
            bAtLeastOneDataDefinition = FALSE;

            if( bInStream )
            {
                if( m_pCaps && (StreamNum >= MaxStreams) )
                {
                    if( MaxStreams )
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d is out of range. Max allowed is %d.  Aborting shader decl. validation.",
                                    TokenNum, StreamNum, m_pCaps->MaxStreams - 1);
                    else
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d is out of range. There are no streams available.  Aborting shader decl. validation.",
                                    TokenNum, StreamNum, m_pCaps->MaxStreams - 1);

                    m_ErrorCount++;
                    goto Exit;
                }
            }
            else if( StreamNum > 0 )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number must not be specified for tesselator stream.",
                            TokenNum);
                m_ErrorCount++;
            }

            if( bInStream && pVertexStreamDeclared )
            {
                if( TRUE == pVertexStreamDeclared[StreamNum] )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d has already been declared.  Aborting shader decl. validation.",
                                TokenNum, StreamNum );
                    m_ErrorCount++;
                    goto Exit;
                }
                pVertexStreamDeclared[StreamNum] = TRUE;                
            }

            if( bInTessStream )
            {
                if( bTessStreamDeclared )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Tesselation stream has already been declared.  Aborting shader decl. validation.",
                                TokenNum);
                    m_ErrorCount++;
                    goto Exit;
                }
                bTessStreamDeclared = TRUE;
            }

            break;
        }
        case D3DVSD_TOKEN_STREAMDATA:
            if( !bInStream )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Cannot set stream input without first setting stream #.  Aborting shader decl. validation.",
                            TokenNum);
                m_ErrorCount++;
                goto Exit;
            }
            if( (Token & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT ) // SKIP
            {
                if( m_bFixedFunction )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: SKIP not permitted in fixed-function declarations.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }
            }
            else
            {
                UINT RegNum = (Token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT; 
                if( RegNum >= m_pInputRegFile->GetNumRegs() )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid reg num: %d. Max allowed is %d.",
                           TokenNum, RegNum, m_pInputRegFile->GetNumRegs() - 1);
                    m_ErrorCount++;
                    break;
                }
                
                switch( (Token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT )
                {
                case D3DVSDT_FLOAT1:
                case D3DVSDT_FLOAT2:
                case D3DVSDT_FLOAT3:
                case D3DVSDT_FLOAT4:
                case D3DVSDT_D3DCOLOR:
                case D3DVSDT_SHORT2:
                case D3DVSDT_SHORT4:
                    break;
                default:
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Unrecognized stream data type.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }

                bErrorInForLoop = FALSE;
                for( UINT i = 0; i < 4; i++ )
                {
                    if( TRUE == m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register %d already declared.",
                                    TokenNum, RegNum);
                        m_ErrorCount++;
                        bErrorInForLoop = TRUE;
                        break;
                    }
                    m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized = TRUE;
                }
                if( bErrorInForLoop )
                    break;

                bAtLeastOneDataDefinition = TRUE;
            }
            break;
        case D3DVSD_TOKEN_TESSELLATOR:
        {
            if( !bInTessStream )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Cannot set tesselator stream input without first setting tesselator stream #.  Aborting shader decl. validation.",
                            TokenNum);
                m_ErrorCount++;
                goto Exit;
            }

            DWORD InRegNum = (Token & D3DVSD_VERTEXREGINMASK) >> D3DVSD_VERTEXREGINSHIFT;
            DWORD RegNum = (Token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;
            BOOL  bNormalGen = !(Token & 0x10000000); // TODO: Why isnt there a const for this in the d3d api headers?

            if( RegNum >= m_pInputRegFile->GetNumRegs() )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid reg num: %d. Max allowed is %d.",
                       TokenNum, RegNum, m_pInputRegFile->GetNumRegs() - 1);
                m_ErrorCount++;
                break;
            }
            
            if( bNormalGen )
            {
                if( InRegNum >= m_pInputRegFile->GetNumRegs() )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid input reg num: %d. Max allowed is %d.",
                           TokenNum, InRegNum, m_pInputRegFile->GetNumRegs() - 1);
                    m_ErrorCount++;
                    break;
                }

                bErrorInForLoop = FALSE;
                for( UINT i = 0; i < NumNormalGenOperations; i++ )
                {
                    if( pNormalGenOperations[i].DestReg == RegNum )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Duplicate declaration of input register %d as destination for normal generation.",
                               TokenNum, RegNum );
                        m_ErrorCount++;
                        bErrorInForLoop = TRUE;
                        break;                
                    }
                }
                if( bErrorInForLoop )
                    break;

                // Defer checking of initialization of inputs for normal gen until the entire declaration has been seen.
                // Also, defer setting of normal gen destination reg. to initialized, 
                // in order to disallow normal generation loops.
                pNormalGenOperations[NumNormalGenOperations].DestReg = RegNum;
                pNormalGenOperations[NumNormalGenOperations].SourceReg = InRegNum;
                pNormalGenOperations[NumNormalGenOperations].TokenNum = TokenNum; // used later for spew
                NumNormalGenOperations++;
            }
            else
            {
                if( ((Token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT) != D3DVSDT_FLOAT2 )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Tess datatype must be FLOAT2 for UV generation.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }

                if( InRegNum > 0 )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register number must not be specified (does not apply) for UV tesselation.",
                           TokenNum);
                    m_ErrorCount++;
                    break;                
                }

                for( UINT i = 0; i < 4; i++ )
                {
                    if( TRUE == m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register %d already declared.",
                                    TokenNum, RegNum);
                        m_ErrorCount++;
                        break;
                    }
                    m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized = TRUE;
                }
            }
            bAtLeastOneDataDefinition = TRUE;
            break;
        }
        case D3DVSD_TOKEN_CONSTMEM:
        {
            DWORD ConstCount = (Token & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT;
            DWORD MaxOffset = ((Token & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT) + ConstCount;
            DWORD NumConstRegs = m_pConstRegFile->GetNumRegs();
            DXGASSERT(NumConstRegs > 0);
            if( (bInStream || bInTessStream) && !bAtLeastOneDataDefinition )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream selector token must be followed by at least one stream data definition token.",
                            TokenNum);
                m_ErrorCount++;
            }
            if( 0 == NumConstRegs )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Write to const register %d is not valid.  There are no constant registers available.",
                            TokenNum,MaxOffset );
            }
            else if( MaxOffset > NumConstRegs )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Write to const register %d is out of range.  Max offset is %d.",
                            TokenNum,MaxOffset,m_pConstRegFile->GetNumRegs() - 1 );
                m_ErrorCount++;
            }
            pCurrToken += ConstCount*4;
            bInStream = bInTessStream = FALSE;
            break;
        }
        case D3DVSD_TOKEN_EXT:
            pCurrToken += ((Token & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT);
            if( (bInStream || bInTessStream) && !bAtLeastOneDataDefinition )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream selector token must be followed by at least one stream data definition token.",
                            TokenNum);
                m_ErrorCount++;
            }
            bInStream = bInTessStream = FALSE;
            break;
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Unrecognized stream declaration token.  Aborting shader decl. validation.",
                        TokenNum);
            m_ErrorCount++;
            goto Exit;
        }
        pCurrToken++;
    }

    // Make sure inputs to normal gen operations have been initialized
    {
        for( UINT i = 0; i < NumNormalGenOperations; i++ )
        {
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( FALSE == m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].SourceReg].m_bPreShaderInitialized )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token %d: Source input register %d for normal generation has not been declared.",
                           pNormalGenOperations[i].TokenNum, pNormalGenOperations[i].SourceReg);
                    m_ErrorCount++;
                    break;                
                }
            }
        }
    }

    // Set outputs of normal gen operations to initialized
    {
        for( UINT i = 0; i < NumNormalGenOperations; i++ )
        {
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( TRUE == m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].DestReg].m_bPreShaderInitialized )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input reg %d specified as destination for normal generation is already declared elsewhere.",
                                pNormalGenOperations[i].TokenNum, pNormalGenOperations[i].DestReg);
                    m_ErrorCount++;
                    break;
                }
                m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].DestReg].m_bPreShaderInitialized = TRUE;
            }
        }
    }

Exit:
    if( pVertexStreamDeclared )
        delete [] pVertexStreamDeclared;
    if( pNormalGenOperations )
        delete [] pNormalGenOperations;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ApplyPerInstructionRules
//
// Returns FALSE if shader validation must terminate.
// Returns TRUE if validation may proceed to next instruction.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::ApplyPerInstructionRules()
{
    if( !   Rule_InstructionRecognized()            ) return FALSE;   // Bail completely on unrecognized instr.
    if( !   Rule_InstructionSupportedByVersion()    ) goto EXIT;
    if( !   Rule_ValidParamCount()                  ) goto EXIT;
    if( !   Rule_ValidSrcParams()                   ) goto EXIT;
    if( !   Rule_SrcInitialized()                   ) goto EXIT; // needs to be before ValidDstParam()
    if( !   Rule_ValidAddressRegWrite()             ) goto EXIT;
    if( !   Rule_ValidDstParam()                    ) goto EXIT;
    if( !   Rule_ValidFRCInstruction()              ) goto EXIT;
    if( !   Rule_ValidRegisterPortUsage()           ) goto EXIT;
    if( !   Rule_ValidInstructionCount()            ) goto EXIT;
EXIT:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ApplyPostInstructionsRules
//-----------------------------------------------------------------------------
void CVShaderValidator::ApplyPostInstructionsRules()
{
    Rule_ValidInstructionCount(); // see if we went over the limits
    Rule_oPosWritten();
}

//-----------------------------------------------------------------------------
//
// Per Instruction Rules
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_InstructionRecognized
//
// ** Rule:
// Is the instruction opcode known? (regardless of shader version)
//
// ** When to call:  
// Per instruction.
//
// ** Returns:  
// FALSE when instruction not recognized.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_InstructionRecognized()
{
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_MAD:
    case D3DSIO_MUL:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_MIN:
    case D3DSIO_MAX:
    case D3DSIO_SLT:
    case D3DSIO_SGE:
    case D3DSIO_EXPP:
    case D3DSIO_LOGP:
    case D3DSIO_LIT:
    case D3DSIO_DST:
    case D3DSIO_M4x4:
    case D3DSIO_M4x3:
    case D3DSIO_M3x4:
    case D3DSIO_M3x3:
    case D3DSIO_M3x2:
    case D3DSIO_FRC:
    case D3DSIO_EXP:
    case D3DSIO_LOG:
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction recognized - ok.
    case D3DSIO_DPH:
    case D3DSIO_RCC:
        if(m_bXboxExtensions){
            return TRUE;
        }
        else {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Xbox specific instruction, but not an Xbox shader." );
            m_ErrorCount++;
            return TRUE;  // Keep going...
        }

    }

    // if we get here, the instruction is not recognized
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Unrecognized instruction. Aborting vertex shader validation." );
    m_ErrorCount++;
    return FALSE;  
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_InstructionSupportedByVersion
//
// ** Rule:
// Is the instruction supported by the current pixel shader version?
//
// ** When to call:  
// Per instruction.
//
// ** Returns:  
// FALSE when instruction not supported by version.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_InstructionSupportedByVersion()
{
  
    if( D3DVS_VERSION(1,0) <= m_Version ) // 1.0 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_MOV:
        case D3DSIO_ADD:
        case D3DSIO_MAD:
        case D3DSIO_MUL:
        case D3DSIO_RCP:
        case D3DSIO_RSQ:
        case D3DSIO_DP3:
        case D3DSIO_DP4:
        case D3DSIO_MIN:
        case D3DSIO_MAX:
        case D3DSIO_SLT:
        case D3DSIO_SGE:
        case D3DSIO_EXPP:
        case D3DSIO_LOGP:
        case D3DSIO_LIT:
        case D3DSIO_DST:
        case D3DSIO_M4x4:
        case D3DSIO_M4x3:
        case D3DSIO_M3x4:
        case D3DSIO_M3x3:
        case D3DSIO_M3x2:
        case D3DSIO_FRC:
        case D3DSIO_EXP:
        case D3DSIO_LOG:
            return TRUE; // instruction supported - ok.
        case D3DSIO_DPH:
        case D3DSIO_RCC:
            if(m_bXboxExtensions){
                return TRUE;
            }
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by non-Xbox vertex shader.");
            m_ErrorCount++;
            return FALSE;
        }
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction supported - ok.
    }

    // if we get here, the instruction is not supported.
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by version %d.%d vertex shader.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
    m_ErrorCount++;
    return FALSE;  // no more checks on this instruction
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidParamCount
//
// ** Rule:
// Is the parameter count correct for the instruction?
// The count includes dest + source parameters.
//
// DEF is a special case that is treated as having only 1 dest parameter,
// even though there are also 4 source parameters.  The 4 source params for DEF
// are immediate float values, so there is nothing to check, and no way of
// knowing whether or not those parameter tokens were actually present in the
// token list - all the validator can do is skip over 4 DWORDS (which it does).
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
//
// FALSE when the parameter count is incorrect.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidParamCount()
{
    BOOL bBadParamCount = FALSE;

    if ((m_pCurrInst->m_DstParamCount + m_pCurrInst->m_SrcParamCount) > SHADER_INSTRUCTION_MAX_PARAMS)  bBadParamCount = TRUE;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_EXP:
    case D3DSIO_EXPP:
    case D3DSIO_FRC:
    case D3DSIO_LOG:
    case D3DSIO_LOGP:
    case D3DSIO_LIT:
    case D3DSIO_MOV:
    case D3DSIO_RCC:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_ADD:
    case D3DSIO_DP3:
    case D3DSIO_DPH:
    case D3DSIO_DP4:
    case D3DSIO_DST:
    case D3DSIO_M3x2:
    case D3DSIO_M3x3:
    case D3DSIO_M3x4:
    case D3DSIO_M4x3:
    case D3DSIO_M4x4:
    case D3DSIO_MAX:
    case D3DSIO_MIN:
    case D3DSIO_MUL:
    case D3DSIO_SGE:
    case D3DSIO_SLT:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_MAD:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 3); break;
    }

    if (bBadParamCount)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid parameter count." );
        m_ErrorCount++;
        return FALSE;  // no more checks on this instruction
    }

    return TRUE;

}

static int EncodeRegNum(DWORD regType, DWORD regNum){
    int result = regNum;
    if(regType == D3DSPR_CONST)
    {
        // Map 0..191 to -96..95
        // Map 96.. to 0..95
        if(regNum <= 191){
            result -= 96;
        }
    }
    return result;
}

DWORD CVShaderValidator::GetMinRegNumber(DWORD type){
    // special case for constant registers, because in non-Xbox
    if(type == D3DSPR_CONST && ! m_bXboxExtensions){
        return 96;
    }
    return 0;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidSrcParams
//
// ** Rule:
// For each source parameter,
//     Source register type must be D3DSPR_TEMP/_INPUT/_CONST.
//     Register # must be within range for register type.
//     Modifier must be D3DSPSM_NONE or _NEG.
//     If version is < 1.1, addressmode must be absolute.
//     If the register type is not _CONST, addressmode must be absolute.
//     If relative addressing is used for constants, a0.x must be referenced.
//     Swizzle cannot be used for vector*matrix instructions.
//     
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
// 
// Errors in any of the source parameters causes m_bSrcParamError[i]
// to be TRUE, so later rules that only apply when a particular source
// parameter was valid know whether they need to execute or not.
// e.g. Rule_SrcInitialized.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidSrcParams()  // could break this down for more granularity
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        DXGASSERT(i < 3);
        BOOL bFoundSrcError = FALSE;
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT ValidRegNum = 0;
        char* SourceName[3] = {"first", "second", "third"};
        switch(pSrcParam->m_RegType)
        {
        case D3DSPR_TEMP:       ValidRegNum = m_pTempRegFile->GetNumRegs(); break;
        case D3DSPR_INPUT:      ValidRegNum = m_pInputRegFile->GetNumRegs(); break;
        case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for %s source param.", SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }

        if( (!bFoundSrcError) ){
            DWORD minRegNum = GetMinRegNumber(pSrcParam->m_RegType);
            if( pSrcParam->m_RegNum < minRegNum ){
                int regNum = EncodeRegNum(pSrcParam->m_RegType, pSrcParam->m_RegNum);
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num: %d for %s source param. Minimum allowed for this type is %d.",
                                    regNum, SourceName[i], EncodeRegNum(pSrcParam->m_RegType, minRegNum));
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
            else if (pSrcParam->m_RegNum >= ValidRegNum)
            {
                if(pSrcParam->m_RegNum == REGNUM_OUT_OF_RANGE) {
                    // out of range, but we don't know exactly what it was.
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num: for %s source param. Expected %d..%d.",
                                        SourceName[i], EncodeRegNum(pSrcParam->m_RegType, minRegNum),
                                        EncodeRegNum(pSrcParam->m_RegType, ValidRegNum - 1));
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                else {
                    int regNum = EncodeRegNum(pSrcParam->m_RegType, pSrcParam->m_RegNum);
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num: %d for %s source param. Max allowed for this type is %d.",
                                        regNum, SourceName[i], EncodeRegNum(pSrcParam->m_RegType, ValidRegNum - 1));
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
            }
        }

        switch( pSrcParam->m_SrcMod )
        {
        case D3DSPSM_NONE:
        case D3DSPSM_NEG:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for %s source param.",
                                SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }
    
        if( pSrcParam->m_AddressMode != D3DVS_ADDRMODE_ABSOLUTE 
            &&
            ( m_Version < D3DVS_VERSION(1,1) || pSrcParam->m_RegType != D3DSPR_CONST )
          )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Address mode must be absolute (%s source param).",
                                SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }
        
        if( (pSrcParam->m_AddressMode == D3DVS_ADDRMODE_RELATIVE) &&
            (D3DSPR_CONST == pSrcParam->m_RegType) )
        {
            if( pSrcParam->m_RelativeAddrComponent != D3DSP_WRITEMASK_0 )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Relative addressing of constant register must reference a0.x only.",
                                    SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }

        if( pSrcParam->m_SwizzleShift != D3DSP_NOSWIZZLE )
        {
            switch( m_pCurrInst->m_Type )
            {
            case D3DSIO_M3x2:
            case D3DSIO_M3x3:
            case D3DSIO_M3x4:
            case D3DSIO_M4x3:
            case D3DSIO_M4x4:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot swizzle on vector*matrix instructions.",
                                    SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;        
                break;
            }
        }

        if( bFoundSrcError )
        {
            m_bSrcParamError[i] = TRUE; // needed in Rule_SrcInitialized
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_SrcInitialized
//
// ** Rule:
// for each source parameter,
//     The register type must be _TEMP, _INPUT or _CONST.
//     Certain components of the register need to have been initialized, depending
//     on what the instruction is and also taking into account the source swizzle.
//     For reads of the _CONST register file, do no validation.
//
// ** When to call:  
// Per instruction. This rule must be called before Rule_ValidDstParam().
//
// ** Returns:
// Always TRUE.
//
// NOTE: This rule also updates the access history to indicate reads of the
// affected components of each source register.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_SrcInitialized()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam[0]);

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        CRegisterFile* pRegFile = NULL;
        char* RegChar = NULL;
        UINT NumConsecutiveRegistersUsed = 1; // more than one for matrix mul macros.
        CAccessHistoryNode* pWriterInCurrCycle[4] = {0, 0, 0, 0};

        if( m_bSrcParamError[i] ) continue;

        switch( pSrcParam->m_RegType )
        {
            case D3DSPR_TEMP:       
                pRegFile = m_pTempRegFile; 
                RegChar = "r";
                break;
            case D3DSPR_INPUT:       
                pRegFile = m_pInputRegFile; 
                RegChar = "v";
                break;
            case D3DSPR_CONST:
                // if this is an address register read, check that the address register is initialized
                if(pSrcParam->m_AddressMode == D3DVS_ADDRMODE_RELATIVE) {
                    CAccessHistoryNode* pPreviousWriter = m_pAddrRegFile->m_pAccessHistory[0][0].m_pMostRecentWriter;

                    // If co-issue, find the real previous writer.
                    while( pPreviousWriter
                           && pPreviousWriter->m_pInst->m_CycleNum == m_pCurrInst->m_CycleNum )
                    {
                        pPreviousWriter = pPreviousWriter->m_pPreviousWriter;
                    }
                    if(NULL == pPreviousWriter){
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized A0.x");
                        m_ErrorCount++;
                    }
                }
                continue; // no validation for const register reads (no need to update access history either).
                // but we still need to check the other arguments.
        }
        if( !pRegFile ) continue;

        switch( m_pCurrInst->m_Type )
        {
            case D3DSIO_M3x2:
                if( 1 == i )        NumConsecutiveRegistersUsed = 2;
                break;
            case D3DSIO_M3x3:
                if( 1 == i )        NumConsecutiveRegistersUsed = 3;
                break;
            case D3DSIO_M3x4:
                if( 1 == i )        NumConsecutiveRegistersUsed = 4;
                break;
            case D3DSIO_M4x3:
                if( 1 == i )        NumConsecutiveRegistersUsed = 3;
                break;
            case D3DSIO_M4x4:
                if( 1 == i )        NumConsecutiveRegistersUsed = 4;
                break;
            case D3DSIO_NOP:
            default:
                break;
        }

        // check for read of uninitialized components
        for( UINT j = 0; j < NumConsecutiveRegistersUsed; j++ ) // will loop for macro matrix instructions
        {
            DWORD  UninitializedComponentsMask = 0;
            UINT   NumUninitializedComponents = 0;

            for( UINT k = 0; k < 4; k++ )
            {
                if( pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[k] )
                {

                    CAccessHistoryNode* pPreviousWriter = pRegFile->m_pAccessHistory[k][RegNum].m_pMostRecentWriter;

                    // If co-issue, find the real previous writer.
                    while( pPreviousWriter
                           && pPreviousWriter->m_pInst->m_CycleNum == m_pCurrInst->m_CycleNum )
                    {
                        pWriterInCurrCycle[k] = pPreviousWriter; // log read just before this write for co-issue
                        pPreviousWriter = pPreviousWriter->m_pPreviousWriter;
                    }

                    if( NULL == pPreviousWriter &&
                        !pRegFile->m_pAccessHistory[k][RegNum + j].m_bPreShaderInitialized )
                    {
                        NumUninitializedComponents++;
                        UninitializedComponentsMask |= COMPONENT_MASKS[k];
                    }
                }
            }

            if( NumUninitializedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s",
                    NumUninitializedComponents > 1 ? "s" : "",
                    RegChar, RegNum + j, MakeAffectedComponentsText(UninitializedComponentsMask,FALSE,TRUE));
                m_ErrorCount++;
            }

            // Update register file to indicate READ.
            // Multiple reads of the same register component by the current instruction
            // will only be logged as one read in the access history.

            {
                for( UINT k = 0; k < 4; k++ )
                {
                    #define PREV_READER(_CHAN,_REG) \
                            ((NULL == pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader) ? NULL :\
                            pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader->m_pInst)
                    if (!pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[k])
                        continue;

                    if( NULL != pWriterInCurrCycle[k] )
                    {
                        if( !pWriterInCurrCycle[k]->m_pPreviousReader ||
                            pWriterInCurrCycle[k]->m_pPreviousReader->m_pInst != m_pCurrInst )
                        {
                            if( !pRegFile->m_pAccessHistory[k][RegNum].InsertReadBeforeWrite(
                                                    pWriterInCurrCycle[k], m_pCurrInst ) )
                            {
                                Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                                m_ErrorCount++;
                            }
                        }
                    }
                    else if( PREV_READER(k,RegNum) != m_pCurrInst )
                    {
                        if( !pRegFile->m_pAccessHistory[k][RegNum].NewAccess(m_pCurrInst,FALSE) )
                        {
                            Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                            m_ErrorCount++;
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}
//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidAddressRegWrite
//
// ** Rule:
// Address register may only be written by MOV, and only for version >= 1.1.
// Register format must be a0.x
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidAddressRegWrite() 
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam[0]);

    if( pDstParam->m_bParamUsed )
    {
        if( D3DSPR_ADDR == pDstParam->m_RegType )
        {
            if( m_Version < D3DVS_VERSION(1,1) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Address register not available for vertex shader version %d.%d.  Version 1.1 required.",
                            D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version) );
                m_ErrorCount++;
            }
            if( D3DSIO_MOV == m_pCurrInst->m_Type )
            {
                if( 0 != pDstParam->m_RegNum ||
                    D3DSP_WRITEMASK_0 != pDstParam->m_WriteMask ||
                    D3DSPDM_NONE != pDstParam->m_DstMod ||
                    DSTSHIFT_NONE != pDstParam->m_DstShift )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Format for address register must be a0.x." );
                    m_ErrorCount++;
                }
            }
            else
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Only the mov instruction is allowed to write to the address register." );
                m_ErrorCount++;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidDstParam
//
// ** Rule:
// Dst register type must be temp/addr/rastout/attrout/texcrdout,
// and reg num must be within range for register type.
//
// There can be no dst modifiers or shifts with vertex shaders.
//
// The writemask cannot be 'none'.
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// NOTE: After checking the dst parameter, if no error was found,
// the write to the appropriate component(s) of the destination register
// is recorded by this function, so subsequent rules may check for previous
// write to registers.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidDstParam() // could break this down for more granularity
{
    BOOL   bFoundDstError = FALSE;
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam[0]);
    UINT RegNum = pDstParam->m_RegNum;

    if( pDstParam->m_bParamUsed )
    {
        UINT ValidRegNum = 0;

        BOOL bWritable = FALSE;
        switch( pDstParam->m_RegType )
        {
        case D3DSPR_TEMP:       
            bWritable = m_pTempRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        case D3DSPR_ADDR:       
            bWritable = m_pAddrRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pAddrRegFile->GetNumRegs();                                
            break;
        case D3DSPR_RASTOUT:    
            bWritable = m_pRastOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pRastOutputRegFile->GetNumRegs();            
            break;
        case D3DSPR_CONST:    
            bWritable = m_pConstRegFile->IsWritable();
            ValidRegNum = m_pConstRegFile->GetNumRegs();                        
            break;
        case D3DSPR_ATTROUT:    
            bWritable = m_pAttrOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pAttrOutputRegFile->GetNumRegs();                        
            break;
        case D3DSPR_TEXCRDOUT:  
            bWritable = m_pTexCrdOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pTexCrdOutputRegFile->GetNumRegs();                                    
            break;
        }

        if( !bWritable || !ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for dest param." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        } 
        else if( RegNum >= ValidRegNum )
        {
            int minRegNum = EncodeRegNum(pDstParam->m_RegType, GetMinRegNumber(pDstParam->m_RegType));
            int maxRegNum = EncodeRegNum(pDstParam->m_RegType, ValidRegNum - 1);
            if( RegNum == REGNUM_OUT_OF_RANGE ) {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dest reg num. Allowed range for this reg type is %d..%d.",
                    minRegNum, maxRegNum);
            }
            else {
                int encRegNum = EncodeRegNum(pDstParam->m_RegType, RegNum);
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Invalid dest reg num: %d. Max allowed for this reg type is %d.", encRegNum, minRegNum, maxRegNum);
            }
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        switch( pDstParam->m_DstMod )
        {
        case D3DSPDM_NONE:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dst modifiers not allowed for vertex shaders." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        switch( pDstParam->m_DstShift )
        {
        case DSTSHIFT_NONE:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest shifts not allowed for vertex shaders." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        if( 0 == pDstParam->m_WriteMask )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask cannot be empty." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        // Update register file to indicate write.
        if( !bFoundDstError )
        {
            CRegisterFile* pRegFile = NULL;
            switch( pDstParam->m_RegType )
            {
            case D3DSPR_TEMP:       
                pRegFile = m_pTempRegFile; 
                break;
            case D3DSPR_ADDR:       
                pRegFile = m_pAddrRegFile; 
                break;
            case D3DSPR_CONST:       
                pRegFile = m_pConstRegFile; 
                break;
            case D3DSPR_RASTOUT:    
                pRegFile = m_pRastOutputRegFile; 
                break;
            case D3DSPR_ATTROUT:    
                pRegFile = m_pAttrOutputRegFile; 
                break;
            case D3DSPR_TEXCRDOUT:  
                pRegFile = m_pTexCrdOutputRegFile; 
                break;
            }

            if( pRegFile )
            {
                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_0 ) 
                    pRegFile->m_pAccessHistory[0][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_1 ) 
                    pRegFile->m_pAccessHistory[1][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_2 ) 
                    pRegFile->m_pAccessHistory[2][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_3 ) 
                    pRegFile->m_pAccessHistory[3][RegNum].NewAccess(m_pCurrInst,TRUE);
                if(m_bXboxExtensions && pDstParam->m_RegType == D3DSPR_RASTOUT && RegNum == 0){
                    DXGASSERT(m_pTempRegFile->GetNumRegs() >= 13);
                    if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_0 ) 
                        m_pTempRegFile->m_pAccessHistory[0][12].NewAccess(m_pCurrInst,TRUE);

                    if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_1 ) 
                        m_pTempRegFile->m_pAccessHistory[1][12].NewAccess(m_pCurrInst,TRUE);

                    if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_2 ) 
                        m_pTempRegFile->m_pAccessHistory[2][12].NewAccess(m_pCurrInst,TRUE);

                    if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_3 ) 
                        m_pTempRegFile->m_pAccessHistory[3][12].NewAccess(m_pCurrInst,TRUE);
                    }
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidFRCInstruction
//
// ** Rule:
// The only valid write masks for the FRC instruction are .y and .xy
// 
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidFRCInstruction()
{
    if( NULL == m_pCurrInst )
        return TRUE;

    if( D3DSIO_FRC == m_pCurrInst->m_Type )
    {
        if( ( (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1) != m_pCurrInst->m_DstParam[0].m_WriteMask ) &&
            (                      D3DSP_WRITEMASK_1  != m_pCurrInst->m_DstParam[0].m_WriteMask ) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                "The only valid write masks for the FRC instruction are .xy and .y." );
            m_ErrorCount++;                            
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidRegisterPortUsage
//
// ** Rule:
// Each register class (TEMP,TEXTURE,INPUT,CONST) may only appear as parameters
// in an individual instruction up to a maximum number of times.
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidRegisterPortUsage()
{
    UINT TempRegAccessCount = 0;
    UINT TempRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT InputRegAccessCount = 0;
    UINT InputRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT ConstRegAccessCount = 0;
    UINT ConstRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];

    for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
    {
        D3DSHADER_PARAM_REGISTER_TYPE   RegType;
        UINT                            RegNum;

        if( !m_pCurrInst->m_SrcParam[i].m_bParamUsed ) continue;
        RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
        RegNum  = m_pCurrInst->m_SrcParam[i].m_RegNum;

        UINT* pCount = NULL;
        UINT* pAccess = NULL;
        switch( RegType )
        {
        case D3DSPR_TEMP:
            pCount = &TempRegAccessCount;
            pAccess = TempRegAccess;
            break;
        case D3DSPR_INPUT:
            pCount = &InputRegAccessCount;
            pAccess = InputRegAccess;
            break;
        case D3DSPR_CONST:
            pCount = &ConstRegAccessCount;
            pAccess = ConstRegAccess;
            break;
        }

        if( pCount && pAccess )
        {
            BOOL bNewRegNumberAccessed = TRUE;
            for( UINT j = 0; j < *pCount; j++ )
            {
                if( RegNum == pAccess[j] )
                {
                    bNewRegNumberAccessed = FALSE;
                    break;
                }
            }
            if( bNewRegNumberAccessed )
            {
                pAccess[*pCount] = RegNum;
                (*pCount)++;
            }
        }
    }

    if( TempRegAccessCount > m_pTempRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Temp registers (r#) read %d times in one instruction.  Max #reads/instruction is %d.",
                        TempRegAccessCount,  m_pTempRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    if( InputRegAccessCount > m_pInputRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Input registers (v#) read %d times by instruction.  Max #reads/instruction is %d.",
                        InputRegAccessCount,  m_pInputRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    if( ConstRegAccessCount > m_pConstRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Constant registers (c#) read %d times by instruction.  Max #reads/instruction is %d.",
                        ConstRegAccessCount, m_pConstRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidInstructionCount
//
// ** Rule:
// Make sure instruction count for vertex shader version has not been exceeded.
//
// Nop, and comments (already stripped) do not count towards the limit.
//
// ** When to call:  
// Per instruction AND after all instructions seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidInstructionCount()
{
    static UINT s_OpCount;
    static UINT s_MaxTotalOpCount;

    if(!m_pCurrInst){
        // No instructions
        Spew( SPEW_GLOBAL_ERROR, NULL, "Vertex shader must contain at least one instruction.");
        m_ErrorCount++;
        return TRUE; 
    }

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_OpCount = 0;

        switch(m_Version)
        {
        case D3DVS_VERSION(1,0):
        case D3DVS_VERSION(1,1):
        default:
            // Xbox can have a total of 136 instructions, plus instruction pairing can double that.
            // But we don't know at this point in the code how many instructions will be paired.
            s_MaxTotalOpCount   = m_bXboxExtensions ? (136 * 2) : 128;
            break;
        }
    }

    if( m_bSeenAllInstructions )
    {
        if( s_OpCount > s_MaxTotalOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Number of instruction slots used too high: %d. Max. allowed is %d.",
                  s_OpCount, s_MaxTotalOpCount);
            m_ErrorCount++;
        }
        return TRUE;
    }

    switch( m_pCurrInst->m_Type )
    {
    case D3DSIO_NOP:
        s_OpCount += 0; break;
    case D3DSIO_ADD:
    case D3DSIO_DP3:
    case D3DSIO_DPH:
    case D3DSIO_DP4:
    case D3DSIO_DST:
    case D3DSIO_EXPP:
    case D3DSIO_LIT:
    case D3DSIO_LOGP:
    case D3DSIO_MAD:
    case D3DSIO_MAX:
    case D3DSIO_MIN:
    case D3DSIO_MOV:
    case D3DSIO_MUL:
    case D3DSIO_RCC:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
    case D3DSIO_SGE:
    case D3DSIO_SLT:
        s_OpCount += 1; break;
    case D3DSIO_M3x2:
        s_OpCount += 2; break;
    case D3DSIO_FRC: //todo: if output is only .y, frc expands to only 1 instruction, not 3
    case D3DSIO_M3x3:
    case D3DSIO_M4x3:
        s_OpCount += 3; break;
    case D3DSIO_M3x4:
    case D3DSIO_M4x4:
        s_OpCount += 4; break;
    case D3DSIO_EXP:
    case D3DSIO_LOG:
        s_OpCount += 2; break;
    }
    
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_oPosWritten
//
// ** Rule:
// First two channels (x,y) of oPos output register must be written.
//
// ** When to call:  
// After all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_oPosWritten()
{
    if ( m_bStateShader) {
        // Must write to at least one c register
        bool foundWrite = false;
        UINT numRegs = m_pConstRegFile->GetNumRegs();
        for(UINT j = 0; j < 4; j++){ // For each component
            for(UINT i = 0; i < numRegs; i++){ // for each constant register
                if(m_pConstRegFile->m_pAccessHistory[j][i].m_pMostRecentWriter){
                    foundWrite = true;
                    break; // Found at least one component that was written to.
                }
            }
        }
        if(!foundWrite){
            Spew( SPEW_GLOBAL_ERROR, NULL, "A valid vertex state shader must write to at least one constant register.");
            m_ErrorCount++;
        }
    }
    else {
        UINT  NumUninitializedComponents    = 0;
        DWORD UninitializedComponentsMask   = 0;

        for( UINT i = 0; i < 2; i++ ) // looking at component 0 (X) and component 1 (Y)
        {
            if( NULL == m_pRastOutputRegFile->m_pAccessHistory[i][0].m_pMostRecentWriter )
            {
                NumUninitializedComponents++;
                UninitializedComponentsMask |= COMPONENT_MASKS[i];
            }
        }
        if( 1 == NumUninitializedComponents )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Vertex shader must minimally write first two (x,y) components of oPos output register.  Affected component%s(*): %s",
                NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,FALSE,TRUE));
            m_ErrorCount++;
        } 
        else if( 2 == NumUninitializedComponents )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Vertex shader must minimally write first two (x,y) components of oPos output register.");
            m_ErrorCount++;
        }
    }
    return TRUE;
}

// 0..1 -> 0..1
// 0x100..0x101 -> 2..3
// anything else -> REGNUM_OUT_OF_RANGE (an error)

static DWORD DecodeXboxAttrRegNum(DWORD regNum){
    if(regNum < 2){
        return regNum;
    }
    else if (regNum >= 0x100 && regNum <= 0x101){
        return regNum - 0x100;
    }
    else {
        return REGNUM_OUT_OF_RANGE;
    }
}

// 0..95 -> 96..192
// 0xfa0..0xfff -> 0..95
// anything else -> REGNUM_OUT_OF_RANGE (an error)

static DWORD DecodeXboxConstantRegNum(DWORD regNum){
    if(regNum < 96){
        return regNum + 96;
    }
    else if (regNum >= 0xfa0 && regNum <= 0xfff){
        return regNum - 0xfa0;
    }
    else {
        return REGNUM_OUT_OF_RANGE;
    }
}

//-----------------------------------------------------------------------------
// CVShaderValidator::DecodeDstParam
//-----------------------------------------------------------------------------
void CVShaderValidator::DecodeDstParam( D3DSHADER_INSTRUCTION_OPCODE_TYPE inst, DSTPARAM* pDstParam, DWORD Token )
{
    DXGASSERT(pDstParam);
    pDstParam->m_bParamUsed = TRUE;
    pDstParam->m_RegNum = Token & D3DSP_REGNUM_MASK;
    pDstParam->m_WriteMask = Token & D3DSP_WRITEMASK_ALL;
    pDstParam->m_DstMod = (D3DSHADER_PARAM_DSTMOD_TYPE)(Token & D3DSP_DSTMOD_MASK);
    pDstParam->m_DstShift = (DSTSHIFT)((Token & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT );
    pDstParam->m_RegType = (D3DSHADER_PARAM_REGISTER_TYPE)(Token & D3DSP_REGTYPE_MASK);

    // Decode funky Xbox extended constant registers
    switch(pDstParam->m_RegType){
    case D3DSPR_CONST:
        pDstParam->m_RegNum = DecodeXboxConstantRegNum(pDstParam->m_RegNum);
        break;
    case D3DSPR_ATTROUT:
        pDstParam->m_RegNum = DecodeXboxAttrRegNum(pDstParam->m_RegNum);
        break;
    default:
        break;
    }

	switch (inst) {
	case D3DSIO_M4x3:
	case D3DSIO_M3x3:
		pDstParam->m_WriteMask &= D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
		break;
	case D3DSIO_M3x2:
		pDstParam->m_WriteMask &= D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1;
		break;
	}

}

//-----------------------------------------------------------------------------
// CVShaderValidator::DecodeSrcParam
//-----------------------------------------------------------------------------
void CVShaderValidator::DecodeSrcParam( SRCPARAM* pSrcParam, DWORD Token )
{
    DXGASSERT(pSrcParam);
    pSrcParam->m_bParamUsed = TRUE;
    pSrcParam->m_RegNum = Token & D3DSP_REGNUM_MASK;
    pSrcParam->m_SwizzleShift = Token & D3DSP_SWIZZLE_MASK;
    pSrcParam->m_AddressMode = (D3DVS_ADDRESSMODE_TYPE)(Token & D3DVS_ADDRESSMODE_MASK);
    pSrcParam->m_RelativeAddrComponent = COMPONENT_MASKS[(Token >> 14) & 0x3];
    pSrcParam->m_SrcMod = (D3DSHADER_PARAM_SRCMOD_TYPE)(Token & D3DSP_SRCMOD_MASK);
    pSrcParam->m_RegType = (D3DSHADER_PARAM_REGISTER_TYPE)(Token & D3DSP_REGTYPE_MASK);

    // Decode funky Xbox extended constant registers
    if(pSrcParam->m_RegType == D3DSPR_CONST){
        pSrcParam->m_RegNum = DecodeXboxConstantRegNum(pSrcParam->m_RegNum);
    }
}

//-----------------------------------------------------------------------------
//
// CVShaderValidator Wrapper Functions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// ValidateVertexShaderInternal
//-----------------------------------------------------------------------------
BOOL ValidateVertexShaderInternal(   const DWORD* pCode, 
                                     const DWORD* pDecl, 
                                     const D3DCAPS8* pCaps,
                                     XD3DXErrorLog* pLog)
{
    CVShaderValidator Validator(pCode,pDecl,pCaps,0, pLog);
    return SUCCEEDED(Validator.GetStatus()) ? TRUE : FALSE;
}

//-----------------------------------------------------------------------------
// ValidateVertexShader
//
//-----------------------------------------------------------------------------
HRESULT WINAPI ValidateVertexShader(    const DWORD* pCode, 
                                        const DWORD* pDecl,
                                        const D3DCAPS8* pCaps, 
                                        const DWORD Flags, 
                                        XD3DXErrorLog* pLog)
{
    CVShaderValidator Validator(pCode,pDecl,pCaps,Flags, pLog);
#if 0
    if( ppBuf )
    {
        *ppBuf = (char*)HeapAlloc(GetProcessHeap(), 0, Validator.GetRequiredLogBufferSize());
        if( NULL == *ppBuf )
            OutputDebugString("Out of memory.\n");
        else
            Validator.WriteLogToBuffer(*ppBuf);
    }
#endif
    return Validator.GetStatus();
}

} // namespace XGRAPHICS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\swizzler\sources.inc ===
MAJORCOMP=directx
MINORCOMP=d3d

TARGETNAME=swizzler$(D)

TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES);..\..\inc

SOURCES = \
     swizzler.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\shadeasm\vshdrval.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// vshdrval.hpp
//
// Direct3D Reference Device - VertexShader validation
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __VSHDRVAL_HPP__
#define __VSHDRVAL_HPP__

namespace XGRAPHICS {

//-----------------------------------------------------------------------------
// CVSInstruction
//-----------------------------------------------------------------------------
class CVSInstruction : public CBaseInstruction
{
public:
    CVSInstruction(CVSInstruction* pPrevInst) : CBaseInstruction(pPrevInst) {};

    void CalculateComponentReadMasks();
};

// Flags for validator

#define VSF_XBOXEXTENSIONS      (1 << 0)
#define VSF_READWRITESHADER     (1 << 1)
#define VSF_STATESHADER         (1 << 2)

//-----------------------------------------------------------------------------
// CVShaderValidator
//-----------------------------------------------------------------------------
class CVShaderValidator : public CBaseShaderValidator
{
private:
    void ValidateDeclaration();
    const DWORD*    m_pDecl;
    BOOL            m_bFixedFunction;
    BOOL            m_bXboxExtensions;
    BOOL            m_bReadWriteShader;
    BOOL            m_bStateShader;

    CRegisterFile*  m_pTempRegFile;    
    CRegisterFile*  m_pInputRegFile;
    CRegisterFile*  m_pConstRegFile;
    CRegisterFile*  m_pAddrRegFile;
    CRegisterFile*  m_pTexCrdOutputRegFile;
    CRegisterFile*  m_pAttrOutputRegFile;
    CRegisterFile*  m_pRastOutputRegFile;

    CBaseInstruction* AllocateNewInstruction(CBaseInstruction*pPrevInst);
    BOOL DecodeNextInstruction();
    BOOL InitValidation();
    BOOL ApplyPerInstructionRules();
    void ApplyPostInstructionsRules();

    BOOL Rule_InstructionRecognized();
    BOOL Rule_InstructionSupportedByVersion();
    BOOL Rule_ValidParamCount();
    BOOL Rule_ValidSrcParams(); 
    BOOL Rule_SrcInitialized();
    BOOL Rule_ValidAddressRegWrite();
    BOOL Rule_ValidDstParam();
    BOOL Rule_ValidFRCInstruction();
    BOOL Rule_ValidRegisterPortUsage();
    BOOL Rule_ValidInstructionCount();             // Call per instruction AND after all instructions seen
    BOOL Rule_oPosWritten();                       // Call after all instructions seen

    DWORD GetMinRegNumber(DWORD type);
    
    void  DecodeDstParam(D3DSHADER_INSTRUCTION_OPCODE_TYPE inst, DSTPARAM* pDstParam, DWORD Token ); // replace method on base class
    void  DecodeSrcParam( SRCPARAM* pSrcParam, DWORD Token ); // replace method on base class

public:
    CVShaderValidator(  const DWORD* pCode, 
                        const DWORD* pDecl, 
                        const D3DCAPS8* pCaps, 
                        DWORD Flags,
                        XD3DXErrorLog* pLog );
    ~CVShaderValidator();
};

HRESULT WINAPI ValidateVertexShader(    const DWORD* pCode, 
                                        const DWORD* pDecl,
                                        const D3DCAPS8* pCaps, 
                                        const DWORD Flags, 
                                        XD3DXErrorLog* pLog);

} // namespace XGRAPHICS

#endif __VSHDRVAL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\inc\d3d8sddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       D3D8sddi.h
 *  Content:    Defines the interface between the ddi thunk layer
 *              and the refrast/RGB HEL layer..
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   04-nov-99  smac    initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __D3D8SW_INCLUDED__
#define __D3D8SW_INCLUDED__

typedef struct _D3D8_SWCAPS
{
    D3DHAL_D3DEXTENDEDCAPS      D3DExtendedCaps;        // Extended D3D caps
    D3DHAL_GLOBALDRIVERDATA     D3DGlobalDriverData;    // D3D global driver data
    DWORD                       Caps;                   // Subset of DDraw Caps
    DWORD                       Caps2;                  // Subset of DDraw Caps2
    D3DCAPS8                    D3DCaps8;               // DX8 DDI caps
    DWORD                       dwFlags;
} D3D8_SWCAPS, * PD3D8_SWCAPS;

// Surface types
#define SWSURF_SURFACE                     0x00000001
#define SWSURF_VOLUME                      0x00000002
#define SWSURF_MIPMAP                      0x00000004
#define SWSURF_MIPVOLUME                   0x00000008
#define SWSURF_CUBEMAP                     0x00000010
#define SWSURF_VERTEXBUFFER                0x00000020
#define SWSURF_OPTIMIZERVERTEXBUFFER       0x00000040
#define SWSURF_INDEXBUFFER                 0x00000080
#define SWSURF_COMMANDBUFFER               0x00000100

// Flags
#define SWFLAG_D3DEXENDEDCAPS              0x00000001
#define SWFLAG_D3DGLOBALDRIVERDATA         0x00000002
#define SWFLAG_D3DCAPS8                    0x00000004



typedef struct _D3D8_SWCALLBACKS
{
    // From Callbacks
    LPD3DHAL_CONTEXTCREATECB                CreateContext;
    LPD3DHAL_CONTEXTDESTROYCB               ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB            ContextDestroyAll;
    LPD3DHAL_SCENECAPTURECB                 SceneCapture;
    LPD3DHAL_RENDERSTATECB                  RenderState;
    LPD3DHAL_RENDERPRIMITIVECB              RenderPrimitive;
    LPD3DHAL_TEXTURECREATECB                TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB               TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB                  TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB               TextureGetSurf;
    LPD3DHAL_GETSTATECB                     GetState;

    // From Callbacks2
    LPD3DHAL_SETRENDERTARGETCB              SetRenderTarget;
    LPD3DHAL_CLEARCB                        Clear;
    LPD3DHAL_DRAWONEPRIMITIVECB             DrawOnePrimitive;
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB      DrawOneIndexedPrimitive;
    LPD3DHAL_DRAWPRIMITIVESCB               DrawPrimitives;

    // From Callbacks3
    LPD3DHAL_CLEAR2CB                       Clear2;
    LPD3DHAL_VALIDATETEXTURESTAGESTATECB    ValidateTextureStageState;
    LPD3DHAL_DRAWPRIMITIVES2CB              DrawPrimitives2;

    // From MiscCallbacks in DDraw
    LPDDHAL_GETDRIVERSTATE                  GetDriverState;
    LPDDHAL_CREATESURFACEEX                 CreateSurfaceEx;

    // DDraw Callbacks
    LPDDHAL_CREATESURFACE                   CreateSurface;
    LPDDHALSURFCB_DESTROYSURFACE            DestroySurface;
    LPDDHALSURFCB_LOCK                      Lock;
    LPDDHALSURFCB_UNLOCK                    Unlock;

} D3D8_SWCALLBACKS, * PD3D8_SWCALLBACKS;


#ifdef __cplusplus
extern "C" {
#endif

HRESULT APIENTRY D3D8GetSWInfo(
    PD3D8_SWCAPS        pCaps,
    PD3D8_SWCALLBACKS   pCallbacks
    );

#ifdef __cplusplus
}
#endif


// Prototypes required to hook the DDI layer (used by RefRast and the HEL

#define D3D8_REFRASTNAME            "D3DREF8.DLL"

#define D3D8HOOK_GETSWINFOPROCNAME  "D3D8GetSWInfo"

typedef HRESULT (WINAPI * PD3D8GetSWInfo)(PD3D8_SWCAPS       pCaps,
                                         PD3D8_SWCALLBACKS  pCallbacks);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:    debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-jan-95  craige  initial implementation
 *   03-mar-95  craige  added dprintf2
 *   31-mar-95  craige  add DPFInit to read WIN.INI for [DirectDraw] section;
 *                      added dprintf3
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   18-jun-95  craige  use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed DXdprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR       "DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT       "DirectDraw"
    #endif

    #define END_STR             "\r\n"

    HWND                hWndListBox;
    LONG                lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
            if( hWndListBox != NULL )
            {
                if( !IsWindow( hWndListBox ) )
                {
                    hWndListBox = NULL;
                }
            }
            if( hWndListBox != NULL )
            {
                UINT    sel;
                int     len;
                len = strlen( str );
                if( len > 0 )
                {
                    if( str[len-1] == '\r' || str[len-1] == '\n' )
                    {
                        str[len-1] = 0;
                    }
                    if( len > 1 )
                    {
                        if( str[len-2] == '\r' || str[len-2] == '\n' )
                        {
                            str[len-2] = 0;
                        }
                    }
                }
                SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
                sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
                if( sel != LB_ERR )
                {
                    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
                }
            }
        #endif

    } /* dumpStr */

    /*
     * DXdprintf
     */
    void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

        va_end(ap);
    } /* DXdprintf */


    static void cdecl D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;

        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            wsprintf( (LPSTR) str+lstrlen( str ), msgType );
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

    } /* D3Dprintf */

    void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap, szFormat);

        D3Dprintf(lvl, "(INFO) :", szFormat, ap);

        va_end(ap);
    }

    void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(lvl, "(WARN) :", szFormat, ap);
        va_end(ap);
    }

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        DXdprintf( ASSERT_MESSAGE_LEVEL, buffer );
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
            /*
             * Into the debugger we go...
             */
            DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xgraphics\swizzler\swizzler.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       swizzler.cpp
 *  Content:    Xbox swizzle helper utilities
 *
 ****************************************************************************/

#if XBOX
    #include <xgrphseg.h>
    #include "xtl.h"
#else
    #include "windows.h"
    #include "d3d8-xbox.h"
#endif

#include "xgraphics.h"
#include "debug.h"

namespace XGRAPHICS
{

//returns 1 if sse instructions are supported
extern "C" 
BOOL SupportsSSE () {
	__try { __asm {
			cpuid
	} }
	__except(EXCEPTION_EXECUTE_HANDLER) {
		return FALSE;
	}

	BOOL b;

	_asm {
        mov  eax,1           // Get feature flag in edx
        cpuid
		mov eax, edx
		and eax, 02000000h
		shr eax, 25
		mov [b], eax
	}
	return b;
}

typedef __int64 QWORD;

struct XGINTERNALSWIZZLE {
    LPCVOID pSource;
    DWORD   Pitch, SLeft, STop, RWidth, RHeight;
    LPVOID  pDest;
	DWORD Width, Height, DTop, DLeft;
	int xOff, yOff, uWidth, uHeight;
	int bpp;
	Swizzler swiz;
	DWORD mask[2];
};

/*
Log2 
 
  Purpose: to calculate the log(base 2) of a number that is a power of 2

  Parameters:
    IN Value: the number to take the Log of. 

  Returns: 
    (1 << returnvalue) == Value

  Note: Value must be a power of 2, otherwise strange results will occur.
*/
#pragma warning (disable: 4035)
inline DWORD __fastcall Log2 (DWORD Value)
{ 
	__asm { bsf eax, [Value] }; 
}
#pragma warning (default: 4035)

/*
GetMasks2

  Purpose: produces the coordinate masks for manuvering through swizzled textures

  Parameters:
	IN Width: the width of the texture to be swizzled
	IN Height: the height of the texture to be swizzled
	OUT pMaskU: the mask for the u-coodinate
	OUT pMaskV: the mask for the v-coordinate

  Notes: This is a much faster algorithm for getting the masks than the 
    more generic algorithm used in the Swizzler class defined in xgraphics.h.
	This algorithm works only for 2d textures. Swizzler's works for 2d and 3d.

*/
inline VOID GetMasks2(int Width, int Height, DWORD* pMaskU, DWORD* pMaskV) 
{
	DWORD LogWidth, LogHeight, Log;

	LogWidth = Log2(Width); 
	LogHeight = Log2(Height);

	Log = min(LogWidth, LogHeight);

    DWORD LowerMask = (1 << (Log << 1)) - 1;
    DWORD UpperMask = ~LowerMask;

    DWORD MaskU = (LogWidth > LogHeight) ? (0x55555555 | UpperMask)
                                        : (0x55555555 & LowerMask);

    DWORD MaskV = (LogWidth < LogHeight) ? (0xaaaaaaaa | UpperMask)
                                        : (0xaaaaaaaa & LowerMask);

	MaskU &= ((1 << (LogWidth + LogHeight)) - 1); //we're letting u & v just loop, so
	MaskV &= ((1 << (LogWidth + LogHeight)) - 1); //we need to limit the bits to the ones we need.

	*pMaskU = MaskU;
	*pMaskV = MaskV;
}


/*
Quick-Swizzling algorithm:

  The 2d swizzling/unswizzling code grabs a rectangular block of optimized size from the texture, 
  rearranges that, moves it to the destination, then repeats with the next block.

  swizzling,                  8-bit or 16-bit
  linear:                     swizzled:
  00 01 02 03 04 05 06 07     
  10 11 12 13 14 15 16 17     
  20 21 22 23 24 25 26 27     00 01 10 11 02 03 12 13 20 21 30 31 22 23 32 33 \
  30 31 32 33 34 35 36 37 =>  04 05 14 15 06 07 16 17 24 25 34 35 26 27 36 37 \
  40 41 42 43 44 45 46 47     40 41 50 51 42 43 52 53 60 61 70 71 62 63 72 73 \
  50 51 52 53 54 55 56 57     44 45 54 55 46 47 56 57 64 65 74 75 66 67 76 77   
  60 61 62 63 64 65 66 67     
  70 71 72 73 74 75 76 77     

  swizzling,                  32-bit
  linear:                     swizzled:
  00 01 02 03 04 05 06 07     
  10 11 12 13 14 15 16 17 =>  00 01 10 11 02 03 12 13 20 21 30 31 22 23 32 33 \
  20 21 22 23 24 25 26 27     04 05 14 15 06 07 16 17 24 25 34 35 26 27 36 37  
  30 31 32 33 34 35 36 37

  unswizzling, 8-bit or 16-bit
  swizzled:                                             linear:
  00 01 10 11 02 03 12 13 20 21 30 31 22 21 32 31 \     00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
  04 05 14 15 06 07 16 17 24 25 34 35 26 27 36 37... => 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
  08 09 18 19 0a 0b 1a 1b 28 29 38 39 2a 2b 3a 3b \     20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
  0c 0d 1c 1d 0e 0f 1e 1f 2c 2d 3c 3d 2e 2f 3e 3f       30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f

  unswizzling, 32-bit
  swizzled:	                                            linear:
                                                        00 01 02 03 04 05 06 07
  00 01 10 11 02 03 12 13 20 21 30 31 22 23 32 33 \  => 10 11 12 13 14 15 16 17
  04 05 14 15 06 07 16 17 24 25 34 35 26 27 36 37       20 21 22 23 24 25 26 27
                                                        30 31 32 33 34 35 36 37

  The algorithm moves through the linear texture left->right, top->bottom,
  which means the swizzled array gets 64 or 128-byte blocks written to it in a
  seemingly random order.

  AddValU and AddValV are set to move to the next block. (-32), (-64), (-128), 
  and (-256) were precalculated using the following algorithm (using 
  Swizzler class methods):

    After finishing with one block, the U coordinate must be incrimented to
	the next block. Since all blocks are 4 texels wide, the value to add will
    be constant. Swizzing (4) for use with the U coordinate results in 16. 
	(This assumes that the texture is at least 4 texels wide and 2 texels tall). 
	Then, 16 is plugged into the AddU formula from the Swizzler class: 

	  m_u = (m_u - ((-num) & m_MaskU)) & m_MaskU

	AddValU is set equal to ((-num) & m_MaskU). AddValV is calculated in a 
	similar manner. 

  This algorithm only works with textures with width and height >= block_size.
  This means that special-cases must occur when the is smaller. XBSwizzleRect
  and XBUnswizzleRect take care of this. Textures with width < 4, or height < 2 
  actually look exactly the same in memory when they are swizzled as when they 
  are deswizzled. memcpy() is used in that condition. For sizes between (2,4) and 
  (blocksize_x, blocksize_y), the texture is swizzled in 2x1 blocks.
*/

VOID swiz2d_8bit (LPCVOID pSrc, LPVOID pDest, int Width, int Height) 
{
	DWORD MaskU, MaskV, AddValU, AddValV;

	GetMasks2(Width, Height, &MaskU, &MaskV);

	AddValU = (-64) & MaskU;
	AddValV = (-128) & MaskV;

	//eax = scratch
	//ebx = u
	//ecx = y
	//edx = pitch
	//esi = pSrc 
	//edi = pDest 

	_asm {
		mov esi, pSrc;					//source + (0, 0)
		mov edi, pDest;					//dest

		mov edx, [Width];				//edx = width
		xor ebx, ebx;					//swiz(u)
		xor ecx, ecx;					//swiz(v)

		align 16						//seems to help speed a little

Start:

			  movq mm0, [esi];				//00 01 02 03 04 05 06 07
			  movq mm1, [esi + edx];		//10 11 12 13 14 15 16 17
			  add esi, edx;					//pSrc + (u, v + 1)
			  mov eax, ebx;					//eax = swiz(u)
			  movq mm4, [esi + edx];		//20 21 22 23 24 25 26 27
			  movq mm5, [esi + edx * 2];	//30 31 32 33 34 35 36 37
			  or eax, ecx;					//eax = swiz(u) | swiz(b)
			  movq mm6, mm4;				//20 21 22 23 24 25 26 27
			  movq mm2, mm0;				//00 01 02 03 04 05 06 07
			  
			  punpckhwd mm6, mm5;			//24 25 34 35 26 27 36 37

			  lea esi, [esi + edx * 4];		//pSrc + (u, v + 5)
			  punpckhwd mm2, mm1			//04 05 14 15 06 07 16 17
			  punpcklwd mm4, mm5;			//20 21 30 31 22 23 30 33

			  movq mm3, [esi];				//50 51 52 53 54 55 56 57
			  movq mm5, [esi+edx];			//60 61 62 63 64 65 66 67
			  movq mm7, [esi+edx*2];		//70 71 72 73 74 75 76 77
			  sub esi, edx					//pSrc + (u, v + 4)
			  punpcklwd mm0, mm1;			//00 01 10 11 02 03 12 13
			  movq mm1, [esi];				//40 41 42 43 44 45 46 47

			  movq [edi + eax      ], mm0;	//00 01 10 11 02 03 12 13
			  movq [edi + eax +   8], mm4;	//20 21 30 31 22 23 30 33
			  movq [edi + eax +  16], mm2;  //04 05 14 15 06 07 16 17
			  movq [edi + eax +  24], mm6;	//24 25 34 35 26 27 36 37
		  
			  movq mm0, mm1					//40 41 42 43 44 45 46 47
			  movq mm4, mm5					//60 61 62 63 64 65 66 67

			  punpcklwd mm0, mm3			//40 41 50 51 42 43 52 53
			  punpcklwd mm4, mm7			//60 61 70 71 62 63 72 73
			  punpckhwd mm1, mm3			//44 45 54 55 46 47 56 57
			  punpckhwd mm5, mm7			//64 65 74 75 66 67 76 77

			  movq [edi + eax +  32], mm0;	//40 41 50 51 42 43 52 53
			  movq [edi + eax +  40], mm4;	//60 61 70 71 62 63 72 73
			  movq [edi + eax +  48], mm1;  //44 45 54 55 46 47 56 57
			  movq [edi + eax +  56], mm5;	//64 65 74 75 66 67 76 77

			  sub esi, edx
			  sub esi, edx
			  sub esi, edx
			  sub esi, edx					//pSrc + (u, v)

			  sub ebx, [AddValU];			//part 1 of: swiz(u) += 8

			  //this number of nops seems to be optimal.
			  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
			  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
			  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
			  _asm{nop} _asm{nop} _asm{nop} _asm{nop} //_asm{nop} //_asm{nop} _asm{nop} _asm{nop}

			  add esi, 8;					//u += 8
			  and ebx, [MaskU];				//(continued): swiz(u) += 8;
			jnz Start;						//if swiz(u) hasn't looped back to 0, repeat

		  sub ecx, [AddValV];			//part 1 of: swiz(v) += 8		

		  lea esi, [esi + edx * 8]		//pSrc + (u, v + 9) //(v has been incrimented by u looping)
		  sub esi, edx;					//pSrc + (u, v + 8)
		//(it has already looped around to 1 row below where we were. This moves
		//it to the second row down, since we are dealing with 8x8 blocks)

		  and ecx, [MaskV];				//(continued): swiz(v) += 8
		  jnz Start;					//if v is not done, keep going

		emms;		//done with mmx
	}
}


VOID swiz2d_16bit (LPCVOID pSrc, LPVOID pDest, int Width, int Height) 
{
	DWORD MaskU, MaskV, AddValU, AddValV;

    if (((DWORD)pDest) & 15)
        DXGRIP("Error: Destination memory must be 16-byte aligned");


	GetMasks2(Width, Height, &MaskU, &MaskV);

	AddValU = (-64) & MaskU;
	AddValV = (-128) & MaskV;

	//eax = scratch
	//ebx = u
	//ecx = y
	//edx = pitch
	//esi = pSrc (this is not changed)
	//edi = pDest (this is incrimented)

	_asm {
		mov esi, pSrc;					
		mov edi, pDest;

		mov edx, [Width];
		xor ebx, ebx;
		xor ecx, ecx;
		add edx, edx;					//edx = width * 2

		align 16
Start:
		  movups xmm0, [esi];			
		  movups xmm1, [esi + edx];		
		  add esi, edx;
		  mov eax, ebx;					//eax = u
		  movups xmm4, [esi + edx];
		  movups xmm5, [esi + edx * 2];
		  or eax, ecx;					//eax = u | v

		  movaps xmm6, xmm4;
		  movaps xmm2, xmm0;

		  unpckhps xmm6, xmm5;

          lea esi, [esi + edx * 4]; //esi = src + width*5
		  unpckhps xmm2, xmm1		
		  unpcklps xmm4, xmm5;

		  movups xmm3, [esi]; //5
		  movups xmm5, [esi+edx]; //6;
		  movups xmm7, [esi+edx*2]; //7
		  sub esi, edx
		  unpcklps xmm0, xmm1;			
		  movups xmm1, [esi]; //4

		  movntps [edi + eax*2      ], xmm0;		
		  movntps [edi + eax*2 +  16], xmm4;
		  movntps [edi + eax*2 +  32], xmm2;  
		  movntps [edi + eax*2 +  48], xmm6;
	  
		  movaps xmm0, xmm1
		  movaps xmm4, xmm5

		  unpcklps xmm0, xmm3
		  unpcklps xmm4, xmm7
		  unpckhps xmm1, xmm3
		  unpckhps xmm5, xmm7

		  movntps [edi + eax*2 +  64], xmm0;		
		  movntps [edi + eax*2 +  80], xmm4;
		  movntps [edi + eax*2 +  96], xmm1;  
		  movntps [edi + eax*2 + 112], xmm5;

		  sub esi, edx
		  sub esi, edx
		  sub esi, edx
		  sub esi, edx

		  sub ebx, [AddValU];				//part 1 of adding 8 to u

		  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
		  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
		  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
		  _asm{nop} _asm{nop} _asm{nop} _asm{nop} //_asm{nop} //_asm{nop} _asm{nop} _asm{nop}

		  add esi, 16;						//move source pointer to next block
		  and ebx, [MaskU];				//ebx = the next u coordinate
		jnz Start;						//if u hasn't looped back to 0, repeat

		sub ecx, [AddValV];				//part 1 of adding 8 to v		
		lea esi, [esi + edx * 8]
		sub esi, edx;					//move src pointer to next row
		//(this moves it to the second row down, since it has already looped
		//to the first row down)

		and ecx, [MaskV];				//ecx = the next v coordinate
		jnz Start;						//if v is not done, keep going
	}
}

VOID swiz2d_32bit (LPCVOID pSrc, LPVOID pDest, int Width, int Height) 
{
	DWORD MaskU, MaskV, AddValU, AddValV;

    if (((DWORD)pDest) & 15)
        DXGRIP("Error: Destination memory must be 16-byte aligned");

	GetMasks2(Width, Height, &MaskU, &MaskV);

	AddValU = (-64) & MaskU;
	AddValV = (-32) & MaskV;

	//eax = scratch
	//ebx = u
	//ecx = y
	//edx = pitch
	//esi = pSrc (this is not changed)
	//edi = pDest (this is incrimented)

	_asm {
		mov esi, pSrc;
		mov edi, pDest;

		mov edx, [Width];
		xor ebx, ebx;
		xor ecx, ecx;
		shl edx, 2;						//edx = width * 4

		align 16
Start:
			mov eax, ebx;				//eax = u

			movups xmm0, [esi];			
			movups xmm4, [esi + 16];	
			movups xmm2, [esi + edx];   
			movups xmm6, [esi + edx + 16];

			movaps xmm1, xmm0
			movaps xmm5, xmm4

			lea esi, [esi + edx * 2]
			or eax, ecx;				//eax = u | v

			movlhps xmm0, xmm2
			movhlps xmm2, xmm1
			movlhps xmm4, xmm6
			movhlps xmm6, xmm5

			movups xmm1, [esi];			
			movups xmm5, [esi + 16];	
			movups xmm3, [esi + edx];   
			movups xmm7, [esi + edx + 16];

			movntps [edi + eax*4      ], xmm0;	
			movntps [edi + eax*4 +  16], xmm2;
			movntps [edi + eax*4 +  64], xmm4;
			movntps [edi + eax*4 +  80], xmm6;

			movaps xmm0, xmm1
			movaps xmm4, xmm5

			movlhps xmm1, xmm3
			movhlps xmm3, xmm0
			movlhps xmm5, xmm7
			movhlps xmm7, xmm4

			movntps [edi + eax*4 +  32], xmm1;
			movntps [edi + eax*4 +  48], xmm3;
			movntps [edi + eax*4 +  96], xmm5;
			movntps [edi + eax*4 + 112], xmm7;

			sub esi, edx;
			sub esi, edx;

		  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
		  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
		  _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
		  _asm{nop} _asm{nop} _asm{nop} _asm{nop} //_asm{nop} //_asm{nop} _asm{nop} _asm{nop}



			sub ebx, [AddValU];			//part 1 of adding 8 to u
			add esi, 32;				//move source pointer to next block
		
			and ebx, [MaskU];			//part 2 of "u += 8"
			jnz Start;					//if u hasn't looped to 0, keep going

		  sub ecx, [AddValV];			//part 1 of "v += 4"

		  lea esi, [esi + edx * 4];
		  sub esi, edx;					//move source pointer to 2 rows down

		  and ecx, [MaskV];				//part 1 of "v += 4"
		  jnz Start;					//if v hasn't looped to 0, repeat
	}
}

VOID unswiz2d_8bit (LPCVOID pSrc, LPVOID pDest, int Width, int Height) 
{
	DWORD MaskU, MaskV, AddValU, AddValV;

	GetMasks2(Width, Height, &MaskU, &MaskV);

	AddValU = (-256)& MaskU;
	AddValV = (-32) & MaskV;

	//eax = scratch
	//ebx = u
	//ecx = y
	//edx = pitch
	//esi = pSrc (this is not changed)
	//edi = pDest (this is incrimented)

	_asm {
		mov esi, pSrc;
		mov edi, pDest;

		mov edx, [Width];				//edx = width
		xor ebx, ebx;
		xor ecx, ecx;

Start:
			mov eax, ebx;					//eax = u
			sub ebx, [AddValU];				//part 1 of "u += 4"
			or eax, ecx;					//eax = u | v

			pshufw mm0, [esi + eax       ], 11011000b;
			pshufw mm2, [esi + eax +64   ], 11011000b;
			pshufw mm4, [esi + eax +   16], 11011000b;
			pshufw mm6, [esi + eax +64+16], 11011000b;

			movq mm1, mm0;
			movq mm3, mm2;

			punpckldq mm0, mm4;
			punpckhdq mm1, mm4;
			punpckldq mm2, mm6;
			punpckhdq mm3, mm6;

			movq [edi], mm0;
			movq [edi+8], mm2;
			movq [edi + edx], mm1;
			movq [edi + edx + 8], mm3;

			add edi, edx;

			pshufw mm4, [esi + eax +    8], 11011000b;
			pshufw mm5, [esi + eax +64+ 8], 11011000b;
			pshufw mm6, [esi + eax +   24], 11011000b;
			pshufw mm7, [esi + eax +64+24], 11011000b;

			movq mm0, mm4;
			movq mm1, mm5;

			punpckldq mm0, mm6;
			punpckhdq mm4, mm6;
			punpckldq mm1, mm7;
			punpckhdq mm5, mm7;


			movq [edi + edx], mm0;
			movq [edi + edx + 8], mm1;
			movq [edi + edx*2], mm4;
			movq [edi + edx*2 + 8], mm5;


			sub edi, edx;
			add edi, 16;
			and ebx, [MaskU];
			jnz Start;

  		  sub ecx, [AddValV];			//part 1 of "v += 2"

		  lea edi, [edi + edx*4];
		  sub edi, edx;						//move dest to next row of blocks

		  and ecx, [MaskV];				//part 2 of "v += 2"
		  jnz Start;					//if v hasn't looped back to 0, do this row

		emms;							//done with mmx instructions
	}
}

VOID unswiz2d_16bit (LPCVOID pSrc, LPVOID pDest, int Width, int Height) 
{
	DWORD MaskU, MaskV, AddValU, AddValV;

    if (((DWORD)pSrc) & 15)
        DXGRIP("16-bit unswizzle: Source memory must be 16-byte aligned");
	if (((DWORD)pDest) & 15)
		DXGRIP("16-bit unswizzle: Destination must be 16-byte aligned");

	GetMasks2(Width, Height, &MaskU, &MaskV);

	AddValU = (-256) & MaskU;
	AddValV = (-32) & MaskV;

	//eax = scratch
	//ebx = u
	//ecx = y
	//edx = pitch
	//esi = pSrc (this is not changed)
	//edi = pDest (this is incrimented)

	_asm {
		mov esi, pSrc;
		mov edi, pDest;

		mov edx, [Width];
		xor ebx, ebx;
		xor ecx, ecx;
		add edx, edx; 

		align 16;
Start:
			mov eax, ebx;					//eax = u
			sub ebx, [AddValU];				//part 1 of "u += 16"
			or eax, ecx;					//eax = u | v

			movaps xmm0, [esi + eax*2       ];
			movaps xmm4, [esi + eax*2 +   32];
			movaps xmm2, [esi + eax*2 +  128];
			movaps xmm6, [esi + eax*2 +128+32];

			movaps xmm1, xmm0;
			movaps xmm3, xmm2;

			shufps xmm0, xmm4, 10001000b;
			shufps xmm1, xmm4, 11011101b;
			shufps xmm2, xmm6, 10001000b;
			shufps xmm3, xmm6, 11011101b;

			movaps xmm4, [esi + eax*2 +   16];
			movaps xmm6, [esi + eax*2 +   48];
			movaps xmm5, [esi + eax*2 +128+16];
			movaps xmm7, [esi + eax*2 +128+48];

			movntps [edi], xmm0;
			movntps [edi+16], xmm2;
			movntps [edi + edx], xmm1;
			movntps [edi + edx + 16], xmm3;

			add edi, edx;
			movaps xmm0, xmm4;
			movaps xmm1, xmm5;

			shufps xmm0, xmm6, 10001000b;
			shufps xmm4, xmm6, 11011101b;
			shufps xmm1, xmm7, 10001000b;
			shufps xmm5, xmm7, 11011101b;

			movntps [edi + edx], xmm0;
			movntps [edi + edx + 16], xmm1;
			movntps [edi + edx*2], xmm4;
			movntps [edi + edx*2 + 16], xmm5;


			_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
			_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
			_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
			_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
			_asm {nop} _asm {nop} //_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 

			sub edi, edx;
			add edi, 32;
			and ebx, [MaskU];				//part 2 of "u += 16"
			jnz Start;

 		  sub ecx, [AddValV];				//part 1 of "v += 4"

		  lea edi, [edi + edx*4];
		  sub edi, edx;						//move dest to next row of blocks

		  and ecx, [MaskV];					//part 2 of "v += 4"
		  jnz Start;						//if v hasn't looped to 0, do this row
	}
}

VOID unswiz2d_32bit (LPCVOID pSrc, LPVOID pDest, int Width, int Height) 
{
	DWORD MaskU, MaskV, AddValU, AddValV;

    if (((DWORD)pSrc) & 15)
        DXGRIP("32-bit unswizzle: Source memory must be 16-byte aligned");
	if (((DWORD)pDest) & 15)
		DXGRIP("32-bit unswizzle: Destination must be 16-byte aligned");



	GetMasks2(Width, Height, &MaskU, &MaskV);

	AddValU = (-64) & MaskU;
	AddValV = (-32) & MaskV;

	//eax = scratch
	//ebx = u
	//ecx = y
	//edx = pitch
	//esi = pSrc (this is not changed)
	//edi = pDest (this is incrimented)

	_asm {
		mov esi, pSrc;
		mov edi, pDest;

		mov edx, [Width];
		xor ebx, ebx;
		xor ecx, ecx;
		shl edx, 2;

Start:			
			mov eax, ebx;				//eax = u
			or eax, ecx;				//eax = u | v
			sub ebx, [AddValU];			//part 1 of "u += 8"

			movaps xmm0, [esi+eax*4];		
			movaps xmm2, [esi+eax*4+16];
			movaps xmm4, [esi+eax*4+64];
			movaps xmm6, [esi+eax*4+80];

			movaps xmm1, xmm0;
			movaps xmm5, xmm4;

			movlhps xmm0, xmm2;
			movhlps xmm2, xmm1;
			movlhps xmm4, xmm6;
			movhlps xmm6, xmm5;

			movaps xmm1, [esi+eax*4+32];
			movaps xmm3, [esi+eax*4+48];
			movaps xmm5, [esi+eax*4+96];
			movaps xmm7, [esi+eax*4+112];

			movntps [edi], xmm0;
			movntps [edi+16], xmm4;
			movntps [edi+edx], xmm2;
			movntps [edi+edx+16], xmm6;

			add edi, edx;
			movaps xmm0, xmm1;
			movaps xmm4, xmm5;

			movlhps xmm1, xmm3;
			movhlps xmm3, xmm0;
			movlhps xmm5, xmm7;
			movhlps xmm7, xmm4;

			movntps [edi+edx], xmm1;
			movntps [edi+edx+16], xmm5;
			movntps [edi+edx*2], xmm3;
			movntps [edi+edx*2+16], xmm7;

			sub edi, edx;

			_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
			_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
			_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
			_asm {nop} _asm {nop} _asm {nop} _asm {nop} //_asm {nop} _asm {nop} _asm {nop} _asm {nop} 

			add edi, 32;				//move dest ptr to next block
				
			and ebx, [MaskU];			//part 2 of "u += 8"
			jnz Start;					//if u hasn't looped to 0, repeat for next block
	
		  sub ecx, [AddValV];			//part 1 of "v += 4"

		  lea edi, [edi + edx*4];
		  sub edi, edx;					//move dst ptr to next row

		  and ecx, [MaskV];				//part 2 of "v += 4"
		  jnz Start;					//if v hasn't looped to 0, repeat for next row
	}
}


//----------------------------------------------------------------------------
// Determine if a D3DFORMAT is a swizzled one
//
extern "C"
BOOL WINAPI XGIsSwizzledFormat(
    D3DFORMAT Format
    )
{
    switch(Format)
    {
    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
    case D3DFMT_A1R5G5B5:
    case D3DFMT_A4R4G4B4:
    case D3DFMT_A8:
    case D3DFMT_A8B8G8R8:
    case D3DFMT_B8G8R8A8:
    case D3DFMT_R4G4B4A4:
    case D3DFMT_R5G5B5A1:
    case D3DFMT_R8G8B8A8:
    case D3DFMT_R8B8:
    case D3DFMT_G8B8:
    case D3DFMT_P8:
    case D3DFMT_L8:
    case D3DFMT_A8L8:
    case D3DFMT_AL8:
    case D3DFMT_L16:
    case D3DFMT_L6V5U5:
    case D3DFMT_V16U16:
    case D3DFMT_D16_LOCKABLE:
    case D3DFMT_D24S8:
    case D3DFMT_F16:
    case D3DFMT_F24S8:
        return TRUE;
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// Helper to get bytes per pixel from a D3DFORMAT
//
extern "C"
DWORD WINAPI XGBytesPerPixelFromFormat(
    D3DFORMAT Format
    )
{
    switch (Format)
    {
    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
    case D3DFMT_A8B8G8R8:
    case D3DFMT_B8G8R8A8:
    case D3DFMT_R8G8B8A8:
    case D3DFMT_V16U16:
    case D3DFMT_D24S8:
    case D3DFMT_F24S8:
    case D3DFMT_UYVY:
    case D3DFMT_YUY2:
    case D3DFMT_LIN_A8B8G8R8:
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_B8G8R8A8:
    case D3DFMT_LIN_R8G8B8A8:
    case D3DFMT_LIN_X8R8G8B8:
    case D3DFMT_LIN_D24S8:
    case D3DFMT_LIN_F24S8:
        return 4;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
    case D3DFMT_A1R5G5B5:
    case D3DFMT_A4R4G4B4:
    case D3DFMT_R4G4B4A4:
    case D3DFMT_R5G5B5A1:
    case D3DFMT_R8B8:
    case D3DFMT_G8B8:
    case D3DFMT_A8L8:
    case D3DFMT_L16:
    case D3DFMT_L6V5U5:
    case D3DFMT_D16_LOCKABLE:
    case D3DFMT_F16:
    case D3DFMT_LIN_A1R5G5B5:
    case D3DFMT_LIN_A4R4G4B4:
    case D3DFMT_LIN_G8B8:
    case D3DFMT_LIN_R4G4B4A4:
    case D3DFMT_LIN_R5G5B5A1:
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_R6G5B5:
    case D3DFMT_LIN_R8B8:
    case D3DFMT_LIN_X1R5G5B5:
    case D3DFMT_LIN_A8L8:
    case D3DFMT_LIN_L16:
    case D3DFMT_LIN_D16:
    case D3DFMT_LIN_F16:
        return 2;

    case D3DFMT_DXT2:
    case D3DFMT_DXT4:
    case D3DFMT_A8:
    case D3DFMT_P8:
    case D3DFMT_L8:
    case D3DFMT_AL8:
    case D3DFMT_LIN_A8:
    case D3DFMT_LIN_AL8:
    case D3DFMT_LIN_L8:
        return 1;
    }

    return 0;
}

template <class T>
class XGInternalSwizzler {
	public:
	//for swizzling 1x* columns
    static VOID Swizzle1x1Column (XGINTERNALSWIZZLE* ps)
	{    
		SWIZNUM SwizU = ps->swiz.SwizzleU(ps->DLeft + ps->xOff);
		SWIZNUM SwizV = ps->swiz.SwizzleV(ps->DTop + ps->yOff);

	    ps->swiz.SetV(SwizV);
		ps->swiz.SetU(0);

		unsigned int v;
//        DWORD PitchAdjust = Pitch - RWidth * sizeof(T);

		T* src = (T*)((BYTE*)ps->pSource + (ps->Pitch * (ps->STop + ps->yOff)) + (sizeof(T) * (ps->SLeft + ps->xOff)));
		T* dest = &((T*)ps->pDest)[SwizU];

        for (v = ps->uHeight; v--;) 
        {
            dest[ps->swiz.m_v] = *src;
            ps->swiz.IncV();
            src = (T*)((BYTE *)src + ps->Pitch);
        }
	}

    static VOID Unswizzle1x1Column (XGINTERNALSWIZZLE* ps)
	{
		SWIZNUM SwizU = ps->swiz.SwizzleU(ps->SLeft + ps->xOff);
		SWIZNUM SwizV = ps->swiz.SwizzleV(ps->STop + ps->yOff);
		ps->swiz.SetV(SwizV);
		ps->swiz.SetU(0);
		unsigned int v;

		T* src = &((T*)ps->pSource)[SwizU];
		T* dest = (T*)((BYTE*)ps->pDest + (ps->Pitch * (ps->DTop + ps->yOff)) + (sizeof(T) * (ps->DLeft + ps->xOff)));

		for (v = ps->uHeight; v--;) 
		{
			*dest = src[ps->swiz.m_v];
			ps->swiz.IncV();
			dest = (T*)((BYTE*)dest + ps->Pitch);
		}
	}

	//note: call this with WORD, DWORD, and QWORD, instead of BYTE, WORD, DWORD.
	//also, only call this if the SLeft, STop, RWidth, and RHeight are multiples of 2.

    static VOID Swizzle2x1 (XGINTERNALSWIZZLE* ps)
	{	
		ps->mask[0] = ps->swiz.m_MaskU;
		ps->mask[1] = ps->swiz.m_MaskV;

		SWIZNUM SwizU = ps->swiz.SwizzleU(ps->DLeft + ps->xOff);
		SWIZNUM SwizV = ps->swiz.SwizzleV(ps->DTop + ps->yOff);
		
		ps->swiz.m_MaskU >>= 1;  ps->swiz.m_MaskV >>= 1;
		SwizU >>= 1;             SwizV >>= 1;

		unsigned int u, v, i;
        DWORD PitchAdjust = ps->Pitch - ps->uWidth * (sizeof(T) / 2);

		T* src = (T*)((BYTE*)ps->pSource + (ps->Pitch * (ps->STop + ps->yOff)) + ((sizeof(T) / 2) * (ps->SLeft + ps->xOff)));
		T* dest = (T*)ps->pDest;

	    ps->swiz.SetV(SwizV);

		for (v = ps->uHeight; v--;) 
        {
            ps->swiz.SetU(SwizU);

            for (u = ps->uWidth >> 1; u--;) 
            {
                dest[ps->swiz.Get2D()] = *(src++);
                ps->swiz.IncU();
            }

            ps->swiz.IncV();
            src = (T*)((BYTE *)src + PitchAdjust);
        }
		ps->swiz.m_MaskU = ps->mask[0];
		ps->swiz.m_MaskV = ps->mask[1];
	}

    static VOID Unswizzle2x1 (XGINTERNALSWIZZLE* ps)
	{
		ps->mask[0] = ps->swiz.m_MaskU;
		ps->mask[1] = ps->swiz.m_MaskV;

		SWIZNUM SwizU = ps->swiz.SwizzleU(ps->SLeft + ps->xOff);
		SWIZNUM SwizV = ps->swiz.SwizzleV(ps->STop + ps->yOff);
		ps->swiz.m_MaskU >>= 1;  ps->swiz.m_MaskV >>= 1;
		SwizU >>= 1;             SwizV >>= 1;

		unsigned int u,v,i;
		DWORD PitchAdjust = ps->Pitch - ps->uWidth * (sizeof(T) / 2);

		T* src = (T*)ps->pSource;
		T* dest = (T*)((BYTE*)ps->pDest + (ps->Pitch * (ps->DTop + ps->yOff)) + ((sizeof(T) / 2) * (ps->DLeft + ps->xOff)));
		
		ps->swiz.SetV(SwizV);
		for(v = ps->uHeight; v--;)
		{
			ps->swiz.SetU(SwizU);
			for(u = ps->uWidth >> 1; u--;)
			{
				*(dest++) = src[ps->swiz.Get2D()];
				ps->swiz.IncU();
			}
			ps->swiz.IncV();
			dest = (T*)((BYTE*)dest + PitchAdjust);
		}

		ps->swiz.m_MaskU = ps->mask[0];
		ps->swiz.m_MaskV = ps->mask[1];
	}
};

__forceinline VOID XGInternalSwizzle1x1Column(XGINTERNALSWIZZLE* ps)
{
	if(ps->bpp == 4) {
		XGInternalSwizzler<DWORD>::Swizzle1x1Column(ps);
	} else if (ps->bpp == 2) {
		XGInternalSwizzler<WORD>::Swizzle1x1Column(ps);
	} else {
		XGInternalSwizzler<BYTE>::Swizzle1x1Column(ps);
	}
}
__forceinline VOID XGInternalSwizzle2x1(XGINTERNALSWIZZLE* ps)
{
	if(ps->bpp == 4) {
		XGInternalSwizzler<QWORD>::Swizzle2x1(ps);
	} else if (ps->bpp == 2) {
		XGInternalSwizzler<DWORD>::Swizzle2x1(ps);
	} else {
		XGInternalSwizzler<WORD>::Swizzle2x1(ps);
	}
}
__forceinline VOID XGInternalUnswizzle1x1Column(XGINTERNALSWIZZLE* ps)
{
	if(ps->bpp == 4) {
		XGInternalSwizzler<DWORD>::Unswizzle1x1Column(ps);
	} else if (ps->bpp == 2) {
		XGInternalSwizzler<WORD>::Unswizzle1x1Column(ps);
	} else {
		XGInternalSwizzler<BYTE>::Unswizzle1x1Column(ps);
	}
}
__forceinline VOID XGInternalUnswizzle2x1(XGINTERNALSWIZZLE* ps)
{
	if(ps->bpp == 4) {
		XGInternalSwizzler<QWORD>::Unswizzle2x1(ps);
	} else if (ps->bpp == 2) {
		XGInternalSwizzler<DWORD>::Unswizzle2x1(ps);
	} else {
		XGInternalSwizzler<WORD>::Unswizzle2x1(ps);
	}
}



//----------------------------------------------------------------------------
// Swizzle a subrectangle from a buffer into a larger texture.  The 
// destination rectangle must be completely contained within the destination 
// texture (no clipping).
//
// If pRect is NULL, pPoint is NULL and Pitch == 0, this routine will
// assume that the source buffer is exactly the same size as the destination
// texture and will swizzle the whole thing.  This routine will run
// considerably faster in that case.
//
extern "C"
VOID WINAPI XGSwizzleRect(
    LPCVOID pSource,      // The buffer that contains the source rectangle
    DWORD   Pitch,        // The pitch of the buffer that contains the source
    LPCRECT pRect,        // The rectangle within the buffer to copy.
    LPVOID  pDest,        // The destination texture.
    DWORD   Width,        // The width of the entire destination texture.
    DWORD   Height,       // The height of the entire destination texture.
    CONST LPPOINT pPoint, // Where to put the rectangle in the texture.
    DWORD   BytesPerPixel
    )
{
#ifndef XBOX
	//if SSE instructions are not supported, XGSwizzleBox with depth==1 does the same thing as 
	  //XGSwizzleRect, but doesn't use pentium-3-specific instructions
	if (!SupportsSSE()) {
		D3DBOX Box, *pBox = &Box;
		XGPOINT3D Point3, *pPoint3 = &Point3;
		if(!pRect) {
			pBox = NULL;
		} else {
			Box.Left = pRect->left;
			Box.Right = pRect->right;
			Box.Top = pRect->top;
			Box.Bottom = pRect->bottom;
			Box.Front = 0;
			Box.Back = 1;
		}

		if(!pPoint) {
			pPoint3 = NULL;
		} else {
			Point3.u = pPoint->x;
			Point3.v = pPoint->y;
			Point3.w = 0;
		}

		XGSwizzleBox(pSource, Pitch, Pitch * Width, pBox, pDest, Width, Height, 1, pPoint3, BytesPerPixel);
		return;
	}
#endif

	unsigned int MinBlockWidth[3]  = {16,16, 8};
	unsigned int MinBlockHeight[3] = { 8, 8, 8};

	unsigned int WidthMasks[3]     = { 7, 7, 7};
	unsigned int HeightMasks[3]    = { 7, 7, 3};

    if (DBG_CHECK(1))
    {
		if (((Width - 1) & Width) || ((Height - 1) & Height))
        {
			DXGRIP("XGSwizzleRect - Width and Height must be power of 2!");
        }
		if ((Width < 1) || (Width > 4096) || (Height < 1) || (Height > 4096))
        {
			DXGRIP("XGSwizzleRect - Width and Height must be between 1 and 4096");
        }
		if ((BytesPerPixel != 4) && (BytesPerPixel != 2) && (BytesPerPixel != 1)) 
        {
			DXGRIP("XGSwizzleRect - BytesPerPixel must be 1, 2, or 4!");
        }
    }

	//tiny textures
	if (Width <= 2 || Height <= 1) 
	{		
		memcpy(pDest, pSource, Width * Height * BytesPerPixel);
		return;
	} 

	//full-texture swizzles
	if (!pRect && !pPoint && Pitch == 0)
	{
		if (BytesPerPixel == 4) 
		{
			if(Width >= MinBlockWidth[2] && Height >= MinBlockHeight[2]) {
				//32-bit swizzler does 8x4 blocks
				swiz2d_32bit(pSource, pDest, Width, Height);
				return;
			} 
		} 
		else if (BytesPerPixel == 2) 
		{
			if(Width >= MinBlockWidth[1] && Height >= MinBlockHeight[1]) {
				//16-bit swizzler does 8x8 blocks
				swiz2d_16bit(pSource, pDest, Width, Height);
				return;
			} 
		}
		else 
		{
			if(Width >= MinBlockWidth[0] && Height >= MinBlockHeight[0]) {
				//8-bit swizzler does 8x8 blocks
				swiz2d_8bit(pSource, pDest, Width, Height);
				return;
			} 
		}

		//too small for the full-texture swizzler. Use the smaller swizzlers instead.
	} 
	else if (DBG_CHECK(1)) 
	{
        if (!pRect || !pPoint || Pitch == 0)
        {
//            DXGRIP("XGSwizzleRect - Either all of pRect, pPoint and Pitch == 0 or none.");
        }
	}

	XGINTERNALSWIZZLE s;
	s.bpp = BytesPerPixel;
	s.Height = Height;
	s.Width = Width;
	if(pPoint == NULL) {
		s.DLeft = 0;
		s.DTop = 0;
	} else {
		s.DLeft = pPoint->x;
		s.DTop = pPoint->y;
	}
	s.pDest = pDest;
	s.pSource = pSource;
	if(pRect == NULL) {
		s.RHeight = Height;
		s.RWidth = Width;
		s.SLeft = 0;
		s.STop = 0;
	} else {
		s.RHeight = pRect->bottom - pRect->top;
		s.RWidth = pRect->right - pRect->left;
		s.SLeft = pRect->left;
		s.STop = pRect->top;
	}
	if(Pitch == 0) {
		s.Pitch = s.Width * s.bpp;
	} else {
		s.Pitch = Pitch;
	}
	s.swiz.Init(Width, Height, 0);
	s.mask[0] = s.swiz.m_MaskU;
	s.mask[1] = s.swiz.m_MaskV;

 	if (DBG_CHECK(1))
    {
        if (s.DLeft + s.RWidth > Width
            || s.DTop + s.RHeight > Height)
        {
            DXGRIP("XGSwizzleRect - The swizzled rectangle must fit completely inside of the destination texture, this routine does no clipping.");
        }

        if (s.Pitch < s.RWidth * BytesPerPixel)
        {
            DXGRIP("XGSwizzleRect - The pitch of the source rectangle must be at least as big as the rectangle width * BytesPerPixel.");
        }
    }

	if(!s.RHeight || !s.RWidth) return; //width == 0, or height == 0

	DWORD WMask = WidthMasks [(BytesPerPixel >> 1)]; //7,7,7
	DWORD HMask = HeightMasks[(BytesPerPixel >> 1)]; //7,7,3
	
	//if the left edge isn't 2-pixel aligned, deal with that first.
	if(s.DLeft & 1) {
		s.xOff = 0;  s.yOff = 0;
		s.uWidth = 1; s.uHeight = s.RHeight;
		XGInternalSwizzle1x1Column(&s);
		++s.SLeft; 
		++s.DLeft;
		if(!--s.RWidth) return; //if width == 0, we're done
	}

	//if the right edge isn't 2-pixel aligned, do that too...
	if(s.RWidth & 1) {
		s.RWidth--;
		s.xOff = s.RWidth;   s.yOff = 0;
		s.uWidth = 1;
		s.uHeight = s.RHeight;
		XGInternalSwizzle1x1Column(&s);
		if(!s.RWidth) return; //if width == 0, we're done.
	}

	//if there aren't going to be any 8x8's, just fill the rest using 2x1s.
	//if left edge (aligned right) is >= right edge (aligned left), there is no opportunity for 8x8.
	//if top edge, (aligned downward) is lower than bottom edge (aligned upward), there is no opportunity for 8x8.
	if((((s.DLeft + WMask) & ~WMask) >= ((s.DLeft + s.RWidth ) & ~WMask)) || 
	   (((s.DTop  + HMask) & ~HMask) >= ((s.DTop  + s.RHeight) & ~HMask)) ||
	   ((s.Width < MinBlockWidth[(BytesPerPixel >> 1)])) ||
	   ((s.Height < MinBlockHeight[(BytesPerPixel >> 1)]))) {
		s.xOff = 0;              s.yOff = 0;
		s.uHeight = s.RHeight;   s.uWidth = s.RWidth;
		XGInternalSwizzle2x1(&s);
		return;
	}

	//if the top isn't 8-pixel aligned, deal with that.
	if(s.DTop & HMask) {
		DWORD h = (0-s.DTop) & HMask;
		s.xOff = 0;           s.yOff = 0;
		s.uWidth = s.RWidth;  s.uHeight = h;
		XGInternalSwizzle2x1(&s);
		s.STop += h;
		s.DTop += h;
		s.RHeight -= h;
	}

	//if the bottom isn't 8-pixel aligned, deal with that.
	if(s.RHeight & HMask) {
		DWORD h = (s.RHeight & HMask);
		s.RHeight -= h;
		s.xOff = 0; 	       s.yOff = s.RHeight;
		s.uWidth = s.RWidth;   s.uHeight = h;
		XGInternalSwizzle2x1(&s);
	}

	//if the left isn't 8-pixel aligned, do that...
	if(s.DLeft & WMask) {
		DWORD w = (0-s.DLeft) & WMask;
		s.xOff = 0;     s.yOff = 0;
		s.uWidth = w;   s.uHeight = s.RHeight;
		XGInternalSwizzle2x1(&s);
		s.DLeft += w;
		s.SLeft += w;
		s.RWidth -= w;
	}

	//if the right isn't 8-pixel aligned, do that too.
	if(s.RWidth & WMask) {
		DWORD w = (s.RWidth & WMask);
		s.RWidth -= w;
		s.xOff = s.RWidth;  s.yOff = 0;
		s.uWidth = w;       s.uHeight = s.RHeight; 
		XGInternalSwizzle2x1(&s);
	}

	//now, do the 8x8's!
	DWORD AddValU, AddValV;
	DWORD StartU,  StartV;
	DWORD EsiStore;
	DWORD WidthStore;
	
	if(s.bpp == 4) {
		AddValU = (-64) & s.swiz.m_MaskU;
		AddValV = (-32) &  s.swiz.m_MaskV;
		StartU = s.swiz.SwizzleU(s.DLeft);
		StartV = s.swiz.SwizzleV(s.DTop);
		s.pSource = ((BYTE*)s.pSource) + (s.SLeft * s.bpp) + (s.STop * s.Pitch);
		s.RWidth  >>= 3; // width /= 8;
		s.RHeight >>= 2; //height /= 4;
		WidthStore = s.RWidth;
		if((DWORD)(s.pDest) & 15) {
			DXGRIP("XBSwizzleRect: pDest must be 16-byte aligned");
		}

		
		_asm {
			mov esi, [s.pSource]
			mov edi, [s.pDest]
			mov edx, [s.Width]
			shl edx, 2 //size of each destination row
			mov ebx, [StartU]
			mov ecx, [StartV]

			mov EsiStore, esi;
			align 16;

Start32:	
				mov eax, ebx
				movups xmm0, [esi];
				movups xmm4, [esi + 16];
				movups xmm2, [esi + edx];
				movups xmm6, [esi + edx + 16];

				movaps xmm1, xmm0;
				movaps xmm5, xmm4;

				lea esi, [esi + edx * 2];
				or eax, ecx;

				movlhps xmm0, xmm2
				movhlps xmm2, xmm1
				movlhps xmm4, xmm6
				movhlps xmm6, xmm5

				movups xmm1, [esi];			
				movups xmm5, [esi + 16];	
				movups xmm3, [esi + edx];   
				movups xmm7, [esi + edx + 16];

				movntps [edi + eax*4      ], xmm0;	//dest[u | v] = {a,b,c,d}
				movntps [edi + eax*4 +  16], xmm2;
				movntps [edi + eax*4 +  64], xmm4;
				movntps [edi + eax*4 +  80], xmm6;

				movaps xmm0, xmm1
				movaps xmm4, xmm5

				movlhps xmm1, xmm3
				movhlps xmm3, xmm0
				movlhps xmm5, xmm7
				movhlps xmm7, xmm4

				movntps [edi + eax*4 +  32], xmm1;
				movntps [edi + eax*4 +  48], xmm3;
				movntps [edi + eax*4 +  96], xmm5;
				movntps [edi + eax*4 + 112], xmm7;

				sub esi, edx;
				sub esi, edx;

				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} //_asm{nop} //_asm{nop} _asm{nop} _asm{nop}

				sub ebx, [AddValU];
				add esi, 32;
				and ebx, [s.swiz.m_MaskU];
				
				dec [s.RWidth];
 			  jnz Start32;

			  mov esi, [WidthStore];
			  mov ebx, [StartU];
			  mov [s.RWidth], esi;
			  mov esi, [EsiStore];
			  mov eax, [s.Pitch];
			  sub ecx, [AddValV];
		      lea esi, [esi + eax * 4];
			  and ecx, [s.swiz.m_MaskV];
			  mov [EsiStore], esi;

			  dec [s.RHeight];
			jnz Start32;
		}
	} else if ( s.bpp == 2) {
		AddValU = (-64) & s.swiz.m_MaskU;
		AddValV = (-128) &  s.swiz.m_MaskV;
		StartU = s.swiz.SwizzleU(s.DLeft);
		StartV = s.swiz.SwizzleV(s.DTop);
		s.pSource = ((BYTE*)s.pSource) + (s.SLeft * s.bpp) + (s.STop * s.Pitch);
		s.RWidth  >>= 3; // width /= 8;
		s.RHeight >>= 3; //height /= 8;
		WidthStore = s.RWidth;
		if((DWORD)(s.pDest) & 15) {
			DXGRIP("XBSwizzleRect: pDest must be 16-byte aligned");
		}

		_asm {
			mov esi, [s.pSource]
			mov edi, [s.pDest]
			mov edx, [s.Width]
			shl edx, 1 //size of each destination row
			mov ebx, [StartU]
			mov ecx, [StartV]

			mov EsiStore, esi;
			align 16;
Start16:
				movups xmm0, [esi];				//xmm0 = {a, b, e, f, ?, ?, ?, ?}
				movups xmm1, [esi + edx];		//xmm1 = {c, d, g, h, ?, ?, ?, ?}
				add esi, edx;
				mov eax, ebx;					//eax = u
				movups xmm4, [esi + edx];
				movups xmm5, [esi + edx * 2];
				or eax, ecx;					//eax = u | v
				movaps xmm2, xmm0;
				movaps xmm6, xmm4;
				unpckhps xmm6, xmm5;

				lea esi, [esi + edx * 4]; //esi = src + width*5
				unpckhps xmm2, xmm1		
				unpcklps xmm4, xmm5;

				movups xmm3, [esi]; //5
				movups xmm5, [esi+edx]; //6;
				movups xmm7, [esi+edx*2]; //7
				sub esi, edx
				unpcklps xmm0, xmm1;			//xmm1 = {a, b, c, d, e, f, g, h}
				movups xmm1, [esi]; //4

				movntps [edi + eax*2      ], xmm0;		//dest[u | v] = {a, b, c, d, e, f, g, h}
				movntps [edi + eax*2 +  16], xmm4;
				movntps [edi + eax*2 +  32], xmm2;  
				movntps [edi + eax*2 +  48], xmm6;

				movaps xmm0, xmm1
				movaps xmm4, xmm5

				unpcklps xmm0, xmm3
				unpcklps xmm4, xmm7
				unpckhps xmm1, xmm3
				unpckhps xmm5, xmm7

				movntps [edi + eax*2 +  64], xmm0;		//dest[u | v] = {a, b, c, d, e, f, g, h}
				movntps [edi + eax*2 +  80], xmm4;
				movntps [edi + eax*2 +  96], xmm1;  
				movntps [edi + eax*2 + 112], xmm5;

				sub esi, edx
				sub esi, edx
				sub esi, edx
				sub esi, edx

				sub ebx, [AddValU];				//part 1 of adding 4 to u

				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} //_asm{nop} //_asm{nop} _asm{nop} _asm{nop}

				add esi, 16;						//move source pointer to next block
				and ebx, [s.swiz.m_MaskU];				//ebx = the next u coordinate
				dec s.RWidth;
			  jnz Start16;

			  mov esi, [WidthStore];
			  mov ebx, [StartU];
			  mov [s.RWidth], esi;
			  mov esi, [EsiStore];
			  mov eax, [s.Pitch];
			  sub ecx, [AddValV];
		      lea esi, [esi + eax * 8];
			  and ecx, [s.swiz.m_MaskV];
			  mov [EsiStore], esi;

			  dec [s.RHeight];
			jnz Start16;
		}
	} else {
		AddValU = (-64) & s.swiz.m_MaskU;
		AddValV = (-128) &  s.swiz.m_MaskV;
		StartU = s.swiz.SwizzleU(s.DLeft);
		StartV = s.swiz.SwizzleV(s.DTop);
		s.pSource = ((BYTE*)s.pSource) + (s.SLeft * s.bpp) + (s.STop * s.Pitch);
		s.RWidth  >>= 3; // width /= 8;
		s.RHeight >>= 3; //height /= 8;
		WidthStore = s.RWidth;

		_asm {
			mov esi, [s.pSource]
			mov edi, [s.pDest]
			mov edx, [s.Width]
			mov ebx, [StartU]
			mov ecx, [StartV]

			mov EsiStore, esi;
			align 16;

Start8:
				movq mm0, [esi];				//xmm0 = {a, b, e, f, ?, ?, ?, ?}
				movq mm1, [esi + edx];		//xmm1 = {c, d, g, h, ?, ?, ?, ?}
				add esi, edx;
				mov eax, ebx;					//eax = u
				movq mm4, [esi + edx];
				movq mm5, [esi + edx * 2];
				or eax, ecx;					//eax = u | v
				movq mm2, mm0;
				movq mm6, mm4;
				punpckhwd mm6, mm5;

				lea esi, [esi + edx * 4]; //esi = src + width*5
				punpckhwd mm2, mm1		
				punpcklwd mm4, mm5;

				movq mm3, [esi]; //5
				movq mm5, [esi+edx]; //6;
				movq mm7, [esi+edx*2]; //7
				sub esi, edx
				punpcklwd mm0, mm1;			//xmm1 = {a, b, c, d, e, f, g, h}
				movq mm1, [esi]; //4

				movq [edi + eax      ], mm0;		//dest[u | v] = {a, b, c, d, e, f, g, h}
				movq [edi + eax +   8], mm4;
				movq [edi + eax +  16], mm2;  
				movq [edi + eax +  24], mm6;

				movq mm0, mm1
				movq mm4, mm5
				punpcklwd mm0, mm3
				punpcklwd mm4, mm7
				punpckhwd mm1, mm3
				punpckhwd mm5, mm7
				movq [edi + eax +  32], mm0;		//dest[u | v] = {a, b, c, d, e, f, g, h}
				movq [edi + eax +  40], mm4;
				movq [edi + eax +  48], mm1;  
				movq [edi + eax +  56], mm5;

				sub esi, edx
				sub esi, edx
				sub esi, edx
				sub esi, edx

				sub ebx, [AddValU];				//part 1 of adding 4 to u

				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop} _asm{nop}
				_asm{nop} _asm{nop} _asm{nop} _asm{nop} //_asm{nop} //_asm{nop} _asm{nop} _asm{nop}

				add esi, 8;						//move source pointer to next block
				and ebx, [s.swiz.m_MaskU];				//ebx = the next u coordinate
				dec s.RWidth;
			  jnz Start8;

			  mov eax, [WidthStore];
			  mov ebx, [StartU];
			  mov [s.RWidth], eax;
			  mov esi, [EsiStore];
			  mov eax, [s.Pitch];
			  sub ecx, [AddValV];
		      lea esi, [esi + eax * 8];
			  and ecx, [s.swiz.m_MaskV];
			  mov [EsiStore], esi;

			  dec [s.RHeight];
			jnz Start8;
			emms 
		}

	}

	return;

}

//----------------------------------------------------------------------------
// Unswizzle a subrectangle from a texture into a buffer.
//
// If pRect is NULL, pPoint is NULL and Pitch == 0, this routine will
// assume that the source texture is exactly the same size as the destination
// buffer and will unswizzle the whole thing.  This routine will run
// considerably faster in that case.
//
extern "C"
VOID WINAPI XGUnswizzleRect(
    LPCVOID pSource,      // The source texture.
    DWORD   Width,        // The width of the entire source texture.
    DWORD   Height,       // The height of the entire source texture.
    LPCRECT pRect,        // The rectangle within the texture to copy.
    LPVOID  pDest,        // The destination buffer
    DWORD   Pitch,        // The pitch of the destination buffer
    CONST LPPOINT pPoint, // Where to copy the rectangle to
    DWORD   BytesPerPixel
    )
{
#ifndef XBOX
	//if SSE instructions are not supported, XGUnswizzleBox with depth==1 does the same thing as 
	  //XGUnswizzleRect, but doesn't use pentium-3-specific instructions
	if (!SupportsSSE()) {
		D3DBOX Box, *pBox = &Box;
		XGPOINT3D Point3, *pPoint3 = &Point3;
		if(!pRect) {
			pBox = NULL;
		} else {
			Box.Left = pRect->left;
			Box.Right = pRect->right;
			Box.Top = pRect->top;
			Box.Bottom = pRect->bottom;
			Box.Front = 0;
			Box.Back = 1;
		}

		if(!pPoint) {
			pPoint3 = NULL;
		} else {
			Point3.u = pPoint->x;
			Point3.v = pPoint->y;
			Point3.w = 0;
		}

		XGUnswizzleBox(pSource, Width, Height, 1, pBox, pDest, Pitch, Pitch * Height, pPoint3, BytesPerPixel);
		return;
	}
#endif

	unsigned int MinBlockWidth[3] =  {16,16,8};
	unsigned int MinBlockHeight[3] = {16,16,8}; //height isn't actually 16, but is required to be at least 8.
	unsigned int WidthMasks[3] =  {15,15,7}; //used in aligning block-unswizzles
	unsigned int HeightMasks[3] = {3, 3, 3}; //used in aligning for block-unswizzles

    if (DBG_CHECK(1))
    {
		if (((Width - 1) & Width) || ((Height - 1) & Height))
        {
			DXGRIP("XGSwizzleRect - Width and Height must be power of 2!");
        }
		if ((Width < 1) || (Width > 4096) || (Height < 1) || (Height > 4096))
        {
			DXGRIP("XGSwizzleRect - Width and Height must be between 1 and 4096");
        }
		if ((BytesPerPixel != 4) && (BytesPerPixel != 2) && (BytesPerPixel != 1)) 
        {
			DXGRIP("XGSwizzleRect - BytesPerPixel must be 1, 2, or 4!");
        }
    }

	//tiny textures
	if (Width <= 2 || Height <= 1) 
	{		
		memcpy(pDest, pSource, Width * Height * BytesPerPixel);
		return;
	} 

	//full-texture swizzles
	if (!pRect && !pPoint && Pitch == 0)
	{
		if (BytesPerPixel == 4) 
		{
			if(Width >= MinBlockWidth[2] && Height >= MinBlockHeight[2]) {
				//32-bit unswizzler does 8x4 blocks
				unswiz2d_32bit(pSource, pDest, Width, Height);
				return;
			} 
		} 
		else if (BytesPerPixel == 2) 
		{
			if(Width >= MinBlockWidth[1] && Height >= MinBlockHeight[1]) {
				//16-bit unswizzler does 16x4 blocks
				unswiz2d_16bit(pSource, pDest, Width, Height);
				return;
			} 
		}
		else 
		{
			if(Width >= MinBlockWidth[0] && Height >= MinBlockHeight[0]) {
				//8-bit unswizzler does 16x4 blocks
				unswiz2d_8bit(pSource, pDest, Width, Height);
				return;
			} 
		}

		//too small for the full-texture unswizzler. Use the smaller swizzlers instead.
	} 
	else if (DBG_CHECK(1)) 
	{
        if (!pRect || !pPoint || Pitch == 0)
        {
//            DXGRIP("XGUnwizzleRect - Either all of pRect, pPoint and Pitch == 0 or none.");
        }
	}

	XGINTERNALSWIZZLE s;
	s.bpp = BytesPerPixel;
	s.Height = Height;
	s.Width = Width;
	if(pPoint == NULL) {
		s.DLeft = 0;
		s.DTop = 0;
	} else { 
		s.DLeft = pPoint->x;
		s.DTop = pPoint->y;
	}
	s.pDest = pDest;
	s.pSource = pSource;
	if(pRect == NULL) {
		s.RHeight = Height; 
		s.RWidth = Width;
		s.SLeft = 0;
		s.STop = 0;
	} else {
		s.RHeight = pRect->bottom - pRect->top;
		s.RWidth = pRect->right - pRect->left;

		s.SLeft = pRect->left;
		s.STop = pRect->top;
	}
	if(Pitch == 0) {
		s.Pitch = s.Width * s.bpp;
	} else {
		s.Pitch = Pitch;
	}
	s.swiz.Init(Width, Height, 0);
	s.mask[0] = s.swiz.m_MaskU;
	s.mask[1] = s.swiz.m_MaskV;

 	if (DBG_CHECK(1))
    {
        if (s.SLeft + s.RWidth > Width
            || s.STop + s.RHeight > Height)
        {
            DXGRIP("XGUnwizzleRect - The swizzled rectangle must fit completely inside of the source texture, this routine does no clipping.");
        }

        if (s.Pitch < s.RWidth * BytesPerPixel)
        {
            DXGRIP("XGUnwizzleRect - The pitch of the destination rectangle must be at least as big as the rectangle width * BytesPerPixel.");
        }
    }

	if(!s.RHeight || !s.RWidth) return; //width == 0, or height == 0

	DWORD WMask = WidthMasks[(BytesPerPixel >> 1)]; //15,15,7
	DWORD HMask = HeightMasks[(BytesPerPixel >> 1)]; //3,3,3
	
	//if the left edge isn't 2-pixel aligned, deal with that first.
	if(s.SLeft & 1) {
		s.xOff = 0;  s.yOff = 0;
		s.uWidth = 1; s.uHeight = s.RHeight;
		XGInternalUnswizzle1x1Column(&s);
		++s.SLeft; 
		++s.DLeft;
		if(!--s.RWidth) return; //if width == 0, we're done
	}

	//if the right edge isn't 2-pixel aligned, do that too...
	if(s.RWidth & 1) {
		s.RWidth--;
		s.xOff = s.RWidth;   s.yOff = 0;
		s.uWidth = 1;
		s.uHeight = s.RHeight;
		XGInternalUnswizzle1x1Column(&s);
		if(!s.RWidth) return; //if width == 0, we're done.
	}

	//if there aren't going to be any 8x8's, just fill the rest using 2x1s.
	//if left edge (aligned right) is >= right edge (aligned left), there is no opportunity for 8x8.
	//if top edge, (aligned downward) is lower than bottom edge (aligned upward), there is no opportunity for 8x8.
	if((((s.SLeft + WMask) & ~WMask) >= ((s.SLeft + s.RWidth ) & ~WMask)) || 
	   (((s.STop  + HMask) & ~HMask) >= ((s.STop  + s.RHeight) & ~HMask)) ||
	   ((s.Width < MinBlockWidth[(BytesPerPixel >> 1)])) ||
	   ((s.Height < MinBlockHeight[(BytesPerPixel >> 1)])))
	{
		s.xOff = 0;              s.yOff = 0;
		s.uHeight = s.RHeight;   s.uWidth = s.RWidth;
		XGInternalUnswizzle2x1(&s);
		return;
	}

	//if the top isn't 8-pixel aligned, deal with that.
	if(s.STop & HMask) {
		DWORD h = (0-s.STop) & HMask; //number of texels from top to aligned top
		s.xOff = 0;           s.yOff = 0;
		s.uWidth = s.RWidth;  s.uHeight = h;
		XGInternalUnswizzle2x1(&s);
		s.STop += h;
		s.DTop += h;
		s.RHeight -= h;
	}

	//if the bottom isn't 8-pixel aligned, deal with that.
	if(s.RHeight & HMask) {
		DWORD h = (s.RHeight & HMask);
		s.RHeight -= h;
		s.xOff = 0; 	       s.yOff = s.RHeight;
		s.uWidth = s.RWidth;   s.uHeight = h;
		XGInternalUnswizzle2x1(&s);
	}

	//if the left isn't 8-pixel aligned, do that...
	if(s.SLeft & WMask) {
		DWORD w = (0-s.SLeft) & WMask;
		s.xOff = 0;     s.yOff = 0;
		s.uWidth = w;   s.uHeight = s.RHeight;
		XGInternalUnswizzle2x1(&s);
		s.DLeft += w;
		s.SLeft += w;
		s.RWidth -= w;
	}

	//if the right isn't 8-pixel aligned, do that too.
	if(s.RWidth & WMask) {
		DWORD w = (s.RWidth & WMask);
		s.RWidth -= w;
		s.xOff = s.RWidth;  s.yOff = 0;
		s.uWidth = w;       s.uHeight = s.RHeight; 
		XGInternalUnswizzle2x1(&s);
	}

	//now, do the 8x8's!
	DWORD AddValU, AddValV;
	DWORD StartU,  StartV;
	DWORD EdiStore;
	DWORD WidthStore;
	
	if(s.bpp == 4) {
		AddValU = (-64) & s.swiz.m_MaskU;
		AddValV = (-32) & s.swiz.m_MaskV;
		StartU = s.swiz.SwizzleU(s.SLeft);
		StartV = s.swiz.SwizzleV(s.STop);
		s.pDest = ((BYTE*)s.pDest) + (s.DLeft * s.bpp) + (s.DTop * s.Pitch);
		s.RWidth  >>= 3; // width /= 8;
		s.RHeight >>= 2; //height /= 4;
		WidthStore = s.RWidth;
		if(/*((DWORD)(s.pDest) & 15) ||*/ ((DWORD)(s.pSource) & 15)) {
			DXGRIP("XGUnswizzleRect: pSource" /*" and pDest"*/ " must be 16-byte aligned");
		}

		
		_asm {
			mov esi, [s.pSource]
			mov edi, [s.pDest]
			mov edx, [s.Width]
			shl edx, 2 //size of each destination row
			mov ebx, [StartU]
			mov ecx, [StartV]

			mov EdiStore, edi;
			align 16;

Start32:	
				mov eax, ebx;				//eax = u
				or eax, ecx;				//eax = u | v
				sub ebx, [AddValU];			//part 1 of "u += 8"

				movaps xmm0, [esi+eax*4];		
				movaps xmm2, [esi+eax*4+16];
				movaps xmm4, [esi+eax*4+64];
				movaps xmm6, [esi+eax*4+80];

				movaps xmm1, xmm0;
				movaps xmm5, xmm4;

				movlhps xmm0, xmm2;
				movhlps xmm2, xmm1;
				movlhps xmm4, xmm6;
				movhlps xmm6, xmm5;

				movaps xmm1, [esi+eax*4+32];
				movaps xmm3, [esi+eax*4+48];
				movaps xmm5, [esi+eax*4+96];
				movaps xmm7, [esi+eax*4+112];

				movups [edi], xmm0;
				movups [edi+16], xmm4;
				movups [edi+edx], xmm2;
				movups [edi+edx+16], xmm6;

				add edi, edx;
				movaps xmm0, xmm1;
				movaps xmm4, xmm5;

				movlhps xmm1, xmm3;
				movhlps xmm3, xmm0;
				movlhps xmm5, xmm7;
				movhlps xmm7, xmm4;

				movups [edi+edx], xmm1;
				movups [edi+edx+16], xmm5;
				movups [edi+edx*2], xmm3;
				movups [edi+edx*2+16], xmm7;

				sub edi, edx;
/*
				_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
				_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
				_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
				_asm {nop} _asm {nop} _asm {nop} _asm {nop} //_asm {nop} _asm {nop} _asm {nop} _asm {nop} 
*/
				add edi, 32;				//move dest ptr to next block
				and ebx, [s.swiz.m_MaskU];
				
				dec [s.RWidth];
 			  jnz Start32;

			  mov eax, [WidthStore];
			  mov ebx, [StartU];
			  mov [s.RWidth], eax;
			  mov edi, [EdiStore];
			  mov eax, [s.Pitch];
			  sub ecx, [AddValV];
		      lea edi, [edi + eax * 4];
			  and ecx, [s.swiz.m_MaskV];
			  mov [EdiStore], edi;

			  dec [s.RHeight];
			jnz Start32;
		}
	} else if ( s.bpp == 2) {
		AddValU = (-256) & s.swiz.m_MaskU;
		AddValV = (-32) & s.swiz.m_MaskV;
		StartU = s.swiz.SwizzleU(s.SLeft);
		StartV = s.swiz.SwizzleV(s.STop);
		s.pDest = ((BYTE*)s.pDest) + (s.DLeft * s.bpp) + (s.DTop * s.Pitch);
		s.RWidth  >>= 4; // width /= 16;
		s.RHeight >>= 2; //height /= 4;
		WidthStore = s.RWidth;
		if(/*((DWORD)(s.pDest) & 15) ||*/ ((DWORD)(s.pSource) & 15)) {
			DXGRIP("XGUnswizzleRect: pSource "/*"and pDest "*/"must be 16-byte aligned");
		}

		_asm {
			mov esi, [s.pSource]
			mov edi, [s.pDest]
			mov edx, [s.Width]
			shl edx, 1 //size of each destination row
			mov ebx, [StartU]
			mov ecx, [StartV]

			mov EdiStore, edi;
			align 16;
Start16:
				mov eax, ebx;					//eax = u
				sub ebx, [AddValU];				//part 1 of "u += 16"
				or eax, ecx;					//eax = u | v

				movaps xmm0, [esi + eax*2       ];
				movaps xmm4, [esi + eax*2 +   32];
				movaps xmm2, [esi + eax*2 +  128];
				movaps xmm6, [esi + eax*2 +128+32];

				movaps xmm1, xmm0;
				movaps xmm3, xmm2;

				shufps xmm0, xmm4, 10001000b;
				shufps xmm1, xmm4, 11011101b;
				shufps xmm2, xmm6, 10001000b;
				shufps xmm3, xmm6, 11011101b;

				movaps xmm4, [esi + eax*2 +   16];
				movaps xmm6, [esi + eax*2 +   48];
				movaps xmm5, [esi + eax*2 +128+16];
				movaps xmm7, [esi + eax*2 +128+48];

				movups [edi], xmm0;
				movups [edi+16], xmm2;
				movups [edi + edx], xmm1;
				movups [edi + edx + 16], xmm3;

				add edi, edx;
				movaps xmm0, xmm4;
				movaps xmm1, xmm5;

				shufps xmm0, xmm6, 10001000b;
				shufps xmm4, xmm6, 11011101b;
				shufps xmm1, xmm7, 10001000b;
				shufps xmm5, xmm7, 11011101b;

				movups [edi + edx], xmm0;
				movups [edi + edx + 16], xmm1;
				movups [edi + edx*2], xmm4;
				movups [edi + edx*2 + 16], xmm5;

/*
				_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
				_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
				_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
				_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
				_asm {nop} _asm {nop} //_asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} _asm {nop} 
*/
				sub edi, edx;
				add edi, 32;
				and ebx, [s.swiz.m_MaskU];		//ebx = the next u coordinate

				dec [s.RWidth];
			  jnz Start16;

			  mov eax, [WidthStore];
			  mov ebx, [StartU];
			  mov [s.RWidth], eax;
			  mov edi, [EdiStore];
			  mov eax, [s.Pitch];
			  sub ecx, [AddValV];
		      lea edi, [edi + eax * 4];
			  and ecx, [s.swiz.m_MaskV];
			  mov [EdiStore], edi;

			  dec [s.RHeight];
			jnz Start16;
		}
	} else {
		AddValU = (-256) & s.swiz.m_MaskU;
		AddValV = (-32) & s.swiz.m_MaskV;
		StartU = s.swiz.SwizzleU(s.SLeft);
		StartV = s.swiz.SwizzleV(s.STop);
		s.pDest = ((BYTE*)s.pDest) + (s.DLeft * s.bpp) + (s.DTop * s.Pitch);
		s.RWidth  >>= 4; // width /= 16;
		s.RHeight >>= 2; //height /= 4;
		WidthStore = s.RWidth;

		_asm {
			mov esi, [s.pSource]
			mov edi, [s.pDest]
			mov edx, [s.Width]
			mov ebx, [StartU]
			mov ecx, [StartV]

			mov EdiStore, edi;
			align 16;

Start8:
				mov eax, ebx;					//eax = u
				sub ebx, [AddValU];				//part 1 of "u += 4"
				or eax, ecx;					//eax = u | v

				pshufw mm0, [esi + eax       ], 11011000b;
				pshufw mm2, [esi + eax +64   ], 11011000b;
				pshufw mm4, [esi + eax +   16], 11011000b;
				pshufw mm6, [esi + eax +64+16], 11011000b;

				movq mm1, mm0;
				movq mm3, mm2;

				punpckldq mm0, mm4;
				punpckhdq mm1, mm4;
				punpckldq mm2, mm6;
				punpckhdq mm3, mm6;

				movq [edi], mm0;             //row 0
				movq [edi+8], mm2;           //row 0
				movq [edi + edx], mm1;       //row 1
				movq [edi + edx + 8], mm3;   //row 1

				add edi, edx;

				pshufw mm4, [esi + eax +    8], 11011000b;
				pshufw mm5, [esi + eax +64+ 8], 11011000b;
				pshufw mm6, [esi + eax +   24], 11011000b;
				pshufw mm7, [esi + eax +64+24], 11011000b;

				movq mm0, mm4;
				movq mm1, mm5;

				punpckldq mm0, mm6;
				punpckhdq mm4, mm6;
				punpckldq mm1, mm7;
				punpckhdq mm5, mm7;


				movq [edi + edx], mm0;       //row 2
				movq [edi + edx + 8], mm1;   //row 2
                movq [edi + edx*2], mm4;     //row 3
                movq [edi + edx*2 + 8], mm5; //row 3


				sub edi, edx;
				add edi, 16;
				and ebx, [s.swiz.m_MaskU];				//ebx = the next u coordinate

				dec s.RWidth;
			  jnz Start8;

			  mov eax, [WidthStore];
			  mov ebx, [StartU];
			  mov [s.RWidth], eax;
			  mov edi, [EdiStore];
			  mov eax, [s.Pitch];
			  sub ecx, [AddValV];
		      lea edi, [edi + eax * 4];
			  and ecx, [s.swiz.m_MaskV];
			  mov [EdiStore], edi;

			  dec [s.RHeight];
			jnz Start8;
			emms 
		}

	}

	return;
}


//----------------------------------------------------------------------------
// Swizzle a box from a buffer into a larger texture.  The destination box 
// must be completely contained within the destination texture (no clipping).
//
extern "C"
VOID WINAPI XGSwizzleBox(
    LPCVOID     pSource,      // The buffer that contains the source rectangle
    DWORD       RowPitch,     // Byte offset from the left edge of one row to
                                // the left edge of the next row
    DWORD       SlicePitch,   // Byte offset from the top-left of one slice to
                                // the top-left of the next deepest slice
    CONST D3DBOX * pBox,      // The box within the buffer to copy.
    LPVOID      pDest,        // The destination texture.
    DWORD       Width,        // The width of the entire destination texture.
    DWORD       Height,       // The height of the entire destination texture.
    DWORD       Depth,        // The depth of the entire destination texture.
    CONST XGPOINT3D * pPoint, // Where to put the rectangle in the texture.
    DWORD       BytesPerPixel
    )
{
	//PERF: swizzling/unswizzling when Width==1 || Height==1 || Depth==1 is the same as 2d 
	//PERF: if 2 of the following are true: Width==2, Height==1, Depth==1: use memcpy

	//PERF: optimal swiz/unswiz of 32-bit should be done with 8x2x2. (requires 8x4x4 area, aligned to 8x2x2)
	//PERF: optimal 16-bit unswiz is 8x2x2 movups (requires 8x4x4 area, aligned to 8x2x2)
	//PERF: optimal 16-bit swiz is 8x2x2 movntps (requires 8x4x4 area, aligned to 8x2x2)
	//PERF: optimal 8-bit swiz is 4x2x2 movq 

    DWORD RWidth;
    DWORD RHeight;
    DWORD RDepth;

    DWORD UOffset;
    DWORD VOffset;
    DWORD WOffset;

    if (!pBox && !pPoint && !RowPitch && !SlicePitch)
    {
        RWidth = Width;
        RHeight = Height;
        RDepth = Depth;

        UOffset = 0;
        VOffset = 0;
        WOffset = 0;

        RowPitch = Width * BytesPerPixel;
        SlicePitch = RowPitch * Height;
    }
    else
    {
        if (DBG_CHECK(!pBox || !pPoint || !RowPitch || !SlicePitch))
        {
            DXGRIP("XGSwizzleBox - either all of pBox, pPoint, RowPitch and SlicePitch can be zero or none.");
        }

        pSource = (void *)((BYTE *)pSource + pBox->Left + pBox->Top * RowPitch + pBox->Front * SlicePitch);

        RWidth = pBox->Right - pBox->Left;
        RHeight = pBox->Bottom - pBox->Top;
        RDepth = pBox->Back - pBox->Front;

        UOffset = pPoint->u;
        VOffset = pPoint->v;
        WOffset = pPoint->w;

        if (DBG_CHECK(TRUE))
        {
            if (pPoint->u + RWidth > Width
                || pPoint->v + RHeight > Height
                || pPoint->w + RDepth > Depth)
            {
                DXGRIP("XGSwizzleBox - The swizzled rectangle must fit completely inside of the destination texture, this routine does no clipping.");
            }

            if (RowPitch < RWidth * BytesPerPixel)
            {
                DXGRIP("XGSwizzleBox - The row pitch of the source rectangle must be at least as big as the rectangle width * BytesPerPixel.");
            }

            if (SlicePitch < RowPitch * RHeight)
            {
                DXGRIP("XGSwizzleBox - The slice pitch of the source rectangle must be at least as big as the row pitch * height.");
            }
        }
    }

    unsigned int u, v, w;
    Swizzler swiz(Width, Height, Depth);

    SWIZNUM SwizU = swiz.SwizzleU(UOffset);
    SWIZNUM SwizV = swiz.SwizzleV(VOffset);
    SWIZNUM SwizW = swiz.SwizzleW(WOffset);

    swiz.SetW(SwizW);

    if (BytesPerPixel == 4)
    {
        DWORD *pSrc = (DWORD *)pSource;
        DWORD *pDst = (DWORD *)pDest;
        DWORD RowPitchAdjust = RowPitch - RWidth * BytesPerPixel;
        DWORD SlicePitchAdjust = SlicePitch - RHeight * RowPitch;

        for (w = RDepth; w--;) 
        {
            swiz.SetV(SwizV);

            for (v = RHeight; v--;) 
            {
                swiz.SetU(SwizU);

                for (u = RWidth; u--;) 
                {
                    pDst[swiz.Get3D()] = *(pSrc++);
                    swiz.IncU();
                }

                pSrc = (DWORD *)((BYTE *)pSrc + RowPitchAdjust);
                swiz.IncV();
            }

            pSrc = (DWORD *)((BYTE *)pSrc + SlicePitchAdjust);
            swiz.IncW();
        }
    }
    else if (BytesPerPixel == 2)
    {
        WORD *pSrc = (WORD *)pSource;
        WORD *pDst = (WORD *)pDest;
        DWORD RowPitchAdjust = RowPitch - RWidth * BytesPerPixel;
        DWORD SlicePitchAdjust = SlicePitch - RHeight * RowPitch;

        for (w = RDepth; w--;) 
        {
            swiz.SetV(SwizV);

            for (v = RHeight; v--;) 
            {
                swiz.SetU(SwizU);

                for (u = RWidth; u--;) 
                {
                    pDst[swiz.Get3D()] = *(pSrc++);
                    swiz.IncU();
                }

                pSrc = (WORD *)((BYTE *)pSrc + RowPitchAdjust);
                swiz.IncV();
            }

            pSrc = (WORD *)((BYTE *)pSrc + SlicePitchAdjust);
            swiz.IncW();
        }
    }
    else
    {
        BYTE *pSrc = (BYTE *)pSource;
        BYTE *pDst = (BYTE *)pDest;
        DWORD RowPitchAdjust = RowPitch - RWidth * BytesPerPixel;
        DWORD SlicePitchAdjust = SlicePitch - RHeight * RowPitch;

        for (w = RDepth; w--;) 
        {
            swiz.SetV(SwizV);

            for (v = RHeight; v--;) 
            {
                swiz.SetU(SwizU);

                for (u = RWidth; u--;) 
                {
                    pDst[swiz.Get3D()] = *(pSrc++);
                    swiz.IncU();
                }

                pSrc = pSrc + RowPitchAdjust;
                swiz.IncV();
            }

            pSrc = pSrc + SlicePitchAdjust;
            swiz.IncW();
        }
    }
}

//----------------------------------------------------------------------------
// Unswizzle a box from a texture into a buffer.
//
extern "C"
VOID WINAPI XGUnswizzleBox(
    LPCVOID     pSource,      // The source texture.
    DWORD       Width,        // The width of the entire source texture.
    DWORD       Height,       // The height of the entire source texture.
    DWORD       Depth,        // The depth of the entire destination texture.
    CONST D3DBOX * pBox,      // The rectangle within the texture to copy.
    LPVOID      pDest,        // The destination buffer
    DWORD       RowPitch,     // Byte offset from the left edge of one row to
                                // the left edge of the next row
    DWORD       SlicePitch,   // Byte offset from the top-left of one slice to
                                // the top-left of the next deepest slice
    CONST XGPOINT3D * pPoint, // Where to copy the rectangle to
    DWORD       BytesPerPixel
    )
{
	//PERF: swizzling/unswizzling when Width==1 || Height==1 || Depth==1 is the same as 2d 
	//PERF: if 2 of the following are true: Width==2, Height==1, Depth==1: use memcpy

	//PERF: optimal swiz/unswiz of 32-bit should be done with 8x2x2. (requires 8x4x4 area, aligned to 8x2x2)
	//PERF: optimal 16-bit unswiz is 8x2x2 movups (requires 8x4x4 area, aligned to 8x2x2)
	//PERF: optimal 16-bit swiz is 8x2x2 movntps (requires 8x4x4 area, aligned to 8x2x2)
	//PERF: optimal 8-bit swiz is 4x2x2 movq 



    DWORD RWidth;
    DWORD RHeight;
    DWORD RDepth;

    DWORD UOffset;
    DWORD VOffset;
    DWORD WOffset;

    if (!pBox && !pPoint && !RowPitch && !SlicePitch)
    {
        RWidth = Width;
        RHeight = Height;
        RDepth = Depth;

        UOffset = 0;
        VOffset = 0;
        WOffset = 0;

        RowPitch = Width * BytesPerPixel;
        SlicePitch = RowPitch * Height;
    }
    else
    {
        if (DBG_CHECK(!pBox || !pPoint || !RowPitch || !SlicePitch))
        {
            DXGRIP("XGSwizzleBox - either all of pBox, pPoint, RowPitch and SlicePitch can be zero or none.");
        }

        pDest = (void *)((BYTE *)pDest + pPoint->u + pPoint->v * RowPitch + pPoint->w * SlicePitch);

        RWidth = pBox->Right - pBox->Left;
        RHeight = pBox->Bottom - pBox->Top;
        RDepth = pBox->Back - pBox->Front;

        UOffset = pBox->Left;
        VOffset = pBox->Top;
        WOffset = pBox->Front;

        if (DBG_CHECK(TRUE))
        {
            if (pPoint->u + RWidth > Width
                || pPoint->v + RHeight > Height
                || pPoint->w + RDepth > Depth)
            {
                DXGRIP("XGUnswizzleBox - The swizzled rectangle must fit completely inside of the source texture, this routine does no clipping.");
            }

            if (RowPitch < RWidth * BytesPerPixel)
            {
                DXGRIP("XGUnswizzleBox - The row pitch of the source rectangle must be at least as big as the rectangle width * BytesPerPixel.");
            }

            if (SlicePitch < RowPitch * RHeight)
            {
                DXGRIP("XGUnswizzleBox - The slice pitch of the source rectangle must be at least as big as the row pitch * height.");
            }
        }
    }

    unsigned int u, v, w;
    Swizzler swiz(Width, Height, Depth);

    SWIZNUM SwizU = swiz.SwizzleU(UOffset);
    SWIZNUM SwizV = swiz.SwizzleV(VOffset);
    SWIZNUM SwizW = swiz.SwizzleW(WOffset);

    swiz.SetW(SwizW);

    if (BytesPerPixel == 4)
    {
        DWORD *pSrc = (DWORD *)pSource;
        DWORD *pDst = (DWORD *)pDest;
        DWORD RowPitchAdjust = RowPitch - RWidth * BytesPerPixel;
        DWORD SlicePitchAdjust = SlicePitch - RHeight * RowPitch;

        for (w = RDepth; w--;) 
        {
            swiz.SetV(SwizV);

            for (v = RHeight; v--;) 
            {
                swiz.SetU(SwizU);

                for (u = RWidth; u--;) 
                {
                    *(pDst++) = pSrc[swiz.Get3D()];
                    swiz.IncU();
                }

                pDst = (DWORD *)((BYTE *)pDst + RowPitchAdjust);
                swiz.IncV();
            }

            pDst = (DWORD *)((BYTE *)pDst + SlicePitchAdjust);
            swiz.IncW();
        }
    }
    else if (BytesPerPixel == 2)
    {
        WORD *pSrc = (WORD *)pSource;
        WORD *pDst = (WORD *)pDest;
        DWORD RowPitchAdjust = RowPitch - RWidth * BytesPerPixel;
        DWORD SlicePitchAdjust = SlicePitch - RHeight * RowPitch;

        for (w = RDepth; w--;) 
        {
            swiz.SetV(SwizV);

            for (v = RHeight; v--;) 
            {
                swiz.SetU(SwizU);

                for (u = RWidth; u--;) 
                {
                    *(pDst++) = pSrc[swiz.Get3D()];
                    swiz.IncU();
                }

                pDst = (WORD *)((BYTE *)pDst + RowPitchAdjust);
                swiz.IncV();
            }

            pDst = (WORD *)((BYTE *)pDst + SlicePitchAdjust);
            swiz.IncW();
        }
    }
    else
    {
        BYTE *pSrc = (BYTE *)pSource;
        BYTE *pDst = (BYTE *)pDest;
        DWORD RowPitchAdjust = RowPitch - RWidth * BytesPerPixel;
        DWORD SlicePitchAdjust = SlicePitch - RHeight * RowPitch;

        for (w = RDepth; w--;) 
        {
            swiz.SetV(SwizV);

            for (v = RHeight; v--;) 
            {
                swiz.SetU(SwizU);

                for (u = RWidth; u--;) 
                {
                    *(pDst++) = pSrc[swiz.Get3D()];
                    swiz.IncU();
                }

                pDst = pDst + RowPitchAdjust;
                swiz.IncV();
            }

            pDst = pDst + SlicePitchAdjust;
            swiz.IncW();
        }
    }
}

}
=== C:/Users/tree