IPSEC_OFFLOAD_V1_NET_BUFFER_LIST_INFO
{
    union
    {
        struct
        {
            NDIS_HANDLE OffloadHandle;

        } Transmit;

        struct
        {
            USHORT   SaDeleteReq:1;
            USHORT   CryptoDone:1;
            USHORT   NextCryptoDone:1;
            USHORT   Pad:13;
            USHORT   CryptoStatus;
        } Receive;
    };
} NDIS_IPSEC_OFFLOAD_V1_NET_BUFFER_LIST_INFO, *PNDIS_IPSEC_OFFLOAD_V1_NET_BUFFER_LIST_INFO;
#endif // (NDIS_SUPPORT_NDIS6 || NDIS60)

#if NDIS_LEGACY_DRIVER
//
//  The following defines are used in the Task field above to define
//  the type of task offloading necessary.
//
typedef enum _NDIS_TASK
{
    TcpIpChecksumNdisTask,
    IpSecNdisTask,
    TcpLargeSendNdisTask,
    MaxNdisTask
} NDIS_TASK, *PNDIS_TASK;


typedef enum _NDIS_ENCAPSULATION
{
    UNSPECIFIED_Encapsulation,
    NULL_Encapsulation,
    IEEE_802_3_Encapsulation,
    IEEE_802_5_Encapsulation,
    LLC_SNAP_ROUTED_Encapsulation,
    LLC_SNAP_BRIDGED_Encapsulation

} NDIS_ENCAPSULATION;

//
// Encapsulation header format
//
typedef struct _NDIS_ENCAPSULATION_FORMAT
{
    NDIS_ENCAPSULATION  Encapsulation;              // Encapsulation type
    struct
    {
        ULONG   FixedHeaderSize:1;
        ULONG   Reserved:31;
    } Flags;

    ULONG    EncapsulationHeaderSize;               // Encapsulation header size

} NDIS_ENCAPSULATION_FORMAT,*PNDIS_ENCAPSULATION_FORMAT;


//
// OFFLOAD header structure for OID_TCP_TASK_OFFLOAD
//
typedef struct _NDIS_TASK_OFFLOAD_HEADER
{
    ULONG       Version;                            // set to NDIS_TASK_OFFLOAD_VERSION
    ULONG       Size;                               // Size of this structure
    ULONG       Reserved;                           // Reserved for future use
    ULONG       OffsetFirstTask;                    // Offset to the first
    NDIS_ENCAPSULATION_FORMAT  EncapsulationFormat; // Encapsulation information.
                                                    // NDIS_TASK_OFFLOAD structure(s)

} NDIS_TASK_OFFLOAD_HEADER, *PNDIS_TASK_OFFLOAD_HEADER;


//
//  Task offload Structure, which follows the above header in ndis query
//
typedef struct _NDIS_TASK_OFFLOAD
{
    ULONG       Version;                            //  NDIS_TASK_OFFLOAD_VERSION
    ULONG       Size;                               //  Size of this structure. Used for version checking.
    NDIS_TASK   Task;                               //  Task.
    ULONG       OffsetNextTask;                     //  Offset to the next NDIS_TASK_OFFLOAD
    ULONG       TaskBufferLength;                   //  Length of the task offload information.
    UCHAR       TaskBuffer[1];                      //  The task offload information.
} NDIS_TASK_OFFLOAD, *PNDIS_TASK_OFFLOAD;

//
//  Offload structure for NDIS_TASK_TCP_IP_CHECKSUM
//
typedef struct _NDIS_TASK_TCP_IP_CHECKSUM
{
    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;
        ULONG       IpChecksum:1;
    } V4Transmit;

    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;
        ULONG       IpChecksum:1;
    } V4Receive;


    struct
    {
        ULONG       IpOptionsSupported:1;           // This field implies IpExtensionHeaders support
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;

    } V6Transmit;

    struct
    {
        ULONG       IpOptionsSupported:1;           // This field implies IpExtensionHeaders support
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;

    } V6Receive;


} NDIS_TASK_TCP_IP_CHECKSUM, *PNDIS_TASK_TCP_IP_CHECKSUM;

//
//  Off-load structure for NDIS_TASK_TCP_LARGE_SEND
//
#define NDIS_TASK_TCP_LARGE_SEND_V0         0

typedef struct _NDIS_TASK_TCP_LARGE_SEND
{
    ULONG     Version;                      // set to NDIS_TASK_TCP_LARGE_SEND_V0
    ULONG     MaxOffLoadSize;
    ULONG     MinSegmentCount;
    BOOLEAN   TcpOptions;
    BOOLEAN   IpOptions;

} NDIS_TASK_TCP_LARGE_SEND, *PNDIS_TASK_TCP_LARGE_SEND;


typedef struct _NDIS_TASK_IPSEC
{
    struct
    {
        ULONG   AH_ESP_COMBINED;
        ULONG   TRANSPORT_TUNNEL_COMBINED;
        ULONG   V4_OPTIONS;
        ULONG   RESERVED;
    } Supported;

    struct
    {
        ULONG   MD5:1;
        ULONG   SHA_1:1;
        ULONG   Transport:1;
        ULONG   Tunnel:1;
        ULONG   Send:1;
        ULONG   Receive:1;
    } V4AH;

    struct
    {
        ULONG   DES:1;
        ULONG   RESERVED:1;
        ULONG   TRIPLE_DES:1;
        ULONG   NULL_ESP:1;
        ULONG   Transport:1;
        ULONG   Tunnel:1;
        ULONG   Send:1;
        ULONG   Receive:1;
    } V4ESP;

} NDIS_TASK_IPSEC, *PNDIS_TASK_IPSEC;
#endif // NDIS_LEGACY_DRIVER

//
// flags used in NDIS_TASK_IPSEC->Supprted.RESERVED and
// NDIS_IPSEC_OFFLOAD_V1->Supported.Flags
// 
#define IPSEC_TPT_UDPESP_ENCAPTYPE_IKE                 0x00000001
#define IPSEC_TUN_UDPESP_ENCAPTYPE_IKE                 0x00000002
#define IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_IKE          0x00000004
#define IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_IKE   0x00000008
#define IPSEC_TPT_UDPESP_ENCAPTYPE_OTHER               0x00000010
#define IPSEC_TUN_UDPESP_ENCAPTYPE_OTHER               0x00000020
#define IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_OTHER        0x00000040
#define IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_OTHER 0x00000080


#if (NDIS_SUPPORT_NDIS6 || NDIS60)

//
// The definitions for the NDIS_TCP_LARGE_SEND_OFFLOAD_NET_BUFFER_LIST_INFO.Transmit.Type
// A miniport will use this definition to identify what offload type to use
// on the NetBufferList 
//
#define NDIS_TCP_LARGE_SEND_OFFLOAD_V1_TYPE     0
#define NDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE     1

//
// IP protocol version encoded in IPVersion field of
// NDIS_TCP_LARGE_SEND_OFFLOAD_NET_BUFFER_LIST_INFO->LsoV2Transmit.IPVersion
//
#define NDIS_TCP_LARGE_SEND_OFFLOAD_IPv4     0
#define NDIS_TCP_LARGE_SEND_OFFLOAD_IPv6     1

//
// The maximum length of the headers (MAC+IP+IP option or extension headers+TCP+TCP options)
// when stack does large send offload. If header is bigger than this value, it will not do
// LSO
// 
#define NDIS_LARGE_SEND_OFFLOAD_MAX_HEADER_LENGTH   128

//
// This structure is used in the OOB TcpLargeSendNetBufferListInfo.
//
typedef struct _NDIS_TCP_LARGE_SEND_OFFLOAD_NET_BUFFER_LIST_INFO
{
    union
    {
        struct
        {   
            ULONG    Unused:30;
            ULONG    Type:1;
            ULONG    Reserved2:1;
        } Transmit;

        struct
        {   
            ULONG    MSS:20;
            ULONG    TcpHeaderOffset:10;
            ULONG    Type:1;
            ULONG    Reserved2:1;
        } LsoV1Transmit;

        struct
        {
            ULONG    TcpPayload:30;
            ULONG    Type:1;
            ULONG    Reserved2:1;
        } LsoV1TransmitComplete;

        struct
        {
            ULONG    MSS:20;
            ULONG    TcpHeaderOffset:10;
            ULONG    Type:1;
            ULONG    IPVersion:1;
        } LsoV2Transmit;

        struct
        {
            ULONG    Reserved:30;
            ULONG    Type:1;
            ULONG    Reserved2:1;
        } LsoV2TransmitComplete;

        PVOID Value;
    };
} NDIS_TCP_LARGE_SEND_OFFLOAD_NET_BUFFER_LIST_INFO,*PNDIS_TCP_LARGE_SEND_OFFLOAD_NET_BUFFER_LIST_INFO;


//
//  Per-NetBufferList information for TcpIpChecksumNetBufferListInfo.
//
typedef struct _NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO
{
    union
    {
        struct
        {
            ULONG   IsIPv4:1;
            ULONG   IsIPv6:1;
            ULONG   TcpChecksum:1;
            ULONG   UdpChecksum:1;
            ULONG   IpHeaderChecksum:1;
            ULONG   Reserved:11;
            ULONG   TcpHeaderOffset:10;
        } Transmit;

        struct
        {
            ULONG   TcpChecksumFailed:1;
            ULONG   UdpChecksumFailed:1;
            ULONG   IpChecksumFailed:1;
            ULONG   TcpChecksumSucceeded:1;
            ULONG   UdpChecksumSucceeded:1;
            ULONG   IpChecksumSucceeded:1;
            ULONG   Loopback:1;
        } Receive;

        PVOID   Value;
    };
} NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO, *PNDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO;

//
// used in NDIS_STATUS_OFFLOAD_ENCASPULATION_CHANGE status indication and
// and OID_OFFLOAD_ENCAPSULATION OID request
//
#define NDIS_OFFLOAD_ENCAPSULATION_REVISION_1          1

typedef struct _NDIS_OFFLOAD_ENCAPSULATION
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_OFFLOAD_ENCAPSULATION;
    // Header.Size = sizeof(NDIS_OFFLOAD_ENCAPSULATION);
    // Header.Revision  = NDIS_OFFLOAD_ENCAPSULATION_REVISION_1;
    //
    
    NDIS_OBJECT_HEADER                     Header;

    struct
    {
        //
        // A Protocol sets Enable to NDIS_OFFLOAD_SET_ON if it is enabling IPv4 LSO,
        // or XSum offloads
        // otherwise it is set to NDIS_OFFLOAD_SET_NO_CHANGE
        //
        ULONG                               Enabled;

        //
        // If Enabled is TRUE, a Protocol must set this to 
        // either NDIS_ENCAPSULATION_IEEE_802_3 
        // or NDIS_ENCAPSULATION_IEEE_LLC_SNAP_ROUTED         
        //
        ULONG                               EncapsulationType;

        //
        // If Enabled is TRUE, a protocol must set this field to the 
        // HeaderSize it uses
        //
        ULONG                               HeaderSize;
    } IPv4;


    struct
    {
        //
        // A Protocol sets Enable to NDIS_OFFLOAD_SET_ON if it is enabling IPv6 LSO,
        // or XSum offloads
        // otherwise it is set to NDIS_OFFLOAD_SET_NO_CHANGE
        //
        ULONG                               Enabled;
        //
        // If Enabled is TRUE, a Protocol must set this to 
        // either NDIS_ENCAPSULATION_IEEE_802_3 
        // or NDIS_ENCAPSULATION_IEEE_LLC_SNAP_ROUTED         
        //
        ULONG                               EncapsulationType;

        //
        // If Enabled is TRUE, a protocol must set this field to the 
        // HeaderSize it uses
        //
        ULONG                               HeaderSize;
    } IPv6;

}NDIS_OFFLOAD_ENCAPSULATION, *PNDIS_OFFLOAD_ENCAPSULATION;

#define NDIS_SIZEOF_OFFLOAD_ENCAPSULATION_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD_ENCAPSULATION, IPv6.HeaderSize)

#if (NDIS_SUPPORT_NDIS61)
//
//  Per-NetBufferList information for IPsecOffloadV2NetBufferListInfo.
//
typedef struct _NDIS_IPSEC_OFFLOAD_V2_NET_BUFFER_LIST_INFO
{
    union
    {
        struct
        {
            PVOID   OffloadHandle;
        } Transmit;

        struct
        {
            ULONG   SaDeleteReq:1;
            ULONG   CryptoDone:1;
            ULONG   NextCryptoDone:1;  // Required for transport over tunnel
            ULONG   Reserved:13;
            ULONG   CryptoStatus:16;
        } Receive;
    };
} NDIS_IPSEC_OFFLOAD_V2_NET_BUFFER_LIST_INFO, *PNDIS_IPSEC_OFFLOAD_V2_NET_BUFFER_LIST_INFO;

//
//  Per-NetBufferList information for IPsecOffloadV2TunnelNetBufferListInfo.
//
typedef struct _NDIS_IPSEC_OFFLOAD_V2_TUNNEL_NET_BUFFER_LIST_INFO
{
    struct
    {
        NDIS_HANDLE TunnelHandle;      // Tunnel SA handle in Transport over tunnel
    } Transmit;
} NDIS_IPSEC_OFFLOAD_V2_TUNNEL_NET_BUFFER_LIST_INFO, *PNDIS_IPSEC_OFFLOAD_V2_TUNNEL_NET_BUFFER_LIST_INFO;

//
//  Per-NetBufferList information for IPsecOffloadV2HeaderNetBufferListInfo.
//
typedef struct _NDIS_IPSEC_OFFLOAD_V2_HEADER_NET_BUFFER_LIST_INFO
{
    struct
    {
        ULONG   NextHeader:8;           // Next Header value is the one carried in ESP trailer 
        ULONG   PadLength:8;
        ULONG   AhHeaderOffset:8;       // This is offset from beginning of IP Header and is measured in 4 byte increments
        ULONG   EspHeaderOffset:8;      // This is offset from beginning of IP Header and is measured in 4 byte increments
    } Transmit;
} NDIS_IPSEC_OFFLOAD_V2_HEADER_NET_BUFFER_LIST_INFO, *PNDIS_IPSEC_OFFLOAD_V2_HEADER_NET_BUFFER_LIST_INFO;

//
// Used in IPSEC_OFFLOAD_V2_ADD_SA.SecAssoc
//
#define IPSEC_OFFLOAD_V2_MAX_EXTENSION_HEADERS        2

//
// used in IPSEC_OFFLOAD_V2_ADD_SA.UdpEspEncapsulation and 
// NDIS_IPSEC_OFFLOAD_V2.UdpEsp
//
#define IPSEC_OFFLOAD_V2_UDP_ESP_ENCAPSULATION_NONE                         0x00000000
#define IPSEC_OFFLOAD_V2_UDP_ESP_ENCAPSULATION_TRANSPORT                    0x00000001
#define IPSEC_OFFLOAD_V2_UDP_ESP_ENCAPSULATION_TUNNEL                       0x00000002
#define IPSEC_OFFLOAD_V2_TRANSPORT_OVER_UDP_ESP_ENCAPSULATION_TUNNEL        0x00000004
#define IPSEC_OFFLOAD_V2_UDP_ESP_ENCAPSULATION_TRANSPORT_OVER_TUNNEL        0x00000008

//
// used in IPSEC_OFFLOAD_V2_SECURITY_ASSOCIATION.Flags
//
#define IPSEC_OFFLOAD_V2_ESN_SA                                             0x00000001

//
// used in IPSEC_OFFLOAD_V2_SECURITY_ASSOCIATION.Operation
//
typedef enum _IPSEC_OFFLOAD_V2_OPERATION
{
    IPsecOffloadV2Ah = 1,
    IPsecOffloadV2Esp,
    IPsecOffloadV2Max
} IPSEC_OFFLOAD_V2_OPERATION, *PIPSEC_OFFLOAD_V2_OPERATION;

//
// used in IPSEC_OFFLOAD_V2_SECURITY_ASSOCIATION.Spi
//
typedef ULONG IPSEC_OFFLOAD_V2_SPI_TYPE;

//
// used in AuthenticationAlgorithm and EncryptionAlgorithm fields
// of IPSEC_OFFLOAD_V2_SECURITY_ASSOCIATION structure
//
typedef struct _IPSEC_OFFLOAD_V2_ALGORITHM_INFO
{
    ULONG  Identifier;
    ULONG  KeyLength;
    ULONG  KeyOffsetBytes;
    ULONG  AdditionalInfo;
} IPSEC_OFFLOAD_V2_ALGORITHM_INFO, *PIPSEC_OFFLOAD_V2_ALGORITHM_INFO;

//
// used in IPSEC_OFFLOAD_V2_ADD_SA.SecAssoc
//
typedef struct _IPSEC_OFFLOAD_V2_SECURITY_ASSOCIATION
{
    ULONG                                 Flags;
    IPSEC_OFFLOAD_V2_OPERATION            Operation;        // AH - SA is used for AH, ESP - SA is used for ESP
    IPSEC_OFFLOAD_V2_SPI_TYPE             Spi;
    IPSEC_OFFLOAD_V2_ALGORITHM_INFO       AuthenticationAlgorithm;
    IPSEC_OFFLOAD_V2_ALGORITHM_INFO       EncryptionAlgorithm;
    ULONG                                 SequenceNumberHighOrder;
} IPSEC_OFFLOAD_V2_SECURITY_ASSOCIATION, *PIPSEC_OFFLOAD_V2_SECURITY_ASSOCIATION;

//
// used in IPSEC_OFFLOAD_V2_ADD_SA.Flags
//
#define IPSEC_OFFLOAD_V2_INBOUND          0x00000001
#define IPSEC_OFFLOAD_V2_IPv6             0x00000010

//
// used in OID_TCP_TASK_IPSEC_OFFLOAD_V2_ADD_SA
//
typedef struct _IPSEC_OFFLOAD_V2_ADD_SA IPSEC_OFFLOAD_V2_ADD_SA, *PIPSEC_OFFLOAD_V2_ADD_SA;

#define NDIS_IPSEC_OFFLOAD_V2_ADD_SA_REVISION_1      1

typedef struct _IPSEC_OFFLOAD_V2_ADD_SA
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_IPSEC_OFFLOAD_V2_ADD_SA_REVISION_1;
    // Header.Size = sizeof(IPSEC_OFFLOAD_V2_ADD_SA);
    // 
    NDIS_OBJECT_HEADER            Header;
    PIPSEC_OFFLOAD_V2_ADD_SA      Next;
    ULONG                         NumExtHdrs;   
    ULONG                         Flags;

    union
    {
        struct
        {
            IPAddr SrcAddr;
            IPAddr DestAddr;
        } IPv4Endpoints;

        struct
        {
            UCHAR SrcAddr[16];
            UCHAR DestAddr[16];
        } IPv6Endpoints;
    };
  
    NDIS_HANDLE                   OffloadHandle;
    ULONG                         UdpEspEncapsulation;
    IPSEC_OFFLOAD_V2_SECURITY_ASSOCIATION SecAssoc[IPSEC_OFFLOAD_V2_MAX_EXTENSION_HEADERS];
    ULONG                         KeyLength;
    UCHAR                         KeyData[1];
} IPSEC_OFFLOAD_V2_ADD_SA, *PIPSEC_OFFLOAD_V2_ADD_SA;

#define NDIS_SIZEOF_IPSEC_OFFLOAD_V2_ADD_SA_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(IPSEC_OFFLOAD_V2_ADD_SA, KeyData)

//
// used in OID_TCP_TASK_IPSEC_OFFLOAD_V2_DELETE_SA
//
typedef struct _IPSEC_OFFLOAD_V2_DELETE_SA IPSEC_OFFLOAD_V2_DELETE_SA, *PIPSEC_OFFLOAD_V2_DELETE_SA;

#define NDIS_IPSEC_OFFLOAD_V2_DELETE_SA_REVISION_1      1

typedef struct _IPSEC_OFFLOAD_V2_DELETE_SA
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_IPSEC_OFFLOAD_V2_DELETE_SA_REVISION_1;
    // Header.Size = sizeof(IPSEC_OFFLOAD_V2_DELETE_SA);
    // 
    NDIS_OBJECT_HEADER              Header;
    PIPSEC_OFFLOAD_V2_DELETE_SA     Next;
    NDIS_HANDLE                     OffloadHandle;
} IPSEC_OFFLOAD_V2_DELETE_SA, *PIPSEC_OFFLOAD_V2_DELETE_SA;

#define NDIS_SIZEOF_IPSEC_OFFLOAD_V2_DELETE_SA_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(IPSEC_OFFLOAD_V2_DELETE_SA, OffloadHandle)

//
// Structure and defines used in 
// OID_TCP_TASK_IPSEC_OFFLOAD_V2_UPDATE_SA
//

#define NDIS_IPSEC_OFFLOAD_V2_UPDATE_SA_REVISION_1      1

typedef struct _IPSEC_OFFLOAD_V2_UPDATE_SA
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_IPSEC_OFFLOAD_V2_UPDATE_SA_REVISION_1;
    // Header.Size = sizeof(IPSEC_OFFLOAD_V2_UPDATE_SA);
    // 
    NDIS_OBJECT_HEADER              Header;
    NDIS_HANDLE                     OffloadHandle;
    IPSEC_OFFLOAD_V2_OPERATION      Operation;
    IPSEC_OFFLOAD_V2_SPI_TYPE       Spi;
    ULONG                           SequenceNumberHighOrder;
} IPSEC_OFFLOAD_V2_UPDATE_SA, *PIPSEC_OFFLOAD_V2_UPDATE_SA;

#define NDIS_SIZEOF_IPSEC_OFFLOAD_V2_UPDATE_SA_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(IPSEC_OFFLOAD_V2_UPDATE_SA, SequenceNumberHighOrder)

#endif //  (NDIS_SUPPORT_NDIS61)

#endif // (NDIS_SUPPORT_NDIS6 || NDIS60)



#pragma once

#if NDIS_LEGACY_PROTOCOL

//
// Function types for NDIS_PROTOCOL_CHARACTERISTICS
//
 
typedef
VOID
(*OPEN_ADAPTER_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenErrorStatus
    );

typedef
VOID
(*CLOSE_ADAPTER_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*RESET_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );
 
typedef
VOID
(*REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*STATUS_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );
 
typedef
VOID
(*STATUS_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

typedef
VOID
(*SEND_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*WAN_SEND_COMPLETE_HANDLER) (
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_WAN_PACKET        Packet,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*TRANSFER_DATA_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    );

typedef
VOID
(*WAN_TRANSFER_DATA_COMPLETE_HANDLER)(
    VOID
    );

typedef
NDIS_STATUS
(*RECEIVE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookAheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

typedef
NDIS_STATUS
(*WAN_RECEIVE_HANDLER)(
    IN  NDIS_HANDLE             NdisLinkHandle,
    IN  PUCHAR                  Packet,
    IN  ULONG                   PacketSize
    );

typedef
VOID
(*RECEIVE_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

//
// Function types extensions for NDIS 4.0 Protocols
//
typedef
INT
(*RECEIVE_PACKET_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet
    );

typedef
VOID
(*BIND_HANDLER)(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    );

typedef
VOID
(*UNBIND_HANDLER)(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             UnbindContext
    );
 
typedef
NDIS_STATUS
(*PNP_EVENT_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_PNP_EVENT          NetPnPEvent
    );


typedef
VOID
(*UNLOAD_PROTOCOL_HANDLER)(
    VOID
    );

//
// Protocol characteristics for NDIS 4.0 protocols
//
typedef struct _NDIS40_PROTOCOL_CHARACTERISTICS
{
    UCHAR                           MajorNdisVersion;
    UCHAR                           MinorNdisVersion;
    USHORT                          Filler;
    union
    {
        UINT                        Reserved;
        UINT                        Flags;
    };
    OPEN_ADAPTER_COMPLETE_HANDLER   OpenAdapterCompleteHandler;
    CLOSE_ADAPTER_COMPLETE_HANDLER  CloseAdapterCompleteHandler;
    union
    {
        SEND_COMPLETE_HANDLER       SendCompleteHandler;
        WAN_SEND_COMPLETE_HANDLER   WanSendCompleteHandler;
    };
    union
    {
     TRANSFER_DATA_COMPLETE_HANDLER TransferDataCompleteHandler;
     WAN_TRANSFER_DATA_COMPLETE_HANDLER WanTransferDataCompleteHandler;
    };

    RESET_COMPLETE_HANDLER          ResetCompleteHandler;
    REQUEST_COMPLETE_HANDLER        RequestCompleteHandler;
    union
    {
        RECEIVE_HANDLER             ReceiveHandler;
        WAN_RECEIVE_HANDLER         WanReceiveHandler;
    };
    RECEIVE_COMPLETE_HANDLER        ReceiveCompleteHandler;
    STATUS_HANDLER                  StatusHandler;
    STATUS_COMPLETE_HANDLER         StatusCompleteHandler;
    NDIS_STRING                     Name;

    //
    // Start of NDIS 4.0 extensions.
    //
    RECEIVE_PACKET_HANDLER          ReceivePacketHandler;

    //
    // PnP protocol entry-points
    //
    BIND_HANDLER                    BindAdapterHandler;
    UNBIND_HANDLER                  UnbindAdapterHandler;
    PNP_EVENT_HANDLER               PnPEventHandler;
    UNLOAD_PROTOCOL_HANDLER         UnloadHandler;

} NDIS40_PROTOCOL_CHARACTERISTICS;

#endif

#if NDIS_LEGACY_DRIVER

//
// NDIS 5.0 co-NDIS Protocol handler proto-types - used by clients as well as call manager modules
//
typedef
VOID
(*CO_SEND_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

typedef
VOID
(*CO_STATUS_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

typedef
UINT
(*CO_RECEIVE_PACKET_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

typedef
NDIS_STATUS
(*CO_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

typedef
VOID
(*CO_REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    );

#endif // NDIS_LEGACY_DRIVER

#if (NDIS_SUPPORT_NDIS6 || defined(NDIS60))
typedef
NDIS_STATUS
(*CO_OID_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_OID_REQUEST    OidRequest
    );


typedef
VOID
(*CO_OID_REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolAfContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );
#endif // (NDIS_SUPPORT_NDIS6 || defined(NDIS60))

//
// CO_CREATE_VC_HANDLER and CO_DELETE_VC_HANDLER are synchronous calls
// the following APIs are used by NDIS 6 protocols as well as NDIS 5 protocols
//
typedef
NDIS_STATUS
(*CO_CREATE_VC_HANDLER)(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

typedef
NDIS_STATUS
(*CO_DELETE_VC_HANDLER)(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

typedef
VOID
(*CO_AF_REGISTER_NOTIFY_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    );

#if NDIS_LEGACY_PROTOCOL

typedef struct _NDIS50_PROTOCOL_CHARACTERISTICS
{
#ifdef __cplusplus
    NDIS40_PROTOCOL_CHARACTERISTICS Ndis40Chars;
#else
    NDIS40_PROTOCOL_CHARACTERISTICS;
#endif

    //
    // Placeholders for protocol extensions for PnP/PM etc.
    //
    PVOID                           ReservedHandlers[4];

    //
    // Start of NDIS 5.0 extensions.
    //

    CO_SEND_COMPLETE_HANDLER        CoSendCompleteHandler;
    CO_STATUS_HANDLER               CoStatusHandler;
    CO_RECEIVE_PACKET_HANDLER       CoReceivePacketHandler;
    CO_AF_REGISTER_NOTIFY_HANDLER   CoAfRegisterNotifyHandler;

} NDIS50_PROTOCOL_CHARACTERISTICS;

#endif // NDIS_LEGACY_PROTOCOL

#if (NDIS_SUPPORT_NDIS6 || defined(NDIS60))

//
// CONDIS 6.0 protocol's entry points
//

typedef
VOID
(*CO_RECEIVE_NET_BUFFER_LISTS_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  ULONG                   NumberOfNetBufferLists,
    IN  ULONG                   ReceiveFlags
    );

typedef
VOID
(*CO_SEND_NET_BUFFER_LISTS_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  ULONG                   SendCompleteFlags
    );

typedef
VOID
(*CO_STATUS_HANDLER_EX)(
    IN NDIS_HANDLE              ProtocolBindingContext,
    IN NDIS_HANDLE              ProtocolVcContext,
    IN PNDIS_STATUS_INDICATION  StatusIndication
    );
//
// CoNDIS 6 Client handler
//
typedef
NDIS_STATUS
(*CL_NOTIFY_CLOSE_AF_HANDLER)(
    IN NDIS_HANDLE            ClientAfContext
    );

typedef
VOID
(*CL_OPEN_AF_COMPLETE_HANDLER_EX)(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_STATUS             Status
    );

//
// CoNDIS 6 Call manager handler
//
typedef
VOID
(*CM_NOTIFY_CLOSE_AF_COMPLETE_HANDLER)(
    IN NDIS_HANDLE           CallMgrAfContext,
    IN NDIS_STATUS           Status 
    );

EXPORT
VOID
NdisDeregisterProtocolDriver(
    IN  NDIS_HANDLE             NdisProtocolHandle
    );


#endif // (NDIS_SUPPORT_NDIS6 || defined(NDIS60))


#if NDIS_LEGACY_PROTOCOL

EXPORT
VOID
NdisDeregisterProtocol(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisProtocolHandle
    );


EXPORT
VOID
NdisOpenAdapter(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PNDIS_HANDLE            NdisBindingHandle,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STRING            AdapterName,
    IN  UINT                    OpenOptions,
    IN  PSTRING                 AddressingInformation OPTIONAL
    );


EXPORT
VOID
NdisCloseAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle
    );


EXPORT
VOID
NdisCompleteBindAdapter(
    IN   NDIS_HANDLE            BindAdapterContext,
    IN   NDIS_STATUS            Status,
    IN   NDIS_STATUS            OpenStatus
    );

EXPORT
VOID
NdisCompleteUnbindAdapter(
    IN   NDIS_HANDLE            UnbindAdapterContext,
    IN   NDIS_STATUS            Status
    );

EXPORT
VOID
NdisSetProtocolFilter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  RECEIVE_HANDLER         ReceiveHandler,
    IN  RECEIVE_PACKET_HANDLER  ReceivePacketHandler,
    IN  NDIS_MEDIUM             Medium,
    IN  UINT                    Offset,
    IN  UINT                    Size,
    IN  PUCHAR                  Pattern
    );

EXPORT
VOID
NdisGetDriverHandle(
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisDriverHandle
    );

EXPORT
VOID
NdisOpenProtocolConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN  PNDIS_STRING            ProtocolSection
    );

#endif // NDIS_LEGACY_PROTOCOL

EXPORT
VOID
NdisReEnumerateProtocolBindings(
    IN  NDIS_HANDLE             NdisProtocolHandle
    );

EXPORT
NDIS_STATUS
NdisWriteEventLogEntry(
    IN  PVOID                   LogHandle,
    IN  NDIS_STATUS             EventCode,
    IN  ULONG                   UniqueEventValue,
    IN  USHORT                  NumStrings,
    IN  PVOID                   StringsList    OPTIONAL,
    IN  ULONG                   DataSize,
    IN  PVOID                   Data           OPTIONAL
    );

#if NDIS_LEGACY_PROTOCOL

//
//  The following routine is used by transports to complete pending
//  network PnP events.
//
EXPORT
VOID
NdisCompletePnPEvent(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PNET_PNP_EVENT  NetPnPEvent
    );

#endif // NDIS_LEGACY_PROTOCOL

#if (NDIS_SUPPORT_NDIS6 || defined(NDIS60))
EXPORT
VOID
NdisCompleteNetPnPEvent(
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification,
    IN  NDIS_STATUS     Status
    );
#endif //  (NDIS_SUPPORT_NDIS6 || defined(NDIS60))

//
//  The following routine is used by a transport to query the localized
//  friendly instance name of the adapter that they are bound to. There
//  are two variations of this, one uses the binding handle and the other
//  the binding context. Some transports need this before they bind - like
//  TCP/IP for instance.
//
EXPORT
NDIS_STATUS
NdisQueryAdapterInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     NdisBindingHandle
    );

EXPORT
NDIS_STATUS
NdisQueryBindInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     BindingContext
    );

//
// The following is used by TDI/NDIS interface as part of Network PnP.
// For use by TDI alone.
//
typedef
NTSTATUS
(*TDI_REGISTER_CALLBACK)(
    IN  PUNICODE_STRING         DeviceName,
    OUT HANDLE  *               TdiHandle
    );

typedef
NTSTATUS
(*TDI_PNP_HANDLER)(
    IN  PUNICODE_STRING         UpperComponent,
    IN  PUNICODE_STRING         LowerComponent,
    IN  PUNICODE_STRING         BindList,
    IN  PVOID                   ReconfigBuffer,
    IN  UINT                    ReconfigBufferSize,
    IN  UINT                    Operation
    );

EXPORT
VOID
NdisRegisterTdiCallBack(
    IN  TDI_REGISTER_CALLBACK   RegisterCallback,
    IN  TDI_PNP_HANDLER         PnPHandler
    );

EXPORT
VOID
NdisDeregisterTdiCallBack(
    VOID
    );

#if NDIS_LEGACY_PROTOCOL

VOID
NdisReset(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle
    );

VOID
NdisRequest(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    );

#ifdef __cplusplus

#define NdisSend(Status, NdisBindingHandle, Packet)                                     \
{                                                                                       \
    *(Status) =                                                                         \
        (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.SendHandler)(     \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.BindingHandle, \
        (Packet));                                                                      \
}

#define NdisSendPackets(NdisBindingHandle, PacketArray, NumberOfPackets)                \
{                                                                                       \
    (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.SendPacketsHandler)(  \
        (PNDIS_OPEN_BLOCK)(NdisBindingHandle),                                          \
        (PacketArray),                                                                  \
        (NumberOfPackets));                                                             \
}


#define NdisTransferData(Status,                                                        \
                         NdisBindingHandle,                                             \
                         MacReceiveContext,                                             \
                         ByteOffset,                                                    \
                         BytesToTransfer,                                               \
                         Packet,                                                        \
                         BytesTransferred)                                              \
{                                                                                       \
    *(Status) =                                                                         \
        (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.TransferDataHandler)( \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.BindingHandle, \
            (MacReceiveContext),                                                        \
            (ByteOffset),                                                               \
            (BytesToTransfer),                                                          \
            (Packet),                                                                   \
            (BytesTransferred));                                                        \
}

#else

#define NdisSend(Status, NdisBindingHandle, Packet)                         \
{                                                                           \
    *(Status) =                                                             \
        (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->SendHandler)(             \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->BindingHandle,         \
        (Packet));                                                          \
}


#define NdisSendPackets(NdisBindingHandle, PacketArray, NumberOfPackets)    \
{                                                                           \
    (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->SendPacketsHandler)(          \
        (PNDIS_OPEN_BLOCK)(NdisBindingHandle),                              \
        (PacketArray),                                                      \
        (NumberOfPackets));                                                 \
}

#define NdisTransferData(Status,                                            \
                         NdisBindingHandle,                                 \
                         MacReceiveContext,                                 \
                         ByteOffset,                                        \
                         BytesToTransfer,                                   \
                         Packet,                                            \
                         BytesTransferred)                                  \
{                                                                           \
    *(Status) =                                                             \
        (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->TransferDataHandler)(     \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->BindingHandle,         \
            (MacReceiveContext),                                            \
            (ByteOffset),                                                   \
            (BytesToTransfer),                                              \
            (Packet),                                                       \
            (BytesTransferred));                                            \
}

#endif // ifdef __cplusplus
#endif // NDIS_LEGACY_PROTOCOL

#if NDIS_LEGACY_PROTOCOL
//
// Routines to access packet flags
//

/*++

VOID
NdisSetSendFlags(
    IN  PNDIS_PACKET            Packet,
    IN  UINT                    Flags
    );

--*/

#define NdisSetSendFlags(_Packet,_Flags)    (_Packet)->Private.Flags = (_Flags)

/*++

VOID
NdisQuerySendFlags(
    IN  PNDIS_PACKET            Packet,
    OUT PUINT                   Flags
    );

--*/

#define NdisQuerySendFlags(_Packet,_Flags)  *(_Flags) = (_Packet)->Private.Flags

#endif // NDIS_LEGACY_PROTOCOL

#if NDIS_LEGACY_DRIVER
//
// The following is the minimum size of packets a miniport must allocate
// when it indicates packets via NdisMIndicatePacket or NdisMCoIndicatePacket
//
#define PROTOCOL_RESERVED_SIZE_IN_PACKET    (4 * sizeof(PVOID))
#endif // NDIS_LEGACY_DRIVER


#ifdef __cplusplus
#define WanMiniportSend(Status,                                                         \
                        NdisBindingHandle,                                              \
                        NdisLinkHandle,                                                 \
                        WanPacket)                                                      \
{                                                                                       \
    *(Status) =                                                                         \
        ((((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.WanSendHandler))( \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.BindingHandle, \
            (NdisLinkHandle),                                                           \
            (PNDIS_PACKET)(WanPacket));                                                 \
}

#else
#define WanMiniportSend(Status,                                             \
                        NdisBindingHandle,                                  \
                        NdisLinkHandle,                                     \
                        WanPacket)                                          \
{                                                                           \
    *(Status) =                                                             \
        ((((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->WanSendHandler))(        \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->BindingHandle,         \
            (NdisLinkHandle),                                               \
            (PNDIS_PACKET)(WanPacket));                                     \
}

#endif


#if NDIS_LEGACY_PROTOCOL

EXPORT
VOID
NdisReturnPackets(
    IN  PNDIS_PACKET    *       PacketsToReturn,
    IN  UINT                    NumberOfPackets
    );

EXPORT
PNDIS_PACKET
NdisGetReceivedPacket(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacContext
    );

#endif // NDIS_LEGACY_PROTOCOL

//
// Macros to portably manipulate NDIS buffers.
//

#define NdisBufferLength(Buffer)                            MmGetMdlByteCount(Buffer)
#define NdisBufferVirtualAddress(_Buffer)                   MmGetSystemAddressForMdl(_Buffer)
#define NdisBufferVirtualAddressSafe(_Buffer, _Priority)    MmGetSystemAddressForMdlSafe(_Buffer, _Priority)



#if NDIS_LEGACY_PROTOCOL

EXPORT
VOID
NdisCancelSendPackets(
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PVOID           CancelId
    );


EXPORT
NDIS_STATUS
NdisQueryPendingIOCount(
    IN      PVOID       NdisBindingHandle,
    IN OUT  PULONG      IoCount
    );

#endif // NDIS_LEGACY_PROTOCOL

EXPORT
UCHAR
NdisGeneratePartialCancelId(
    VOID
    );


#if (NDIS_SUPPORT_NDIS6 || defined(NDIS60))

//
// NDIS 6.0 protocol's entry points
//
typedef
VOID
(*OID_REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*RECEIVE_NET_BUFFER_LISTS_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  NDIS_PORT_NUMBER        PortNumber,
    IN  ULONG                   NumberOfNetBufferLists,
    IN  ULONG                   ReceiveFlags
    );

typedef
VOID
(*SEND_NET_BUFFER_LISTS_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_BUFFER_LIST        NetBufferList,
    IN  ULONG                   SendCompleteFlags
    );

#if (NDIS_SUPPORT_NDIS61)
//
// NDIS 6.1 protocol's entry points
//
typedef
VOID
(*DIRECT_OID_REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );
#endif // (NDIS_SUPPORT_NDIS61)    

//
// structure passed to protocol's BIND_HANDLER_EX
//
#define NDIS_BIND_PARAMETERS_REVISION_1     1

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_BIND_PARAMETERS_REVISION_2     2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_BIND_PARAMETERS
{
    NDIS_OBJECT_HEADER              Header;
    PNDIS_STRING                    ProtocolSection;
    PNDIS_STRING                    AdapterName;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    NDIS_MEDIUM                     MediaType;
    ULONG                           MtuSize;
    ULONG64                         MaxXmitLinkSpeed;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         MaxRcvLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    NDIS_MEDIA_DUPLEX_STATE         MediaDuplexState;
    ULONG                           LookaheadSize;
    PNDIS_PNP_CAPABILITIES          PowerManagementCapabilities;
    ULONG                           SupportedPacketFilters;
    ULONG                           MaxMulticastListSize;
    USHORT                          MacAddressLength;
    UCHAR                           CurrentMacAddress[NDIS_MAX_PHYS_ADDRESS_LENGTH];
    NDIS_PHYSICAL_MEDIUM            PhysicalMediumType;
    PNDIS_RECEIVE_SCALE_CAPABILITIES RcvScaleCapabilities;
    NET_LUID                        BoundIfNetluid;
    NET_IFINDEX                     BoundIfIndex;
    NET_LUID                        LowestIfNetluid;
    NET_IFINDEX                     LowestIfIndex;
    NET_IF_ACCESS_TYPE              AccessType; // NET_IF_ACCESS_BROADCAST for a typical ethernet adapter
    NET_IF_DIRECTION_TYPE           DirectionType; // NET_IF_DIRECTION_SENDRECEIVE for a typical ethernet adapter
    NET_IF_CONNECTION_TYPE          ConnectionType; // NET_IF_CONNECTION_DEDICATED for a typical ethernet adapter
    NET_IFTYPE                      IfType; // IF_TYPE_ETHERNET_CSMACD for a typical ethernet adapter (regardless of speed)
    BOOLEAN                         IfConnectorPresent; // RFC 2665 TRUE if physical adapter
    PNDIS_PORT                      ActivePorts; 
    ULONG                           DataBackFillSize;
    ULONG                           ContextBackFillSize;
    ULONG                           MacOptions;
    NET_IF_COMPARTMENT_ID           CompartmentId;
    PNDIS_OFFLOAD                   DefaultOffloadConfiguration;
    PNDIS_TCP_CONNECTION_OFFLOAD    TcpConnectionOffloadCapabilities;
    PNDIS_STRING                    BoundAdapterName;
#if (NDIS_SUPPORT_NDIS61)
    PNDIS_HD_SPLIT_CURRENT_CONFIG   HDSplitCurrentConfig;
#endif // (NDIS_SUPPORT_NDIS61)
}NDIS_BIND_PARAMETERS, *PNDIS_BIND_PARAMETERS;

#define NDIS_SIZEOF_BIND_PARAMETERS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_BIND_PARAMETERS, BoundAdapterName)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_BIND_PARAMETERS_REVISION_2     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_BIND_PARAMETERS, HDSplitCurrentConfig)
#endif // (NDIS_SUPPORT_NDIS61)
typedef
NDIS_STATUS
(*BIND_HANDLER_EX)(
    IN  NDIS_HANDLE             ProtocolDriverContext,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_BIND_PARAMETERS   BindParameters
    );

typedef
NDIS_STATUS
(*UNBIND_HANDLER_EX)(
    IN  NDIS_HANDLE             UnbindContext,
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

typedef
VOID
(*OPEN_ADAPTER_COMPLETE_HANDLER_EX)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*CLOSE_ADAPTER_COMPLETE_HANDLER_EX)(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );


typedef
VOID
(*STATUS_HANDLER_EX)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STATUS_INDICATION StatusIndication
    );

typedef
NDIS_STATUS
(*NET_PNP_EVENT_HANDLER)(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification
    );

typedef
VOID
(*UNINSTALL_PROTOCOL_HANDLER)(
    VOID
    );


#define NDIS_PROTOCOL_CO_CHARACTERISTICS_REVISION_1     1

typedef struct _NDIS_PROTOCOL_CO_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER                      Header;     // Header.Type = NDIS_OBJECT_TYPE_PROTOCOL_CO_CHARACTERISTICS
    ULONG                                   Flags;
    CO_STATUS_HANDLER_EX                    CoStatusHandlerEx;
    CO_AF_REGISTER_NOTIFY_HANDLER           CoAfRegisterNotifyHandler;
    CO_RECEIVE_NET_BUFFER_LISTS_HANDLER     CoReceiveNetBufferListsHandler;
    CO_SEND_NET_BUFFER_LISTS_COMPLETE_HANDLER CoSendNetBufferListsCompleteHandler;
} NDIS_PROTOCOL_CO_CHARACTERISTICS, *PNDIS_PROTOCOL_CO_CHARACTERISTICS;

#define NDIS_SIZEOF_PROTOCOL_CO_CHARACTERISTICS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PROTOCOL_CO_CHARACTERISTICS, CoSendNetBufferListsCompleteHandler)

#define NDIS_PROTOCOL_DRIVER_CHARACTERISTICS_REVISION_1     1
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_PROTOCOL_DRIVER_CHARACTERISTICS_REVISION_2     2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_PROTOCOL_DRIVER_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER                      Header;
    UCHAR                                   MajorNdisVersion;
    UCHAR                                   MinorNdisVersion;
    UCHAR                                   MajorDriverVersion;
    UCHAR                                   MinorDriverVersion;
    ULONG                                   Flags;
    NDIS_STRING                             Name;
    SET_OPTIONS_HANDLER                     SetOptionsHandler;
    BIND_HANDLER_EX                         BindAdapterHandlerEx;
    UNBIND_HANDLER_EX                       UnbindAdapterHandlerEx;
    OPEN_ADAPTER_COMPLETE_HANDLER_EX        OpenAdapterCompleteHandlerEx;
    CLOSE_ADAPTER_COMPLETE_HANDLER_EX       CloseAdapterCompleteHandlerEx;
    NET_PNP_EVENT_HANDLER                   NetPnPEventHandler;
    UNINSTALL_PROTOCOL_HANDLER              UninstallHandler;
    OID_REQUEST_COMPLETE_HANDLER            OidRequestCompleteHandler;
    STATUS_HANDLER_EX                       StatusHandlerEx;
    RECEIVE_NET_BUFFER_LISTS_HANDLER        ReceiveNetBufferListsHandler;
    SEND_NET_BUFFER_LISTS_COMPLETE_HANDLER  SendNetBufferListsCompleteHandler;
#if (NDIS_SUPPORT_NDIS61)
    DIRECT_OID_REQUEST_COMPLETE_HANDLER     DirectOidRequestCompleteHandler;
#endif // (NDIS_SUPPORT_NDIS61)
} NDIS_PROTOCOL_DRIVER_CHARACTERISTICS, *PNDIS_PROTOCOL_DRIVER_CHARACTERISTICS;

#define NDIS_SIZEOF_PROTOCOL_DRIVER_CHARACTERISTICS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PROTOCOL_DRIVER_CHARACTERISTICS, SendNetBufferListsCompleteHandler)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_PROTOCOL_DRIVER_CHARACTERISTICS_REVISION_2    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PROTOCOL_DRIVER_CHARACTERISTICS, DirectOidRequestCompleteHandler)
#endif // (NDIS_SUPPORT_NDIS61)       

#endif // (NDIS_SUPPORT_NDIS6 || defined(NDIS60))


#if NDIS_LEGACY_PROTOCOL

#if (defined(NDIS50) || defined(NDIS51))
typedef NDIS50_PROTOCOL_CHARACTERISTICS  NDIS_PROTOCOL_CHARACTERISTICS;
#else
typedef NDIS40_PROTOCOL_CHARACTERISTICS  NDIS_PROTOCOL_CHARACTERISTICS;
#endif


typedef NDIS_PROTOCOL_CHARACTERISTICS *PNDIS_PROTOCOL_CHARACTERISTICS;

EXPORT
VOID
NdisRegisterProtocol(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            NdisProtocolHandle,
    IN  PNDIS_PROTOCOL_CHARACTERISTICS ProtocolCharacteristics,
    IN  UINT                    CharacteristicsLength
    );

#endif // NDIS_LEGACY_PROTOCOL

#if (NDIS_SUPPORT_NDIS6 || defined(NDIS60))

EXPORT
NDIS_STATUS
NdisRegisterProtocolDriver(
    IN  NDIS_HANDLE             ProtocolDriverContext,
    IN  PNDIS_PROTOCOL_DRIVER_CHARACTERISTICS ProtocolCharacteristics,
    OUT PNDIS_HANDLE            NdisProtocolHandle
    );

EXPORT
VOID
NdisSendNetBufferLists(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  NDIS_PORT_NUMBER        PortNumber,
    IN  ULONG                   SendFlags
    );

EXPORT
VOID
NdisReturnNetBufferLists(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  ULONG                   ReturnFlags
    );

EXPORT
VOID
NdisCancelSendNetBufferLists(
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PVOID           CancelId
    );

EXPORT
NDIS_STATUS
NdisOidRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_OID_REQUEST       OidRequest
    );

EXPORT
VOID
NdisCancelOidRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PVOID                   RequestId
    );


EXPORT
NDIS_STATUS
NdisUnbindAdapter(
    IN  NDIS_HANDLE                     NdisBindingHandle
    );


//
// structure passed to NdisOpenAdapterEx
//

#define NDIS_OPEN_PARAMETERS_REVISION_1     1
typedef struct _NDIS_OPEN_PARAMETERS
{
    NDIS_OBJECT_HEADER          Header;
    PNDIS_STRING                AdapterName;
    PNDIS_MEDIUM                MediumArray;
    UINT                        MediumArraySize;
    PUINT                       SelectedMediumIndex;
    PNET_FRAME_TYPE             FrameTypeArray;
    UINT                        FrameTypeArraySize;
} NDIS_OPEN_PARAMETERS, *PNDIS_OPEN_PARAMETERS;

#define NDIS_SIZEOF_OPEN_PARAMETERS_REVSION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_OPEN_PARAMETERS, FrameTypeArraySize)

EXPORT
NDIS_STATUS
NdisOpenAdapterEx(
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_OPEN_PARAMETERS   OpenParameters,
    IN  NDIS_HANDLE             BindContext,
    OUT PNDIS_HANDLE            NdisBindingHandle
    );

EXPORT
VOID
NdisCompleteBindAdapterEx(
    IN  NDIS_HANDLE             BindAdapterContext,
    IN  NDIS_STATUS             Status
    );

EXPORT
NDIS_STATUS
NdisCloseAdapterEx(
    IN  NDIS_HANDLE             NdisBindingHandle
    );

EXPORT
VOID
NdisCompleteUnbindAdapterEx(
    IN  NDIS_HANDLE             UnbindContext
    );



#define NDIS_PROTOCOL_PAUSE_PARAMETERS_REVISION_1     1
    
typedef struct _NDIS_PROTOCOL_PAUSE_PARAMETERS
{
    NDIS_OBJECT_HEADER          Header;
    ULONG                       Flags;
    ULONG                       PauseReason;
} NDIS_PROTOCOL_PAUSE_PARAMETERS, *PNDIS_PROTOCOL_PAUSE_PARAMETERS;

#define NDIS_SIZEOF_PROTOCOL_PAUSE_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PROTOCOL_PAUSE_PARAMETERS, Flags)


#define NDIS_PROTOCOL_RESTART_PARAMETERS_REVISION_1     1

typedef struct _NDIS_PROTOCOL_RESTART_PARAMETERS
{
    NDIS_OBJECT_HEADER          Header;
    PUCHAR                      FilterModuleNameBuffer;
    ULONG                       FilterModuleNameBufferLength;
    PNDIS_RESTART_ATTRIBUTES    RestartAttributes;
    NET_IFINDEX                 BoundIfIndex;  
    NET_LUID                    BoundIfNetluid;    
    ULONG                       Flags;
} NDIS_PROTOCOL_RESTART_PARAMETERS, *PNDIS_PROTOCOL_RESTART_PARAMETERS;

#define NDIS_SIZEOF_PROTOCOL_RESTART_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PROTOCOL_RESTART_PARAMETERS, Flags)

#if (NDIS_SUPPORT_NDIS61)
EXPORT
NDIS_STATUS
NdisDirectOidRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_OID_REQUEST       OidRequest
    );

EXPORT
VOID
NdisCancelDirectOidRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PVOID                   RequestId
    );    
#endif // (NDIS_SUPPORT_NDIS61)        

#endif // (NDIS_SUPPORT_NDIS6 || defined(NDIS60))


//
// needed for macros used by legacy protocols
//
#if !defined(NDIS_WRAPPER)
#if NDIS_LEGACY_PROTOCOL
    typedef struct _NDIS_COMMON_OPEN_BLOCK
    {
        PVOID                       MacHandle;          // needed for backward compatibility
     
        NDIS_HANDLE                 BindingHandle;
        NDIS_HANDLE                 Reserved6;
        NDIS_HANDLE                 Reserved7;
        NDIS_HANDLE                 Reserved8;
    
        PVOID                       Reserved9;
        NDIS_HANDLE                 Reserved10;
    
        NDIS_HANDLE                 Reserved11;
        BOOLEAN                     Reserved12;
        BOOLEAN                     Reserved2;
        BOOLEAN                     Reserved3;
        BOOLEAN                     Reserved4;
        PVOID                       Reserved13;
        KSPIN_LOCK                  Reserved5;
        NDIS_HANDLE                 Reserved14;
    
        //
        // These are referenced by the macros used by protocols to call.
        // All of the ones referenced by the macros are internal NDIS handlers for the miniports
        //
        union
        {
            SEND_HANDLER            SendHandler;
            WAN_SEND_HANDLER        WanSendHandler;
        };
        TRANSFER_DATA_HANDLER       TransferDataHandler;
    
        //
        // These are referenced internally by NDIS
        //
        SEND_COMPLETE_HANDLER       SendCompleteHandler;
        TRANSFER_DATA_COMPLETE_HANDLER TransferDataCompleteHandler;
        RECEIVE_HANDLER             ReceiveHandler;
        RECEIVE_COMPLETE_HANDLER    ReceiveCompleteHandler;
        WAN_RECEIVE_HANDLER         WanReceiveHandler;
        REQUEST_COMPLETE_HANDLER    RequestCompleteHandler;
    
        //
        // NDIS 4.0 extensions
        //
        RECEIVE_PACKET_HANDLER      ReceivePacketHandler;
        SEND_PACKETS_HANDLER        SendPacketsHandler;
    
        //
        // More Cached Handlers
        //
        RESET_HANDLER               ResetHandler;
        REQUEST_HANDLER             RequestHandler;
        RESET_COMPLETE_HANDLER      ResetCompleteHandler;
        STATUS_HANDLER              StatusHandler;
        STATUS_COMPLETE_HANDLER     StatusCompleteHandler;
    
    }NDIS_COMMON_OPEN_BLOCK, *PNDIS_COMMON_OPEN_BLOCK;
    //
    // one of these per open on an adapter/protocol
    //
    struct _NDIS_OPEN_BLOCK
    {
#ifdef __cplusplus
        NDIS_COMMON_OPEN_BLOCK NdisCommonOpenBlock;
#else
        NDIS_COMMON_OPEN_BLOCK;
#endif
    
    };

#endif // NDIS_LEGACY_PROTOCOL
#endif // NDIS_WRAPPER




#pragma once

#include <xfilter.h>

#define NDIS_M_MAX_LOOKAHEAD 526


#if NDIS_LEGACY_MINIPORT

//
// Function types for NDIS_MINIPORT_CHARACTERISTICS
//


typedef
BOOLEAN
(*W_CHECK_FOR_HANG_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
VOID
(*W_DISABLE_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
VOID
(*W_ENABLE_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
VOID
(*W_HALT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
VOID
(*W_HANDLE_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
NDIS_STATUS
(*W_INITIALIZE_HANDLER)(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    );

typedef
VOID
(*W_ISR_HANDLER)(
    OUT PBOOLEAN                InterruptRecognized,
    OUT PBOOLEAN                QueueMiniportHandleInterrupt,
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
NDIS_STATUS
(*W_QUERY_INFORMATION_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

typedef
NDIS_STATUS
(*W_RECONFIGURE_HANDLER)(
    OUT PNDIS_STATUS            OpenErrorStatus,
    IN  NDIS_HANDLE             MiniportAdapterContext  OPTIONAL,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    );

typedef
NDIS_STATUS
(*W_RESET_HANDLER)(
    OUT PBOOLEAN                AddressingReset,
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
NDIS_STATUS
(*W_SEND_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            Packet,
    IN  UINT                    Flags
    );

typedef
NDIS_STATUS
(*WM_SEND_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             NdisLinkHandle,
    IN  PNDIS_WAN_PACKET        Packet
    );

typedef
NDIS_STATUS
(*W_SET_INFORMATION_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

typedef
NDIS_STATUS
(*W_TRANSFER_DATA_HANDLER)(
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer
    );

typedef
NDIS_STATUS
(*WM_TRANSFER_DATA_HANDLER)(
    VOID
    );

//
// Definition for shutdown handler
//

typedef
VOID
(*ADAPTER_SHUTDOWN_HANDLER) (
    IN  PVOID ShutdownContext
    );

//
// Miniport extensions for NDIS 4.0
//
typedef
VOID
(*W_RETURN_PACKET_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            Packet
    );

//
// NDIS 4.0 extension
//
typedef
VOID
(*W_SEND_PACKETS_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

typedef
VOID
(*W_ALLOCATE_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PVOID                   VirtualAddress,
    IN  PNDIS_PHYSICAL_ADDRESS  PhysicalAddress,
    IN  ULONG                   Length,
    IN  PVOID                   Context
    );

#endif // NDIS_LEGACY_MINIPORT


//
// W_CO_CREATE_VC_HANDLER is a synchronous call
//
typedef
NDIS_STATUS
(*W_CO_CREATE_VC_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            MiniportVcContext
    );

typedef
NDIS_STATUS
(*W_CO_DELETE_VC_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext
    );

typedef
NDIS_STATUS
(*W_CO_ACTIVATE_VC_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );

typedef
NDIS_STATUS
(*W_CO_DEACTIVATE_VC_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext
    );

#if NDIS_LEGACY_MINIPORT

typedef
VOID
(*W_CO_SEND_PACKETS_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

typedef
NDIS_STATUS
(*W_CO_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportVcContext   OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

#endif // NDIS_LEGACY_MINIPORT


#if NDIS_SUPPORT_NDIS6

//
// CONDIS 6.0 handlers
//

typedef
VOID
(*W_CO_SEND_NET_BUFFER_LISTS_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  ULONG                   SendFlags
    );


typedef 
NDIS_STATUS
(*W_CO_OID_REQUEST_HANDLER)(
    IN NDIS_HANDLE           MiniportAdapterContext,
    IN NDIS_HANDLE           MiniportVcContext OPTIONAL,
    IN OUT PNDIS_OID_REQUEST NdisRequest
    );

#endif // NDIS_SUPPORT_NDIS6

typedef enum _NDIS_DEVICE_PNP_EVENT
{
    NdisDevicePnPEventQueryRemoved,
    NdisDevicePnPEventRemoved,
    NdisDevicePnPEventSurpriseRemoved,
    NdisDevicePnPEventQueryStopped,
    NdisDevicePnPEventStopped,
    NdisDevicePnPEventPowerProfileChanged,
#if NDIS_SUPPORT_NDIS6
    NdisDevicePnPEventFilterListChanged,
#endif // NDIS_SUPPORT_NDIS6
    NdisDevicePnPEventMaximum
} NDIS_DEVICE_PNP_EVENT, *PNDIS_DEVICE_PNP_EVENT;

//
// power profiles
//
typedef enum _NDIS_POWER_PROFILE
{
    NdisPowerProfileBattery,
    NdisPowerProfileAcOnLine
} NDIS_POWER_PROFILE, *PNDIS_POWER_PROFILE;

#if NDIS_LEGACY_MINIPORT

typedef struct _NDIS50_MINIPORT_CHARACTERISTICS
{   
    UCHAR                       MajorNdisVersion;
    UCHAR                       MinorNdisVersion;
    USHORT                      Filler;
    UINT                        Reserved;
    W_CHECK_FOR_HANG_HANDLER    CheckForHangHandler;
    W_DISABLE_INTERRUPT_HANDLER DisableInterruptHandler;
    W_ENABLE_INTERRUPT_HANDLER  EnableInterruptHandler;
    W_HALT_HANDLER              HaltHandler;
    W_HANDLE_INTERRUPT_HANDLER  HandleInterruptHandler;
    W_INITIALIZE_HANDLER        InitializeHandler;
    W_ISR_HANDLER               ISRHandler;
    W_QUERY_INFORMATION_HANDLER QueryInformationHandler;
    W_RECONFIGURE_HANDLER       ReconfigureHandler;
    W_RESET_HANDLER             ResetHandler;
    union
    {
        W_SEND_HANDLER          SendHandler;
        WM_SEND_HANDLER         WanSendHandler;
    };
    W_SET_INFORMATION_HANDLER   SetInformationHandler;
    union
    {
        W_TRANSFER_DATA_HANDLER TransferDataHandler;
        WM_TRANSFER_DATA_HANDLER WanTransferDataHandler;
    };

    //
    // Extensions for NDIS 4.0
    //
    W_RETURN_PACKET_HANDLER     ReturnPacketHandler;
    W_SEND_PACKETS_HANDLER      SendPacketsHandler;
    W_ALLOCATE_COMPLETE_HANDLER AllocateCompleteHandler;
    
    //
    // Extensions for NDIS 5.0
    //
    W_CO_CREATE_VC_HANDLER      CoCreateVcHandler;
    W_CO_DELETE_VC_HANDLER      CoDeleteVcHandler;
    W_CO_ACTIVATE_VC_HANDLER    CoActivateVcHandler;
    W_CO_DEACTIVATE_VC_HANDLER  CoDeactivateVcHandler;
    W_CO_SEND_PACKETS_HANDLER   CoSendPacketsHandler;
    W_CO_REQUEST_HANDLER        CoRequestHandler;
} NDIS50_MINIPORT_CHARACTERISTICS;

#if (((NDIS_MINIPORT_MAJOR_VERSION == 5) &&  (NDIS_MINIPORT_MINOR_VERSION == 1)) || NDIS_WRAPPER)
//
// Miniport extensions for NDIS 5.1
//
typedef VOID
(*W_CANCEL_SEND_PACKETS_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PVOID                   CancelId
    );

typedef VOID
(*W_PNP_EVENT_NOTIFY_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   DevicePnPEvent,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength
    );

typedef VOID
(*W_MINIPORT_SHUTDOWN_HANDLER) (
    IN  NDIS_HANDLE                     MiniportAdapterContext
    );

#endif // (((NDIS_MINIPORT_MAJOR_VERSION == 5) &&  (NDIS_MINIPORT_MINOR_VERSION == 1)) || NDIS_WRAPPER)

#endif // NDIS_LEGACY_MINIPORT

#if NDIS_SUPPORT_NDIS6
typedef
BOOLEAN
(*MINIPORT_ISR_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext,
    OUT PBOOLEAN                QueueDefaultInterruptDpc,
    OUT PULONG                  TargetProcessors
    );

typedef
VOID
(*MINIPORT_INTERRUPT_DPC_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext,
    IN  PVOID                   MiniportDpcContext,
    IN  PVOID                   NdisReserved1,
    IN  PVOID                   NdisReserved2
    );

typedef
VOID
(*MINIPORT_DISABLE_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext
    );

typedef
VOID
(*MINIPORT_ENABLE_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext
    );

//
// MSI support handlers
//
typedef
BOOLEAN
(*MINIPORT_MSI_ISR_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext,
    IN  ULONG                   MessageId,
    OUT PBOOLEAN                QueueDefaultInterruptDpc,
    OUT PULONG                  TargetProcessors
    );

typedef
VOID
(*MINIPORT_MSI_INTERRUPT_DPC_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext,
    IN  ULONG                   MessageId,
    IN  PVOID                   MiniportDpcContext,
    IN  PULONG                  NdisReserved1,
    IN  PULONG                  NdisReserved2
    );


typedef
VOID
(*MINIPORT_DISABLE_MSI_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext,
    IN  ULONG                   MessageId
    );

typedef
VOID
(*MINIPORT_ENABLE_MSI_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext,
    IN  ULONG                   MessageId
    );

typedef enum _NDIS_INTERRUPT_TYPE
{
    NDIS_CONNECT_LINE_BASED = 1,
    NDIS_CONNECT_MESSAGE_BASED
} NDIS_INTERRUPT_TYPE, *PNDIS_INTERRUPT_TYPE;
    
#define NDIS_MINIPORT_INTERRUPT_REVISION_1          1

typedef struct _NDIS_MINIPORT_INTERRUPT_CHARACTERISTICS
{
    IN NDIS_OBJECT_HEADER                      Header;
    IN MINIPORT_ISR_HANDLER                    InterruptHandler;
    IN MINIPORT_INTERRUPT_DPC_HANDLER          InterruptDpcHandler;
    IN MINIPORT_DISABLE_INTERRUPT_HANDLER      DisableInterruptHandler;
    IN MINIPORT_ENABLE_INTERRUPT_HANDLER       EnableInterruptHandler;
    IN BOOLEAN                                 MsiSupported;
    IN BOOLEAN                                 MsiSyncWithAllMessages;
    IN MINIPORT_MSI_ISR_HANDLER                MessageInterruptHandler;
    IN MINIPORT_MSI_INTERRUPT_DPC_HANDLER      MessageInterruptDpcHandler;
    IN MINIPORT_DISABLE_MSI_INTERRUPT_HANDLER  DisableMessageInterruptHandler;
    IN MINIPORT_ENABLE_MSI_INTERRUPT_HANDLER   EnableMessageInterruptHandler;
    OUT NDIS_INTERRUPT_TYPE                    InterruptType;
    OUT PIO_INTERRUPT_MESSAGE_INFO             MessageInfoTable;
} NDIS_MINIPORT_INTERRUPT_CHARACTERISTICS, *PNDIS_MINIPORT_INTERRUPT_CHARACTERISTICS;

#define NDIS_SIZEOF_MINIPORT_INTERRUPT_CHARACTERISTICS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_INTERRUPT_CHARACTERISTICS, MessageInfoTable)

typedef
NDIS_STATUS
(*MINIPORT_ADD_DEVICE_HANDLER)(
    IN NDIS_HANDLE              NdisMiniportHandle,
    IN NDIS_HANDLE              MiniportDriverContext
    );

typedef
VOID
(*MINIPORT_REMOVE_DEVICE_HANDLER)(
    IN NDIS_HANDLE              MiniportAddDeviceContext
    );

typedef
NDIS_STATUS
(*MINIPORT_PNP_IRP_HANDLER)(
    IN NDIS_HANDLE              MiniportAddDeviceContext,
    IN PIRP                     Irp
    );


#define NDIS_MINIPORT_PNP_CHARACTERISTICS_REVISION_1       1

typedef struct _NDIS_MINIPORT_PNP_CHARACTERISTICS
{
     NDIS_OBJECT_HEADER                       Header;
     MINIPORT_ADD_DEVICE_HANDLER              MiniportAddDeviceHandler;
     MINIPORT_REMOVE_DEVICE_HANDLER           MiniportRemoveDeviceHandler;
     MINIPORT_PNP_IRP_HANDLER                 MiniportFilterResourceRequirementsHandler;
     MINIPORT_PNP_IRP_HANDLER                 MiniportStartDeviceHandler;
     ULONG                                    Flags;
     
} NDIS_MINIPORT_PNP_CHARACTERISTICS, *PNDIS_MINIPORT_PNP_CHARACTERISTICS;

#define NDIS_SIZEOF_MINIPORT_PNP_CHARACTERISTICS_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_PNP_CHARACTERISTICS, Flags)

EXPORT
NDIS_STATUS
NdisMRegisterInterruptEx(
    IN  NDIS_HANDLE                                 MiniportAdapterHandle,
    IN  NDIS_HANDLE                                 MiniportInterruptContext,
    IN  PNDIS_MINIPORT_INTERRUPT_CHARACTERISTICS    MiniportInterruptCharacteristics,
    OUT PNDIS_HANDLE                                NdisInterruptHandle
    );

EXPORT
VOID
NdisMDeregisterInterruptEx(
    IN  NDIS_HANDLE                     NdisInterruptHandle
    );

EXPORT
BOOLEAN
NdisMSynchronizeWithInterruptEx(
    IN NDIS_HANDLE                      NdisInterruptHandle,
    IN ULONG                            MessageId,
    IN PVOID                            SynchronizeFunction,
    IN PVOID                            SynchronizeContext
    );

EXPORT
ULONG
NdisMQueueDpc(
    IN  NDIS_HANDLE     NdisInterruptHandle,
    IN  ULONG           MessageId,
    IN  ULONG           TargetProcessors,
    IN  PVOID           MiniportDpcContext
    );

#endif //  NDIS_SUPPORT_NDIS6

#if NDIS_LEGACY_MINIPORT
#if (((NDIS_MINIPORT_MAJOR_VERSION == 5) &&  (NDIS_MINIPORT_MINOR_VERSION == 1)) || NDIS_WRAPPER)
typedef struct _NDIS51_MINIPORT_CHARACTERISTICS
{
#ifdef __cplusplus
    NDIS50_MINIPORT_CHARACTERISTICS Ndis50Chars;
#else
    NDIS50_MINIPORT_CHARACTERISTICS;
#endif
    //
    // Extensions for NDIS 5.1
    //
    W_CANCEL_SEND_PACKETS_HANDLER   CancelSendPacketsHandler;
    W_PNP_EVENT_NOTIFY_HANDLER      PnPEventNotifyHandler;
    W_MINIPORT_SHUTDOWN_HANDLER     AdapterShutdownHandler;
    PVOID                           Reserved1;
    PVOID                           Reserved2;
    PVOID                           Reserved3;
    PVOID                           Reserved4;
} NDIS51_MINIPORT_CHARACTERISTICS;
#endif // (((NDIS_MINIPORT_MAJOR_VERSION == 5) &&  (NDIS_MINIPORT_MINOR_VERSION == 1)) || NDIS_WRAPPER)

typedef struct _NDIS_MINIPORT_INTERRUPT
{
    PKINTERRUPT                 InterruptObject;
    KSPIN_LOCK                  DpcCountLock;
    PVOID                       Reserved;
    W_ISR_HANDLER               MiniportIsr;
    W_HANDLE_INTERRUPT_HANDLER  MiniportDpc;
    KDPC                        InterruptDpc;
    PNDIS_MINIPORT_BLOCK        Miniport;

    UCHAR                       DpcCount;
    BOOLEAN                     Filler1;

    //
    // This is used to tell when all the Dpcs for the adapter are completed.
    //

    KEVENT                      DpcsCompletedEvent;

    BOOLEAN                     SharedInterrupt;
    BOOLEAN                     IsrRequested;

} NDIS_MINIPORT_INTERRUPT, *PNDIS_MINIPORT_INTERRUPT;
#endif // NDIS_LEGACY_MINIPORT

typedef struct _NDIS_MINIPORT_TIMER
{
    KTIMER                      Timer;
    KDPC                        Dpc;
    PNDIS_TIMER_FUNCTION        MiniportTimerFunction;
    PVOID                       MiniportTimerContext;
    PNDIS_MINIPORT_BLOCK        Miniport;
    struct _NDIS_MINIPORT_TIMER *NextTimer;
} NDIS_MINIPORT_TIMER, *PNDIS_MINIPORT_TIMER;

#if NDIS_LEGACY_MINIPORT
typedef
VOID
(*ETH_RCV_INDICATE_HANDLER)(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

typedef
VOID
(*ETH_RCV_COMPLETE_HANDLER)(
    IN  PETH_FILTER             Filter
    );

typedef
VOID
(*TR_RCV_INDICATE_HANDLER)(
    IN  PTR_FILTER              Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

typedef
VOID
(*TR_RCV_COMPLETE_HANDLER)(
    IN  PTR_FILTER              Filter
    );

typedef
VOID
(*WAN_RCV_HANDLER)(
    OUT PNDIS_STATUS            Status,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              NdisLinkContext,
    IN PUCHAR                   Packet,
    IN ULONG                    PacketSize
    );

typedef
VOID
(*WAN_RCV_COMPLETE_HANDLER)(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              NdisLinkContext
    );

typedef
VOID
(*NDIS_M_SEND_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*NDIS_WM_SEND_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PVOID                   Packet,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*NDIS_M_TD_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    );

typedef
VOID
(*NDIS_M_SEND_RESOURCES_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    );

typedef
VOID
(*NDIS_M_STATUS_HANDLER)(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

typedef
VOID
(*NDIS_M_STS_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    );

typedef
VOID
(*NDIS_M_REQ_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*NDIS_M_RESET_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status,
    IN  BOOLEAN                 AddressingReset
    );

typedef
BOOLEAN
(FASTCALL *NDIS_M_START_SENDS)(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    );

//
// Wrapper initialization and termination.
//

EXPORT
VOID
NdisInitializeWrapper(
    OUT PNDIS_HANDLE            NdisWrapperHandle,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

EXPORT
VOID
NdisTerminateWrapper(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PVOID                   SystemSpecific
    );

#endif // NDIS_LEGACY_MINIPORT

#if NDIS_SUPPORT_NDIS6

typedef
VOID
(*MINIPORT_PROCESS_SG_LIST_HANDLER)(
    IN  PDEVICE_OBJECT          pDO,
    IN  PVOID                   Reserved,
    IN  PSCATTER_GATHER_LIST    pSGL,
    IN  PVOID                   Context
    );

//
// NDIS DMA description structure
//

typedef
VOID
(*MINIPORT_ALLOCATE_SHARED_MEM_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PVOID                   VirtualAddress,
    IN  PNDIS_PHYSICAL_ADDRESS  PhysicalAddress,
    IN  ULONG                   Length,
    IN  PVOID                   Context
    );

/*
NDIS_STATUS
NdisMAllocateSharedMemoryAsyncEx(
    IN  NDIS_HANDLE             MiniportDmaHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   Context
    );
*/
#define NdisMAllocateSharedMemoryAsyncEx(_H, _L, _C, _X) NdisMAllocateSharedMemoryAsync(_H, _L, _C, _X)
#endif // NDIS_SUPPORT_NDIS6



EXPORT
NDIS_STATUS
NdisMAllocateSharedMemoryAsync(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   Context
    );

//
// defintions for slave DMA
//

//
// DMA Channel information
//
typedef struct _NDIS_DMA_DESCRIPTION
{
    BOOLEAN     DemandMode;
    BOOLEAN     AutoInitialize;
    BOOLEAN     DmaChannelSpecified;
    DMA_WIDTH   DmaWidth;
    DMA_SPEED   DmaSpeed;
    ULONG       DmaPort;
    ULONG       DmaChannel;
} NDIS_DMA_DESCRIPTION, *PNDIS_DMA_DESCRIPTION;

//
// Internal structure representing an NDIS DMA channel
//
typedef struct _NDIS_DMA_BLOCK
{
    PVOID                   MapRegisterBase;
    KEVENT                  AllocationEvent;
    PVOID                   SystemAdapterObject;
    PVOID                   Miniport;
    BOOLEAN                 InProgress;
} NDIS_DMA_BLOCK, *PNDIS_DMA_BLOCK;


EXPORT
VOID
NdisSetupDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    );

EXPORT
VOID
NdisCompleteDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    );

EXPORT
NDIS_STATUS
NdisMRegisterDmaChannel(
    OUT PNDIS_HANDLE            MiniportDmaHandle,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    DmaChannel,
    IN  BOOLEAN                 Dma32BitAddresses,
    IN  PNDIS_DMA_DESCRIPTION   DmaDescription,
    IN  ULONG                   MaximumLength
    );


EXPORT
VOID
NdisMDeregisterDmaChannel(
    IN  NDIS_HANDLE             MiniportDmaHandle
    );

/*++
VOID
NdisMSetupDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             MiniportDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    )
--*/
#define NdisMSetupDmaTransfer(_S, _H, _B, _O, _L, _M_) \
        NdisSetupDmaTransfer(_S, _H, _B, _O, _L, _M_)

/*++
VOID
NdisMCompleteDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             MiniportDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    )
--*/
#define NdisMCompleteDmaTransfer(_S, _H, _B, _O, _L, _M_) \
        NdisCompleteDmaTransfer(_S, _H, _B, _O, _L, _M_)

EXPORT
ULONG
NdisMReadDmaCounter(
    IN  NDIS_HANDLE             MiniportDmaHandle
    );


//
// This API has been deprecated
//
DECLSPEC_DEPRECATED_DDK
EXPORT
VOID
NdisUpdateSharedMemory(
    IN  NDIS_HANDLE                     NdisAdapterHandle,
    IN  ULONG                           Length,
    IN  PVOID                           VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS           PhysicalAddress
    );


#if NDIS_SUPPORT_NDIS6


//
// Flags used in NDIS_SG_DMA_DESCRIPTION
//

#define NDIS_SG_DMA_64_BIT_ADDRESS      0x00000001

//
// supported revision
//
#define NDIS_SG_DMA_DESCRIPTION_REVISION_1      1

typedef struct _NDIS_SG_DMA_DESCRIPTION
{
    NDIS_OBJECT_HEADER                              Header;
    ULONG                                           Flags;
    ULONG                                           MaximumPhysicalMapping;
    MINIPORT_PROCESS_SG_LIST_HANDLER                ProcessSGListHandler;
    MINIPORT_ALLOCATE_SHARED_MEM_COMPLETE_HANDLER   SharedMemAllocateCompleteHandler;
    ULONG                                           ScatterGatherListSize;
} NDIS_SG_DMA_DESCRIPTION, *PNDIS_SG_DMA_DESCRIPTION;

#define NDIS_SIZEOF_SG_DMA_DESCRIPTION_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_SG_DMA_DESCRIPTION, ScatterGatherListSize)

#define NDIS_MINIPORT_INIT_PARAMETERS_REVISION_1     1

typedef struct _NDIS_MINIPORT_INIT_PARAMETERS
{
    IN  NDIS_OBJECT_HEADER              Header;
    IN  ULONG                           Flags;
    IN  PNDIS_RESOURCE_LIST             AllocatedResources;
    IN  NDIS_HANDLE                     IMDeviceInstanceContext;
    IN  NDIS_HANDLE                     MiniportAddDeviceContext;
    IN  NET_IFINDEX                     IfIndex;
    IN  NET_LUID                        NetLuid;
    IN  PNDIS_PORT_AUTHENTICATION_PARAMETERS   DefaultPortAuthStates;
    IN  PNDIS_PCI_DEVICE_CUSTOM_PROPERTIES PciDeviceCustomProperties;
} NDIS_MINIPORT_INIT_PARAMETERS, *PNDIS_MINIPORT_INIT_PARAMETERS;

#define NDIS_SIZEOF_MINIPORT_INIT_PARAMETER_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_INIT_PARAMETERS, PciDeviceCustomProperties)

#define NDIS_MINIPORT_RESTART_PARAMETERS_REVISION_1     1

typedef struct _NDIS_MINIPORT_RESTART_PARAMETERS
{
    NDIS_OBJECT_HEADER          Header;
    PNDIS_RESTART_ATTRIBUTES    RestartAttributes;
    ULONG                       Flags;
} NDIS_MINIPORT_RESTART_PARAMETERS, *PNDIS_MINIPORT_RESTART_PARAMETERS;

#define NDIS_SIZEOF_MINIPORT_RESTART_PARAMETERS_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_RESTART_PARAMETERS, Flags)

#define NDIS_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES_REVISION_1     1

typedef struct _NDIS_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_HANDLE                     MiniportAdapterContext;
    ULONG                           AttributeFlags;
    UINT                            CheckForHangTimeInSeconds;
    NDIS_INTERFACE_TYPE             InterfaceType;
} NDIS_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES, *PNDIS_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES;

#define NDIS_SIZEOF_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES, InterfaceType)

//
// flags used in NDIS_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES->SupportedStatistics
//

#define NDIS_STATISTICS_XMIT_OK_SUPPORTED                       0x00000001
#define NDIS_STATISTICS_RCV_OK_SUPPORTED                        0x00000002 
#define NDIS_STATISTICS_XMIT_ERROR_SUPPORTED                    0x00000004 
#define NDIS_STATISTICS_RCV_ERROR_SUPPORTED                     0x00000008 
#define NDIS_STATISTICS_RCV_NO_BUFFER_SUPPORTED                 0x00000010 
#define NDIS_STATISTICS_DIRECTED_BYTES_XMIT_SUPPORTED           0x00000020 
#define NDIS_STATISTICS_DIRECTED_FRAMES_XMIT_SUPPORTED          0x00000040 
#define NDIS_STATISTICS_MULTICAST_BYTES_XMIT_SUPPORTED          0x00000080 
#define NDIS_STATISTICS_MULTICAST_FRAMES_XMIT_SUPPORTED         0x00000100 
#define NDIS_STATISTICS_BROADCAST_BYTES_XMIT_SUPPORTED          0x00000200 
#define NDIS_STATISTICS_BROADCAST_FRAMES_XMIT_SUPPORTED         0x00000400 
#define NDIS_STATISTICS_DIRECTED_BYTES_RCV_SUPPORTED            0x00000800 
#define NDIS_STATISTICS_DIRECTED_FRAMES_RCV_SUPPORTED           0x00001000 
#define NDIS_STATISTICS_MULTICAST_BYTES_RCV_SUPPORTED           0x00002000 
#define NDIS_STATISTICS_MULTICAST_FRAMES_RCV_SUPPORTED          0x00004000 
#define NDIS_STATISTICS_BROADCAST_BYTES_RCV_SUPPORTED           0x00008000 
#define NDIS_STATISTICS_BROADCAST_FRAMES_RCV_SUPPORTED          0x00010000 
#define NDIS_STATISTICS_RCV_CRC_ERROR_SUPPORTED                 0x00020000 
#define NDIS_STATISTICS_TRANSMIT_QUEUE_LENGTH_SUPPORTED         0x00040000 
#define NDIS_STATISTICS_BYTES_RCV_SUPPORTED                     0x00080000 
#define NDIS_STATISTICS_BYTES_XMIT_SUPPORTED                    0x00100000 
#define NDIS_STATISTICS_RCV_DISCARDS_SUPPORTED                  0x00200000 
#define NDIS_STATISTICS_GEN_STATISTICS_SUPPORTED                0x00400000
#define NDIS_STATISTICS_XMIT_DISCARDS_SUPPORTED                 0x08000000


#define NDIS_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES_REVISION_1     1

typedef struct _NDIS_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_HANDLE                     MiniportAddDeviceContext;
    ULONG                           Flags;
   
} NDIS_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES, 
  *PNDIS_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES;

#define NDIS_SIZEOF_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES_REVISION_1       \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES, Flags)

#define NDIS_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES_REVISION_1     1

typedef struct _NDIS_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES
{
    NDIS_OBJECT_HEADER              Header;
    ULONG                           Flags;
    NDIS_MEDIUM                     MediaType;
    NDIS_PHYSICAL_MEDIUM            PhysicalMediumType;
    ULONG                           MtuSize;
    ULONG64                         MaxXmitLinkSpeed;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         MaxRcvLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    NDIS_MEDIA_DUPLEX_STATE         MediaDuplexState;
    ULONG                           LookaheadSize;
    PNDIS_PNP_CAPABILITIES          PowerManagementCapabilities;
    ULONG                           MacOptions;
    ULONG                           SupportedPacketFilters;
    ULONG                           MaxMulticastListSize;
    USHORT                          MacAddressLength;
    UCHAR                           PermanentMacAddress[NDIS_MAX_PHYS_ADDRESS_LENGTH];
    UCHAR                           CurrentMacAddress[NDIS_MAX_PHYS_ADDRESS_LENGTH];
    PNDIS_RECEIVE_SCALE_CAPABILITIES RecvScaleCapabilities;
    NET_IF_ACCESS_TYPE              AccessType; // NET_IF_ACCESS_BROADCAST for a typical ethernet adapter
    NET_IF_DIRECTION_TYPE           DirectionType; // NET_IF_DIRECTION_SENDRECEIVE for a typical ethernet adapter
    NET_IF_CONNECTION_TYPE          ConnectionType; // IF_CONNECTION_DEDICATED for a typical ethernet adapter
    NET_IFTYPE                      IfType; // IF_TYPE_ETHERNET_CSMACD for a typical ethernet adapter (regardless of speed)
    BOOLEAN                         IfConnectorPresent; // RFC 2665 TRUE if physical adapter
    ULONG                           SupportedStatistics; // use NDIS_STATISTICS_XXXX_SUPPORTED    
    ULONG                           SupportedPauseFunctions; // IEEE 802.3 37.2.1
    ULONG                           DataBackFillSize;
    ULONG                           ContextBackFillSize;
    PNDIS_OID                       SupportedOidList;
    ULONG                           SupportedOidListLength;
    ULONG                           AutoNegotiationFlags;
} NDIS_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES, *PNDIS_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES;

#define NDIS_SIZEOF_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES, AutoNegotiationFlags)

#if (NDIS_SUPPORT_NDIS61)

//
// Flags and structure for Header/Data split
//
#define NDIS_HD_SPLIT_ATTRIBUTES_REVISION_1     1

typedef struct _NDIS_HD_SPLIT_ATTRIBUTES
{
    IN  NDIS_OBJECT_HEADER          Header;
    IN  ULONG                       HardwareCapabilities;
    IN  ULONG                       CurrentCapabilities;
    OUT ULONG                       HDSplitFlags;
    OUT ULONG                       BackfillSize;
    OUT ULONG                       MaxHeaderSize;    
} NDIS_HD_SPLIT_ATTRIBUTES, *PNDIS_HD_SPLIT_ATTRIBUTES;

#define NDIS_SIZEOF_HD_SPLIT_ATTRIBUTES_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_HD_SPLIT_ATTRIBUTES, MaxHeaderSize)

//
// The miniport registers its hardware assist capabilities through this
// structure
//
#define NDIS_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES_REVISION_1     1
typedef struct _NDIS_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES
{    
    NDIS_OBJECT_HEADER              Header;
    PNDIS_HD_SPLIT_ATTRIBUTES       HDSplitAttributes;
} NDIS_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES, *PNDIS_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES;

#define NDIS_SIZEOF_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES, HDSplitAttributes)

#endif // (NDIS_SUPPORT_NDIS61)

//
// The miniport registers its offload capabilities through this
// structure
//
#define NDIS_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES_REVISION_1     1
typedef struct _NDIS_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES
{    
    NDIS_OBJECT_HEADER              Header;
    PNDIS_OFFLOAD                   DefaultOffloadConfiguration;
    PNDIS_OFFLOAD                   HardwareOffloadCapabilities;
    PNDIS_TCP_CONNECTION_OFFLOAD    DefaultTcpConnectionOffloadConfiguration;
    PNDIS_TCP_CONNECTION_OFFLOAD    TcpConnectionOffloadHardwareCapabilities;    
} NDIS_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES, *PNDIS_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES;

#define NDIS_SIZEOF_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES, TcpConnectionOffloadHardwareCapabilities)

#include <windot11.h>

#define NDIS_MINIPORT_ADAPTER_802_11_ATTRIBUTES_REVISION_1     1

typedef  struct _NDIS_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES 
{
    NDIS_OBJECT_HEADER Header;
    
    ULONG                    OpModeCapability;
    ULONG                    NumOfTXBuffers;
    ULONG                    NumOfRXBuffers;
    BOOLEAN                  MultiDomainCapabilityImplemented;
    ULONG                    NumSupportedPhys;
#ifdef __midl
    [size_is(NumSupportedPhys)]
#endif
    PDOT11_PHY_ATTRIBUTES    SupportedPhyAttributes;
    
    // Attributes specific to the operation modes
    PDOT11_EXTSTA_ATTRIBUTES ExtSTAAttributes;

}NDIS_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES,
  *PNDIS_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES;

#define NDIS_SIZEOF_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES, ExtSTAAttributes)

typedef union _NDIS_MINIPORT_ADAPTER_ATTRIBUTES
{
    NDIS_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES  AddDeviceRegistrationAttributes;
    NDIS_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES     RegistrationAttributes;
    NDIS_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES          GeneralAttributes;
    NDIS_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES          OffloadAttributes;
    NDIS_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES    Native_802_11_Attributes;
#if (NDIS_SUPPORT_NDIS61)
    NDIS_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES  HardwareAssistAttributes;    
#endif // (NDIS_SUPPORT_NDIS61)
} NDIS_MINIPORT_ADAPTER_ATTRIBUTES, *PNDIS_MINIPORT_ADAPTER_ATTRIBUTES;


//
// flags used in NDIS_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES
//

#define NDIS_MINIPORT_ATTRIBUTES_HARDWARE_DEVICE            0x00000001
#define NDIS_MINIPORT_ATTRIBUTES_NDIS_WDM                   0x00000002
#define NDIS_MINIPORT_ATTRIBUTES_SURPRISE_REMOVE_OK         0x00000004
#define NDIS_MINIPORT_ATTRIBUTES_NOT_CO_NDIS                0x00000008
#define NDIS_MINIPORT_ATTRIBUTES_DO_NOT_BIND_TO_ALL_CO      0x00000010
#define NDIS_MINIPORT_ATTRIBUTES_NO_HALT_ON_SUSPEND         0x00000020
#define NDIS_MINIPORT_ATTRIBUTES_BUS_MASTER                 0x00000040
#define NDIS_MINIPORT_ATTRIBUTES_CONTROLS_DEFAULT_PORT      0x00000080

//
// NDIS 6.0 miniport's entry points
//

EXPORT
NDIS_STATUS
NdisMSetMiniportAttributes(
    IN  NDIS_HANDLE                             NdisMiniportHandle,
    IN  PNDIS_MINIPORT_ADAPTER_ATTRIBUTES       MiniportAttributes
    );

typedef
NDIS_STATUS
(*MINIPORT_INITIALIZE_HANDLER)(
    IN  NDIS_HANDLE                         NdisMiniportHandle,
    IN  NDIS_HANDLE                         MiniportDriverContext,
    IN  PNDIS_MINIPORT_INIT_PARAMETERS      MiniportInitParameters
    );

typedef enum _NDIS_HALT_ACTION
{
    NdisHaltDeviceDisabled,
    NdisHaltDeviceInstanceDeInitialized,
    NdisHaltDevicePoweredDown,
    NdisHaltDeviceSurpriseRemoved,
    NdisHaltDeviceFailed,
    NdisHaltDeviceInitializationFailed,
    NdisHaltDeviceStopped
} NDIS_HALT_ACTION, *PNDIS_HALT_ACTION;

typedef
VOID
(*MINIPORT_HALT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HALT_ACTION        HaltAction
    );


#define NDIS_MINIPORT_PAUSE_PARAMETERS_REVISION_1     1

typedef struct _NDIS_MINIPORT_PAUSE_PARAMETERS
{
    NDIS_OBJECT_HEADER          Header;
    ULONG                       Flags;
    ULONG                       PauseReason;
} NDIS_MINIPORT_PAUSE_PARAMETERS, *PNDIS_MINIPORT_PAUSE_PARAMETERS;

#define NDIS_SIZEOF_MINIPORT_PAUSE_PARAMETERS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_PAUSE_PARAMETERS, Flags)

typedef
NDIS_STATUS
(*MINIPORT_PAUSE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_MINIPORT_PAUSE_PARAMETERS   PauseParameters
    );

typedef
NDIS_STATUS
(*MINIPORT_RESTART_HANDLER)(
    IN  NDIS_HANDLE                             MiniportAdapterContext,
    IN  PNDIS_MINIPORT_RESTART_PARAMETERS       RestartParameters
    );

typedef
NDIS_STATUS
(*MINIPORT_OID_REQUEST_HANDLER) (
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_OID_REQUEST       OidRequest
    );

typedef
VOID
(*MINIPORT_DRIVER_UNLOAD) (
    IN PDRIVER_OBJECT           DriverObject
    );

//
// reasons for calling shutdown handler
//
typedef enum _NDIS_SHUTDOWN_ACTION {
    NdisShutdownPowerOff,
    NdisShutdownBugCheck
} NDIS_SHUTDOWN_ACTION, PNDIS_SHUTDOWN_ACTION;

typedef
VOID
(*MINIPORT_SHUTDOWN_HANDLER) (
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_SHUTDOWN_ACTION    ShutdownAction
    );


#define NET_DEVICE_PNP_EVENT_REVISION_1         1

typedef struct _NET_DEVICE_PNP_EVENT
{
    NDIS_OBJECT_HEADER         Header;
    NDIS_PORT_NUMBER           PortNumber;
    NDIS_DEVICE_PNP_EVENT      DevicePnPEvent;
    PVOID                      InformationBuffer;
    ULONG                      InformationBufferLength;
    UCHAR                      NdisReserved[2 * sizeof(PVOID)];
    
} NET_DEVICE_PNP_EVENT, *PNET_DEVICE_PNP_EVENT;

#define NDIS_SIZEOF_NET_DEVICE_PNP_EVENT_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NET_DEVICE_PNP_EVENT, NdisReserved)
    
typedef
VOID
(*MINIPORT_DEVICE_PNP_EVENT_NOTIFY_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNET_DEVICE_PNP_EVENT   NetDevicePnPEvent
    );

typedef
VOID
(*MINIPORT_CANCEL_SEND_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PVOID                   CancelId
    );


typedef
BOOLEAN
(*MINIPORT_CHECK_FOR_HANG_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
NDIS_STATUS
(*MINIPORT_RESET_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    OUT PBOOLEAN                AddressingReset
    );

typedef
VOID
(*MINIPORT_CANCEL_OID_REQUEST_HANDLER)(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PVOID                    RequestId
    );

typedef
VOID
(*MINIPORT_SEND_NET_BUFFER_LISTS_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNET_BUFFER_LIST        NetBufferList,
    IN  NDIS_PORT_NUMBER        PortNumber,
    IN  ULONG                   SendFlags
    );

typedef
VOID
(*MINIPORT_RETURN_NET_BUFFER_LISTS_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  ULONG                   ReturnFlags
    );

#if (NDIS_SUPPORT_NDIS61)    
//
// NDIS 6.1 miniport's entry points
//
typedef
NDIS_STATUS
(*MINIPORT_DIRECT_OID_REQUEST_HANDLER) (
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_OID_REQUEST       OidRequest
    );

typedef
VOID
(*MINIPORT_CANCEL_DIRECT_OID_REQUEST_HANDLER)(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PVOID                    RequestId
    );    
#endif // (NDIS_SUPPORT_NDIS61)    

//
// flags used in Flags field of NDIS60_MINIPORT_CHARACTERISTICS
//
#define NDIS_INTERMEDIATE_DRIVER                0x00000001
#define NDIS_WDM_DRIVER                         0x00000002


#define NDIS_MINIPORT_DRIVER_CHARACTERISTICS_REVISION_1     1

#if (NDIS_SUPPORT_NDIS61)  
#define NDIS_MINIPORT_DRIVER_CHARACTERISTICS_REVISION_2     2
#endif // (NDIS_SUPPORT_NDIS61)    

typedef struct _NDIS_MINIPORT_DRIVER_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER                          Header;
    UCHAR                                       MajorNdisVersion;
    UCHAR                                       MinorNdisVersion;
    UCHAR                                       MajorDriverVersion;
    UCHAR                                       MinorDriverVersion;
    ULONG                                       Flags;
    SET_OPTIONS_HANDLER                         SetOptionsHandler;
    MINIPORT_INITIALIZE_HANDLER                 InitializeHandlerEx;
    MINIPORT_HALT_HANDLER                       HaltHandlerEx;
    MINIPORT_DRIVER_UNLOAD                      UnloadHandler;
    MINIPORT_PAUSE_HANDLER                      PauseHandler;
    MINIPORT_RESTART_HANDLER                    RestartHandler;
    MINIPORT_OID_REQUEST_HANDLER                OidRequestHandler;
    MINIPORT_SEND_NET_BUFFER_LISTS_HANDLER      SendNetBufferListsHandler;
    MINIPORT_RETURN_NET_BUFFER_LISTS_HANDLER    ReturnNetBufferListsHandler;
    MINIPORT_CANCEL_SEND_HANDLER                CancelSendHandler;
    MINIPORT_CHECK_FOR_HANG_HANDLER             CheckForHangHandlerEx;
    MINIPORT_RESET_HANDLER                      ResetHandlerEx;
    MINIPORT_DEVICE_PNP_EVENT_NOTIFY_HANDLER    DevicePnPEventNotifyHandler;
    MINIPORT_SHUTDOWN_HANDLER                   ShutdownHandlerEx;
    MINIPORT_CANCEL_OID_REQUEST_HANDLER         CancelOidRequestHandler;
#if (NDIS_SUPPORT_NDIS61)        
    MINIPORT_DIRECT_OID_REQUEST_HANDLER         DirectOidRequestHandler;    
    MINIPORT_CANCEL_DIRECT_OID_REQUEST_HANDLER  CancelDirectOidRequestHandler;     
#endif // (NDIS_SUPPORT_NDIS61)    
} NDIS_MINIPORT_DRIVER_CHARACTERISTICS, *PNDIS_MINIPORT_DRIVER_CHARACTERISTICS;

#define NDIS_SIZEOF_MINIPORT_DRIVER_CHARACTERISTICS_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_DRIVER_CHARACTERISTICS, CancelOidRequestHandler)

#if (NDIS_SUPPORT_NDIS61)    
#define NDIS_SIZEOF_MINIPORT_DRIVER_CHARACTERISTICS_REVISION_2      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_DRIVER_CHARACTERISTICS, CancelDirectOidRequestHandler)
#endif // (NDIS_SUPPORT_NDIS61)    

//
// CO NDIS 6.0 handlers
//

#define NDIS_MINIPORT_CO_CHARACTERISTICS_REVISION_1      1

typedef struct _NDIS_MINIPORT_CO_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER                          Header;     // Header.Type = NDIS_OBJECT_TYPE_PROTOCOL_CO_CHARACTERISTICS
    ULONG                                       Flags;
    W_CO_CREATE_VC_HANDLER                      CoCreateVcHandler;
    W_CO_DELETE_VC_HANDLER                      CoDeleteVcHandler;
    W_CO_ACTIVATE_VC_HANDLER                    CoActivateVcHandler;
    W_CO_DEACTIVATE_VC_HANDLER                  CoDeactivateVcHandler;
    W_CO_SEND_NET_BUFFER_LISTS_HANDLER          CoSendNetBufferListsHandler;
    W_CO_OID_REQUEST_HANDLER                    CoOidRequestHandler;
    
} NDIS_MINIPORT_CO_CHARACTERISTICS, *PNDIS_MINIPORT_CO_CHARACTERISTICS;

#define NDIS_SIZEOF_MINIPORT_CO_CHARACTERISTICS_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MINIPORT_CO_CHARACTERISTICS, CoOidRequestHandler)

EXPORT
VOID
NdisMIndicateStatusEx(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN PNDIS_STATUS_INDICATION  StatusIndication
    );

EXPORT
VOID
NdisMCoOidRequestComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisMiniportVcHandle,
    IN  PNDIS_OID_REQUEST       Request,
    IN  NDIS_STATUS             Status
    );


EXPORT
NDIS_STATUS
NdisMCmOidRequest(
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN OUT PNDIS_OID_REQUEST    NdisRequest
    );


EXPORT
VOID
NdisMCoIndicateStatusEx(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  PNDIS_STATUS_INDICATION StatusIndication
    );

#endif // NDIS_SUPPORT_NDIS6


//
// Do not change the structure below !!!
//
typedef struct
{
    union
    {
        PETH_FILTER             EthDB;
        PNULL_FILTER            NullDB;             // Default Filter
    };
    PTR_FILTER                  TrDB;

    PVOID                       YYYDB;

    PVOID                       XXXDB;
} FILTERDBS, *PFILTERDBS;

#if NDIS_LEGACY_MINIPORT
typedef
VOID
(*FILTER_PACKET_INDICATION_HANDLER)(
    IN  NDIS_HANDLE             Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

#endif // NDIS_LEGACY_MINIPORT

#if !NDIS_WRAPPER
//
// one of these per mini-port registered on a Driver
//

#if NDIS_LEGACY_MINIPORT

struct _NDIS_MINIPORT_BLOCK
{
    NDIS_OBJECT_HEADER          Header;
    PNDIS_MINIPORT_BLOCK        NextMiniport;       // used by driver's MiniportQueue
    PNDIS_MINIPORT_BLOCK        BaseMiniport;
    NDIS_HANDLE                 MiniportAdapterContext; // context when calling mini-port functions
    UNICODE_STRING              Reserved4;
    PVOID                       Reserved10;
    NDIS_HANDLE                 OpenQueue;          // queue of opens for this mini-port
    REFERENCE                   ShortRef;           // contains spinlock for OpenQueue

    NDIS_HANDLE                 Reserved12;

    UCHAR                       Padding1;           // DO NOT REMOVE OR NDIS WILL BREAK!!!

    //
    // Synchronization stuff.
    //
    // The boolean is used to lock out several DPCs from running at the same time.
    //
    UCHAR                       LockAcquired;       // EXPOSED via macros. Do not move

    UCHAR                       PmodeOpens;         // Count of opens which turned on pmode/all_local

    //
    //  This is the processor number that the miniport's
    //  interrupt DPC and timers are running on.
    //
    UCHAR                       AssignedProcessor;

    KSPIN_LOCK                  Lock;

    PNDIS_REQUEST               MediaRequest;

    PVOID                       Interrupt;
    
    ULONG                       Flags;              // Flags to keep track of the miniport's state.
    ULONG                       PnPFlags;

    //
    // Send information
    //
    LIST_ENTRY                  PacketList;
    PNDIS_PACKET                FirstPendingPacket; // This is head of the queue of packets
                                                    // waiting to be sent to miniport.
    PNDIS_PACKET                ReturnPacketsQueue;

    //
    // Space used for temp. use during request processing
    //
    ULONG                       RequestBuffer;
    PVOID                       SetMCastBuffer;

    PNDIS_MINIPORT_BLOCK        PrimaryMiniport;
    PVOID                       Reserved11;

    //
    // context to pass to bus driver when reading or writing config space
    //
    PVOID                       BusDataContext;
    ULONG                       Reserved3;

    //
    // Resource information
    //
    PCM_RESOURCE_LIST           Resources;

    //
    // Watch-dog timer
    //
    NDIS_TIMER                  WakeUpDpcTimer;

    //
    // Needed for PnP. Upcased version. The buffer is allocated as part of the
    // NDIS_MINIPORT_BLOCK itself.
    //
    // Note:
    // the following two fields should be explicitly UNICODE_STRING because
    // under Win9x the NDIS_STRING is an ANSI_STRING
    //
    UNICODE_STRING              Reserved20;
    UNICODE_STRING              SymbolicLinkName;

    //
    // Check for hang stuff
    //
    ULONG                       CheckForHangSeconds;
    USHORT                      CFHangTicks;
    USHORT                      CFHangCurrentTick;

    //
    // Reset information
    //
    NDIS_STATUS                 ResetStatus;
    NDIS_HANDLE                 ResetOpen;

    //
    // Holds media specific information.
    //
#ifdef __cplusplus
    FILTERDBS                   FilterDbs;          // EXPOSED via macros. Do not move
#else
    FILTERDBS;                                      // EXPOSED via macros. Do not move
#endif

    FILTER_PACKET_INDICATION_HANDLER PacketIndicateHandler;
    NDIS_M_SEND_COMPLETE_HANDLER    SendCompleteHandler;
    NDIS_M_SEND_RESOURCES_HANDLER   SendResourcesHandler;
    NDIS_M_RESET_COMPLETE_HANDLER   ResetCompleteHandler;

    NDIS_MEDIUM                 MediaType;

    //
    // contains mini-port information
    //
    ULONG                       BusNumber;
    NDIS_INTERFACE_TYPE         BusType;
    NDIS_INTERFACE_TYPE         AdapterType;

    PDEVICE_OBJECT              Reserved6;
    PDEVICE_OBJECT              Reserved7;
    PDEVICE_OBJECT              Reserved8;


    PVOID                       MiniportSGDmaBlock;

    //
    // List of registered address families. Valid for the call-manager, Null for the client
    //
    PNDIS_AF_LIST               CallMgrAfList;

    PVOID                       MiniportThread;
    PVOID                       SetInfoBuf;
    USHORT                      SetInfoBufLen;
    USHORT                      MaxSendPackets;

    //
    //  Status code that is returned from the fake handlers.
    //
    NDIS_STATUS                 FakeStatus;

    PVOID                       LockHandler;        // For the filter lock

    PUNICODE_STRING             Reserved9;

    PVOID                       Reserved21;

    UINT                        MacOptions;

    //
    // RequestInformation
    //
    PNDIS_REQUEST               PendingRequest;
    UINT                        MaximumLongAddresses;
    UINT                        MaximumShortAddresses;
    UINT                        CurrentLookahead;
    UINT                        MaximumLookahead;

    //
    //  For efficiency
    //
    ULONG_PTR                   Reserved1;
    W_DISABLE_INTERRUPT_HANDLER DisableInterruptHandler;
    W_ENABLE_INTERRUPT_HANDLER  EnableInterruptHandler;
    W_SEND_PACKETS_HANDLER      SendPacketsHandler;
    NDIS_M_START_SENDS          DeferredSendHandler;

    //
    // The following cannot be unionized.
    //
    ETH_RCV_INDICATE_HANDLER    EthRxIndicateHandler;   // EXPOSED via macros. Do not move
    TR_RCV_INDICATE_HANDLER     TrRxIndicateHandler;    // EXPOSED via macros. Do not move
    PVOID                       Reserved2;

    ETH_RCV_COMPLETE_HANDLER    EthRxCompleteHandler;   // EXPOSED via macros. Do not move
    TR_RCV_COMPLETE_HANDLER     TrRxCompleteHandler;    // EXPOSED via macros. Do not move
    PVOID                       Reserved22;

    NDIS_M_STATUS_HANDLER       StatusHandler;          // EXPOSED via macros. Do not move
    NDIS_M_STS_COMPLETE_HANDLER StatusCompleteHandler;  // EXPOSED via macros. Do not move
    NDIS_M_TD_COMPLETE_HANDLER  TDCompleteHandler;      // EXPOSED via macros. Do not move
    NDIS_M_REQ_COMPLETE_HANDLER QueryCompleteHandler;   // EXPOSED via macros. Do not move
    NDIS_M_REQ_COMPLETE_HANDLER SetCompleteHandler;     // EXPOSED via macros. Do not move

    NDIS_WM_SEND_COMPLETE_HANDLER WanSendCompleteHandler;// EXPOSED via macros. Do not move
    WAN_RCV_HANDLER             WanRcvHandler;          // EXPOSED via macros. Do not move
    WAN_RCV_COMPLETE_HANDLER    WanRcvCompleteHandler;  // EXPOSED via macros. Do not move

    /********************************************************************************************/
    /****************                                                                  **********/
    /**************** STUFF ABOVE IS POTENTIALLY ACCESSED BY MACROS. ADD STUFF BELOW   **********/
    /**************** SEVERE POSSIBILITY OF BREAKING SOMETHING IF STUFF ABOVE IS MOVED **********/
    /****************                                                                  **********/
    /********************************************************************************************/

};
#endif // NDIS_LEGACY_MINIPORT

#endif // NDIS_WRAPPER not defined


#if NDIS_LEGACY_MINIPORT

#ifdef NDIS51_MINIPORT
typedef struct _NDIS51_MINIPORT_CHARACTERISTICS NDIS_MINIPORT_CHARACTERISTICS;
#else
#ifdef NDIS50_MINIPORT
typedef struct _NDIS50_MINIPORT_CHARACTERISTICS NDIS_MINIPORT_CHARACTERISTICS;
#else
#ifdef NDIS40_MINIPORT
typedef struct _NDIS40_MINIPORT_CHARACTERISTICS NDIS_MINIPORT_CHARACTERISTICS;
#else
typedef struct _NDIS30_MINIPORT_CHARACTERISTICS NDIS_MINIPORT_CHARACTERISTICS;
#endif
#endif
#endif

typedef NDIS_MINIPORT_CHARACTERISTICS * PNDIS_MINIPORT_CHARACTERISTICS;
typedef NDIS_MINIPORT_CHARACTERISTICS   NDIS_WAN_MINIPORT_CHARACTERISTICS;
typedef NDIS_WAN_MINIPORT_CHARACTERISTICS * PNDIS_MINIPORT_CHARACTERISTICS;


//
// Routines for intermediate miniport drivers. NDIS 6 IM drivers
// use the same registration deregistration APIs as regular miniports
//

EXPORT
NDIS_STATUS
NdisIMRegisterLayeredMiniport(
    IN  NDIS_HANDLE                     NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS  MiniportCharacteristics,
    IN  UINT                            CharacteristicsLength,
    OUT PNDIS_HANDLE                    DriverHandle
    );

EXPORT
VOID
NdisIMDeregisterLayeredMiniport(
    IN  NDIS_HANDLE         DriverHandle
    );

EXPORT
NDIS_STATUS
NdisMRegisterDevice(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_STRING            DeviceName,
    IN  PNDIS_STRING            SymbolicName,
    IN  PDRIVER_DISPATCH        MajorFunctions[],
    OUT PDEVICE_OBJECT      *   pDeviceObject,
    OUT NDIS_HANDLE         *   NdisDeviceHandle
    );

EXPORT
NDIS_STATUS
NdisMDeregisterDevice(
    IN  NDIS_HANDLE             NdisDeviceHandle
    );

EXPORT
VOID
NdisMRegisterUnloadHandler(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PDRIVER_UNLOAD          UnloadHandler
    );

#endif // NDIS_LEGACY_MINIPORT


EXPORT
VOID
NdisIMAssociateMiniport(
    IN  NDIS_HANDLE         DriverHandle,
    IN  NDIS_HANDLE         ProtocolHandle
    );

//
// Operating System Requests
//
typedef UCHAR   NDIS_DMA_SIZE;

#define NDIS_DMA_24BITS             ((NDIS_DMA_SIZE)0)
#define NDIS_DMA_32BITS             ((NDIS_DMA_SIZE)1)
#define NDIS_DMA_64BITS             ((NDIS_DMA_SIZE)2)

#if NDIS_LEGACY_MINIPORT
EXPORT
NDIS_STATUS
NdisMAllocateMapRegisters(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    DmaChannel,
    IN  NDIS_DMA_SIZE           DmaSize,
    IN  ULONG                   BaseMapRegistersNeeded,
    IN  ULONG                   MaximumPhysicalMapping
    );

EXPORT
VOID
NdisMFreeMapRegisters(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    );

EXPORT
NDIS_STATUS
NdisMInitializeScatterGatherDma(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  BOOLEAN                 Dma64BitAddresses,
    IN  ULONG                   MaximumPhysicalMapping
    );

#endif // NDIS_LEGACY_MINIPORT

EXPORT
NDIS_STATUS
NdisMRegisterIoPortRange(
    OUT PVOID *                 PortOffset,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    InitialPort,
    IN  UINT                    NumberOfPorts
    );

EXPORT
VOID
NdisMDeregisterIoPortRange(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    InitialPort,
    IN  UINT                    NumberOfPorts,
    IN  PVOID                   PortOffset
    );

EXPORT
NDIS_STATUS
NdisMMapIoSpace(
    OUT PVOID *                 VirtualAddress,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress,
    IN  UINT                    Length
    );

EXPORT
VOID
NdisMUnmapIoSpace(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    );

#if NDIS_LEGACY_MINIPORT

EXPORT
NDIS_STATUS
NdisMRegisterInterrupt(
    OUT PNDIS_MINIPORT_INTERRUPT Interrupt,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    InterruptVector,
    IN  UINT                    InterruptLevel,
    IN  BOOLEAN                 RequestIsr,
    IN  BOOLEAN                 SharedInterrupt,
    IN  NDIS_INTERRUPT_MODE     InterruptMode
    );

EXPORT
VOID
NdisMDeregisterInterrupt(
    IN  PNDIS_MINIPORT_INTERRUPT Interrupt
    );

EXPORT
BOOLEAN
NdisMSynchronizeWithInterrupt(
    IN  PNDIS_MINIPORT_INTERRUPT Interrupt,
    IN  PVOID                   SynchronizeFunction,
    IN  PVOID                   SynchronizeContext
    );

EXPORT
VOID
NdisMQueryAdapterResources(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PNDIS_RESOURCE_LIST     ResourceList,
    IN  OUT PUINT               BufferSize
    );

//
// Physical Mapping
//
EXPORT
VOID
NdisMStartBufferPhysicalMapping(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   PhysicalMapRegister,
    IN  BOOLEAN                 WriteToDevice,
    OUT PNDIS_PHYSICAL_ADDRESS_UNIT PhysicalAddressArray,
    OUT PUINT                   ArraySize
    );

EXPORT
VOID
NdisMCompleteBufferPhysicalMapping(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   PhysicalMapRegister
    );

/*++
//
// This API has been deprecated
//
VOID
NdisMUpdateSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  PVOID                   VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    );
*/
#define NdisMUpdateSharedMemory(_H, _L, _V, _P)
#pragma deprecated(NdisMUpdateSharedMemory)


#endif // NDIS_LEGACY_MINIPORT

//
// Timers
//
// VOID
// NdisMSetTimer(
//  IN  PNDIS_MINIPORT_TIMER    Timer,
//  IN  UINT                    MillisecondsToDelay
//  );
#define NdisMSetTimer(_Timer, _Delay)   NdisSetTimer((PNDIS_TIMER)_Timer, _Delay)

EXPORT
VOID
NdisMSetPeriodicTimer(
    IN  PNDIS_MINIPORT_TIMER     Timer,
    IN  UINT                     MillisecondPeriod
    );

EXPORT
VOID
NdisMInitializeTimer(
    IN  OUT PNDIS_MINIPORT_TIMER Timer,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_TIMER_FUNCTION    TimerFunction,
    IN  PVOID                   FunctionContext
    );

EXPORT
VOID
NdisMCancelTimer(
    IN  PNDIS_MINIPORT_TIMER    Timer,
    OUT PBOOLEAN                TimerCancelled
    );

EXPORT
VOID
NdisMSleep(
    IN  ULONG                   MicrosecondsToSleep
    );

EXPORT
ULONG
NdisMGetDmaAlignment(
    IN  NDIS_HANDLE MiniportAdapterHandle
    );

//
// Shared memory
//
EXPORT
VOID
NdisMAllocateSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    OUT PVOID *                 VirtualAddress,
    OUT PNDIS_PHYSICAL_ADDRESS  PhysicalAddress
    );



EXPORT
VOID
NdisMFreeSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    );

#if NDIS_LEGACY_MINIPORT

//
// Requests Used by Miniport Drivers
//
#define NdisMInitializeWrapper(_a,_b,_c,_d) NdisInitializeWrapper((_a),(_b),(_c),(_d))


EXPORT
NDIS_STATUS
NdisMRegisterMiniport(
    IN  NDIS_HANDLE                     NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS  MiniportCharacteristics,
    IN  UINT                            CharacteristicsLength
    );


// EXPORT
// NDIS_STATUS
// NdisIMInitializeDeviceInstance(
//  IN  NDIS_HANDLE             DriverHandle,
//  IN  PNDIS_STRING            DriverInstance
//  );
#define NdisIMInitializeDeviceInstance(_H_, _I_)    \
                                NdisIMInitializeDeviceInstanceEx(_H_, _I_, NULL)
#endif // NDIS_LEGACY_MINIPORT

EXPORT
NDIS_STATUS
NdisIMInitializeDeviceInstanceEx(
    IN  NDIS_HANDLE             DriverHandle,
    IN  PNDIS_STRING            DriverInstance,
    IN  NDIS_HANDLE             DeviceContext   OPTIONAL
    );

EXPORT
NDIS_STATUS
NdisIMCancelInitializeDeviceInstance(
    IN  NDIS_HANDLE             DriverHandle,
    IN  PNDIS_STRING            DeviceInstance
    );

#if NDIS_LEGACY_MINIPORT
EXPORT
NDIS_HANDLE
NdisIMGetDeviceContext(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    );

#endif // NDIS_LEGACY_MINIPORT

EXPORT
NDIS_HANDLE
NdisIMGetBindingContext(
    IN  NDIS_HANDLE             NdisBindingHandle
    );

EXPORT
NDIS_STATUS
NdisIMDeInitializeDeviceInstance(
    IN  NDIS_HANDLE             NdisMiniportHandle
    );


#if NDIS_LEGACY_MINIPORT

EXPORT
VOID
NdisIMCopySendPerPacketInfo(
    OUT PNDIS_PACKET            DstPacket,
    IN  PNDIS_PACKET            SrcPacket
    );

EXPORT
VOID
NdisIMCopySendCompletePerPacketInfo(
    OUT PNDIS_PACKET            DstPacket,
    IN  PNDIS_PACKET            SrcPacket
    );

// EXPORT
// VOID
// NdisMSetAttributes(
//  IN  NDIS_HANDLE             MiniportAdapterHandle,
//  IN  NDIS_HANDLE             MiniportAdapterContext,
//  IN  BOOLEAN                 BusMaster,
//  IN  NDIS_INTERFACE_TYPE     AdapterType
//  );
#define NdisMSetAttributes(_H_, _C_, _M_, _T_)                                      \
                        NdisMSetAttributesEx(_H_,                                   \
                                             _C_,                                   \
                                             0,                                     \
                                             (_M_) ? NDIS_ATTRIBUTE_BUS_MASTER : 0, \
                                             _T_)                                   \


EXPORT
VOID
NdisMSetAttributesEx(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  UINT                    CheckForHangTimeInSeconds OPTIONAL,
    IN  ULONG                   AttributeFlags,
    IN  NDIS_INTERFACE_TYPE     AdapterType OPTIONAL
    );

#define NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT        0x00000001
#define NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT       0x00000002
#define NDIS_ATTRIBUTE_IGNORE_TOKEN_RING_ERRORS     0x00000004
#define NDIS_ATTRIBUTE_BUS_MASTER                   0x00000008
#define NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER          0x00000010
#define NDIS_ATTRIBUTE_DESERIALIZE                  0x00000020
#define NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND           0x00000040
#define NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK           0x00000080
#define NDIS_ATTRIBUTE_NOT_CO_NDIS                  0x00000100
#define NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS        0x00000200
#define NDIS_ATTRIBUTE_DO_NOT_BIND_TO_ALL_CO        0x00000400
#define NDIS_ATTRIBUTE_MINIPORT_PADS_SHORT_PACKETS  0x00000800

EXPORT
NDIS_STATUS
NdisMSetMiniportSecondary(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  NDIS_HANDLE             PrimaryMiniportHandle
    );

EXPORT
NDIS_STATUS
NdisMPromoteMiniport(
    IN  NDIS_HANDLE             MiniportHandle
    );

#endif // NDIS_LEGACY_MINIPORT

EXPORT
NDIS_STATUS
NdisMRemoveMiniport(
    IN  NDIS_HANDLE             MiniportHandle
    );


#if NDIS_LEGACY_MINIPORT

#define NdisMSendComplete(_M, _P, _S)   (*((PNDIS_MINIPORT_BLOCK)(_M))->SendCompleteHandler)(_M, _P, _S)

#define NdisMSendResourcesAvailable(_M) (*((PNDIS_MINIPORT_BLOCK)(_M))->SendResourcesHandler)(_M)

#if (!NDIS_WRAPPER)
#if (!NDIS_SUPPORT_NDIS6)

#define NdisMResetComplete(_M, _S, _A)  (*((PNDIS_MINIPORT_BLOCK)(_M))->ResetCompleteHandler)(_M, _S, _A)
#endif // NDIS_SUPPORT_NDIS6
#endif // !NDIS_WRAPPER

#define NdisMTransferDataComplete(_M, _P, _S, _B)   \
                                        (*((PNDIS_MINIPORT_BLOCK)(_M))->TDCompleteHandler)(_M, _P, _S, _B)

/*++

VOID
NdisMWanSendComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PVOID                   Packet,
    IN  NDIS_STATUS             Status
    );

--*/

#define NdisMWanSendComplete(_M_, _P_, _S_)                                             \
                (*((PNDIS_MINIPORT_BLOCK)(_M_))->WanSendCompleteHandler)(_M_, _P_, _S_)

#define NdisMQueryInformationComplete(_M, _S)   \
                                        (*((PNDIS_MINIPORT_BLOCK)(_M))->QueryCompleteHandler)(_M, _S)

#define NdisMSetInformationComplete(_M, _S) \
                                        (*((PNDIS_MINIPORT_BLOCK)(_M))->SetCompleteHandler)(_M, _S)

/*++

VOID
NdisMIndicateReceivePacket(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PPNDIS_PACKET           ReceivedPackets,
    IN  UINT                    NumberOfPackets
    );

--*/
#define NdisMIndicateReceivePacket(_H, _P, _N)                                  \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->PacketIndicateHandler)(                     \
                        _H,                                                     \
                        _P,                                                     \
                        _N);                                                    \
}

/*++

VOID
NdisMWanIndicateReceive(
    OUT PNDIS_STATUS            Status,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              NdisLinkContext,
    IN PUCHAR                   Packet,
    IN ULONG                    PacketSize
    );

--*/

#define NdisMWanIndicateReceive(_S_, _M_, _C_, _P_, _Z_)                        \
                (*((PNDIS_MINIPORT_BLOCK)(_M_))->WanRcvHandler)(_S_, _M_, _C_, _P_, _Z_)

/*++

VOID
NdisMWanIndicateReceiveComplete(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              NdisLinkContext
    );

--*/

#define NdisMWanIndicateReceiveComplete(_M_, _C_)                                   \
                (*((PNDIS_MINIPORT_BLOCK)(_M_))->WanRcvCompleteHandler)(_M_, _C_)

/*++

VOID
NdisMEthIndicateReceive(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             MiniportReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )

--*/
#ifdef __cplusplus

#define NdisMEthIndicateReceive( _H, _C, _B, _SZ, _L, _LSZ, _PSZ)               \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->EthRxIndicateHandler)(                      \
        ((PNDIS_MINIPORT_BLOCK)(_H))->FilterDbs.EthDB,                          \
        _C,                                                                     \
        _B,                                                                     \
        _B,                                                                     \
        _SZ,                                                                    \
        _L,                                                                     \
        _LSZ,                                                                   \
        _PSZ                                                                    \
        );                                                                      \
}

#else

#define NdisMEthIndicateReceive( _H, _C, _B, _SZ, _L, _LSZ, _PSZ)               \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->EthRxIndicateHandler)(                      \
        ((PNDIS_MINIPORT_BLOCK)(_H))->EthDB,                                    \
        _C,                                                                     \
        _B,                                                                     \
        _B,                                                                     \
        _SZ,                                                                    \
        _L,                                                                     \
        _LSZ,                                                                   \
        _PSZ                                                                    \
        );                                                                      \
}

#endif

/*++

VOID
NdisMTrIndicateReceive(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             MiniportReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )

--*/
#ifdef __cplusplus
#define NdisMTrIndicateReceive( _H, _C, _B, _SZ, _L, _LSZ, _PSZ)                \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->TrRxIndicateHandler)(                       \
        ((PNDIS_MINIPORT_BLOCK)(_H))->FilterDbs.TrDB,                                     \
        _C,                                                                     \
        _B,                                                                     \
        _SZ,                                                                    \
        _L,                                                                     \
        _LSZ,                                                                   \
        _PSZ                                                                    \
        );                                                                      \
}

#else

#define NdisMTrIndicateReceive( _H, _C, _B, _SZ, _L, _LSZ, _PSZ)                \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->TrRxIndicateHandler)(                       \
        ((PNDIS_MINIPORT_BLOCK)(_H))->TrDB,                                     \
        _C,                                                                     \
        _B,                                                                     \
        _SZ,                                                                    \
        _L,                                                                     \
        _LSZ,                                                                   \
        _PSZ                                                                    \
        );                                                                      \
}
#endif

/*++

VOID
NdisMEthIndicateReceiveComplete(
    IN  NDIS_HANDLE             MiniportHandle
    );

--*/
#ifdef __cplusplus

#define NdisMEthIndicateReceiveComplete( _H )                                   \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->EthRxCompleteHandler)(                      \
                                        ((PNDIS_MINIPORT_BLOCK)_H)->FilterDbs.EthDB);     \
}

#else

#define NdisMEthIndicateReceiveComplete( _H )                                   \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->EthRxCompleteHandler)(                      \
                                        ((PNDIS_MINIPORT_BLOCK)_H)->EthDB);               \
}

#endif


/*++

VOID
NdisMTrIndicateReceiveComplete(
    IN  NDIS_HANDLE             MiniportHandle
    );

--*/
#ifdef __cplusplus
#define NdisMTrIndicateReceiveComplete( _H )                                    \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->TrRxCompleteHandler)(                       \
                                        ((PNDIS_MINIPORT_BLOCK)_H)->FilterDbs.TrDB);      \
}
#else
#define NdisMTrIndicateReceiveComplete( _H )                                    \
{                                                                               \
    (*((PNDIS_MINIPORT_BLOCK)(_H))->TrRxCompleteHandler)(                       \
                                        ((PNDIS_MINIPORT_BLOCK)_H)->TrDB);      \
}
#endif


EXPORT
VOID
NdisMIndicateStatus(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

EXPORT
VOID
NdisMIndicateStatusComplete(
    IN  NDIS_HANDLE             MiniportHandle
    );

EXPORT
VOID
NdisMRegisterAdapterShutdownHandler(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  PVOID                   ShutdownContext,
    IN  ADAPTER_SHUTDOWN_HANDLER ShutdownHandler
    );

EXPORT
VOID
NdisMDeregisterAdapterShutdownHandler(
    IN  NDIS_HANDLE             MiniportHandle
    );

EXPORT
NDIS_STATUS
NdisMPciAssignResources(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  ULONG                   SlotNumber,
    IN  PNDIS_RESOURCE_LIST *   AssignedResources
    );

EXPORT
NDIS_STATUS
NdisIMNotifyPnPEvent(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  PNET_PNP_EVENT          NetPnPEvent
    );

#endif // NDIS_LEGACY_MINIPORT


//
// Logging support for miniports
//

EXPORT
NDIS_STATUS
NdisMCreateLog(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    Size,
    OUT PNDIS_HANDLE            LogHandle
    );

EXPORT
VOID
NdisMCloseLog(
    IN  NDIS_HANDLE             LogHandle
    );

EXPORT
NDIS_STATUS
NdisMWriteLogData(
    IN  NDIS_HANDLE             LogHandle,
    IN  PVOID                   LogBuffer,
    IN  UINT                    LogBufferSize
    );

EXPORT
VOID
NdisMFlushLog(
    IN  NDIS_HANDLE             LogHandle
    );

EXPORT
VOID
NdisMGetDeviceProperty(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN OUT PDEVICE_OBJECT *     PhysicalDeviceObject        OPTIONAL,
    IN OUT PDEVICE_OBJECT *     FunctionalDeviceObject      OPTIONAL,
    IN OUT PDEVICE_OBJECT *     NextDeviceObject            OPTIONAL,
    IN OUT PCM_RESOURCE_LIST *  AllocatedResources          OPTIONAL,
    IN OUT PCM_RESOURCE_LIST *  AllocatedResourcesTranslated OPTIONAL
    );

//
//  Get a pointer to the adapter's localized instance name.
//
EXPORT
NDIS_STATUS
NdisMQueryAdapterInstanceName(
    OUT PNDIS_STRING            pAdapterInstanceName,
    IN  NDIS_HANDLE             MiniportHandle
    );


#if NDIS_LEGACY_MINIPORT

//
// NDIS 5.0 extensions for miniports
//

EXPORT
VOID
NdisMCoIndicateReceivePacket(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

EXPORT
VOID
NdisMCoIndicateStatus(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer    OPTIONAL,
    IN  ULONG                   StatusBufferSize
    );

EXPORT
VOID
NdisMCoReceiveComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    );

EXPORT
VOID
NdisMCoSendComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PNDIS_PACKET            Packet
    );


EXPORT
VOID
NdisMCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_REQUEST           Request
    );

EXPORT
NDIS_STATUS
NdisMCmRequest(
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

#endif // NDIS_LEGACY_MINIPORT

EXPORT
VOID
NdisMCoActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

EXPORT
VOID
NdisMCoDeactivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle
    );

EXPORT
NDIS_STATUS
NdisMCmRegisterAddressFamily(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  PNDIS_CALL_MANAGER_CHARACTERISTICS CmCharacteristics,
    IN  UINT                    SizeOfCmCharacteristics
    );

EXPORT
NDIS_STATUS
NdisMCmCreateVc(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             MiniportVcContext,
    OUT PNDIS_HANDLE            NdisVcHandle
    );

EXPORT
NDIS_STATUS
NdisMCmDeleteVc(
    IN  NDIS_HANDLE             NdisVcHandle
    );


EXPORT
NDIS_STATUS
NdisMCmActivateVc(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

EXPORT
NDIS_STATUS
NdisMCmDeactivateVc(
    IN  NDIS_HANDLE             NdisVcHandle
    );


#if NDIS_LEGACY_MINIPORT

// EXPORT
// VOID
// NdisMCmRequestComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisAfHandle,
//  IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
//  IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
//  IN  PNDIS_REQUEST           NdisRequest
//  );
#define NdisMCmRequestComplete(_S_, _AH_, _VH_, _PH_, _R_) \
                                        NdisCoRequestComplete(_S_, _AH_, _VH_, _PH_, _R_)
#endif // NDIS_LEGACY_MINIPORT

#if (NDIS_SUPPORT_NDIS6 || NDIS60)

// EXPORT
// VOID
// NdisMCmOidRequestComplete(
//  IN  NDIS_HANDLE             NdisAfHandle,
//  IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
//  IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
//  IN  PNDIS_OID_REQUEST       OidRequest,
//  IN  NDIS_STATUS             Status
//  );
#define NdisMCmOidRequestComplete(_AH_, _VH_, _PH_, _R_, _S_) \
                                        NdisCoOidRequestComplete(_AH_, _VH_, _PH_, _R_, _S_)
#endif // NDIS_SUPPORT_NDIS6 || NDIS60


// EXPORT
// VOID
// NdisMCmOpenAddressFamilyComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisAfHandle,
//  IN  NDIS_HANDLE             CallMgrAfContext
//  );

#define NdisMCmOpenAddressFamilyComplete(_S_, _H_, _C_) \
                                        NdisCmOpenAddressFamilyComplete(_S_, _H_, _C_)
// EXPORT
// NDIS_STATUS
// NdisMCmNotifyCloseAddressFamily(
//   IN  NDIS_HANDLE              NdisAfHandle
// );

#define NdisMCmNotifyCloseAddressFamily(_AH_) \
                                         NdisCmNotifyCloseAddressFamily(_AH_)

// EXPORT
// VOID
// NdisMCmCloseAddressFamilyComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisAfHandle
//  );

#define NdisMCmCloseAddressFamilyComplete(_S_, _H_)     \
                                        NdisCmCloseAddressFamilyComplete(_S_, _H_)



// EXPORT
// VOID
// NdisMCmRegisterSapComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisSapHandle,
//  IN  NDIS_HANDLE             CallMgrSapContext
//  );

#define NdisMCmRegisterSapComplete(_S_, _H_, _C_)       \
                                        NdisCmRegisterSapComplete(_S_, _H_, _C_)


// EXPORT
// VOID
// NdisMCmDeregisterSapComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisSapHandle
//  );

#define NdisMCmDeregisterSapComplete(_S_, _H_)          \
                                        NdisCmDeregisterSapComplete(_S_, _H_)


// EXPORT
// VOID
// NdisMCmMakeCallComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisVcHandle,
//  IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
//  IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
//  IN  PCO_CALL_PARAMETERS     CallParameters
//  );

#define NdisMCmMakeCallComplete(_S_, _VH_, _PH_, _CC_, _CP_)    \
                                        NdisCmMakeCallComplete(_S_, _VH_, _PH_, _CC_, _CP_)


// EXPORT
// VOID
// NdisMCmCloseCallComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisVcHandle,
//  IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL
//  );

#define NdisMCmCloseCallComplete(_S_, _VH_, _PH_)       \
                                        NdisCmCloseCallComplete(_S_, _VH_, _PH_)


// EXPORT
// VOID
// NdisMCmAddPartyComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisPartyHandle,
//  IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
//  IN  PCO_CALL_PARAMETERS     CallParameters
//  );

#define NdisMCmAddPartyComplete(_S_, _H_, _C_, _P_)     \
                                        NdisCmAddPartyComplete(_S_, _H_, _C_, _P_)


// EXPORT
// VOID
// NdisMCmDropPartyComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisPartyHandle
//  );

#define NdisMCmDropPartyComplete(_S_, _H_)              \
                                        NdisCmDropPartyComplete(_S_, _H_)


// EXPORT
// NDIS_STATUS
// NdisMCmDispatchIncomingCall(
//  IN  NDIS_HANDLE             NdisSapHandle,
//  IN  NDIS_HANDLE             NdisVcHandle,
//  IN  PCO_CALL_PARAMETERS     CallParameters
//  );

#define NdisMCmDispatchIncomingCall(_SH_, _VH_, _CP_)   \
                                        NdisCmDispatchIncomingCall(_SH_, _VH_, _CP_)


// EXPORT
// VOID
// NdisMCmDispatchCallConnected(
//  IN  NDIS_HANDLE             NdisVcHandle
//  );

#define NdisMCmDispatchCallConnected(_H_)               \
                                        NdisCmDispatchCallConnected(_H_)


// EXPORT
// NdisMCmModifyCallQoSComplete(
//  IN  NDIS_STATUS             Status,
//  IN  NDIS_HANDLE             NdisVcHandle,
//  IN  PCO_CALL_PARAMETERS     CallParameters
//  );

#define NdisMCmModifyCallQoSComplete(_S_, _H_, _P_)     \
                                        NdisCmModifyCallQoSComplete(_S_, _H_, _P_)


// EXPORT
// VOID
// VOID
// NdisMCmDispatchIncomingCallQoSChange(
//  IN  NDIS_HANDLE             NdisVcHandle,
//  IN  PCO_CALL_PARAMETERS     CallParameters
//  );

#define NdisMCmDispatchIncomingCallQoSChange(_H_, _P_)  \
                                        NdisCmDispatchIncomingCallQoSChange(_H_, _P_)


// EXPORT
// VOID
// NdisMCmDispatchIncomingCloseCall(
//   IN  NDIS_STATUS             CloseStatus,
//   IN  NDIS_HANDLE             NdisVcHandle,
//   IN  PVOID                   Buffer         OPTIONAL,
//   IN  UINT                    Size
//   );

#define NdisMCmDispatchIncomingCloseCall(_S_, _H_, _B_, _Z_)    \
                                        NdisCmDispatchIncomingCloseCall(_S_, _H_, _B_, _Z_)


//  EXPORT
//  VOID
//  NdisMCmDispatchIncomingDropParty(
//      IN  NDIS_STATUS         DropStatus,
//      IN  NDIS_HANDLE         NdisPartyHandle,
//      IN  PVOID               Buffer      OPTIONAL,
//      IN  UINT                Size
//      );
#define NdisMCmDispatchIncomingDropParty(_S_, _H_, _B_, _Z_)    \
                                        NdisCmDispatchIncomingDropParty(_S_, _H_, _B_, _Z_)


#if NDIS_SUPPORT_NDIS6

EXPORT
NDIS_STATUS
NdisMRegisterScatterGatherDma(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_SG_DMA_DESCRIPTION        DmaDescription,
    OUT PNDIS_HANDLE                    NdisMiniportDmaHandle
    );

EXPORT
VOID
NdisMDeregisterScatterGatherDma(
    IN  NDIS_HANDLE                     NdisMiniportDmaHandle
    );

//
// flags used in the call to NdisMAllocateNetBufferSGList
//
#define NDIS_SG_LIST_WRITE_TO_DEVICE    0x000000001

EXPORT
NDIS_STATUS
NdisMAllocateNetBufferSGList(
    IN  NDIS_HANDLE             NdisMiniportDmaHandle,
    IN  PNET_BUFFER             NetBuffer,
    IN  PVOID                   Context,
    IN  ULONG                   Flags,
    IN  PVOID                   ScatterGatherListBuffer OPTIONAL,
    IN  ULONG                   ScatterGatherListBufferSize OPTIONAL
    );

EXPORT
VOID
NdisMFreeNetBufferSGList(
    IN  NDIS_HANDLE             NdisMiniportDmaHandle,
    IN  PSCATTER_GATHER_LIST    pSGL,
    IN  PNET_BUFFER             NetBuffer
    );

EXPORT
NDIS_STATUS
NdisMRegisterMiniportDriver(
    IN  PDRIVER_OBJECT                              DriverObject,
    IN  PUNICODE_STRING                             RegistryPath,
    IN  NDIS_HANDLE                                 MiniportDriverContext,
    IN  PNDIS_MINIPORT_DRIVER_CHARACTERISTICS       MiniportDriverCharacteristics,
    OUT PNDIS_HANDLE                                NdisMiniportDriverHandle
    );

EXPORT
VOID
NdisMDeregisterMiniportDriver(
    IN NDIS_HANDLE              NdisMiniportDriverHandle
    );

EXPORT
VOID
NdisMPauseComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    );

EXPORT
VOID
NdisMRestartComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status
    );


EXPORT
VOID
NdisMOidRequestComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );
    

EXPORT
VOID
NdisMSendNetBufferListsComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNET_BUFFER_LIST        NetBufferList,
    IN  ULONG                   SendCompleteFlags
    );

EXPORT
VOID
NdisMIndicateReceiveNetBufferLists(
    IN  NDIS_HANDLE             MiniportAdapterHandle, 
    IN  PNET_BUFFER_LIST        NetBufferList,
    IN  NDIS_PORT_NUMBER        PortNumber,
    IN  ULONG                   NumberOfNetBufferLists,
    IN  ULONG                   ReceiveFlags
    );


//
// IO workitem routines
//

EXPORT
NDIS_HANDLE
NdisAllocateIoWorkItem(
    IN  NDIS_HANDLE                 NdisObjectHandle
    );

typedef
VOID
(*NDIS_IO_WORKITEM_ROUTINE)(
    IN PVOID                        WorkItemContext,
    IN NDIS_HANDLE                  NdisIoWorkItemHandle
    );

EXPORT
VOID
NdisQueueIoWorkItem(
    IN NDIS_HANDLE                  NdisIoWorkItemHandle,
    IN NDIS_IO_WORKITEM_ROUTINE     Routine,
    IN PVOID                        WorkItemContext
    );

EXPORT
VOID
NdisFreeIoWorkItem(
    IN NDIS_HANDLE                  NdisIoWorkItemHandle
    );

//
// CONDIS 6.0 extensions
//

EXPORT
VOID
NdisMCoSendNetBufferListsComplete(
    IN NDIS_HANDLE          NdisVcHandle,
    IN PNET_BUFFER_LIST     NetBufferLists,
    IN ULONG                SendCompleteFlags
    );

EXPORT
VOID
NdisMCoIndicateReceiveNetBufferLists(
    IN NDIS_HANDLE          NdisVcHandle,
    IN PNET_BUFFER_LIST     NetBufferLists,
    IN ULONG                NumberOfNetBufferLists,
    IN ULONG                CoReceiveFlags
    );

EXPORT
NDIS_STATUS
NdisMNetPnPEvent(
    IN  NDIS_HANDLE                 MiniportAdapterHandle,
    IN  PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification
    );

EXPORT
VOID
NdisMResetComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status,
    IN  BOOLEAN                 AddressingReset
    );

EXPORT
ULONG
NdisMGetBusData(
    IN NDIS_HANDLE              NdisMiniportHandle,
    IN ULONG                    WhichSpace,
    IN ULONG                    Offset,
    __out_bcount_full(Length) IN PVOID  Buffer,
    IN ULONG                    Length
    );

EXPORT
ULONG
NdisMSetBusData(
    IN NDIS_HANDLE              NdisMiniportHandle,
    IN ULONG                    WhichSpace,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    );

//
// NDIS port APIs
//

EXPORT
NDIS_STATUS
NdisMAllocatePort(
    IN  NDIS_HANDLE                     NdisMiniportHandle,
    IN  OUT PNDIS_PORT_CHARACTERISTICS  PortCharacteristics
    );

EXPORT
NDIS_STATUS
NdisMFreePort(
    IN  NDIS_HANDLE                     NdisMiniportHandle,
    IN  NDIS_PORT_NUMBER                PortNumber
    );

#if (NDIS_SUPPORT_NDIS61)
EXPORT
VOID
NdisMDirectOidRequestComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );

typedef enum _NDIS_MSIX_TABLE_CONFIG
{
    NdisMSIXTableConfigSetTableEntry,
    NdisMSIXTableConfigMaskTableEntry,
    NdisMSIXTableConfigUnmaskTableEntry,
    NdisMSIXTableConfigMax
}NDIS_MSIX_TABLE_OPERATION, *PNDIS_MSIX_TABLE_OPERATION;

#define NDIS_MSIX_CONFIG_PARAMETERS_REVISION_1          1

typedef struct _NDIS_MSIX_CONFIG_PARAMETERS
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_MSIX_TABLE_OPERATION       ConfigOperation;
    ULONG                           TableEntry;
    ULONG                           MessageNumber;
}NDIS_MSIX_CONFIG_PARAMETERS, *PNDIS_MSIX_CONFIG_PARAMETERS;

#define NDIS_SIZEOF_MSIX_CONFIG_PARAMETERS_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_MSIX_CONFIG_PARAMETERS, MessageNumber)

EXPORT
NDIS_STATUS
NdisMConfigMSIXTableEntry(
    IN  NDIS_HANDLE                     NdisMiniportHandle,
    IN  PNDIS_MSIX_CONFIG_PARAMETERS    MSIXConfigParameters
    );
    
#endif // (NDIS_SUPPORT_NDIS61)

#endif // NDIS_SUPPORT_NDIS6



#pragma once

typedef struct _CO_CALL_PARAMETERS      CO_CALL_PARAMETERS, *PCO_CALL_PARAMETERS;
typedef struct _CO_MEDIA_PARAMETERS     CO_MEDIA_PARAMETERS, *PCO_MEDIA_PARAMETERS;

//
// CoNdis client only handler proto-types - used by clients of call managers
//
typedef
VOID
(*CL_OPEN_AF_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisAfHandle
    );

typedef
VOID
(*CL_CLOSE_AF_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext
    );

typedef
VOID
(*CL_REG_SAP_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle
    );

typedef
VOID
(*CL_DEREG_SAP_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolSapContext
    );

typedef
VOID
(*CL_MAKE_CALL_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

typedef
VOID
(*CL_CLOSE_CALL_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    );

typedef
VOID
(*CL_ADD_PARTY_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

typedef
VOID
(*CL_DROP_PARTY_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolPartyContext
    );

typedef
NDIS_STATUS
(*CL_INCOMING_CALL_HANDLER)(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );

typedef
VOID
(*CL_CALL_CONNECTED_HANDLER)(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

typedef
VOID
(*CL_INCOMING_CLOSE_CALL_HANDLER)(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );

typedef
VOID
(*CL_INCOMING_DROP_PARTY_HANDLER)(
    IN  NDIS_STATUS             DropStatus,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );

typedef
VOID
(*CL_MODIFY_CALL_QOS_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

typedef
VOID
(*CL_INCOMING_CALL_QOS_CHANGE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

#if NDIS_LEGACY_PROTOCOL
typedef struct _NDIS_CLIENT_CHARACTERISTICS
{
    UCHAR                           MajorVersion;
    UCHAR                           MinorVersion;

    USHORT                          Filler;
    UINT                            Reserved;

    CO_CREATE_VC_HANDLER            ClCreateVcHandler;
    CO_DELETE_VC_HANDLER            ClDeleteVcHandler;
    CO_REQUEST_HANDLER              ClRequestHandler;
    CO_REQUEST_COMPLETE_HANDLER     ClRequestCompleteHandler;
    CL_OPEN_AF_COMPLETE_HANDLER     ClOpenAfCompleteHandler;
    CL_CLOSE_AF_COMPLETE_HANDLER    ClCloseAfCompleteHandler;
    CL_REG_SAP_COMPLETE_HANDLER     ClRegisterSapCompleteHandler;
    CL_DEREG_SAP_COMPLETE_HANDLER   ClDeregisterSapCompleteHandler;
    CL_MAKE_CALL_COMPLETE_HANDLER   ClMakeCallCompleteHandler;
    CL_MODIFY_CALL_QOS_COMPLETE_HANDLER ClModifyCallQoSCompleteHandler;
    CL_CLOSE_CALL_COMPLETE_HANDLER  ClCloseCallCompleteHandler;
    CL_ADD_PARTY_COMPLETE_HANDLER   ClAddPartyCompleteHandler;
    CL_DROP_PARTY_COMPLETE_HANDLER  ClDropPartyCompleteHandler;
    CL_INCOMING_CALL_HANDLER        ClIncomingCallHandler;
    CL_INCOMING_CALL_QOS_CHANGE_HANDLER ClIncomingCallQoSChangeHandler;
    CL_INCOMING_CLOSE_CALL_HANDLER  ClIncomingCloseCallHandler;
    CL_INCOMING_DROP_PARTY_HANDLER  ClIncomingDropPartyHandler;
    CL_CALL_CONNECTED_HANDLER       ClCallConnectedHandler;

} NDIS_CLIENT_CHARACTERISTICS, *PNDIS_CLIENT_CHARACTERISTICS;
#endif // NDIS_LEGACY_PROTOCOL

//
// CoNdis call-manager only handler proto-types - used by call managers only
//
typedef
NDIS_STATUS
(*CM_OPEN_AF_HANDLER)(
    IN  NDIS_HANDLE             CallMgrBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             NdisAfHandle,
    OUT PNDIS_HANDLE            CallMgrAfContext
    );

typedef
NDIS_STATUS
(*CM_CLOSE_AF_HANDLER)(
    IN  NDIS_HANDLE             CallMgrAfContext
    );

typedef
NDIS_STATUS
(*CM_REG_SAP_HANDLER)(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    );

typedef
NDIS_STATUS
(*CM_DEREG_SAP_HANDLER)(
    IN  NDIS_HANDLE             CallMgrSapContext
    );

typedef
NDIS_STATUS
(*CM_MAKE_CALL_HANDLER)(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    OUT PNDIS_HANDLE            CallMgrPartyContext OPTIONAL
    );

typedef
NDIS_STATUS
(*CM_CLOSE_CALL_HANDLER)(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PVOID                   CloseData           OPTIONAL,
    IN  UINT                    Size                OPTIONAL
    );

typedef
NDIS_STATUS
(*CM_MODIFY_CALL_QOS_HANDLER)(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

typedef
VOID
(*CM_INCOMING_CALL_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

typedef
VOID
(*CM_ACTIVATE_VC_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

typedef
VOID
(*CM_DEACTIVATE_VC_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext
    );

typedef
NDIS_STATUS
(*CM_ADD_PARTY_HANDLER)(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            CallMgrPartyContext
    );

typedef
NDIS_STATUS
(*CM_DROP_PARTY_HANDLER)(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );

#if NDIS_LEGACY_DRIVER

typedef struct _NDIS_CALL_MANAGER_CHARACTERISTICS
{
    UCHAR                           MajorVersion;
    UCHAR                           MinorVersion;
    USHORT                          Filler;
    UINT                            Reserved;

    CO_CREATE_VC_HANDLER            CmCreateVcHandler;
    CO_DELETE_VC_HANDLER            CmDeleteVcHandler;
    CM_OPEN_AF_HANDLER              CmOpenAfHandler;
    CM_CLOSE_AF_HANDLER             CmCloseAfHandler;
    CM_REG_SAP_HANDLER              CmRegisterSapHandler;
    CM_DEREG_SAP_HANDLER            CmDeregisterSapHandler;
    CM_MAKE_CALL_HANDLER            CmMakeCallHandler;
    CM_CLOSE_CALL_HANDLER           CmCloseCallHandler;
    CM_INCOMING_CALL_COMPLETE_HANDLER CmIncomingCallCompleteHandler;
    CM_ADD_PARTY_HANDLER            CmAddPartyHandler;
    CM_DROP_PARTY_HANDLER           CmDropPartyHandler;
    CM_ACTIVATE_VC_COMPLETE_HANDLER CmActivateVcCompleteHandler;
    CM_DEACTIVATE_VC_COMPLETE_HANDLER CmDeactivateVcCompleteHandler;
    CM_MODIFY_CALL_QOS_HANDLER      CmModifyCallQoSHandler;
    CO_REQUEST_HANDLER              CmRequestHandler;
    CO_REQUEST_COMPLETE_HANDLER     CmRequestCompleteHandler;
    
} NDIS_CALL_MANAGER_CHARACTERISTICS, *PNDIS_CALL_MANAGER_CHARACTERISTICS;

#endif // NDIS_LEGACY_DRIVER

//
// this send flag is used on ATM net cards to set ( turn on ) the CLP bit
// (Cell Loss Priority) bit
//
#define CO_SEND_FLAG_SET_DISCARD_ELIBILITY  0x00000001

//
// the Address structure used on NDIS_CO_ADD_ADDRESS or NDIS_CO_DELETE_ADDRESS
//
typedef struct _CO_ADDRESS
{
    ULONG                       AddressSize;
    UCHAR                       Address[1];
} CO_ADDRESS, *PCO_ADDRESS;

//
// the list of addresses returned from the CallMgr on a NDIS_CO_GET_ADDRESSES
//
typedef struct _CO_ADDRESS_LIST
{
    ULONG                       NumberOfAddressesAvailable;
    ULONG                       NumberOfAddresses;
    CO_ADDRESS                  AddressList;
} CO_ADDRESS_LIST, *PCO_ADDRESS_LIST;

#ifndef FAR
#define FAR
#endif
#include <qos.h>

typedef struct _CO_SPECIFIC_PARAMETERS
{
    ULONG                       ParamType;
    ULONG                       Length;
    UCHAR                       Parameters[1];
} CO_SPECIFIC_PARAMETERS, *PCO_SPECIFIC_PARAMETERS;

typedef struct _CO_CALL_MANAGER_PARAMETERS
{
    FLOWSPEC                    Transmit;
    FLOWSPEC                    Receive;
    CO_SPECIFIC_PARAMETERS      CallMgrSpecific;
} CO_CALL_MANAGER_PARAMETERS, *PCO_CALL_MANAGER_PARAMETERS;


//
// this is the generic portion of the media parameters, including the media
// specific component too.
//
typedef struct _CO_MEDIA_PARAMETERS
{
    ULONG                       Flags;
    ULONG                       ReceivePriority;
    ULONG                       ReceiveSizeHint;
    CO_SPECIFIC_PARAMETERS POINTER_ALIGNMENT      MediaSpecific;
} CO_MEDIA_PARAMETERS, *PCO_MEDIA_PARAMETERS;


//
// definitions for the flags in CO_MEDIA_PARAMETERS
//
#define RECEIVE_TIME_INDICATION 0x00000001
#define USE_TIME_STAMPS         0x00000002
#define TRANSMIT_VC             0x00000004
#define RECEIVE_VC              0x00000008
#define INDICATE_ERRED_PACKETS  0x00000010
#define INDICATE_END_OF_TX      0x00000020
#define RESERVE_RESOURCES_VC    0x00000040
#define ROUND_DOWN_FLOW         0x00000080
#define ROUND_UP_FLOW           0x00000100
//
// define a flag to set in the flags of an Ndis packet when the miniport
// indicates a receive with an error in it
//
#define ERRED_PACKET_INDICATION 0x00000001

//
// this is the structure passed during call-setup
//
typedef struct _CO_CALL_PARAMETERS
{
    ULONG                       Flags;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParameters;
    PCO_MEDIA_PARAMETERS        MediaParameters;
} CO_CALL_PARAMETERS, *PCO_CALL_PARAMETERS;

//
// Definitions for the Flags in CO_CALL_PARAMETERS
//
#define PERMANENT_VC            0x00000001
#define CALL_PARAMETERS_CHANGED 0x00000002
#define QUERY_CALL_PARAMETERS   0x00000004
#define BROADCAST_VC            0x00000008
#define MULTIPOINT_VC           0x00000010

//
// The format of the Request for adding/deleting a PVC
//
typedef struct _CO_PVC
{
    NDIS_HANDLE                 NdisAfHandle;
    CO_SPECIFIC_PARAMETERS      PvcParameters;
} CO_PVC,*PCO_PVC;



//
// NDIS 5.0 Extensions for protocols
//

EXPORT
NDIS_STATUS
NdisCoAssignInstanceName(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PNDIS_STRING            BaseInstanceName,
    OUT PNDIS_STRING            VcInstanceName
    );

#if NDIS_LEGACY_PROTOCOL
EXPORT
VOID
NdisCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

#endif // NDIS_LEGACY_PROTOCOL

EXPORT
NDIS_STATUS
NdisCoCreateVc(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle        OPTIONAL,   // For CM signalling VCs
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PNDIS_HANDLE         NdisVcHandle
    );


EXPORT
NDIS_STATUS
NdisCoDeleteVc(
    IN  NDIS_HANDLE             NdisVcHandle
    );

#if NDIS_LEGACY_PROTOCOL
EXPORT
NDIS_STATUS
NdisCoRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );


EXPORT
VOID
NdisCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    );

#endif // NDIS_LEGACY_PROTOCOL

#ifndef __NDISTAPI_VAR_STRING_DECLARED
#define __NDISTAPI_VAR_STRING_DECLARED

typedef struct _VAR_STRING
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulStringFormat;
    ULONG   ulStringSize;
    ULONG   ulStringOffset;

} VAR_STRING, *PVAR_STRING;

#endif // __NDISTAPI_VAR_STRING_DECLARED


#ifndef __NDISTAPI_STRINGFORMATS_DEFINED
#define __NDISTAPI_STRINGFORMATS_DEFINED

#define STRINGFORMAT_ASCII                          0x00000001
#define STRINGFORMAT_DBCS                           0x00000002
#define STRINGFORMAT_UNICODE                        0x00000003
#define STRINGFORMAT_BINARY                         0x00000004

#endif // __NDISTAPI_STRINGFORMATS_DEFINED

EXPORT
NDIS_STATUS
NdisCoGetTapiCallId(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  OUT PVAR_STRING         TapiCallId
    );

#if NDIS_LEGACY_PROTOCOL
//
// Client Apis
//
EXPORT
NDIS_STATUS
NdisClOpenAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  PNDIS_CLIENT_CHARACTERISTICS ClCharacteristics,
    IN  UINT                    SizeOfClCharacteristics,
    OUT PNDIS_HANDLE            NdisAfHandle
    );

#endif // NDIS_LEGACY_PROTOCOL

EXPORT
NDIS_STATUS
NdisClCloseAddressFamily(
    IN  NDIS_HANDLE             NdisAfHandle
    );


EXPORT
NDIS_STATUS
NdisClRegisterSap(
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  PCO_SAP                 Sap,
    OUT PNDIS_HANDLE            NdisSapHandle
    );


EXPORT
NDIS_STATUS
NdisClDeregisterSap(
    IN  NDIS_HANDLE             NdisSapHandle
    );


EXPORT
NDIS_STATUS
NdisClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle         OPTIONAL
    );


EXPORT
NDIS_STATUS
NdisClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    IN  PVOID                   Buffer                  OPTIONAL,
    IN  UINT                    Size                    OPTIONAL
    );


EXPORT
NDIS_STATUS
NdisClModifyCallQoS(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


EXPORT
VOID
NdisClIncomingCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


EXPORT
NDIS_STATUS
NdisClAddParty(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    OUT PNDIS_HANDLE            NdisPartyHandle
    );


EXPORT
NDIS_STATUS
NdisClDropParty(
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PVOID                   Buffer      OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );


EXPORT
NDIS_STATUS
NdisClGetProtocolVcContextFromTapiCallId(
    IN  UNICODE_STRING          TapiCallId,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

//
// Call Manager Apis
//

#if NDIS_LEGACY_DRIVER
EXPORT
NDIS_STATUS
NdisCmRegisterAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  PNDIS_CALL_MANAGER_CHARACTERISTICS CmCharacteristics,
    IN  UINT                    SizeOfCmCharacteristics
    );

#endif

EXPORT
VOID
NdisCmOpenAddressFamilyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             CallMgrAfContext
    );


EXPORT
VOID
NdisCmCloseAddressFamilyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle
    );


EXPORT
VOID
NdisCmRegisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisSapHandle,
    IN  NDIS_HANDLE             CallMgrSapContext
    );


EXPORT
VOID
NdisCmDeregisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisSapHandle
    );


EXPORT
NDIS_STATUS
NdisCmActivateVc(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );


EXPORT
NDIS_STATUS
NdisCmDeactivateVc(
    IN  NDIS_HANDLE             NdisVcHandle
    );


EXPORT
VOID
NdisCmMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


EXPORT
VOID
NdisCmCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL
    );


EXPORT
VOID
NdisCmAddPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


EXPORT
VOID
NdisCmDropPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisPartyHandle
    );


EXPORT
NDIS_STATUS
NdisCmDispatchIncomingCall(
    IN  NDIS_HANDLE             NdisSapHandle,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


EXPORT
VOID
NdisCmDispatchCallConnected(
    IN  NDIS_HANDLE             NdisVcHandle
    );


EXPORT
VOID
NdisCmModifyCallQoSComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


EXPORT
VOID
NdisCmDispatchIncomingCallQoSChange(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


EXPORT
VOID
NdisCmDispatchIncomingCloseCall(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PVOID                   Buffer      OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );


EXPORT
VOID
NdisCmDispatchIncomingDropParty(
    IN  NDIS_STATUS             DropStatus,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PVOID                   Buffer      OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );

#if (NDIS_SUPPORT_NDIS6)

//
// CONDIS 6.0 extensions
//
#define NDIS_CO_CLIENT_OPTIONAL_HANDLERS_REVISION_1     1

typedef struct _NDIS_CO_CLIENT_OPTIONAL_HANDLERS
{
    NDIS_OBJECT_HEADER                      Header;
    ULONG                                   Reserved;
    
    CO_CREATE_VC_HANDLER                ClCreateVcHandler;
    CO_DELETE_VC_HANDLER                ClDeleteVcHandler;
    CO_OID_REQUEST_HANDLER              ClOidRequestHandler;
    CO_OID_REQUEST_COMPLETE_HANDLER     ClOidRequestCompleteHandler;
    CL_OPEN_AF_COMPLETE_HANDLER_EX      ClOpenAfCompleteHandlerEx;
    CL_CLOSE_AF_COMPLETE_HANDLER        ClCloseAfCompleteHandler;
    CL_REG_SAP_COMPLETE_HANDLER         ClRegisterSapCompleteHandler;
    CL_DEREG_SAP_COMPLETE_HANDLER       ClDeregisterSapCompleteHandler;
    CL_MAKE_CALL_COMPLETE_HANDLER       ClMakeCallCompleteHandler;
    CL_MODIFY_CALL_QOS_COMPLETE_HANDLER ClModifyCallQoSCompleteHandler;
    CL_CLOSE_CALL_COMPLETE_HANDLER      ClCloseCallCompleteHandler;
    CL_ADD_PARTY_COMPLETE_HANDLER       ClAddPartyCompleteHandler;
    CL_DROP_PARTY_COMPLETE_HANDLER      ClDropPartyCompleteHandler;
    CL_INCOMING_CALL_HANDLER            ClIncomingCallHandler;
    CL_INCOMING_CALL_QOS_CHANGE_HANDLER ClIncomingCallQoSChangeHandler;
    CL_INCOMING_CLOSE_CALL_HANDLER      ClIncomingCloseCallHandler;
    CL_INCOMING_DROP_PARTY_HANDLER      ClIncomingDropPartyHandler;
    CL_CALL_CONNECTED_HANDLER           ClCallConnectedHandler;
    CL_NOTIFY_CLOSE_AF_HANDLER          ClNotifyCloseAfHandler;
}NDIS_CO_CLIENT_OPTIONAL_HANDLERS, *PNDIS_CO_CLIENT_OPTIONAL_HANDLERS; 

#define NDIS_SIZEOF_CO_CLIENT_OPTIONAL_HANDLERS_REVISION_1  \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_CO_CLIENT_OPTIONAL_HANDLERS, ClNotifyCloseAfHandler)

#define  NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS_REVISION_1     1  

typedef struct _NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS
{
    NDIS_OBJECT_HEADER              Header;
    ULONG                           Reserved;
    CO_CREATE_VC_HANDLER            CmCreateVcHandler;
    CO_DELETE_VC_HANDLER            CmDeleteVcHandler;
    CM_OPEN_AF_HANDLER              CmOpenAfHandler;
    CM_CLOSE_AF_HANDLER             CmCloseAfHandler;
    CM_REG_SAP_HANDLER              CmRegisterSapHandler;
    CM_DEREG_SAP_HANDLER            CmDeregisterSapHandler;
    CM_MAKE_CALL_HANDLER            CmMakeCallHandler;
    CM_CLOSE_CALL_HANDLER           CmCloseCallHandler;
    CM_INCOMING_CALL_COMPLETE_HANDLER CmIncomingCallCompleteHandler;
    CM_ADD_PARTY_HANDLER            CmAddPartyHandler;
    CM_DROP_PARTY_HANDLER           CmDropPartyHandler;
    CM_ACTIVATE_VC_COMPLETE_HANDLER CmActivateVcCompleteHandler;
    CM_DEACTIVATE_VC_COMPLETE_HANDLER CmDeactivateVcCompleteHandler;
    CM_MODIFY_CALL_QOS_HANDLER      CmModifyCallQoSHandler;
    CO_OID_REQUEST_HANDLER          CmOidRequestHandler;
    CO_OID_REQUEST_COMPLETE_HANDLER CmOidRequestCompleteHandler;
    CM_NOTIFY_CLOSE_AF_COMPLETE_HANDLER           CmNotifyCloseAfCompleteHandler;

} NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS, *PNDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS;

#define NDIS_SIZEOF_CO_CALL_MANAGER_OPTIONAL_HANDLERS_REVISION_1  \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_CO_CALL_MANAGER_OPTIONAL_HANDLERS, CmOidRequestCompleteHandler)


EXPORT
VOID
NdisCoSendNetBufferLists(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  ULONG                   SendFlags
    );

EXPORT
NDIS_STATUS
NdisCoOidRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN OUT PNDIS_OID_REQUEST    OidRequest
    );


EXPORT
VOID
NdisCoOidRequestComplete(
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );

EXPORT
NDIS_STATUS
NdisClOpenAddressFamilyEx (
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             ClientAfContext,
    OUT PNDIS_HANDLE            NdisAfHandle
    );

EXPORT
NDIS_STATUS
NdisCmRegisterAddressFamilyEx(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    );

EXPORT
NDIS_STATUS
NdisMCmRegisterAddressFamilyEx(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    );

EXPORT
NDIS_STATUS
NdisCmNotifyCloseAddressFamily (
    IN  NDIS_HANDLE             NdisAfHandle 
    );

EXPORT
VOID
NdisClNotifyCloseAddressFamilyComplete (
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_STATUS              Status
    );


#endif // NDIS_SUPPORT_NDIS6




#pragma once

#if NDIS_SUPPORT_NDIS6
//
// Ndis Light Weight filters
// 

    
//
// init / de-init
//

//
// Flags used in NDIS_FILTER_ATTACH_PARAMETERS
//

#define NDIS_FILTER_ATTACH_FLAGS_IGNORE_MANDATORY          0x00000001   // If a mandatory filter fails to attach, it can set the flag
                                                                        // to ask NDIS to ignore it is a mandatory filter


#define NDIS_FILTER_ATTACH_PARAMETERS_REVISION_1     1

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_FILTER_ATTACH_PARAMETERS_REVISION_2     2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_FILTER_ATTACH_PARAMETERS
{
    IN NDIS_OBJECT_HEADER          Header;
    IN NET_IFINDEX                 IfIndex;
    IN NET_LUID                    NetLuid;
    IN PNDIS_STRING                FilterModuleGuidName;
    IN NET_IFINDEX                 BaseMiniportIfIndex;
    IN PNDIS_STRING                BaseMiniportInstanceName;
    IN PNDIS_STRING                BaseMiniportName;
    IN NDIS_MEDIA_CONNECT_STATE    MediaConnectState;
    IN NET_IF_MEDIA_DUPLEX_STATE   MediaDuplexState;
    IN ULONG64                     XmitLinkSpeed;
    IN ULONG64                     RcvLinkSpeed;
    IN OUT NDIS_MEDIUM             MiniportMediaType;
    IN OUT NDIS_PHYSICAL_MEDIUM    MiniportPhysicalMediaType;
    IN NDIS_HANDLE                 MiniportMediaSpecificAttributes;
    IN PNDIS_OFFLOAD               DefaultOffloadConfiguration;
    IN USHORT                      MacAddressLength;
    IN UCHAR                       CurrentMacAddress[NDIS_MAX_PHYS_ADDRESS_LENGTH];
    IN NET_LUID                    BaseMiniportNetLuid;
    IN NET_IFINDEX                 LowerIfIndex;
    IN NET_LUID                    LowerIfNetLuid;
    IN OUT ULONG                   Flags;
#if (NDIS_SUPPORT_NDIS61)
    IN PNDIS_HD_SPLIT_CURRENT_CONFIG HDSplitCurrentConfig;
#endif // (NDIS_SUPPORT_NDIS61)
} NDIS_FILTER_ATTACH_PARAMETERS, *PNDIS_FILTER_ATTACH_PARAMETERS;
#define NDIS_SIZEOF_FILTER_ATTACH_PARAMETERS_REVISION_1  \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_FILTER_ATTACH_PARAMETERS, Flags)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_FILTER_ATTACH_PARAMETERS_REVISION_2  \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_FILTER_ATTACH_PARAMETERS, HDSplitCurrentConfig)
#endif // (NDIS_SUPPORT_NDIS61)

typedef
NDIS_STATUS
(*FILTER_ATTACH_HANDLER)(
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  NDIS_HANDLE                     FilterDriverContext,
    IN  PNDIS_FILTER_ATTACH_PARAMETERS  AttachParameters
    );

typedef
VOID
(*FILTER_DETACH_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext
    );

typedef
NDIS_STATUS
(*FILTER_SET_FILTER_MODULE_OPTIONS_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext
    );


#define NDIS_FILTER_RESTART_PARAMETERS_REVISION_1     1


typedef struct _NDIS_FILTER_RESTART_PARAMETERS
{
    NDIS_OBJECT_HEADER          Header;
    NDIS_MEDIUM                 MiniportMediaType;
    NDIS_PHYSICAL_MEDIUM        MiniportPhysicalMediaType;
    PNDIS_RESTART_ATTRIBUTES    RestartAttributes;
    NET_IFINDEX                 LowerIfIndex;
    NET_LUID                    LowerIfNetLuid;    
    ULONG                       Flags;    
} NDIS_FILTER_RESTART_PARAMETERS, *PNDIS_FILTER_RESTART_PARAMETERS;

#define NDIS_SIZEOF__FILTER_RESTART_PARAMETERS_REVISION_1  \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_FILTER_RESTART_PARAMETERS, Flags)

typedef
NDIS_STATUS
(*FILTER_RESTART_HANDLER)(
    IN  NDIS_HANDLE                     FilterModuleContext,
    IN  PNDIS_FILTER_RESTART_PARAMETERS RestartParameters
    );

#define NDIS_FILTER_PAUSE_PARAMETERS_REVISION_1     1

typedef struct _NDIS_FILTER_PAUSE_PARAMETERS
{
    NDIS_OBJECT_HEADER          Header;
    ULONG                       Flags;
    ULONG                       PauseReason;
} NDIS_FILTER_PAUSE_PARAMETERS, *PNDIS_FILTER_PAUSE_PARAMETERS;

#define NDIS_SIZEOF_FILTER_PAUSE_PARAMETERS_REVISION_1   \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_FILTER_PAUSE_PARAMETERS, Flags)

typedef
NDIS_STATUS
(*FILTER_PAUSE_HANDLER)(
    IN  NDIS_HANDLE                     FilterModuleContext,
    IN  PNDIS_FILTER_PAUSE_PARAMETERS   PauseParameters
    );

//
// inbound requests/data
//

typedef
NDIS_STATUS
(*FILTER_OID_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNDIS_OID_REQUEST       OidRequest
    );    

typedef
VOID
(*FILTER_CANCEL_OID_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PVOID                   RequestId
    );


typedef
VOID
(*FILTER_SEND_NET_BUFFER_LISTS_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNET_BUFFER_LIST        NetBufferList,
    IN  NDIS_PORT_NUMBER        PortNumber,
    IN  ULONG                   SendFlags
    );

typedef
VOID
(*FILTER_CANCEL_SEND_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PVOID                   CancelId
    );

typedef
VOID
(*FILTER_RETURN_NET_BUFFER_LISTS_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  ULONG                   ReturnFlags
    );

typedef
VOID
(*FILTER_SEND_NET_BUFFER_LISTS_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNET_BUFFER_LIST        NetBufferList,
    IN  ULONG                   SendCompleteFlags
    );

typedef
VOID
(*FILTER_RECEIVE_NET_BUFFER_LISTS_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  NDIS_PORT_NUMBER        PortNumber,
    IN  ULONG                   NumberOfNetBufferLists,
    IN  ULONG                   ReceiveFlags
    );

typedef 
VOID
(*FILTER_DEVICE_PNP_EVENT_NOTIFY_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNET_DEVICE_PNP_EVENT   NetDevicePnPEvent
    );


typedef
NDIS_STATUS
(*FILTER_NET_PNP_EVENT_HANDLER)(
    IN  NDIS_HANDLE                         FilterModuleContext,
    IN  PNET_PNP_EVENT_NOTIFICATION         NetPnPEventNotification
    );


typedef
VOID
(*FILTER_STATUS_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNDIS_STATUS_INDICATION StatusIndication
    );


typedef
VOID
(*FILTER_OID_REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );

#if (NDIS_SUPPORT_NDIS61)    
//
// NDIS 6.1 filter's entry points
//
typedef
NDIS_STATUS
(*FILTER_DIRECT_OID_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNDIS_OID_REQUEST       OidRequest
    );    

typedef
VOID
(*FILTER_DIRECT_OID_REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );    

typedef
VOID
(*FILTER_CANCEL_DIRECT_OID_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             FilterModuleContext,
    IN  PVOID                   RequestId
    );    
#endif (NDIS_SUPPORT_NDIS61)    

#define NDIS_FILTER_PARTIAL_CHARACTERISTICS_REVISION_1      1

typedef struct _NDIS_FILTER_PARTIAL_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER                              Header; // Header.Type = NDIS_OBJECT_TYPE_FILTER_PARTIAL_CHARACTERISTICS
    ULONG                                           Flags;
    FILTER_SEND_NET_BUFFER_LISTS_HANDLER            SendNetBufferListsHandler;
    FILTER_SEND_NET_BUFFER_LISTS_COMPLETE_HANDLER   SendNetBufferListsCompleteHandler;
    FILTER_CANCEL_SEND_HANDLER                      CancelSendNetBufferListsHandler;
    FILTER_RECEIVE_NET_BUFFER_LISTS_HANDLER         ReceiveNetBufferListsHandler;
    FILTER_RETURN_NET_BUFFER_LISTS_HANDLER          ReturnNetBufferListsHandler;
} NDIS_FILTER_PARTIAL_CHARACTERISTICS, *PNDIS_FILTER_PARTIAL_CHARACTERISTICS;

#define NDIS_SIZEOF_FILTER_PARTIAL_CHARACTERISTICS_REVISION_1   \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_FILTER_PARTIAL_CHARACTERISTICS, ReturnNetBufferListsHandler)

//
// Filter driver flags
//
#define NDIS_FILTER_DRIVER_MANDATORY                0x00000001

#define NDIS_FILTER_CHARACTERISTICS_REVISION_1      1

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_FILTER_CHARACTERISTICS_REVISION_2      2
#endif // (NDIS_SUPPORT_NDIS61)    

typedef struct _NDIS_FILTER_DRIVER_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER                              Header;
    UCHAR                                           MajorNdisVersion;
    UCHAR                                           MinorNdisVersion;
    UCHAR                                           MajorDriverVersion;
    UCHAR                                           MinorDriverVersion;
    ULONG                                           Flags;
    NDIS_STRING                                     FriendlyName;
    NDIS_STRING                                     UniqueName;
    NDIS_STRING                                     ServiceName;
    SET_OPTIONS_HANDLER                             SetOptionsHandler;
    FILTER_SET_FILTER_MODULE_OPTIONS_HANDLER        SetFilterModuleOptionsHandler;
    FILTER_ATTACH_HANDLER                           AttachHandler;
    FILTER_DETACH_HANDLER                           DetachHandler;
    FILTER_RESTART_HANDLER                          RestartHandler;
    FILTER_PAUSE_HANDLER                            PauseHandler;
    FILTER_SEND_NET_BUFFER_LISTS_HANDLER            SendNetBufferListsHandler;
    FILTER_SEND_NET_BUFFER_LISTS_COMPLETE_HANDLER   SendNetBufferListsCompleteHandler;
    FILTER_CANCEL_SEND_HANDLER                      CancelSendNetBufferListsHandler;
    FILTER_RECEIVE_NET_BUFFER_LISTS_HANDLER         ReceiveNetBufferListsHandler;
    FILTER_RETURN_NET_BUFFER_LISTS_HANDLER          ReturnNetBufferListsHandler;
    FILTER_OID_REQUEST_HANDLER                      OidRequestHandler;
    FILTER_OID_REQUEST_COMPLETE_HANDLER             OidRequestCompleteHandler;
    FILTER_CANCEL_OID_REQUEST_HANDLER               CancelOidRequestHandler;
    FILTER_DEVICE_PNP_EVENT_NOTIFY_HANDLER          DevicePnPEventNotifyHandler;
    FILTER_NET_PNP_EVENT_HANDLER                    NetPnPEventHandler;  
    FILTER_STATUS_HANDLER                           StatusHandler;
#if (NDIS_SUPPORT_NDIS61)    
    FILTER_DIRECT_OID_REQUEST_HANDLER               DirectOidRequestHandler;
    FILTER_DIRECT_OID_REQUEST_COMPLETE_HANDLER      DirectOidRequestCompleteHandler;
    FILTER_CANCEL_DIRECT_OID_REQUEST_HANDLER        CancelDirectOidRequestHandler;    
#endif // (NDIS_SUPPORT_NDIS61)        
} NDIS_FILTER_DRIVER_CHARACTERISTICS, *PNDIS_FILTER_DRIVER_CHARACTERISTICS;
#define NDIS_SIZEOF_FILTER_DRIVER_CHARACTERISTICS_REVISION_1   \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_FILTER_DRIVER_CHARACTERISTICS, StatusHandler)

#if (NDIS_SUPPORT_NDIS61)    
#define NDIS_SIZEOF_FILTER_DRIVER_CHARACTERISTICS_REVISION_2   \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_FILTER_DRIVER_CHARACTERISTICS, CancelDirectOidRequestHandler)
#endif //(NDIS_SUPPORT_NDIS61)    

#define NDIS_FILTER_ATTRIBUTES_REVISION_1       1

typedef struct _NDIS_FILTER_ATTRIBUTES
{
    NDIS_OBJECT_HEADER                      Header;
    ULONG                                   Flags;
} NDIS_FILTER_ATTRIBUTES, *PNDIS_FILTER_ATTRIBUTES;

#define NDIS_SIZEOF_FILTER_ATTRIBUTES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_FILTER_ATTRIBUTES, Flags)

EXPORT
NDIS_STATUS
NdisFRegisterFilterDriver(
    IN  PDRIVER_OBJECT                          DriverObject,
    IN  NDIS_HANDLE                             FilterDriverContext,
    IN  PNDIS_FILTER_DRIVER_CHARACTERISTICS     FilterDriverCharacteristics,
    OUT PNDIS_HANDLE                            NdisFilterDriverHandle
    );


EXPORT
VOID
NdisFDeregisterFilterDriver(
    IN NDIS_HANDLE                      NdisFilterDriverHandle
    );
    
EXPORT
NDIS_STATUS
NdisFSetAttributes(
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  NDIS_HANDLE                     FilterModuleContext,
    IN  PNDIS_FILTER_ATTRIBUTES         FilterAttributes
    );    

EXPORT
NDIS_STATUS
NdisFRestartFilter(
    IN  NDIS_HANDLE             NdisFilterHandle
    );

EXPORT
VOID
NdisFSendNetBufferLists(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNET_BUFFER_LIST        NetBufferList,
    IN  NDIS_PORT_NUMBER        PortNumber,
    IN  ULONG                   SendFlags
    );

EXPORT
VOID
NdisFReturnNetBufferLists(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  ULONG                   ReturnFlags
    );

EXPORT
VOID
NdisFSendNetBufferListsComplete(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNET_BUFFER_LIST        NetBufferList,
    IN  ULONG                   SendCompleteFlags
    );

EXPORT
VOID
NdisFIndicateReceiveNetBufferLists(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNET_BUFFER_LIST        NetBufferLists,
    IN  NDIS_PORT_NUMBER        PortNumber,
    IN  ULONG                   NumberOfNetBufferLists,
    IN  ULONG                   ReceiveFlags
    );

EXPORT
NDIS_STATUS
NdisFOidRequest(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_OID_REQUEST       OidRequest
    );

EXPORT
VOID
NdisFOidRequestComplete(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );

EXPORT
VOID
NdisFIndicateStatus(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_STATUS_INDICATION StatusIndication
    );


EXPORT
VOID
NdisFRestartComplete(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  NDIS_STATUS             Status
    );

EXPORT
VOID
NdisFPauseComplete(
    IN  NDIS_HANDLE             NdisFilterHandle
    );


EXPORT
VOID
NdisFDevicePnPEventNotify(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNET_DEVICE_PNP_EVENT   NetDevicePnPEvent
    );

EXPORT
NDIS_STATUS
NdisFNetPnPEvent(
    IN  NDIS_HANDLE                 NdisFilterHandle,
    IN  PNET_PNP_EVENT_NOTIFICATION NetPnPEventNotification
    );


EXPORT
VOID
NdisFCancelSendNetBufferLists(
    IN  NDIS_HANDLE     NdisFilterHandle,
    IN  PVOID           CancelId
    );
    
EXPORT
VOID
NdisFCancelOidRequest(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PVOID                   RequestId
    );

#if (NDIS_SUPPORT_NDIS61)
EXPORT
NDIS_STATUS
NdisFDirectOidRequest(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_OID_REQUEST       OidRequest
    );

EXPORT
VOID
NdisFDirectOidRequestComplete(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_OID_REQUEST       OidRequest,
    IN  NDIS_STATUS             Status
    );

EXPORT
VOID
NdisFCancelDirectOidRequest(
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PVOID                   RequestId
    );
    
#endif // (NDIS_SUPPORT_NDIS61)

#endif // NDIS_SUPPORT_NDIS6

#pragma once

#if (NDIS_SUPPORT_NDIS6 || defined(NDIS60))

//
// NDIS IF data structures, function prototypes and macros
//

typedef
NDIS_STATUS
(*IFP_QUERY_OBJECT)(
    IN NDIS_HANDLE          ProviderIfContext,
    IN NET_IF_OBJECT_ID     ObjectId,
    IN OUT PULONG           pOutputBufferLength,
    OUT PVOID               pOutputBuffer
    );

typedef
NDIS_STATUS
(*IFP_SET_OBJECT)(
    IN NDIS_HANDLE          ProviderIfContext,
    IN NET_IF_OBJECT_ID     ObjectId,
    IN ULONG                InputBufferLength,
    IN PVOID                pInputBuffer
    );


typedef struct _NDIS_IF_PROVIDER_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER      Header;

    //
    // Generic query and set handlers:
    //
    IFP_QUERY_OBJECT        QueryObjectHandler;
    IFP_SET_OBJECT          SetObjectHandler;

    PVOID                   Reserved1;
    PVOID                   Reserved2;

} NDIS_IF_PROVIDER_CHARACTERISTICS, *PNDIS_IF_PROVIDER_CHARACTERISTICS;

#define NDIS_SIZEOF_IF_PROVIDER_CHARACTERISTICS_REVISION_1   \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_IF_PROVIDER_CHARACTERISTICS, Reserved2)

//
// NET_IF_INFORMATION is passed to NdisIfRegisterInterface
//
typedef struct _NET_IF_INFORMATION
{
    NDIS_OBJECT_HEADER      Header;
    ULONG                   Flags;              // Misc. information
    NET_PHYSICAL_LOCATION   PhysicalLocation;   // physical location on machine
    ULONG                   WanTunnelType;      // tunnelIfEncapsMethod (RFC 2667)
    ULONG                   PortNumber;         // for WAN devices.
    NET_IF_ACCESS_TYPE      AccessType;
    NET_IF_DIRECTION_TYPE   DirectionType;
    NET_IF_CONNECTION_TYPE  ConnectionType;
    BOOLEAN                 ifConnectorPresent;
    USHORT                  PhysAddressLength;  // in bytes (ifPhysAddress). this is -current- mac address
    USHORT                  PhysAddressOffset;  // from beginning of this struct
    USHORT                  PermanentPhysAddressOffset;  // from beginning of this struct
    //
    //  The "friendly name" represents ifDescr:
    //
    USHORT                  FriendlyNameLength; // in bytes
    USHORT                  FriendlyNameOffset; // from beginning of this struct
    GUID                    InterfaceGuid;
    NET_IF_NETWORK_GUID     NetworkGuid;
    ULONG                   SupportedStatistics;
    NDIS_MEDIUM             MediaType;
    NDIS_PHYSICAL_MEDIUM    PhysicalMediumType;    
} NET_IF_INFORMATION, *PNET_IF_INFORMATION;


#define NDIS_SIZEOF_NET_IF_INFORMATION_REVISION_1   \
        RTL_SIZEOF_THROUGH_FIELD(NET_IF_INFORMATION, PhysicalMediumType)

EXPORT
NDIS_STATUS
NdisIfRegisterProvider(
    IN  PNDIS_IF_PROVIDER_CHARACTERISTICS   ProviderCharacteristics,
    IN  NDIS_HANDLE                         IfProviderContext,
    OUT PNDIS_HANDLE                        pNdisIfProviderHandle
    );

EXPORT
VOID
NdisIfDeregisterProvider(
    IN NDIS_HANDLE          NdisProviderHandle
    );

EXPORT
NDIS_STATUS
NdisIfAllocateNetLuidIndex(
    IN  NET_IFTYPE          ifType,
    OUT PUINT32             pNetLuidIndex
    );

EXPORT
NDIS_STATUS
NdisIfFreeNetLuidIndex(
    IN NET_IFTYPE           ifType,
    IN UINT32               NetLuidIndex
    );

EXPORT
NDIS_STATUS
NdisIfRegisterInterface(
    IN NDIS_HANDLE          NdisProviderHandle,
    IN NET_LUID             NetLuid,
    IN NDIS_HANDLE          ProviderIfContext,
    IN PNET_IF_INFORMATION  pIfInfo,
    OUT PNET_IFINDEX        pfIndex
    );

EXPORT
VOID
NdisIfDeregisterInterface(
    IN NET_IFINDEX          ifIndex
    );

EXPORT
NDIS_STATUS
NdisIfGetInterfaceIndexFromNetLuid(
    IN  NET_LUID            NetLuid,
    OUT PNET_IFINDEX        pIfIndex
    );

EXPORT
NDIS_STATUS
NdisIfGetNetLuidFromInterfaceIndex(
    IN  NET_IFINDEX         ifIndex,
    OUT PNET_LUID           pNetLuid
    );

EXPORT
NDIS_STATUS
NdisIfQueryBindingIfIndex(
    IN  NDIS_HANDLE         NdisBindingHandle,
    OUT PNET_IFINDEX        pBoundIfIndex,
    OUT PNET_LUID           pBoundIfNetLuid,
    OUT PNET_IFINDEX        pLowestIfIndex,
    OUT PNET_LUID           pLowestIfNetLuid
    );

EXPORT
NDIS_STATUS
NdisIfAddIfStackEntry(
    IN NET_IFINDEX          HigherLayerIfIndex,
    IN NET_IFINDEX          LowerLayerIfIndex
    );

EXPORT
VOID
NdisIfDeleteIfStackEntry(
    IN NET_IFINDEX          HigherLayerIfIndex,
    IN NET_IFINDEX          LowerLayerIfIndex
    );

#endif // (NDIS_SUPPORT_NDIS6 || defined(NDIS60))

#endif // _NDIS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ndiswan.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndiswan.h

Abstract:

    Main header file for the wan wrapper


Revision History:

--*/


#ifndef _NDIS_WAN_
#define _NDIS_WAN_

#pragma once

//
// Begin definitions for WANs
//

//
// Bit field set int he Reserved field for
// NdisRegisterMiniport or passed in NdisRegisterSpecial
//

#define NDIS_USE_WAN_WRAPPER            0x00000001

#define NDIS_STATUS_TAPI_INDICATION ((NDIS_STATUS)0x40010080L)


//
// NDIS WAN Framing bits
//
#define RAS_FRAMING                     0x00000001
#define RAS_COMPRESSION                 0x00000002

#define ARAP_V1_FRAMING                 0x00000004
#define ARAP_V2_FRAMING                 0x00000008
#define ARAP_FRAMING                    (ARAP_V1_FRAMING | ARAP_V2_FRAMING)

#define PPP_MULTILINK_FRAMING           0x00000010
#define PPP_SHORT_SEQUENCE_HDR_FORMAT   0x00000020
#define PPP_MC_MULTILINK_FRAMING        0x00000040

#define PPP_FRAMING                     0x00000100
#define PPP_COMPRESS_ADDRESS_CONTROL    0x00000200
#define PPP_COMPRESS_PROTOCOL_FIELD     0x00000400
#define PPP_ACCM_SUPPORTED              0x00000800

#define SLIP_FRAMING                    0x00001000
#define SLIP_VJ_COMPRESSION             0x00002000
#define SLIP_VJ_AUTODETECT              0x00004000

#define MEDIA_NRZ_ENCODING              0x00010000
#define MEDIA_NRZI_ENCODING             0x00020000
#define MEDIA_NLPID                     0x00040000

#define RFC_1356_FRAMING                0x00100000
#define RFC_1483_FRAMING                0x00200000
#define RFC_1490_FRAMING                0x00400000
#define LLC_ENCAPSULATION               0x00800000

#define SHIVA_FRAMING                   0x01000000
#define NBF_PRESERVE_MAC_ADDRESS        0x01000000

#ifndef _WAN50_
#define PASS_THROUGH_MODE               0x10000000
#define RAW_PASS_THROUGH_MODE           0x20000000
#endif

#define TAPI_PROVIDER                   0x80000000

//
// NDIS WAN Information structures used
// by NDIS 3.1 Wan Miniport drivers
//
typedef struct _NDIS_WAN_INFO
{
    OUT ULONG           MaxFrameSize;
    OUT ULONG           MaxTransmit;
    OUT ULONG           HeaderPadding;
    OUT ULONG           TailPadding;
    OUT ULONG           Endpoints;
    OUT UINT            MemoryFlags;
    OUT NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress;
    OUT ULONG           FramingBits;
    OUT ULONG           DesiredACCM;
} NDIS_WAN_INFO, *PNDIS_WAN_INFO;

typedef struct _NDIS_WAN_SET_LINK_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    IN  ULONG           MaxSendFrameSize;
    IN  ULONG           MaxRecvFrameSize;
        ULONG           HeaderPadding;
        ULONG           TailPadding;
    IN  ULONG           SendFramingBits;
    IN  ULONG           RecvFramingBits;
    IN  ULONG           SendCompressionBits;
    IN  ULONG           RecvCompressionBits;
    IN  ULONG           SendACCM;
    IN  ULONG           RecvACCM;
} NDIS_WAN_SET_LINK_INFO, *PNDIS_WAN_SET_LINK_INFO;

typedef struct _NDIS_WAN_GET_LINK_INFO {
    IN  NDIS_HANDLE     NdisLinkHandle;
    OUT ULONG           MaxSendFrameSize;
    OUT ULONG           MaxRecvFrameSize;
    OUT ULONG           HeaderPadding;
    OUT ULONG           TailPadding;
    OUT ULONG           SendFramingBits;
    OUT ULONG           RecvFramingBits;
    OUT ULONG           SendCompressionBits;
    OUT ULONG           RecvCompressionBits;
    OUT ULONG           SendACCM;
    OUT ULONG           RecvACCM;
} NDIS_WAN_GET_LINK_INFO, *PNDIS_WAN_GET_LINK_INFO;

//
// NDIS WAN Bridging Options
//
#define BRIDGING_FLAG_LANFCS            0x00000001
#define BRIDGING_FLAG_LANID             0x00000002
#define BRIDGING_FLAG_PADDING           0x00000004

//
// NDIS WAN Bridging Capabilities
//
#define BRIDGING_TINYGRAM               0x00000001
#define BRIDGING_LANID                  0x00000002
#define BRIDGING_NO_SPANNING_TREE       0x00000004
#define BRIDGING_8021D_SPANNING_TREE    0x00000008
#define BRIDGING_8021G_SPANNING_TREE    0x00000010
#define BRIDGING_SOURCE_ROUTING         0x00000020
#define BRIDGING_DEC_LANBRIDGE          0x00000040

//
// NDIS WAN Bridging Type
//
#define BRIDGING_TYPE_RESERVED          0x00000001
#define BRIDGING_TYPE_8023_CANON        0x00000002
#define BRIDGING_TYPE_8024_NO_CANON     0x00000004
#define BRIDGING_TYPE_8025_NO_CANON     0x00000008
#define BRIDGING_TYPE_FDDI_NO_CANON     0x00000010
#define BRIDGING_TYPE_8024_CANON        0x00000400
#define BRIDGING_TYPE_8025_CANON        0x00000800
#define BRIDGING_TYPE_FDDI_CANON        0x00001000

typedef struct _NDIS_WAN_GET_BRIDGE_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    OUT USHORT          LanSegmentNumber;
    OUT UCHAR           BridgeNumber;
    OUT UCHAR           BridgingOptions;
    OUT ULONG           BridgingCapabilities;
    OUT UCHAR           BridgingType;
    OUT UCHAR           MacBytes[6];
} NDIS_WAN_GET_BRIDGE_INFO, *PNDIS_WAN_GET_BRIDGE_INFO;

typedef struct _NDIS_WAN_SET_BRIDGE_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    IN  USHORT          LanSegmentNumber;
    IN  UCHAR           BridgeNumber;
    IN  UCHAR           BridgingOptions;
    IN  ULONG           BridgingCapabilities;
    IN  UCHAR           BridgingType;
    IN  UCHAR           MacBytes[6];
} NDIS_WAN_SET_BRIDGE_INFO, *PNDIS_WAN_SET_BRIDGE_INFO;

//
// NDIS WAN Compression Information
//

//
// Define MSCompType bit field, 0 disables all
//
#define NDISWAN_COMPRESSION             0x00000001
#define NDISWAN_ENCRYPTION              0x00000010
#define NDISWAN_40_ENCRYPTION           0x00000020
#define NDISWAN_128_ENCRYPTION          0x00000040
#define NDISWAN_56_ENCRYPTION           0x00000080
#define NDISWAN_HISTORY_LESS            0x01000000

//
// Define CompType codes
//
#define COMPTYPE_OUI                    0
#define COMPTYPE_NT31RAS                254
#define COMPTYPE_NONE                   255


typedef struct _NDIS_WAN_COMPRESS_INFO
{
    UCHAR   SessionKey[8];
    ULONG   MSCompType;

    // Fields above indicate NDISWAN capabilities.
    // Fields below indicate MAC-specific capabilities.

    UCHAR   CompType;
    USHORT  CompLength;

    union
    {
        struct
        {
            UCHAR   CompOUI[3];
            UCHAR   CompSubType;
            UCHAR   CompValues[32];
        } Proprietary;

        struct
        {
            UCHAR   CompValues[32];
        } Public;
    };
} NDIS_WAN_COMPRESS_INFO;

typedef NDIS_WAN_COMPRESS_INFO UNALIGNED *PNDIS_WAN_COMPRESS_INFO;

typedef struct _NDIS_WAN_GET_COMP_INFO
{
    IN  NDIS_HANDLE             NdisLinkHandle;
    OUT NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    OUT NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_GET_COMP_INFO, *PNDIS_WAN_GET_COMP_INFO;

typedef struct _NDIS_WAN_SET_COMP_INFO
{
    IN  NDIS_HANDLE             NdisLinkHandle;
    IN  NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    IN  NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_SET_COMP_INFO, *PNDIS_WAN_SET_COMP_INFO;

//
// NDIS WAN Statistics Information
//

typedef struct _NDIS_WAN_GET_STATS_INFO
{
    IN  NDIS_HANDLE NdisLinkHandle;
    OUT ULONG       BytesSent;
    OUT ULONG       BytesRcvd;
    OUT ULONG       FramesSent;
    OUT ULONG       FramesRcvd;
    OUT ULONG       CRCErrors;                      // Serial-like info only
    OUT ULONG       TimeoutErrors;                  // Serial-like info only
    OUT ULONG       AlignmentErrors;                // Serial-like info only
    OUT ULONG       SerialOverrunErrors;            // Serial-like info only
    OUT ULONG       FramingErrors;                  // Serial-like info only
    OUT ULONG       BufferOverrunErrors;            // Serial-like info only
    OUT ULONG       BytesTransmittedUncompressed;   // Compression info only
    OUT ULONG       BytesReceivedUncompressed;      // Compression info only
    OUT ULONG       BytesTransmittedCompressed;     // Compression info only
    OUT ULONG       BytesReceivedCompressed;        // Compression info only
} NDIS_WAN_GET_STATS_INFO, *PNDIS_WAN_GET_STATS_INFO;

#define NdisMWanInitializeWrapper(NdisWrapperHandle,                                \
                                  SystemSpecific1,                                  \
                                  SystemSpecific2,                                  \
                                  SystemSpecific3)                                  \
{                                                                                   \
    NdisMInitializeWrapper(NdisWrapperHandle,                                       \
                            SystemSpecific1,                                        \
                            SystemSpecific2,                                        \
                            SystemSpecific3);                                       \
}

typedef struct _NDIS_MAC_LINE_UP
{
    IN  ULONG               LinkSpeed;
    IN  NDIS_WAN_QUALITY    Quality;
    IN  USHORT              SendWindow;
    IN  NDIS_HANDLE      ConnectionWrapperID;
    IN  NDIS_HANDLE      NdisLinkHandle;
    OUT NDIS_HANDLE      NdisLinkContext;
} NDIS_MAC_LINE_UP, *PNDIS_MAC_LINE_UP;


typedef struct _NDIS_MAC_LINE_DOWN
{
    IN  NDIS_HANDLE      NdisLinkContext;
} NDIS_MAC_LINE_DOWN, *PNDIS_MAC_LINE_DOWN;


//
// These are the error values that can be indicated by the driver.
// This bit field is set when calling NdisIndicateStatus.
//
#define WAN_ERROR_CRC               ((ULONG)0x00000001)
#define WAN_ERROR_FRAMING           ((ULONG)0x00000002)
#define WAN_ERROR_HARDWAREOVERRUN   ((ULONG)0x00000004)
#define WAN_ERROR_BUFFEROVERRUN     ((ULONG)0x00000008)
#define WAN_ERROR_TIMEOUT           ((ULONG)0x00000010)
#define WAN_ERROR_ALIGNMENT         ((ULONG)0x00000020)

typedef struct _NDIS_MAC_FRAGMENT
{
    IN  NDIS_HANDLE     NdisLinkContext;
    IN  ULONG           Errors;
} NDIS_MAC_FRAGMENT, *PNDIS_MAC_FRAGMENT;

//
// NDIS WAN Information structures used
// by NDIS 5.0 Miniport drivers
//

//
// Defines for the individual fields are the
// same as for NDIS 3.x/4.x Wan miniports.
//
// See the DDK.
//

//
// Information that applies to all VC's on
// this adapter.
//
// OID: OID_WAN_CO_GET_INFO
//
typedef struct _NDIS_WAN_CO_INFO {
    OUT ULONG           MaxFrameSize;
    OUT ULONG           MaxSendWindow;
    OUT ULONG           FramingBits;
    OUT ULONG           DesiredACCM;
} NDIS_WAN_CO_INFO, *PNDIS_WAN_CO_INFO;

//
// Set VC specific PPP framing information.
//
// OID: OID_WAN_CO_SET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_SET_LINK_INFO {
    IN  ULONG           MaxSendFrameSize;
    IN  ULONG           MaxRecvFrameSize;
    IN  ULONG           SendFramingBits;
    IN  ULONG           RecvFramingBits;
    IN  ULONG           SendCompressionBits;
    IN  ULONG           RecvCompressionBits;
    IN  ULONG           SendACCM;
    IN  ULONG           RecvACCM;
} NDIS_WAN_CO_SET_LINK_INFO, *PNDIS_WAN_CO_SET_LINK_INFO;

//
// Get VC specific PPP framing information.
//
// OID: OID_WAN_CO_GET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_GET_LINK_INFO {
    OUT ULONG           MaxSendFrameSize;
    OUT ULONG           MaxRecvFrameSize;
    OUT ULONG           SendFramingBits;
    OUT ULONG           RecvFramingBits;
    OUT ULONG           SendCompressionBits;
    OUT ULONG           RecvCompressionBits;
    OUT ULONG           SendACCM;
    OUT ULONG           RecvACCM;
} NDIS_WAN_CO_GET_LINK_INFO, *PNDIS_WAN_CO_GET_LINK_INFO;

//
// Get VC specific PPP compression information
//
// OID: OID_WAN_CO_GET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_GET_COMP_INFO {
    OUT NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    OUT NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_CO_GET_COMP_INFO, *PNDIS_WAN_CO_GET_COMP_INFO;


//
// Set VC specific PPP compression information
//
// OID: OID_WAN_CO_SET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_SET_COMP_INFO {
    IN  NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    IN  NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_CO_SET_COMP_INFO, *PNDIS_WAN_CO_SET_COMP_INFO;


//
// Get VC specific statistics
//
// OID: OID_WAN_CO_GET_STATS_INFO
//
typedef struct _NDIS_WAN_CO_GET_STATS_INFO {
    OUT ULONG       BytesSent;
    OUT ULONG       BytesRcvd;
    OUT ULONG       FramesSent;
    OUT ULONG       FramesRcvd;
    OUT ULONG       CRCErrors;                      // Serial-like info only
    OUT ULONG       TimeoutErrors;                  // Serial-like info only
    OUT ULONG       AlignmentErrors;                // Serial-like info only
    OUT ULONG       SerialOverrunErrors;            // Serial-like info only
    OUT ULONG       FramingErrors;                  // Serial-like info only
    OUT ULONG       BufferOverrunErrors;            // Serial-like info only
    OUT ULONG       BytesTransmittedUncompressed;   // Compression info only
    OUT ULONG       BytesReceivedUncompressed;      // Compression info only
    OUT ULONG       BytesTransmittedCompressed;     // Compression info only
    OUT ULONG       BytesReceivedCompressed;        // Compression info only
} NDIS_WAN_CO_GET_STATS_INFO, *PNDIS_WAN_CO_GET_STATS_INFO;

//
// Used to notify NdisWan of Errors.  See error
// bit mask in ndiswan.h
//
// NDIS_STATUS: NDIS_STATUS_WAN_CO_FRAGMENT
//
typedef struct _NDIS_WAN_CO_FRAGMENT {
    IN  ULONG           Errors;
} NDIS_WAN_CO_FRAGMENT, *PNDIS_WAN_CO_FRAGMENT;

//
// Used to notify NdisWan of changes in link speed and
// send window.  Can be given at any time.  NdisWan will honor
// any send window (even zero).  NdisWan will default zero
// TransmitSpeed/ReceiveSpeed settings to 28.8Kbs.
//
// NDIS_STATUS: NDIS_STATUS_WAN_CO_LINKPARAMS
//
typedef struct _WAN_CO_LINKPARAMS {
    ULONG   TransmitSpeed;              // Transmit speed of the VC in Bytes/sec
    ULONG   ReceiveSpeed;               // Receive speed of the VC in Bytes/sec
    ULONG   SendWindow;                 // Current send window for the VC
} WAN_CO_LINKPARAMS, *PWAN_CO_LINKPARAMS;

#endif  // _NDIS_WAN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video capture drivers   */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) Microsoft Corporation. All rights reserved.         */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		4

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a, but are now obsolete
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)
// The 2 messages above will be removed once the ALLOCBUFFER code is ready

// Following added for Win95 and NTPPC
#define DVM_STREAM_ALLOCBUFFER          (DVM_START + 312)
#define DVM_STREAM_FREEBUFFER           (DVM_START + 313)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef _WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD  dwCallback;
       DWORD  dwCallbackInst;
       DWORD  dwFlags;
       HANDLE hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\nodetype.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in the RDBSS.
    Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:
Revision History:

--*/

#ifndef _NODETYPE_INCLUDED_
#define _NODETYPE_INCLUDED_


typedef USHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;
typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME, *PRECORD_NAME;
//

#ifndef NodeType
#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))
#endif


typedef struct _NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
      NODE_TYPE_CODE NodeTypeCode;
      NODE_BYTE_SIZE NodeByteSize;
}  NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;

#ifdef __cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE : public NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
#else // !__cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE {
      NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;
#endif // __cplusplus

      //
      //  this is for guys with reference counts....not everyone has one
      //

      __volatile ULONG NodeReferenceCount; 
}  NODE_TYPE_CODE_AND_SIZE, *PNODE_TYPE_AND_SIZE;


#define ZeroAndInitializeNodeType(Ptr,TType,Size) {\
        RtlZeroMemory( Ptr, Size );   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeTypeCode = TType;   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeByteSize = (CSHORT)Size;    \
        }


//
//  N O D E T Y P E S
//


//
//  0xeb00 was selected as being far from the other codes
//  0xec00 was added so that we could encode the structure type in the code.
//

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)



#define RDBSS_STORAGE_NTC(x) (0xec00+(x))

//
//  these are here to ensure that we don't use any of the old cairo storage types.
//

#define StorageTypeDirectory (@@@)
#define StorageTypeFile (@@@)

typedef enum _RX_FILE_TYPE {
    FileTypeNotYetKnown = 0,
    FileTypeDirectory = 2,
    FileTypeFile = 3
} RX_FILE_TYPE;

//
//  according to markz, i should plan on the number of STORAGE_NTCs growing to bytesize!!
//

#define RDBSS_NTC_STORAGE_TYPE_UNKNOWN		       ((NODE_TYPE_CODE)0xec00)
#define RDBSS_NTC_STORAGE_TYPE_DIRECTORY     	   ((NODE_TYPE_CODE)0xec02)
#define RDBSS_NTC_STORAGE_TYPE_FILE		           ((NODE_TYPE_CODE)0xec03)

#define RDBSS_NTC_OPENTARGETDIR_FCB                ((NODE_TYPE_CODE)0xecff) //  must be an fcb type and not the same
#define RDBSS_NTC_IPC_SHARE                        ((NODE_TYPE_CODE)0xecfe)
#define RDBSS_NTC_MAILSLOT                         ((NODE_TYPE_CODE)0xecfd)
#define RDBSS_NTC_SPOOLFILE                        ((NODE_TYPE_CODE)0xecfc)

#define RDBSS_NTC_SRVCALL                          ((NODE_TYPE_CODE)0xeb10)
#define RDBSS_NTC_NETROOT                          ((NODE_TYPE_CODE)0xeb11)
#define RDBSS_NTC_V_NETROOT                        ((NODE_TYPE_CODE)0xeb12)
    
//
//  Local filesystems sometimes need volume opens. these are not yet
//  implemented but we reserve the nodetype now.
//     

#define RDBSS_NTC_VOLUME_FCB                       ((NODE_TYPE_CODE)0xeb1f)

#define RDBSS_NTC_SRVOPEN                          ((NODE_TYPE_CODE)0xeb1c)
#define RDBSS_NTC_INTERNAL_SRVOPEN                 ((NODE_TYPE_CODE)0xeb1d)
#define RDBSS_NTC_DEVICE_FCB                       ((NODE_TYPE_CODE)0xeb9a)

#define RDBSS_NTC_DATA_HEADER                      ((NODE_TYPE_CODE)0xeb00)
#define RDBSS_NTC_VCB                              ((NODE_TYPE_CODE)0xeb01)
#define RDBSS_NTC_FOBX                             ((NODE_TYPE_CODE)0xeb07)
#define RDBSS_NTC_RX_CONTEXT                       ((NODE_TYPE_CODE)0xeb08)

#define RDBSS_NTC_PREFIX_TABLE                     ((NODE_TYPE_CODE)0xeb0d)
#define RDBSS_NTC_PREFIX_ENTRY                     ((NODE_TYPE_CODE)0xeb0e)

#define RDBSS_NTC_FCB_TABLE                        ((NODE_TYPE_CODE)0xeb09)
#define RDBSS_NTC_FCB_TABLE_ENTRY                  ((NODE_TYPE_CODE)0xeb0a)

#define RDBSS_NTC_RXCE_TRANSPORT                   ((NODE_TYPE_CODE)0xeb71)
#define RDBSS_NTC_RXCE_ADDRESS                     ((NODE_TYPE_CODE)0xeb72)
#define RDBSS_NTC_RXCE_CONNECTION                  ((NODE_TYPE_CODE)0xeb73)
#define RDBSS_NTC_RXCE_VC                          ((NODE_TYPE_CODE)0xeb74)

#define RDBSS_NTC_NONPAGED_FCB                     ((NODE_TYPE_CODE)0xebfd)
#define RDBSS_NTC_COMMON_DISPATCH                  ((NODE_TYPE_CODE)0xebfe)
#define RDBSS_NTC_MINIRDR_DISPATCH                 ((NODE_TYPE_CODE)0xebff)

typedef USHORT RDBSS_STORAGE_TYPE_CODES;

#define RDBSS_NTC_FCB                      RDBSS_NTC_STORAGE_TYPE_FILE

#define NodeTypeIsFcb( FCB ) \
    ((((NodeType(FCB) & 0xff00) == RDBSS_NTC_STORAGE_TYPE_UNKNOWN)) || ((NodeType( FCB ) & 0xfff0) == 0xeb90))

//
//  a mask to alter the type of a data structure once it is marked for scavenging so
//  that subsequent tests will fail.
//

#define RX_SCAVENGER_MASK (0x1000)


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded the line number of the
//  bugcheck call in the low order 16 bits. The high order bits can be whatever
//  the caller wants. In the wrapper, we actually define file identifiers as well.
//  However, the system also displays quire a but of the backtrace; this shows
//  the .sys file of the caller and it is frequently the case that the linenumber
//  is completely disambiguating.
//

//
//  Each individual wrapper file that calls bugcheck has defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  RDBSS_BUG_CHECK_ values defined below and then use RxBugCheck to bugcheck
//  the system.
//


typedef enum _RDBSS_BUG_CHECK_CODES {

     RDBSS_BUG_CHECK_FCBSTRUC  = 0xfcb00000,
     RDBSS_BUG_CHECK_CACHESUP  = 0xca550000,
     RDBSS_BUG_CHECK_CLEANUP   = 0xc1ee0000,
     RDBSS_BUG_CHECK_CLOSE     = 0xc10e0000,
     RDBSS_BUG_CHECK_NTEXCEPT  = 0xbaad0000,

} RDBSS_BUG_CHECK_CODES;

// we overload on the original redirector's bugcheck code using the stack
// backtrace to differentiate among consumers

#define RDBSS_FILE_SYSTEM RDR_FILE_SYSTEM
#define RxBugCheck(A,B,C) { \
        KeBugCheckEx(RDBSS_FILE_SYSTEM, \
                     BugCheckFileId | ((ULONG)(__LINE__)), \
                     A, B, C ); \
        }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#endif // _NODETYPE_INCLUDED_


#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in the RDBSS.
    Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:
Revision History:

--*/

#ifndef _NODETYPE_INCLUDED_
#define _NODETYPE_INCLUDED_


typedef USHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;
typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME, *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))


typedef struct _NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
      NODE_TYPE_CODE NodeTypeCode;
      NODE_BYTE_SIZE NodeByteSize;
}  NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;

#ifdef __cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE : public NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
#else // !__cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE {
      NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;
#endif // __cplusplus

      //
      //  this is for guys with reference counts....not everyone has one
      //

      ULONG NodeReferenceCount; 
}  NODE_TYPE_CODE_AND_SIZE, *PNODE_TYPE_AND_SIZE;


#define ZeroAndInitializeNodeType(Ptr,TType,Size) {\
        RtlZeroMemory( Ptr, Size );   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeTypeCode = TType;   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeByteSize = (CSHORT)Size;    \
        }


//
//  N O D E T Y P E S
//


//
//  0xeb00 was selected as being far from the other codes
//  0xec00 was added so that we could encode the structure type in the code.
//

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)



#define RDBSS_STORAGE_NTC(x) (0xec00+(x))

//
//  these are here to ensure that we don't use any of the old cairo storage types.
//

#define StorageTypeDirectory (@@@)
#define StorageTypeFile (@@@)

typedef enum _RX_FILE_TYPE {
    FileTypeNotYetKnown = 0,
    FileTypeDirectory = 2,
    FileTypeFile = 3
} RX_FILE_TYPE;

//
//  according to markz, i should plan on the number of STORAGE_NTCs growing to bytesize!!
//

#define RDBSS_NTC_STORAGE_TYPE_UNKNOWN		       ((NODE_TYPE_CODE)0xec00)
#define RDBSS_NTC_STORAGE_TYPE_DIRECTORY     	   ((NODE_TYPE_CODE)0xec02)
#define RDBSS_NTC_STORAGE_TYPE_FILE		           ((NODE_TYPE_CODE)0xec03)

#define RDBSS_NTC_OPENTARGETDIR_FCB                ((NODE_TYPE_CODE)0xecff) //  must be an fcb type and not the same
#define RDBSS_NTC_IPC_SHARE                        ((NODE_TYPE_CODE)0xecfe)
#define RDBSS_NTC_MAILSLOT                         ((NODE_TYPE_CODE)0xecfd)
#define RDBSS_NTC_SPOOLFILE                        ((NODE_TYPE_CODE)0xecfc)

#define RDBSS_NTC_SRVCALL                          ((NODE_TYPE_CODE)0xeb10)
#define RDBSS_NTC_NETROOT                          ((NODE_TYPE_CODE)0xeb11)
#define RDBSS_NTC_V_NETROOT                        ((NODE_TYPE_CODE)0xeb12)
    
//
//  Local filesystems sometimes need volume opens. these are not yet
//  implemented but we reserve the nodetype now.
//     

#define RDBSS_NTC_VOLUME_FCB                       ((NODE_TYPE_CODE)0xeb1f)

#define RDBSS_NTC_SRVOPEN                          ((NODE_TYPE_CODE)0xeb1c)
#define RDBSS_NTC_INTERNAL_SRVOPEN                 ((NODE_TYPE_CODE)0xeb1d)
#define RDBSS_NTC_DEVICE_FCB                       ((NODE_TYPE_CODE)0xeb9a)

#define RDBSS_NTC_DATA_HEADER                      ((NODE_TYPE_CODE)0xeb00)
#define RDBSS_NTC_VCB                              ((NODE_TYPE_CODE)0xeb01)
#define RDBSS_NTC_FOBX                             ((NODE_TYPE_CODE)0xeb07)
#define RDBSS_NTC_RX_CONTEXT                       ((NODE_TYPE_CODE)0xeb08)

#define RDBSS_NTC_PREFIX_TABLE                     ((NODE_TYPE_CODE)0xeb0d)
#define RDBSS_NTC_PREFIX_ENTRY                     ((NODE_TYPE_CODE)0xeb0e)

#define RDBSS_NTC_FCB_TABLE                        ((NODE_TYPE_CODE)0xeb09)
#define RDBSS_NTC_FCB_TABLE_ENTRY                  ((NODE_TYPE_CODE)0xeb0a)

#define RDBSS_NTC_RXCE_TRANSPORT                   ((NODE_TYPE_CODE)0xeb71)
#define RDBSS_NTC_RXCE_ADDRESS                     ((NODE_TYPE_CODE)0xeb72)
#define RDBSS_NTC_RXCE_CONNECTION                  ((NODE_TYPE_CODE)0xeb73)
#define RDBSS_NTC_RXCE_VC                          ((NODE_TYPE_CODE)0xeb74)

#define RDBSS_NTC_NONPAGED_FCB                     ((NODE_TYPE_CODE)0xebfd)
#define RDBSS_NTC_COMMON_DISPATCH                  ((NODE_TYPE_CODE)0xebfe)
#define RDBSS_NTC_MINIRDR_DISPATCH                 ((NODE_TYPE_CODE)0xebff)

typedef USHORT RDBSS_STORAGE_TYPE_CODES;

#define RDBSS_NTC_FCB                      RDBSS_NTC_STORAGE_TYPE_FILE

#define NodeTypeIsFcb( FCB ) \
    ((((NodeType(FCB) & 0xff00) == RDBSS_NTC_STORAGE_TYPE_UNKNOWN)) || ((NodeType( FCB ) & 0xfff0) == 0xeb90))

//
//  a mask to alter the type of a data structure once it is marked for scavenging so
//  that subsequent tests will fail.
//

#define RX_SCAVENGER_MASK (0x1000)


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded the line number of the
//  bugcheck call in the low order 16 bits. The high order bits can be whatever
//  the caller wants. In the wrapper, we actually define file identifiers as well.
//  However, the system also displays quire a but of the backtrace; this shows
//  the .sys file of the caller and it is frequently the case that the linenumber
//  is completely disambiguating.
//

//
//  Each individual wrapper file that calls bugcheck has defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  RDBSS_BUG_CHECK_ values defined below and then use RxBugCheck to bugcheck
//  the system.
//


typedef enum _RDBSS_BUG_CHECK_CODES {

     RDBSS_BUG_CHECK_FCBSTRUC  = 0xfcb00000,
     RDBSS_BUG_CHECK_CACHESUP  = 0xca550000,
     RDBSS_BUG_CHECK_CLEANUP   = 0xc1ee0000,
     RDBSS_BUG_CHECK_CLOSE     = 0xc10e0000,
     RDBSS_BUG_CHECK_NTEXCEPT  = 0xbaad0000,

} RDBSS_BUG_CHECK_CODES;

// we overload on the original redirector's bugcheck code using the stack
// backtrace to differentiate among consumers

#define RDBSS_FILE_SYSTEM RDR_FILE_SYSTEM
#define RxBugCheck(A,B,C) { \
        KeBugCheckEx(RDBSS_FILE_SYSTEM, \
                     BugCheckFileId | ((ULONG)(__LINE__)), \
                     A, B, C ); \
        }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#endif // _NODETYPE_INCLUDED_



#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in the RDBSS.
    Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:
Revision History:

--*/

#ifndef _NODETYPE_INCLUDED_
#define _NODETYPE_INCLUDED_


typedef USHORT          NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;
typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME, *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))


typedef struct _NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
      NODE_TYPE_CODE NodeTypeCode;
      NODE_BYTE_SIZE NodeByteSize;
}  NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;

#ifdef __cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE : public NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
#else // !__cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE {
      NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;
#endif // __cplusplus
      ULONG          NodeReferenceCount; //this is for guys with reference counts....not everyone has one
}  NODE_TYPE_CODE_AND_SIZE;


#define ZeroAndInitializeNodeType(Ptr,TType,Size) {\
        RtlZeroMemory( Ptr, Size );   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeTypeCode = TType;   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeByteSize = (CSHORT)Size;    \
        }


//
// N O D E T Y P E S


// 0xeb00 was selected as being far from the other codes
// 0xec00 was added so that we could encode the structure type in the code.

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)



#define RDBSS_STORAGE_NTC(x) (0xec00+(x))

// these are here to ensure that we don't use any of the old cairo storage types.
#define StorageTypeDirectory (@@@)
#define StorageTypeFile (@@@)

typedef enum _RX_FILE_TYPE {
    FileTypeNotYetKnown   = 0,
    FileTypeDirectory = 2,
    FileTypeFile      = 3
} RX_FILE_TYPE;
//according to markz, i should plan on the number of STORAGE_NTCs growing to bytesize!!
typedef enum _RDBSS_STORAGE_TYPE_CODES{
     RDBSS_NTC_STORAGE_TYPE_UNKNOWN		       = RDBSS_STORAGE_NTC(FileTypeNotYetKnown),
     RDBSS_NTC_STORAGE_TYPE_DIRECTORY     	   = RDBSS_STORAGE_NTC(FileTypeDirectory),
     RDBSS_NTC_STORAGE_TYPE_FILE		       = RDBSS_STORAGE_NTC(FileTypeFile),

     RDBSS_NTC_OPENTARGETDIR_FCB   =  RDBSS_STORAGE_NTC(0xff),   //must be an fcb type and not the same
     RDBSS_NTC_IPC_SHARE           =  RDBSS_STORAGE_NTC(0xfe),
     RDBSS_NTC_MAILSLOT            =  RDBSS_STORAGE_NTC(0xfd),
     RDBSS_NTC_SPOOLFILE           =  RDBSS_STORAGE_NTC(0xfc),

     RDBSS_NTC_SRVCALL         =      (NODE_TYPE_CODE)0xeb10,
     RDBSS_NTC_NETROOT         =      (NODE_TYPE_CODE)0xeb11,
     RDBSS_NTC_V_NETROOT       =      (NODE_TYPE_CODE)0xeb12,

//Local filesystems sometimes need volume opens. these are not yet
//    implemented but we reserve the nodetype now.

     RDBSS_NTC_VOLUME_FCB      =      (NODE_TYPE_CODE)0xeb1f,


     RDBSS_NTC_SRVOPEN         =      (NODE_TYPE_CODE)0xeb1c,
     RDBSS_NTC_INTERNAL_SRVOPEN =     (NODE_TYPE_CODE)0xeb1d,
     RDBSS_NTC_DEVICE_FCB      =      (NODE_TYPE_CODE)0xeb9a,

     RDBSS_NTC_DATA_HEADER     =      (NODE_TYPE_CODE)0xeb00,
     RDBSS_NTC_VCB             =      (NODE_TYPE_CODE)0xeb01,
     RDBSS_NTC_ROOT_DCB        =      (NODE_TYPE_CODE)0xeb04,
     RDBSS_NTC_FOBX            =      (NODE_TYPE_CODE)0xeb07,
     RDBSS_NTC_RX_CONTEXT     =       (NODE_TYPE_CODE)0xeb08,

     RDBSS_NTC_PREFIX_TABLE    =      (NODE_TYPE_CODE)0xeb0d,
     RDBSS_NTC_PREFIX_ENTRY    =      (NODE_TYPE_CODE)0xeb0e,

     RDBSS_NTC_FCB_TABLE       =      (NODE_TYPE_CODE)0xeb09,
     RDBSS_NTC_FCB_TABLE_ENTRY =      (NODE_TYPE_CODE)0xeb0a,

     RDBSS_NTC_RXCE_TRANSPORT  =      (NODE_TYPE_CODE)0xeb71,
     RDBSS_NTC_RXCE_ADDRESS    =      (NODE_TYPE_CODE)0xeb72,
     RDBSS_NTC_RXCE_CONNECTION =      (NODE_TYPE_CODE)0xeb73,
     RDBSS_NTC_RXCE_VC         =      (NODE_TYPE_CODE)0xeb74,

     RDBSS_NTC_NONPAGED_FCB     =      (NODE_TYPE_CODE)0xebfd,
     RDBSS_NTC_COMMON_DISPATCH  =      (NODE_TYPE_CODE)0xebfe,
     RDBSS_NTC_MINIRDR_DISPATCH =      (NODE_TYPE_CODE)0xebff

} RDBSS_STORAGE_TYPE_CODES;

#define RDBSS_NTC_FCB                      RDBSS_NTC_STORAGE_TYPE_FILE

#define NodeTypeIsFcb(FCB) \
    (  ((NodeType(FCB)&0xff00)== RDBSS_STORAGE_NTC(0)) ||  ((NodeType(FCB)&0xfff0)==0xeb90)   )

// a mask to alter the type of a data structure once it is marked for scavenging so
// that subsequent tests will fail.

#define RX_SCAVENGER_MASK (0x1000)


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded the line number of the
//  bugcheck call in the low order 16 bits. The high order bits can be whatever
//  the caller wants. In the wrapper, we actually define file identifiers as well.
//  However, the system also displays quire a but of the backtrace; this shows
//  the .sys file of the caller and it is frequently the case that the linenumber
//  is completely disambiguating.

//  Each individual wrapper file that calls bugcheck has defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  RDBSS_BUG_CHECK_ values defined below and then use RxBugCheck to bugcheck
//  the system.
//


typedef enum _RDBSS_BUG_CHECK_CODES {

     RDBSS_BUG_CHECK_FCBSTRUC  = 0xfcb00000,
     RDBSS_BUG_CHECK_CACHESUP  = 0xca550000,
     RDBSS_BUG_CHECK_CLEANUP   = 0xc1ee0000,
     RDBSS_BUG_CHECK_CLOSE     = 0xc10e0000,
     RDBSS_BUG_CHECK_NTEXCEPT  = 0xbaad0000,

} RDBSS_BUG_CHECK_CODES;

// we overload on the original redirector's bugcheck code using the stack
// backtrace to differentiate among consumers

#define RDBSS_FILE_SYSTEM RDR_FILE_SYSTEM
#define RxBugCheck(A,B,C) { \
        KeBugCheckEx(RDBSS_FILE_SYSTEM, \
                     BugCheckFileId | ((ULONG)(__LINE__)), \
                     A, B, C ); \
        }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#endif // _NODETYPE_INCLUDED_



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in the RDBSS.
    Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    JoeLinn     [Joelinn]    9-July-1994

Revision History:

--*/

#ifndef _NODETYPE_INCLUDED_
#define _NODETYPE_INCLUDED_


typedef USHORT          NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;
typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME, *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))


typedef struct _NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
      NODE_TYPE_CODE NodeTypeCode;
      NODE_BYTE_SIZE NodeByteSize;
}  NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;

typedef struct _NODE_TYPE_CODE_AND_SIZE {
      NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;
      ULONG          NodeReferenceCount; //this is for guys with reference counts....not everyone has one
}  NODE_TYPE_CODE_AND_SIZE;


#define ZeroAndInitializeNodeType(Ptr,TType,Size) {\
        RtlZeroMemory( Ptr, Size );   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeTypeCode = TType;   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeByteSize = (CSHORT)Size;    \
        }


//
// N O D E T Y P E S


// 0xeb00 was selected as being far from the other codes
// 0xec00 was added so that we could encode the structure type in the code.

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)



#define RDBSS_STORAGE_NTC(x) (0xec00+(x))

// these are here to ensure that we don't use any of the old cairo storage types.
#define StorageTypeDirectory (@@@)
#define StorageTypeFile (@@@)

typedef enum _RX_FILE_TYPE {
    FileTypeNotYetKnown   = 0,
    FileTypeDirectory = 2,
    FileTypeFile      = 3
} RX_FILE_TYPE;
//according to markz, i should plan on the number of STORAGE_NTCs growing to bytesize!!
typedef enum _RDBSS_STORAGE_TYPE_CODES{
     RDBSS_NTC_STORAGE_TYPE_UNKNOWN		       = RDBSS_STORAGE_NTC(FileTypeNotYetKnown),
     RDBSS_NTC_STORAGE_TYPE_DIRECTORY     	   = RDBSS_STORAGE_NTC(FileTypeDirectory),
     RDBSS_NTC_STORAGE_TYPE_FILE		       = RDBSS_STORAGE_NTC(FileTypeFile),

     RDBSS_NTC_OPENTARGETDIR_FCB   =  RDBSS_STORAGE_NTC(0xff),   //must be an fcb type and not the same
     RDBSS_NTC_IPC_SHARE           =  RDBSS_STORAGE_NTC(0xfe),
     RDBSS_NTC_MAILSLOT            =  RDBSS_STORAGE_NTC(0xfd),
     RDBSS_NTC_SPOOLFILE           =  RDBSS_STORAGE_NTC(0xfc),

     RDBSS_NTC_SRVCALL         =      (NODE_TYPE_CODE)0xeb10,
     RDBSS_NTC_NETROOT         =      (NODE_TYPE_CODE)0xeb11,
     RDBSS_NTC_V_NETROOT       =      (NODE_TYPE_CODE)0xeb12,

//Local filesystems sometimes need volume opens. these are not yet
//    implemented but we reserve the nodetype now.

     RDBSS_NTC_VOLUME_FCB      =      (NODE_TYPE_CODE)0xeb1f,


     RDBSS_NTC_SRVOPEN         =      (NODE_TYPE_CODE)0xeb1c,
     RDBSS_NTC_INTERNAL_SRVOPEN =     (NODE_TYPE_CODE)0xeb1d,
     RDBSS_NTC_DEVICE_FCB      =      (NODE_TYPE_CODE)0xeb9a,

     RDBSS_NTC_DATA_HEADER     =      (NODE_TYPE_CODE)0xeb00,
     RDBSS_NTC_VCB             =      (NODE_TYPE_CODE)0xeb01,
     RDBSS_NTC_ROOT_DCB        =      (NODE_TYPE_CODE)0xeb04,
     RDBSS_NTC_FOBX            =      (NODE_TYPE_CODE)0xeb07,
     RDBSS_NTC_RX_CONTEXT     =       (NODE_TYPE_CODE)0xeb08,

     RDBSS_NTC_PREFIX_TABLE    =      (NODE_TYPE_CODE)0xeb0d,
     RDBSS_NTC_PREFIX_ENTRY    =      (NODE_TYPE_CODE)0xeb0e,

     RDBSS_NTC_FCB_TABLE       =      (NODE_TYPE_CODE)0xeb09,
     RDBSS_NTC_FCB_TABLE_ENTRY =      (NODE_TYPE_CODE)0xeb0a,

     RDBSS_NTC_RXCE_TRANSPORT  =      (NODE_TYPE_CODE)0xeb71,
     RDBSS_NTC_RXCE_ADDRESS    =      (NODE_TYPE_CODE)0xeb72,
     RDBSS_NTC_RXCE_CONNECTION =      (NODE_TYPE_CODE)0xeb73,
     RDBSS_NTC_RXCE_VC         =      (NODE_TYPE_CODE)0xeb74,

     RDBSS_NTC_NONPAGED_FCB     =      (NODE_TYPE_CODE)0xebfd,
     RDBSS_NTC_COMMON_DISPATCH  =      (NODE_TYPE_CODE)0xebfe,
     RDBSS_NTC_MINIRDR_DISPATCH =      (NODE_TYPE_CODE)0xebff

} RDBSS_STORAGE_TYPE_CODES;

#define RDBSS_NTC_FCB                      RDBSS_NTC_STORAGE_TYPE_FILE

#define NodeTypeIsFcb(FCB) \
    (  ((NodeType(FCB)&0xff00)== RDBSS_STORAGE_NTC(0)) ||  ((NodeType(FCB)&0xfff0)==0xeb90)   )

// a mask to alter the type of a data structure once it is marked for scavenging so
// that subsequent tests will fail.

#define RX_SCAVENGER_MASK (0x1000)


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded the line number of the
//  bugcheck call in the low order 16 bits. The high order bits can be whatever
//  the caller wants. In the wrapper, we actually define file identifiers as well.
//  However, the system also displays quire a but of the backtrace; this shows
//  the .sys file of the caller and it is frequently the case that the linenumber
//  is completely disambiguating.

//  Each individual wrapper file that calls bugcheck has defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  RDBSS_BUG_CHECK_ values defined below and then use RxBugCheck to bugcheck
//  the system.
//


typedef enum _RDBSS_BUG_CHECK_CODES {

     RDBSS_BUG_CHECK_FCBSTRUC  = 0xfcb00000,
     RDBSS_BUG_CHECK_CACHESUP  = 0xca550000,
     RDBSS_BUG_CHECK_CLEANUP   = 0xc1ee0000,
     RDBSS_BUG_CHECK_CLOSE     = 0xc10e0000,
     RDBSS_BUG_CHECK_NTEXCEPT  = 0xbaad0000,

} RDBSS_BUG_CHECK_CODES;

// we overload on the original redirector's bugcheck code using the stack
// backtrace to differentiate among consumers

#define RDBSS_FILE_SYSTEM RDR_FILE_SYSTEM
#define RxBugCheck(A,B,C) { \
        KeBugCheckEx(RDBSS_FILE_SYSTEM, \
                     BugCheckFileId | ((ULONG)(__LINE__)), \
                     A, B, C ); \
        }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#endif // _NODETYPE_INCLUDED_



#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\netdma.h ===
/*++

Copyright (c) 2005-2006  Microsoft Corporation

Module Name:

    netdma.h

Abstract:

    This module contains function prototypes and definitons for memory to memory DMA
    providers

Author:

    
Revision history:
    Nov 2006: Added support for a subset of IOAT V2 features (page break and descriptor ring)
    Feb 2005: Original version
    
Environment:

    kernel mode only

--*/

#ifndef _NET_DMA_H
#define _NET_DMA_H

#undef NET_DMA_EXPORT
#if defined(NET_DMA)
#define NET_DMA_EXPORT
#else
#define NET_DMA_EXPORT DECLSPEC_IMPORT
#endif

//
// flags used in NET_DMA_DESCRIPTOR->ControlFlags
//
#define NET_DMA_INTERRUPT_ON_COMPLETION     0x00000001
#define NET_DMA_SOURCE_NO_SNOOP             0x00000002
#define NET_DMA_DESTINATION_NO_SNOOP        0x00000004
#define NET_DMA_STATUS_UPDATE_ON_COMPLETION 0x00000008
#define NET_DMA_SERIALIZE_TRANSFER          0x00000010      // fence bit
#define NET_DMA_NULL_TRANSFER               0x00000020

//
// new flags supported in NETDMA V2
//

#define NET_DMA_SOURCE_PAGE_BREAK           0x00000040
#define NET_DMA_DESTINATION_PAGE_BREAK      0x00000080
#define NET_DMA_DESTINATION_DCA_ENABLE      0x00000200

//
// flags used in NET_DMA_DESCRIPTOR->ControlFlags with NET_DMA_OP_TYPE_CONTEXT_CHANGE
//
#define NET_DMA_DCA_CONTEXT_CHANGE          0x00000001


#define NET_DMA_OP_TYPE_STANDARD_DMA        0x00000000
#define NET_DMA_OP_TYPE_CONTEXT_CHANGE      0xFF000000


//
// The low 3 bits in "Completed Descriptor Address" are used
// to indicate the status of a DMA transfer. The physical and virtual address of 
// "Completed Descriptor Address" of a DMA channel are specified 
// by CompletionVirtualAddress and CompletionPhysicalAddress fields of 
// NET_DMA_CHANNEL_PARAMETERS at the time of allocating a DMA channel
//
#define NET_DMA_TRANSFER_STATUS_MASK        0x00000007

typedef enum _NET_DMA_TRANSFER_STATUS
{
    NetDmaTransferStatusActive = 0,     // 000 = Active, transfer completed successfully. This was -not- the last pending descriptor
    NetDmaTransferStatusIdle = 1,       // 001 = Idle, transfer completed successfully. This was the last pending descriptor
    NetDmaTransferStatusSuspend = 2,    // 010 = Suspend completed (no hard error). DMA channel is in Halt state
    NetDmaTransferStatusHalted = 3,     // 011 = Halted, operation aborted
    NetDmaTransferStatusArmed = 4       // 100 = Armed, first descriptor has not yet completed and Completed Descriptor Address is not valid
} NET_DMA_TRANSFER_STATUS, *PNET_DMA_TRANSFER_STATUS;
        
  
//
// NET_DMA_DESCRIPTOR data structure is used to submit a dma transfer to DMA engine
// DMA descriptors can be chained together. Descriptor structure is modeled after
// CB DMA descriptors. DMA descriptors are aligned on 64 bit boundary
//
typedef struct _NET_DMA_DESCRIPTOR
{
    union
    {
        ULONG               TransferSize;       // DMA Transfer size
        // DCA context = the APIC ID of the target CPU
        struct 
        {
            ULONG           DCAContext:32;
        }DCAContext32;
        struct
        {   
            ULONG           DCAContext:16;
            ULONG           Reserved:16;
        }DCAContext16;
        struct
        {
            ULONG           DCAContext:8;
            ULONG           Reserved:24;
        }DCAContext8;
    };
    
    ULONG               ControlFlags;           // see NET_DMA_xxx flags
    PHYSICAL_ADDRESS    SourceAddress;          // Source physical address
    PHYSICAL_ADDRESS    DestinationAddress;     // Destination physical address
    PHYSICAL_ADDRESS    NextDescriptor;         // Physical address of the next descriptor in the chain
    union
    {
        ULONG64             Reserved1;              // reserved for use by DMA engine (Provider)
        PHYSICAL_ADDRESS    NextSourceAddress;
    };
    union
    {
        ULONG64             Reserved2;              // reserved for use by DMA engine (Provider)
        PHYSICAL_ADDRESS    NextDestinationAddress;
    };
    ULONG64             UserContext1;           // Used by netdma driver and/or DMA client
    ULONG64             UserContext2;           // Used by netdma driver and/or DMA client
} NET_DMA_DESCRIPTOR, *PNET_DMA_DESCRIPTOR;


//
// DMA Provider entry points
//

typedef struct _NET_DMA_CHANNEL_CPU_AFFINITY
{
    ULONG   DmaChannel;
    ULONG   CpuNumber;
}NET_DMA_CHANNEL_CPU_AFFINITY,*PNET_DMA_CHANNEL_CPU_AFFINITY;

//
// DMA channel CPU affinity handler. NETDMA calls this entry point to set the affinity
// policy of DMA channels
//
typedef
NTSTATUS
(*DMA_CHANNELS_CPU_AFFINITY_HANDLER)(
    IN  PVOID   ProviderContext,                        // the Provider context passed to NetDmaRegisterProvider
    IN  PNET_DMA_CHANNEL_CPU_AFFINITY CpuAffinityArray, // see NET_DMA_CHANNEL_CPU_AFFINITY
    IN  ULONG   CpuAffinityArraySize                    // size of CpuAffinityArray
    );


//
// NET_DMA_CHANNEL_PARAMETERS is used to set up a DMA channel
// at the time of allocating the channel
//

#define NET_DMA_CHANNEL_REVISION_1  1

typedef struct _NET_DMA_CHANNEL_PARAMETERS
{
    USHORT              Revision;                   // Structure revision
    USHORT              Size;                       // size of this structure
    ULONG               Flags;                      // TBD
    PVOID               CompletionVirtualAddress;   // the virtual address where the engine will write the completion status
    PHYSICAL_ADDRESS    CompletionPhysicalAddress;  // the physical address where the engine will write the completion status
    ULONG               ProcessorAffinityMask;      // bitmap of CPUs that this channel could be associated with
    ULONG               ChannelPriority;            // per CB spec
    ULONG               CpuNumber;                  // provider will fill this with the CPU this channel is associated with
} NET_DMA_CHANNEL_PARAMETERS, *PNET_DMA_CHANNEL_PARAMETERS;

//
// DMA channel Allocate handler. NETDMA calls this entry point to allocate a DMA channel
//
typedef
NTSTATUS
(*DMA_CHANNEL_ALLOCATE_HANDLER)(
    IN  PVOID   ProviderContext,                        // the Provider context passed to NetDmaRegisterProvider
    IN  PNET_DMA_CHANNEL_PARAMETERS ChannelParameters,  // see NET_DMA_CHANNEL_PARAMETERS
    IN  PVOID   NetDmaChannelHandle,                    // NETDMA handle for this channel. used by all calls from Provider to NETDMA regarding this channel
    OUT PVOID * pProviderChannelContext                 // on return holds Provider context for this channel. used in all calls from NETDMA to provider regarding this channel
    );

//
// NETDMA calls this entry point to free a DMA channel. When NETDMA calls this
// entry points, there are no outstanding DMA operations on this channel. Once
// NETDMA makes this call, it can not call the provider for any operation on the
// channel
// 

typedef
VOID
(*DMA_CHANNEL_FREE_HANDLER)(
    IN  PVOID   ProviderChannelContext               // Provider context for this channel (retuned from DMA_CHANNEL_ALLOCATE_HANDLER in pProviderChannelContext)
    );

//
// NETDMA calls this entry point to start a DMA transfer
//
typedef
NTSTATUS
(*DMA_START_HANDLER)(
    IN  PVOID                   ProviderChannelContext,     // Provider context for this channel
    IN  PNET_DMA_DESCRIPTOR     DescriptorVirtualAddress,   // pointer to the virtual address of the first descriptor
    IN  PHYSICAL_ADDRESS        DescriptorPhysicalAddress,  // pointer to the physical address of the first descriptor
    IN  ULONG                   DescriptorCount             // number of descriptors
    );

//
// NETDMA calls this entry point to suspend the DMA transfers
// currently in progress. The provider will return the
// physical address of the last DMA descriptor that it processed
//
typedef
NTSTATUS
(*DMA_SUSPEND_HANDLER)(
    IN  PVOID                   ProviderChannelContext,     // Provider context for this channel
    OUT PPHYSICAL_ADDRESS*      pLastDescriptor             // the physical address of the last processed descriptor
    );

//
// NETDMA calls this entry point to resume DMA operations on 
// a suspended DMA channel
//
typedef
NTSTATUS
(*DMA_RESUME_HANDLER)(
    IN  PVOID   ProviderChannelContext                      // Provider context for this channel
    );

//
// NETDMA calls this entry point to abort all DMA transfers
// that have been scheduled on a DMA channel
//
typedef
NTSTATUS
(*DMA_ABORT_HANDLER)(
    IN  PVOID   ProviderChannelContext                      // Provider context for this channel
    );

//
// NETDMA calls this entry point to append a chain of DMA descriptors
// to the last descriptor on a DMA channel
//
typedef
NTSTATUS
(*DMA_APPEND_HANDLER)(
    IN  PVOID                   ProviderChannelContext,     // Provider context for this channel
    IN  PNET_DMA_DESCRIPTOR     DescriptorVirtualAddress,   // pointer to the virtual address of the first descriptor to append
    IN  PHYSICAL_ADDRESS        DescriptorPhysicalAddress,  // pointer to the physical address of the first descriptor to append
    IN  ULONG                   DescriptorCount             // number of descriptors
    );

//
// TBD:
//
typedef
NTSTATUS
(*DMA_RESET_HANDLER)(
    IN  PVOID   ProviderChannelContext
    );


//
// DMA providers use NET_DMA_PROVIDER_CHARACTERISTICS structure in the call to 
// NetDmaRegisterProvider
//
#define NET_DMA_PROVIDER_REVISION_1  1
#define NET_DMA_PROVIDER_REVISION_2  2

typedef struct _NET_DMA_PROVIDER_CHARACTERISTICS
{
    UCHAR                           MajorVersion;               // Major version of the DMA provider
    UCHAR                           MinorVersion;               // Minor version of the DMA provider
    USHORT                          Size;                       // the size of this structure
    ULONG                           Flags;                      // TBD
    PDEVICE_OBJECT                  PhysicalDeviceObject;       // The physical device object PnP associates with this device
    ULONG                           MaxDmaChannelCount;         // Maximum number of DMA channels
    DMA_CHANNELS_CPU_AFFINITY_HANDLER SetDmaChannelCpuAffinity; // Set channel CPU affinity handler
    DMA_CHANNEL_ALLOCATE_HANDLER    AllocateDmaChannel;         // Allocate DMA channel handler
    DMA_CHANNEL_FREE_HANDLER        FreeDmaChannel;             // Free DMA channel handler
    DMA_START_HANDLER               StartDma;                   // Start DMA handler
    DMA_SUSPEND_HANDLER             SuspendDma;                 // Suspend DMA handler
    DMA_RESUME_HANDLER              ResumeDma;                  // Resume DMA handler
    DMA_ABORT_HANDLER               AbortDma;                   // Abort DMA handler
    DMA_APPEND_HANDLER              AppendDma;                  // Append DMA handler
    DMA_RESET_HANDLER               ResetChannel;               // Reset channel handler
    UNICODE_STRING                  FriendlyName;               // Provider's friendly name
} NET_DMA_PROVIDER_CHARACTERISTICS, *PNET_DMA_PROVIDER_CHARACTERISTICS;


//
// DMA providers call NetDmaRegisterProvider to register an instance of a 
// DMA provider. An instance of a DMA provider is associated with a device
// (DMA engine). Providers usually make this call in their AddDevice entry point.
// Note: the reason that the call has to be made during AddDevice and not
// START IRP is because allocating MSI-X resources has to be done in
// FILTER_RESOURCE_REQUIREMENTS that is sent to the device drivers before
// the START IRP
//
NET_DMA_EXPORT
NTSTATUS
NetDmaRegisterProvider(
    IN  PVOID                           ProviderContext,                // Provider context for this device
    IN  PVOID *                         pNetDmaProviderHandle,          // upon return, this will hold NETDMA handle for this device
    IN  PNET_DMA_PROVIDER_CHARACTERISTICS ProviderCharacteristics       // provider's characteristics
    );

//
// DMA providers call NetDmaDeregisterProvider to deregister a provider
// that was previously registered by a call to NetDmaRegisterProvider
// the call is usually made while handling REMOVE IRP. 
//
NET_DMA_EXPORT
VOID
NetDmaDeregisterProvider(
    IN PVOID                        NetDmaProviderHandle                // Handle obtained by the call to NetDmaRegisterProvider
    );

#define NET_DMA_PROVIDER_ATTRIBUTES_DCA_SUPPORTED   0x00000001

//
// DMA providers use this structure in the call to NetDmaProviderStart
//

typedef struct _NET_DMA_PROVIDER_ATTRIBUTES
{
    UCHAR                           MajorHwVersion;             // Major version of the DMA provider
    UCHAR                           MinorHwVersion;             // Minor version of the DMA provider
    USHORT                          Size;                       // the size of this structure
    ULONG                           Flags;                      // TBD
    ULONG                           VendorId;                   // vendor ID
    ULONG                           DmaChannelCount;            // number of DMA channels
    ULONG                           MaximumTransferSize;        // Maximum DMA transfer size (minimum of 4K)
    PHYSICAL_ADDRESS                MaximumAddressSpace;        // Maximum physical adddress that can be addressed by this device
} NET_DMA_PROVIDER_ATTRIBUTES, *PNET_DMA_PROVIDER_ATTRIBUTES;

//
// DMA providers call NetDmaProviderStart to notify NETDMA that all the DMA channels
// on a provider are initialized  and ready to be used. DMA providers call this API in the
// context of handling START IRP.
//
NET_DMA_EXPORT
VOID
NetDmaProviderStart(
    IN PVOID                        NetDmaProviderHandle,      // Handle obtained by the call to NetDmaRegisterProvider
    IN PNET_DMA_PROVIDER_ATTRIBUTES ProviderAttributes         // the provider's device attributes    
    );

//
// DMA providers call NetDmaProviderStop to notify NETDMA that a previously started
// DMA engine is no longer available.
// DMA providers call this API in the context of handling REMOVE or STOP IRP. NETDMA will wait 
// for outstanding DMA operations to complete and frees all the DMA channels
// before returning back from this API
//
NET_DMA_EXPORT
VOID
NetDmaProviderStop(
    IN PVOID                NetDmaProviderHandle        // Handle obtained by the call to NetDmaRegisterProvider                
    );

//
// DMA providers call NetDmaIsr in their ISR handler
//
NET_DMA_EXPORT
VOID
NetDmaIsr(
    IN  PVOID               NetDmaChannelHandle,
    IN  PHYSICAL_ADDRESS    DmaDescriptor,
    OUT PULONG              pCpuNumber
    );

//
// DMA providers call NetDmaInterruptDpc in their interrupt DPC handler
//
NET_DMA_EXPORT
VOID
NetDmaInterruptDpc(
    IN  PVOID               NetDmaChannelHandle,    // DMA channel
    IN  PHYSICAL_ADDRESS    DmaDescriptor OPTIONAL  // optional if this is called for reasons other DMA completion
    );


NET_DMA_EXPORT
UINT
NetDmaGetVersion(
    VOID
    );


typedef enum _NET_DMA_PNP_NOTIFICATION_CODE
{
    NetDmaNotificationProviderRegistered = 1,   // a provider has registered. not used by providers
    NetDmaNotificationProviderArrival,          // a provider is ready for use. not used by providers
    NetDmaNotificationProviderRemoval,          // a provider is about to be removed. not used by providers
    NetDmaNotificationChannelArrival,           // a DMA channel has become available. not used by providers
    NetDmaNotificationProviderPowerDown,        // the DMA provider is going to D3. 
    NetDmaNotificationProviderPowerUp,          // the DMA provider is back to D0
    NetDmaNotificationMax
}NET_DMA_PNP_NOTIFICATION_CODE, *PNET_DMA_PNP_NOTIFICATION_CODE;

#define NET_DMA_PNP_NOTIFICATION_REVISION_1 1

typedef struct _NET_DMA_PNP_NOTIFICATION
{
    ULONG                           StructureRevision;
    ULONG                           StructureSize;
    NET_DMA_PNP_NOTIFICATION_CODE   NotificationCode;
    PVOID                           Buffer;
    ULONG                           BufferLength;
}NET_DMA_PNP_NOTIFICATION, *PNET_DMA_PNP_NOTIFICATION;

//
// this API is available to Providers version 1.1 and above
//
NET_DMA_EXPORT
VOID
NetDmaPnPEventNotify(
    IN  PVOID                       NetDmaProviderHandle,   // Provider handle
    IN  PNET_DMA_PNP_NOTIFICATION   PnPEvent                // PnP and Power Management event
    );

#endif //_NET_DMA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\npapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    npapi.h

Abstract:

    Network Provider API prototypes and manifests.  A network provider
    is a client of the Win32 WNet APIs.  See the "NT/Win32 Network
    Provider API Specification" document for further details.

Environment:

    User Mode -Win32

--*/

#ifndef _NPAPI_INCLUDED
#define _NPAPI_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
//  CONNECTIONS
//

DWORD APIENTRY
NPAddConnection (
    __in     LPNETRESOURCEW lpNetResource,
    __in_opt LPWSTR         lpPassword,
    __in_opt LPWSTR         lpUserName
    );

typedef DWORD (APIENTRY *PF_NPAddConnection) (
    __in     LPNETRESOURCEW lpNetResource,
    __in_opt LPWSTR         lpPassword,
    __in_opt LPWSTR         lpUserName
    );


DWORD APIENTRY
NPAddConnection3 (
    __in_opt HWND           hwndOwner,
    __in     LPNETRESOURCEW lpNetResource,
    __in_opt LPWSTR         lpPassword,
    __in_opt LPWSTR         lpUserName,
    __in     DWORD          dwFlags
    );

typedef DWORD (APIENTRY *PF_NPAddConnection3) (
    __in_opt HWND           hwndOwner,
    __in     LPNETRESOURCEW lpNetResource,
    __in_opt LPWSTR         lpPassword,
    __in_opt LPWSTR         lpUserName,
    __in     DWORD          dwFlags
    );


DWORD APIENTRY
NPCancelConnection (
    __in LPWSTR  lpName,
    __in BOOL    fForce
    );

typedef DWORD (APIENTRY *PF_NPCancelConnection) (
    __in LPWSTR  lpName,
    __in BOOL    fForce
    );


DWORD APIENTRY
NPGetConnection (
    __in LPWSTR     lpLocalName,
    __out_ecount_opt(*lpnBufferLen) LPWSTR lpRemoteName,
    __inout LPDWORD lpnBufferLen
    );

typedef DWORD (APIENTRY *PF_NPGetConnection) (
    __in LPWSTR   lpLocalName,
    __out_ecount_opt(*lpnBufferLen) LPWSTR lpRemoteName,
    __inout LPDWORD lpnBufferLen
    );


#define WNGETCON_CONNECTED      0x00000000
#define WNGETCON_DISCONNECTED   0x00000001

DWORD APIENTRY
NPGetConnection3 (
    __in LPCWSTR    lpLocalName,
    __in DWORD      dwLevel,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

typedef DWORD (APIENTRY *PF_NPGetConnection3) (
    __in LPCWSTR    lpLocalName,
    __in DWORD      dwLevel,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );


DWORD APIENTRY
NPGetUniversalName (
    __in LPCWSTR    lpLocalPath,
    __in DWORD      dwInfoLevel,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

typedef DWORD (APIENTRY *PF_NPGetUniversalName) (
    __in LPCWSTR    lpLocalPath,
    __in DWORD      dwInfoLevel,
    __out_bcount(*lpnBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpnBufferSize
    );

DWORD APIENTRY
NPGetConnectionPerformance (
    __in  LPCWSTR                lpRemoteName,
    __out LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    );

typedef DWORD (APIENTRY *PF_NPGetConnectionPerformance) (
    __in  LPCWSTR                lpRemoteName,
    __out LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    );


DWORD APIENTRY
NPOpenEnum (
    __in     DWORD          dwScope,
    __in     DWORD          dwType,
    __in     DWORD          dwUsage,
    __in_opt LPNETRESOURCEW lpNetResource,
    __out    LPHANDLE       lphEnum
    );

typedef DWORD (APIENTRY *PF_NPOpenEnum) (
    __in     DWORD          dwScope,
    __in     DWORD          dwType,
    __in     DWORD          dwUsage,
    __in_opt LPNETRESOURCEW lpNetResource,
    __out    LPHANDLE       lphEnum
    );

DWORD APIENTRY
NPEnumResource (
    __in    HANDLE  hEnum,
    __inout LPDWORD lpcCount,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

typedef DWORD (APIENTRY *PF_NPEnumResource) (
    __in    HANDLE  hEnum,
    __inout LPDWORD lpcCount,
    __out_bcount(*lpbufferSize) LPVOID  lpBuffer,
    __inout LPDWORD lpBufferSize
    );

DWORD APIENTRY
NPCloseEnum (
    __in HANDLE   hEnum
    );

typedef DWORD (APIENTRY *PF_NPCloseEnum) (
    __in HANDLE   hEnum
    );


//
//  CAPABILITIES
//

#define WNNC_SPEC_VERSION                0x00000001
#define WNNC_SPEC_VERSION51              0x00050001

#define WNNC_NET_TYPE                    0x00000002
#define WNNC_NET_NONE                    0x00000000

#define WNNC_DRIVER_VERSION              0x00000003

#define WNNC_USER                        0x00000004
#define WNNC_USR_GETUSER                 0x00000001

#define WNNC_CONNECTION                  0x00000006
#define WNNC_CON_ADDCONNECTION           0x00000001
#define WNNC_CON_CANCELCONNECTION        0x00000002
#define WNNC_CON_GETCONNECTIONS          0x00000004
#define WNNC_CON_ADDCONNECTION3          0x00000008
#define WNNC_CON_GETPERFORMANCE          0x00000040
#define WNNC_CON_DEFER                   0x00000080

#define WNNC_DIALOG                      0x00000008
#define WNNC_DLG_DEVICEMODE              0x00000001
#define WNNC_DLG_PROPERTYDIALOG          0x00000020
#define WNNC_DLG_SEARCHDIALOG            0x00000040
#define WNNC_DLG_FORMATNETWORKNAME       0x00000080
#define WNNC_DLG_PERMISSIONEDITOR        0x00000100
#define WNNC_DLG_GETRESOURCEPARENT       0x00000200
#define WNNC_DLG_GETRESOURCEINFORMATION  0x00000800

#define WNNC_ADMIN                       0x00000009
#define WNNC_ADM_GETDIRECTORYTYPE        0x00000001
#define WNNC_ADM_DIRECTORYNOTIFY         0x00000002

#define WNNC_ENUMERATION                 0x0000000B
#define WNNC_ENUM_GLOBAL                 0x00000001
#define WNNC_ENUM_LOCAL                  0x00000002
#define WNNC_ENUM_CONTEXT                0x00000004
#define WNNC_ENUM_SHAREABLE              0x00000008

#define WNNC_START                       0x0000000C
#define WNNC_WAIT_FOR_START              0x00000001

#define WNNC_CONNECTION_FLAGS            0x0000000D
#define WNNC_CF_DEFAULT ( CONNECT_TEMPORARY | CONNECT_INTERACTIVE | CONNECT_PROMPT )
#define WNNC_CF_MAXIMUM (WNNC_CF_DEFAULT | CONNECT_DEFERRED | CONNECT_COMMANDLINE | CONNECT_CMD_SAVECRED | CONNECT_CRED_RESET)



DWORD APIENTRY
NPGetCaps (
    __in DWORD ndex
    );

typedef DWORD (APIENTRY *PF_NPGetCaps) (
    __in DWORD ndex
    );

//
//  OTHER
//

DWORD APIENTRY
NPGetUser (
    __in    LPWSTR  lpName,
    __out_ecount(*lpnBufferLen) LPWSTR lpUserName,
    __inout LPDWORD lpnBufferLen
    );

typedef DWORD (APIENTRY *PF_NPGetUser) (
    __in    LPWSTR  lpName,
    __out_ecount(*lpnBufferLen) LPWSTR lpUserName,
    __inout LPDWORD lpnBufferLen
    );

#define WNTYPE_DRIVE    1
#define WNTYPE_FILE     2
#define WNTYPE_PRINTER  3
#define WNTYPE_COMM     4

#define WNPS_FILE       0
#define WNPS_DIR        1
#define WNPS_MULT       2

DWORD APIENTRY
NPDeviceMode(
    __in HWND hParent
    );

typedef DWORD (APIENTRY *PF_NPDeviceMode) (
    __in HWND hParent
    );

// flag for search dialog
#define WNSRCH_REFRESH_FIRST_LEVEL 0x00000001

DWORD APIENTRY
NPSearchDialog(
    __in     HWND   hwndParent,
    __in_opt LPNETRESOURCEW lpNetResource,
    __out_ecount(cbBuffer) LPVOID lpBuffer,
    __in     DWORD   cbBuffer,
    __out    LPDWORD lpnFlags
    );

typedef DWORD (APIENTRY *PF_NPSearchDialog) (
    __in     HWND   hwndParent,
    __in_opt LPNETRESOURCEW lpNetResource,
    __out_ecount(cbBuffer) LPVOID lpBuffer,
    __in     DWORD   cbBuffer,
    __out    LPDWORD lpnFlags
    );

DWORD APIENTRY
NPGetResourceParent(
    __in LPNETRESOURCEW lpNetResource,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

typedef DWORD (APIENTRY *PF_NPGetResourceParent) (
    __in LPNETRESOURCEW lpNetResource,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

DWORD APIENTRY NPGetResourceInformation(
    __in LPNETRESOURCEW lpNetResource,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize,
    __deref_out LPWSTR *lplpSystem
    );

typedef DWORD (APIENTRY *PF_NPGetResourceInformation) (
    __in LPNETRESOURCEW lpNetResource,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize,
    __deref_out LPWSTR *lplpSystem
    );

DWORD APIENTRY
NPFormatNetworkName(
    __in    LPWSTR   lpRemoteName,
    __out_ecount(*lpnLength) LPWSTR lpFormattedName,
    __inout LPDWORD  lpnLength,
    __in    DWORD    dwFlags,
    __in    DWORD    dwAveCharPerLine
    );

typedef DWORD (APIENTRY *PF_NPFormatNetworkName) (
    __in    LPWSTR   lpRemoteName,
    __out_ecount(*lpnLength) LPWSTR lpFormattedName,
    __inout LPDWORD  lpnLength,
    __in    DWORD    dwFlags,
    __in    DWORD    dwAveCharPerLine
    );

DWORD APIENTRY
NPGetPropertyText(
    __in DWORD  iButton,
    __in DWORD  nPropSel,
    __in LPWSTR lpName,
    __out_ecount(nButtonNameLen) LPWSTR lpButtonName,
    __in DWORD  nButtonNameLen,
    __in DWORD  nType
    );

typedef DWORD (APIENTRY *PF_NPGetPropertyText) (
    __in DWORD  iButton,
    __in DWORD  nPropSel,
    __in LPWSTR lpName,
    __out_ecount(nButtonNameLen) LPWSTR lpButtonName,
    __in DWORD  nButtonNameLen,
    __in DWORD  nType
    );

DWORD APIENTRY
NPPropertyDialog(
    __in HWND   hwndParent,
    __in DWORD  iButtonDlg,
    __in DWORD  nPropSel,
    __in LPWSTR lpFileName,
    __in DWORD  nType
    );

typedef DWORD (APIENTRY *PF_NPPropertyDialog) (
    __in HWND   hwndParent,
    __in DWORD  iButtonDlg,
    __in DWORD  nPropSel,
    __in LPWSTR lpFileName,
    __in DWORD  nType
    );


//
//  ADMIN
//

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR    1
#define WNDN_RMDIR    2
#define WNDN_MVDIR    3

DWORD APIENTRY
NPGetDirectoryType (
    __in LPWSTR  lpName,
    __in LPINT   lpType,
    __in BOOL    bFlushCache
    );

typedef DWORD (APIENTRY *PF_NPGetDirectoryType) (
    __in LPWSTR  lpName,
    __in LPINT   lpType,
    __in BOOL    bFlushCache
    );

DWORD APIENTRY
NPDirectoryNotify (
    __in HWND    hwnd,
    __in LPWSTR  lpDir,
    __in DWORD   dwOper
    );

typedef DWORD (APIENTRY *PF_NPDirectoryNotify) (
    __in HWND    hwnd,
    __in LPWSTR  lpDir,
    __in DWORD   dwOper
    );

VOID
WNetSetLastErrorA(
    __in DWORD   err,
    __in LPSTR   lpError,
    __in LPSTR   lpProviders
    );

VOID
WNetSetLastErrorW(
    __in DWORD   err,
    __in LPWSTR  lpError,
    __in LPWSTR  lpProviders
    );

#ifdef UNICODE
#define WNetSetLastError   WNetSetLastErrorW
#else
#define WNetSetLastError   WNetSetLastErrorA
#endif  // UNICODE

//
//  CREDENTIAL MANAGEMENT and other classes of providers
//


// Define the Net/Authentication and othr Provider Classes
#define WN_NETWORK_CLASS            0x00000001
#define WN_CREDENTIAL_CLASS         0x00000002
#define WN_PRIMARY_AUTHENT_CLASS    0x00000004
#define WN_SERVICE_CLASS            0x00000008

#define WN_VALID_LOGON_ACCOUNT      0x00000001
#define WN_NT_PASSWORD_CHANGED      0x00000002

DWORD APIENTRY
NPLogonNotify (
    __in     PLUID               lpLogonId,
    __in     LPCWSTR             lpAuthentInfoType,
    __in     LPVOID              lpAuthentInfo,
    __in_opt LPCWSTR             lpPreviousAuthentInfoType,
    __in_opt LPVOID              lpPreviousAuthentInfo,
    __in     LPWSTR              lpStationName,
    __in_opt LPVOID              StationHandle,
    __out    LPWSTR              *lpLogonScript
    );

typedef DWORD (APIENTRY *PF_NPLogonNotify) (
    __in     PLUID               lpLogonId,
    __in     LPCWSTR             lpAuthentInfoType,
    __in     LPVOID              lpAuthentInfo,
    __in_opt LPCWSTR             lpPreviousAuthentInfoType,
    __in_opt LPVOID              lpPreviousAuthentInfo,
    __in     LPWSTR              lpStationName,
    __in_opt LPVOID              StationHandle,
    __out    LPWSTR              *lpLogonScript
    );

DWORD APIENTRY
NPPasswordChangeNotify (
    __in     LPCWSTR             lpAuthentInfoType,
    __in     LPVOID              lpAuthentInfo,
    __in     LPCWSTR             lpPreviousAuthentInfoType,
    __in     LPVOID              lpPreviousAuthentInfo,
    __in     LPWSTR              lpStationName,
    __in_opt LPVOID              StationHandle,
    __in     DWORD               dwChangeInfo
    );

typedef DWORD (APIENTRY *PF_NPPasswordChangeNotify) (
    __in     LPCWSTR             lpAuthentInfoType,
    __in     LPVOID              lpAuthentInfo,
    __in     LPCWSTR             lpPreviousAuthentInfoType,
    __in     LPVOID              lpPreviousAuthentInfo,
    __in     LPWSTR              lpStationName,
    __in_opt LPVOID              StationHandle,
    __in     DWORD               dwChangeInfo
    );

//
//  CONNECTION NOTIFICATION
//

//
// NotifyStatus
//
#define NOTIFY_PRE      0x00000001
#define NOTIFY_POST     0x00000002

typedef struct _NOTIFYINFO {
    DWORD       dwNotifyStatus;
    DWORD       dwOperationStatus;
    LPVOID      lpContext;
} NOTIFYINFO, *LPNOTIFYINFO;

typedef struct _NOTIFYADD {
    HWND            hwndOwner;
    NETRESOURCE     NetResource;
    DWORD           dwAddFlags;
} NOTIFYADD, *LPNOTIFYADD;

typedef struct _NOTIFYCANCEL {
    LPWSTR      lpName;
    LPWSTR      lpProvider;
    DWORD       dwFlags;
    BOOL        fForce;
} NOTIFYCANCEL, *LPNOTIFYCANCEL;


DWORD APIENTRY
AddConnectNotify (
    __inout LPNOTIFYINFO lpNotifyInfo,
    __in    LPNOTIFYADD  lpAddInfo
    );

typedef DWORD (APIENTRY *PF_AddConnectNotify) (
    __inout LPNOTIFYINFO lpNotifyInfo,
    __in    LPNOTIFYADD  lpAddInfo
    );

DWORD APIENTRY
CancelConnectNotify (
    __inout LPNOTIFYINFO   lpNotifyInfo,
    __in    LPNOTIFYCANCEL lpCancelInfo
    );

typedef DWORD (APIENTRY *PF_CancelConnectNotify) (
    __inout LPNOTIFYINFO   lpNotifyInfo,
    __in    LPNOTIFYCANCEL lpCancelInfo
    );

//
// Permission editor dialogs
//

//
// Capabilities bits of permission editor dialogs
//
#define WNPERMC_PERM  0x00000001
#define WNPERMC_AUDIT 0x00000002
#define WNPERMC_OWNER 0x00000004

DWORD APIENTRY
NPFMXGetPermCaps (
    __in LPWSTR lpDriveName
    );

typedef DWORD (APIENTRY *PF_NPFMXGetPermCaps) (
    __in LPWSTR lpDriveName
    );

//
// Type of security dialog
//
#define WNPERM_DLG_PERM   0
#define WNPERM_DLG_AUDIT  1
#define WNPERM_DLG_OWNER  2

DWORD APIENTRY
NPFMXEditPerm (
    __in LPWSTR lpDriveName,
    __in HWND   hwndFMX,
    __in DWORD  nDialogType
    );

typedef DWORD (APIENTRY *PF_NPFMXEditPerm) (
    __in LPWSTR lpDriveName,
    __in HWND   hwndFMX,
    __in DWORD  nDialogType
    );

DWORD APIENTRY
NPFMXGetPermHelp (
    __in    LPWSTR  lpDriveName,
    __in    DWORD   nDialogType,
    __in    BOOL    fDirectory,
    __out_ecount(*lpBufferSize) LPVOID lpFileNameBuffer,
    __inout LPDWORD lpBufferSize,
    __out   LPDWORD lpnHelpContext
    );

typedef DWORD (APIENTRY *PF_NPFMXGetPermHelp) (
    __in    LPWSTR  lpDriveName,
    __in    DWORD   nDialogType,
    __in    BOOL    fDirectory,
    __out_ecount(*lpBufferSize) LPVOID lpFileNameBuffer,
    __inout LPDWORD lpBufferSize,
    __out   LPDWORD lpnHelpContext
    );

#ifdef __cplusplus
}
#endif

#endif  // _NPAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntagp.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ntagp.h

Abstract:

    This file defines the external interface for the AGP bus filter driver


Revision History:

--*/
#ifndef _NTAGP_
#define _NTAGP_

#if _MSC_VER > 1000
#pragma once
#endif

typedef struct _AGP_INFO_COMMON
{
    PCI_AGP_CAPABILITY  MasterCap;
    PCI_AGP_CAPABILITY  TargetCap;    
    USHORT              DeviceId;
    USHORT              VendorId;
    USHORT              SubVendorId;
    USHORT              SubSystemId;
    UCHAR               HwRevisionId;
    ULONG               VerifierFlags;
    BOOLEAN             GuardPageCorruption;        
}AGP_INFO_COMMON, *PAGP_INFO_COMMON;

typedef struct _AGP_INFO_DRIVER
{
    ULONG               AGPReg1;
    ULONG               AGPReg2;              
    PHYSICAL_ADDRESS    ApertureStart;
    PHYSICAL_ADDRESS    GartTranslationTable;
    ULONG               ApertureLength;
}AGP_INFO_DRIVER, *PAGP_INFO_DRIVER;

typedef struct
{    
    //
    // This is gerneic info collected by the AgpLib
    //
    AGP_INFO_COMMON CommonInfo;

    //
    // The following data is collected differently by each AGP driver
    //
    AGP_INFO_DRIVER DriverInfo;    
}AGP_INFO, *PAGP_INFO;

DEFINE_GUID(GUID_AGP_BUS_INTERFACE_STANDARD, 0x2ef74803, 0xd8d3, 0x11d1, 0x9c, 0xaa, 0x00, 0xc0, 0xf0, 0x16, 0x56, 0x36 );
//
// Define AGP Interface version
//
#define AGP_BUS_INTERFACE_V1 1
#define AGP_BUS_INTERFACE_V2 2
#define AGP_BUS_INTERFACE_V3 3
#define AGP_BUS_INTERFACE_V4 4
#define AGP_BUS_INTERFACE_V5 5

//
// Define AGP Capabilities field
//
#define AGP_CAPABILITIES_MAP_PHYSICAL       0x00000001
#define AGP_CAPABILITIES_CACHE_COHERENT     0x00000002
#define AGP_CAPABILITIES_REQUIRES_GPU_FLUSH 0x00000004

//
// Video can disable SBA and/or FW by OR'ing these into AgpSetRate's AgpRate
// parameter
//
#define AGP_SET_RATE_DISABLE_SBA 0x00010000
#define AGP_SET_RATE_DISABLE_FW  0x00020000

typedef
NTSTATUS
(*PAGP_BUS_SET_RATE)(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

typedef
NTSTATUS
(*PAGP_BUS_RESERVE_MEMORY)(
    IN PVOID AgpContext,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    );

typedef
NTSTATUS
(*PAGP_BUS_RELEASE_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle
    );

typedef
NTSTATUS
(*PAGP_BUS_COMMIT_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

typedef
NTSTATUS
(*PAGP_BUS_FREE_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

typedef
NTSTATUS
(*PAGP_GET_MAPPED_PAGES)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mld
    );

typedef
NTSTATUS
(*PAGP_MAP_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN PMDL Mdl,
    OUT PHYSICAL_ADDRESS *MemoryBase    
    );

typedef
NTSTATUS
(*PAGP_UNMAP_MEMORY)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN PMDL Mdl
    );

typedef
NTSTATUS
(*PAGP_FLUSH_CHIPSET_CACHES)(
    IN PVOID AgpContext
    );
    
typedef
NTSTATUS
(*PAGP_CHECK_INTEGRITY)(
    IN PVOID AgpContext
    );

typedef
NTSTATUS
(*PAGP_MAP_MEMORY_EX)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN PMDL Mdl,
    IN OPTIONAL MEMORY_CACHING_TYPE *CacheTypeOverride,
    OUT PHYSICAL_ADDRESS *MemoryBase    
    );

typedef
NTSTATUS
(*PAGP_UNMAP_MEMORY_EX)(
    IN PVOID AgpContext,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN PMDL Mdl
    );

typedef
NTSTATUS
(*PAGP_FLUSH_GART_TLB)(
    IN PVOID AgpContext
    );

typedef
NTSTATUS
(*PAGP_CHECK_GUARD_PAGE)(
    IN PVOID AgpContext,
    IN ULONG Flags,
    IN ULONG ULongsToCheck
    );

typedef
VOID
(*PAGP_GET_INFO)(
    IN PVOID AgpContext,
    OUT PAGP_INFO AgpInfo
    );


#define AGP_GUARD_PAGE_CHECK_FIRST_ULONG        0x00000001
#define AGP_GUARD_PAGE_CHECK_USE_SAME_OFFSET    0x00000002
#define AGP_GUARD_PAGE_CHECK_DO_NOT_BUGCHECK    0x00000004

typedef struct _AGP_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID AgpContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // AGP bus interfaces (Version 1.0)
    //

    ULONG Capabilities;
    PAGP_BUS_RESERVE_MEMORY ReserveMemory;
    PAGP_BUS_RELEASE_MEMORY ReleaseMemory;
    PAGP_BUS_COMMIT_MEMORY CommitMemory;
    PAGP_BUS_FREE_MEMORY FreeMemory;
    PAGP_GET_MAPPED_PAGES GetMappedPages;
    
    //
    // New functionnality in Version 2.0 of the interface.
    //
    
    PAGP_BUS_SET_RATE SetRate;
    
    //
    // New functionnality in Version 3.0 of the interface.
    //
    
    SIZE_T AgpSize;
    PHYSICAL_ADDRESS AgpBase;
    PHYSICAL_ADDRESS MaxPhysicalAddress;
    PAGP_MAP_MEMORY MapMemory;
    PAGP_UNMAP_MEMORY UnMapMemory;
    
    //
    // New functionnality in Version 4.0 of the interface.
    //    
    
    PAGP_FLUSH_CHIPSET_CACHES FlushChipsetCaches;
    PAGP_CHECK_INTEGRITY CheckIntegrity;

    //
    // New functionnality in Version 5.0 of the interface.
    //    
    PAGP_MAP_MEMORY_EX  MapMemoryEx;
    PAGP_UNMAP_MEMORY_EX UnMapMemoryEx;
    PAGP_FLUSH_GART_TLB FlushGartTLB;   
    PAGP_CHECK_GUARD_PAGE CheckGuardPage;
    PAGP_GET_INFO GetAgpInfo;
} AGP_BUS_INTERFACE_STANDARD, *PAGP_BUS_INTERFACE_STANDARD;

//
// Support for older version of the interface.
//

#define AGP_BUS_INTERFACE_V1_SIZE \
    (FIELD_OFFSET(AGP_BUS_INTERFACE_STANDARD,SetRate))

#define AGP_BUS_INTERFACE_V2_SIZE \
    (FIELD_OFFSET(AGP_BUS_INTERFACE_STANDARD, AgpSize))
    
#define AGP_BUS_INTERFACE_V3_SIZE \
    (FIELD_OFFSET(AGP_BUS_INTERFACE_STANDARD, FlushChipsetCaches))    

#define AGP_BUS_INTERFACE_V4_SIZE \
    (FIELD_OFFSET(AGP_BUS_INTERFACE_STANDARD, MapMemoryEx))  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\netpnp.h ===
#ifndef __NET_PNP__
#define __NET_PNP__

#pragma once

//
//  PnP and PM event codes that can be indicated up to transports
//  and clients.
//
typedef enum _NET_PNP_EVENT_CODE
{
    NetEventSetPower,
    NetEventQueryPower,
    NetEventQueryRemoveDevice,
    NetEventCancelRemoveDevice,
    NetEventReconfigure,
    NetEventBindList,
    NetEventBindsComplete,
    NetEventPnPCapabilities,
    NetEventPause,
    NetEventRestart,
    NetEventPortActivation,
    NetEventPortDeactivation,
    NetEventIMReEnableDevice,
    NetEventMaximum
} NET_PNP_EVENT_CODE, *PNET_PNP_EVENT_CODE;

//
//  Networking PnP event indication structure.
//
typedef struct _NET_PNP_EVENT
{
    //
    //  Event code describing action to take.
    //
    NET_PNP_EVENT_CODE  NetEvent;

    //
    //  Event specific data.
    //
    PVOID               Buffer;

    //
    //  Length of event specific data.
    //
    ULONG               BufferLength;

    //
    //  Reserved values are for use by respective components only.
    //
    //  Note: these reserved areas must be pointer aligned.
    //  

    ULONG_PTR           NdisReserved[4];
    ULONG_PTR           TransportReserved[4];
    ULONG_PTR           TdiReserved[4];
    ULONG_PTR           TdiClientReserved[4];
} NET_PNP_EVENT, *PNET_PNP_EVENT;

//
//  The following structure defines the device power states.
//
typedef enum _NET_DEVICE_POWER_STATE
{
    NetDeviceStateUnspecified = 0,
    NetDeviceStateD0,
    NetDeviceStateD1,
    NetDeviceStateD2,
    NetDeviceStateD3,
    NetDeviceStateMaximum
} NET_DEVICE_POWER_STATE, *PNET_DEVICE_POWER_STATE;

#endif // __NET_PNP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\netioddk.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    netioddk.h

Abstract:

    This module contains the DDK definitions and structures for the
    network I/O subsystem.

Environment:

    kernel mode only

--*/

#ifndef _NETIODDK_
#define _NETIODDK_
#pragma once

#include <netiodef.h>

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable:4200) // zero-sized array in struct/union


//
// These types define the pointers to constant data supplied by a client
// or provider during its registration.  The data pointed to must be
// kept valid for the life of the registration.
//

typedef CONST struct _NPI_CLIENT_CHARACTERISTICS * PNPI_CLIENT_CHARACTERISTICS;
typedef CONST struct _NPI_PROVIDER_CHARACTERISTICS * PNPI_PROVIDER_CHARACTERISTICS;
typedef CONST struct _NPI_REGISTRATION_INSTANCE * PNPI_REGISTRATION_INSTANCE;

//
// Network Programming Interface Registration Instance: represents a
// registration of an implementation of a specific network programming
// interface by a specific network module.  The information in this structure
// is specified by the module implementing an instance of a network
// programming interface.
//

typedef struct _NPI_REGISTRATION_INSTANCE {
    USHORT Version;
    USHORT Size;
    PNPIID NpiId;
    PNPI_MODULEID ModuleId;
    ULONG Number;
    CONST VOID  *NpiSpecificCharacteristics OPTIONAL;
} NPI_REGISTRATION_INSTANCE;


//
// A Network Programming Interface (NPI) is a well-defined table of function
// pointers and a caller-specific handle representing the caller of the
// functions.  The handle is usually passed as a parameter to the functions
// as defined by the specific network programming interface definition.
// This structure is a place holder to opaquely describe network programming
// interfaces.  It is usually cast to a specific NPI structure for use.
//
typedef struct _NPI {
    HANDLE Handle;
    CONST VOID* Dispatch;
} NPI;


typedef
NTSTATUS
(NTAPI NPI_CLIENT_ATTACH_PROVIDER_FN)(
    IN HANDLE  NmrBindingHandle,
    IN PVOID  ClientContext,
    IN PNPI_REGISTRATION_INSTANCE  ProviderRegistrationInstance
    );
typedef NPI_CLIENT_ATTACH_PROVIDER_FN *PNPI_CLIENT_ATTACH_PROVIDER_FN;


typedef
NTSTATUS
(NTAPI NPI_CLIENT_DETACH_PROVIDER_FN  )(
    IN PVOID  ClientBindingContext
    );
typedef NPI_CLIENT_DETACH_PROVIDER_FN *PNPI_CLIENT_DETACH_PROVIDER_FN;


typedef
VOID
(NTAPI NPI_CLIENT_CLEANUP_BINDING_CONTEXT_FN)(
    IN PVOID  ClientBindingContext
    );
typedef NPI_CLIENT_CLEANUP_BINDING_CONTEXT_FN *PNPI_CLIENT_CLEANUP_BINDING_CONTEXT_FN;


typedef struct _NPI_CLIENT_CHARACTERISTICS {
    USHORT Version;
    USHORT Length;
    PNPI_CLIENT_ATTACH_PROVIDER_FN  ClientAttachProvider;
    PNPI_CLIENT_DETACH_PROVIDER_FN  ClientDetachProvider;
    PNPI_CLIENT_CLEANUP_BINDING_CONTEXT_FN  ClientCleanupBindingContext;
    NPI_REGISTRATION_INSTANCE  ClientRegistrationInstance;
} NPI_CLIENT_CHARACTERISTICS;


//
// Definition for provider side of structures and prototypes.
//
typedef
NTSTATUS
(NTAPI NPI_PROVIDER_ATTACH_CLIENT_FN)(
    IN HANDLE  NmrBindingHandle,
    IN PVOID  ProviderContext,
    IN PNPI_REGISTRATION_INSTANCE  ClientRegistrationInstance,
    IN PVOID  ClientBindingContext,
    IN CONST VOID *ClientDispatch,
    OUT PVOID  *ProviderBindingContext,
    OUT CONST VOID*  *ProviderDispatch
    );
typedef NPI_PROVIDER_ATTACH_CLIENT_FN *PNPI_PROVIDER_ATTACH_CLIENT_FN;


typedef
NTSTATUS
(NTAPI NPI_PROVIDER_DETACH_CLIENT_FN)(
    IN PVOID  ProviderBindingContext
    );
typedef NPI_PROVIDER_DETACH_CLIENT_FN *PNPI_PROVIDER_DETACH_CLIENT_FN;


typedef
VOID
(NTAPI NPI_PROVIDER_CLEANUP_BINDING_CONTEXT_FN)(
    IN PVOID  ProviderBindingContext
    );
typedef NPI_PROVIDER_CLEANUP_BINDING_CONTEXT_FN *PNPI_PROVIDER_CLEANUP_BINDING_CONTEXT_FN;


typedef struct _NPI_PROVIDER_CHARACTERISTICS {
    USHORT Version;
    USHORT Length;
    PNPI_PROVIDER_ATTACH_CLIENT_FN ProviderAttachClient;
    PNPI_PROVIDER_DETACH_CLIENT_FN ProviderDetachClient;
    PNPI_PROVIDER_CLEANUP_BINDING_CONTEXT_FN ProviderCleanupBindingContext;
    NPI_REGISTRATION_INSTANCE ProviderRegistrationInstance;
} NPI_PROVIDER_CHARACTERISTICS;


//
// Called by a module to register an instance of an implementation of the
// client side of a particular network programming interface.
//
NTSTATUS
NmrRegisterClient(
    IN PNPI_CLIENT_CHARACTERISTICS  ClientCharacteristics,
    IN PVOID  ClientContext,
    OUT PHANDLE  NmrClientHandle
    );

//
// Called by a module to un-register an instance of an implementation of the
// client side of a particular network programming interface.
//
NTSTATUS
NmrDeregisterClient(
    IN HANDLE  NmrClientHandle
    );

//
// Called by a client to close a registration.
//
NTSTATUS
NmrWaitForClientDeregisterComplete(
    IN HANDLE  NmrClientHandle
    );

//
// Called by a client module to attach itself to a provider.
//
NTSTATUS
NmrClientAttachProvider(
    IN HANDLE  NmrBindingHandle,
    IN PVOID  ClientBindingContext,
    IN CONST VOID  *ClientDispatch,
    OUT PVOID  *ProviderBindingContext,
    OUT CONST VOID*  *ProviderDispatch
    );

//
// Called by a client module to indicate detach to a provider is
// complete.
//
VOID
NmrClientDetachProviderComplete(
    IN HANDLE  NmrBindingHandle
    );


//
// Called by a module to register an instance of an implementation of the
// provider side of a particular network programming interface.
//
NTSTATUS
NmrRegisterProvider(
    IN PNPI_PROVIDER_CHARACTERISTICS  ProviderCharacteristics,
    IN PVOID  ProviderContext,
    OUT PHANDLE  NmrProviderHandle
    );

//
// Called by a module to un-register an instance of an implementation of the
// provider side of a particular network programming interface.
//
NTSTATUS
NmrDeregisterProvider(
    IN HANDLE  NmrProviderHandle
    );

//
// Called by a provider to close a registration.
//
NTSTATUS
NmrWaitForProviderDeregisterComplete(
    IN HANDLE  NmrProviderHandle
    );

//
// Called by a provider module to notify NMR that a detach from client
// is complete.
//
VOID
NmrProviderDetachClientComplete(
    IN HANDLE  NmrBindingHandle
    );



#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#endif // _NETIODDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ndr64types.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndr64types.h

Abstract:

    Definitions for NDR64 format strings.

--*/



#ifndef _NDR64TYPES_H
#define _NDR64TYPES_H

#include <pshpack8.h>

#include <guiddef.h>    // REVIEW: or just redefine GUID here
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning (disable: 4201)     // nameless struct/union
#pragma warning (disable: 4214)     // bitfield


typedef const void * FormatInfoRef;
#define INVALID_FRAGMENT_ID 0

/*
*  Format string types
*/
typedef unsigned __int8     NDR64_UINT8;
typedef unsigned __int16    NDR64_UINT16;
typedef unsigned __int32    NDR64_UINT32;
typedef unsigned __int64    NDR64_UINT64;

typedef __int8              NDR64_INT8;
typedef __int16             NDR64_INT16;
typedef __int32             NDR64_INT32;
typedef __int64             NDR64_INT64;

typedef NDR64_UINT8         NDR64_FORMAT_CHAR;
typedef const void *        PNDR64_FORMAT;
typedef NDR64_UINT8         NDR64_ALIGNMENT;
typedef NDR64_UINT32        NDR64_FORMAT_UINT32;


#define NDR64_FC_EXPLICIT_HANDLE    0
#define NDR64_FC_BIND_GENERIC       1
#define NDR64_FC_BIND_PRIMITIVE     2
#define NDR64_FC_AUTO_HANDLE        3
#define NDR64_FC_CALLBACK_HANDLE    4
#define NDR64_FC_NO_HANDLE          5


#if defined(__RPC_WIN32__)
typedef NDR64_INT32 NDR64_PTR_WIRE_TYPE;
#else
typedef NDR64_INT64 NDR64_PTR_WIRE_TYPE;
#endif

#define NDR64_PTR_WIRE_ALIGN (sizeof(NDR64_PTR_WIRE_TYPE)-1)

typedef NDR64_UINT64 NDR64_WIRE_COUNT_TYPE;
#define NDR64_WIRE_COUNT_ALIGN (sizeof(NDR64_WIRE_COUNT_TYPE)-1)

//
// Procedures and parameters
//

typedef struct _NDR64_PROC_FLAGS
{
    NDR64_UINT32    HandleType              : 3;        // 0x00000000
    NDR64_UINT32    ProcType                : 3;        // 0x00000008
    NDR64_UINT32    IsInterpreted           : 2;        // 0x00000040
    NDR64_UINT32    IsObject                : 1;        // 0x00000100
    NDR64_UINT32    IsAsync                 : 1;        // 0x00000200
    NDR64_UINT32    IsEncode                : 1;        // 0x00000400
    NDR64_UINT32    IsDecode                : 1;        // 0x00000800
    NDR64_UINT32    UsesFullPtrPackage      : 1;        // 0x00001000
    NDR64_UINT32    UsesRpcSmPackage        : 1;        // 0x00002000
    NDR64_UINT32    UsesPipes               : 1;        // 0x00004000
    NDR64_UINT32    HandlesExceptions       : 2;        // 0x00008000
    NDR64_UINT32    ServerMustSize          : 1;        // 0x00020000
    NDR64_UINT32    ClientMustSize          : 1;        // 0x00040000
    NDR64_UINT32    HasReturn               : 1;        // 0x00080000
    NDR64_UINT32    HasComplexReturn        : 1;        // 0x00100000
    NDR64_UINT32    ServerHasCorrelation    : 1;        // 0x00200000
    NDR64_UINT32    ClientHasCorrelation    : 1;        // 0x00400000
    NDR64_UINT32    HasNotify               : 1;        // 0x00800000
    NDR64_UINT32    HasOtherExtensions      : 1;        // 0x01000000
    NDR64_UINT32    HasBigByValueParam      : 1;        // 0x02000000
    NDR64_UINT32    Reserved                : 6;        // 0x04000000
} NDR64_PROC_FLAGS;

typedef struct _NDR64_RPC_FLAGS
{
    NDR64_UINT16    Idempotent          : 1;
    NDR64_UINT16    Broadcast           : 1;
    NDR64_UINT16    Maybe               : 1;
    NDR64_UINT16    Reserved0           : 1;
    NDR64_UINT16    HasGuarantee        : 1;
    NDR64_UINT16    Reserved1           : 3;
    NDR64_UINT16    Message             : 1;
    NDR64_UINT16    Reserved2           : 4;
    NDR64_UINT16    InputSynchronous    : 1;
    NDR64_UINT16    Asynchronous        : 1;
    NDR64_UINT16    Reserved3           : 1;
} NDR64_RPC_FLAGS;


typedef struct _NDR64_PROC_FORMAT
{
    NDR64_UINT32        Flags;
    NDR64_UINT32        StackSize;
    NDR64_UINT32        ConstantClientBufferSize;
    NDR64_UINT32        ConstantServerBufferSize;
    NDR64_UINT16        RpcFlags;
    NDR64_UINT16        FloatDoubleMask;
    NDR64_UINT16        NumberOfParams;
    NDR64_UINT16        ExtensionSize;
} NDR64_PROC_FORMAT, *PNDR64_PROC_FORMAT;

typedef struct _NDR64_PARAM_FLAGS
{
    NDR64_UINT16    MustSize            : 1;
    NDR64_UINT16    MustFree            : 1;
    NDR64_UINT16    IsPipe              : 1;
    NDR64_UINT16    IsIn                : 1;
    NDR64_UINT16    IsOut               : 1;
    NDR64_UINT16    IsReturn            : 1;
    NDR64_UINT16    IsBasetype          : 1;
    NDR64_UINT16    IsByValue           : 1;
    NDR64_UINT16    IsSimpleRef         : 1;
    NDR64_UINT16    IsDontCallFreeInst  : 1;
    NDR64_UINT16    SaveForAsyncFinish  : 1;
    NDR64_UINT16    IsPartialIgnore     : 1;
    NDR64_UINT16    IsForceAllocate     : 1;
    NDR64_UINT16    Reserved            : 2;
    NDR64_UINT16    UseCache            : 1;
} NDR64_PARAM_FLAGS;


typedef struct _NDR64_PARAM_FORMAT
{
    PNDR64_FORMAT       Type;
    NDR64_PARAM_FLAGS   Attributes;
    NDR64_UINT16        Reserved;
    NDR64_UINT32        StackOffset;
} NDR64_PARAM_FORMAT, *PNDR64_PARAM_FORMAT;


//
// Base types
//

typedef struct _NDR64_RANGE_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_FORMAT_CHAR   RangeType;
    NDR64_UINT16        Reserved;
    NDR64_INT64         MinValue;
    NDR64_INT64         MaxValue;
} NDR64_RANGE_FORMAT;

//
// Handles & bindings
//

typedef struct _NDR64_CONTEXT_HANDLE_FLAGS
{
    NDR64_UINT8         CannotBeNull : 1;
    NDR64_UINT8         Serialize    : 1;
    NDR64_UINT8         NoSerialize  : 1;
    NDR64_UINT8         Strict       : 1;
    NDR64_UINT8         IsReturn     : 1;
    NDR64_UINT8         IsOut        : 1;
    NDR64_UINT8         IsIn         : 1;
    NDR64_UINT8         IsViaPointer : 1;
} NDR64_CONTEXT_HANDLE_FLAGS;

typedef struct _NDR64_CONTEXT_HANDLE_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         ContextFlags;
    NDR64_UINT8         RundownRoutineIndex;
    NDR64_UINT8         Ordinal;
} NDR64_CONTEXT_HANDLE_FORMAT;

typedef struct _NDR64_BIND_PRIMITIVE
{
    NDR64_FORMAT_CHAR   HandleType;
    NDR64_UINT8         Flags;
    NDR64_UINT16        StackOffset;
    NDR64_UINT16        Reserved;
} NDR64_BIND_PRIMITIVE;

typedef struct _NDR64_BIND_GENERIC
{
    NDR64_FORMAT_CHAR   HandleType;
    NDR64_UINT8         Flags;
    NDR64_UINT16        StackOffset;
    NDR64_UINT8         RoutineIndex;
    NDR64_UINT8         Size;
} NDR64_BIND_GENERIC;

typedef struct _NDR64_BIND_CONTEXT
{
    NDR64_FORMAT_CHAR   HandleType;
    NDR64_UINT8         Flags;
    NDR64_UINT16        StackOffset;
    NDR64_UINT8         RoutineIndex;
    NDR64_UINT8         Ordinal;
} NDR64_BIND_CONTEXT;

typedef union _NDR64_BINDINGS
{
    NDR64_BIND_PRIMITIVE    Primitive;
    NDR64_BIND_GENERIC      Generic;
    NDR64_BIND_CONTEXT      Context;
} NDR64_BINDINGS;

// NOTE: The type of the Binding member below is actually NDR64_BINDINGS.
//       We use NDR64_BIND_CONTEXT because it has essentially the same
//       signature as the others and it makes static initilization clearer.

typedef struct _NDR64_BIND_AND_NOTIFY_EXTENSION
{
    NDR64_BIND_CONTEXT  Binding;
    NDR64_UINT16        NotifyIndex;
} NDR64_BIND_AND_NOTIFY_EXTENSION;


//
// Pointers
//

typedef struct _NDR64_POINTER_FORMAT
{
    NDR64_FORMAT_CHAR  FormatCode;
    NDR64_UINT8        Flags;
    NDR64_UINT16       Reserved;
    PNDR64_FORMAT      Pointee;
} NDR64_POINTER_FORMAT;

typedef struct _NDR64_NO_REPEAT_FORMAT
{
   NDR64_FORMAT_CHAR    FormatCode;
   NDR64_UINT8          Flags;
   NDR64_UINT16         Reserved1;
   NDR64_UINT32         Reserved2;
} NDR64_NO_REPEAT_FORMAT;

typedef struct _NDR64_POINTER_INSTANCE_HEADER_FORMAT
{
    NDR64_UINT32         Offset;
    NDR64_UINT32         Reserved;
} NDR64_POINTER_INSTANCE_HEADER_FORMAT;

typedef struct _NDR64_POINTER_REPEAT_FLAGS
{
    NDR64_UINT8          SetCorrMark : 1;
    NDR64_UINT8          Reserved : 7;
} NDR64_POINTER_REPEAT_FLAGS, *PNDR64_POINTER_REPEAT_FLAGS;

typedef struct _NDR64_REPEAT_FORMAT
{
    NDR64_FORMAT_CHAR    FormatCode;
    NDR64_POINTER_REPEAT_FLAGS  Flags;
    NDR64_UINT16         Reserved;
    NDR64_UINT32         Increment;
    NDR64_UINT32         OffsetToArray;
    NDR64_UINT32         NumberOfPointers;
} NDR64_REPEAT_FORMAT, *PNDR64_REPEAT_FORMAT;

typedef struct _NDR64_FIXED_REPEAT_FORMAT
{
    NDR64_REPEAT_FORMAT  RepeatFormat;
    NDR64_UINT32         Iterations;
    NDR64_UINT32         Reserved;
} NDR64_FIXED_REPEAT_FORMAT, *PNDR64_FIXED_REPEAT_FORMAT;

typedef struct _NDR64_IID_FLAGS
{
    NDR64_UINT8         ConstantIID : 1;
    NDR64_UINT8         Reserved    : 7;
} NDR64_IID_FLAGS;

typedef struct _NDR64_CONSTANT_IID_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT16        Reserved;
    GUID                Guid;
} NDR64_CONSTANT_IID_FORMAT;

typedef struct _NDR64_IID_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT16        Reserved;
    PNDR64_FORMAT       IIDDescriptor;
} NDR64_IID_FORMAT;

//
// Structures
//

typedef struct _NDR64_STRUCTURE_FLAGS
{
    NDR64_UINT8         HasPointerInfo      : 1; /* 1 */
    NDR64_UINT8         HasMemberInfo       : 1; /* 2 */
    NDR64_UINT8         HasConfArray        : 1; /* 3 */
    NDR64_UINT8         HasOrigPointerInfo  : 1; /* 4 */
    NDR64_UINT8         HasOrigMemberInfo   : 1; /* 5 */
    NDR64_UINT8         Reserved1           : 1; /* 6 */
    NDR64_UINT8         Reserved2           : 1; /* 7 */
    NDR64_UINT8         Reserved3           : 1; /* 8 */
} NDR64_STRUCTURE_FLAGS;

typedef struct _NDR64_STRUCTURE_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR       FormatCode;
    NDR64_ALIGNMENT         Alignment;
    NDR64_STRUCTURE_FLAGS   Flags;
    NDR64_UINT8             Reserve;
    NDR64_UINT32            MemorySize;
} NDR64_STRUCTURE_HEADER_FORMAT;

typedef struct _NDR64_CONF_STRUCTURE_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR       FormatCode;
    NDR64_ALIGNMENT         Alignment;
    NDR64_STRUCTURE_FLAGS   Flags;
    NDR64_UINT8             Reserve;
    NDR64_UINT32            MemorySize;
    PNDR64_FORMAT           ArrayDescription;
} NDR64_CONF_STRUCTURE_HEADER_FORMAT;

typedef struct _NDR64_BOGUS_STRUCTURE_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR       FormatCode;
    NDR64_ALIGNMENT         Alignment;
    NDR64_STRUCTURE_FLAGS   Flags;
    NDR64_UINT8             Reserve;
    NDR64_UINT32            MemorySize;
    PNDR64_FORMAT           OriginalMemberLayout;
    PNDR64_FORMAT           OriginalPointerLayout;
    PNDR64_FORMAT           PointerLayout;
} NDR64_BOGUS_STRUCTURE_HEADER_FORMAT;

typedef struct _NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR       FormatCode;
    NDR64_ALIGNMENT         Alignment;
    NDR64_STRUCTURE_FLAGS   Flags;
    NDR64_UINT8             Dimensions;
    NDR64_UINT32            MemorySize;
    PNDR64_FORMAT           OriginalMemberLayout;
    PNDR64_FORMAT           OriginalPointerLayout;
    PNDR64_FORMAT           PointerLayout;
    PNDR64_FORMAT           ConfArrayDescription;
} NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT;

/*
*   Structure member layout components
*/

typedef struct _NDR64_SIMPLE_MEMBER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Reserved1;
    NDR64_UINT16        Reserved2;
    NDR64_UINT32        Reserved3;
} NDR64_SIMPLE_MEMBER_FORMAT;

typedef struct _NDR64_MEMPAD_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Reserve1;
    NDR64_UINT16        MemPad;
    NDR64_UINT32        Reserved2;
} NDR64_MEMPAD_FORMAT;

typedef struct _NDR64_EMBEDDED_COMPLEX_FORMAT
{
    NDR64_FORMAT_CHAR FormatCode;
    NDR64_UINT8       Reserve1;
    NDR64_UINT16      Reserve2;
    PNDR64_FORMAT     Type;
} NDR64_EMBEDDED_COMPLEX_FORMAT;

typedef struct _NDR64_BUFFER_ALIGN_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_UINT16        Reserved;
    NDR64_UINT32        Reserved2;
} NDR64_BUFFER_ALIGN_FORMAT;

typedef struct _NDR64_SIMPLE_REGION_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_UINT16        RegionSize;
    NDR64_UINT32        Reserved;
} NDR64_SIMPLE_REGION_FORMAT;

//
// Unions
//

typedef struct _NDR64_ENCAPSULATED_UNION
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Alignment;
    NDR64_UINT8         Flags;
    NDR64_FORMAT_CHAR   SwitchType;
    NDR64_UINT32        MemoryOffset;
    NDR64_UINT32        MemorySize;
    NDR64_UINT32        Reserved;
}
NDR64_ENCAPSULATED_UNION;

typedef struct _NDR64_NON_ENCAPSULATED_UNION
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Alignment;
    NDR64_UINT8         Flags;
    NDR64_FORMAT_CHAR   SwitchType;
    NDR64_UINT32        MemorySize;
    PNDR64_FORMAT       Switch;
    NDR64_UINT32        Reserved;
}
NDR64_NON_ENCAPSULATED_UNION;

typedef struct _NDR64_UNION_ARM_SELECTOR
{
    NDR64_UINT8         Reserved1;
    NDR64_UINT8         Alignment;
    NDR64_UINT16        Reserved2;
    NDR64_UINT32        Arms;
}
NDR64_UNION_ARM_SELECTOR;

typedef struct _NDR64_UNION_ARM
{
    NDR64_INT64         CaseValue;
    PNDR64_FORMAT       Type;
    NDR64_UINT32        Reserved;
}
NDR64_UNION_ARM;

/*
*    Array related data
*/

typedef struct _NDR64_ARRAY_FLAGS
{
    NDR64_UINT8         HasPointerInfo      :   1; /* 1 */
    NDR64_UINT8         HasElementInfo      :   1; /* 2 */
    NDR64_UINT8         IsMultiDimensional  :   1; /* 3 */
    NDR64_UINT8         IsArrayofStrings    :   1; /* 4 */
    NDR64_UINT8         Reserved1           :   1; /* 5 */
    NDR64_UINT8         Reserved2           :   1; /* 6 */
    NDR64_UINT8         Reserved3           :   1; /* 7 */
    NDR64_UINT8         Reserved4           :   1; /* 8 */
} NDR64_ARRAY_FLAGS;

typedef struct _NDR64_ARRAY_ELEMENT_INFO
{
    NDR64_UINT32        ElementMemSize;
    PNDR64_FORMAT       Element;
} NDR64_ARRAY_ELEMENT_INFO;

typedef struct _NDR64_FIX_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         Reserved;
    NDR64_UINT32        TotalSize;
} NDR64_FIX_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_CONF_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         Reserved;
    NDR64_UINT32        ElementSize;
    PNDR64_FORMAT       ConfDescriptor;
} NDR64_CONF_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_CONF_VAR_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         Reserved;
    NDR64_UINT32        ElementSize;
    PNDR64_FORMAT       ConfDescriptor;
    PNDR64_FORMAT       VarDescriptor;
} NDR64_CONF_VAR_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_VAR_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         Reserved;
    NDR64_UINT32        TotalSize;
    NDR64_UINT32        ElementSize;
    PNDR64_FORMAT       VarDescriptor;
} NDR64_VAR_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_BOGUS_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         NumberDims;
    NDR64_UINT32        NumberElements;
    PNDR64_FORMAT       Element;
} NDR64_BOGUS_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT
{
    NDR64_BOGUS_ARRAY_HEADER_FORMAT FixedArrayFormat;
    PNDR64_FORMAT                ConfDescription;
    PNDR64_FORMAT                VarDescription;
    PNDR64_FORMAT                OffsetDescription;
} NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT;

/*
*   String related data.
*/

typedef struct _NDR64_STRING_FLAGS
{
  NDR64_UINT8           IsSized     : 1;
  NDR64_UINT8           IsRanged    : 1;
  NDR64_UINT8           Reserved3   : 1;
  NDR64_UINT8           Reserved4   : 1;
  NDR64_UINT8           Reserved5   : 1;
  NDR64_UINT8           Reserved6   : 1;
  NDR64_UINT8           Reserved7   : 1;
  NDR64_UINT8           Reserved8   : 1;
} NDR64_STRING_FLAGS;

typedef struct NDR64_STRING_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR    FormatCode;
    NDR64_STRING_FLAGS   Flags;
    NDR64_UINT16         ElementSize;
} NDR64_STRING_HEADER_FORMAT;

typedef struct _NDR64_NON_CONFORMANT_STRING_FORMAT
{
   NDR64_STRING_HEADER_FORMAT   Header;
   NDR64_UINT32                 TotalSize;
} NDR64_NON_CONFORMANT_STRING_FORMAT;

#if NTDDI_VERSION >= NTDDI_LONGHORN
typedef struct _NDR64_RANGED_STRING_FORMAT
{
    NDR64_STRING_HEADER_FORMAT Header;
    NDR64_UINT32 Reserved;
    NDR64_UINT64 Min;
    NDR64_UINT64 Max;
} NDR64_RANGED_STRING_FORMAT;
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN)

typedef struct _NDR64_CONFORMANT_STRING_FORMAT
{
   NDR64_STRING_HEADER_FORMAT   Header;
} NDR64_CONFORMANT_STRING_FORMAT;

typedef struct NDR64_SIZED_CONFORMANT_STRING_FORMAT
{
   NDR64_STRING_HEADER_FORMAT   Header;
   PNDR64_FORMAT                SizeDescription;
} NDR64_SIZED_CONFORMANT_STRING_FORMAT;

//
// Correlation expressions
//

typedef enum _tagEXPR_TOKEN
{
    FC_EXPR_START = 0,
    FC_EXPR_ILLEGAL = FC_EXPR_START,
    FC_EXPR_CONST32,
    FC_EXPR_CONST64,
    FC_EXPR_VAR,
    FC_EXPR_OPER,
    FC_EXPR_NOOP,    // pad up the format string buffer.
    FC_EXPR_END

} EXPR_TOKEN;

typedef struct _NDR64_EXPR_OPERATOR
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_FORMAT_CHAR   Operator;
    NDR64_FORMAT_CHAR   CastType;
    NDR64_UINT8         Reserved;
} NDR64_EXPR_OPERATOR;

typedef struct _NDR64_EXPR_CONST32
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_FORMAT_CHAR   Reserved;
    NDR64_UINT16        Reserved1;
    NDR64_UINT32        ConstValue;
} NDR64_EXPR_CONST32;

typedef struct _NDR64_EXPR_CONST64
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_FORMAT_CHAR   Reserved;
    NDR64_UINT16        Reserved1;
    NDR64_INT64         ConstValue;
} NDR64_EXPR_CONST64;

typedef struct _NDR64_EXPR_VAR
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_FORMAT_CHAR   VarType;
    NDR64_UINT16        Reserved;
    NDR64_UINT32        Offset;
} NDR64_EXPR_VAR;

typedef struct _NDR64_EXPR_NOOP
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_UINT8         Size;
    NDR64_UINT16        Reserved;
} NDR64_EXPR_NOOP;

//
// transmit_as, represent_as
//

typedef struct _NDR64_TRANSMIT_AS_FLAGS
{
    NDR64_UINT8         PresentedTypeIsArray : 1;
    NDR64_UINT8         PresentedTypeAlign4  : 1;
    NDR64_UINT8         PresentedTypeAlign8  : 1;
    NDR64_UINT8         Reserved             : 5;
} NDR64_TRANSMIT_AS_FLAGS;

typedef struct _NDR64_TRANSMIT_AS_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT16        RoutineIndex;
    NDR64_UINT16        TransmittedTypeWireAlignment;
    NDR64_UINT16        MemoryAlignment;
    NDR64_UINT32        PresentedTypeMemorySize;
    NDR64_UINT32        TransmittedTypeBufferSize;
    PNDR64_FORMAT       TransmittedType;
} NDR64_TRANSMIT_AS_FORMAT;

typedef NDR64_TRANSMIT_AS_FORMAT NDR64_REPRESENT_AS_FORMAT;

//
// user_marshal
//

typedef struct _NDR64_USER_MARSHAL_FLAGS
{
    NDR64_UINT8         Reserved        : 5;
    NDR64_UINT8         IID             : 1;
    NDR64_UINT8         RefPointer      : 1;
    NDR64_UINT8         UniquePointer   : 1;
} NDR64_USER_MARSHAL_FLAGS;

typedef struct _NDR64_USER_MARSHAL_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT16        RoutineIndex;
    NDR64_UINT16        TransmittedTypeWireAlignment;
    NDR64_UINT16        MemoryAlignment;
    NDR64_UINT32        UserTypeMemorySize;
    NDR64_UINT32        TransmittedTypeBufferSize;
    PNDR64_FORMAT       TransmittedType;
} NDR64_USER_MARSHAL_FORMAT;

//
// Pipes
//

typedef struct NDR64_PIPE_FLAGS
{
    NDR64_UINT8         Reserved1  : 5;
    NDR64_UINT8         HasRange   : 1;
    NDR64_UINT8         BlockCopy  : 1;
    NDR64_UINT8         Reserved2  : 1;
} NDR64_PIPE_FLAGS;

typedef struct _NDR64_PIPE_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT8         Alignment;
    NDR64_UINT8         Reserved;
    PNDR64_FORMAT       Type;
    NDR64_UINT32        MemorySize;
    NDR64_UINT32        BufferSize;
} NDR64_PIPE_FORMAT;


typedef struct _NDR64_RANGE_PIPE_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT8         Alignment;
    NDR64_UINT8         Reserved;
    PNDR64_FORMAT       Type;
    NDR64_UINT32        MemorySize;
    NDR64_UINT32        BufferSize;
    NDR64_UINT32        MinValue;
    NDR64_UINT32        MaxValue;
} NDR64_RANGE_PIPE_FORMAT;

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef struct _NDR64_TYPE_STRICT_CONTEXT_HANDLE
{
	NDR64_FORMAT_CHAR FormatCode;
	NDR64_FORMAT_CHAR RealFormatCode;
	NDR64_UINT16      Reserved;
	PNDR64_FORMAT     Type;
	NDR64_UINT32      CtxtFlags;
	NDR64_UINT32      CtxtID;
} NDR64_TYPE_STRICT_CONTEXT_HANDLE;
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN)


#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#include <poppack.h>

#endif //_NDR64TYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntddk.h ===
/*++ BUILD Version: 0186    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

 ntddk.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#ifndef _NTDDK_
#define _NTDDK_

#if !defined(_NTHAL_) && !defined(_NTIFS_)
#define _NTDDK_INCLUDED_
#define _DDK_DRIVER_
#endif

#ifndef RC_INVOKED
#if _MSC_VER < 1300
#error Compiler version not supported by Windows DDK
#endif
#endif // RC_INVOKED

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4115) // named type definition in parentheses
#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

#include <wdm.h>
#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>

#include <driverspecs.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Define types that are not exported.
//

typedef struct _BUS_HANDLER *PBUS_HANDLER;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _DEVICE_HANDLER_OBJECT *PDEVICE_HANDLER_OBJECT;
#if defined(_NTHAL_INCLUDED_)
typedef struct _KPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
#elif defined(_NTIFS_INCLUDED_)
typedef struct _KPROCESS *PEPROCESS;
typedef struct _KTHREAD *PETHREAD;
#else
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
#endif
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _PEB *PPEB;
typedef struct _IMAGE_NT_HEADERS *PIMAGE_NT_HEADERS32;
typedef struct _IMAGE_NT_HEADERS64 *PIMAGE_NT_HEADERS64;
#ifdef _WIN64
typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;
#else
typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS;
#endif

#define PsGetCurrentProcess IoGetCurrentProcess

#if (NTDDI_VERSION >= NTDDI_VISTA)
extern NTSYSAPI volatile CCHAR KeNumberProcessors;
#else
#if (NTDDI_VERSION >= NTDDI_WINXP)
extern NTSYSAPI CCHAR KeNumberProcessors;
#else
extern PCCHAR KeNumberProcessors;
#endif
#endif

#include <mce.h>

#ifndef FAR
#define FAR
#endif

#ifdef _X86_

//
// Disable these two pragmas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif

//
// Size of kernel mode stack.
//

#define KERNEL_STACK_SIZE 12288

//
// Define size of large kernel mode stack for callbacks.
//

#define KERNEL_LARGE_STACK_SIZE 61440

//
// Define number of pages to initialize in a large kernel stack.
//

#define KERNEL_LARGE_STACK_COMMIT 12288

#ifdef _X86_

#if !defined(MIDL_PASS) && defined(_M_IX86)

#if !defined(_M_CEE_PURE)

#pragma warning( push )
#pragma warning( disable : 4793 )
FORCEINLINE
VOID
MemoryBarrier (
    VOID
    )
{
    LONG Barrier;
    __asm {
        xchg Barrier, eax
    }
}
#pragma warning( pop )

#endif /* _M_CEE_PURE */
//
// Prefetch is not supported on all x86 procssors.
//

#define PreFetchCacheLine(l, a)
#define PrefetchForWrite(p)
#define ReadForWriteAccess(p) (*(p))

//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1 
#define PF_NON_TEMPORAL_LEVEL_ALL

//
// Define function to read the value of a performance counter.
//

#if _MSC_FULL_VER >= 140050727

#define ReadPMC __readpmc

ULONG64
__readpmc (
    __in ULONG Counter
    );

#pragma intrinsic(__readpmc)

#else

FORCEINLINE
ULONG64
ReadPMC (
    __in ULONG Counter
    )

{

    __asm {
        mov ecx, Counter
        rdpmc
    };
}

#endif

//
// Define function to read the value of the time stamp counter
//

#if _MSC_FULL_VER >= 140040310

#define ReadTimeStampCounter() __rdtsc()

ULONG64
__rdtsc (
    VOID
    );

#pragma intrinsic(__rdtsc)

#else

FORCEINLINE
ULONG64
ReadTimeStampCounter (
    VOID
    )

{

    __asm rdtsc
}

#endif

#endif // !defined(MIDL_PASS) && defined(_M_IX86)

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records



#define CONTEXT_CONTROL         (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER         (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS        (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT  (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER |\
                      CONTEXT_SEGMENTS)

#define CONTEXT_ALL             (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | \
                                 CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | \
                                 CONTEXT_EXTENDED_REGISTERS)



#endif // !defined(RC_INVOKED)

#define MAXIMUM_SUPPORTED_EXTENSION     512

typedef struct _FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    UCHAR   ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT;



typedef CONTEXT *PCONTEXT;


#endif //_X86_

#endif // _X86_

#ifdef _AMD64_

//
// Size of kernel mode stack.
//

#define KERNEL_STACK_SIZE 0x6000

//
// Define size of large kernel mode stack for callbacks.
//

#define KERNEL_LARGE_STACK_SIZE 0x12000

//
// Define number of pages to initialize in a large kernel stack.
//

#define KERNEL_LARGE_STACK_COMMIT KERNEL_STACK_SIZE

//
// Define the size of the stack used for processing an MCA exception.
//

#define KERNEL_MCA_EXCEPTION_STACK_SIZE 0x2000

//
// The following values specify the type of access in the first parameter
// of the exception record whan the exception code specifies an access
// violation.
//

#define EXCEPTION_READ_FAULT 0          // exception caused by a read
#define EXCEPTION_WRITE_FAULT 1         // exception caused by a write
#define EXCEPTION_EXECUTE_FAULT 8       // exception caused by an instruction fetch


//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_AMD64   0x100000



#define CONTEXT_CONTROL (CONTEXT_AMD64 | 0x1L)
#define CONTEXT_INTEGER (CONTEXT_AMD64 | 0x2L)
#define CONTEXT_SEGMENTS (CONTEXT_AMD64 | 0x4L)
#define CONTEXT_FLOATING_POINT  (CONTEXT_AMD64 | 0x8L)
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_AMD64 | 0x10L)

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT)

#define CONTEXT_ALL (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS)

#define CONTEXT_EXCEPTION_ACTIVE 0x8000000
#define CONTEXT_SERVICE_ACTIVE 0x10000000
#define CONTEXT_EXCEPTION_REQUEST 0x40000000
#define CONTEXT_EXCEPTION_REPORTING 0x80000000



#endif // !defined(RC_INVOKED)

//
// Define initial MxCsr and FpCsr control.
//

#define INITIAL_MXCSR 0x1f80            // initial MXCSR value
#define INITIAL_FPCSR 0x027f            // initial FPCSR value

//
// Define 128-bit 16-byte aligned xmm register type.
//

typedef struct DECLSPEC_ALIGN(16) _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;

//
// Format of data for 32-bit fxsave/fxrstor instructions.
//

typedef struct _XMM_SAVE_AREA32 {
    USHORT ControlWord;
    USHORT StatusWord;
    UCHAR TagWord;
    UCHAR Reserved1;
    USHORT ErrorOpcode;
    ULONG ErrorOffset;
    USHORT ErrorSelector;
    USHORT Reserved2;
    ULONG DataOffset;
    USHORT DataSelector;
    USHORT Reserved3;
    ULONG MxCsr;
    ULONG MxCsr_Mask;
    M128A FloatRegisters[8];
    M128A XmmRegisters[16];
    UCHAR Reserved4[96];
} XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;

#define LEGACY_SAVE_AREA_LENGTH sizeof(XMM_SAVE_AREA32)

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//
// The flags field within this record controls the contents of a CONTEXT
// record.
//
// If the context record is used as an input parameter, then for each
// portion of the context record controlled by a flag whose value is
// set, it is assumed that that portion of the context record contains
// valid context. If the context record is being used to modify a threads
// context, then only that portion of the threads context is modified.
//
// If the context record is used as an output parameter to capture the
// context of a thread, then only those portions of the thread's context
// corresponding to set flags will be returned.
//
// CONTEXT_CONTROL specifies SegSs, Rsp, SegCs, Rip, and EFlags.
//
// CONTEXT_INTEGER specifies Rax, Rcx, Rdx, Rbx, Rbp, Rsi, Rdi, and R8-R15.
//
// CONTEXT_SEGMENTS specifies SegDs, SegEs, SegFs, and SegGs.
//
// CONTEXT_DEBUG_REGISTERS specifies Dr0-Dr3 and Dr6-Dr7.
//
// CONTEXT_MMX_REGISTERS specifies the floating point and extended registers
//     Mm0/St0-Mm7/St7 and Xmm0-Xmm15).
//

typedef struct DECLSPEC_ALIGN(16) _CONTEXT {

    //
    // Register parameter home addresses.
    //
    // N.B. These fields are for convience - they could be used to extend the
    //      context record in the future.
    //

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5Home;
    ULONG64 P6Home;

    //
    // Control flags.
    //

    ULONG ContextFlags;
    ULONG MxCsr;

    //
    // Segment Registers and processor flags.
    //

    USHORT SegCs;
    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;
    USHORT SegSs;
    ULONG EFlags;

    //
    // Debug registers
    //

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

    //
    // Integer registers.
    //

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 Rbx;
    ULONG64 Rsp;
    ULONG64 Rbp;
    ULONG64 Rsi;
    ULONG64 Rdi;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;
    ULONG64 R12;
    ULONG64 R13;
    ULONG64 R14;
    ULONG64 R15;

    //
    // Program counter.
    //

    ULONG64 Rip;

    //
    // Floating point state.
    //

    union {
        XMM_SAVE_AREA32 FltSave;
        struct {
            M128A Header[2];
            M128A Legacy[8];
            M128A Xmm0;
            M128A Xmm1;
            M128A Xmm2;
            M128A Xmm3;
            M128A Xmm4;
            M128A Xmm5;
            M128A Xmm6;
            M128A Xmm7;
            M128A Xmm8;
            M128A Xmm9;
            M128A Xmm10;
            M128A Xmm11;
            M128A Xmm12;
            M128A Xmm13;
            M128A Xmm14;
            M128A Xmm15;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    //
    // Vector registers.
    //

    M128A VectorRegister[26];
    ULONG64 VectorControl;

    //
    // Special debug control registers.
    //

    ULONG64 DebugControl;
    ULONG64 LastBranchToRip;
    ULONG64 LastBranchFromRip;
    ULONG64 LastExceptionToRip;
    ULONG64 LastExceptionFromRip;
} CONTEXT, *PCONTEXT;


#endif // _AMD64_


#ifdef _IA64_

//
// Define size of kernel mode stack.
//

#define KERNEL_STACK_SIZE 0x8000

//
// Define size of large kernel mode stack for callbacks.
//

#define KERNEL_LARGE_STACK_SIZE 0x1A000

//
// Define number of pages to initialize in a large kernel stack.
//

#define KERNEL_LARGE_STACK_COMMIT 0x8000

//
//  Define size of kernel mode backing store stack.
//

#define KERNEL_BSTORE_SIZE 0x8000

//
//  Define size of large kernel mode backing store for callbacks.
//

#define KERNEL_LARGE_BSTORE_SIZE 0x10000

//
//  Define number of pages to initialize in a large kernel backing store.
//

#define KERNEL_LARGE_BSTORE_COMMIT 0x8000

//
// Define base address for kernel and user space.
//

#define UREGION_INDEX 0

#define KREGION_INDEX 7

#define UADDRESS_BASE ((ULONGLONG)UREGION_INDEX << 61)


#define KADDRESS_BASE ((ULONGLONG)KREGION_INDEX << 61)


#if defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#ifdef __cplusplus
extern "C" {
#endif

//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64

BOOLEAN
_bittest (
    IN LONG const *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandreset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittest64 (
    IN LONG64 const *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

BOOLEAN
_BitScanForward (
    OUT ULONG *Index,
    IN ULONG Mask
    );

BOOLEAN
_BitScanReverse (
    OUT ULONG *Index,
    IN ULONG Mask
    );

BOOLEAN
_BitScanForward64 (
    OUT ULONG *Index,
    IN ULONG64 Mask
    );

BOOLEAN
_BitScanReverse64 (
    OUT ULONG *Index,
    IN ULONG64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

#define InterlockedCompareExchange16 _InterlockedCompareExchange16

SHORT
_InterlockedCompareExchange16 (
    __inout SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange16)

#ifdef __cplusplus
}
#endif

#define InterlockedAdd 				_InterlockedAdd
#define InterlockedAddAcquire 			_InterlockedAdd_acq
#define InterlockedAddRelease 			_InterlockedAdd_rel

#define InterlockedIncrement 			_InterlockedIncrement
#define InterlockedIncrementAcquire 		_InterlockedIncrement_acq
#define InterlockedIncrementRelease 		_InterlockedIncrement_rel

#define InterlockedDecrement 			_InterlockedDecrement
#define InterlockedDecrementAcquire 		_InterlockedDecrement_acq
#define InterlockedDecrementRelease 		_InterlockedDecrement_rel

#define InterlockedExchange 			_InterlockedExchange
#define InterlockedExchangeAcquire 		_InterlockedExchange_acq

#define InterlockedExchangeAdd 			_InterlockedExchangeAdd
#define InterlockedExchangeAddAcquire 		_InterlockedExchangeAdd_acq
#define InterlockedExchangeAddRelease 		_InterlockedExchangeAdd_rel

#define InterlockedAdd64 			_InterlockedAdd64
#define InterlockedAddAcquire64 		_InterlockedAdd64_acq
#define InterlockedAddRelease64 		_InterlockedAdd64_rel

#define InterlockedIncrement64 			_InterlockedIncrement64
#define InterlockedIncrementAcquire64 		_InterlockedIncrement64_acq
#define InterlockedIncrementRelease64 		_InterlockedIncrement64_rel

#define InterlockedDecrement64 			_InterlockedDecrement64
#define InterlockedDecrementAcquire64 		_InterlockedDecrement64_acq
#define InterlockedDecrementRelease64 		_InterlockedDecrement64_rel

#define InterlockedExchange64 			_InterlockedExchange64
#define InterlockedExchangeAcquire64 		_InterlockedExchange64_acq

#define InterlockedExchangeAdd64 		_InterlockedExchangeAdd64
#define InterlockedExchangeAddAcquire64 	_InterlockedExchangeAdd64_acq
#define InterlockedExchangeAddRelease64 	_InterlockedExchangeAdd64_rel

#define InterlockedCompareExchange64 		_InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 	_InterlockedCompareExchange64_acq
#define InterlockedCompareExchangeRelease64 	_InterlockedCompareExchange64_rel

#define InterlockedCompare64Exchange128     _InterlockedCompare64Exchange128
#define InterlockedCompare64ExchangeAcquire128  _InterlockedCompare64Exchange128_acq
#define InterlockedCompare64ExchangeRelease128  _InterlockedCompare64Exchange128_rel

#define InterlockedCompareExchange 		_InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire 	_InterlockedCompareExchange_acq
#define InterlockedCompareExchangeRelease 	_InterlockedCompareExchange_rel

#define InterlockedExchangePointer 		_InterlockedExchangePointer
#define InterlockedExchangePointerAcquire       _InterlockedExchangePointer_acq

#define InterlockedCompareExchangePointer 	 _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer_rel
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer_acq


#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

#define InterlockedOr       _InterlockedOr
#define InterlockedOrAcquire   _InterlockedOr_acq
#define InterlockedOrRelease   _InterlockedOr_rel
#define InterlockedOr8      _InterlockedOr8
#define InterlockedOr8Acquire  _InterlockedOr8_acq
#define InterlockedOr8Release  _InterlockedOr8_rel
#define InterlockedOr16     _InterlockedOr16
#define InterlockedOr16Acquire _InterlockedOr16_acq
#define InterlockedOr16Release _InterlockedOr16_rel
#define InterlockedOr64     _InterlockedOr64
#define InterlockedOr64Acquire _InterlockedOr64_acq
#define InterlockedOr64Release _InterlockedOr64_rel
#define InterlockedXor      _InterlockedXor
#define InterlockedXorAcquire  _InterlockedXor_acq
#define InterlockedXorRelease  _InterlockedXor_rel
#define InterlockedXor8     _InterlockedXor8
#define InterlockedXor8Acquire _InterlockedXor8_acq
#define InterlockedXor8Release _InterlockedXor8_rel
#define InterlockedXor16    _InterlockedXor16
#define InterlockedXor16Acquire _InterlockedXor16_acq
#define InterlockedXor16Release _InterlockedXor16_rel
#define InterlockedXor64     _InterlockedXor64
#define InterlockedXor64Acquire _InterlockedXor64_acq
#define InterlockedXor64Release _InterlockedXor64_rel
#define InterlockedAnd       _InterlockedAnd
#define InterlockedAndAcquire   _InterlockedAnd_acq
#define InterlockedAndRelease   _InterlockedAnd_rel
#define InterlockedAnd8      _InterlockedAnd8
#define InterlockedAnd8Acquire  _InterlockedAnd8_acq
#define InterlockedAnd8Release  _InterlockedAnd8_rel
#define InterlockedAnd16     _InterlockedAnd16
#define InterlockedAnd16Acquire _InterlockedAnd16_acq
#define InterlockedAnd16Release _InterlockedAnd16_rel
#define InterlockedAnd64     _InterlockedAnd64
#define InterlockedAnd64Acquire _InterlockedAnd64_acq
#define InterlockedAnd64Release _InterlockedAnd64_rel

#ifdef __cplusplus
extern "C" {
#endif

LONG
__cdecl
InterlockedAdd (
    LONG volatile *Addend,
    LONG Value
    );

LONG
__cdecl
InterlockedAddAcquire (
    LONG volatile *Addend,
    LONG Value
    );

LONG
__cdecl
InterlockedAddRelease (
    LONG volatile *Addend,
    LONG Value
    );
    
LONGLONG
__cdecl
InterlockedAdd64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAddAcquire64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );


LONGLONG
__cdecl
InterlockedAddRelease64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONG
__cdecl
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementAcquire(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementAcquire(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementRelease(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementRelease(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAcquire(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAddAcquire(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAddRelease(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );
LONG
__cdecl
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeRelease (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONGLONG
__cdecl
InterlockedIncrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedIncrementAcquire64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedIncrementRelease64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrementAcquire64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrementRelease64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedExchange64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAcquire64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAddAcquire64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAddRelease64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeAcquire64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeRelease64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONG64
__cdecl
InterlockedCompare64Exchange128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeAcquire128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeRelease128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerAcquire (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerRelease (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

PVOID
__cdecl
InterlockedExchangePointerAcquire(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

LONG
__cdecl
InterlockedOr (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedOrAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedOrRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedOr8 (
    IN OUT CHAR volatile *Destination,
    IN    CHAR Value
    );

CHAR
__cdecl
InterlockedOr8Acquire (
    IN OUT CHAR volatile *Destination,
    IN    CHAR Value
    );

CHAR
__cdecl
InterlockedOr8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedOr16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedOr16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedOr16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedOr64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedOr64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedOr64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONG
__cdecl
InterlockedXor (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedXorAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedXorRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedXor8 (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedXor8Acquire (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedXor8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedXor16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedXor16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedXor16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedXor64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedXor64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedXor64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONG
__cdecl
InterlockedAnd (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedAndAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedAndRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedAnd8 (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedAnd8Acquire (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedAnd8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedAnd16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedAnd16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedAnd16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedAnd64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAnd64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedAnd64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

#pragma intrinsic(_InterlockedAdd)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedIncrement_acq)
#pragma intrinsic(_InterlockedIncrement_rel)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedDecrement_acq)
#pragma intrinsic(_InterlockedDecrement_rel)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedCompareExchange_acq)
#pragma intrinsic(_InterlockedCompareExchange_rel)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedAdd64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedCompareExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64_rel)
#pragma intrinsic(_InterlockedCompare64Exchange128)
#pragma intrinsic(_InterlockedCompare64Exchange128_acq)
#pragma intrinsic(_InterlockedCompare64Exchange128_rel)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer_acq)
#pragma intrinsic(_InterlockedCompareExchangePointer_rel)
#pragma intrinsic(_InterlockedAdd_acq)
#pragma intrinsic(_InterlockedAdd_rel)
#pragma intrinsic(_InterlockedExchange_acq)
#pragma intrinsic(_InterlockedExchangeAdd_acq)
#pragma intrinsic(_InterlockedExchangeAdd_rel)
#pragma intrinsic(_InterlockedAdd64_acq)
#pragma intrinsic(_InterlockedAdd64_rel)
#pragma intrinsic(_InterlockedIncrement64_acq)
#pragma intrinsic(_InterlockedIncrement64_rel)
#pragma intrinsic(_InterlockedDecrement64_acq)
#pragma intrinsic(_InterlockedDecrement64_rel)
#pragma intrinsic(_InterlockedExchangeAdd64_acq)
#pragma intrinsic(_InterlockedExchangeAdd64_rel)
#pragma intrinsic(_InterlockedExchangePointer_acq)
#pragma intrinsic (_InterlockedOr)
#pragma intrinsic (_InterlockedOr_acq)
#pragma intrinsic (_InterlockedOr_rel)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedOr8_acq)
#pragma intrinsic (_InterlockedOr8_rel)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedOr16_acq)
#pragma intrinsic (_InterlockedOr16_rel)
#pragma intrinsic (_InterlockedOr64)
#pragma intrinsic (_InterlockedOr64_acq)
#pragma intrinsic (_InterlockedOr64_rel)
#pragma intrinsic (_InterlockedXor)
#pragma intrinsic (_InterlockedXor_acq)
#pragma intrinsic (_InterlockedXor_rel)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedXor8_acq)
#pragma intrinsic (_InterlockedXor8_rel)
#pragma intrinsic (_InterlockedXor16)
#pragma intrinsic (_InterlockedXor16_acq)
#pragma intrinsic (_InterlockedXor16_rel)
#pragma intrinsic (_InterlockedXor64)
#pragma intrinsic (_InterlockedXor64_acq)
#pragma intrinsic (_InterlockedXor64_rel)
#pragma intrinsic (_InterlockedAnd)
#pragma intrinsic (_InterlockedAnd_acq)
#pragma intrinsic (_InterlockedAnd_rel)
#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedAnd8_acq)
#pragma intrinsic (_InterlockedAnd8_rel)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedAnd16_acq)
#pragma intrinsic (_InterlockedAnd16_rel)
#pragma intrinsic (_InterlockedAnd64)
#pragma intrinsic (_InterlockedAnd64_acq)
#pragma intrinsic (_InterlockedAnd64_rel)

#if !defined (InterlockedAnd64)

#define InterlockedAnd64 InterlockedAnd64_Inline

LONGLONG
FORCEINLINE
InterlockedAnd64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

#endif

#define InterlockedAndAffinity InterlockedAnd64

#if !defined (InterlockedOr64)

#define InterlockedOr64 InterlockedOr64_Inline

LONGLONG
FORCEINLINE
InterlockedOr64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

#endif

#define InterlockedOrAffinity InterlockedOr64

#if !defined (InterlockedXor64)

#define InterlockedXor64 InterlockedXor64_Inline

LONGLONG
FORCEINLINE
InterlockedXor64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

#endif

#if !defined (InterlockedBitTestAndSet)

#define InterlockedBitTestAndSet InterlockedBitTestAndSet_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndSet_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedOr (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset)

#define InterlockedBitTestAndReset InterlockedBitTestAndReset_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndReset_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedAnd (&Base[Bit/(sizeof (*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndSet64)

#define InterlockedBitTestAndSet64 InterlockedBitTestAndSet64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndSet64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedOr64 (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset64)

#define InterlockedBitTestAndReset64 InterlockedBitTestAndReset64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndReset64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedAnd64 (&Base[Bit/(sizeof (*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement)

#define InterlockedBitTestAndComplement InterlockedBitTestAndComplement_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndComplement_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedXor (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement64)

#define InterlockedBitTestAndComplement64 InterlockedBitTestAndComplement64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndComplement64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedXor64 (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#ifdef __cplusplus
}
#endif

#endif /* defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS) */


#ifdef __cplusplus
extern "C" {
#endif



#if defined(_IA64_) && defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

void 
__break( 
    int
    );

#pragma intrinsic (__break)

#define BREAK_DEBUG_BASE    0x080000
#define ASSERT_BREAKPOINT         (BREAK_DEBUG_BASE+3)  // Cause a STATUS_ASSERTION_FAILURE exception to be raised.

#define DbgRaiseAssertionFailure() __break(ASSERT_BREAKPOINT)

#endif



void 
__yield(
   void
   );

void
__mf(
    void
    );

void 
__lfetch(
    int Level, 
    __in volatile VOID CONST *Address
    );

void 
__lfetchfault(
    __in int Level, 
    __in volatile VOID CONST *Address
    );

void 
__lfetch_excl(
    __in int Level, 
    __in volatile VOID CONST *Address
    );

void
__lfetchfault_excl(
    __in int Level, 
    __in volatile VOID CONST *Address
    );

//
// __lfetch control defines.
//

#define MD_LFHINT_NONE    0x00
#define MD_LFHINT_NT1     0x01
#define MD_LFHINT_NT2     0x02
#define MD_LFHINT_NTA     0x03

#pragma intrinsic (__yield)
#pragma intrinsic (__lfetch)
#pragma intrinsic (__lfetchfault)
#pragma intrinsic (__lfetchfault_excl)
#pragma intrinsic (__lfetch_excl)
#pragma intrinsic (__mf)

//
// Define function to read the value of the time stamp counter
//
// N.B. The register number for the time stamp counter is CV_IA64_ApITC which
//      is 3116.
//

#define ReadTimeStampCounter() __getReg(3116)

unsigned __int64
__getReg (
    int Number
    );

#pragma intrinsic(__getReg)

#define YieldProcessor          __yield
#define MemoryBarrier           __mf
#define PreFetchCacheLine       __lfetch
#define PrefetchForWrite(p)
#define ReadForWriteAccess(p)   (__lfetch_excl(MD_LFHINT_NONE, (p)), (*(p)))


//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1         MD_LFHINT_NONE
#define PF_TEMPORAL_LEVEL_2         MD_LFHINT_NT1
#define PF_TEMPORAL_LEVEL_3         MD_LFHINT_NT2
#define PF_NON_TEMPORAL_LEVEL_ALL   MD_LFHINT_NTA

//
// Define functions to capture the high 64-bits of a 128-bit multiply.
//

#define UnsignedMultiplyHigh __UMULH

ULONGLONG
UnsignedMultiplyHigh (
    IN ULONGLONG Multiplier,
    IN ULONGLONG Multiplicand
    );

#pragma intrinsic(__UMULH)

#if (_MSC_VER >= 1400)

#define UnsignedMultiply128 _umul128

ULONG64
UnsignedMultiply128 (
    __in unsigned __int64 Multiplier,
    __in unsigned __int64 Multiplicand,
    __out __deref_out_range(==,Multiplier * Multiplicand) unsigned __int64 *HighProduct
    );
#pragma intrinsic(_umul128)

#endif

#ifdef __cplusplus
}
#endif


//
// The following values specify the type of failing access when the status is 
// STATUS_ACCESS_VIOLATION and the first parameter in the exception record.
//

#define EXCEPTION_READ_FAULT          0 // Access violation was caused by a read
#define EXCEPTION_WRITE_FAULT         1 // Access violation was caused by a write
#define EXCEPTION_EXECUTE_FAULT       2 // Access violation was caused by an instruction fetch

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_IA64                    0x00080000

#define CONTEXT_CONTROL                 (CONTEXT_IA64 | 0x00000001L)
#define CONTEXT_LOWER_FLOATING_POINT    (CONTEXT_IA64 | 0x00000002L)
#define CONTEXT_HIGHER_FLOATING_POINT   (CONTEXT_IA64 | 0x00000004L)
#define CONTEXT_INTEGER                 (CONTEXT_IA64 | 0x00000008L)
#define CONTEXT_DEBUG                   (CONTEXT_IA64 | 0x00000010L)
#define CONTEXT_IA32_CONTROL            (CONTEXT_IA64 | 0x00000020L)  // Includes StIPSR


#define CONTEXT_FLOATING_POINT          (CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT)
#define CONTEXT_FULL                    (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER | CONTEXT_IA32_CONTROL)
#define CONTEXT_ALL                     (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER | CONTEXT_DEBUG | CONTEXT_IA32_CONTROL)

#define CONTEXT_EXCEPTION_ACTIVE        0x8000000
#define CONTEXT_SERVICE_ACTIVE          0x10000000
#define CONTEXT_EXCEPTION_REQUEST       0x40000000
#define CONTEXT_EXCEPTION_REPORTING     0x80000000

#endif // !defined(RC_INVOKED)

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to construct a call frame for APC delivery,
//  3) it is used to construct a call frame for exception dispatching
//  in user mode, 4) it is used in the user level thread creation
//  routines, and 5) it is used to to pass thread state to debuggers.
//
//  N.B. Because this record is used as a call frame, it must be EXACTLY
//  a multiple of 16 bytes in length and aligned on a 16-byte boundary.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;
    ULONG Fill1[3];         // for alignment of following on 16-byte boundary

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_DEBUG.
    //
    // N.B. CONTEXT_DEBUG is *not* part of CONTEXT_FULL.
    //

    ULONGLONG DbI0;
    ULONGLONG DbI1;
    ULONGLONG DbI2;
    ULONGLONG DbI3;
    ULONGLONG DbI4;
    ULONGLONG DbI5;
    ULONGLONG DbI6;
    ULONGLONG DbI7;

    ULONGLONG DbD0;
    ULONGLONG DbD1;
    ULONGLONG DbD2;
    ULONGLONG DbD3;
    ULONGLONG DbD4;
    ULONGLONG DbD5;
    ULONGLONG DbD6;
    ULONGLONG DbD7;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT.
    //

    FLOAT128 FltS0;
    FLOAT128 FltS1;
    FLOAT128 FltS2;
    FLOAT128 FltS3;
    FLOAT128 FltT0;
    FLOAT128 FltT1;
    FLOAT128 FltT2;
    FLOAT128 FltT3;
    FLOAT128 FltT4;
    FLOAT128 FltT5;
    FLOAT128 FltT6;
    FLOAT128 FltT7;
    FLOAT128 FltT8;
    FLOAT128 FltT9;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_HIGHER_FLOATING_POINT.
    //

    FLOAT128 FltS4;
    FLOAT128 FltS5;
    FLOAT128 FltS6;
    FLOAT128 FltS7;
    FLOAT128 FltS8;
    FLOAT128 FltS9;
    FLOAT128 FltS10;
    FLOAT128 FltS11;
    FLOAT128 FltS12;
    FLOAT128 FltS13;
    FLOAT128 FltS14;
    FLOAT128 FltS15;
    FLOAT128 FltS16;
    FLOAT128 FltS17;
    FLOAT128 FltS18;
    FLOAT128 FltS19;

    FLOAT128 FltF32;
    FLOAT128 FltF33;
    FLOAT128 FltF34;
    FLOAT128 FltF35;
    FLOAT128 FltF36;
    FLOAT128 FltF37;
    FLOAT128 FltF38;
    FLOAT128 FltF39;

    FLOAT128 FltF40;
    FLOAT128 FltF41;
    FLOAT128 FltF42;
    FLOAT128 FltF43;
    FLOAT128 FltF44;
    FLOAT128 FltF45;
    FLOAT128 FltF46;
    FLOAT128 FltF47;
    FLOAT128 FltF48;
    FLOAT128 FltF49;

    FLOAT128 FltF50;
    FLOAT128 FltF51;
    FLOAT128 FltF52;
    FLOAT128 FltF53;
    FLOAT128 FltF54;
    FLOAT128 FltF55;
    FLOAT128 FltF56;
    FLOAT128 FltF57;
    FLOAT128 FltF58;
    FLOAT128 FltF59;

    FLOAT128 FltF60;
    FLOAT128 FltF61;
    FLOAT128 FltF62;
    FLOAT128 FltF63;
    FLOAT128 FltF64;
    FLOAT128 FltF65;
    FLOAT128 FltF66;
    FLOAT128 FltF67;
    FLOAT128 FltF68;
    FLOAT128 FltF69;

    FLOAT128 FltF70;
    FLOAT128 FltF71;
    FLOAT128 FltF72;
    FLOAT128 FltF73;
    FLOAT128 FltF74;
    FLOAT128 FltF75;
    FLOAT128 FltF76;
    FLOAT128 FltF77;
    FLOAT128 FltF78;
    FLOAT128 FltF79;

    FLOAT128 FltF80;
    FLOAT128 FltF81;
    FLOAT128 FltF82;
    FLOAT128 FltF83;
    FLOAT128 FltF84;
    FLOAT128 FltF85;
    FLOAT128 FltF86;
    FLOAT128 FltF87;
    FLOAT128 FltF88;
    FLOAT128 FltF89;

    FLOAT128 FltF90;
    FLOAT128 FltF91;
    FLOAT128 FltF92;
    FLOAT128 FltF93;
    FLOAT128 FltF94;
    FLOAT128 FltF95;
    FLOAT128 FltF96;
    FLOAT128 FltF97;
    FLOAT128 FltF98;
    FLOAT128 FltF99;

    FLOAT128 FltF100;
    FLOAT128 FltF101;
    FLOAT128 FltF102;
    FLOAT128 FltF103;
    FLOAT128 FltF104;
    FLOAT128 FltF105;
    FLOAT128 FltF106;
    FLOAT128 FltF107;
    FLOAT128 FltF108;
    FLOAT128 FltF109;

    FLOAT128 FltF110;
    FLOAT128 FltF111;
    FLOAT128 FltF112;
    FLOAT128 FltF113;
    FLOAT128 FltF114;
    FLOAT128 FltF115;
    FLOAT128 FltF116;
    FLOAT128 FltF117;
    FLOAT128 FltF118;
    FLOAT128 FltF119;

    FLOAT128 FltF120;
    FLOAT128 FltF121;
    FLOAT128 FltF122;
    FLOAT128 FltF123;
    FLOAT128 FltF124;
    FLOAT128 FltF125;
    FLOAT128 FltF126;
    FLOAT128 FltF127;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT | CONTEXT_CONTROL.
    //

    ULONGLONG StFPSR;       //  FP status

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, rp are part of the control context
    //

    ULONGLONG IntGp;        //  r1, volatile
    ULONGLONG IntT0;        //  r2-r3, volatile
    ULONGLONG IntT1;        //
    ULONGLONG IntS0;        //  r4-r7, preserved
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntV0;        //  r8, volatile
    ULONGLONG IntT2;        //  r9-r11, volatile
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;        //  stack pointer (r12), special
    ULONGLONG IntTeb;       //  teb (r13), special
    ULONGLONG IntT5;        //  r14-r31, volatile
    ULONGLONG IntT6;
    ULONGLONG IntT7;
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG IntNats;      //  Nat bits for r1-r31
                            //  r1-r31 in bits 1 thru 31.
    ULONGLONG Preds;        //  predicates, preserved

    ULONGLONG BrRp;         //  return pointer, b0, preserved
    ULONGLONG BrS0;         //  b1-b5, preserved
    ULONGLONG BrS1;
    ULONGLONG BrS2;
    ULONGLONG BrS3;
    ULONGLONG BrS4;
    ULONGLONG BrT0;         //  b6-b7, volatile
    ULONGLONG BrT1;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    // Other application registers
    ULONGLONG ApUNAT;       //  User Nat collection register, preserved
    ULONGLONG ApLC;         //  Loop counter register, preserved
    ULONGLONG ApEC;         //  Epilog counter register, preserved
    ULONGLONG ApCCV;        //  CMPXCHG value register, volatile
    ULONGLONG ApDCR;        //  Default control register (TBD)

    // Register stack info
    ULONGLONG RsPFS;        //  Previous function state, preserved
    ULONGLONG RsBSP;        //  Backing store pointer, preserved
    ULONGLONG RsBSPSTORE;
    ULONGLONG RsRSC;        //  RSE configuration, volatile
    ULONGLONG RsRNAT;       //  RSE Nat collection register, preserved

    // Trap Status Information
    ULONGLONG StIPSR;       //  Interruption Processor Status
    ULONGLONG StIIP;        //  Interruption IP
    ULONGLONG StIFS;        //  Interruption Function State

    // iA32 related control registers
    ULONGLONG StFCR;        //  copy of Ar21
    ULONGLONG Eflag;        //  Eflag copy of Ar24
    ULONGLONG SegCSD;       //  iA32 CSDescriptor (Ar25)
    ULONGLONG SegSSD;       //  iA32 SSDescriptor (Ar26)
    ULONGLONG Cflag;        //  Cr0+Cr4 copy of Ar27
    ULONGLONG StFSR;        //  x86 FP status (copy of AR28)
    ULONGLONG StFIR;        //  x86 FP status (copy of AR29)
    ULONGLONG StFDR;        //  x86 FP status (copy of AR30)

      ULONGLONG UNUSEDPACK;   //  added to pack StFDR to 16-bytes

} CONTEXT, *PCONTEXT;

//
// Plabel descriptor structure definition
//

typedef struct _PLABEL_DESCRIPTOR {
   ULONGLONG EntryPoint;
   ULONGLONG GlobalPointer;
} PLABEL_DESCRIPTOR, *PPLABEL_DESCRIPTOR;



#endif // _IA64_


//
// Well known SID definitions for lookup.
//

typedef enum {

    WinNullSid                                  = 0,
    WinWorldSid                                 = 1,
    WinLocalSid                                 = 2,
    WinCreatorOwnerSid                          = 3,
    WinCreatorGroupSid                          = 4,
    WinCreatorOwnerServerSid                    = 5,
    WinCreatorGroupServerSid                    = 6,
    WinNtAuthoritySid                           = 7,
    WinDialupSid                                = 8,
    WinNetworkSid                               = 9,
    WinBatchSid                                 = 10,
    WinInteractiveSid                           = 11,
    WinServiceSid                               = 12,
    WinAnonymousSid                             = 13,
    WinProxySid                                 = 14,
    WinEnterpriseControllersSid                 = 15,
    WinSelfSid                                  = 16,
    WinAuthenticatedUserSid                     = 17,
    WinRestrictedCodeSid                        = 18,
    WinTerminalServerSid                        = 19,
    WinRemoteLogonIdSid                         = 20,
    WinLogonIdsSid                              = 21,
    WinLocalSystemSid                           = 22,
    WinLocalServiceSid                          = 23,
    WinNetworkServiceSid                        = 24,
    WinBuiltinDomainSid                         = 25,
    WinBuiltinAdministratorsSid                 = 26,
    WinBuiltinUsersSid                          = 27,
    WinBuiltinGuestsSid                         = 28,
    WinBuiltinPowerUsersSid                     = 29,
    WinBuiltinAccountOperatorsSid               = 30,
    WinBuiltinSystemOperatorsSid                = 31,
    WinBuiltinPrintOperatorsSid                 = 32,
    WinBuiltinBackupOperatorsSid                = 33,
    WinBuiltinReplicatorSid                     = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid             = 36,
    WinBuiltinNetworkConfigurationOperatorsSid  = 37,
    WinAccountAdministratorSid                  = 38,
    WinAccountGuestSid                          = 39,
    WinAccountKrbtgtSid                         = 40,
    WinAccountDomainAdminsSid                   = 41,
    WinAccountDomainUsersSid                    = 42,
    WinAccountDomainGuestsSid                   = 43,
    WinAccountComputersSid                      = 44,
    WinAccountControllersSid                    = 45,
    WinAccountCertAdminsSid                     = 46,
    WinAccountSchemaAdminsSid                   = 47,
    WinAccountEnterpriseAdminsSid               = 48,
    WinAccountPolicyAdminsSid                   = 49,
    WinAccountRasAndIasServersSid               = 50,
    WinNTLMAuthenticationSid                    = 51,
    WinDigestAuthenticationSid                  = 52,
    WinSChannelAuthenticationSid                = 53,
    WinThisOrganizationSid                      = 54,
    WinOtherOrganizationSid                     = 55,
    WinBuiltinIncomingForestTrustBuildersSid    = 56,
    WinBuiltinPerfMonitoringUsersSid            = 57,
    WinBuiltinPerfLoggingUsersSid               = 58,
    WinBuiltinAuthorizationAccessSid            = 59,
    WinBuiltinTerminalServerLicenseServersSid   = 60,
    WinBuiltinDCOMUsersSid                      = 61,
    WinBuiltinIUsersSid                         = 62,
    WinIUserSid                                 = 63,
    WinBuiltinCryptoOperatorsSid                = 64,
    WinUntrustedLabelSid                        = 65,
    WinLowLabelSid                              = 66,
    WinMediumLabelSid                           = 67,
    WinHighLabelSid                             = 68,
    WinSystemLabelSid                           = 69,
    WinWriteRestrictedCodeSid                   = 70,
    WinCreatorOwnerRightsSid                    = 71,
    WinCacheablePrincipalsGroupSid              = 72,
    WinNonCacheablePrincipalsGroupSid           = 73,
    WinEnterpriseReadonlyControllersSid         = 74,
    WinAccountReadonlyControllersSid            = 75,
    WinBuiltinEventLogReadersGroup              = 76,
    WinNewEnterpriseReadonlyControllersSid      = 77,
    WinBuiltinCertSvcDComAccessGroup 		= 78,
} WELL_KNOWN_SID_TYPE;

//
// Unsolicited Input is obsolete and unused.
//

#define SE_UNSOLICITED_INPUT_PRIVILEGE      (6L)

// begin_ntsecapi
#ifndef _NTLSA_IFS_


//
// All of this stuff (between the Ifndef _NTLSA_AUDIT_ and its endif) were not
// present in NTIFS prior to Windows Server 2003 SP1. All of the definitions however
// exist down to windows 2000 (except for the few exceptions noted in the code).
//

#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Data types related to Auditing                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The following enumerated type is used between the reference monitor and
// LSA in the generation of audit messages.  It is used to indicate the
// type of data being passed as a parameter from the reference monitor
// to LSA.  LSA is responsible for transforming the specified data type
// into a set of unicode strings that are added to the event record in
// the audit log.
//

typedef enum _SE_ADT_PARAMETER_TYPE {

    SeAdtParmTypeNone = 0,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  a unicode string containing "-".
                                    //
                                    //Note:  This is typically used to
                                    //       indicate that a parameter value
                                    //       was not available.
                                    //

    SeAdtParmTypeString,            //Produces 1 parameter.
                                    //Received Value:
                                    //
                                    //  Unicode String (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  No transformation.  The string
                                    //  entered into the event record as
                                    //  received.
                                    //
                                    // The Address value of the audit info
                                    // should be a pointer to a UNICODE_STRING
                                    // structure.



    SeAdtParmTypeFileSpec,          //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  Unicode string containing a file or
                                    //  directory name.
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string with the prefix of the
                                    //  file's path replaced by a drive letter
                                    //  if possible.
                                    //




    SeAdtParmTypeUlong,             //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value.


    SeAdtParmTypeSid,               //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  SID (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  String representation of SID
                                    //




    SeAdtParmTypeLogonId,           //Produces 4 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Sid string
                                    //  param 2: Username string
                                    //  param 3: domain name string
                                    //  param 4: Logon ID (Luid) string


    SeAdtParmTypeNoLogonId,         //Produces 3 parameters.
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  param 1: "-"
                                    //  param 2: "-"
                                    //  param 3: "-"
                                    //  param 4: "-"
                                    //
                                    //Note:
                                    //
                                    //  This type is used when a logon ID
                                    //  is needed, but one is not available
                                    //  to pass.  For example, if an
                                    //  impersonation logon ID is expected
                                    //  but the subject is not impersonating
                                    //  anyone.
                                    //

    SeAdtParmTypeAccessMask,        //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //  ACCESS_MASK followed by
                                    //  a Unicode string.  The unicode
                                    //  string contains the name of the
                                    //  type of object the access mask
                                    //  applies to.  The event's source
                                    //  further qualifies the object type.
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string built to
                                    //  take advantage of the specified
                                    //  source's parameter message file.
                                    //
                                    //Note:
                                    //
                                    //  An access mask containing three
                                    //  access types for a Widget object
                                    //  type (defined by the Foozle source)
                                    //  might end up looking like:
                                    //
                                    //      %%1062\n\t\t%1066\n\t\t%%601
                                    //
                                    //  The %%numbers are signals to the
                                    //  event viewer to perform parameter
                                    //  substitution before display.
                                    //



    SeAdtParmTypePrivs,             //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string similar to
                                    //  that for access types.  Each priv
                                    //  will be formatted to be displayed
                                    //  on its own line.  E.g.,
                                    //
                                    //      %%642\n\t\t%%651\n\t\t%%655
                                    //

    SeAdtParmTypeObjectTypes,       //Produces 10 parameters with formatting.
                                    //Received value:
                                    //
                                    // Produces a list a stringized GUIDS along
                                    // with information similar to that for
                                    // an access mask.

    SeAdtParmTypeHexUlong,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

// In W2k this value did not exist, it was ParmTypeLUID

    SeAdtParmTypePtr,               //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  pointer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

//
// Everything below exists only in Windows XP and greater
//

    SeAdtParmTypeTime,              //Produces 2 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time.

                                    //
    SeAdtParmTypeGuid,              //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  GUID pointer
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of GUID
                                    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                                    //

//
// Everything below exists only in Windows Server 2003 and Greater
//

    SeAdtParmTypeLuid,              //
                                    //Produces 1 parameter
                                    //Received value:
                                    //
                                    // LUID
                                    //
                                    //Results in:
                                    //
                                    // Hex LUID
                                    //

    SeAdtParmTypeHexInt64,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  64 bit integer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

    SeAdtParmTypeStringList,        //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_STRING_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the strings in the list

    SeAdtParmTypeSidList,           //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_SID_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the SIDs in the list

    SeAdtParmTypeDuration,          //Produces 1 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // a duration.

    SeAdtParmTypeUserAccountControl,//Produces 3 parameters
                                    //Received value:
                                    //
                                    // old and new UserAccountControl values
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representations of
                                    // the flags in UserAccountControl.
                                    // 1 - old value in hex
                                    // 2 - new value in hex
                                    // 3 - difference as strings

    SeAdtParmTypeNoUac,             //Produces 3 parameters
                                    //Received value:
                                    //
                                    // none
                                    //
                                    //Results in:
                                    //
                                    // Three dashes ('-') as unicode strings.

    SeAdtParmTypeMessage,           //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  ULONG (MessageNo from msobjs.mc)
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // %%MessageNo which the event viewer
                                    // will replace with the message string
                                    // from msobjs.mc

    SeAdtParmTypeDateTime,          //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time (in _one_ string).

    SeAdtParmTypeSockAddr,          // Produces 2 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IP address string
                                    // param 2: Port number string
                                    //

//
// Everything below this exists only in Longhorn and greater
//

    SeAdtParmTypeSD,                // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SECURITY_DESCRIPTOR
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // SDDL string representation of SD
                                    //

    SeAdtParmTypeLogonHours,        // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to LOGON_HOURS
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // String representation of allowed logon hours
                                    //

    SeAdtParmTypeLogonIdNoSid,      //Produces 3 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Username string
                                    //  param 2: domain name string
                                    //  param 3: Logon ID (Luid) string

    SeAdtParmTypeUlongNoConv,       // Produces 1 parameter.
                                    // Received Value:
                                    // Ulong
                                    //
                                    //Results in:
                                    // Not converted to string
                                    //

    SeAdtParmTypeSockAddrNoPort     // Produces 1 parameter
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IPv4/IPv6 address string
                                    //

} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

typedef struct _SE_ADT_OBJECT_TYPE {
    GUID ObjectType;
    USHORT Flags;
#define SE_ADT_OBJECT_ONLY 0x1
    USHORT Level;
    ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {

    SE_ADT_PARAMETER_TYPE Type;
    ULONG Length;
    ULONG_PTR Data[2];
    PVOID Address;

} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;



//
// Structure that will be passed between the Reference Monitor and LSA
// to transmit auditing information.
//

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

typedef struct _SE_ADT_PARAMETER_ARRAY {

    ULONG CategoryId;
    ULONG AuditId;
    ULONG ParameterCount;
    ULONG Length;
    USHORT FlatSubCategoryId;
    USHORT Type;
    ULONG Flags;
    SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];

} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;


#define SE_ADT_PARAMETERS_SELF_RELATIVE     0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA       0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT   0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT      0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS  0x00000010


//
// This macro only existed in longhorn and after
//

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(AuditParameters)    \
     ( sizeof(SE_ADT_PARAMETER_ARRAY) -                           \
       sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) *                     \
       (SE_MAX_AUDIT_PARAMETERS - AuditParameters->ParameterCount) )

#endif // _NTLSA_AUDIT_


#endif // _NTLSA_IFS_
// end_ntsecapi

#ifndef _RTL_RUN_ONCE_DEF
#define _RTL_RUN_ONCE_DEF

//
// Run once
//

#define RTL_RUN_ONCE_INIT {0}   // Static initializer

//
// Run once flags
//

#define RTL_RUN_ONCE_CHECK_ONLY     0x00000001UL
#define RTL_RUN_ONCE_ASYNC          0x00000002UL
#define RTL_RUN_ONCE_INIT_FAILED    0x00000004UL

//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//

#define RTL_RUN_ONCE_CTX_RESERVED_BITS 2

typedef union _RTL_RUN_ONCE {       
    PVOID Ptr;                      
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;     

typedef
ULONG /* LOGICAL */
(NTAPI *PRTL_RUN_ONCE_INIT_FN) (
    __inout PRTL_RUN_ONCE RunOnce,
    __inout_opt PVOID Parameter,
    __deref_opt_out_opt PVOID *Context
    );

#endif // _RTL_RUN_ONCE_DEF

#if (NTDDI_VERSION >= NTDDI_LONGHORN)

NTSYSAPI
VOID
NTAPI
RtlRunOnceInitialize (
    __out PRTL_RUN_ONCE RunOnce
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlRunOnceExecuteOnce (
    __inout PRTL_RUN_ONCE RunOnce,
    __in __callback PRTL_RUN_ONCE_INIT_FN InitFn,
    __inout_opt PVOID Parameter,
    __deref_opt_out_opt PVOID *Context
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlRunOnceBeginInitialize (
    __inout PRTL_RUN_ONCE RunOnce,
    __in ULONG Flags,
    __deref_opt_out_opt PVOID *Context
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlRunOnceComplete (
    __inout PRTL_RUN_ONCE RunOnce,
    __in ULONG Flags,
    __in_opt PVOID Context
    );

#endif // NTDDI_VERSION >= NTDDI_LONGHORN


#if defined (_MSC_VER) && ( _MSC_VER >= 900 )

PVOID
_ReturnAddress (
    VOID
    );

#pragma intrinsic(_ReturnAddress)

#endif

#if (defined(_M_AMD64) || defined(_M_IA64)) && !defined(_REALLY_GET_CALLERS_CALLER_)

#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;

#else

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );

#endif

#endif

//
// prototype for replaceable Stack Walker routine
//

typedef ULONG (NTAPI * PRTL_WALK_FRAME_CHAIN)(
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// Reserve byte 1 of the RtlWalkFrameChain flags for
// specifying a number of frames to skip.
//

#define RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT     8

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain (
    __out_ecount(Count - (Flags >> RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT)) PVOID *Callers,
    __in ULONG Count,
    __in ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlCharToInteger (
    PCSZ String,
    ULONG Base,
    PULONG Value
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlCopyString(
    PSTRING DestinationString,
    const STRING * SourceString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
CHAR
NTAPI
RtlUpperChar (
    CHAR Character
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
LONG
NTAPI
RtlCompareString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlUpperString(
    PSTRING DestinationString,
    const STRING * SourceString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    __in PCUNICODE_STRING String1,
    __in PCUNICODE_STRING String2,
    __in BOOLEAN CaseInSensitive
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    __inout PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif

#if !defined(MIDL_PASS)
#if defined(_AMD64_) || defined(_IA64_)
//
// Large Integer divide - 64-bits / 64-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder OPTIONAL
    )
{
    LARGE_INTEGER Quotient;

    Quotient.QuadPart = Dividend.QuadPart / Divisor.QuadPart;
    if (ARGUMENT_PRESENT(Remainder)) {
        Remainder->QuadPart = Dividend.QuadPart % Divisor.QuadPart;
    }

    return Quotient;
}

#else
//
// Large Integer divide - 64-bits / 64-bits -> 64-bits
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );
#endif

#endif // defined(_AMD64_) || defined(_IA64_)
#endif // !defined(MIDL_PASS)


//
// BOOLEAN
// RtlEqualLuid(
//      PLUID L1,
//      PLUID L2
//      );

#define RtlEqualLuid(L1, L2) (((L1)->LowPart == (L2)->LowPart) && \
                              ((L1)->HighPart  == (L2)->HighPart))

//
// BOOLEAN
// RtlIsZeroLuid(
//      PLUID L1
//      );
//
#define RtlIsZeroLuid(L1) ((BOOLEAN) (((L1)->LowPart | (L1)->HighPart) == 0))



#if !defined(MIDL_PASS)

FORCEINLINE
LUID
NTAPI_INLINE
RtlConvertLongToLuid(
    LONG Long
    )
{
    LUID TempLuid;
    LARGE_INTEGER TempLi;

    TempLi.QuadPart = Long;
    TempLuid.LowPart = TempLi.u.LowPart;
    TempLuid.HighPart = TempLi.u.HighPart;
    return(TempLuid);
}

FORCEINLINE
LUID
NTAPI_INLINE
RtlConvertUlongToLuid(
    ULONG Ulong
    )
{
    LUID TempLuid;

    TempLuid.LowPart = Ulong;
    TempLuid.HighPart = 0;
    return(TempLuid);
}
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    PACCESS_MASK AccessMask,
    PGENERIC_MAPPING GenericMapping
    );
#endif

//
// Routine for converting from a volume device object to a DOS name.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );
#endif

typedef struct _OSVERSIONINFOA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif // UNICODE

typedef struct _OSVERSIONINFOEXA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
#ifdef UNICODE
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#endif // UNICODE

//
// RtlVerifyVersionInfo() conditions
//

#define VER_EQUAL                       1
#define VER_GREATER                     2
#define VER_GREATER_EQUAL               3
#define VER_LESS                        4
#define VER_LESS_EQUAL                  5
#define VER_AND                         6
#define VER_OR                          7

#define VER_CONDITION_MASK              7
#define VER_NUM_BITS_PER_CONDITION_MASK 3

//
// RtlVerifyVersionInfo() type mask bits
//

#define VER_MINORVERSION                0x0000001
#define VER_MAJORVERSION                0x0000002
#define VER_BUILDNUMBER                 0x0000004
#define VER_PLATFORMID                  0x0000008
#define VER_SERVICEPACKMINOR            0x0000010
#define VER_SERVICEPACKMAJOR            0x0000020
#define VER_SUITENAME                   0x0000040
#define VER_PRODUCT_TYPE                0x0000080

//
// RtlVerifyVersionInfo() os product type values
//

#define VER_NT_WORKSTATION              0x0000001
#define VER_NT_DOMAIN_CONTROLLER        0x0000002
#define VER_NT_SERVER                   0x0000003

//
// dwPlatformId defines:
//

#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2


//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//

#define VER_SET_CONDITION(_m_,_t_,_c_)  \
        ((_m_)=VerSetConditionMask((_m_),(_t_),(_c_)))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONGLONG
NTAPI
VerSetConditionMask(
        IN  ULONGLONG   ConditionMask,
        IN  ULONG   TypeMask,
        IN  UCHAR   Condition
        );
#endif

//

//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
    OUT PRTL_OSVERSIONINFOW lpVersionInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlVerifyVersionInfo(
    IN PRTL_OSVERSIONINFOEXW VersionInfo,
    IN ULONG TypeMask,
    IN ULONGLONG  ConditionMask
    );
#endif

NTSYSAPI
ULONG
NTAPI
DbgPrompt (
    __in PCCH Prompt,
    __out_bcount(Length) PCH Response,
    __in ULONG Length
    );

//

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTSYSAPI
BOOLEAN
NTAPI
RtlGetProductInfo(
    __in  ULONG  OSMajorVersion,
    __in  ULONG  OSMinorVersion,
    __in  ULONG  SpMajorVersion,
    __in  ULONG  SpMinorVersion,
    __out PULONG ReturnedProductType
    );

#endif

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Macro to extract buffering method out of the device io control code
//
#define METHOD_FROM_CTL_CODE(ctrlCode)          ((ULONG)(ctrlCode & 3))

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define some easier to comprehend aliases:
//   METHOD_DIRECT_TO_HARDWARE (writes, aka METHOD_IN_DIRECT)
//   METHOD_DIRECT_FROM_HARDWARE (reads, aka METHOD_OUT_DIRECT)
//

#define METHOD_DIRECT_TO_HARDWARE       METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE     METHOD_OUT_DIRECT

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe


//
// The FILE_EXPECT flags will only exist for WinXP. After that they will be
// ignored and an IRP will be sent in their place.
//
#define FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL     0x00000200
#define FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL    0x00000300
#define FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK        0x00000300

//
// flags specified here will be propagated up and down a device stack
// after FDO and all filter devices are added, but before the device
// stack is started
//

#define FILE_CHARACTERISTICS_PROPAGATED (   FILE_REMOVABLE_MEDIA   | \
                                            FILE_READ_ONLY_DEVICE  | \
                                            FILE_FLOPPY_DISKETTE   | \
                                            FILE_WRITE_ONCE_MEDIA  | \
                                            FILE_DEVICE_SECURE_OPEN  )


typedef struct _FILE_ALIGNMENT_INFORMATION {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

//
// This is also used for FileNormalizedNameInformation
//

typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

//
// NtQuery[Set]VolumeInformationFile types:
//
//  FILE_FS_LABEL_INFORMATION
//  FILE_FS_VOLUME_INFORMATION
//  FILE_FS_SIZE_INFORMATION
//  FILE_FS_DEVICE_INFORMATION
//  FILE_FS_ATTRIBUTE_INFORMATION
//  FILE_FS_CONTROL_INFORMATION
//  FILE_FS_OBJECTID_INFORMATION
//

typedef struct _FILE_FS_LABEL_INFORMATION {
    ULONG VolumeLabelLength;
    WCHAR VolumeLabel[1];
} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BOOLEAN SupportsObjects;
    WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_FS_SIZE_INFORMATION {
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER AvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;

typedef struct _FILE_FS_FULL_SIZE_INFORMATION {
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER CallerAvailableAllocationUnits;
    LARGE_INTEGER ActualAvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;

typedef struct _FILE_FS_OBJECTID_INFORMATION {
    UCHAR ObjectId[16];
    UCHAR ExtendedInfo[48];
} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;


//
// Define segement buffer structure for scatter/gather read/write.
//

typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;

//
// AVIO IOCTLS.
//

#define IOCTL_AVIO_ALLOCATE_STREAM      CTL_CODE(FILE_DEVICE_AVIO, 1, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_AVIO_FREE_STREAM          CTL_CODE(FILE_DEVICE_AVIO, 2, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_AVIO_MODIFY_STREAM        CTL_CODE(FILE_DEVICE_AVIO, 3, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)


//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

typedef struct _KEY_NAME_INFORMATION {
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

typedef struct _KEY_CACHED_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    ULONG   NameLength;
} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;

#define     REG_KEY_DONT_JOURNAL        1
#define     REG_KEY_DONT_VIRTUALIZE     2
#define     REG_KEY_DONT_SILENT_FAIL    4
#define     REG_KEY_RECURSE_FLAG        8

typedef struct _KEY_FLAGS_INFORMATION {
    ULONG   Wow64Flags;
    ULONG   KeyFlags;           // LSB bit set --> Key is Volatile
                                // second to LSB bit set --> Key is symlink

    ULONG   ControlFlags;       // combination of the above flags
} KEY_FLAGS_INFORMATION, *PKEY_FLAGS_INFORMATION;

typedef struct _KEY_VIRTUALIZATION_INFORMATION {
    ULONG   VirtualizationCandidate : 1; // Tells whether the key is part of the virtualization namespace scope (only HKLM\Software for now)
    ULONG   VirtualizationEnabled   : 1; // Tells whether virtualization is enabled on this key. Can be 1 only if above flag is 1.
    ULONG   VirtualTarget           : 1; // Tells if the key is a virtual key. Can be 1 only if above 2 are 0. Valid only on the virtual store key handles.
    ULONG   VirtualStore            : 1; // Tells if the key is a part of the virtual sore path. Valid only on the virtual store key handles.
    ULONG   VirtualSource           : 1; // Tells if the key has ever been virtualized, Can be 1 only if VirtualizationCandidate is 1
    ULONG   Reserved                : 27;   
} KEY_VIRTUALIZATION_INFORMATION, *PKEY_VIRTUALIZATION_INFORMATION;

//
// Thread Environment Block (and portable part of Thread Information Block)
//

//
//  NT_TIB - Thread Information Block - Portable part.
//
//      This is the subsystem portable part of the Thread Information Block.
//      It appears as the first part of the TEB for all threads which have
//      a user mode component.
//
//



typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
#if defined(_MSC_EXTENSIONS)
    union {
        PVOID FiberData;
        ULONG Version;
    };
#else
    PVOID FiberData;
#endif
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;

//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    ULONG ExceptionList;
    ULONG StackBase;
    ULONG StackLimit;
    ULONG SubSystemTib;
#if defined(_MSC_EXTENSIONS)
    union {
        ULONG FiberData;
        ULONG Version;
    };
#else
    ULONG FiberData;
#endif
    ULONG ArbitraryUserPointer;
    ULONG Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    ULONG64 ExceptionList;
    ULONG64 StackBase;
    ULONG64 StackLimit;
    ULONG64 SubSystemTib;
#if defined(_MSC_EXTENSIONS)
    union {
        ULONG64 FiberData;
        ULONG Version;
    };
#else
    ULONG64 FiberData;
#endif
    ULONG64 ArbitraryUserPointer;
    ULONG64 Self;
} NT_TIB64, *PNT_TIB64;

//
// Process Information Classes
//

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
    ProcessDeviceMap,
    ProcessSessionInformation,
    ProcessForegroundInformation,
    ProcessWow64Information,
    ProcessImageFileName,
    ProcessLUIDDeviceMapsEnabled,
    ProcessBreakOnTermination,
    ProcessDebugObjectHandle,
    ProcessDebugFlags,
    ProcessHandleTracing,
    ProcessIoPriority,
    ProcessExecuteFlags,
    ProcessTlsInformation,
    ProcessCookie,
    ProcessImageInformation,
    ProcessCycleTime,
    ProcessPagePriority,
    ProcessInstrumentationCallback,
    ProcessThreadStackAllocation,
    ProcessWorkingSetWatchEx,
    ProcessImageFileNameWin32,
    ProcessImageFileMapping,
    ProcessAffinityUpdateMode,
    ProcessMemoryAllocationMode,
    MaxProcessInfoClass             // MaxProcessInfoClass should always be the last enum
} PROCESSINFOCLASS;

//
// Thread Information Classes
//

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair_Reusable,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,   // Obsolete
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    ThreadBreakOnTermination,
    ThreadSwitchLegacyState,
    ThreadIsTerminated,
    ThreadLastSystemCall,
    ThreadIoPriority,
    ThreadCycleTime,
    ThreadPagePriority,
    ThreadActualBasePriority,
    ThreadTebInformation,
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    MaxThreadInfoClass
} THREADINFOCLASS;

#define THREAD_CSWITCH_PMU_DISABLE  FALSE
#define THREAD_CSWITCH_PMU_ENABLE   TRUE

//
// Process Information Structures
//

//
// Working set page priority information.
// Used with ProcessPagePriority and ThreadPagePriority
//

typedef struct _PAGE_PRIORITY_INFORMATION {
    ULONG PagePriority;
} PAGE_PRIORITY_INFORMATION, *PPAGE_PRIORITY_INFORMATION;

//
// PageFaultHistory Information
//  NtQueryInformationProcess using ProcessWorkingSetWatch
//
typedef struct _PROCESS_WS_WATCH_INFORMATION {
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;

//
// Basic and Extended Basic Process Information
//  NtQueryInformationProcess using ProcessBasicInformation
//

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION,*PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION {
    SIZE_T Size;    // Must be set to structure size on input
    PROCESS_BASIC_INFORMATION BasicInfo;
    union {
        ULONG Flags;
        struct {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG SpareBits : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;


//
// Process Device Map information
//  NtQueryInformationProcess using ProcessDeviceMap
//  NtSetInformationProcess using ProcessDeviceMap
//

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[ 32 ];
        } Query;
    } DUMMYUNIONNAME;
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

typedef struct _PROCESS_DEVICEMAP_INFORMATION_EX {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[ 32 ];
        } Query;
    } DUMMYUNIONNAME;
    ULONG Flags;    // specifies that the query type
} PROCESS_DEVICEMAP_INFORMATION_EX, *PPROCESS_DEVICEMAP_INFORMATION_EX;

//
// PROCESS_DEVICEMAP_INFORMATION_EX flags
//
#define PROCESS_LUID_DOSDEVICES_ONLY 0x00000001

//
// Multi-User Session specific Process Information
//  NtQueryInformationProcess using ProcessSessionInformation
//

typedef struct _PROCESS_SESSION_INFORMATION {
    ULONG SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;

typedef struct _PROCESS_HANDLE_TRACING_ENABLE {
    ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, *PPROCESS_HANDLE_TRACING_ENABLE;

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
    ULONG Flags;
    ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, *PPROCESS_HANDLE_TRACING_ENABLE_EX;


#define PROCESS_HANDLE_TRACING_MAX_STACKS 16

typedef struct _PROCESS_HANDLE_TRACING_ENTRY {
    HANDLE Handle;
    CLIENT_ID ClientId;
    ULONG Type;
    PVOID Stacks[PROCESS_HANDLE_TRACING_MAX_STACKS];
} PROCESS_HANDLE_TRACING_ENTRY, *PPROCESS_HANDLE_TRACING_ENTRY;

typedef struct _PROCESS_HANDLE_TRACING_QUERY {
    HANDLE Handle;
    ULONG  TotalTraces;
    PROCESS_HANDLE_TRACING_ENTRY HandleTrace[1];
} PROCESS_HANDLE_TRACING_QUERY, *PPROCESS_HANDLE_TRACING_QUERY;

//
// Process Quotas
//  NtQueryInformationProcess using ProcessQuotaLimits
//  NtQueryInformationProcess using ProcessPooledQuotaLimits
//  NtSetInformationProcess using ProcessQuotaLimits
//



typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;

#define QUOTA_LIMITS_HARDWS_MIN_ENABLE  0x00000001
#define QUOTA_LIMITS_HARDWS_MIN_DISABLE 0x00000002
#define QUOTA_LIMITS_HARDWS_MAX_ENABLE  0x00000004
#define QUOTA_LIMITS_HARDWS_MAX_DISABLE 0x00000008
#define QUOTA_LIMITS_USE_DEFAULT_LIMITS 0x00000010

typedef union _RATE_QUOTA_LIMIT {
    ULONG RateData;
    struct {
        ULONG RatePercent : 7;
        ULONG Reserved0   : 25;
    } DUMMYSTRUCTNAME;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;               // Limit expressed in pages
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit;             // Limit expressed in pages
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    ULONG  Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;



//
// Process I/O Counters
//  NtQueryInformationProcess using ProcessIoCounters
//


typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;



//
// Process Virtual Memory Counters
//  NtQueryInformationProcess using ProcessVmCounters
//

typedef struct _VM_COUNTERS {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} VM_COUNTERS;
typedef VM_COUNTERS *PVM_COUNTERS;

typedef struct _VM_COUNTERS_EX {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} VM_COUNTERS_EX;
typedef VM_COUNTERS_EX *PVM_COUNTERS_EX;

//
// Process Pooled Quota Usage and Limits
//  NtQueryInformationProcess using ProcessPooledUsageAndLimits
//

typedef struct _POOLED_USAGE_AND_LIMITS {
    SIZE_T PeakPagedPoolUsage;
    SIZE_T PagedPoolUsage;
    SIZE_T PagedPoolLimit;
    SIZE_T PeakNonPagedPoolUsage;
    SIZE_T NonPagedPoolUsage;
    SIZE_T NonPagedPoolLimit;
    SIZE_T PeakPagefileUsage;
    SIZE_T PagefileUsage;
    SIZE_T PagefileLimit;
} POOLED_USAGE_AND_LIMITS;
typedef POOLED_USAGE_AND_LIMITS *PPOOLED_USAGE_AND_LIMITS;

//
// Process Security Context Information
//  NtSetInformationProcess using ProcessAccessToken
// PROCESS_SET_ACCESS_TOKEN access to the process is needed
// to use this info level.
//

typedef struct _PROCESS_ACCESS_TOKEN {

    //
    // Handle to Primary token to assign to the process.
    // TOKEN_ASSIGN_PRIMARY access to this token is needed.
    //

    HANDLE Token;

    //
    // Handle to the initial thread of the process.
    // A process's access token can only be changed if the process has
    // no threads or a single thread that has not yet begun execution.
    //
    // N.B. This field is unused.
    //

    HANDLE Thread;

} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

//
// Process Exception Port Information
//  NtSetInformationProcess using ProcessExceptionPort
// PROCESS_SET_PORT access to the process is needed
// to use this info level.
//

#define PROCESS_EXCEPTION_PORT_ALL_STATE_BITS     0x00000003UL
#define PROCESS_EXCEPTION_PORT_ALL_STATE_FLAGS    ((ULONG_PTR)((1UL << PROCESS_EXCEPTION_PORT_ALL_STATE_BITS) - 1))

typedef struct _PROCESS_EXCEPTION_PORT {

    //
    // Handle to the exception port. No particular access required.
    //

    IN HANDLE ExceptionPortHandle;

    //
    // Miscellaneous state flags to be cached along with the exception
    // port in the kernel.
    //

    IN OUT ULONG StateFlags;

} PROCESS_EXCEPTION_PORT, *PPROCESS_EXCEPTION_PORT;

//
// Process/Thread System and User Time
//  NtQueryInformationProcess using ProcessTimes
//  NtQueryInformationThread using ThreadTimes
//

typedef struct _KERNEL_USER_TIMES {
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES;
typedef KERNEL_USER_TIMES *PKERNEL_USER_TIMES;


__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess (
    __out PHANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PCLIENT_ID ClientId
    );


__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess (
    __in HANDLE ProcessHandle,
    __in PROCESSINFOCLASS ProcessInformationClass,
    __out_bcount_opt(ProcessInformationLength) PVOID ProcessInformation,
    __in ULONG ProcessInformationLength,
    __out_opt PULONG ReturnLength
    );

#define NTKERNELAPI DECLSPEC_IMPORT     

#if defined(_X86_)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );
#endif


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)



#define KeQueryTickCount(CurrentCount) { \
    KSYSTEM_TIME volatile *_TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    for (;;) {                                                              \
        (CurrentCount)->HighPart = _TickCount->High1Time;                   \
        (CurrentCount)->LowPart = _TickCount->LowPart;                      \
        if ((CurrentCount)->HighPart == _TickCount->High2Time) break;       \
        YieldProcessor();                                                   \
    }                                                                       \
}



#else


VOID
NTAPI
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)



//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// Certain fields in the TIB are not used in kernel mode. These include the
// stack limit, subsystem TIB, fiber data, arbitrary user pointer, and the
// self address of then PCR itself (another field has been added for that
// purpose). Therefore, these fields are overlaid with other data to get
// better cache locality.
//

    union {
        NT_TIB  NtTib;
        struct {
            struct _EXCEPTION_REGISTRATION_RECORD *Used_ExceptionList;
            PVOID Used_StackBase;
            PVOID Spare2;
            PVOID TssCopy;
            ULONG ContextSwitches;
            KAFFINITY SetMemberCopy;
            PVOID Used_Self;
        };
    };

    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;                       // do not use 3 bytes after this as
                                        // HALs assume they are zero.
    ULONG   IRR;
    ULONG   IrrActive;
    ULONG   IDR;
    PVOID   KdVersionBlock;

    struct _KIDTENTRY *IDT;
    struct _KGDTENTRY *GDT;
    struct _KTSS      *TSS;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    KAFFINITY SetMember;
    ULONG   StallScaleFactor;
    UCHAR   SpareUnused;
    UCHAR   Number;



    UCHAR   Spare0;
    UCHAR   SecondLevelCacheAssociativity;
    ULONG   VdmAlert;
    ULONG   KernelReserved[14];         // For use by the kernel
    ULONG   SecondLevelCacheSize;
    ULONG   HalReserved[16];            // For use by Hal


} KPCR, *PKPCR;

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT_X86    22
#define PDI_SHIFT_X86PAE 21

#if !defined (_X86PAE_)
#define PDI_SHIFT PDI_SHIFT_X86
#else
#define PDI_SHIFT PDI_SHIFT_X86PAE
#define PPI_SHIFT 30
#endif

#define GUARD_PAGE_SIZE   (PAGE_SIZE * 1)

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define the highest user address and user probe address.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

#if defined(_LOCAL_COPY_USER_PROBE_ADDRESS_)

#define MM_USER_PROBE_ADDRESS _LOCAL_COPY_USER_PROBE_ADDRESS_

extern ULONG _LOCAL_COPY_USER_PROBE_ADDRESS_;

#else

#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#endif

#define MM_KSEG0_BASE       MM_SYSTEM_RANGE_START
#define MM_SYSTEM_SPACE_END 0xFFFFFFFF

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

//
// The lowest address for system space.
//

#if !defined (_X86PAE_)
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000
#else
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0C00000
#endif


//
// Prototypes for architectural specific versions of Exi386 Api
//

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedIncrementLong (
    IN LONG volatile *Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedDecrementLong (
    IN LONG volatile *Addend
    );

NTKERNELAPI
ULONG
FASTCALL
Exfi386InterlockedExchangeUlong (
    IN ULONG volatile *Target,
    IN ULONG Value
    );


//
// Turn these instrinsics off until the compiler can handle them
//

#if (_MSC_FULL_VER > 13009037)

LONG
_InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic(_InterlockedOr)

#define InterlockedOr _InterlockedOr
#define InterlockedOrAffinity InterlockedOr

LONG
_InterlockedAnd (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic(_InterlockedAnd)

#define InterlockedAnd _InterlockedAnd
#define InterlockedAndAffinity InterlockedAnd

LONG
_InterlockedXor (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic(_InterlockedXor)

#define InterlockedXor _InterlockedXor

#if !defined(_WINBASE_) && !defined(NONTOSPINTERLOCK)

FORCEINLINE
LONGLONG
_InterlockedAnd64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

#define InterlockedAnd64 _InterlockedAnd64

LONGLONG
FORCEINLINE
_InterlockedOr64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

#define InterlockedOr64 _InterlockedOr64

FORCEINLINE
LONGLONG
_InterlockedXor64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

#define InterlockedXor64 _InterlockedXor64

LONGLONG
FORCEINLINE
_InterlockedIncrement64 (
    IN OUT LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old + 1,
                                          Old) != Old);

    return Old + 1;
}

#define InterlockedIncrement64 _InterlockedIncrement64

FORCEINLINE
LONGLONG
_InterlockedDecrement64 (
    IN OUT LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old - 1,
                                          Old) != Old);

    return Old - 1;
}

#define InterlockedDecrement64 _InterlockedDecrement64

FORCEINLINE
LONGLONG
_InterlockedExchange64 (
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Target;
    } while (InterlockedCompareExchange64(Target,
                                          Value,
                                          Old) != Old);

    return Old;
}

#define InterlockedExchange64 _InterlockedExchange64

FORCEINLINE
LONGLONG
_InterlockedExchangeAdd64 (
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old + Value,
                                          Old) != Old);

    return Old;
}

#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64

#endif // !defined(_WINBASE_) && !defined(NONTOSPINTERLOCK)

#else // compiler version

FORCEINLINE
LONG
InterlockedAnd (
    IN OUT LONG volatile *Target,
    LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i & Set,
                                       i);

    } while (i != j);

    return j;
}

FORCEINLINE
LONG
InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i | Set,
                                       i);

    } while (i != j);

    return j;
}

#endif // compiler version


#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//



#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4035)               // re-enable below

#define _PCR   fs:[0]                   

//
// Get the current processor number
//

FORCEINLINE
ULONG
NTAPI
KeGetCurrentProcessorNumber(VOID)
{
#if (_MSC_FULL_VER >= 13012035)
    return (ULONG) __readfsbyte (FIELD_OFFSET (KPCR, Number));
#else
    __asm {  movzx eax, _PCR KPCR.Number  }
#endif
}


#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4035)
#endif


#endif // !defined(MIDL_PASS) && defined(_M_IX86)


#endif // defined(_X86_)


// Use the following for kernel mode runtime checks of X86 system architecture

#ifdef _X86_

#ifdef IsNEC_98
#undef IsNEC_98
#endif

#ifdef IsNotNEC_98
#undef IsNotNEC_98
#endif

#ifdef SetNEC_98
#undef SetNEC_98
#endif

#ifdef SetNotNEC_98
#undef SetNotNEC_98
#endif

#define IsNEC_98     (SharedUserData->AlternativeArchitecture == NEC98x86)
#define IsNotNEC_98  (SharedUserData->AlternativeArchitecture != NEC98x86)
#define SetNEC_98    SharedUserData->AlternativeArchitecture = NEC98x86
#define SetNotNEC_98 SharedUserData->AlternativeArchitecture = StandardDesign

#endif

#if defined(_AMD64_) 

//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// Certain fields in the TIB are not used in kernel mode. These include the
// exception list, stack base, stack limit, subsystem TIB, fiber data, and
// the arbitrary user pointer. Therefore, these fields are overlaid with
// other data to get better cache locality.
//
// N.B. The offset to the PRCB in the PCR is fixed for all time.
//

    union {
        NT_TIB NtTib;
        struct {
            union _KGDTENTRY64 *GdtBase;
            struct _KTSS64 *TssBase;
            ULONG64 UserRsp;
            struct _KPCR *Self;
            struct _KPRCB *CurrentPrcb;
            PKSPIN_LOCK_QUEUE LockArray;
            PVOID Used_Self;
        };
    };

    union _KIDTENTRY64 *IdtBase;
    ULONG64 Unused[2];
    KIRQL Irql;
    UCHAR SecondLevelCacheAssociativity;
    UCHAR ObsoleteNumber;
    UCHAR Fill0;
    ULONG Unused0[3];
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONG StallScaleFactor;
    PVOID Unused1[3];

    ULONG KernelReserved[15];
    ULONG SecondLevelCacheSize;
    ULONG HalReserved[16];
    ULONG Unused2;
    PVOID KdVersionBlock;
    PVOID Unused3;
    ULONG PcrAlign1[24];


} KPCR, *PKPCR;

//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all nonvolatile registers. The volatile registers will already
//  have been saved in a trap frame.
//
// N.B. The exception frame has a built in exception record capable of
//      storing information for four parameter values. This exception
//      record is used exclusively within the trap handling code.
//

typedef struct _KEXCEPTION_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Kernel callout initial stack value.
//

    ULONG64 InitialStack;

//
// Saved nonvolatile floating registers.
//

    M128A Xmm6;
    M128A Xmm7;
    M128A Xmm8;
    M128A Xmm9;
    M128A Xmm10;
    M128A Xmm11;
    M128A Xmm12;
    M128A Xmm13;
    M128A Xmm14;
    M128A Xmm15;

//
// Kernel callout frame variables.
//

    ULONG64 TrapFrame;
    ULONG64 CallbackStack;
    ULONG64 OutputBuffer;
    ULONG64 OutputLength;

//
// Saved MXCSR when a thread is interrupted in kernel mode via a dispatch
// interrupt.
//

    ULONG64 MxCsr;

//
// Saved nonvolatile register - not always saved.
//

    ULONG64 Rbp;

//
// Saved nonvolatile registers.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;
    ULONG64 R12;
    ULONG64 R13;
    ULONG64 R14;
    ULONG64 R15;

//
// EFLAGS and return address.
//

    ULONG64 Return;
} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;

//
// Trap frame
//
// This frame is established when handling a trap. It provides a place to
// save all volatile registers. The nonvolatile registers are saved in an
// exception frame or through the normal C calling conventions for saved
// registers.
//

typedef struct _KTRAP_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Previous processor mode (system services only) and previous IRQL
// (interrupts only).
//

    KPROCESSOR_MODE PreviousMode;
    KIRQL PreviousIrql;

//
// Page fault load/store indicator.
//

    UCHAR FaultIndicator;

//
// Exception active indicator.
//
//    0 - interrupt frame.
//    1 - exception frame.
//    2 - service frame.
//

    UCHAR ExceptionActive;

//
// Floating point state.
//

    ULONG MxCsr;

//
//  Volatile registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;

//
// Gsbase is only used if the previous mode was kernel.
//
// GsSwap is only used if the previous mode was user.
//

    union {
        ULONG64 GsBase;
        ULONG64 GsSwap;
    };

//
// Volatile floating registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    M128A Xmm0;
    M128A Xmm1;
    M128A Xmm2;
    M128A Xmm3;
    M128A Xmm4;
    M128A Xmm5;

//
// First parameter, page fault address, context record address if user APC
// bypass, or time stamp value.
//

    union {
        ULONG64 FaultAddress;
        ULONG64 ContextRecord;
        ULONG64 TimeStampCKCL;
    };

//
//  Debug registers.
//

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

//
// Special debug registers.
//
// N.B. Either AMD64 or EM64T information is stored in the following locations.

    union {
        struct {
            ULONG64 DebugControl;
            ULONG64 LastBranchToRip;
            ULONG64 LastBranchFromRip;
            ULONG64 LastExceptionToRip;
            ULONG64 LastExceptionFromRip;
        };

        struct {
            ULONG64 LastBranchControl;
            ULONG LastBranchMSR;
        };
    };

//
//  Segment registers
//

    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;

//
// Previous trap frame address.
//

    ULONG64 TrapFrame;

//
// Saved nonvolatile registers RBX, RDI and RSI. These registers are only
// saved in system service trap frames.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;

//
// Saved nonvolatile register RBP. This register is used as a frame
// pointer during trap processing and is saved in all trap frames.
//

    ULONG64 Rbp;

//
// Information pushed by hardware.
//
// N.B. The error code is not always pushed by hardware. For those cases
//      where it is not pushed by hardware a dummy error code is allocated
//      on the stack.
//

    union {
        ULONG64 ErrorCode;
        ULONG64 ExceptionFrame;
        ULONG64 TimeStampKlog;
    };

    ULONG64 Rip;
    USHORT SegCs;
    UCHAR Fill0;
    UCHAR Logging;
    USHORT Fill1[2];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3;

//
// Copy of the global patch cycle at the time of the fault. Filled in by the
// invalid opcode and general protection fault routines.
//

    LONG CodePatchCycle;
} KTRAP_FRAME, *PKTRAP_FRAME;


#define PXE_BASE          0xFFFFF6FB7DBED000UI64
#define PXE_SELFMAP       0xFFFFF6FB7DBEDF68UI64
#define PPE_BASE          0xFFFFF6FB7DA00000UI64
#define PDE_BASE          0xFFFFF6FB40000000UI64
#define PTE_BASE          0xFFFFF68000000000UI64

#define PXE_TOP           0xFFFFF6FB7DBEDFFFUI64
#define PPE_TOP           0xFFFFF6FB7DBFFFFFUI64
#define PDE_TOP           0xFFFFF6FB7FFFFFFFUI64
#define PTE_TOP           0xFFFFF6FFFFFFFFFFUI64

#define PDE_KTBASE_AMD64  PPE_BASE

#define PTI_SHIFT 12
#define PDI_SHIFT 21
#define PPI_SHIFT 30
#define PXI_SHIFT 39

#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PXE_PER_PAGE 512

#define PTI_MASK_AMD64 (PTE_PER_PAGE - 1)
#define PDI_MASK_AMD64 (PDE_PER_PAGE - 1)
#define PPI_MASK (PPE_PER_PAGE - 1)
#define PXI_MASK (PXE_PER_PAGE - 1)

#define GUARD_PAGE_SIZE (PAGE_SIZE * 2)

//
// Define the last branch control MSR address.
//

extern NTKERNELAPI ULONG KeLastBranchMSR;

//
// Define the highest user address and user probe address.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG64 MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

//
// Allow non-kernel components to capture the user probe address and use a
// local copy for efficiency.
//

#if defined(_LOCAL_COPY_USER_PROBE_ADDRESS_)

#define MM_USER_PROBE_ADDRESS _LOCAL_COPY_USER_PROBE_ADDRESS_

extern ULONG64 _LOCAL_COPY_USER_PROBE_ADDRESS_;

#else

#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#endif

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)(LONG_PTR)0x10000

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xFFFF080000000000


//
// Intrinsic functions
//

#if defined(_M_AMD64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)

//
// The following routines are provided for backward compatibility with old
// code. They are no longer the preferred way to accomplish these functions.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

#define ExInterlockedDecrementLong(Addend, Lock)                            \
    _ExInterlockedDecrementLong(Addend)

__forceinline
LONG
_ExInterlockedDecrementLong (
    IN OUT PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedDecrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedIncrementLong(Addend, Lock)                            \
    _ExInterlockedIncrementLong(Addend)

__forceinline
LONG
_ExInterlockedIncrementLong (
    IN OUT PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedIncrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedExchangeUlong(Target, Value, Lock)                     \
    _ExInterlockedExchangeUlong(Target, Value)

__forceinline
ULONG
_ExInterlockedExchangeUlong (
    IN OUT PULONG Target,
    IN ULONG Value
    )

{

    return (ULONG)InterlockedExchange((PLONG)Target, (LONG)Value);
}

#endif // defined(_M_AMD64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)


#if !defined(MIDL_PASS) && defined(_M_AMD64)

//
// AMD646 function prototype definitions
//


//
// Get address of current processor block.
//

__forceinline
PKPCR
KeGetPcr (
    VOID
    )

{
    return (PKPCR)__readgsqword(FIELD_OFFSET(KPCR, Self));
}


//
// Get the current processor number
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
__forceinline
ULONG
KeGetCurrentProcessorNumber (
    VOID
    )

{

    return (ULONG)__readgsword(0x184);
}

#else

__forceinline
ULONG
KeGetCurrentProcessorNumber (
    VOID
    )

{

    return (ULONG)__readgsbyte(0x184);
}
#endif


#endif // !defined(MIDL_PASS) && defined(_M_AMD64)


#endif // defined(_AMD64_)


//
// Platform specific kernel fucntions to raise and lower IRQL.
//


#if defined(_AMD64_) && !defined(MIDL_PASS)

__forceinline
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to DPC_LEVEL and returns the
    previous IRQL.

Arguments:

    None.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    return KfRaiseIrql(DISPATCH_LEVEL);
}

__forceinline
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to SYNCH_LEVEL and returns the
    previous IRQL.

Arguments:

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    return KfRaiseIrql(12);
}


#endif // defined(_AMD64_) && !defined(MIDL_PASS)


#if defined(_IA64_)

//
// IA64 specific interlocked operation result values.
//

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for values are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

//
// Convert portable interlock interfaces to architecture specific interfaces.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend, Lock) \
    ExIa64InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend, Lock) \
    ExIa64InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target, Value, Lock) \
    ExIa64InterlockedExchangeUlong(Target, Value)

NTKERNELAPI
INTERLOCKED_RESULT
ExIa64InterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
ExIa64InterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
ExIa64InterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

//
// Get address of processor control region.
//

#define KeGetPcr() PCR

//
// Get address of current kernel thread object.
//

#if defined(_M_IA64)
#define KeGetCurrentThread() PCR->CurrentThread
#endif

//
// Get current processor number.
//

#define KeGetCurrentProcessorNumber() ((ULONG)(PCR->Number))

//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() PCR->DcacheFillSize

//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all preserved registers. The volatile registers will already
//  have been saved in a trap frame. Also used as part of switch frame built
//  at thread switch.
//
//  The frame is 16-byte aligned to maintain 16-byte alignment for the stack,
//

typedef struct _KEXCEPTION_FRAME {


    // Preserved application registers
    ULONGLONG ApEC;       // epilogue count
    ULONGLONG ApLC;       // loop count
    ULONGLONG IntNats;    // Nats for S0-S3; i.e. ar.UNAT after spill

    // Preserved (saved) interger registers, s0-s3
    ULONGLONG IntS0;
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;

    // Preserved (saved) branch registers, bs0-bs4
    ULONGLONG BrS0;
    ULONGLONG BrS1;
    ULONGLONG BrS2;
    ULONGLONG BrS3;
    ULONGLONG BrS4;

    // Preserved (saved) floating point registers, f2 - f5, f16 - f31
    FLOAT128 FltS0;
    FLOAT128 FltS1;
    FLOAT128 FltS2;
    FLOAT128 FltS3;
    FLOAT128 FltS4;
    FLOAT128 FltS5;
    FLOAT128 FltS6;
    FLOAT128 FltS7;
    FLOAT128 FltS8;
    FLOAT128 FltS9;
    FLOAT128 FltS10;
    FLOAT128 FltS11;
    FLOAT128 FltS12;
    FLOAT128 FltS13;
    FLOAT128 FltS14;
    FLOAT128 FltS15;
    FLOAT128 FltS16;
    FLOAT128 FltS17;
    FLOAT128 FltS18;
    FLOAT128 FltS19;


} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;

//
// Trap frame
//  This frame is established when handling a trap. It provides a place to
//  save all volatile registers. The nonvolatile registers are saved in an
//  exception frame or through the normal C calling conventions for saved
//  registers.  Its size must be a multiple of 16 bytes.
//
//  N.B - the 16-byte alignment is required to maintain the stack alignment.
//

#define KTRAP_FRAME_ARGUMENTS (8 * 8)       // up to 8 in-memory syscall args


typedef struct _KTRAP_FRAME {

    //
    // Reserved for additional memory arguments and stack scratch area
    // The size of Reserved[] must be a multiple of 16 bytes.
    //

    ULONGLONG Reserved[(KTRAP_FRAME_ARGUMENTS+16)/8];

    // Temporary (volatile) FP registers - f6-f15 (don't use f32+ in kernel)
    FLOAT128 FltT0;
    FLOAT128 FltT1;
    FLOAT128 FltT2;
    FLOAT128 FltT3;
    FLOAT128 FltT4;
    FLOAT128 FltT5;
    FLOAT128 FltT6;
    FLOAT128 FltT7;
    FLOAT128 FltT8;
    FLOAT128 FltT9;

    // Temporary (volatile) interger registers
    ULONGLONG IntGp;    // global pointer (r1)
    ULONGLONG IntT0;
    ULONGLONG IntT1;
                        // The following 4 registers fill in space of preserved  (S0-S3) to align Nats
    ULONGLONG ApUNAT;   // ar.UNAT on kernel entry
    ULONGLONG ApCCV;    // ar.CCV
    ULONGLONG SegCSD;   // Second register for 16 byte values
    ULONGLONG Preds;    // Predicates

    ULONGLONG IntV0;    // return value (r8)
    ULONGLONG IntT2;
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;    // stack pointer (r12)
    ULONGLONG IntTeb;   // teb (r13)
    ULONGLONG IntT5;
    ULONGLONG IntT6;
    ULONGLONG IntT7;
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG IntNats;  // Temporary (volatile) registers' Nats directly from ar.UNAT at point of spill

    ULONGLONG BrRp;     // Return pointer on kernel entry

    ULONGLONG BrT0;     // Temporary (volatile) branch registers (b6-b7)
    ULONGLONG BrT1;

    // Register stack info
    ULONGLONG RsRSC;    // RSC on kernel entry
    ULONGLONG RsBSP;    // BSP on kernel entry
    ULONGLONG RsBSPSTORE; // User BSP Store at point of switch to kernel backing store
    ULONGLONG RsRNAT;   // old RNAT at point of switch to kernel backing store
    ULONGLONG RsPFS;    // PFS on kernel entry

    // Trap Status Information
    ULONGLONG StIPSR;   // Interruption Processor Status Register
    ULONGLONG StIIP;    // Interruption IP
    ULONGLONG StIFS;    // Interruption Function State
    ULONGLONG StFPSR;   // FP status
    ULONGLONG StISR;    // Interruption Status Register
    ULONGLONG StIFA;    // Interruption Data Address
    ULONGLONG StIIPA;   // Last executed bundle address
    ULONGLONG StIIM;    // Interruption Immediate
    ULONGLONG StIHA;    // Interruption Hash Address

    ULONG OldIrql;      // Previous Irql.
    ULONG PreviousMode; // Previous Mode.
    ULONGLONG TrapFrame;// Previous Trap Frame

    //
    // Exception record
    //
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD) + 15) & (~15)];

    // End of frame marker (for debugging)

    ULONGLONG NewBSP;  // NewBSP  When a stack switch occur this is the value of the new BSP
    ULONGLONG EOFMarker;

    ULONGLONG SegSSD;   // IA32 SSDescriptor (Ar26)

} KTRAP_FRAME, *PKTRAP_FRAME;

//
// OS_MCA, OS_INIT HandOff State definitions
//
// Note: The following definitions *must* match the definions of the
//       corresponding SAL Revision Hand-Off structures.
//

typedef struct _SAL_HANDOFF_STATE   {
    ULONGLONG     PalProcEntryPoint;
    ULONGLONG     SalProcEntryPoint;
    ULONGLONG     SalGlobalPointer;
     LONGLONG     RendezVousResult;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     MinStateSavePtr;
} SAL_HANDOFF_STATE, *PSAL_HANDOFF_STATE;

typedef struct _OS_HANDOFF_STATE    {
    ULONGLONG     Result;
    ULONGLONG     SalGlobalPointer;
    ULONGLONG     MinStateSavePtr;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     NewContextFlag;
} OS_HANDOFF_STATE, *POS_HANDOFF_STATE;

//
// per processor OS_MCA and OS_INIT resource structure
//


#define SER_EVENT_STACK_FRAME_ENTRIES    8

typedef struct _SAL_EVENT_RESOURCES {

    SAL_HANDOFF_STATE   SalToOsHandOff;
    OS_HANDOFF_STATE    OsToSalHandOff;
    PVOID               StateDump;
    ULONGLONG           StateDumpPhysical;
    PVOID               BackStore;
    ULONGLONG           BackStoreLimit;
    PVOID               Stack;
    ULONGLONG           StackLimit;
    PULONGLONG          PTOM;
    ULONGLONG           StackFrame[SER_EVENT_STACK_FRAME_ENTRIES];
    PVOID               EventPool;
    ULONG               EventPoolSize;
    ULONGLONG           PoisonPageAddress;
} SAL_EVENT_RESOURCES, *PSAL_EVENT_RESOURCES;

//
// Define Processor Control Region Structure.
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Major and minor version numbers of the PCR.
//
    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

//
// First and second level cache parameters.
//

    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;
    ULONG SecondLevelDcacheSize;
    ULONG SecondLevelDcacheFillSize;
    ULONG SecondLevelIcacheSize;
    ULONG SecondLevelIcacheFillSize;

//
// Data cache alignment and fill size used for cache flushing and alignment.
// These fields are set to the larger of the first and second level data
// cache fill sizes.
//

    ULONG DcacheAlignment;
    ULONG DcacheFillSize;

//
// Instruction cache alignment and fill size used for cache flushing and
// alignment. These fields are set to the larger of the first and second
// level data cache fill sizes.
//

    ULONG IcacheAlignment;
    ULONG IcacheFillSize;

//
// Processor identification from PrId register.
//

    ULONG ProcessorId;

//
// Profiling data.
//

    ULONG ProfileInterval;
    ULONG ProfileCount;

//
// Stall execution count and scale factor.
//

    ULONG StallExecutionCount;
    ULONG StallScaleFactor;

    ULONG InterruptionCount;

//
// Space reserved for the system.
//

    ULONGLONG   SystemReserved[6];

//
// Space reserved for the HAL
//

    ULONGLONG   HalReserved[64];

//
// IRQL mapping tables.
//

    UCHAR IrqlMask[64];
    UCHAR IrqlTable[64];

//
// External Interrupt vectors.
//

    PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];

//
// Reserved interrupt vector mask.
//

    ULONG ReservedVectors;

//
// Processor affinity mask.
//

    KAFFINITY SetMember;

//
// Complement of the processor affinity mask.
//

    KAFFINITY NotMember;

//
// Pointer to processor control block.
//

    struct _KPRCB *Prcb;

//
//  Shadow copy of Prcb->CurrentThread for fast access
//

    struct _KTHREAD *CurrentThread;

//
// Processor number.
//

    CCHAR Number;                        // Processor Number



    CCHAR PollSlot;                      // Used by the clock routine track when we should break in.
    UCHAR KernelDebugActive;             // debug register active in kernel flag
    UCHAR CurrentIrql;                   // Current IRQL
    union {
        USHORT SoftwareInterruptPending; // Software Interrupt Pending Flag
        struct {
            UCHAR ApcInterrupt;          // 0x01 if APC int pending
            UCHAR DispatchInterrupt;     // 0x01 if dispatch int pending
        };
    };

//
// Address of per processor SAPIC EOI Table
//

    PVOID       EOITable;

//
// IA-64 Machine Check Events trackers
//

    UCHAR       InOsMca;
    UCHAR       InOsInit;
    UCHAR       InOsCmc;
    UCHAR       InOsCpe;
    ULONG       InOsULONG_Spare; // Spare ULONG
    PSAL_EVENT_RESOURCES OsMcaResourcePtr;
    PSAL_EVENT_RESOURCES OsInitResourcePtr;

    UCHAR AlternateStack;
    UCHAR Pad[7];

//
// End of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//


} KPCR, *PKPCR;


NTKERNELAPI
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    );

NTKERNELAPI
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );


//
// The highest user address reserves 64K bytes for a guard page. This
// the probing of address from kernel mode to only have to check the
// starting address for structures of 64k bytes or less.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG_PTR MmUserProbeAddress;


#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

#define MM_KSEG0_BASE 0xE000000080000000UI64
#define MM_SYSTEM_SPACE_END (KADDRESS_BASE + 0x70000000000UI64)

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)((ULONG_PTR)(UADDRESS_BASE+0x00010000))

#endif // defined(_IA64_)

//
// Firmware Table provider definitions
//

typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION {
    SystemFirmwareTable_Enumerate,
    SystemFirmwareTable_Get
} SYSTEM_FIRMWARE_TABLE_ACTION;

typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    ULONG                           ProviderSignature;
    SYSTEM_FIRMWARE_TABLE_ACTION    Action;
    ULONG                           TableID;
    ULONG                           TableBufferLength;
    UCHAR                           TableBuffer[ANYSIZE_ARRAY];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

typedef NTSTATUS (__cdecl *PFNFTH)(PSYSTEM_FIRMWARE_TABLE_INFORMATION);

typedef struct _SYSTEM_FIRMWARE_TABLE_HANDLER {
    ULONG       ProviderSignature;
    BOOLEAN     Register;
    PFNFTH      FirmwareTableHandler;
    PVOID       DriverObject;
} SYSTEM_FIRMWARE_TABLE_HANDLER, *PSYSTEM_FIRMWARE_TABLE_HANDLER;

//
// Timer APC routine definition.
//

typedef
VOID
(*PTIMER_APC_ROUTINE) (
    __in PVOID TimerContext,
    __in ULONG TimerLowValue,
    __in LONG TimerHighValue
    );


//
//  Driver Verifier Definitions
//

typedef ULONG_PTR (*PDRIVER_VERIFIER_THUNK_ROUTINE) (
    IN PVOID Context
    );

//
//  This structure is passed in by drivers that want to thunk callers of
//  their exports.
//

typedef struct _DRIVER_VERIFIER_THUNK_PAIRS {
    PDRIVER_VERIFIER_THUNK_ROUTINE  PristineRoutine;
    PDRIVER_VERIFIER_THUNK_ROUTINE  NewRoutine;
} DRIVER_VERIFIER_THUNK_PAIRS, *PDRIVER_VERIFIER_THUNK_PAIRS;

//
//  Driver Verifier flags.
//

#define DRIVER_VERIFIER_SPECIAL_POOLING             0x0001
#define DRIVER_VERIFIER_FORCE_IRQL_CHECKING         0x0002
#define DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES  0x0004
#define DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS      0x0008
#define DRIVER_VERIFIER_IO_CHECKING                 0x0010


//
// Define data shared between kernel and user mode.
//
// N.B. User mode has read only access to this data
//
#ifdef _MAC
#pragma warning( disable : 4121)
#endif

#define MAX_WOW64_SHARED_ENTRIES 16

//
// WARNING: This structure must have exactly the same layout for 32- and
//    64-bit systems. The layout of this structure cannot change and new
//    fields can only be added at the end of the structure (unless a gap
//    can be exploited). Deprecated fields cannot be deleted. Platform
//    specific fields are included on all systems.
//
//    Layout exactness is required for Wow64 support of 32-bit applications
//    on Win64 systems.
//
//    The layout itself cannot change since this structure has been exported
//    in ntddk, ntifs.h, and nthal.h for some time.
//
// Define NX support policy values.
//

#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON 1
#define NX_SUPPORT_POLICY_OPTIN 2
#define NX_SUPPORT_POLICY_OPTOUT 3

//
// Global shared data flags and manipulation macros.
//

#define SHARED_GLOBAL_FLAGS_ERROR_PORT_V        0x0
#define SHARED_GLOBAL_FLAGS_ERROR_PORT          (1UL << SHARED_GLOBAL_FLAGS_ERROR_PORT_V)

#define SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V 0x1
#define SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED   (1UL << SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V)

#define SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V      0x2
#define SHARED_GLOBAL_FLAGS_VIRT_ENABLED        (1UL << SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V)

#define SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V  0x3
#define SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED    \
    (1UL << SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V)

#define SHARED_GLOBAL_FLAGS_SYSTEM_DLL_RELOCATED_V      0x4
#define SHARED_GLOBAL_FLAGS_SYSTEM_DLL_RELOCATED        \
    (1UL << SHARED_GLOBAL_FLAGS_SYSTEM_DLL_RELOCATED_V)

#define SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V      0x5
#define SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED        \
    (1UL << SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V)

#define SHARED_GLOBAL_FLAGS_SEH_VALIDATION_ENABLED_V    0x6
#define SHARED_GLOBAL_FLAGS_SEH_VALIDATION_ENABLED        \
    (1UL << SHARED_GLOBAL_FLAGS_SEH_VALIDATION_ENABLED_V)

#define EX_INIT_BITS(Flags, Bit) \
    *((Flags)) |= (Bit)             // Safe to use before concurrently accessible

#define EX_TEST_SET_BIT(Flags, Bit) \
    InterlockedBitTestAndSet ((PLONG)(Flags), (Bit))

#define EX_TEST_CLEAR_BIT(Flags, Bit) \
    InterlockedBitTestAndReset ((PLONG)(Flags), (Bit))

typedef struct _KUSER_SHARED_DATA {

    //
    // Current low 32-bit of tick count and tick count multiplier.
    //
    // N.B. The tick count is updated each time the clock ticks.
    //

    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    //
    // Current 64-bit interrupt time in 100ns units.
    //

    volatile KSYSTEM_TIME InterruptTime;

    //
    // Current 64-bit system time in 100ns units.
    //

    volatile KSYSTEM_TIME SystemTime;

    //
    // Current 64-bit time zone bias.
    //

    volatile KSYSTEM_TIME TimeZoneBias;

    //
    // Support image magic number range for the host system.
    //
    // N.B. This is an inclusive range.
    //

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    //
    // Copy of system root in unicode.
    //

    WCHAR NtSystemRoot[260];

    //
    // Maximum stack trace depth if tracing enabled.
    //

    ULONG MaxStackTraceDepth;

    //
    // Crypto exponent value.
    //

    ULONG CryptoExponent;

    //
    // Time zone ID.
    //

    ULONG TimeZoneId;
    ULONG LargePageMinimum;
    ULONG Reserved2[7];

    //
    // Product type.
    //

    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;

    //
    // three bytes of padding here -- offsets 0x269, 0x26A, 0x26B
    //

    //
    // The NT Version.
    //
    // N. B. Note that each process sees a version from its PEB, but if the
    //       process is running with an altered view of the system version,
    //       the following two fields are used to correctly identify the
    //       version
    //

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    //
    // Processor features.
    //

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];

    //
    // Reserved fields - do not use.
    //

    ULONG Reserved1;
    ULONG Reserved3;

    //
    // Time slippage while in debugger.
    //

    volatile ULONG TimeSlip;

    //
    // Alternative system architecture, e.g., NEC PC98xx on x86.
    //

    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;

    //
    // four bytes of padding here -- offsets 0x2c4, 0x2c5, 0x2c6, 0x2c7
    //

    //
    // If the system is an evaluation unit, the following field contains the
    // date and time that the evaluation unit expires. A value of 0 indicates
    // that there is no expiration. A non-zero value is the UTC absolute time
    // that the system expires.
    //

    LARGE_INTEGER SystemExpirationDate;

    //
    // Suite support.
    //

    ULONG SuiteMask;

    //
    // TRUE if a kernel debugger is connected/enabled.
    //

    BOOLEAN KdDebuggerEnabled;

    //
    // NX support policy.
    //

    UCHAR NXSupportPolicy;

    //
    // two bytes of padding here -- offsets 0x2d6, 0x2d7
    //

    //
    // Current console session Id. Always zero on non-TS systems.
    //

    volatile ULONG ActiveConsoleId;

    //
    // Force-dismounts cause handles to become invalid. Rather than always
    // probe handles, a serial number of dismounts is maintained that clients
    // can use to see if they need to probe handles.
    //

    volatile ULONG DismountCount;

    //
    // This field indicates the status of the 64-bit COM+ package on the
    // system. It indicates whether the Itermediate Language (IL) COM+
    // images need to use the 64-bit COM+ runtime or the 32-bit COM+ runtime.
    //

    ULONG ComPlusPackage;

    //
    // Time in tick count for system-wide last user input across all terminal
    // sessions. For MP performance, it is not updated all the time (e.g. once
    // a minute per session). It is used for idle detection.
    //

    ULONG LastSystemRITEventTickCount;

    //
    // Number of physical pages in the system. This can dynamically change as
    // physical memory can be added or removed from a running system.
    //

    ULONG NumberOfPhysicalPages;

    //
    // True if the system was booted in safe boot mode.
    //

    BOOLEAN SafeBootMode;

    //
    // three bytes of padding here -- offsets 0x2ed, 0x2ee, 0x2ef
    //

#if 0 // pre-Vista
    ULONG TraceLogging;
#endif

    //
    // This is a packed bitfield that contains various flags concerning
    // the system state. They must be manipulated using interlocked
    // operations.
    //

    union {
        ULONG SharedDataFlags;
        struct {

            //
            // The following bit fields are for the debugger only. Do not use.
            // Use the bit definitions instead.
            //

            ULONG DbgErrorPortPresent       : 1;
            ULONG DbgElevationEnabled       : 1;
            ULONG DbgVirtEnabled            : 1;
            ULONG DbgInstallerDetectEnabled : 1;

            ULONG DbgSystemDllRelocated     : 1;
            ULONG DbgDynProcessorEnabled    : 1;
            ULONG DbgSEHValidationEnabled   : 1;
            ULONG SpareBits                 : 25;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    //
    // Depending on the processor, the code for fast system call will differ,
    // Stub code is provided pointers below to access the appropriate code.
    //
    // N.B. The following two fields are only used on 32-bit systems.
    //

    ULONGLONG TestRetInstruction;
    ULONG SystemCall;
    ULONG SystemCallReturn;
    ULONGLONG SystemCallPad[3];

    //
    // The 64-bit tick count.
    //

    union {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
    } DUMMYUNIONNAME2;

    //
    // four bytes of padding here, why? Offsets 0x32c, 0x32d, 0x32e, 0x32f
    //

    //
    // Cookie for encoding pointers system wide.
    //

    ULONG Cookie;

    //
    // Client id of the process having the focus in the current
    // active console session id.
    //

    LONGLONG ConsoleSessionForegroundProcessId;

    //
    // Shared information for Wow64 processes.
    //

    ULONG Wow64SharedInformation[MAX_WOW64_SHARED_ENTRIES];

    //
    // The following field is used for ETW user mode global logging
    // (UMGL).
    //

    USHORT UserModeGlobalLogger[8];
    ULONG HeapTracingPid[2];
    ULONG CritSecTracingPid[2];

    //
    // Settings that can enable the use of Image File Execution Options
    // from HKCU in addition to the original HKLM.
    //

    ULONG ImageFileExecutionOptions;

#if 0
    //
    // pre-Vista Service Pack 1, four bytes of padding here -- offsets 0x3a4, 0x3a5, 0x3a6, 0x3a7
    //

#else
    //
    // Generation of the kernel structure holding system language information
    //
    ULONG LangGenerationCount;
#endif

    //
    // This represents the affinity of active processors in the system.
    // This is updated by the kernel as processors are added\removed from
    // the system.
    //

    union {
        ULONGLONG AffinityPad;
        KAFFINITY ActiveProcessorAffinity;
    } DUMMYUNIONNAME3;

    //
    // Current 64-bit interrupt time bias in 100ns units.
    //

    volatile ULONG64 InterruptTimeBias;

} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;

//
// Mostly enforce earlier comment about the stability and
// architecture-neutrality of this struct.
//
#if !defined(__midl) && !defined(MIDL_PASS)
//
// The overall size can change, but it must be the same for all architectures.
//
C_ASSERT(sizeof(KUSER_SHARED_DATA) == 0x3B8);

C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountLowDeprecated) == 0x0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x08);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x014);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x020);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberLow) == 0x02c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberHigh) == 0x02e);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x030);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, MaxStackTraceDepth) == 0x238);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, CryptoExponent) == 0x23c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneId) == 0x240);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved2) == 0x248);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid) == 0x268);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved1) == 0x2b4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved3) == 0x2b8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TimeSlip) == 0x2bc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AlternativeArchitecture) == 0x2c0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemExpirationDate) == 0x2c8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask) == 0x2d0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NXSupportPolicy) == 0x2d5);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, DismountCount) == 0x2dc);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ComPlusPackage) == 0x2e0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LastSystemRITEventTickCount) == 0x2e4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec);
#if 0 // pre-Vista
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TraceLogging) == 0x2f0);
#else
#if defined(_MSC_EXTENSIONS)
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SharedDataFlags) == 0x2f0);
#endif
#endif
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TestRetInstruction) == 0x2f8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCall) == 0x300);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallReturn) == 0x304);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad) == 0x308);
#if defined(_MSC_EXTENSIONS)
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320);
#endif
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Cookie) == 0x330);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ConsoleSessionForegroundProcessId) == 0x338);
#if 0 // pre-Vista
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Wow64SharedInformation) == 0x334);
#else
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, Wow64SharedInformation) == 0x340);
#endif
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, HeapTracingPid) == 0x390);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, CritSecTracingPid) == 0x398);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, UserModeGlobalLogger) == 0x380);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, HeapTracingPid) == 0x390);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, CritSecTracingPid) == 0x398);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ImageFileExecutionOptions) == 0x3a0);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, LangGenerationCount) == 0x3a4);
#if defined(_MSC_EXTENSIONS)
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, AffinityPad) == 0x3a8);
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveProcessorAffinity) == 0x3a8);
#endif
C_ASSERT(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTimeBias) == 0x3b0);
#endif /* __midl | MIDL_PASS */

#ifdef _MAC
#pragma warning(default:4121)
#endif

#define CmResourceTypeMaximum             8
//
// Declaration of the structure for the PcCard ISA IRQ map
//

typedef struct _CM_PCCARD_DEVICE_DATA {
    UCHAR Flags;
    UCHAR ErrorCode;
    USHORT Reserved;
    ULONG BusData;
    ULONG DeviceId;
    ULONG LegacyBaseAddress;
    UCHAR IRQMap[16];
} CM_PCCARD_DEVICE_DATA, *PCM_PCCARD_DEVICE_DATA;

// Definitions for Flags

#define PCCARD_MAP_ERROR        0x01
#define PCCARD_DEVICE_PCI       0x10

#define PCCARD_SCAN_DISABLED    0x01
#define PCCARD_MAP_ZERO         0x02
#define PCCARD_NO_TIMER         0x03
#define PCCARD_NO_PIC           0x04
#define PCCARD_NO_LEGACY_BASE   0x05
#define PCCARD_DUP_LEGACY_BASE  0x06
#define PCCARD_NO_CONTROLLERS   0x07

#ifndef _ARC_DDK_
#define _ARC_DDK_

//
// Define configuration routine types.
//
// Configuration information.
//

typedef enum _CONFIGURATION_TYPE {
    ArcSystem,
    CentralProcessor,
    FloatingPointProcessor,
    PrimaryIcache,
    PrimaryDcache,
    SecondaryIcache,
    SecondaryDcache,
    SecondaryCache,
    EisaAdapter,
    TcAdapter,
    ScsiAdapter,
    DtiAdapter,
    MultiFunctionAdapter,
    DiskController,
    TapeController,
    CdromController,
    WormController,
    SerialController,
    NetworkController,
    DisplayController,
    ParallelController,
    PointerController,
    KeyboardController,
    AudioController,
    OtherController,
    DiskPeripheral,
    FloppyDiskPeripheral,
    TapePeripheral,
    ModemPeripheral,
    MonitorPeripheral,
    PrinterPeripheral,
    PointerPeripheral,
    KeyboardPeripheral,
    TerminalPeripheral,
    OtherPeripheral,
    LinePeripheral,
    NetworkPeripheral,
    SystemMemory,
    DockingInformation,
    RealModeIrqRoutingTable,
    RealModePCIEnumeration,
    MaximumType
} CONFIGURATION_TYPE, *PCONFIGURATION_TYPE;

#endif // _ARC_DDK_

//
// Several routines have an architecture specific implementation. Generate
// an error if a supported target is not defined.
//

#if !(defined(_X86_) || defined(_AMD64_) || defined(_IA64_))

#error "No target architecture defined"

#endif

//

#if defined(_X86_) || defined(_AMD64_)

#define PAUSE_PROCESSOR YieldProcessor();

#elif defined(_IA64_)

#define PAUSE_PROCESSOR __yield();

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeSetImportanceDpc (
    __inout PRKDPC Dpc,
    __in KDPC_IMPORTANCE Importance
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeSetTargetProcessorDpc (
    __inout PRKDPC Dpc,
    __in CCHAR Number
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KePulseEvent (
    __inout PRKEVENT Event,
    __in KPRIORITY Increment,
    __in BOOLEAN Wait
    );
#endif



#define MAXIMUM_EXPANSION_SIZE (KERNEL_LARGE_STACK_SIZE - (PAGE_SIZE / 2))

typedef
VOID
(NTAPI *PEXPAND_STACK_CALLOUT) (
    __in_opt PVOID Parameter
    );

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
NTSTATUS
KeExpandKernelStackAndCallout (
    __in PEXPAND_STACK_CALLOUT Callout,
    __in_opt PVOID Parameter,
    __in SIZE_T Size
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeSetBasePriorityThread (
    __inout PKTHREAD Thread,
    __in LONG Increment
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
KeEnterGuardedRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
KeLeaveGuardedRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
BOOLEAN
KeAreApcsDisabled (
    VOID
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck (
    __in ULONG BugCheckCode
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
KeInvalidateAllCaches (
    VOID
    );
#endif

NTKERNELAPI
VOID
FASTCALL
KeInvalidateRangeAllCaches (
    __in PVOID BaseAddress,
    __in ULONG Length
    );


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
KAFFINITY
KeQueryActiveProcessors (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
ULONG
KeQueryActiveProcessorCount (
    __out_opt PKAFFINITY ActiveProcessors
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
ULONG
KeQueryMaximumProcessorCount (
    VOID
    );
#endif


#if defined(POOL_TAGGING)
#define ExFreePool(a) ExFreePoolWithTag(a,0)
#endif

//
// If high order bit in Pool tag is set, then must use ExFreePoolWithTag to free
//

#define PROTECTED_POOL 0x80000000

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
DECLSPEC_NORETURN
VOID
ExRaiseDatatypeMisalignment (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
DECLSPEC_NORETURN
VOID
ExRaiseAccessViolation (
    VOID
    );
#endif

//
// Zone Allocation
//

typedef struct _ZONE_SEGMENT_HEADER {
    SINGLE_LIST_ENTRY SegmentList;
    PVOID Reserved;
} ZONE_SEGMENT_HEADER, *PZONE_SEGMENT_HEADER;

typedef struct _ZONE_HEADER {
    SINGLE_LIST_ENTRY FreeList;
    SINGLE_LIST_ENTRY SegmentList;
    ULONG BlockSize;
    ULONG TotalSegmentSize;
} ZONE_HEADER, *PZONE_HEADER;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExInitializeZone(
    __out PZONE_HEADER Zone,
    __in ULONG BlockSize,
    __inout PVOID InitialSegment,
    __in ULONG InitialSegmentSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExExtendZone(
    __inout PZONE_HEADER Zone,
    __inout PVOID Segment,
    __in ULONG SegmentSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExInterlockedExtendZone(
    __inout PZONE_HEADER Zone,
    __inout PVOID Segment,
    __in ULONG SegmentSize,
    __inout PKSPIN_LOCK Lock
    );
#endif

//++
//
// PVOID
// ExAllocateFromZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--
#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExAllocateFromZone)
#endif
#define ExAllocateFromZone(Zone) \
    (PVOID)((Zone)->FreeList.Next); \
    if ( (Zone)->FreeList.Next ) (Zone)->FreeList.Next = (Zone)->FreeList.Next->Next


//++
//
// PVOID
// ExFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExFreeToZone)
#endif
#define ExFreeToZone(Zone,Block)                                    \
    ( ((PSINGLE_LIST_ENTRY)(Block))->Next = (Zone)->FreeList.Next,  \
      (Zone)->FreeList.Next = ((PSINGLE_LIST_ENTRY)(Block)),        \
      ((PSINGLE_LIST_ENTRY)(Block))->Next                           \
    )

//++
//
// BOOLEAN
// ExIsFullZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine determines if the specified zone is full or not.  A zone
//     is considered full if the free list is empty.
//
// Arguments:
//
//     Zone - Pointer to the zone header to be tested.
//
// Return Value:
//
//     TRUE if the zone is full and FALSE otherwise.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExIsFullZone)
#endif
#define ExIsFullZone(Zone) \
    ( (Zone)->FreeList.Next == (PSINGLE_LIST_ENTRY)NULL )

//++
//
// PVOID
// ExInterlockedAllocateFromZone(
//     IN PZONE_HEADER Zone,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//     The removal is performed with the specified lock owned for the sequence
//     to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
//     Lock - Pointer to the spin lock which should be obtained before removing
//         the entry from the allocation list.  The lock is released before
//         returning to the caller.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedAllocateFromZone)
#endif
#define ExInterlockedAllocateFromZone(Zone,Lock) \
    (PVOID) ExInterlockedPopEntryList( &(Zone)->FreeList, Lock )

//++
//
// PVOID
// ExInterlockedFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.  The insertion is performed with the lock
//     owned for the sequence to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
//     Lock - Pointer to the spin lock which should be obtained before inserting
//         the entry onto the free list.  The lock is released before returning
//         to the caller.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedFreeToZone)
#endif
#define ExInterlockedFreeToZone(Zone,Block,Lock) \
    ExInterlockedPushEntryList( &(Zone)->FreeList, ((PSINGLE_LIST_ENTRY) (Block)), Lock )


//++
//
// BOOLEAN
// ExIsObjectInFirstZoneSegment(
//     IN PZONE_HEADER Zone,
//     IN PVOID Object
//     )
//
// Routine Description:
//
//     This routine determines if the specified pointer lives in the zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         object may belong.
//
//     Object - Pointer to the object in question.
//
// Return Value:
//
//     TRUE if the Object came from the first segment of zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExIsObjectInFirstZoneSegment)
#endif
#define ExIsObjectInFirstZoneSegment(Zone,Object) ((BOOLEAN)     \
    (((PUCHAR)(Object) >= (PUCHAR)(Zone)->SegmentList.Next) &&   \
     ((PUCHAR)(Object) < (PUCHAR)(Zone)->SegmentList.Next +      \
                         (Zone)->TotalSegmentSize))              \
)

//
//  ntddk.h stole the entrypoints we wanted so fix them up here.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInitializeResource)            // use ExInitializeResourceLite
#pragma deprecated(ExAcquireResourceShared)         // use ExAcquireResourceSharedLite
#pragma deprecated(ExAcquireResourceExclusive)      // use ExAcquireResourceExclusiveLite
#pragma deprecated(ExReleaseResourceForThread)      // use ExReleaseResourceForThreadLite
#pragma deprecated(ExConvertExclusiveToShared)      // use ExConvertExclusiveToSharedLite
#pragma deprecated(ExDeleteResource)                // use ExDeleteResourceLite
#pragma deprecated(ExIsResourceAcquiredExclusive)   // use ExIsResourceAcquiredExclusiveLite
#pragma deprecated(ExIsResourceAcquiredShared)      // use ExIsResourceAcquiredSharedLite
#pragma deprecated(ExIsResourceAcquired)            // use ExIsResourceAcquiredSharedLite
#endif
#define ExInitializeResource ExInitializeResourceLite
#define ExAcquireResourceShared ExAcquireResourceSharedLite
#define ExAcquireResourceExclusive ExAcquireResourceExclusiveLite
#define ExReleaseResourceForThread ExReleaseResourceForThreadLite
#define ExConvertExclusiveToShared ExConvertExclusiveToSharedLite
#define ExDeleteResource ExDeleteResourceLite
#define ExIsResourceAcquiredExclusive ExIsResourceAcquiredExclusiveLite
#define ExIsResourceAcquiredShared ExIsResourceAcquiredSharedLite
#define ExIsResourceAcquired ExIsResourceAcquiredSharedLite


//
// UUID Generation
//

typedef GUID UUID;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ExUuidCreate(
    __out UUID *Uuid
    );
#endif

//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0


//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1



//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6


//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2


//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6


//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2


//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
MmIsThisAnNtAsSystem (
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
MmMapUserAddressesToPage (
    __in_bcount(NumberOfBytes) PVOID BaseAddress,
    __in SIZE_T NumberOfBytes,
    __in PVOID PageAddress
    );
#endif


typedef struct _PHYSICAL_MEMORY_RANGE {
    PHYSICAL_ADDRESS BaseAddress;
    LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
MmAddPhysicalMemory (
    __in PPHYSICAL_ADDRESS StartAddress,
    __inout PLARGE_INTEGER NumberOfBytes
    );
#endif

typedef NTSTATUS (*PMM_ROTATE_COPY_CALLBACK_FUNCTION) (
    __in PMDL DestinationMdl,
    __in PMDL SourceMdl,
    __in PVOID Context
    );

typedef enum _MM_ROTATE_DIRECTION {
    MmToFrameBuffer,
    MmToFrameBufferNoCopy,
    MmToRegularMemory,
    MmToRegularMemoryNoCopy,
    MmMaximumRotateDirection
} MM_ROTATE_DIRECTION, *PMM_ROTATE_DIRECTION;

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
MmRotatePhysicalView (
    __in PVOID VirtualAddress,
    __inout PSIZE_T NumberOfBytes,
    __in_opt PMDLX NewMdl,
    __in MM_ROTATE_DIRECTION Direction,
    __in PMM_ROTATE_COPY_CALLBACK_FUNCTION CopyFunction,
    __in_opt PVOID Context
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
MmRemovePhysicalMemory (
    __in PPHYSICAL_ADDRESS StartAddress,
    __inout PLARGE_INTEGER NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PPHYSICAL_MEMORY_RANGE
MmGetPhysicalMemoryRanges (
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__out_bcount_opt (NumberOfBytes) PVOID
MmMapVideoDisplay (
    __in PHYSICAL_ADDRESS PhysicalAddress,
    __in SIZE_T NumberOfBytes,
    __in MEMORY_CACHING_TYPE CacheType
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmUnmapVideoDisplay (
     __in_bcount (NumberOfBytes) PVOID BaseAddress,
     __in SIZE_T NumberOfBytes
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    __in PVOID BaseAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
MmGetVirtualForPhysical (
    __in PHYSICAL_ADDRESS PhysicalAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__bcount (NumberOfBytes) PVOID
MmAllocateContiguousMemory (
    __in SIZE_T NumberOfBytes,
    __in PHYSICAL_ADDRESS HighestAcceptableAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__out_bcount_opt (NumberOfBytes) PVOID
MmAllocateContiguousMemorySpecifyCache (
    __in SIZE_T NumberOfBytes,
    __in PHYSICAL_ADDRESS LowestAcceptableAddress,
    __in PHYSICAL_ADDRESS HighestAcceptableAddress,
    __in_opt PHYSICAL_ADDRESS BoundaryAddressMultiple,
    __in MEMORY_CACHING_TYPE CacheType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef ULONG NODE_REQUIREMENT;

#define MM_ANY_NODE_OK          0x80000000

NTKERNELAPI
__out_bcount_opt (NumberOfBytes) PVOID
MmAllocateContiguousMemorySpecifyCacheNode (
    __in SIZE_T NumberOfBytes,
    __in PHYSICAL_ADDRESS LowestAcceptableAddress,
    __in PHYSICAL_ADDRESS HighestAcceptableAddress,
    __in_opt PHYSICAL_ADDRESS BoundaryAddressMultiple,
    __in MEMORY_CACHING_TYPE CacheType,
    __in NODE_REQUIREMENT PreferredNode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmFreeContiguousMemory (
    __in PVOID BaseAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmFreeContiguousMemorySpecifyCache (
    __in_bcount (NumberOfBytes) PVOID BaseAddress,
    __in SIZE_T NumberOfBytes,
    __in MEMORY_CACHING_TYPE CacheType
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__out_bcount_opt (NumberOfBytes) PVOID
MmAllocateNonCachedMemory (
    __in SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmFreeNonCachedMemory (
    __in_bcount (NumberOfBytes) PVOID BaseAddress,
    __in SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
MmIsAddressValid (
    __in PVOID VirtualAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
BOOLEAN
MmIsNonPagedSystemAddressValid (
    __in PVOID VirtualAddress
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmLockPagableSectionByHandle (
    __in PVOID ImageSectionHandle
    );
#endif


//
// Note that even though this function prototype
// says "HANDLE", MmSecureVirtualMemory does NOT return
// anything resembling a Win32-style handle.  The return
// value from this function can ONLY be used with MmUnsecureVirtualMemory.
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
HANDLE
MmSecureVirtualMemory (
    __in_data_source(USER_MODE) __out_validated(MEMORY) __in_bcount (Size) PVOID Address,
    __in  __in_data_source(USER_MODE) SIZE_T Size,
    __in ULONG ProbeMode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmUnsecureVirtualMemory (
    __in HANDLE SecureHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
MmMapViewInSystemSpace (
    __in PVOID Section,
    __deref_out_bcount (*ViewSize) PVOID *MappedBase,
    __inout PSIZE_T ViewSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
MmUnmapViewInSystemSpace (
    __in PVOID MappedBase
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
MmMapViewInSessionSpace (
    __in PVOID Section,
    __deref_out_bcount (*ViewSize) PVOID *MappedBase,
    __inout PSIZE_T ViewSize
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
MmUnmapViewInSessionSpace (
    __in PVOID MappedBase
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
NTSTATUS
MmCreateMirror (
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SeSinglePrivilegeCheck(
    __in LUID PrivilegeValue,
    __in KPROCESSOR_MODE PreviousMode
    );
#endif


extern NTKERNELAPI PEPROCESS PsInitialSystemProcess;


#if !defined(_PSGETCURRENTTHREAD_)

#define _PSGETCURRENTTHREAD_

FORCEINLINE
PETHREAD
PsGetCurrentThread (
    VOID
    )

/*++

Routine Description:

    This function returns a pointer to the current executive thread object.

Arguments:

    None.

Return Value:

    A pointer to the current executive thread object.

--*/

{

    return (PETHREAD)KeGetCurrentThread();
}

#endif


typedef
VOID
(*PCREATE_PROCESS_NOTIFY_ROUTINE)(
    IN HANDLE ParentId,
    IN HANDLE ProcessId,
    IN BOOLEAN Create
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PsSetCreateProcessNotifyRoutine(
    __in PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
    __in BOOLEAN Remove
    );
#endif

typedef struct _PS_CREATE_NOTIFY_INFO {
    __in SIZE_T Size;
    union {
        __in ULONG Flags;
        struct {
            __in ULONG FileOpenNameAvailable : 1;
            __in ULONG Reserved : 31;
        };
    };
    __in HANDLE ParentProcessId;
    __in CLIENT_ID CreatingThreadId;
    __inout struct _FILE_OBJECT *FileObject;
    __in PCUNICODE_STRING ImageFileName;
    __in_opt PCUNICODE_STRING CommandLine;
    __inout NTSTATUS CreationStatus;
} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;

typedef
VOID
(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX) (
    __inout PEPROCESS Process,
    __in HANDLE ProcessId,
    __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo
    );

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
NTSTATUS
PsSetCreateProcessNotifyRoutineEx (
    __in PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,
    __in BOOLEAN Remove
    );
#endif

typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
    IN HANDLE ProcessId,
    IN HANDLE ThreadId,
    IN BOOLEAN Create
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PsSetCreateThreadNotifyRoutine(
    __in PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
PsRemoveCreateThreadNotifyRoutine (
    __in PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );
#endif

//
// Structures for Load Image Notify
//

#define IMAGE_ADDRESSING_MODE_32BIT     3

typedef struct _IMAGE_INFO {
    union {
        ULONG Properties;
        struct {
            ULONG ImageAddressingMode  : 8;  // Code addressing mode
            ULONG SystemModeImage      : 1;  // System mode image
            ULONG ImageMappedToAllPids : 1;  // Image mapped into all processes
            ULONG ExtendedInfoPresent  : 1;  // IMAGE_INFO_EX available
            ULONG Reserved             : 21;
        };
    };
    PVOID       ImageBase;
    ULONG       ImageSelector;
    SIZE_T      ImageSize;
    ULONG       ImageSectionNumber;
} IMAGE_INFO, *PIMAGE_INFO;

typedef struct _IMAGE_INFO_EX {
    SIZE_T              Size;
    IMAGE_INFO          ImageInfo;
    struct _FILE_OBJECT *FileObject;
} IMAGE_INFO_EX, *PIMAGE_INFO_EX;

typedef
VOID
(*PLOAD_IMAGE_NOTIFY_ROUTINE)(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,                // pid into which image is being mapped
    IN PIMAGE_INFO ImageInfo
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PsSetLoadImageNotifyRoutine(
    __in PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
PsRemoveLoadImageNotifyRoutine(
    __in PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
HANDLE
PsGetCurrentProcessId(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
HANDLE
PsGetCurrentThreadId(
    VOID
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
PsGetVersion(
    __out_opt PULONG MajorVersion,
    __out_opt PULONG MinorVersion,
    __out_opt PULONG BuildNumber,
    __out_opt PUNICODE_STRING CSDVersion
    );
#endif

//
// Prefetch information.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
BOOLEAN
PsSetCurrentThreadPrefetching (
    __in BOOLEAN Prefetching
    );

NTKERNELAPI
BOOLEAN
PsIsCurrentThreadPrefetching (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
LONGLONG
PsGetProcessCreateTimeQuadPart(
    __in PEPROCESS Process
    );
#endif
#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
HANDLE
PsGetProcessId(
    __in PEPROCESS Process
    );

NTKERNELAPI
HANDLE
PsGetThreadId(
    __in PETHREAD Thread
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
HANDLE
PsGetThreadProcessId(
    __in PETHREAD Thread
    );
#endif

//
// Directory control minor function codes
//

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02

//
// File system control minor function codes.  Note that "user request" is
// assumed to be zero by both the I/O system and file systems.  Do not change
// this value.
//

#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04    // To be obsoleted soon
#define IRP_MN_KERNEL_CALL              0x04

//
// Lock control minor function codes
//

#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04

//
// Flush minor function codes
//

#define IRP_MN_FLUSH_AND_PURGE          0x01

//
// Read and Write minor function codes for file systems supporting Lan Manager
// software.  All of these subfunction codes are invalid if the file has been
// opened with FO_NO_INTERMEDIATE_BUFFERING.  They are also invalid in combi-
// nation with synchronous calls (Irp Flag or file open option).
//
// Note that "normal" is assumed to be zero by both the I/O system and file
// systems.  Do not change this value.
//

#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08

#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)

#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18

#define IO_CHECK_CREATE_PARAMETERS      0x0200
#define IO_ATTACH_DEVICE                0x0400

//
//  This flag is only meaningful to IoCreateFileSpecifyDeviceObjectHint.
//  FileHandles created using IoCreateFileSpecifyDeviceObjectHint with this
//  flag set will bypass ShareAccess checks on this file.
//

#define IO_IGNORE_SHARE_ACCESS_CHECK    0x0800  // Ignores share access checks on opens.

//
// Define callout routine type for use in IoQueryDeviceDescription().
//

typedef NTSTATUS (*PIO_QUERY_DEVICE_ROUTINE)(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );


// Defines the order of the information in the array of
// PKEY_VALUE_FULL_INFORMATION.
//

typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
    IoQueryDeviceIdentifier = 0,
    IoQueryDeviceConfigurationData,
    IoQueryDeviceComponentInformation,
    IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT, *PIO_QUERY_DEVICE_DATA_FORMAT;

//
// Define driver reinitialization routine type.
//

typedef
VOID
DRIVER_REINITIALIZE (
    __in struct _DRIVER_OBJECT *DriverObject,
    __in_opt PVOID Context,
    __in ULONG Count
    );

typedef DRIVER_REINITIALIZE *PDRIVER_REINITIALIZE;


typedef struct _CONTROLLER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PVOID ControllerExtension;
    KDEVICE_QUEUE DeviceWaitQueue;

    ULONG Spare1;
    LARGE_INTEGER Spare2;

} CONTROLLER_OBJECT, *PCONTROLLER_OBJECT;

#define DO_VERIFY_VOLUME                0x00000002      
#define DO_BUFFERED_IO                  0x00000004      
#define DO_EXCLUSIVE                    0x00000008      
#define DO_DIRECT_IO                    0x00000010      
#define DO_MAP_IO_BUFFER                0x00000020      
#define DO_DEVICE_HAS_NAME              0x00000040      
#define DO_DEVICE_INITIALIZING          0x00000080      
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      
#define DO_LONG_TERM_REQUESTS           0x00000200      
#define DO_NEVER_LAST_DEVICE            0x00000400      
#define DO_SHUTDOWN_REGISTERED          0x00000800      
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      
#define DO_POWER_PAGABLE                0x00002000      
#define DO_POWER_INRUSH                 0x00004000      
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      
#define DO_SUPPORTS_TRANSACTIONS        0x00040000      
#define DO_FORCE_NEITHER_IO             0x00080000      
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040

//
// The following structure is used by drivers that are initializing to
// determine the number of devices of a particular type that have already
// been initialized.  It is also used to track whether or not the AtDisk
// address range has already been claimed.  Finally, it is used by the
// NtQuerySystemInformation system service to return device type counts.
//

typedef struct _CONFIGURATION_INFORMATION {

    //
    // This field indicates the total number of disks in the system.  This
    // number should be used by the driver to determine the name of new
    // disks.  This field should be updated by the driver as it finds new
    // disks.
    //

    ULONG DiskCount;                // Count of hard disks thus far
    ULONG FloppyCount;              // Count of floppy disks thus far
    ULONG CdRomCount;               // Count of CD-ROM drives thus far
    ULONG TapeCount;                // Count of tape drives thus far
    ULONG ScsiPortCount;            // Count of SCSI port adapters thus far
    ULONG SerialCount;              // Count of serial devices thus far
    ULONG ParallelCount;            // Count of parallel devices thus far

    //
    // These next two fields indicate ownership of one of the two IO address
    // spaces that are used by WD1003-compatable disk controllers.
    //

    BOOLEAN AtDiskPrimaryAddressClaimed;    // 0x1F0 - 0x1FF
    BOOLEAN AtDiskSecondaryAddressClaimed;  // 0x170 - 0x17F

    //
    // Indicates the structure version, as anything value belong this will have been added.
    // Use the structure size as the version.
    //

    ULONG Version;

    //
    // Indicates the total number of medium changer devices in the system.
    // This field will be updated by the drivers as it determines that
    // new devices have been found and will be supported.
    //

    ULONG MediumChangerCount;

} CONFIGURATION_INFORMATION, *PCONFIGURATION_INFORMATION;

#if !(defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
NTKERNELAPI
NTSTATUS
IoAllocateAdapterChannel(
    __in PADAPTER_OBJECT AdapterObject,
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG NumberOfMapRegisters,
    __in PDRIVER_CONTROL ExecutionRoutine,
    __in PVOID Context
    );
#endif

#endif // !(defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoAllocateController(
    __in PCONTROLLER_OBJECT ControllerObject,
    __in PDEVICE_OBJECT DeviceObject,
    __in PDRIVER_CONTROL ExecutionRoutine,
    __in_opt PVOID Context
    );
#endif

//++
//
// VOID
// IoAssignArcName(
//     IN PUNICODE_STRING ArcName,
//     IN PUNICODE_STRING DeviceName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers of bootable media to create a symbolic
//     link between the ARC name of their device and its NT name.  This allows
//     the system to determine which device in the system was actually booted
//     from since the ARC firmware only deals in ARC names, and NT only deals
//     in NT names.
//
// Arguments:
//
//     ArcName - Supplies the Unicode string representing the ARC name.
//
//     DeviceName - Supplies the name to which the ARCname refers.
//
// Return Value:
//
//     None.
//
//--

#define IoAssignArcName( ArcName, DeviceName ) (  \
    IoCreateSymbolicLink( (ArcName), (DeviceName) ) )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReprtDetectedDevice
NTKERNELAPI
NTSTATUS
IoAssignResources (
    __in PUNICODE_STRING RegistryPath,
    __in_opt PUNICODE_STRING DriverClassName,
    __in PDRIVER_OBJECT DriverObject,
    __in_opt PDEVICE_OBJECT DeviceObject,
    __in_opt PIO_RESOURCE_REQUIREMENTS_LIST RequestedResources,
    __inout PCM_RESOURCE_LIST *AllocatedResources
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoAttachDeviceToDeviceStack
NTKERNELAPI
NTSTATUS
IoAttachDeviceByPointer(
    __in PDEVICE_OBJECT SourceDevice,
    __in PDEVICE_OBJECT TargetDevice
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PCONTROLLER_OBJECT
IoCreateController(
    __in ULONG Size
    );
#endif


//++
//
// VOID
// IoDeassignArcName(
//     IN PUNICODE_STRING ArcName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers to deassign an ARC name that they
//     created to a device.  This is generally only called if the driver is
//     deleting the device object, which means that the driver is probably
//     unloading.
//
// Arguments:
//
//     ArcName - Supplies the ARC name to be removed.
//
// Return Value:
//
//     None.
//
//--

#define IoDeassignArcName( ArcName ) (  \
    IoDeleteSymbolicLink( (ArcName) ) )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoDeleteController(
    __in PCONTROLLER_OBJECT ControllerObject
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoFreeController(
    __in PCONTROLLER_OBJECT ControllerObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)          
NTKERNELAPI                                 
PCONFIGURATION_INFORMATION                  
IoGetConfigurationInformation( VOID );      
#endif                                      

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PDEVICE_OBJECT
IoGetDeviceToVerify(
    __in PETHREAD Thread
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PGENERIC_MAPPING
IoGetFileObjectGenericMapping(
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoCancelFileOpen(
    __in PDEVICE_OBJECT  DeviceObject,
    __in PFILE_OBJECT    FileObject
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIRP
IoMakeAssociatedIrp(
    __in PIRP Irp,
    __in CCHAR StackSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoGetDeviceProperty
NTKERNELAPI
NTSTATUS
IoQueryDeviceDescription(
    __in_opt PINTERFACE_TYPE BusType,
    __in_opt PULONG BusNumber,
    __in_opt PCONFIGURATION_TYPE ControllerType,
    __in_opt PULONG ControllerNumber,
    __in_opt PCONFIGURATION_TYPE PeripheralType,
    __in_opt PULONG PeripheralNumber,
    __in PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,
    __inout_opt PVOID Context
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoRaiseHardError(
    __in PIRP Irp,
    __in_opt PVPB Vpb,
    __in PDEVICE_OBJECT RealDeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
IoRaiseInformationalHardError(
    __in NTSTATUS ErrorStatus,
    __in_opt PUNICODE_STRING String,
    __in_opt PKTHREAD Thread
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
IoSetThreadHardErrorMode(
    __in BOOLEAN EnableHardErrors
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoRegisterBootDriverReinitialization(
    __in PDRIVER_OBJECT DriverObject,
    __in PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    __in_opt PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoRegisterDriverReinitialization(
    __in PDRIVER_OBJECT DriverObject,
    __in PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    __in_opt PVOID Context
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoReportResourceForDetection
NTKERNELAPI
NTSTATUS
IoReportResourceUsage(
    __in_opt PUNICODE_STRING DriverClassName,
    __in  PDRIVER_OBJECT DriverObject,
    __in_opt PCM_RESOURCE_LIST DriverList,
    __in_opt ULONG DriverListSize,
    __in  PDEVICE_OBJECT DeviceObject,
    __in_opt PCM_RESOURCE_LIST DeviceList,
    __in_opt ULONG DeviceListSize,
    __in  BOOLEAN OverrideConflict,
    __out PBOOLEAN ConflictDetected
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
BOOLEAN
IoTranslateBusAddress(
    __in  INTERFACE_TYPE InterfaceType,
    __in  ULONG BusNumber,
    __in  PHYSICAL_ADDRESS BusAddress,
    __inout PULONG AddressSpace,
    __out PPHYSICAL_ADDRESS TranslatedAddress
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoSetHardErrorOrVerifyDevice(
    __in PIRP Irp,
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
HalExamineMBR(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
DECLSPEC_DEPRECATED_DDK                 // Use IoReadPartitionTableEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoReadPartitionTable(
    __in  PDEVICE_OBJECT DeviceObject,
    __in  ULONG SectorSize,
    __in  BOOLEAN ReturnRecognizedPartitions,
    __out struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
DECLSPEC_DEPRECATED_DDK                 // Use IoSetPartitionInformationEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoSetPartitionInformation(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG SectorSize,
    __in ULONG PartitionNumber,
    __in ULONG PartitionType
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
DECLSPEC_DEPRECATED_DDK                 // Use IoWritePartitionTableEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoWritePartitionTable(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG SectorSize,
    __in ULONG SectorsPerTrack,
    __in ULONG NumberOfHeads,
    __in struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoCreateDisk(
    __in PDEVICE_OBJECT DeviceObject,
    __in_opt struct _CREATE_DISK* Disk
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoReadPartitionTableEx(
    __in PDEVICE_OBJECT DeviceObject,
    __out struct _DRIVE_LAYOUT_INFORMATION_EX** DriveLayout
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWritePartitionTableEx(
    __in PDEVICE_OBJECT DeviceObject,
    __in_xcount(FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0])) struct _DRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoSetPartitionInformationEx(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG PartitionNumber,
    __in struct _SET_PARTITION_INFORMATION_EX* PartitionInfo
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoUpdateDiskGeometry(
    __in PDEVICE_OBJECT DeviceObject,
    __in struct _DISK_GEOMETRY_EX* OldDiskGeometry,
    __in struct _DISK_GEOMETRY_EX* NewDiskGeometry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoVerifyPartitionTable(
    __in PDEVICE_OBJECT DeviceObject,
    __in BOOLEAN FixErrors
    );
#endif

typedef struct _DISK_SIGNATURE {
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;

        struct {
            GUID DiskId;
        } Gpt;
    };
} DISK_SIGNATURE, *PDISK_SIGNATURE;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoReadDiskSignature(
    __in  PDEVICE_OBJECT DeviceObject,
    __in  ULONG BytesPerSector,
    __out PDISK_SIGNATURE Signature
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoVolumeDeviceToDosName(
    __in  PVOID           VolumeDeviceObject,
    __out PUNICODE_STRING DosName
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoSetSystemPartition(
    __in PUNICODE_STRING VolumeNameString
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoCreateFileSpecifyDeviceObjectHint(
    __out PHANDLE FileHandle,
    __in  ACCESS_MASK DesiredAccess,
    __in  POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_opt PLARGE_INTEGER AllocationSize,
    __in  ULONG FileAttributes,
    __in  ULONG ShareAccess,
    __in  ULONG Disposition,
    __in  ULONG CreateOptions,
    __in_opt PVOID EaBuffer,
    __in  ULONG EaLength,
    __in  CREATE_FILE_TYPE CreateFileType,
    __in_opt PVOID InternalParameters,
    __in  ULONG Options,
    __in_opt PVOID DeviceObject
    );
#endif

typedef struct _TXN_PARAMETER_BLOCK {

    USHORT Length;              // sizeof( TXN_PARAMETER_BLOCK )
    USHORT TxFsContext;         // this is mini version of the requested file
    PVOID  TransactionObject;   // referenced pointer to KTRANSACTION

} TXN_PARAMETER_BLOCK, *PTXN_PARAMETER_BLOCK;

//
//  This value should be used in the TxFsContext member of the
//  TXN_PARAMETER_BLOCK in the absence of a specific miniversion.
//

#define TXF_MINIVERSION_DEFAULT_VIEW        (0xFFFE)

#if (NTDDI_VERSION >= NTDDI_VISTA)
PTXN_PARAMETER_BLOCK
IoGetTransactionParameterBlock (
    __in PFILE_OBJECT FileObject
    );
#endif

typedef struct _IO_DRIVER_CREATE_CONTEXT {
    CSHORT Size;
    struct _ECP_LIST *ExtraCreateParameter;
    PVOID DeviceObjectHint;
    PTXN_PARAMETER_BLOCK TxnParameters;
} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;

VOID
FORCEINLINE
IoInitializeDriverCreateContext(
    PIO_DRIVER_CREATE_CONTEXT DriverContext
    )
{
    // Initialize the context
    RtlZeroMemory(DriverContext, sizeof(IO_DRIVER_CREATE_CONTEXT));
    DriverContext->Size = sizeof(IO_DRIVER_CREATE_CONTEXT);
}

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoCreateFileEx(
    __out PHANDLE FileHandle,
    __in  ACCESS_MASK DesiredAccess,
    __in  POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_opt PLARGE_INTEGER AllocationSize,
    __in  ULONG FileAttributes,
    __in  ULONG ShareAccess,
    __in  ULONG Disposition,
    __in  ULONG CreateOptions,
    __in_opt PVOID EaBuffer,
    __in  ULONG EaLength,
    __in  CREATE_FILE_TYPE CreateFileType,
    __in_opt PVOID InternalParameters,
    __in  ULONG Options,
    __in_opt PIO_DRIVER_CREATE_CONTEXT DriverContext
    );

NTSTATUS
IoSetIrpExtraCreateParameter(
    __inout PIRP Irp,
    __in struct _ECP_LIST *ExtraCreateParameter
    );

VOID
IoClearIrpExtraCreateParameter(
    __inout PIRP Irp
    );

NTSTATUS
IoGetIrpExtraCreateParameter(
    __in PIRP Irp,
    __deref_out struct _ECP_LIST **ExtraCreateParameter
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoAttachDeviceToDeviceStackSafe(
    __in  PDEVICE_OBJECT SourceDevice,
    __in  PDEVICE_OBJECT TargetDevice,
    __deref_out PDEVICE_OBJECT *AttachedToDeviceObject
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
NTKERNELAPI
BOOLEAN
IoIsFileOriginRemote(
    __in PFILE_OBJECT FileObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
NTKERNELAPI
NTSTATUS
IoSetFileOrigin(
    __in PFILE_OBJECT FileObject,
    __in BOOLEAN Remote
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
BOOLEAN
IoIsFileObjectIgnoringSharing (
  __in PFILE_OBJECT FileObject
);
#endif


#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
IO_PAGING_PRIORITY
FASTCALL
IoGetPagingIoPriority(
    __in PIRP Irp
    );
#endif


typedef struct _AGP_TARGET_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // config munging routines
    //
    PGET_SET_DEVICE_DATA SetBusData;
    PGET_SET_DEVICE_DATA GetBusData;
    UCHAR CapabilityID;  // 2 (AGPv2 host) or new 0xE (AGPv3 bridge)

} AGP_TARGET_BUS_INTERFACE_STANDARD, *PAGP_TARGET_BUS_INTERFACE_STANDARD;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoReportDetectedDevice(
    __in PDRIVER_OBJECT DriverObject,
    __in INTERFACE_TYPE LegacyBusType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __in_opt PCM_RESOURCE_LIST ResourceList,
    __in_opt PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements,
    __in BOOLEAN ResourceAssigned,
    __deref_inout_opt PDEVICE_OBJECT *DeviceObject
    );
#endif

//
// Device location interface declarations
//
typedef
NTSTATUS
(*PGET_LOCATION_STRING) (
    __inout_opt PVOID Context,
    __deref_out PWCHAR *LocationStrings
    );

typedef struct _PNP_LOCATION_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // interface specific entry
    //
    PGET_LOCATION_STRING GetLocationString;

} PNP_LOCATION_INTERFACE, *PPNP_LOCATION_INTERFACE;

//
// Resource arbiter declarations
//

typedef enum _ARBITER_ACTION {
    ArbiterActionTestAllocation,
    ArbiterActionRetestAllocation,
    ArbiterActionCommitAllocation,
    ArbiterActionRollbackAllocation,
    ArbiterActionQueryAllocatedResources,
    ArbiterActionWriteReservedResources,
    ArbiterActionQueryConflict,
    ArbiterActionQueryArbitrate,
    ArbiterActionAddReserved,
    ArbiterActionBootAllocation
} ARBITER_ACTION, *PARBITER_ACTION;

typedef struct _ARBITER_CONFLICT_INFO {
    //
    // The device object owning the device that is causing the conflict
    //
    PDEVICE_OBJECT OwningObject;

    //
    // The start of the conflicting range
    //
    ULONGLONG Start;

    //
    // The end of the conflicting range
    //
    ULONGLONG End;

} ARBITER_CONFLICT_INFO, *PARBITER_CONFLICT_INFO;

//
// The parameters for those actions
//

typedef struct _ARBITER_TEST_ALLOCATION_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's
    //
    IN OUT PLIST_ENTRY ArbitrationList;

    //
    // The size of the AllocateFrom array
    //
    IN ULONG AllocateFromCount;

    //
    // Array of resource descriptors describing the resources available
    // to the arbiter for it to arbitrate
    //
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom;

} ARBITER_TEST_ALLOCATION_PARAMETERS, *PARBITER_TEST_ALLOCATION_PARAMETERS;


typedef struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's
    //
    IN OUT PLIST_ENTRY ArbitrationList;

    //
    // The size of the AllocateFrom array
    //
    IN ULONG AllocateFromCount;

    //
    // Array of resource descriptors describing the resources available
    // to the arbiter for it to arbitrate
    //
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom;

} ARBITER_RETEST_ALLOCATION_PARAMETERS, *PARBITER_RETEST_ALLOCATION_PARAMETERS;

typedef struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's
    //
    IN OUT PLIST_ENTRY ArbitrationList;

} ARBITER_BOOT_ALLOCATION_PARAMETERS, *PARBITER_BOOT_ALLOCATION_PARAMETERS;


typedef struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {

    //
    // The resources that are currently allocated
    //
    OUT PCM_PARTIAL_RESOURCE_LIST *AllocatedResources;

} ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS, *PARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS;

typedef struct _ARBITER_QUERY_CONFLICT_PARAMETERS {

    //
    // This is the device we are trying to find a conflict for
    //
    IN PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // This is the resource to find the conflict for
    //
    IN PIO_RESOURCE_DESCRIPTOR ConflictingResource;

    //
    // Number of devices conflicting on the resource
    //
    OUT PULONG ConflictCount;

    //
    // Pointer to array describing the conflicting device objects and ranges
    //
    OUT PARBITER_CONFLICT_INFO *Conflicts;

} ARBITER_QUERY_CONFLICT_PARAMETERS, *PARBITER_QUERY_CONFLICT_PARAMETERS;

typedef struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's - should have
    // only one entry
    //
    IN PLIST_ENTRY ArbitrationList;

} ARBITER_QUERY_ARBITRATE_PARAMETERS, *PARBITER_QUERY_ARBITRATE_PARAMETERS;

typedef struct _ARBITER_ADD_RESERVED_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's - should have
    // only one entry
    //
    IN PDEVICE_OBJECT ReserveDevice;

} ARBITER_ADD_RESERVED_PARAMETERS, *PARBITER_ADD_RESERVED_PARAMETERS;


typedef struct _ARBITER_PARAMETERS {

    union {

        ARBITER_TEST_ALLOCATION_PARAMETERS              TestAllocation;
        ARBITER_RETEST_ALLOCATION_PARAMETERS            RetestAllocation;
        ARBITER_BOOT_ALLOCATION_PARAMETERS              BootAllocation;
        ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS    QueryAllocatedResources;
        ARBITER_QUERY_CONFLICT_PARAMETERS               QueryConflict;
        ARBITER_QUERY_ARBITRATE_PARAMETERS              QueryArbitrate;
        ARBITER_ADD_RESERVED_PARAMETERS                 AddReserved;

    } Parameters;

} ARBITER_PARAMETERS, *PARBITER_PARAMETERS;

typedef enum _ARBITER_REQUEST_SOURCE {

    ArbiterRequestUndefined = -1,
    ArbiterRequestLegacyReported,   // IoReportResourceUsage
    ArbiterRequestHalReported,      // IoReportHalResourceUsage
    ArbiterRequestLegacyAssigned,   // IoAssignResources
    ArbiterRequestPnpDetected,      // IoReportResourceForDetection
    ArbiterRequestPnpEnumerated     // IRP_MN_QUERY_RESOURCE_REQUIREMENTS

} ARBITER_REQUEST_SOURCE;


typedef enum _ARBITER_RESULT {

    ArbiterResultUndefined = -1,
    ArbiterResultSuccess,
    ArbiterResultExternalConflict, // This indicates that the request can never be solved for devices in this list
    ArbiterResultNullRequest       // The request was for length zero and thus no translation should be attempted

} ARBITER_RESULT;

//
// ARBITER_FLAG_BOOT_CONFIG - this indicates that the request is for the
// resources assigned by the firmware/BIOS.  It should be succeeded even if
// it conflicts with another devices boot config.
//

#define ARBITER_FLAG_BOOT_CONFIG 0x00000001

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoReportResourceForDetection(
    __in PDRIVER_OBJECT DriverObject,
    __in_bcount_opt(DriverListSize) PCM_RESOURCE_LIST DriverList,
    __in_opt ULONG DriverListSize,
    __in_opt PDEVICE_OBJECT DeviceObject,
    __in_bcount_opt(DeviceListSize) PCM_RESOURCE_LIST DeviceList,
    __in_opt ULONG DeviceListSize,
    __out PBOOLEAN ConflictDetected
    );
#endif

typedef struct _ARBITER_LIST_ENTRY {

    //
    // This is a doubly linked list of entries for easy sorting
    //
    LIST_ENTRY ListEntry;

    //
    // The number of alternative allocation
    //
    ULONG AlternativeCount;

    //
    // Pointer to an array of resource descriptors for the possible allocations
    //
    PIO_RESOURCE_DESCRIPTOR Alternatives;

    //
    // The device object of the device requesting these resources.
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Indicates where the request came from
    //
    ARBITER_REQUEST_SOURCE RequestSource;

    //
    // Flags these indicate a variety of things (use ARBITER_FLAG_*)
    //
    ULONG Flags;

    //
    // Space to aid the arbiter in processing the list it is initialized to 0 when
    // the entry is created.  The system will not attempt to interpret it.
    //
    LONG_PTR WorkSpace;

    //
    // Interface Type, Slot Number and Bus Number from Resource Requirements list,
    // used only for reverse identification.
    //
    INTERFACE_TYPE InterfaceType;
    ULONG SlotNumber;
    ULONG BusNumber;

    //
    // A pointer to a descriptor to indicate the resource that was allocated.
    // This is allocated by the system and filled in by the arbiter in response to an
    // ArbiterActionTestAllocation.
    //
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Assignment;

    //
    // Pointer to the alternative that was chosen from to provide the assignment.
    // This is filled in by the arbiter in response to an ArbiterActionTestAllocation.
    //
    PIO_RESOURCE_DESCRIPTOR SelectedAlternative;

    //
    // The result of the operation
    // This is filled in by the arbiter in response to an ArbiterActionTestAllocation.
    //
    ARBITER_RESULT Result;

} ARBITER_LIST_ENTRY, *PARBITER_LIST_ENTRY;

//
// The arbiter's entry point
//

typedef
NTSTATUS
(*PARBITER_HANDLER) (
    __inout_opt PVOID Context,
    __in ARBITER_ACTION Action,
    __inout PARBITER_PARAMETERS Parameters
    );

//
// Arbiter interface
//

#define ARBITER_PARTIAL   0x00000001


typedef struct _ARBITER_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Entry point to the arbiter
    //
    PARBITER_HANDLER ArbiterHandler;

    //
    // Other information about the arbiter, use ARBITER_* flags
    //
    ULONG Flags;

} ARBITER_INTERFACE, *PARBITER_INTERFACE;

//
// The directions translation can take place in
//

typedef enum _RESOURCE_TRANSLATION_DIRECTION {
    TranslateChildToParent,
    TranslateParentToChild
} RESOURCE_TRANSLATION_DIRECTION;

//
// Translation functions
//

typedef
NTSTATUS
(*PTRANSLATE_RESOURCE_HANDLER)(
    __inout_opt PVOID Context,
    __in PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    __in RESOURCE_TRANSLATION_DIRECTION Direction,
    __in_opt ULONG AlternativesCount,
    __in_ecount_opt(AlternativesCount) IO_RESOURCE_DESCRIPTOR Alternatives[],
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __out PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

typedef
NTSTATUS
(*PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER)(
    __inout_opt PVOID Context,
    __in PIO_RESOURCE_DESCRIPTOR Source,
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __out PULONG TargetCount,
    __out_ecount(TargetCount) PIO_RESOURCE_DESCRIPTOR *Target
);

//
// Translator Interface
//

typedef struct _TRANSLATOR_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PTRANSLATE_RESOURCE_HANDLER TranslateResources;
    PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER TranslateResourceRequirements;
} TRANSLATOR_INTERFACE, *PTRANSLATOR_INTERFACE;

//
// The following function prototypes are for HAL routines with a prefix of Hal.
//
// General functions.
//

typedef
BOOLEAN
(*PHAL_RESET_DISPLAY_PARAMETERS) (
    __in ULONG Columns,
    __in ULONG Rows
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTHALAPI
VOID
HalAcquireDisplayOwnership (
    __in PHAL_RESET_DISPLAY_PARAMETERS ResetDisplayParameters
    );
#endif

#if defined(_IA64_)                             
                                                
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use GetDmaRequirement
NTHALAPI
ULONG
HalGetDmaAlignmentRequirement (
    VOID
    );
#endif

#endif                                          
                                                
#if defined(_M_IX86) || defined(_M_AMD64)       
                                                
#define HalGetDmaAlignmentRequirement() 1L      
#endif                                          
                                                
//
// I/O driver configuration functions.
//
#if !defined(NO_LEGACY_DRIVERS)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
NTHALAPI
NTSTATUS
HalAssignSlotResources (
    __in PUNICODE_STRING RegistryPath,
    __in PUNICODE_STRING DriverClassName OPTIONAL,
    __in PDRIVER_OBJECT DriverObject,
    __in PDEVICE_OBJECT DeviceObject,
    __in INTERFACE_TYPE BusType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __inout PCM_RESOURCE_LIST *AllocatedResources
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
NTHALAPI
ULONG
HalGetInterruptVector (
    __in INTERFACE_TYPE  InterfaceType,
    __in ULONG BusNumber,
    __in ULONG BusInterruptLevel,
    __in ULONG BusInterruptVector,
    __out PKIRQL Irql,
    __out PKAFFINITY Affinity
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalSetBusData (
    __in BUS_DATA_TYPE BusDataType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length
    );
#endif

#endif // NO_LEGACY_DRIVERS

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalSetBusDataByOffset (
    __in BUS_DATA_TYPE BusDataType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
BOOLEAN
HalTranslateBusAddress (
    __in INTERFACE_TYPE  InterfaceType,
    __in ULONG BusNumber,
    __in PHYSICAL_ADDRESS BusAddress,
    __inout PULONG AddressSpace,
    __out PPHYSICAL_ADDRESS TranslatedAddress
    );
#endif

//
// Values for AddressSpace parameter of HalTranslateBusAddress
//
//      0x0         - Memory space
//      0x1         - Port space
//      0x2 - 0x1F  - Address spaces specific for Alpha
//                      0x2 - UserMode view of memory space
//                      0x3 - UserMode view of port space
//                      0x4 - Dense memory space
//                      0x5 - reserved
//                      0x6 - UserMode view of dense memory space
//                      0x7 - 0x1F - reserved
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTHALAPI
PVOID
HalAllocateCrashDumpRegisters (
    __in PADAPTER_OBJECT AdapterObject,
    __inout PULONG NumberOfMapRegisters
    );
#endif

#if !defined(NO_LEGACY_DRIVERS)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalGetBusData (
    __in BUS_DATA_TYPE BusDataType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length
    );
#endif
#endif // NO_LEGACY_DRIVERS

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalGetBusDataByOffset (
    __in BUS_DATA_TYPE BusDataType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoGetDmaAdapter
NTHALAPI
PADAPTER_OBJECT
HalGetAdapter (
    __in PDEVICE_DESCRIPTION DeviceDescription,
    __out PULONG NumberOfMapRegisters
    );
#endif

//
// System beep functions.
//
#if !defined(NO_LEGACY_DRIVERS)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTHALAPI
BOOLEAN
HalMakeBeep(
    __in ULONG Frequency
    );
#endif
#endif // NO_LEGACY_DRIVERS

//
// The following function prototypes are for HAL routines with a prefix of Io.
//
// DMA adapter object functions.
//

typedef
PBUS_HANDLER
(FASTCALL *pHalHandlerForBus) (
    __in INTERFACE_TYPE InterfaceType,
    __in ULONG          BusNumber
    );
typedef
VOID
(FASTCALL *pHalReferenceBusHandler) (
    __in PBUS_HANDLER   BusHandler
    );

//-----------------------------------------------------------------------------
//      HAL Function dispatch
//

typedef enum _HAL_QUERY_INFORMATION_CLASS {
    HalInstalledBusInformation,
    HalProfileSourceInformation,
    HalInformationClassUnused1,
    HalPowerInformation,
    HalProcessorSpeedInformation,
    HalCallbackInformation,
    HalMapRegisterInformation,
    HalMcaLogInformation,               // Machine Check Abort Information
    HalFrameBufferCachingInformation,
    HalDisplayBiosInformation,
    HalProcessorFeatureInformation,
    HalNumaTopologyInterface,
    HalErrorInformation,                // General MCA, CMC, CPE Error Information.
    HalCmcLogInformation,               // Processor Corrected Machine Check Information
    HalCpeLogInformation,               // Corrected Platform Error Information
    HalQueryMcaInterface,
    HalQueryAMLIIllegalIOPortAddresses,
    HalQueryMaxHotPlugMemoryAddress,
    HalPartitionIpiInterface,
    HalPlatformInformation,
    HalQueryProfileSourceList,
    HalInitLogInformation,
    HalFrequencyInformation,
    HalProcessorBrandString
    // information levels >= 0x8000000 reserved for OEM use
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;


typedef enum _HAL_SET_INFORMATION_CLASS {
    HalProfileSourceInterval,
    HalProfileSourceInterruptHandler,  // Register performance monitor interrupt callback
    HalMcaRegisterDriver,              // Register Machine Check Abort driver
    HalKernelErrorHandler,
    HalCmcRegisterDriver,              // Register Processor Corrected Machine Check driver
    HalCpeRegisterDriver,              // Register Corrected Platform  Error driver
    HalMcaLog,
    HalCmcLog,
    HalCpeLog,
    HalGenerateCmcInterrupt,           // Used to test CMC
    HalProfileSourceTimerHandler,      // Resister profile timer interrupt callback
    HalEnlightenment,
    HalProfileDpgoSourceInterruptHandler  // Register performance monitor interrupt callback for dpgo
} HAL_SET_INFORMATION_CLASS, *PHAL_SET_INFORMATION_CLASS;



typedef
NTSTATUS
(*pHalQuerySystemInformation)(
    __in HAL_QUERY_INFORMATION_CLASS  InformationClass,
    __in ULONG     BufferSize,
    __inout PVOID Buffer,
    __out PULONG   ReturnedLength
    );


typedef
NTSTATUS
(*pHalSetSystemInformation)(
    __in HAL_SET_INFORMATION_CLASS    InformationClass,
    __in ULONG     BufferSize,
    __in PVOID     Buffer
    );


typedef
VOID
(FASTCALL *pHalExamineMBR)(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG SectorSize,
    __in ULONG MBRTypeIdentifier,
    __out PVOID *Buffer
    );

typedef
VOID
(FASTCALL *pHalIoAssignDriveLetters)(
    __in struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    __in PSTRING NtDeviceName,
    __out PUCHAR NtSystemPath,
    __out PSTRING NtSystemPathString
    );

typedef
NTSTATUS
(FASTCALL *pHalIoReadPartitionTable)(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG SectorSize,
    __in BOOLEAN ReturnRecognizedPartitions,
    __out struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

typedef
NTSTATUS
(FASTCALL *pHalIoSetPartitionInformation)(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG SectorSize,
    __in ULONG PartitionNumber,
    __in ULONG PartitionType
    );

typedef
NTSTATUS
(FASTCALL *pHalIoWritePartitionTable)(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG SectorSize,
    __in ULONG SectorsPerTrack,
    __in ULONG NumberOfHeads,
    __in struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

typedef
NTSTATUS
(*pHalQueryBusSlots)(
    __in PBUS_HANDLER         BusHandler,
    __in ULONG                BufferSize,
    __out PULONG              SlotNumbers,
    __out PULONG              ReturnedLength
    );

typedef
NTSTATUS
(*pHalInitPnpDriver)(
    VOID
    );


typedef struct _PM_DISPATCH_TABLE {
    ULONG   Signature;
    ULONG   Version;
    PVOID   Function[1];
} PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;



typedef
NTSTATUS
(*pHalInitPowerManagement)(
    __in PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    __out PPM_DISPATCH_TABLE *PmHalDispatchTable
    );


typedef
struct _DMA_ADAPTER *
(*pHalGetDmaAdapter)(
    __in PVOID Context,
    __in struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    __out PULONG NumberOfMapRegisters
    );


typedef
NTSTATUS
(*pHalGetInterruptTranslator)(
    __in INTERFACE_TYPE ParentInterfaceType,
    __in ULONG ParentBusNumber,
    __in INTERFACE_TYPE BridgeInterfaceType,
    __in USHORT Size,
    __in USHORT Version,
    __out PTRANSLATOR_INTERFACE Translator,
    __out PULONG BridgeBusNumber
    );


typedef
BOOLEAN
(*pHalTranslateBusAddress)(
    __in INTERFACE_TYPE  InterfaceType,
    __in ULONG BusNumber,
    __in PHYSICAL_ADDRESS BusAddress,
    __inout PULONG AddressSpace,
    __out PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef
NTSTATUS
(*pHalAssignSlotResources) (
    __in PUNICODE_STRING RegistryPath,
    __in PUNICODE_STRING DriverClassName OPTIONAL,
    __in PDRIVER_OBJECT DriverObject,
    __in PDEVICE_OBJECT DeviceObject,
    __in INTERFACE_TYPE BusType,
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __inout PCM_RESOURCE_LIST *AllocatedResources
    );

typedef
VOID
(*pHalHaltSystem) (
    VOID
    );

typedef
BOOLEAN
(*pHalResetDisplay) (
    VOID
    );



typedef struct _MAP_REGISTER_ENTRY {
    PVOID   MapRegister;
    BOOLEAN WriteToDevice;
} MAP_REGISTER_ENTRY, *PMAP_REGISTER_ENTRY;




typedef
UCHAR
(*pHalVectorToIDTEntry) (
    ULONG Vector
);

typedef
BOOLEAN
(*pHalFindBusAddressTranslation) (
    __in PHYSICAL_ADDRESS BusAddress,
    __inout PULONG AddressSpace,
    __out PPHYSICAL_ADDRESS TranslatedAddress,
    __inout PULONG_PTR Context,
    __in BOOLEAN NextBus
    );

typedef
NTSTATUS
(*pHalStartMirroring)(
    VOID
    );

typedef
NTSTATUS
(*pHalEndMirroring)(
    __in ULONG PassNumber
    );

typedef
NTSTATUS
(*pHalMirrorPhysicalMemory)(
    __in PHYSICAL_ADDRESS PhysicalAddress,
    __in LARGE_INTEGER NumberOfBytes
    );

typedef
NTSTATUS
(*pHalMirrorVerify)(
    __in PHYSICAL_ADDRESS PhysicalAddress,
    __in LARGE_INTEGER NumberOfBytes
    );


typedef struct {
    UCHAR     Type;  //CmResourceType
    BOOLEAN   Valid;
    UCHAR     Reserved[2];
    PUCHAR    TranslatedAddress;
    ULONG     Length;
} DEBUG_DEVICE_ADDRESS, *PDEBUG_DEVICE_ADDRESS;

typedef struct {
    PHYSICAL_ADDRESS  Start;
    PHYSICAL_ADDRESS  MaxEnd;
    PVOID             VirtualAddress;
    ULONG             Length;
    BOOLEAN           Cached;
    BOOLEAN           Aligned;
} DEBUG_MEMORY_REQUIREMENTS, *PDEBUG_MEMORY_REQUIREMENTS;

typedef struct {
    ULONG     Bus;
    USHORT    Segment;
    ULONG     Slot;
    USHORT    VendorID;
    USHORT    DeviceID;
    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    BOOLEAN   Initialized;
    BOOLEAN   Configured;
    DEBUG_DEVICE_ADDRESS BaseAddress[6];
    DEBUG_MEMORY_REQUIREMENTS   Memory;
} DEBUG_DEVICE_DESCRIPTOR, *PDEBUG_DEVICE_DESCRIPTOR;



typedef
NTSTATUS
(*pKdSetupPciDeviceForDebugging)(
    __in     PVOID                     LoaderBlock,   OPTIONAL
    __inout PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
NTSTATUS
(*pKdReleasePciDeviceForDebugging)(
    __inout PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
PVOID
(*pKdGetAcpiTablePhase0)(
    __in struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    __in ULONG Signature
    );

typedef
VOID
(*pKdCheckPowerButton)(
    VOID
    );

typedef
VOID
(*pHalEndOfBoot)(
    VOID
    );

typedef
ULONG
(*pHalGetInterruptVector)(
    __in INTERFACE_TYPE InterfaceType,
    __in ULONG BusNumber,
    __in ULONG BusInterruptLevel,
    __in ULONG BusInterruptVector,
    __out PKIRQL Irql,
    __out PKAFFINITY Affinity
    );

typedef
NTSTATUS
(*pHalGetVectorInput)(
    __in ULONG Vector,
    __in KAFFINITY Affinity,
    __out PULONG Input,
    __out PKINTERRUPT_POLARITY Polarity
    );

typedef
PVOID
(*pKdMapPhysicalMemory64)(
    __in PHYSICAL_ADDRESS PhysicalAddress,
    __in ULONG NumberPages,
    __in BOOLEAN FlushCurrentTLB
    );

typedef
VOID
(*pKdUnmapVirtualAddress)(
    __in PVOID VirtualAddress,
    __in ULONG NumberPages,
    __in BOOLEAN FlushCurrentTLB
    );

typedef
ULONG
(*pKdGetPciDataByOffset)(
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

typedef
ULONG
(*pKdSetPciDataByOffset)(
    __in ULONG BusNumber,
    __in ULONG SlotNumber,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

typedef
NTSTATUS
(*pHalLoadMicrocode)(
    __in PVOID ImageHandle
    );

typedef
NTSTATUS
(*pHalUnloadMicrocode)(
    VOID
    );

typedef
NTSTATUS
(*pHalPostMicrocodeUpdate)(
    VOID
    );

typedef
NTSTATUS
(*pHalAllocateMessageTarget)(
    __in PDEVICE_OBJECT Owner,
    __in KAFFINITY ProcessorSet,
    __in ULONG NumberOfIdtEntries,
    __in KINTERRUPT_MODE Mode,
    __in BOOLEAN ShareVector,
    __out PULONG Vector,
    __out PKIRQL Irql,
    __out PULONG IdtEntry
    );

typedef
VOID
(*pHalFreeMessageTarget)(
    __in PDEVICE_OBJECT Owner,
    __in ULONG Vector,
    __in KAFFINITY ProcessorSet
    );

typedef
PVOID
(*pHalGetAcpiTable)(
    __in ULONG Signature,
    __in_opt PCSTR OemId,
    __in_opt PCSTR OemTableId
    );

#if defined(_IA64_)
typedef
NTSTATUS
(*pHalGetErrorCapList)(
    __inout PULONG CapsListLength,
    __inout_bcount(*CapsListLength) PUCHAR ErrorCapList
    );

typedef
NTSTATUS
(*pHalInjectError)(
    __in ULONG BufferLength,
    __in_bcount(BufferLength) PUCHAR Buffer
    );
#endif

typedef
VOID
(*PCI_ERROR_HANDLER_CALLBACK)(
    VOID
    );

typedef
VOID
(*pHalSetPciErrorHandlerCallback)(
    __in PCI_ERROR_HANDLER_CALLBACK Callback
    );




typedef struct {
    ULONG                           Version;
    pHalQuerySystemInformation      HalQuerySystemInformation;
    pHalSetSystemInformation        HalSetSystemInformation;
    pHalQueryBusSlots               HalQueryBusSlots;
    ULONG                           Spare1;
    pHalExamineMBR                  HalExamineMBR;
    pHalIoAssignDriveLetters        HalIoAssignDriveLetters;
    pHalIoReadPartitionTable        HalIoReadPartitionTable;
    pHalIoSetPartitionInformation   HalIoSetPartitionInformation;
    pHalIoWritePartitionTable       HalIoWritePartitionTable;

    pHalHandlerForBus               HalReferenceHandlerForBus;
    pHalReferenceBusHandler         HalReferenceBusHandler;
    pHalReferenceBusHandler         HalDereferenceBusHandler;

    pHalInitPnpDriver               HalInitPnpDriver;
    pHalInitPowerManagement         HalInitPowerManagement;

    pHalGetDmaAdapter               HalGetDmaAdapter;
    pHalGetInterruptTranslator      HalGetInterruptTranslator;

    pHalStartMirroring              HalStartMirroring;
    pHalEndMirroring                HalEndMirroring;
    pHalMirrorPhysicalMemory        HalMirrorPhysicalMemory;
    pHalEndOfBoot                   HalEndOfBoot;
    pHalMirrorVerify                HalMirrorVerify;

    pHalGetAcpiTable                HalGetCachedAcpiTable;
    pHalSetPciErrorHandlerCallback  HalSetPciErrorHandlerCallback;

#if defined(_IA64_)
    pHalGetErrorCapList             HalGetErrorCapList;
    pHalInjectError                 HalInjectError;
#endif

} HAL_DISPATCH, *PHAL_DISPATCH;



#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_DISPATCH   HalDispatchTable;
#define HALDISPATCH     HalDispatchTable

#else

extern  HAL_DISPATCH    HalDispatchTable;
#define HALDISPATCH     (&HalDispatchTable)

#endif

#define HAL_DISPATCH_VERSION        3

#define HalDispatchTableVersion         HALDISPATCH->Version
#define HalQuerySystemInformation       HALDISPATCH->HalQuerySystemInformation
#define HalSetSystemInformation         HALDISPATCH->HalSetSystemInformation
#define HalQueryBusSlots                HALDISPATCH->HalQueryBusSlots

#define HalReferenceHandlerForBus       HALDISPATCH->HalReferenceHandlerForBus
#define HalReferenceBusHandler          HALDISPATCH->HalReferenceBusHandler
#define HalDereferenceBusHandler        HALDISPATCH->HalDereferenceBusHandler

#define HalInitPnpDriver                HALDISPATCH->HalInitPnpDriver
#define HalInitPowerManagement          HALDISPATCH->HalInitPowerManagement

#define HalGetDmaAdapter                HALDISPATCH->HalGetDmaAdapter
#define HalGetInterruptTranslator       HALDISPATCH->HalGetInterruptTranslator

#define HalStartMirroring               HALDISPATCH->HalStartMirroring
#define HalEndMirroring                 HALDISPATCH->HalEndMirroring
#define HalMirrorPhysicalMemory         HALDISPATCH->HalMirrorPhysicalMemory
#define HalEndOfBoot                    HALDISPATCH->HalEndOfBoot
#define HalMirrorVerify                 HALDISPATCH->HalMirrorVerify

#define HalGetCachedAcpiTable           HALDISPATCH->HalGetCachedAcpiTable
#define HalSetPciErrorHandlerCallback   HALDISPATCH->HalSetPciErrorHandlerCallback

#if defined(_IA64_)
#define HalGetErrorCapList              HALDISPATCH->HalGetErrorCapList
#define HalInjectError                  HALDISPATCH->HalInjectError
#endif


//
// HAL System Information Structures.
//

// for the information class "HalInstalledBusInformation"
typedef struct _HAL_BUS_INFORMATION{
    INTERFACE_TYPE  BusType;
    BUS_DATA_TYPE   ConfigurationType;
    ULONG           BusNumber;
    ULONG           Reserved;
} HAL_BUS_INFORMATION, *PHAL_BUS_INFORMATION;

// for the information class "HalProfileSourceInformation"
typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
    KPROFILE_SOURCE Source;
    BOOLEAN Supported;
    ULONG Interval;
} HAL_PROFILE_SOURCE_INFORMATION, *PHAL_PROFILE_SOURCE_INFORMATION;

// for the information class "HalProfileSourceInformation"
typedef struct _HAL_PROFILE_SOURCE_INFORMATION_EX {
    KPROFILE_SOURCE Source;
    BOOLEAN         Supported;
    ULONG_PTR       Interval;
    ULONG_PTR       DefInterval;
    ULONG_PTR       MaxInterval;
    ULONG_PTR       MinInterval;
} HAL_PROFILE_SOURCE_INFORMATION_EX, *PHAL_PROFILE_SOURCE_INFORMATION_EX;

// for the information class "HalProfileSourceInterval"
typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
    KPROFILE_SOURCE Source;
    ULONG_PTR Interval;
} HAL_PROFILE_SOURCE_INTERVAL, *PHAL_PROFILE_SOURCE_INTERVAL;

// for the information class "HalQueryProfileSourceList"
typedef struct _HAL_PROFILE_SOURCE_LIST {
    KPROFILE_SOURCE Source;
    PWSTR Description;
} HAL_PROFILE_SOURCE_LIST, *PHAL_PROFILE_SOURCE_LIST;

// for the information class "HalDispayBiosInformation"
typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
    HalDisplayInt10Bios,
    HalDisplayEmulatedBios,
    HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION, *PHAL_DISPLAY_BIOS_INFORMATION;

// for the information class "HalPowerInformation"
typedef struct _HAL_POWER_INFORMATION {
    ULONG   TBD;
} HAL_POWER_INFORMATION, *PHAL_POWER_INFORMATION;

// for the information class "HalProcessorSpeedInformation"
typedef struct _HAL_PROCESSOR_SPEED_INFO {
    ULONG   ProcessorSpeed;
} HAL_PROCESSOR_SPEED_INFORMATION, *PHAL_PROCESSOR_SPEED_INFORMATION;

// for the information class "HalCallbackInformation"
typedef struct _HAL_CALLBACKS {
    PCALLBACK_OBJECT  SetSystemInformation;
    PCALLBACK_OBJECT  BusCheck;
} HAL_CALLBACKS, *PHAL_CALLBACKS;

// for the information class "HalProcessorFeatureInformation"
typedef struct _HAL_PROCESSOR_FEATURE {
    ULONG UsableFeatureBits;
} HAL_PROCESSOR_FEATURE;


typedef
NTSTATUS
(*PHALIOREADWRITEHANDLER)(
    __in      BOOLEAN fRead,
    __in      ULONG dwAddr,
    __in      ULONG dwSize,
    __inout  PULONG pdwData
    );



// for the information class "HalQueryIllegalIOPortAddresses"
typedef struct _HAL_AMLI_BAD_IO_ADDRESS_LIST
{
    ULONG                   BadAddrBegin;
    ULONG                   BadAddrSize;
    ULONG                   OSVersionTrigger;
    PHALIOREADWRITEHANDLER  IOHandler;
} HAL_AMLI_BAD_IO_ADDRESS_LIST, *PHAL_AMLI_BAD_IO_ADDRESS_LIST;




#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

//
// HalQueryMcaInterface
//

typedef
VOID
(*PHALMCAINTERFACELOCK)(
    VOID
    );

typedef
VOID
(*PHALMCAINTERFACEUNLOCK)(
    VOID
    );

typedef
NTSTATUS
(*PHALMCAINTERFACEREADREGISTER)(
    __in     UCHAR    BankNumber,
    __inout PVOID    Exception
    );


typedef struct _HAL_MCA_INTERFACE {
    PHALMCAINTERFACELOCK            Lock;
    PHALMCAINTERFACEUNLOCK          Unlock;
    PHALMCAINTERFACEREADREGISTER    ReadRegister;
} HAL_MCA_INTERFACE;

typedef enum {
    ApicDestinationModePhysical = 1,
    ApicDestinationModeLogicalFlat,
    ApicDestinationModeLogicalClustered,
    ApicDestinationModeUnknown
} HAL_APIC_DESTINATION_MODE, *PHAL_APIC_DESTINATION_MODE;


#if defined(_AMD64_)

struct _KTRAP_FRAME;
struct _KEXCEPTION_FRAME;

typedef
ERROR_SEVERITY
(*PDRIVER_EXCPTN_CALLBACK) (
    __in PVOID Context,
    __in struct _KTRAP_FRAME *TrapFrame,
    __in struct _KEXCEPTION_FRAME *ExceptionFrame,
    __in PMCA_EXCEPTION Exception
);

#endif

#if defined(_X86_) || defined(_IA64_)

typedef
#if defined(_IA64_)
ERROR_SEVERITY
#else
VOID
#endif
(*PDRIVER_EXCPTN_CALLBACK) (
    __in PVOID Context,
    __in PMCA_EXCEPTION BankLog
);

#endif

typedef PDRIVER_EXCPTN_CALLBACK  PDRIVER_MCA_EXCEPTION_CALLBACK;


//
// Structure to record the callbacks from driver
//

typedef struct _MCA_DRIVER_INFO {
    PDRIVER_MCA_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} MCA_DRIVER_INFO, *PMCA_DRIVER_INFO;



typedef struct _HAL_ERROR_INFO {
    ULONG     Version;                 // Version of this structure
    ULONG     InitMaxSize;             // Maximum size of the INIT record.
    ULONG     McaMaxSize;              // Maximum size of a Machine Check Abort record
    ULONG     McaPreviousEventsCount;  // Flag indicating previous or early-boot MCA event logs.
    ULONG     McaCorrectedEventsCount; // Number of corrected MCA events since boot.      approx.
    ULONG     McaKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     McaDriverDpcQueueFails;  // Number of OEM MCA Driver Dpc queueing failures. approx.
    ULONG     McaReserved;
    ULONG     CmcMaxSize;              // Maximum size of a Corrected Machine  Check record
    ULONG     CmcPollingInterval;      // In units of seconds
    ULONG     CmcInterruptsCount;      // Number of CMC interrupts.                       approx.
    ULONG     CmcKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     CmcDriverDpcQueueFails;  // Number of OEM CMC Driver Dpc queueing failures. approx.
    ULONG     CmcGetStateFails;        // Number of failures in getting  the log from FW.
    ULONG     CmcClearStateFails;      // Number of failures in clearing the log from FW.
    ULONG     CmcReserved;
    ULONGLONG CmcLogId;                // Last seen record identifier.
    ULONG     CpeMaxSize;              // Maximum size of a Corrected Platform Event record
    ULONG     CpePollingInterval;      // In units of seconds
    ULONG     CpeInterruptsCount;      // Number of CPE interrupts.                       approx.
    ULONG     CpeKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     CpeDriverDpcQueueFails;  // Number of OEM CPE Driver Dpc queueing failures. approx.
    ULONG     CpeGetStateFails;        // Number of failures in getting  the log from FW.
    ULONG     CpeClearStateFails;      // Number of failures in clearing the log from FW.
    ULONG     CpeInterruptSources;     // Number of SAPIC Platform Interrupt Sources
    ULONGLONG CpeLogId;                // Last seen record identifier.
    ULONGLONG KernelReserved[4];
} HAL_ERROR_INFO, *PHAL_ERROR_INFO;



#define HAL_MCE_INTERRUPTS_BASED ((ULONG)-1)
#define HAL_MCE_DISABLED          ((ULONG)0)

//
// Known values for HAL_ERROR_INFO.CmcPollingInterval.
//

#define HAL_CMC_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_CMC_DISABLED          HAL_MCE_DISABLED

//
// Known values for HAL_ERROR_INFO.CpePollingInterval.
//

#define HAL_CPE_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_CPE_DISABLED          HAL_MCE_DISABLED

#define HAL_MCA_INTERRUPTS_BASED  HAL_MCE_INTERRUPTS_BASED
#define HAL_MCA_DISABLED          HAL_MCE_DISABLED



//
// Driver Callback type for the information class "HalCmcRegisterDriver"
//

typedef
VOID
(*PDRIVER_CMC_EXCEPTION_CALLBACK) (
    __in PVOID            Context,
    __in PCMC_EXCEPTION   CmcLog
);

//
// Driver Callback type for the information class "HalCpeRegisterDriver"
//

typedef
VOID
(*PDRIVER_CPE_EXCEPTION_CALLBACK) (
    __in PVOID            Context,
    __in PCPE_EXCEPTION   CmcLog
);


//
//
// Structure to record the callbacks from driver
//

typedef struct _CMC_DRIVER_INFO {
    PDRIVER_CMC_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} CMC_DRIVER_INFO, *PCMC_DRIVER_INFO;

typedef struct _CPE_DRIVER_INFO {
    PDRIVER_CPE_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} CPE_DRIVER_INFO, *PCPE_DRIVER_INFO;



#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)



#if defined(_IA64_)

typedef
NTSTATUS
(*HALSENDCROSSPARTITIONIPI)(
    __in USHORT ProcessorID,
    __in UCHAR  HardwareVector
    );

typedef
NTSTATUS
(*HALRESERVECROSSPARTITIONINTERRUPTVECTOR)(
    __out PULONG Vector,
    __out PKIRQL Irql,
    __inout PKAFFINITY Affinity,
    __out PUCHAR HardwareVector
    );

typedef
VOID
(*HALFREECROSSPARTITIONINTERRUPTVECTOR)(
    __in ULONG Vector,
    __in KAFFINITY Affinity
    );

typedef struct _HAL_CROSS_PARTITION_IPI_INTERFACE {
    HALSENDCROSSPARTITIONIPI HalSendCrossPartitionIpi;
    HALRESERVECROSSPARTITIONINTERRUPTVECTOR HalReserveCrossPartitionInterruptVector;
    HALFREECROSSPARTITIONINTERRUPTVECTOR HalFreeCrossPartitionInterruptVector;
} HAL_CROSS_PARTITION_IPI_INTERFACE;

#define HAL_CROSS_PARTITION_IPI_INTERFACE_MINIMUM_SIZE \
    FIELD_OFFSET(HAL_CROSS_PARTITION_IPI_INTERFACE,    \
                 HalFreeCrossPartitionInterruptVector)

#endif

typedef struct _HAL_PLATFORM_INFORMATION {
    ULONG PlatformFlags;
} HAL_PLATFORM_INFORMATION, *PHAL_PLATFORM_INFORMATION;



//
// These platform flags are carried over from the IPPT table
// definition if appropriate.
//

#define HAL_PLATFORM_DISABLE_WRITE_COMBINING      0x01L
#define HAL_PLATFORM_DISABLE_PTCG                 0x04L
#define HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY       0x08L
#define HAL_PLATFORM_ENABLE_WRITE_COMBINING_MMIO  0x10L
#define HAL_PLATFORM_ACPI_TABLES_CACHED           0x20L



#if defined(_WIN64)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64

#if defined(USE_DMA_MACROS) && !defined(_NTHAL_) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_) 

#else

//
// DMA adapter object functions.
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
NTHALAPI
NTSTATUS
HalAllocateAdapterChannel(
    __in PADAPTER_OBJECT AdapterObject,
    __in PWAIT_CONTEXT_BLOCK Wcb,
    __in ULONG NumberOfMapRegisters,
    __in PDRIVER_CONTROL ExecutionRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
NTHALAPI
PVOID
HalAllocateCommonBuffer(
    __in PADAPTER_OBJECT AdapterObject,
    __in ULONG Length,
    __out PPHYSICAL_ADDRESS LogicalAddress,
    __in BOOLEAN CacheEnabled
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
NTHALAPI
VOID
HalFreeCommonBuffer(
    __in PADAPTER_OBJECT AdapterObject,
    __in ULONG Length,
    __in PHYSICAL_ADDRESS LogicalAddress,
    __in PVOID VirtualAddress,
    __in BOOLEAN CacheEnabled
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
NTHALAPI
ULONG
HalReadDmaCounter(
    __in PADAPTER_OBJECT AdapterObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
NTHALAPI
BOOLEAN
IoFlushAdapterBuffers(
    __in PADAPTER_OBJECT AdapterObject,
    __in PMDL Mdl,
    __in PVOID MapRegisterBase,
    __in PVOID CurrentVa,
    __in ULONG Length,
    __in BOOLEAN WriteToDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
NTHALAPI
VOID
IoFreeAdapterChannel(
    __in PADAPTER_OBJECT AdapterObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
NTHALAPI
VOID
IoFreeMapRegisters(
   __in PADAPTER_OBJECT AdapterObject,
   __in PVOID MapRegisterBase,
   __in ULONG NumberOfMapRegisters
   );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
NTHALAPI
PHYSICAL_ADDRESS
IoMapTransfer(
    __in PADAPTER_OBJECT AdapterObject,
    __in PMDL Mdl,
    __in PVOID MapRegisterBase,
    __in PVOID CurrentVa,
    __inout PULONG Length,
    __in BOOLEAN WriteToDevice
    );
#endif

#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_)



#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTSTATUS
HalGetScatterGatherList (               // Use GetScatterGatherList
    __in PADAPTER_OBJECT DmaAdapter,
    __in PDEVICE_OBJECT DeviceObject,
    __in PMDL Mdl,
    __in PVOID CurrentVa,
    __in ULONG Length,
    __in PDRIVER_LIST_CONTROL ExecutionRoutine,
    __in PVOID Context,
    __in BOOLEAN WriteToDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use PutScatterGatherList
VOID
HalPutScatterGatherList (
    __in PADAPTER_OBJECT DmaAdapter,
    __in PSCATTER_GATHER_LIST ScatterGather,
    __in BOOLEAN WriteToDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use PutDmaAdapter
VOID
HalPutDmaAdapter(
    __in PADAPTER_OBJECT DmaAdapter
    );
#endif

NTHALAPI
VOID
HalBugCheckSystem(
    __in PVOID ErrorRecord
    );


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PoSetSystemState (
    __in EXECUTION_STATE Flags
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
PoRegisterSystemState (
    __inout_opt PVOID StateHandle,
    __in EXECUTION_STATE Flags
    );
#endif



typedef
VOID
(*PREQUEST_POWER_COMPLETE) (
    __in PDEVICE_OBJECT DeviceObject,
    __in UCHAR MinorFunction,
    __in POWER_STATE PowerState,
    __in_opt PVOID Context,
    __in PIO_STATUS_BLOCK IoStatus
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PoRequestPowerIrp (
    __in PDEVICE_OBJECT DeviceObject,
    __in UCHAR MinorFunction,
    __in POWER_STATE PowerState,
    __in_opt PREQUEST_POWER_COMPLETE CompletionFunction,
    __in_opt PVOID Context,
    __out_opt PIRP *Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
PoSetSystemWake (
    __inout PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
BOOLEAN
PoGetSystemWake (
    __in PIRP Irp
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PoUnregisterSystemState (
    __in PVOID StateHandle
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
POWER_STATE
PoSetPowerState (
    __in PDEVICE_OBJECT   DeviceObject,
    __in POWER_STATE_TYPE Type,
    __in POWER_STATE      State
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PoCallDriver (
    __in PDEVICE_OBJECT DeviceObject,
    __inout PIRP        Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PoStartNextPowerIrp(
    __in PIRP   Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PULONG
PoRegisterDeviceForIdleDetection (
    __in PDEVICE_OBJECT     DeviceObject,
    __in ULONG              ConservationIdleTime,
    __in ULONG              PerformanceIdleTime,
    __in DEVICE_POWER_STATE State
    );
#endif

#define PoSetDeviceBusy(IdlePointer) \
    *IdlePointer = 0
    
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
NTKERNELAPI
VOID
PoSetDeviceBusyEx (
    __inout PULONG IdlePointer
    );
#endif

typedef NTSTATUS (*PPOWER_SETTING_CALLBACK) (  
    IN LPCGUID SettingGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN PVOID Context
);

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
PoRegisterPowerSettingCallback (
    __in_opt PDEVICE_OBJECT         DeviceObject,
    __in LPCGUID                    SettingGuid,
    __in PPOWER_SETTING_CALLBACK    Callback,
    __in_opt PVOID                  Context,
    __out_opt PVOID                 * Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
PoUnregisterPowerSettingCallback(
    __inout PVOID   Handle
    );
#endif

//
// \Callback\PowerState values
//

#define PO_CB_SYSTEM_POWER_POLICY       0
#define PO_CB_AC_STATUS                 1
#define PO_CB_BUTTON_COLLISION          2
#define PO_CB_SYSTEM_STATE_LOCK         3
#define PO_CB_LID_SWITCH_STATE          4
#define PO_CB_PROCESSOR_POWER_POLICY    5

//
// Determine if there is a complete device failure on an error.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlIsTotalDeviceFailure(
    __in NTSTATUS Status
    );
#endif


//
// AGP Capabilities
//
typedef struct _PCI_AGP_CAPABILITY {
    
    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Agp3Mode:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   HostTransDisable:1;
        ULONG   Gart64:1;
        ULONG   ITA_Coherent:1;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   CalibrationCycle:3;
        ULONG   AsyncRequestSize:3;
        ULONG   Rsvd1:1;
        ULONG   Isoch:1;
        ULONG   Rsvd2:6;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:1;
        ULONG   Gart64:1;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   CalibrationCycle:3;
        ULONG   AsyncReqSize:3;
        ULONG   Rsvd3:8;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

//
// An AGPv3 Target must have an extended capability,
// but it's only present for a Master when the Isoch
// bit is set in its status register
//
typedef enum _EXTENDED_AGP_REGISTER {
    IsochStatus,
    AgpControl,
    ApertureSize,
    AperturePageSize,
    GartLow,
    GartHigh,
    IsochCommand
} EXTENDED_AGP_REGISTER, *PEXTENDED_AGP_REGISTER;

typedef struct _PCI_AGP_ISOCH_STATUS {
    ULONG ErrorCode: 2;
    ULONG Rsvd1: 1;
    ULONG Isoch_L: 3;
    ULONG Isoch_Y: 2;
    ULONG Isoch_N: 8;
    ULONG Rsvd2: 16;
} PCI_AGP_ISOCH_STATUS, *PPCI_AGP_ISOCH_STATUS;

typedef struct _PCI_AGP_CONTROL {
    ULONG Rsvd1: 7;
    ULONG GTLB_Enable: 1;
    ULONG AP_Enable: 1;
    ULONG CAL_Disable: 1;
    ULONG Rsvd2: 22;
} PCI_AGP_CONTROL, *PPCI_AGP_CONTROL;

typedef struct _PCI_AGP_APERTURE_PAGE_SIZE {
    USHORT PageSizeMask: 11;
    USHORT Rsvd1: 1;
    USHORT PageSizeSelect: 4;
} PCI_AGP_APERTURE_PAGE_SIZE, *PPCI_AGP_APERTURE_PAGE_SIZE;

typedef struct _PCI_AGP_ISOCH_COMMAND {
    USHORT Rsvd1: 6;
    USHORT Isoch_Y: 2;
    USHORT Isoch_N: 8;
} PCI_AGP_ISOCH_COMMAND, *PPCI_AGP_ISOCH_COMMAND;

typedef struct PCI_AGP_EXTENDED_CAPABILITY {

    PCI_AGP_ISOCH_STATUS IsochStatus;

//
// Target only ----------------<<-begin->>
//
    PCI_AGP_CONTROL AgpControl;
    USHORT ApertureSize;
    PCI_AGP_APERTURE_PAGE_SIZE AperturePageSize;
    ULONG GartLow;
    ULONG GartHigh;
//
// ------------------------------<<-end->>
//

    PCI_AGP_ISOCH_COMMAND IsochCommand;

} PCI_AGP_EXTENDED_CAPABILITY, *PPCI_AGP_EXTENDED_CAPABILITY;


#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4


//
// PCI-X Bridge Capability
//

//
// Values for BusModeFrequency in the SecondaryStatus register
//
#define PCIX_MODE_CONVENTIONAL_PCI  0x0
#define PCIX_MODE1_66MHZ            0x1
#define PCIX_MODE1_100MHZ           0x2
#define PCIX_MODE1_133MHZ           0x3
#define PCIX_MODE2_266_66MHZ        0x9
#define PCIX_MODE2_266_100MHZ       0xA
#define PCIX_MODE2_266_133MHZ       0xB
#define PCIX_MODE2_533_66MHZ        0xD
#define PCIX_MODE2_533_100MHZ       0xE
#define PCIX_MODE2_533_133MHZ       0xF

//
// Values for the Version in the SecondaryStatus register
//
#define PCIX_VERSION_MODE1_ONLY     0x0
#define PCIX_VERSION_MODE2_ECC      0x1
#define PCIX_VERSION_DUAL_MODE_ECC  0x2

typedef struct _PCIX_BRIDGE_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    union {
        struct {
            USHORT Bus64Bit:1;
            USHORT Bus133MHzCapable:1;
            USHORT SplitCompletionDiscarded:1;
            USHORT UnexpectedSplitCompletion:1;
            USHORT SplitCompletionOverrun:1;
            USHORT SplitRequestDelayed:1;
            USHORT BusModeFrequency:4;  // PCIX_MODE_x
            USHORT Rsvd:2;
            USHORT Version:2;           // PCIX_VERSION_x
            USHORT Bus266MHzCapable:1;
            USHORT Bus533MHzCapable:1;
        } DUMMYSTRUCTNAME;
        USHORT AsUSHORT;
    } SecondaryStatus;
    
    union {
        struct {
            ULONG FunctionNumber:3;
            ULONG DeviceNumber:5;
            ULONG BusNumber:8;
            ULONG Device64Bit:1;
            ULONG Device133MHzCapable:1;
            ULONG SplitCompletionDiscarded:1;
            ULONG UnexpectedSplitCompletion:1;
            ULONG SplitCompletionOverrun:1;
            ULONG SplitRequestDelayed:1;
            ULONG Rsvd:7;
            ULONG DIMCapable:1;
            ULONG Device266MHzCapable:1;
            ULONG Device533MHzCapable:1;
        } DUMMYSTRUCTNAME;
        ULONG AsULONG;
    } BridgeStatus;

    USHORT UpstreamSplitTransactionCapacity;
    USHORT UpstreamSplitTransactionLimit;

    USHORT DownstreamSplitTransactionCapacity;
    USHORT DownstreamSplitTransactionLimit;

    union {
        struct {
            ULONG SelectSecondaryRegisters:1;
            ULONG ErrorPresentInOtherBank:1;
            ULONG AdditionalCorrectableError:1;
            ULONG AdditionalUncorrectableError:1;
            ULONG ErrorPhase:3;
            ULONG ErrorCorrected:1;
            ULONG Syndrome:8;
            ULONG ErrorFirstCommand:4;
            ULONG ErrorSecondCommand:4;
            ULONG ErrorUpperAttributes:4;
            ULONG ControlUpdateEnable:1;
            ULONG Rsvd:1;
            ULONG DisableSingleBitCorrection:1;
            ULONG EccMode:1;
        } DUMMYSTRUCTNAME;
        ULONG AsULONG;
    } EccControlStatus;
    
    ULONG EccFirstAddress;
    ULONG EccSecondAddress;
    ULONG EccAttribute;

} PCIX_BRIDGE_CAPABILITY, *PPCIX_BRIDGE_CAPABILITY;

//
// PCI to PCI Bridge Subsystem ID Capability
//
typedef struct _PCI_SUBSYSTEM_IDS_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;
    USHORT Reserved;
    USHORT SubVendorID;
    USHORT SubSystemID;

} PCI_SUBSYSTEM_IDS_CAPABILITY, *PPCI_SUBSYSTEM_IDS_CAPABILITY;

//
// _OSC is used by OSPM to query the capabilities of a device and to 
// communicate the features supported by the device driver to the platform.
// The _OSC interface for PCI host bridge devices that originate PCI, PCI-X or
// PCI Express hierarchies is identified by a UUID of {33db4d5b-1ff7-401c-9657-
// 7441c03dd766}. A revision ID of 1 indicates that the capabilities buffer is
// composed of 3 DWORDs.
// The first DWORD is common across all OSC implementations and includes status
// and error information.
// The second DWORD (Support Field) provides information regarding OS supported 
// features.
// The third DWORD (Control Field) is used to submit request for control of 
// associated features. If any bits in the control field are returned cleared,
// then the respective feature is unsupported by the platform and must not be
// enabled.
// According to the PCI Firmware Specification a machine with multiple host 
// bridge devices should report the same capabilities for all host bridges
// and also negotiate control of the features in the same way.
//

#define OSC_FIRMWARE_FAILURE                            0x02
#define OSC_UNRECOGNIZED_UUID                           0x04
#define OSC_UNRECOGNIZED_REVISION                       0x08
#define OSC_CAPABILITIES_MASKED                         0x10

#define PCI_ROOT_BUS_OSC_METHOD_CAPABILITY_REVISION     0x01

//
// The following declarations pertain to the second and third DWORD in
// evaluation of _OSC for PCI host bridge devices.
//

typedef struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD {
    union {
        struct {
            ULONG ExtendedConfigOpRegions:1;
            ULONG ActiveStatePowerManagement:1;
            ULONG ClockPowerManagement:1;
            ULONG SegmentGroups:1;
            ULONG MessageSignaledInterrupts:1;
            ULONG WindowsHardwareErrorArchitecture:1;
            ULONG Reserved:26;
        } DUMMYSTRUCTNAME;
        ULONG AsULONG;
    } u;
} PCI_ROOT_BUS_OSC_SUPPORT_FIELD, *PPCI_ROOT_BUS_OSC_SUPPORT_FIELD;

typedef struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD {
    union {
        struct {
            ULONG ExpressNativeHotPlug:1;
            ULONG ShpcNativeHotPlug:1;
            ULONG ExpressNativePME:1;
            ULONG ExpressAdvancedErrorReporting:1;
            ULONG ExpressCapabilityStructure:1;
            ULONG Reserved:27;
        } DUMMYSTRUCTNAME;
        ULONG AsULONG;
    } u;
} PCI_ROOT_BUS_OSC_CONTROL_FIELD, *PPCI_ROOT_BUS_OSC_CONTROL_FIELD;

//
// An enumerator for the PCI physical and electrical interface.
//

typedef enum _PCI_HARDWARE_INTERFACE {

    PciConventional,
    PciXMode1,
    PciXMode2,
    PciExpress

} PCI_HARDWARE_INTERFACE, *PPCI_HARDWARE_INTERFACE;

typedef enum {

    BusWidth32Bits,
    BusWidth64Bits

} PCI_BUS_WIDTH;

typedef struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY {

    //
    // Describes the secondary side of a PCI root bus.
    //

    PCI_HARDWARE_INTERFACE SecondaryInterface;

    //
    // These additional capabilities are available when each of the following
    // is true.
    // 1. The secondary side of a PCI root bus operates in conventional or
    //    PCI-X mode.
    // 2. The PCI root bus has a hardware ID or compatible ID of PNP0A03.
    // 3. A _DSM function 4 is defined for the root bus.
    //

    struct {

        //
        // This boolean indicates if the remaining fields describing the bus
        // capabilities are valid or not.
        //

        BOOLEAN BusCapabilitiesFound;


        //
        // Provides information on current and supported speeds/modes.
        //

        ULONG CurrentSpeedAndMode;
        ULONG SupportedSpeedsAndModes;

        //
        // Describes the root bus capability on forwarding of Device ID message
        // transactions.
        //

        BOOLEAN DeviceIDMessagingCapable;

        //
        // Provides the width for a PCI interface.
        //

        PCI_BUS_WIDTH SecondaryBusWidth;
    } DUMMYSTRUCTNAME;

    //
    // Fields describing features supported as well as control for them from
    // the bios.
    //

    PCI_ROOT_BUS_OSC_SUPPORT_FIELD OscFeatureSupport;
    PCI_ROOT_BUS_OSC_CONTROL_FIELD OscControlRequest;
    PCI_ROOT_BUS_OSC_CONTROL_FIELD OscControlGranted;

} PCI_ROOT_BUS_HARDWARE_CAPABILITY, *PPCI_ROOT_BUS_HARDWARE_CAPABILITY;

//
// PCI Express Capability
//

typedef union _PCI_EXPRESS_CAPABILITIES_REGISTER {

    struct {

        USHORT CapabilityVersion:4;
        USHORT DeviceType:4;               // PCI_EXPRESS_DEVICE_TYPE
        USHORT SlotImplemented:1;
        USHORT InterruptMessageNumber:5;
        USHORT Rsvd:2;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_CAPABILITIES_REGISTER, *PPCI_EXPRESS_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER {

    struct {

        ULONG MaxPayloadSizeSupported:3;     // EXPRESS_MAX_PAYLOAD_SIZE
        ULONG PhantomFunctionsSupported:2;
        ULONG ExtendedTagSupported:1;
        ULONG L0sAcceptableLatency:3;        // EXPRESS_L0S_LATENCY
        ULONG L1AcceptableLatency:3;         // EXPRESS_L1_LATENCY
        ULONG Undefined:3;
        ULONG RoleBasedErrorReporting:1;
        ULONG Rsvd1:2;
        ULONG CapturedSlotPowerLimit:8;
        ULONG CapturedSlotPowerLimitScale:2;
        ULONG Rsvd2:4;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER, *PPCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_DEVICE_CONTROL_REGISTER {

    struct {

        USHORT CorrectableErrorEnable:1;
        USHORT NonFatalErrorEnable:1;
        USHORT FatalErrorEnable:1;
        USHORT UnsupportedRequestErrorEnable:1;
        USHORT EnableRelaxedOrder:1;
        USHORT MaxPayloadSize:3;                 // EXPRESS_MAX_PAYLOAD_SIZE
        USHORT ExtendedTagEnable:1;
        USHORT PhantomFunctionsEnable:1;
        USHORT AuxPowerEnable:1;
        USHORT NoSnoopEnable:1;
        USHORT MaxReadRequestSize:3;             // EXPRESS_MAX_PAYLOAD_SIZE
        USHORT BridgeConfigRetryEnable:1;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_DEVICE_CONTROL_REGISTER, *PPCI_EXPRESS_DEVICE_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_DEVICE_STATUS_REGISTER {

    struct {

        USHORT CorrectableErrorDetected:1;
        USHORT NonFatalErrorDetected:1;
        USHORT FatalErrorDetected:1;
        USHORT UnsupportedRequestDetected:1;
        USHORT AuxPowerDetected:1;
        USHORT TransactionsPending:1;
        USHORT Rsvd:10;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_DEVICE_STATUS_REGISTER, *PPCI_EXPRESS_DEVICE_STATUS_REGISTER;

typedef union _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER {

    struct {

        ULONG MaximumLinkSpeed:4;
        ULONG MaximumLinkWidth:6;
        ULONG ActiveStatePMSupport:2;   // EXPRESS_ASPM_CONFIG
        ULONG L0sExitLatency:3;         // EXPRESS_L0S_LATENCY
        ULONG L1ExitLatency:3;          // EXPRESS_L1_LATENCY
        ULONG ClockPowerManagement:1;
        ULONG SurpriseDownErrorReportingCapable:1;
        ULONG DataLinkLayerActiveReportingCapable:1;
        ULONG Rsvd:3;
        ULONG PortNumber:8;
    } DUMMYSTRUCTNAME;
    
    ULONG AsULONG;

} PCI_EXPRESS_LINK_CAPABILITIES_REGISTER, *PPCI_EXPRESS_LINK_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_LINK_CONTROL_REGISTER {

    struct {

        USHORT ActiveStatePMControl:2;    // EXPRESS_ASPM_CONFIG
        USHORT Rsvd1:1;
        USHORT ReadCompletionBoundary:1;  // EXPRESS_RCB
        USHORT LinkDisable:1;
        USHORT RetrainLink:1;
        USHORT CommonClockConfig:1;
        USHORT ExtendedSynch:1;
        USHORT EnableClockPowerManagement:1;
        USHORT Rsvd2:7;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_LINK_CONTROL_REGISTER, *PPCI_EXPRESS_LINK_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_LINK_STATUS_REGISTER {

    struct {

        USHORT LinkSpeed:4;
        USHORT LinkWidth:6;
        USHORT Undefined:1;
        USHORT LinkTraining:1;
        USHORT SlotClockConfig:1;
        USHORT DataLinkLayerActive:1;
        USHORT Rsvd:2;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_LINK_STATUS_REGISTER, *PPCI_EXPRESS_LINK_STATUS_REGISTER;

typedef union _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER {

    struct {

        ULONG AttentionButtonPresent:1;
        ULONG PowerControllerPresent:1;
        ULONG MRLSensorPresent:1;
        ULONG AttentionIndicatorPresent:1;
        ULONG PowerIndicatorPresent:1;
        ULONG HotPlugSurprise:1;
        ULONG HotPlugCapable:1;
        ULONG SlotPowerLimit:8;
        ULONG SlotPowerLimitScale:2;
        ULONG ElectromechanicalLockPresent:1;
        ULONG NoCommandCompletedSupport:1;
        ULONG PhysicalSlotNumber:13;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER, *PPCI_EXPRESS_SLOT_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_SLOT_CONTROL_REGISTER {

    struct {

        USHORT AttentionButtonEnable:1;
        USHORT PowerFaultDetectEnable:1;
        USHORT MRLSensorEnable:1;
        USHORT PresenceDetectEnable:1;
        USHORT CommandCompletedEnable:1;
        USHORT HotPlugInterruptEnable:1;
        USHORT AttentionIndicatorControl:2;  // EXPRESS_INDICATOR_STATE
        USHORT PowerIndicatorControl:2;      // EXPRESS_INDICATOR_STATE
        USHORT PowerControllerControl:1;     // EXPRESS_POWER_STATE
        USHORT ElectromechanicalLockControl:1;
        USHORT DataLinkStateChangeEnable:1;
        USHORT Rsvd:3;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_SLOT_CONTROL_REGISTER, *PPCI_EXPRESS_SLOT_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_SLOT_STATUS_REGISTER {

    struct {

        USHORT AttentionButtonPressed:1;
        USHORT PowerFaultDetected:1;
        USHORT MRLSensorChanged:1;
        USHORT PresenceDetectChanged:1;
        USHORT CommandCompleted:1;
        USHORT MRLSensorState:1;        // EXPRESS_MRL_STATE
        USHORT PresenceDetectState:1;   // EXPRESS_CARD_PRESENCE
        USHORT ElectromechanicalLockEngaged:1;
        USHORT DataLinkStateChanged:1;
        USHORT Rsvd:7;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_SLOT_STATUS_REGISTER, *PPCI_EXPRESS_SLOT_STATUS_REGISTER;

typedef union _PCI_EXPRESS_ROOT_CONTROL_REGISTER {

    struct {

        USHORT CorrectableSerrEnable:1;
        USHORT NonFatalSerrEnable:1;
        USHORT FatalSerrEnable:1;
        USHORT PMEInterruptEnable:1;
        USHORT CRSSoftwareVisibilityEnable:1;
        USHORT Rsvd:11;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_ROOT_CONTROL_REGISTER, *PPCI_EXPRESS_ROOT_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER {

    struct {

        USHORT CRSSoftwareVisibility:1;
        USHORT Rsvd:15;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER, *PPCI_EXPRESS_ROOT_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_ROOT_STATUS_REGISTER {

    struct {

        ULONG PMERequestorId:16;  // PCI_EXPRESS_REQUESTOR_ID
        ULONG PMEStatus:1;
        ULONG PMEPending:1;
        ULONG Rsvd:14;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_ROOT_STATUS_REGISTER, *PPCI_EXPRESS_ROOT_STATUS_REGISTER;

//
// PCI Express Capability
//

typedef struct _PCI_EXPRESS_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;
    PCI_EXPRESS_CAPABILITIES_REGISTER ExpressCapabilities;

    PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER DeviceCapabilities;

    PCI_EXPRESS_DEVICE_CONTROL_REGISTER DeviceControl;
    PCI_EXPRESS_DEVICE_STATUS_REGISTER DeviceStatus;

    PCI_EXPRESS_LINK_CAPABILITIES_REGISTER LinkCapabilities;

    PCI_EXPRESS_LINK_CONTROL_REGISTER LinkControl;
    PCI_EXPRESS_LINK_STATUS_REGISTER LinkStatus;

    PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER SlotCapabilities;

    PCI_EXPRESS_SLOT_CONTROL_REGISTER SlotControl;
    PCI_EXPRESS_SLOT_STATUS_REGISTER SlotStatus;

    PCI_EXPRESS_ROOT_CONTROL_REGISTER RootControl;
    PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER RootCapabilities;

    PCI_EXPRESS_ROOT_STATUS_REGISTER RootStatus;

} PCI_EXPRESS_CAPABILITY, *PPCI_EXPRESS_CAPABILITY;

typedef enum {

    MRLClosed = 0,
    MRLOpen

} PCI_EXPRESS_MRL_STATE;

typedef enum {

    SlotEmpty = 0,
    CardPresent

} PCI_EXPRESS_CARD_PRESENCE;

typedef enum {

    IndicatorOn = 1,
    IndicatorBlink,
    IndicatorOff

} PCI_EXPRESS_INDICATOR_STATE;

typedef enum {

    PowerOn = 0,
    PowerOff

} PCI_EXPRESS_POWER_STATE;

typedef enum {

    L0sEntrySupport = 1,
    L0sAndL1EntrySupport = 3

} PCI_EXPRESS_ASPM_SUPPORT;

typedef enum {

    L0sAndL1EntryDisabled,
    L0sEntryEnabled,
    L1EntryEnabled,
    L0sAndL1EntryEnabled

} PCI_EXPRESS_ASPM_CONTROL;

typedef enum {

    L0s_Below64ns = 0,
    L0s_64ns_128ns,
    L0s_128ns_256ns,
    L0s_256ns_512ns,
    L0s_512ns_1us,
    L0s_1us_2us,
    L0s_2us_4us,
    L0s_Above4us

} PCI_EXPRESS_L0s_EXIT_LATENCY;

typedef enum {

    L1_Below1us = 0,
    L1_1us_2us,
    L1_2us_4us,
    L1_4us_8us,
    L1_8us_16us,
    L1_16us_32us,
    L1_32us_64us,
    L1_Above64us

} PCI_EXPRESS_L1_EXIT_LATENCY;

typedef enum {

    PciExpressEndpoint = 0,
    PciExpressLegacyEndpoint,
    PciExpressRootPort = 4,
    PciExpressUpstreamSwitchPort,
    PciExpressDownstreamSwitchPort,
    PciExpressToPciXBridge,
    PciXToExpressBridge,
    PciExpressRootComplexIntegratedEndpoint,
    PciExpressRootComplexEventCollector
    
} PCI_EXPRESS_DEVICE_TYPE;

typedef enum {

    MaxPayload128Bytes = 0,
    MaxPayload256Bytes,
    MaxPayload512Bytes,
    MaxPayload1024Bytes,
    MaxPayload2048Bytes,
    MaxPayload4096Bytes

} PCI_EXPRESS_MAX_PAYLOAD_SIZE;

typedef union _PCI_EXPRESS_PME_REQUESTOR_ID {

    struct {

        USHORT FunctionNumber:3;
        USHORT DeviceNumber:5;
        USHORT BusNumber:8;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_PME_REQUESTOR_ID, *PPCI_EXPRESS_PME_REQUESTOR_ID;


//
// Portable portion of HAL & HAL bus extender definitions for BUSHANDLER
// BusData for installed PCI buses.
//

typedef VOID
(*PciPin2Line) (
    IN struct _BUS_HANDLER  *BusHandler,
    IN struct _BUS_HANDLER  *RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

typedef VOID
(*PciLine2Pin) (
    IN struct _BUS_HANDLER  *BusHandler,
    IN struct _BUS_HANDLER  *RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

typedef VOID
(*PciReadWriteConfig) (
    IN struct _BUS_HANDLER *BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

#define PCI_DATA_TAG            ' ICP'
#define PCI_DATA_VERSION        1

typedef struct _PCIBUSDATA {
    ULONG                   Tag;
    ULONG                   Version;
    PciReadWriteConfig      ReadConfig;
    PciReadWriteConfig      WriteConfig;
    PciPin2Line             Pin2Line;
    PciLine2Pin             Line2Pin;
    PCI_SLOT_NUMBER         ParentSlot;
    PVOID                   Reserved[4];
} PCIBUSDATA, *PPCIBUSDATA;


#ifndef _PCIINTRF_X_
#define _PCIINTRF_X_

//
// PCI Bus interface
//

typedef ULONG (*PCI_READ_WRITE_CONFIG)(
    IN PVOID Context,
    IN ULONG BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef VOID (*PCI_PIN_TO_LINE)(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciData
    );

typedef VOID (*PCI_LINE_TO_PIN)(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciNewData,
    IN PPCI_COMMON_CONFIG PciOldData
    );

typedef VOID (*PCI_ROOT_BUS_CAPABILITY) (
    __in PVOID Context,
    __out PPCI_ROOT_BUS_HARDWARE_CAPABILITY HardwareCapability
    );

typedef VOID (*PCI_EXPRESS_WAKE_CONTROL) (
    __in PVOID Context,
    __in BOOLEAN EnableWake
    );

typedef struct _PCI_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard PCI bus interfaces
    //
    PCI_READ_WRITE_CONFIG ReadConfig;
    PCI_READ_WRITE_CONFIG WriteConfig;
    PCI_PIN_TO_LINE PinToLine;
    PCI_LINE_TO_PIN LineToPin;
    PCI_ROOT_BUS_CAPABILITY RootBusCapability;
    PCI_EXPRESS_WAKE_CONTROL ExpressWakeControl;

} PCI_BUS_INTERFACE_STANDARD, *PPCI_BUS_INTERFACE_STANDARD;

#define PCI_BUS_INTERFACE_STANDARD_VERSION 1


#endif

//
// Define exported ZwXxx routines to device drivers.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread (
    __in HANDLE ThreadHandle,
    __in THREADINFOCLASS ThreadInformationClass,
    __in_bcount(ThreadInformationLength) PVOID ThreadInformation,
    __in ULONG ThreadInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSTATUS
ZwCreateTimer (
    __out PHANDLE TimerHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in TIMER_TYPE TimerType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSTATUS
ZwOpenTimer (
    __out PHANDLE TimerHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSTATUS
ZwCancelTimer (
    __in HANDLE TimerHandle,
    __out_opt PBOOLEAN CurrentState
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSTATUS
ZwSetTimer (
    __in HANDLE TimerHandle,
    __in PLARGE_INTEGER DueTime,
    __in_opt PTIMER_APC_ROUTINE TimerApcRoutine,
    __in_opt PVOID TimerContext,
    __in BOOLEAN ResumeTimer,
    __in_opt LONG Period,
    __out_opt PBOOLEAN PreviousState
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG IoControlCode,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwDisplayString(
    __in PUNICODE_STRING String
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    __in POWER_INFORMATION_LEVEL InformationLevel,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength
    );
#endif


NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId(
    __out PLUID Luid
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateProcess (
    __in_opt HANDLE ProcessHandle,
    __in NTSTATUS ExitStatus
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcess (
    __out PHANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PCLIENT_ID ClientId
    );


//
// Windows Error Record Creator GUID.
//

DEFINE_GUID( WHEA_RECORD_CREATOR_GUID,
    0xcf07c4bd,0xb789,0x4e18,0xb3,0xc4,0x1f,0x73,0x2c,0xb5,0x71,0x31 );

//
// Error notification type GUIDs.
//
    
DEFINE_GUID( CMC_NOTIFY_TYPE_GUID,
    0x2dce8bb1,0xbdd7,0x450e,0xb9,0xad,0x9c,0xf4,0xeb,0xd4,0xf8,0x90 );
DEFINE_GUID( CPE_NOTIFY_TYPE_GUID,
    0x4e292f96,0xd843,0x4a55,0xa8,0xc2,0xd4,0x81,0xf2,0x7e,0xbe,0xee );
DEFINE_GUID( MCE_NOTIFY_TYPE_GUID,
    0xe8f56ffe,0x919c,0x4cc5,0xba,0x88,0x65,0xab,0xe1,0x49,0x13,0xbb );
DEFINE_GUID( PCIe_NOTIFY_TYPE_GUID,
    0xcf93c01f,0x1a16,0x4dfc,0xb8,0xbc,0x9c,0x4d,0xaf,0x67,0xc1,0x04 );
DEFINE_GUID( INIT_NOTIFY_TYPE_GUID,
    0xcc5263e8,0x9308,0x454a,0x89,0xd0,0x34,0x0b,0xd3,0x9b,0xc9,0x8e );
DEFINE_GUID( NMI_NOTIFY_TYPE_GUID,
    0x5bad89ff,0xb7e6,0x42c9,0x81,0x4a,0xcf,0x24,0x85,0xd6,0xe9,0x8a );
DEFINE_GUID( BOOT_NOTIFY_TYPE_GUID,
    0x3d61a466,0xab40,0x409a,0xa6,0x98,0xf3,0x62,0xd4,0x64,0xb3,0x8f );
DEFINE_GUID( GENERIC_NOTIFY_TYPE_GUID,
    0x3e62a467,0xab40,0x409a,0xa6,0x98,0xf3,0x62,0xd4,0x64,0xb3,0x8f );
   
//
// Error Section type GUIDs.
// 

DEFINE_GUID( PROCESSOR_GENERIC_SECTION_GUID,
    0x9876ccad,0x47b4,0x4bdb,0xb6,0x5e,0x16,0xf1,0x93,0xc4,0xf3,0xdb );
DEFINE_GUID( X86_PROCESSOR_SPECIFIC_SECTION_GUID,
    0xdc3ea0b0,0xa144,0x4797,0xb9,0x5b,0x53,0xfa,0x24,0x2b,0x6e,0x1d );
DEFINE_GUID( IPF_PROCESSOR_SPECIFIC_SECTION_GUID,
    0xe429faf1,0x3cb7,0x11d4,0xbc,0xa7,0x00,0x80,0xc7,0x3c,0x88,0x81 );
DEFINE_GUID( X64_PROCESSOR_SPECIFIC_SECTION_GUID,
    0x390f56d5,0xca86,0x4649,0x95,0xc4,0x73,0xa4,0x08,0xae,0x58,0x34 );
DEFINE_GUID( PLATFORM_MEMORY_SECTION_GUID,
    0xa5bc1114,0x6f64,0x4ede,0xb8,0x63,0x3e,0x83,0xed,0x7c,0x83,0xb1 );
DEFINE_GUID( PCIEXPRESS_SECTION_GUID,
    0xd995e954,0xbbc1,0x430f,0xad,0x91,0xb4,0x4d,0xcb,0x3c,0x6f,0x35 );
DEFINE_GUID( PCIX_BUS_SECTION_GUID,
    0xc5753963,0x3b84,0x4095,0xbf,0x78,0xed,0xda,0xd3,0xf9,0xc9,0xdd );
DEFINE_GUID( PCIX_COMPONENT_SECTION_GUID,
    0xeb5e4685,0xca66,0x4769,0xb6,0xa2,0x26,0x06,0x8b,0x00,0x13,0x26 );
DEFINE_GUID( NMI_SECTION_GUID,
    0xe71254e7,0xc1b9,0x4940,0xab,0x76,0x90,0x97,0x03,0xa4,0x32,0x0f );
DEFINE_GUID( GENERIC_SECTION_GUID,
    0xe71254e8,0xc1b9,0x4940,0xab,0x76,0x90,0x97,0x03,0xa4,0x32,0x0f );
DEFINE_GUID( WHEA_PACKET_SECTION_GUID,
    0xe71254e9,0xc1b9,0x4940,0xab,0x76,0x90,0x97,0x03,0xa4,0x32,0x0f );
DEFINE_GUID( PLATFORM_CACHE_SECTION_GUID,
    0x59a0a229,0x9399,0x4140,0x85,0xb3,0x06,0xd4,0x8a,0x9e,0x00,0x60 );
DEFINE_GUID( IPF_SAL_RECORD_REFERENCE_SECTION_GUID,
    0x81212A96,0x09ED,0x4996,0x94,0x71,0x8D,0x72,0x9C,0x8E,0x69,0xED );

//
// Processor error check section GUIDs.
//

DEFINE_GUID( WHEA_CACHECHECK_GUID,
    0xA55701F5,0xE3EF,0x43de,0xAC,0x72,0x24,0x9B,0x57,0x3F,0xAD,0x2C );
DEFINE_GUID( WHEA_TLBCHECK_GUID,
    0xFC06B535,0x5E1F,0x4562,0x9F,0x25,0x0A,0x3B,0x9A,0xDB,0x63,0xC3 );
DEFINE_GUID( WHEA_BUSCHECK_GUID,
    0x1CF3F8B3,0xC5B1,0x49A2,0xAA,0x59,0x5E,0xEF,0x92,0xFF,0xA6,0x3C );
DEFINE_GUID( WHEA_MSCHECK_GUID,
    0x48AB7F57,0xDC34,0x4F6C,0xA7,0xD3,0xB0,0xB5,0xB0,0xA7,0x43,0x14 );

#define WHEA_PHYSICAL_ADDRESS LARGE_INTEGER

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
// The following definitions and structures are used to describe platform-
// implemented hardware error sources to the OS.
//
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

//
//
// This enumeration defines the various types of error sources a platform can
// expose to the OS.
//

typedef enum _WHEA_ERROR_SOURCE_TYPE {
    WheaErrSrcTypeMCE       = 0x00,   // Machine Check Exception
    WheaErrSrcTypeCMC       = 0x01,   // Corrected Machine Check
    WheaErrSrcTypeCPE       = 0x02,   // Corrected Platform Error
    WheaErrSrcTypeNMI       = 0x03,   // Non-Maskable Interrupt
    WheaErrSrcTypePCIe      = 0x04,   // PCI Express Error
    WheaErrSrcTypeGeneric   = 0x05,   // Other types of error sources
    WheaErrSrcTypeINIT      = 0x06,   // IA64 INIT Error Source
    WheaErrSrcTypeBOOT      = 0x07,   // BOOT Error Source
    WheaErrSrcTypeSCIGeneric= 0x08,   // SCI-based generic error source
    WheaErrSrcTypeIPFMCA    = 0x09,   // IPF MCA
    WheaErrSrcTypeIPFCMC    = 0x0a,   // IPF CMC
    WheaErrSrcTypeIPFCPE    = 0x0b,   // IPF CPE
    WheaErrSrcTypeMax       = 0x0c
} WHEA_ERROR_SOURCE_TYPE, *PWHEA_ERROR_SOURCE_TYPE;

//
// The information encoded within an error source's status registers is
// encoded in one of the following standardized formats.
//

typedef enum _WHEA_RAW_DATA_FORMAT {
    WheaRawDataFormatIPFSalRecord = 0x00,
    WheaRawDataFormatIA32MCA,
    WheaRawDataFormatIntel64MCA,
    WheaRawDataFormatAMD64MCA,
    WheaRawDataFormatMemory,
    WheaRawDataFormatPCIExpress,
    WheaRawDataFormatNMIPort,
    WheaRawDataFormatPCIXBus,
    WheaRawDataFormatPCIXDevice,
    WheaRawDataFormatGeneric,
    WheaRawDataFormatMax
} WHEA_RAW_DATA_FORMAT, *PWHEA_RAW_DATA_FORMAT;

//
// Error sources have a runtime state associated with them. The following are
// the valid states for an error source.
//

typedef enum _WHEA_ERROR_SOURCE_STATE {
    WheaErrSrcStateStopped = 0x01,
    WheaErrSrcStateStarted = 0x02
} WHEA_ERROR_SOURCE_STATE, *PWHEA_ERROR_SOURCE_STATE;

#define WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10          10

#define WHEA_MAX_MC_BANKS                                32

#define WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST             0x00000001
#define WHEA_ERROR_SOURCE_FLAG_GLOBAL                    0x00000002
#define WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE             0x80000000

#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE         0
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC         1
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI         2
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA         3
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC         4
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE         5
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT    6
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT    7
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE      8
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC        9

#define WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA            0
#define WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA         1
#define WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA           2

#define WHEA_NOTIFICATION_TYPE_POLLED                    0
#define WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT         1
#define WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT            2
#define WHEA_NOTIFICATION_TYPE_SCI                       3
#define WHEA_NOTIFICATION_TYPE_NMI                       4

#include <pshpack1.h>

typedef union _WHEA_NOTIFICATION_FLAGS {
    struct {
        USHORT PollIntervalRW:1;
        USHORT SwitchToPollingThresholdRW:1;
        USHORT SwitchToPollingWindowRW:1;
        USHORT ErrorThresholdRW:1;
        USHORT ErrorThresholdWindowRW:1;
        USHORT Reserved:11;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} WHEA_NOTIFICATION_FLAGS, *PWHEA_NOTIFICATION_FLAGS;

typedef union _XPF_MC_BANK_FLAGS {
    struct {
        UCHAR ClearOnInitializationRW:1;
        UCHAR ControlDataRW:1;
        UCHAR Reserved:6;
    } DUMMYSTRUCTNAME;
    UCHAR AsUCHAR;
} XPF_MC_BANK_FLAGS, *PXPF_MC_BANK_FLAGS;
    
typedef union _XPF_MCE_FLAGS {
    struct {
        ULONG MCG_CapabilityRW:1;
        ULONG MCG_GlobalControlRW:1;
        ULONG Reserved:30;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} XPF_MCE_FLAGS, *PXPF_MCE_FLAGS;

typedef union _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT RootErrorCommandRW:1;
        USHORT Reserved:11;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_ROOTPORT_DESCRIPTOR_FLAGS, *PAER_ROOTPORT_DESCRIPTOR_FLAGS;

typedef union _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT Reserved:12;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_ENDPOINT_DESCRIPTOR_FLAGS, *PAER_ENDPOINT_DESCRIPTOR_FLAGS;

typedef union _AER_BRIDGE_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT SecondaryUncorrectableErrorMaskRW:1;
        USHORT SecondaryUncorrectableErrorSevRW:1;
        USHORT SecondaryCapsAndControlRW:1;
        USHORT Reserved:9;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_BRIDGE_DESCRIPTOR_FLAGS, *PAER_BRIDGE_DESCRIPTOR_FLAGS;

//
// The following structure is used to describe how a given error source reports
// errors to the OS.
//

typedef struct _WHEA_NOTIFICATION_DESCRIPTOR {
    UCHAR Type;
    UCHAR Length;
    WHEA_NOTIFICATION_FLAGS Flags;

    union {
        struct {
            ULONG PollInterval;
        } Polled;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Interrupt;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } LocalInterrupt;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Sci;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Nmi;
    } u;
} WHEA_NOTIFICATION_DESCRIPTOR, *PWHEA_NOTIFICATION_DESCRIPTOR;

//
// The following structure describes an XPF machine check bank. It identifies
// the bank with a BankNumber and it contains information that is used to
// configure the bank. MCE and CMC error sources make use of this descriptor
// to describe and configure each bank.
//

typedef struct _WHEA_XPF_MC_BANK_DESCRIPTOR {
    UCHAR BankNumber;
    BOOLEAN ClearOnInitialization;
    UCHAR StatusDataFormat;
    XPF_MC_BANK_FLAGS Flags;
    ULONG ControlMsr;
    ULONG StatusMsr;
    ULONG AddressMsr;
    ULONG MiscMsr;
    ULONGLONG ControlData;
} WHEA_XPF_MC_BANK_DESCRIPTOR, *PWHEA_XPF_MC_BANK_DESCRIPTOR;

//
// The following structure describes an XPF platform's machine check exception
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's MCE error source.
//

typedef struct _WHEA_XPF_MCE_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR NumberOfBanks;
    XPF_MCE_FLAGS Flags;
    ULONGLONG MCG_Capability;
    ULONGLONG MCG_GlobalControl;
    WHEA_XPF_MC_BANK_DESCRIPTOR Banks[WHEA_MAX_MC_BANKS];
} WHEA_XPF_MCE_DESCRIPTOR, *PWHEA_XPF_MCE_DESCRIPTOR;

//
// The following structure describes an XPF platform's corrected machine check
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's CMC error source.
//

typedef struct _WHEA_XPF_CMC_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR NumberOfBanks;
    ULONG Reserved;
    WHEA_NOTIFICATION_DESCRIPTOR Notify;
    WHEA_XPF_MC_BANK_DESCRIPTOR Banks[WHEA_MAX_MC_BANKS];
} WHEA_XPF_CMC_DESCRIPTOR, *PWHEA_XPF_CMC_DESCRIPTOR;

typedef struct _WHEA_PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG DeviceNumber:5;
            ULONG FunctionNumber:3;
            ULONG Reserved:24;
        } bits;
        ULONG AsULONG;
    } u;
} WHEA_PCI_SLOT_NUMBER, *PWHEA_PCI_SLOT_NUMBER;

//
// The following structure describes an XPF platform's non-maskable interrupt
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's NMI error source.
//

typedef struct _WHEA_XPF_NMI_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
} WHEA_XPF_NMI_DESCRIPTOR, *PWHEA_XPF_NMI_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER root port
// error source. The information represented in this structure tells the OS how
// to configure the root port's AER settings.
//

typedef struct _WHEA_AER_ROOTPORT_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_ROOTPORT_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
    ULONG RootErrorCommand;
} WHEA_AER_ROOTPORT_DESCRIPTOR, *PWHEA_AER_ROOTPORT_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER endpoint 
// error source. The information represented in this structure tells the OS how
// to configure the device's AER settings.
//

typedef struct _WHEA_AER_ENDPOINT_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_ENDPOINT_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
} WHEA_AER_ENDPOINT_DESCRIPTOR, *PWHEA_AER_ENDPOINT_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER bridge 
// error source. The information represented in this structure tells the OS how
// to configure the bridge's AER settings.
//

typedef struct _WHEA_AER_BRIDGE_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_BRIDGE_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
    ULONG SecondaryUncorrectableErrorMask;
    ULONG SecondaryUncorrectableErrorSev;
    ULONG SecondaryCapsAndControl;
} WHEA_AER_BRIDGE_DESCRIPTOR, *PWHEA_AER_BRIDGE_DESCRIPTOR;

//
// The following structure describes a generic error source to the OS. Using
// the information in this structure the OS is able to configure a handler for
// the generic error source.
//

typedef struct _WHEA_GENERIC_ERROR_DESCRIPTOR {

    //
    // Type is WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC.
    //

    USHORT Type;

    //
    // This field is reserved.
    //

    UCHAR Reserved;

    //
    // Indicates whether the generic error source is to be enabled.
    //

    UCHAR Enabled;

    //
    // Length of the error status block.
    //

    ULONG ErrStatusBlockLength;
    
    //
    // If this generic error source relates back to another error source, keep
    // it's identifier here.
    //

    ULONG RelatedErrorSourceId;
    
    //
    // The following 5 fields have the same layout as a GEN_ADDR structure. They
    // describe the address at which the OS reads error status information
    // from the error source. 
    //

    UCHAR ErrStatusAddressSpaceID;
    UCHAR ErrStatusAddressBitWidth;
    UCHAR ErrStatusAddressBitOffset;
    UCHAR ErrStatusAddressAccessSize;
    WHEA_PHYSICAL_ADDRESS ErrStatusAddress;

    //
    // Notify describes how the generic error source notifies the OS that error
    // information is available.
    //

    WHEA_NOTIFICATION_DESCRIPTOR Notify;

} WHEA_GENERIC_ERROR_DESCRIPTOR, *PWHEA_GENERIC_ERROR_DESCRIPTOR;

typedef struct _WHEA_IPF_MCA_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_MCA_DESCRIPTOR, *PWHEA_IPF_MCA_DESCRIPTOR;

typedef struct _WHEA_IPF_CMC_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_CMC_DESCRIPTOR, *PWHEA_IPF_CMC_DESCRIPTOR;

typedef struct _WHEA_IPF_CPE_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_CPE_DESCRIPTOR, *PWHEA_IPF_CPE_DESCRIPTOR;

//
// This structure describes a hardware error source.
//

typedef struct _WHEA_ERROR_SOURCE_DESCRIPTOR {
    ULONG Length;                                              // +00 (0)
    ULONG Version;                                             // +04 (4)
    WHEA_ERROR_SOURCE_TYPE Type;                               // +08 (8)
    WHEA_ERROR_SOURCE_STATE State;                             // +0C (12)
    ULONG MaxRawDataLength;                                    // +10 (16)
    ULONG NumRecordsToPreallocate;                             // +14 (20)
    ULONG MaxSectionsPerRecord;                                // +18 (24)
    ULONG ErrorSourceId;                                       // +1C (28)
    ULONG PlatformErrorSourceId;                               // +20 (32)
    ULONG Flags;                                               // +24 (36)

    union {                                                    // +28 (40)
        WHEA_XPF_MCE_DESCRIPTOR XpfMceDescriptor;
        WHEA_XPF_CMC_DESCRIPTOR XpfCmcDescriptor;
        WHEA_XPF_NMI_DESCRIPTOR XpfNmiDescriptor;
        WHEA_IPF_MCA_DESCRIPTOR IpfMcaDescriptor;
        WHEA_IPF_CMC_DESCRIPTOR IpfCmcDescriptor;
        WHEA_IPF_CPE_DESCRIPTOR IpfCpeDescriptor;
        WHEA_AER_ROOTPORT_DESCRIPTOR AerRootportDescriptor;
        WHEA_AER_ENDPOINT_DESCRIPTOR AerEndpointDescriptor;
        WHEA_AER_BRIDGE_DESCRIPTOR AerBridgeDescriptor;
        WHEA_GENERIC_ERROR_DESCRIPTOR GenErrDescriptor;
    } Info;
    
} WHEA_ERROR_SOURCE_DESCRIPTOR, *PWHEA_ERROR_SOURCE_DESCRIPTOR;

typedef union _WHEA_REVISION {
    struct {
        UCHAR MinorRevision;
        UCHAR MajorRevision;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} WHEA_REVISION, *PWHEA_REVISION;

//
// These are the different types of hardware that can report errors.
//
typedef enum _WHEA_ERROR_TYPE {
    WheaErrTypeProcessor = 0,
    WheaErrTypeMemory,
    WheaErrTypePCIExpress,
    WheaErrTypeNMI,
    WheaErrTypePCIXBus,
    WheaErrTypePCIXDevice,
    WheaErrTypeGeneric
} WHEA_ERROR_TYPE, *PWHEA_ERROR_TYPE;

//
// WHEA_ERROR_SEVERITY enumeration defines the valid severity levels of a
// reported hardware error.
//

typedef enum _WHEA_ERROR_SEVERITY {
    WheaErrSevRecoverable = 0,
    WheaErrSevFatal       = 1,
    WheaErrSevCorrected   = 2,
    WheaErrSevNone        = 3
} WHEA_ERROR_SEVERITY, *PWHEA_ERROR_SEVERITY;

//
// Error Status Structure
//

#define ERRTYP_INTERNAL                 0x01 // 1
#define ERRTYP_BUS                      0x10 // 16
#define ERRTYP_MEM                      0x04 // 4
#define ERRTYP_TLB                      0x05 // 5
#define ERRTYP_CACHE                    0x06 // 6
#define ERRTYP_FUNCTION                 0x07 // 7
#define ERRTYP_SELFTEST                 0x08 // 8
#define ERRTYP_FLOW                     0x09 // 9
#define ERRTYP_MAP                      0x11 // 17
#define ERRTYP_IMPROPER                 0x12 // 18
#define ERRTYP_UNIMPL                   0x13 // 19
#define ERRTYP_LOSSOFLOCKSTEP           0x14 // 20
#define ERRTYP_RESPONSE                 0x15 // 21
#define ERRTYP_PARITY                   0x16 // 22
#define ERRTYP_PROTOCOL                 0x17 // 23
#define ERRTYP_PATHERROR                0x18 // 24
#define ERRTYP_TIMEOUT                  0x19 // 25
#define ERRTYP_POISONED                 0x1A // 26

typedef union _WHEA_ERROR_STATUS {
    ULONGLONG ErrorStatus;
    struct {
        ULONGLONG Reserved1:8;
        ULONGLONG ErrorType:8;
        ULONGLONG Address:1;
        ULONGLONG Control:1;
        ULONGLONG Data:1;
        ULONGLONG Responder:1;
        ULONGLONG Requester:1;
        ULONGLONG FirstError:1;
        ULONGLONG Overflow:1;
        ULONGLONG Reserved2:41;
    } DUMMYSTRUCTNAME;
} WHEA_ERROR_STATUS, *PWHEA_ERROR_STATUS;

//
// Processor generic error section.
//

#define GENPROC_PROCTYPE_XPF                 0
#define GENPROC_PROCTYPE_IPF                 1

#define GENPROC_PROCISA_X86                  0
#define GENPROC_PROCISA_IPF                  1
#define GENPROC_PROCISA_X64                  2

#define GENPROC_PROCERRTYPE_UNKNOWN          0
#define GENPROC_PROCERRTYPE_CACHE            1
#define GENPROC_PROCERRTYPE_TLB              2
#define GENPROC_PROCERRTYPE_BUS              4
#define GENPROC_PROCERRTYPE_MAE              8

#define GENPROC_OP_GENERIC                   0
#define GENPROC_OP_DATAREAD                  1
#define GENPROC_OP_DATAWRITE                 2
#define GENPROC_OP_INSTRUCTIONEXE            3

#define GENPROC_FLAGS_RESTARTABLE            0x01
#define GENPROC_FLAGS_PRECISEIP              0x02
#define GENPROC_FLAGS_OVERFLOW               0x04
#define GENPROC_FLAGS_CORRECTED              0x08

typedef union _WHEA_PROCESSOR_FAMILY_INFO {
    struct {
        ULONG Stepping:4;
        ULONG Model:4;
        ULONG Family:4;
        ULONG ProcessorType:2;
        ULONG Reserved1:2;
        ULONG ExtendedModel:4;
        ULONG ExtendedFamily:8;
        ULONG Reserved2:4;
        ULONG Reserved3;
    } DUMMYSTRUCTNAME;
    ULONGLONG AsULONGLONG;
} WHEA_PROCESSOR_FAMILY_INFO, *PWHEA_PROCESSOR_FAMILY_INFO;

typedef union _WHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS {
    struct {
        ULONGLONG ProcessorType:1;
        ULONGLONG InstructionSet:1;
        ULONGLONG ErrorType:1;
        ULONGLONG Operation:1;
        ULONGLONG Flags:1;
        ULONGLONG Level:1;
        ULONGLONG CPUVersion:1;
        ULONGLONG CPUBrandString:1;
        ULONGLONG ProcessorId:1;
        ULONGLONG TargetAddress:1;
        ULONGLONG RequesterId:1;
        ULONGLONG ResponderId:1;
        ULONGLONG InstructionPointer:1;
        ULONGLONG Reserved:51;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS, 
  *PWHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS;

typedef struct _WHEA_GENERIC_PROCESSOR_ERROR {
    WHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS ValidBits; // +0x00 (00)
    UCHAR ProcessorType;                              // +0x08 (08)
    UCHAR InstructionSet;                             // +0x09 (09)
    UCHAR ErrorType;                                  // +0x0A (10)
    UCHAR Operation;                                  // +0x0B (11)
    UCHAR Flags;                                      // +0x0C (12)
    UCHAR Level;                                      // +0x0D (13)
    USHORT Reserved;                                  // +0x0E (14)
    ULONGLONG CPUVersion;                             // +0x10 (16)
    UCHAR CPUBrandString[128];                        // +0x18 (24)
    ULONGLONG ProcessorId;                            // +0x98 (152)
    ULONGLONG TargetAddress;                          // +0xA0 (160)
    ULONGLONG RequesterId;                            // +0xA8 (168)
    ULONGLONG ResponderId;                            // +0xB0 (176)
    ULONGLONG InstructionPointer;                     // +0xB8 (184)
                                                      // +0xC0 (192)
} WHEA_GENERIC_PROCESSOR_ERROR, *PWHEA_GENERIC_PROCESSOR_ERROR;

//
// IA32/X64 Processor Cache Check Structure
//

#define XPF_CACHE_CHECK_TRANSACTIONTYPE_INSTRUCTION     0
#define XPF_CACHE_CHECK_TRANSACTIONTYPE_DATAACCESS      1
#define XPF_CACHE_CHECK_TRANSACTIONTYPE_GENERIC         2

#define XPF_CACHE_CHECK_OPERATION_GENERIC               0
#define XPF_CACHE_CHECK_OPERATION_GENREAD               1
#define XPF_CACHE_CHECK_OPERATION_GENWRITE              2
#define XPF_CACHE_CHECK_OPERATION_DATAREAD              3
#define XPF_CACHE_CHECK_OPERATION_DATAWRITE             4
#define XPF_CACHE_CHECK_OPERATION_INSTRUCTIONFETCH      5
#define XPF_CACHE_CHECK_OPERATION_PREFETCH              6
#define XPF_CACHE_CHECK_OPERATION_EVICTION              7
#define XPF_CACHE_CHECK_OPERATION_SNOOP                 8

typedef union _WHEA_XPF_CACHE_CHECK {
    struct {
        ULONGLONG TransactionTypeValid:1;
        ULONGLONG OperationValid:1;
        ULONGLONG LevelValid:1;
        ULONGLONG ProcessorContextCorruptValid:1;
        ULONGLONG UncorrectedValid:1;
        ULONGLONG PreciseIPValid:1;
        ULONGLONG RestartableIPValid:1;
        ULONGLONG OverflowValid:1;
        ULONGLONG ReservedValid:8;
	ULONGLONG TransactionType:2;
	ULONGLONG Operation:4;
	ULONGLONG Level:3;
	ULONGLONG ProcessorContextCorrupt:1;
	ULONGLONG Uncorrected:1;
	ULONGLONG PreciseIP:1;
	ULONGLONG RestartableIP:1;
	ULONGLONG Overflow:1;
        ULONGLONG Reserved:34;
    } DUMMYSTRUCTNAME;
    ULONGLONG XpfCacheCheck;
} WHEA_XPF_CACHE_CHECK, *PWHEA_XPF_CACHE_CHECK;

//
// IA32/X64 Processor TLB Check Structure
//

#define XPF_TLB_CHECK_TRANSACTIONTYPE_INSTRUCTION     0
#define XPF_TLB_CHECK_TRANSACTIONTYPE_DATAACCESS      1
#define XPF_TLB_CHECK_TRANSACTIONTYPE_GENERIC         2

#define XPF_TLB_CHECK_OPERATION_GENERIC               0
#define XPF_TLB_CHECK_OPERATION_GENREAD               1
#define XPF_TLB_CHECK_OPERATION_GENWRITE              2
#define XPF_TLB_CHECK_OPERATION_DATAREAD              3
#define XPF_TLB_CHECK_OPERATION_DATAWRITE             4
#define XPF_TLB_CHECK_OPERATION_INSTRUCTIONFETCH      5
#define XPF_TLB_CHECK_OPERATION_PREFETCH              6

typedef union _WHEA_XPF_TLB_CHECK {
    struct {
        ULONGLONG TransactionTypeValid:1;
        ULONGLONG OperationValid:1;
        ULONGLONG LevelValid:1;
        ULONGLONG ProcessorContextCorruptValid:1;
        ULONGLONG UncorrectedValid:1;
        ULONGLONG PreciseIPValid:1;
        ULONGLONG RestartableIPValid:1;
        ULONGLONG OverflowValid:1;
        ULONGLONG ReservedValid:8;
	ULONGLONG TransactionType:2;
	ULONGLONG Operation:4;
	ULONGLONG Level:3;
	ULONGLONG ProcessorContextCorrupt:1;
	ULONGLONG Uncorrected:1;
	ULONGLONG PreciseIP:1;
	ULONGLONG RestartableIP:1;
	ULONGLONG Overflow:1;
	ULONGLONG Reserved:34;
    } DUMMYSTRUCTNAME;
    ULONGLONG XpfTLBCheck;
} WHEA_XPF_TLB_CHECK, *PWHEA_XPF_TLB_CHECK;

//
// IA32/X64 Processor Bus Check Structure
//

#define XPF_BUS_CHECK_TRANSACTIONTYPE_INSTRUCTION     0
#define XPF_BUS_CHECK_TRANSACTIONTYPE_DATAACCESS      1
#define XPF_BUS_CHECK_TRANSACTIONTYPE_GENERIC         2

#define XPF_BUS_CHECK_OPERATION_GENERIC               0
#define XPF_BUS_CHECK_OPERATION_GENREAD               1
#define XPF_BUS_CHECK_OPERATION_GENWRITE              2
#define XPF_BUS_CHECK_OPERATION_DATAREAD              3
#define XPF_BUS_CHECK_OPERATION_DATAWRITE             4
#define XPF_BUS_CHECK_OPERATION_INSTRUCTIONFETCH      5
#define XPF_BUS_CHECK_OPERATION_PREFETCH              6

#define XPF_BUS_CHECK_PARTICIPATION_PROCORIGINATED    0
#define XPF_BUS_CHECK_PARTICIPATION_PROCRESPONDED     1
#define XPF_BUS_CHECK_PARTICIPATION_PROCOBSERVED      2
#define XPF_BUS_CHECK_PARTICIPATION_GENERIC           3

#define XPF_BUS_CHECK_ADDRESS_MEMORY                  0
#define XPF_BUS_CHECK_ADDRESS_RESERVED                1
#define XPF_BUS_CHECK_ADDRESS_IO                      2
#define XPF_BUS_CHECK_ADDRESS_OTHER                   3

typedef union _WHEA_XPF_BUS_CHECK {
    struct {
        ULONGLONG TransactionTypeValid:1;
        ULONGLONG OperationValid:1;
        ULONGLONG LevelValid:1;
        ULONGLONG ProcessorContextCorruptValid:1;
        ULONGLONG UncorrectedValid:1;
        ULONGLONG PreciseIPValid:1;
        ULONGLONG RestartableIPValid:1;
        ULONGLONG OverflowValid:1;
        ULONGLONG ParticipationValid:1;
        ULONGLONG TimeoutValid:1;
        ULONGLONG AddressSpaceValid:1;
        ULONGLONG ReservedValid:5;
	ULONGLONG TransactionType:2;
	ULONGLONG Operation:4;
	ULONGLONG Level:3;
	ULONGLONG ProcessorContextCorrupt:1;
	ULONGLONG Uncorrected:1;
	ULONGLONG PreciseIP:1;
	ULONGLONG RestartableIP:1;
	ULONGLONG Overflow:1;
	ULONGLONG Participation:2;
	ULONGLONG Timeout:1;
	ULONGLONG AddressSpace:2;
	ULONGLONG Reserved:29;
    } DUMMYSTRUCTNAME;
    ULONGLONG XpfBusCheck;
} WHEA_XPF_BUS_CHECK, *PWHEA_XPF_BUS_CHECK;

//
// IA32/X64 Micro-Architecture Specific Check Structure
//

#define XPF_MS_CHECK_ERRORTYPE_NOERROR               0
#define XPF_MS_CHECK_ERRORTYPE_UNCLASSIFIED          1
#define XPF_MS_CHECK_ERRORTYPE_MCROMPARITY           2
#define XPF_MS_CHECK_ERRORTYPE_EXTERNAL              3
#define XPF_MS_CHECK_ERRORTYPE_FRC                   4
#define XPF_MS_CHECK_ERRORTYPE_INTERNALUNCLASSIFIED  5

typedef union _WHEA_XPF_MS_CHECK {
    struct {
        ULONGLONG ErrorTypeValid:1;
        ULONGLONG ProcessorContextCorruptValid:1;
        ULONGLONG UncorrectedValid:1;
        ULONGLONG PreciseIPValid:1;
        ULONGLONG RestartableIPValid:1;
        ULONGLONG OverflowValid:1;
        ULONGLONG ReservedValue:10;
        ULONGLONG ErrorType:3;
        ULONGLONG ProcessorContextCorrupt:1;
        ULONGLONG Uncorrected:1;
        ULONGLONG PreciseIP:1;
        ULONGLONG RestartableIP:1;
        ULONGLONG Overflow:1;
        ULONGLONG Reserved:40;
    } DUMMYSTRUCTNAME;
    ULONGLONG XpfMsCheck;
} WHEA_XPF_MS_CHECK, *PWHEA_XPF_MS_CHECK;

//
// IA32/X64 Processor Error Information
//

typedef union _WHEA_XPF_PROCESSOR_ERROR_VALIDBITS {
    struct {
        ULONGLONG LocalAPICId:1;
        ULONGLONG CpuId:1;
        ULONGLONG ProcInfoCount:6;
        ULONGLONG ContextInfoCount:6;
        ULONGLONG Reserved:50;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_XPF_PROCESSOR_ERROR_VALIDBITS, *PWHEA_XPF_PROCESSOR_ERROR_VALIDBITS;

typedef struct _WHEA_XPF_PROCESSOR_ERROR {
    WHEA_XPF_PROCESSOR_ERROR_VALIDBITS ValidBits;
    ULONGLONG LocalAPICId;
    UCHAR CpuId[48];
    UCHAR VariableInfo[1];
} WHEA_XPF_PROCESSOR_ERROR, *PWHEA_XPF_PROCESSOR_ERROR;

typedef union _WHEA_XPF_PROCINFO_VALIDBITS {
    struct {
        ULONGLONG CheckInfo:1;
        ULONGLONG TargetId:1;
        ULONGLONG RequesterId:1;
        ULONGLONG ResponderId:1;
        ULONGLONG InstructionPointer:1;
        ULONGLONG Reserved:59;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_XPF_PROCINFO_VALIDBITS, *PWHEA_XPF_PROCINFO_VALIDBITS;

typedef struct _WHEA_XPF_PROCINFO {
    GUID CheckInfoId;
    WHEA_XPF_PROCINFO_VALIDBITS ValidBits;
    union {
        WHEA_XPF_BUS_CHECK BusCheck;
        WHEA_XPF_CACHE_CHECK CacheCheck;
        WHEA_XPF_MS_CHECK MsCheck;
        WHEA_XPF_TLB_CHECK TlbCheck;
        ULONGLONG AsULONGLONG;
    } CheckInfo;
    ULONGLONG TargetId;
    ULONGLONG RequesterId;
    ULONGLONG ResponderId;
    ULONGLONG InstructionPointer;
} WHEA_XPF_PROCINFO, *PWHEA_XPF_PROCINFO;

//
// IA32/X64 Process Context Structure
//

#define XPF_CONTEXT_INFO_UNCLASSIFIEDDATA       0
#define XPF_CONTEXT_INFO_MSRREGISTERS           1
#define XPF_CONTEXT_INFO_32BITCONTEXT           2
#define XPF_CONTEXT_INFO_64BITCONTEXT           3
#define XPF_CONTEXT_INFO_FXSAVE                 4
#define XPF_CONTEXT_INFO_32BITDEBUGREGS         5
#define XPF_CONTEXT_INFO_64BITDEBUGREGS         6
#define XPF_CONTEXT_INFO_MMREGISTERS            7

typedef struct _WHEA_XPF_CONTEXT_INFO {
    USHORT RegisterContextType;
    USHORT RegisterDataSize;
    ULONG MSRAddress;
    ULONGLONG MmRegisterAddress;
    UCHAR RegisterData[1];
} WHEA_XPF_CONTEXT_INFO, *PWHEA_XPF_CONTEXT_INFO;

typedef struct _WHEA_X86_REGISTER_STATE {
    ULONG Eax;        // +00 (00)
    ULONG Ebx;        // +04 (04)
    ULONG Ecx;        // +08 (08)
    ULONG Edx;        // +0C (12)
    ULONG Esi;        // +10 (16)
    ULONG Edi;        // +14 (20)
    ULONG Ebp;        // +18 (24)
    ULONG Esp;        // +1C (28)
    USHORT Cs;        // +20 (32)
    USHORT Ds;        // +22 (34)
    USHORT Ss;        // +24 (36)
    USHORT Es;        // +26 (38)
    USHORT Fs;        // +28 (40)
    USHORT Gs;        // +2A (42)
    ULONG Eflags;     // +2C (44)
    ULONG Eip;        // +30 (48)
    ULONG Cr0;        // +34 (52)
    ULONG Cr1;        // +38 (56)
    ULONG Cr2;        // +3C (60)
    ULONG Cr3;        // +40 (64)
    ULONG Cr4;        // +44 (68)
    ULONGLONG Gdtr;   // +48 (72)
    ULONGLONG Idtr;   // +50 (80)
    USHORT Ldtr;      // +58 (88)
    USHORT Tr;        // +5A (90)
                      // +5C (92)
} WHEA_X86_REGISTER_STATE, *PWHEA_X86_REGISTER_STATE;

typedef struct _WHEA128A {
    ULONGLONG Low;
    LONGLONG High;
} WHEA128A, *PWHEA128A;

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4324) // structure padded due to __declspec(align())
#endif
#endif

typedef struct _WHEA_X64_REGISTER_STATE {
    ULONGLONG     Rax;            // +00 (00)
    ULONGLONG     Rbx;            // +08 (08)
    ULONGLONG     Rcx;            // +10 (16)
    ULONGLONG     Rdx;            // +18 (24)
    ULONGLONG     Rsi;            // +20 (32)
    ULONGLONG     Rdi;            // +28 (40)
    ULONGLONG     Rbp;            // +30 (48)
    ULONGLONG     Rsp;            // +38 (56)
    ULONGLONG     R8;             // +40 (64)
    ULONGLONG     R9;             // +48 (72)
    ULONGLONG     R10;            // +50 (80)
    ULONGLONG     R11;            // +58 (88)
    ULONGLONG     R12;            // +60 (96)
    ULONGLONG     R13;            // +68 (104)
    ULONGLONG     R14;            // +70 (112)
    ULONGLONG     R15;            // +78 (120)
    USHORT      Cs;               // +80 (128)
    USHORT      Ds;               // +82 (130)
    USHORT      Ss;               // +84 (132)
    USHORT      Es;               // +86 (134)
    USHORT      Fs;               // +88 (136)
    USHORT      Gs;               // +8A (138)
    USHORT      Reserved;         // +8C (140)
    ULONGLONG     Rflags;         // +90 (144)
    ULONGLONG     Eip;            // +98 (152)
    ULONGLONG     Cr0;            // +A0 (160)
    ULONGLONG     Cr1;            // +A8 (168)
    ULONGLONG     Cr2;            // +B0 (176)
    ULONGLONG     Cr3;            // +B8 (184)
    ULONGLONG     Cr4;            // +C0 (192)
    ULONGLONG     Cr8;            // +C8 (200)    
    WHEA128A    Gdtr;             // +D0 (208)    
    WHEA128A    Idtr;             // +E0 (224)    
    USHORT      Ldtr;             // +F0 (240)    
    USHORT      Tr;               // +F2 (242)
                                  // +F4 (244) 
} WHEA_X64_REGISTER_STATE, *PWHEA_X64_REGISTER_STATE;

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(pop)
#endif
#endif

//
// Platform Memory Error
//

typedef union _WHEA_MEMORY_ERROR_VALIDBITS {
    struct {
        ULONGLONG ErrorStatus:1;
        ULONGLONG PhysicalAddress:1;
        ULONGLONG PhysicalAddressMask:1;
        ULONGLONG Node:1;
        ULONGLONG Card:1;
        ULONGLONG Module:1;
        ULONGLONG Bank:1;
        ULONGLONG Device:1;
        ULONGLONG Row:1;
        ULONGLONG Column:1;
        ULONGLONG BitPosition:1;
        ULONGLONG RequesterId:1;
        ULONGLONG ResponderId:1;
        ULONGLONG TargetId:1;
        ULONGLONG ErrorType:1;
        ULONGLONG Reserved:49;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_MEMORY_ERROR_VALIDBITS, *PWHEA_MEMORY_ERROR_VALIDBITS;

#define WHEA_MEMERRTYPE_UNKNOWN                 0x00
#define WHEA_MEMERRTYPE_NOERROR                 0x01
#define WHEA_MEMERRTYPE_SINGLEBITECC            0x02
#define WHEA_MEMERRTYPE_MULTIBITECC             0x03
#define WHEA_MEMERRTYPE_SINGLESYMCHIPKILL       0x04
#define WHEA_MEMERRTYPE_MULTISYMCHIPKILL        0x05
#define WHEA_MEMERRTYPE_MASTERABORT             0x06
#define WHEA_MEMERRTYPE_TARGETABORT             0x07
#define WHEA_MEMERRTYPE_PARITYERROR             0x08
#define WHEA_MEMERRTYPE_WATCHDOGTIMEOUT         0x09
#define WHEA_MEMERRTYPE_INVALIDADDRESS          0x0A
#define WHEA_MEMERRTYPE_MIRRORBROKEN            0x0B
#define WHEA_MEMERRTYPE_MEMORYSPARING           0x0C

typedef struct _WHEA_MEMORY_ERROR {
    WHEA_MEMORY_ERROR_VALIDBITS ValidBits; // 0x00 (00)
    WHEA_ERROR_STATUS ErrorStatus;         // 0x08 (08)
    ULONGLONG PhysicalAddress;             // 0x10 (16)
    ULONGLONG PhysicalAddressMask;         // 0x18 (24)
    USHORT Node;                           // 0x20 (32)
    USHORT Card;                           // 0x22 (34)
    USHORT Module;                         // 0x24 (36)
    USHORT Bank;                           // 0x26 (38)
    USHORT Device;                         // 0x28 (40)
    USHORT Row;                            // 0x2A (42)
    USHORT Column;                         // 0x2C (44)
    USHORT BitPosition;                    // 0x2E (46)
    ULONGLONG RequesterId;                 // 0x30 (48)
    ULONGLONG ResponderId;                 // 0x38 (56)
    ULONGLONG TargetId;                    // 0x40 (64)
    UCHAR ErrorType;                       // 0x48 (72)
                                           // 0x49 (73)
} WHEA_MEMORY_ERROR, *PWHEA_MEMORY_ERROR;

//
// NMI Error.
//

typedef union _WHEA_NMI_ERROR_FLAGS {
    struct {
        ULONG HypervisorError:1;
        ULONG Reserved:31;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_NMI_ERROR_FLAGS, *PWHEA_NMI_ERROR_FLAGS;

typedef struct _WHEA_NMI_ERROR {
    UCHAR Data[8];                         // 0x00 (00)
    WHEA_NMI_ERROR_FLAGS Flags;            // 0x08 (08)
                                           // 0x0C (12)
} WHEA_NMI_ERROR, *PWHEA_NMI_ERROR;

//
// PCI Express Error
//

typedef union _WHEA_PCIEXPRESS_ERROR_VALIDBITS {
    struct {
        ULONGLONG PortType:1;
        ULONGLONG Version:1;
        ULONGLONG CommandStatus:1;
        ULONGLONG DeviceId:1;
        ULONGLONG DeviceSerialNumber:1;
        ULONGLONG BridgeControlStatus:1;
        ULONGLONG ExpressCapability:1;
        ULONGLONG AerInfo:1;
        ULONGLONG Reserved:56;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_PCIEXPRESS_ERROR_VALIDBITS, *PWHEA_PCIEXPRESS_ERROR_VALIDBITS;

typedef struct _WHEA_PCIEXPRESS_DEVICE_ID {
    USHORT VendorID;                         // 0x00 (00)
    USHORT DeviceID;                         // 0x02 (02)
    ULONG ClassCode:24;                      // 0x04 (04)
    ULONG FunctionNumber:8;                  // 0x07 (07)
    ULONG DeviceNumber:8;                    // 0x08 (08)
    ULONG Segment:16;                        // 0x09 (09)
    ULONG PrimaryBusNumber:8;                // 0x0B (11)
    ULONG SecondaryBusNumber:8;              // 0x0C (12)
    ULONG Reserved1:2;                       // 0x0D (13)
    ULONG SlotNumber:14;                     // 0x0E (14)
    ULONG Reserved2:8;                       // 0x0F (15)
                                             // 0x10 (16)
} WHEA_PCIEXPRESS_DEVICE_ID, *PWHEA_PCIEXPRESS_DEVICE_ID;

typedef union _WHEA_PCIEXPRESS_VERSION {
    struct {
        UCHAR MinorVersion;
        UCHAR MajorVersion;
        USHORT Reserved;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_PCIEXPRESS_VERSION, *PWHEA_PCIEXPRESS_VERSION;
    
typedef union _WHEA_PCIEXPRESS_COMMAND_STATUS {
    struct {
        USHORT Command;
        USHORT Status;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_PCIEXPRESS_COMMAND_STATUS, *PWHEA_PCIEXPRESS_COMMAND_STATUS;

typedef union _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS {
    struct {
        USHORT BridgeSecondaryStatus;
        USHORT BridgeControl;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS, 
    *PWHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS;

typedef enum {
    WheaPciExpressEndpoint = 0,
    WheaPciExpressLegacyEndpoint,
    WheaPciExpressRootPort = 4,
    WheaPciExpressUpstreamSwitchPort,
    WheaPciExpressDownstreamSwitchPort,
    WheaPciExpressToPciXBridge,
    WheaPciXToExpressBridge,
    WheaPciExpressRootComplexIntegratedEndpoint,
    WheaPciExpressRootComplexEventCollector
} WHEA_PCIEXPRESS_DEVICE_TYPE;

typedef struct _WHEA_PCIEXPRESS_ERROR {
    WHEA_PCIEXPRESS_ERROR_VALIDBITS ValidBits;                 // 0x00 (00)
    WHEA_PCIEXPRESS_DEVICE_TYPE PortType;                      // 0x08 (08)
    WHEA_PCIEXPRESS_VERSION Version;                           // 0x0C (12)
    WHEA_PCIEXPRESS_COMMAND_STATUS CommandStatus;              // 0x10 (16)
    ULONG Reserved;                                            // 0x14 (20)
    WHEA_PCIEXPRESS_DEVICE_ID DeviceId;                        // 0x18 (24)
    ULONGLONG DeviceSerialNumber;                              // 0x28 (40)
    WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS BridgeControlStatus; // 0x30 (48)
    UCHAR ExpressCapability[60];                               // 0x34 (52)
    UCHAR AerInfo[96];                                         // 0x70 (112)
                                                               // 0xD0 (208)
} WHEA_PCIEXPRESS_ERROR, *PWHEA_PCIEXPRESS_ERROR;

//
// PCI/PCI-X Bus Error
//

#define PCIXBUS_ERRTYPE_UNKNOWN             0x0000
#define PCIXBUS_ERRTYPE_DATAPARITY          0x0001
#define PCIXBUS_ERRTYPE_SYSTEM              0x0002
#define PCIXBUS_ERRTYPE_MASTERABORT         0x0003
#define PCIXBUS_ERRTYPE_BUSTIMEOUT          0x0004
#define PCIXBUS_ERRTYPE_MASTERDATAPARITY    0x0005
#define PCIXBUS_ERRTYPE_ADDRESSPARITY       0x0006
#define PCIXBUS_ERRTYPE_COMMANDPARITY       0x0007

typedef union _WHEA_PCIXBUS_ERROR_VALIDBITS {
    struct {
        ULONGLONG ErrorStatus:1;
        ULONGLONG ErrorType:1;
        ULONGLONG BusId:1;
        ULONGLONG BusAddress:1;
        ULONGLONG BusData:1;
        ULONGLONG BusCommand:1;
        ULONGLONG RequesterId:1;
        ULONGLONG CompleterId:1;
        ULONGLONG TargetId:1;
        ULONGLONG Reserved:55;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_PCIXBUS_ERROR_VALIDBITS, *PWHEA_PCIXBUS_ERROR_VALIDBITS;

typedef union _WHEA_PCIXBUS_ID {
    struct {
        UCHAR BusNumber;
        UCHAR BusSegment;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} WHEA_PCIXBUS_ID, *PWHEA_PCIXBUS_ID;

typedef union _WHEA_PCIXBUS_COMMAND {
    struct {
        ULONGLONG Command:56;
        ULONGLONG PCIXCommand:1;
        ULONGLONG Reserved:7;
    } DUMMYSTRUCTNAME;
    ULONGLONG AsULONGLONG;
} WHEA_PCIXBUS_COMMAND, *PWHEA_PCIXBUS_COMMAND;

typedef struct _WHEA_PCIXBUS_ERROR {
    WHEA_PCIXBUS_ERROR_VALIDBITS ValidBits;         // 0x00 (00)
    WHEA_ERROR_STATUS ErrorStatus;                  // 0x08 (08)
    USHORT ErrorType;                               // 0x10 (16)
    WHEA_PCIXBUS_ID BusId;                          // 0x12 (18)
    ULONG Reserved;                                 // 0x14 (20)
    ULONGLONG BusAddress;                           // 0x18 (24)
    ULONGLONG BusData;                              // 0x20 (32)
    WHEA_PCIXBUS_COMMAND BusCommand;                // 0x28 (40)
    ULONGLONG RequesterId;                          // 0x30 (48)
    ULONGLONG CompleterId;                          // 0x38 (56)
    ULONGLONG TargetId;                             // 0x40 (64)
                                                    // 0x48 (72)
} WHEA_PCIXBUS_ERROR, *PWHEA_PCIXBUS_ERROR;

//
// PCI/PCI_X Component Error
//

typedef union _WHEA_PCIXDEVICE_ERROR_VALIDBITS {
    struct {
        ULONGLONG ErrorStatus:1;
        ULONGLONG IdInfo:1;
        ULONGLONG MemoryNumber:1;
        ULONGLONG IoNumber:1;
        ULONGLONG RegisterDataPairs:1;
        ULONGLONG Reserved:59;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_PCIXDEVICE_ERROR_VALIDBITS, *PWHEA_PCIXDEVICE_ERROR_VALIDBITS;

typedef struct _WHEA_PCIXDEVICE_ID {
    USHORT VendorId;
    USHORT DeviceId;
    ULONG ClassCode:24;
    ULONG FunctionNumber:8;
    ULONG DeviceNumber:8;
    ULONG BusNumber:8;
    ULONG SegmentNumber:8;
    ULONG Reserved1:8;
    ULONG Reserved2;
} WHEA_PCIXDEVICE_ID, *PWHEA_PCIXDEVICE_ID;

typedef struct WHEA_PCIXDEVICE_REGISTER_PAIR {
    ULONGLONG Register;
    ULONGLONG Data;
} WHEA_PCIXDEVICE_REGISTER_PAIR, *PWHEA_PCIXDEVICE_REGISTER_PAIR;

typedef struct _WHEA_PCIXDEVICE_ERROR {
    WHEA_PCIXDEVICE_ERROR_VALIDBITS ValidBits;          // 0x00 (00)
    WHEA_ERROR_STATUS ErrorStatus;                      // 0x08 (08)
    WHEA_PCIXDEVICE_ID IdInfo;                          // 0x10 (16)
    ULONG MemoryNumber;                                 // 0x20 (32)
    ULONG IoNumber;                                     // 0x24 (36)
    WHEA_PCIXDEVICE_REGISTER_PAIR RegisterDataPairs[4]; // 0x28 (42)
                                                        // 0x8C (140)
} WHEA_PCIXDEVICE_ERROR, *PWHEA_PCIXDEVICE_ERROR;

//
// Firmware reference.
//

#define WHEA_FIRMWARE_RECORD_TYPE_IPFSAL 0

typedef struct _WHEA_FIRMWARE_RECORD {
    UCHAR Type;
    UCHAR Reserved[7];
    ULONGLONG FirmwareRecordId;
} WHEA_FIRMWARE_RECORD, *PWHEA_FIRMWARE_RECORD;

//
// All generic error status blocks must have the following format.
//

typedef union _WHEA_GENERIC_ERROR_BLOCKSTATUS {
    struct {
        ULONG UncorrectableError:1;
        ULONG CorrectableError:1;
        ULONG MultipleUncorrectableErrors:1;
        ULONG MultipleCorrectableErrors:1;
        ULONG ErrorDataEntryCount:10;
        ULONG Reserved:18;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_GENERIC_ERROR_BLOCKSTATUS, *PWHEA_GENERIC_ERROR_BLOCKSTATUS;

typedef struct _WHEA_GENERIC_ERROR {
    WHEA_GENERIC_ERROR_BLOCKSTATUS BlockStatus;
    ULONG RawDataOffset;
    ULONG RawDataLength;
    ULONG DataLength;
    WHEA_ERROR_SEVERITY ErrorSeverity;
    UCHAR Data[1];
} WHEA_GENERIC_ERROR, *PWHEA_GENERIC_ERROR;

typedef struct _WHEA_GENERIC_ERROR_DATA_ENTRY {
    GUID SectionType;
    WHEA_ERROR_SEVERITY ErrorSeverity;
    WHEA_REVISION Revision;
    UCHAR ValidBits;
    UCHAR Flags;
    ULONG ErrorDataLength;
    GUID FRUId;
    UCHAR FRUText[20];
    UCHAR Data[1];
} WHEA_GENERIC_ERROR_DATA_ENTRY, *PWHEA_GENERIC_ERROR_DATA_ENTRY;

typedef union _WHEA_BOOT_ERROR_VALIDBITS {
    struct {
        UCHAR FRUId:1;
        UCHAR FRUString:1;
        UCHAR ErrorData:1;
        UCHAR Reserved:5;
    } DUMMYSTRUCTNAME;
    UCHAR AsUCHAR;
} WHEA_BOOT_ERROR_VALIDBITS, *PWHEA_BOOT_ERROR_VALIDBITS;

#define WHEA_BOOT_ERROR_DESCRIPTION_UNKNOWN      0
#define WHEA_BOOT_ERROR_DESCRIPTION_FWRESET      1
#define WHEA_BOOT_ERROR_DESCRIPTION_SPRESET      2
#define WHEA_BOOT_ERROR_DESCRIPTION_HUNGSYSTEM   3

#define WHEA_BOOT_ERROR_TYPE_PROCESSOR           0x00
#define WHEA_BOOT_ERROR_TYPE_MEMORY              0x01
#define WHEA_BOOT_ERROR_TYPE_PCIEXPRESS          0x02
#define WHEA_BOOT_ERROR_TYPE_NMI                 0x03
#define WHEA_BOOT_ERROR_TYPE_PCIXBUS             0x04
#define WHEA_BOOT_ERROR_TYPE_PCIXDEVICE          0x05
#define WHEA_BOOT_ERROR_TYPE_GENERIC             0x06

typedef struct _WHEA_BOOT_ERROR_STATUS {
    UCHAR ErrorPresent;
    WHEA_BOOT_ERROR_VALIDBITS ValidBits;
    UCHAR ErrorDescription;
    UCHAR Reserved;
    ULONG ErrorDataLength;
    GUID Type;
    UCHAR FRUId[16];
    UCHAR FRUString[24];
    UCHAR ErrorData[1];    
} WHEA_BOOT_ERROR_STATUS, *PWHEA_BOOT_ERROR_STATUS;

#define WHEA_ERROR_PKT_SIGNATURE 'tPrE'
#define WHEA_ERROR_PKT_VERSION   2

#define WHEA_ERROR_PKT_FLAGS_PREVERROR             0x00000001
#define WHEA_ERROR_PKT_FLAGS_CPUVALID              0x00000002
#define WHEA_ERROR_PKT_FLAGS_HVERROR               0x00000004
#define WHEA_ERROR_PKT_FLAGS_SIMULATED             0x00000008

typedef union _WHEA_ERROR_PACKET_FLAGS {
    struct {
        ULONG PreviousError:1;
        ULONG CpuValid:1;
        ULONG HypervisorError:1;
        ULONG Simulated:1;
        ULONG Reserved:28;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_PACKET_FLAGS, *PWHEA_ERROR_PACKET_FLAGS;
    
typedef struct _WHEA_ERROR_PACKET {

    ULONG                   Signature;                  // +0x00 (0)
    WHEA_ERROR_PACKET_FLAGS Flags;                      // +0x04 (4)
    ULONG                   Size;                       // +0x08 (8)
    ULONG                   RawDataLength;              // +0x0C (12)
    ULONGLONG               Reserved1;                  // +0x10 (16)
    ULONGLONG               Context;                    // +0x18 (24)
    WHEA_ERROR_TYPE         ErrorType;                  // +0x20 (32)
    WHEA_ERROR_SEVERITY     ErrorSeverity;              // +0x24 (36)
    ULONG                   ErrorSourceId;              // +0x28 (40)
    WHEA_ERROR_SOURCE_TYPE  ErrorSourceType;            // +0x2C (44)
    ULONG                   Reserved2;                  // +0x30 (48)
    ULONG                   Version;                    // +0x34 (52)
    ULONGLONG               Cpu;                        // +0x38 (56)

    union {                                             // +0x40 (64)
        WHEA_GENERIC_PROCESSOR_ERROR ProcessorError;
        WHEA_MEMORY_ERROR            MemoryError;
        WHEA_NMI_ERROR               NmiError;
        WHEA_PCIEXPRESS_ERROR        PciExpressError;
        WHEA_PCIXBUS_ERROR           PciXBusError;
        WHEA_PCIXDEVICE_ERROR        PciXDeviceError;
    } u;

    WHEA_RAW_DATA_FORMAT     RawDataFormat;             // +0x110 (272)
    ULONG                    RawDataOffset;             // +0x114 (276)    
    UCHAR                    RawData[1];               // +0x118 (280)

} WHEA_ERROR_PACKET, *PWHEA_ERROR_PACKET;

#define WHEA_ERROR_PACKET_LENGTH FIELD_OFFSET(WHEA_ERROR_PACKET, RawData)

typedef USHORT WHEA_ERROR_RECORD_ID, *PWHEA_ERROR_RECORD_ID;

//
// An error section descriptor provides key information about an error section
// contained in an error record.
//

#define WHEA_SECTION_DESCRIPTOR_FLAGS_PRIMARY            0x00000001
#define WHEA_SECTION_DESCRIPTOR_FLAGS_CONTAINMENTWRN     0x00000002
#define WHEA_SECTION_DESCRIPTOR_FLAGS_RESET              0x00000004
#define WHEA_SECTION_DESCRIPTOR_FLAGS_THRESHOLDEXCEEDED  0x00000008
#define WHEA_SECTION_DESCRIPTOR_FLAGS_RESOURCENA         0x00000010
#define WHEA_SECTION_DESCRIPTOR_FLAGS_LATENTERROR        0x00000020

#define WHEA_SECTION_DESCRIPTOR_REVISION                 0x0201

typedef union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    struct {
        ULONG Primary:1;
        ULONG ContainmentWarning:1;
        ULONG Reset:1;
        ULONG ThresholdExceeded:1;
        ULONG ResourceNotAvailable:1;
        ULONG LatentError:1;
        ULONG Reserved:26;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS, 
    *PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS;

typedef union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    struct {
        UCHAR FRUId:1;
        UCHAR FRUText:1;
        UCHAR Reserved:6;
    } DUMMYSTRUCTNAME;
    UCHAR AsUCHAR;
} WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS, 
    *PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS;

typedef struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    ULONG SectionOffset;                                       // +0x00
    ULONG SectionLength;                                       // +0x04
    WHEA_REVISION Revision;                                    // +0x08
    WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS ValidBits;  // +0x0A
    UCHAR Reserved;                                            // +0x0B
    WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS Flags;          // +0x0C
    GUID SectionType;                                          // +0x10
    GUID FRUId;                                                // +0x20
    WHEA_ERROR_SEVERITY SectionSeverity;                       // +0x30 
    CCHAR FRUText[20];                                         // +0x34
                                                               // +0x48
} WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, *PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR;

//
// Information used by the error record serialization interface.
//

typedef union _WHEA_PERSISTENCE_INFO {
    struct {
        ULONGLONG Signature:16;
        ULONGLONG Length:24;
        ULONGLONG Identifier:16;
        ULONGLONG Attributes:2;
        ULONGLONG DoNotLog:1;
        ULONGLONG Reserved:5;
    } DUMMYSTRUCTNAME;
    ULONGLONG AsULONGLONG;
} WHEA_PERSISTENCE_INFO, *PWHEA_PERSISTENCE_INFO;

#define WHEA_ERROR_RECORD_FLAGS_RECOVERED            0x00000001
#define WHEA_ERROR_RECORD_FLAGS_PREVIOUSERROR        0x00000002
#define WHEA_ERROR_RECORD_FLAGS_SIMULATED            0x00000004

typedef union _WHEA_ERROR_RECORD_HEADER_FLAGS {
    struct {
        ULONG Recovered:1;
        ULONG PreviousError:1;
        ULONG Simulated:1;
        ULONG Reserved:29;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_RECORD_HEADER_FLAGS, *PWHEA_ERROR_RECORD_HEADER_FLAGS;

#define WHEA_ERROR_RECORD_VALID_PLATFORMID           0x00000001
#define WHEA_ERROR_RECORD_VALID_TIMESTAMP            0x00000002
#define WHEA_ERROR_RECORD_VALID_PARTITIONID          0x00000004

typedef union _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    struct {
        ULONG Timestamp:1;
        ULONG PlatformId:1;
        ULONG PartitionId:1;
        ULONG Reserved:29;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_RECORD_HEADER_VALIDBITS, *PWHEA_ERROR_RECORD_HEADER_VALIDBITS;

typedef union _WHEA_TIMESTAMP {
    struct {
        ULONGLONG Seconds:8;
        ULONGLONG Minutes:8;
        ULONGLONG Hours:8;
        ULONGLONG Reserved:8;
        ULONGLONG Day:8;
        ULONGLONG Month:8;
        ULONGLONG Year:8;
        ULONGLONG Century:8;
    } DUMMYSTRUCTNAME;
    LARGE_INTEGER AsLARGE_INTEGER;
} WHEA_TIMESTAMP, *PWHEA_TIMESTAMP;

#define WHEA_ERROR_RECORD_REVISION                   0x0201

//
// The error record header provides key information about a hardware error
// condition. A record consists of the header plus at least one section. There
// can be multiple sections, describing a given error conditions.
//

typedef struct _WHEA_ERROR_RECORD_HEADER {
    ULONG Signature;                                 // +0x00
    WHEA_REVISION Revision;                          // +0x04
    ULONG SignatureEnd;                              // +0x06 Must be 0xFFFFFFFF
    USHORT SectionCount;                             // +0x0A
    WHEA_ERROR_SEVERITY Severity;                    // +0x0C
    WHEA_ERROR_RECORD_HEADER_VALIDBITS ValidBits;    // +0x10
    ULONG Length;                                    // +0x14
    WHEA_TIMESTAMP Timestamp;                        // +0x18
    GUID PlatformId;                                 // +0x20
    GUID PartitionId;                                // +0x30
    GUID CreatorId;                                  // +0x40
    GUID NotifyType;                                 // +0x50
    ULONGLONG RecordId;                              // +0x60
    WHEA_ERROR_RECORD_HEADER_FLAGS Flags;            // +0x68
    WHEA_PERSISTENCE_INFO PersistenceInfo;           // +0x6C
    UCHAR Reserved[12];                              // +0x74
                                                     // +0x80
} WHEA_ERROR_RECORD_HEADER, *PWHEA_ERROR_RECORD_HEADER;

//
// Common hardware error record. An error record is expected to contain at
// least one section.
//
typedef struct _WHEA_ERROR_RECORD {
    WHEA_ERROR_RECORD_HEADER              Header;
    WHEA_ERROR_RECORD_SECTION_DESCRIPTOR  SectionDescriptor[1];
} WHEA_ERROR_RECORD, *PWHEA_ERROR_RECORD;
#include <poppack.h>

#define WHEA_ERROR_RECORD_SIGNATURE 'REPC'

#define WheaIsPreviousError(_record_) \
    ((_record_)->Header.Flags & WHEA_ERROR_RECORD_FLAGS_PREVIOUSERROR)

typedef
NTSTATUS
(*WHEA_ERROR_SOURCE_INITIALIZER)(
    __in ULONG Phase,
    __inout PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    __inout_opt PVOID Context
    );

NTSTATUS
WheaReportHwError(
    __inout PWHEA_ERROR_PACKET ErrPkt
    );

NTKERNELAPI
NTSTATUS
WheaAddErrorSource(
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    __in_opt PVOID Context
    );

NTKERNELAPI
NTSTATUS
WheaRemoveErrorSource(
    __in HANDLE Handle
    );

NTSTATUS
WheaRegisterErrSrcInitializer(
    __in WHEA_ERROR_SOURCE_TYPE ErrorSource,
    __in WHEA_ERROR_SOURCE_INITIALIZER Initializer
    );

PWHEA_ERROR_SOURCE_DESCRIPTOR
WheaGetErrorSource (
    __in ULONG ErrorSourceId
    );

FORCEINLINE
PWHEA_ERROR_PACKET
WheaGetErrPacketFromErrRecord (
    __in PWHEA_ERROR_RECORD Record
    )
{

    GUID Guid;
    ULONG Offset;
    PWHEA_ERROR_PACKET Packet;
    ULONG SectionNumber;
    ULONG Size;
    GUID WheaPktSectionType = WHEA_PACKET_SECTION_GUID;

    NT_ASSERT(Record->Header.Signature == WHEA_ERROR_RECORD_SIGNATURE);
    if (Record->Header.Signature != WHEA_ERROR_RECORD_SIGNATURE) {
        return NULL;
    }

    Size = (sizeof(WHEA_ERROR_RECORD_HEADER)) +
            (sizeof(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR) *
             Record->Header.SectionCount);

    if (Record->Header.Length < Size) {
        return NULL;
    }

    for (SectionNumber = 0;
         SectionNumber < Record->Header.SectionCount;
         SectionNumber += 1) {

        RtlCopyMemory(&Guid,
                      &Record->SectionDescriptor[SectionNumber].SectionType,
                      sizeof(GUID));

        if (RtlCompareMemory(&Guid, &WheaPktSectionType, sizeof(GUID)) == 
            sizeof(GUID)) {

            Offset = Record->SectionDescriptor[SectionNumber].SectionOffset;
            Size = (Offset + 
                    Record->SectionDescriptor[SectionNumber].SectionLength);

            if (Record->Header.Length < Size) {
                return NULL;
            }

            Packet = (PWHEA_ERROR_PACKET)((PUCHAR)Record + Offset);
            NT_ASSERT(Packet->Signature == WHEA_ERROR_PKT_SIGNATURE);
            return Packet;
        }
    }

    return NULL;
}

#define INJECT_ERRTYPE_PROCESSOR_CORRECTABLE                    0x00000001
#define INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLENONFATAL          0x00000002
#define INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLEFATAL             0x00000004
#define INJECT_ERRTYPE_MEMORY_CORRECTABLE                       0x00000008
#define INJECT_ERRTYPE_MEMORY_UNCORRECTABLENONFATAL             0x00000010
#define INJECT_ERRTYPE_MEMORY_UNCORRECTABLEFATAL                0x00000020
#define INJECT_ERRTYPE_PCIEXPRESS_CORRECTABLE                   0x00000040
#define INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLENONFATAL         0x00000080
#define INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLEFATAL            0x00000100
#define INJECT_ERRTYPE_PLATFORM_CORRECTABLE                     0x00000200
#define INJECT_ERRTYPE_PLATFORM_UNCORRECTABLENONFATAL           0x00000400
#define INJECT_ERRTYPE_PLATFORM_UNCORRECTABLEFATAL              0x00000800

//
// This union is used to communicate the platform's error injection capabilities
// to the OS.
//

typedef union _WHEA_ERROR_INJECTION_CAPABILITIES {
    struct {
        ULONG ProcessorCorrectable:1;                   // 0x00000001
        ULONG ProcessorUncorrectableNonFatal:1;         // 0x00000002
        ULONG ProcessorUncorrectableFatal:1;            // 0x00000004
        ULONG MemoryCorrectable:1;                      // 0x00000008
        ULONG MemoryUncorrectableNonFatal:1;            // 0x00000010
        ULONG MemoryUncorrectableFatal:1;               // 0x00000020
        ULONG PCIExpressCorrectable:1;                  // 0x00000040
        ULONG PCIExpressUncorrectableNonFatal:1;        // 0x00000080
        ULONG PCIExpressUncorrectableFatal:1;           // 0x00000100
        ULONG PlatformCorrectable:1;                    // 0x00000200
        ULONG PlatformUncorrectableNonFatal:1;          // 0x00000400
        ULONG PlatformUncorrectableFatal:1;             // 0x00000800
        ULONG IA64Corrected:1;                          // 0x00001000
        ULONG IA64Recoverable:1;                        // 0x00002000
        ULONG IA64Fatal:1;                              // 0x00004000
        ULONG IA64RecoverableCache:1;                   // 0x00008000
        ULONG IA64RecoverableRegFile:1;                 // 0x00010000
        ULONG Reserved:15;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_INJECTION_CAPABILITIES, *PWHEA_ERROR_INJECTION_CAPABILITIES;

#define PshedFADiscovery              0x00000001
#define PshedFAErrorSourceControl     0x00000002
#define PshedFAErrorRecordPersistence 0x00000004
#define PshedFAErrorInfoRetrieval     0x00000008
#define PshedFAErrorRecovery          0x00000010
#define PshedFAErrorInjection         0x00000020

typedef
NTSTATUS
(*PSHED_PI_GET_ALL_ERROR_SOURCES) (
    __inout_opt PVOID PluginContext,
    __inout PULONG Count,
    __inout_bcount(*Length) PWHEA_ERROR_SOURCE_DESCRIPTOR *ErrorSrcs,
    __inout PULONG Length
    );

typedef
NTSTATUS
(*PSHED_PI_GET_ERROR_SOURCE_INFO) (
    __inout_opt PVOID PluginContext,
    __inout PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

typedef
NTSTATUS
(*PSHED_PI_SET_ERROR_SOURCE_INFO) (
    __inout_opt PVOID PluginContext,
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

typedef
NTSTATUS
 (*PSHED_PI_ENABLE_ERROR_SOURCE) (
    __inout_opt PVOID PluginContext,
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

typedef
NTSTATUS
 (*PSHED_PI_DISABLE_ERROR_SOURCE) (
    __inout_opt PVOID PluginContext,
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

typedef
NTSTATUS
(*PSHED_PI_WRITE_ERROR_RECORD) (
    __inout_opt PVOID PluginContext,
    __in ULONG Flags,
    __in ULONG RecordLength,
    __in_bcount(RecordLength) PWHEA_ERROR_RECORD ErrorRecord
    );

typedef
NTSTATUS
(*PSHED_PI_READ_ERROR_RECORD) (
    __inout_opt PVOID PluginContext,
    __in ULONG Flags,
    __in ULONGLONG ErrorRecordId,
    __out PULONGLONG NextErrorRecordId,
    __inout PULONG RecordLength,
    __out_bcount(*RecordLength) PWHEA_ERROR_RECORD ErrorRecord
    );

typedef
NTSTATUS
(*PSHED_PI_CLEAR_ERROR_RECORD) (
    __inout_opt PVOID PluginContext,
    __in ULONG Flags,
    __in ULONGLONG ErrorRecordId
    );

typedef
NTSTATUS
(*PSHED_PI_RETRIEVE_ERROR_INFO) (
    __inout_opt PVOID PluginContext,
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    __in ULONGLONG BufferLength,
    __inout_bcount(BufferLength) PWHEA_ERROR_PACKET Packet
    );

typedef
NTSTATUS
(*PSHED_PI_FINALIZE_ERROR_RECORD) (
    __inout_opt PVOID PluginContext,
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    __in ULONG BufferLength,
    __inout_bcount(BufferLength) PWHEA_ERROR_RECORD ErrorRecord
    );

typedef
NTSTATUS
(*PSHED_PI_CLEAR_ERROR_STATUS) (
    __inout_opt PVOID PluginContext,
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    __in ULONG BufferLength,
    __in_bcount(BufferLength) PWHEA_ERROR_RECORD ErrorRecord
    );

typedef
NTSTATUS
(*PSHED_PI_ATTEMPT_ERROR_RECOVERY) (
    __inout_opt PVOID PluginContext,
    __in ULONG BufferLength,
    __in_bcount(BufferLength) PWHEA_ERROR_RECORD ErrorRecord
    );

typedef
NTSTATUS
(*PSHED_PI_GET_INJECTION_CAPABILITIES) (
    __inout_opt PVOID PluginContext,
    __out PWHEA_ERROR_INJECTION_CAPABILITIES Capabilities
    );

typedef
NTSTATUS
(*PSHED_PI_INJECT_ERROR) (
    __inout_opt PVOID PluginContext,
    __in ULONGLONG ErrorType,
    __in ULONGLONG Parameter1,
    __in ULONGLONG Parameter2,
    __in ULONGLONG Parameter3,
    __in ULONGLONG Parameter4
    );

typedef struct _WHEA_PSHED_PLUGIN_CALLBACKS {
    PSHED_PI_GET_ALL_ERROR_SOURCES GetAllErrorSources;
    PVOID Reserved;
    PSHED_PI_GET_ERROR_SOURCE_INFO GetErrorSourceInfo;
    PSHED_PI_SET_ERROR_SOURCE_INFO SetErrorSourceInfo;
    PSHED_PI_ENABLE_ERROR_SOURCE EnableErrorSource;
    PSHED_PI_DISABLE_ERROR_SOURCE DisableErrorSource;
    PSHED_PI_WRITE_ERROR_RECORD WriteErrorRecord;
    PSHED_PI_READ_ERROR_RECORD ReadErrorRecord;
    PSHED_PI_CLEAR_ERROR_RECORD ClearErrorRecord;
    PSHED_PI_RETRIEVE_ERROR_INFO RetrieveErrorInfo;
    PSHED_PI_FINALIZE_ERROR_RECORD FinalizeErrorRecord;
    PSHED_PI_CLEAR_ERROR_STATUS ClearErrorStatus;
    PSHED_PI_ATTEMPT_ERROR_RECOVERY AttemptRecovery;
    PSHED_PI_GET_INJECTION_CAPABILITIES GetInjectionCapabilities;
    PSHED_PI_INJECT_ERROR InjectError;
} WHEA_PSHED_PLUGIN_CALLBACKS, 
 *PWHEA_PSHED_PLUGIN_CALLBACKS;

#define WHEA_PLUGIN_REGISTRATION_PACKET_VERSION 0x00010000

typedef struct _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET {
    ULONG Length;
    ULONG Version;
    PVOID Context;
    ULONG FunctionalAreaMask;
    ULONG Reserved;
    WHEA_PSHED_PLUGIN_CALLBACKS Callbacks;
} WHEA_PSHED_PLUGIN_REGISTRATION_PACKET, 
  *PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET;

typedef struct _WHEA_PSHED_INIT_PACKET {
    ULONG Size;
    ULONG Version;
} WHEA_PSHED_INIT_PACKET, *PWHEA_PSHED_INIT_PACKET;

#define WHEA_WRITE_FLAG_DUMMY 0x00000001

PVOID
PshedAllocateMemory (
    __in ULONG Size
    );

NTSTATUS
PshedAttemptErrorRecovery(
    __inout PWHEA_ERROR_RECORD ErrorRecord
    );

VOID
PshedBugCheckSystem(
    __in PWHEA_ERROR_RECORD ErrorRecord
    );

NTSTATUS
PshedClearErrorRecord(
    __in ULONG Flags,
    __in ULONGLONG RecordId
    );

NTSTATUS
PshedDisableErrorSource (
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

NTSTATUS
PshedEnableErrorSource (
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

NTSTATUS
PshedFinalizeErrorRecord(
    __inout PWHEA_ERROR_RECORD ErrorRecord,
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

VOID
PshedFreeMemory (
    __in PVOID Address
    );

NTSTATUS
PshedGetAllErrorSources (
    __out PULONG ErrorSourceCount,
    __inout_bcount(*Length) PUCHAR *Buffer,
    __inout PULONG Length
    );

NTSTATUS
PshedGetBootErrorPacket (
    __out PULONG BootPacketLength,
    __out PWHEA_ERROR_PACKET *BootPacket
    );

NTSTATUS
PshedGetErrorSourceInfo (
    __in WHEA_ERROR_SOURCE_TYPE ErrorSource,
    __inout PWHEA_ERROR_SOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
PshedGetInjectionCapabilities (
    __out PWHEA_ERROR_INJECTION_CAPABILITIES Capabilities
    );

VOID
PshedHandleCorrectedError (
    __in PWHEA_ERROR_PACKET Packet
    );

NTSTATUS
PshedInjectError (
    __in ULONG ErrorType,
    __in ULONGLONG Parameter1,
    __in ULONGLONG Parameter2,
    __in ULONGLONG Parameter3,
    __in ULONGLONG Parameter4
    );

BOOLEAN
PshedIsSystemWheaEnabled (
    VOID
    );

NTSTATUS
PshedReadErrorRecord(
    __in ULONG Flags,
    __in ULONGLONG ErrorRecordId,
    __out PULONGLONG NextErrorRecordId,
    __out PULONG RecordLength,
    __out_bcount(*RecordLength) PWHEA_ERROR_RECORD *ErrorRecord
    );

NTSTATUS
PshedRegisterPlugin (
    __inout PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET Packet
    );

NTSTATUS
PshedRetrieveErrorInfo (
    __inout PWHEA_ERROR_PACKET ErrorPkt,
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

NTSTATUS
PshedSetErrorSourceInfo (
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

BOOLEAN
PshedSynchronizeExecution (
    __in PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    __in PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    __in PVOID SynchronizeContext
    );

NTSTATUS
PshedWriteErrorRecord(
    __in ULONG Flags,
    __in ULONG RecordLength,
    __in_bcount(RecordLength) PWHEA_ERROR_RECORD ErrorRecord
    );



#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4115)
#pragma warning(default:4201)
#pragma warning(default:4214)
#endif

#endif // _NTDDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntddsfio.h ===
/*++ 

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddsfio.h

Abstract:

    This is the include file that defines all common constants, ioctls and types
    for Scheduled File I/O (SFIO).

Revision History:

--*/
#if (NTDDI_VERSION >= NTDDI_VISTA)

#pragma once

typedef enum _IO_ACCESS_TYPE {

    //
    // Indicates  that the  Io will
    // be comprised solely of reads
    //
    ReadAccess,

    //
    // Indicates  that  the  Io will
    // be comprised solely of writes
    //
    WriteAccess,

    //
    // Indicates that the Io will be
    // comprised of reads and writes
    //
    ModifyAccess

} IO_ACCESS_TYPE;

typedef enum _IO_ACCESS_MODE {

    //
    // Indicates  that the  Io will be
    // sent down in a sequential order
    //
    SequentialAccess,

    //
    // Indicates  that the  Io might
    // not be in a predictable order
    //
    RandomAccess
    
} IO_ACCESS_MODE;

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntddsd.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    ntddsd.h

Abstract:

    This is the include file that defines the SD (aka Secure Digital)
    bus driver interface.


--*/

#ifndef _NTDDSDH_
#define _NTDDSDH_

#if _MSC_VER > 1000
#pragma once
#endif

#include <sddef.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Use this version in the interface_data structure
//

#define SDBUS_INTERFACE_VERSION 0x101

//
// Prototype of the callback routine which is called for SDIO
// devices to reflect device interrupts.
//

typedef
VOID
(*PSDBUS_CALLBACK_ROUTINE) (
    IN PVOID CallbackRoutineContext,
    IN ULONG InterruptType
    );

#define SDBUS_INTTYPE_DEVICE    0

//
// The interface parameters structure is passed to the InitializeInterface
// function in the SDBUS_INTERFACE_STANDARD
//

typedef struct _SDBUS_INTERFACE_PARAMETERS {
    USHORT Size;
    USHORT Reserved;

    //
    // Points to next lower device object in the device stack.
    //
    PDEVICE_OBJECT TargetObject;

    //
    // This flag indicates whether the caller expects any device
    // interrupts from the device.
    //
    BOOLEAN DeviceGeneratesInterrupts;

    //
    // The caller can specify here the IRQL at which the callback
    // function is entered. If this value is TRUE, the callback will
    // be entered at DPC level. If this value is FALSE, the callback
    // will be entered at passive level.
    //
    // Specifying TRUE will generally lower latency time of the interrupt
    // delivery, at the cost of complicating the device driver, which
    // must then deal with running at different IRQLs.
    //
    BOOLEAN CallbackAtDpcLevel;

    //
    // When an IO device interrupts, the SD bus driver will generate a
    // callback to this routine. The caller must supply this pointer if
    // the field DeviceGeneratesInterrupts was set to TRUE;
    //
    PSDBUS_CALLBACK_ROUTINE CallbackRoutine;

    //
    // The caller can specify here a context value which will be passed
    // to the device interrupt callback routine.
    //
    PVOID CallbackRoutineContext;

} SDBUS_INTERFACE_PARAMETERS, *PSDBUS_INTERFACE_PARAMETERS;

//
// Prototype of function used to initialize the the interface once
// it has been opened.
//

typedef
NTSTATUS
(*PSDBUS_INITIALIZE_INTERFACE_ROUTINE)(
    IN PVOID Context,
    IN PSDBUS_INTERFACE_PARAMETERS InterfaceParameters
    );


//
// Prototype of routine that the function driver must call
// when the function driver has completed its interrupt processing
//

typedef
NTSTATUS
(*PSDBUS_ACKNOWLEDGE_INT_ROUTINE)(
    IN PVOID Context
    );


//
// SDBUS_INTERFACE_STANDARD
//
// Interface Data structure used in the SdBusOpenInterface call. This
// structure defines the communication path between the SD function
// driver and the bus driver.
//

DEFINE_GUID( GUID_SDBUS_INTERFACE_STANDARD, 0x6bb24d81L, 0xe924, 0x4825, 0xaf, 0x49, 0x3a, 0xcd, 0x33, 0xc1, 0xd8, 0x20 );


typedef struct _SDBUS_INTERFACE_STANDARD {
    USHORT Size;
    USHORT Version;
    //
    // Interface Context
    //
    // This context pointer is filled in by the bus driver during the call
    // to SdBusOpenInterface(). This data must be passed as a parameter to
    // the other interface functions.
    //
    PVOID Context;

    //
    // Interface Reference/Dereference maintain the interface's reference
    // count. The reference count is automatically incremented to 1 when
    // the interface is opened. The caller must dereference the interface
    // under the following circumstances:
    //  a) the function driver receives a query_remove IRP
    //  b) the function driver receives a surprise_remove IRP
    //  c) the function driver receives a remove IRP without either a
    //     query_remove or a surprise_remove.
    //
    // In all cases, the function driver should dereference the interface
    // before passing the respective IRP down to the bus driver.
    //
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // After the interface has been opened, the bus driver will have filled
    // in the pointer to the following routine which allows the function
    // driver to set the parameters of the interface.
    //

    PSDBUS_INITIALIZE_INTERFACE_ROUTINE InitializeInterface;

    //
    // NTSTATUS SdBusAcknowledgeInterrupt(InterfaceContext)
    //
    // This routine is filled in by the call to SdBusOpenInterface(),
    // and is used by the function driver to indicate when processing
    // of an IO device interrupt is complete.
    //
    // When an IO function of an SD device asserts an interrupt, the bus
    // driver will disable that interrupt to allow I/O operations to be
    // sent to the device at a reasonable IRQL (that is, <=DISPATCH_LEVEL).
    //
    // When the function driver's callback routine, which is equivalent to
    // an ISR, is done clearing the function's interrupt, this routine should
    // be called to re-enable the IRQ for card interrupts.
    //
    // Callers must be running at IRQL <= DISPATCH_LEVEL.
    //
    // Returns STATUS_UNSUCCESSFUL if the InterfaceContext pointer is invalid.
    //

    PSDBUS_ACKNOWLEDGE_INT_ROUTINE AcknowledgeInterrupt;

} SDBUS_INTERFACE_STANDARD, *PSDBUS_INTERFACE_STANDARD;


//
// SdBusOpenInterface()
//
// This routine establishes a connection to the SD bus driver.
// It should be called in the AddDevice routine with the FDO for
// the device stack is created.
//
// If STATUS_SUCCESS is returned, then the InterfaceData structure
// is filled in with valid function pointers and an interface context
// parameter. The context pointer must be used in all other SD bus
// driver calls.
//
// Callers must be running at IRQL < DISPATCH_LEVEL.
//

NTSTATUS
SdBusOpenInterface(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PSDBUS_INTERFACE_STANDARD InterfaceStandard,
    IN USHORT Size,
    IN USHORT Version
    );


//
// Definitions for properties used in Get/Set Property requests
//
// The bus driver version where any given property was introduced is 
// indicated as a comment to the right of the property. Note that the
// property to retrieve the version was not introduced until v2.0.
// Callers can determine the bus driver is at version 1.0 by looking
// for a STATUS_INVALID_PARAMETER return from an get property call on
// SDP_BUS_DRIVER_VERSION.
//

typedef enum {
    SDP_MEDIA_CHANGECOUNT = 0,          // v1.0  ULONG
    SDP_MEDIA_STATE,                    // v1.0  SDPROP_MEDIA_STATE
    SDP_WRITE_PROTECTED,                // v1.0  BOOLEAN
    SDP_FUNCTION_NUMBER,                // v1.0  UCHAR
    SDP_FUNCTION_TYPE,                  // v2.0  SDBUS_FUNCTION_TYPE
    SDP_BUS_DRIVER_VERSION,             // v2.0  USHORT
    SDP_BUS_WIDTH,                      // v2.0  UCHAR
    SDP_BUS_CLOCK,                      // v2.0  ULONG
    SDP_BUS_INTERFACE_CONTROL,          // v2.0  UCHAR
    SDP_HOST_BLOCK_LENGTH,              // v2.0  USHORT
    SDP_FUNCTION_BLOCK_LENGTH,          // v2.0  USHORT
    SDP_FN0_BLOCK_LENGTH,               // v2.0  USHORT
    SDP_FUNCTION_INT_ENABLE,            // v2.0  BOOLEAN
} SDBUS_PROPERTY;

//
// Bus driver versions
//

#define SDBUS_DRIVER_VERSION_1          0x100
#define SDBUS_DRIVER_VERSION_2          0x200

//
// Media states defined for SDP_MEDIA_STATE
//

typedef enum {
    SDPMS_NO_MEDIA = 0,
    SDPMS_MEDIA_INSERTED
} SDPROP_MEDIA_STATE;


//
// Values defined for SDP_FUNCTION_TYPE
//

typedef enum {
    SDBUS_FUNCTION_TYPE_UNKNOWN = 0,
    SDBUS_FUNCTION_TYPE_SDIO,
    SDBUS_FUNCTION_TYPE_SD_MEMORY,
    SDBUS_FUNCTION_TYPE_MMC_MEMORY,
} SDBUS_FUNCTION_TYPE;

#define IsTypeMemory(type) ((type == SDBUS_FUNCTION_TYPE_SD_MEMORY) || \
                            (type == SDBUS_FUNCTION_TYPE_MMC_MEMORY))
#define IsTypeIo(type)      (type == SDBUS_FUNCTION_TYPE_SDIO)


//
// Data structures for request packets
//

typedef enum {
    SDRF_GET_PROPERTY,
    SDRF_SET_PROPERTY,
    SDRF_DEVICE_COMMAND
} SD_REQUEST_FUNCTION;


//
// SDBUS_REQUEST_PACKET
//
// This structure specifies parameters for individual requests
// and commands sent to the bus driver by SdBusSubmitRequest()
//

typedef struct _SDBUS_REQUEST_PACKET {

    //
    // specifies the parameters for the operation, and how they
    // are interpreted
    //
    SD_REQUEST_FUNCTION RequestFunction;

    //
    // These context fields are provided for the optional use of the caller.
    // They are not referenced by the bus driver
    //
    PVOID UserContext[3];

    //
    // Information from the operation. Its usage is equivalent to
    // the Irp->IoStatus.Information field. For example, the length
    // of data transmitted for read/write operations will be filled
    // in here by the bus driver.
    //
    ULONG_PTR Information;

    //
    // Response data and length is returned by the device. Maximum
    // returned is 16 bytes. The content of this field is defined
    // in the SD spec.
    //
    union {
        UCHAR AsUCHAR[16];
        ULONG AsULONG[4];
        SDRESP_TYPE3 Type3;
    } ResponseData;
    UCHAR ResponseLength;

    //
    // Parameters to the individual functions
    //
    union {

        //
        // The property functions allow the caller to control aspects of
        // bus driver operation.
        //

        struct {
            SDBUS_PROPERTY Property;
            PVOID Buffer;
            ULONG Length;
        } GetSetProperty;

        //
        // DeviceCommand is the 'pipe' that allows SD device codes and arguments
        // to be executed. These codes are either defined in the SD spec,
        // can be based per device class, or can also be proprietary.
        //

        struct {
            SDCMD_DESCRIPTOR CmdDesc;
            ULONG Argument;
            PMDL Mdl;
            ULONG Length;
        } DeviceCommand;

    } Parameters;


} SDBUS_REQUEST_PACKET, *PSDBUS_REQUEST_PACKET;



//
// SdBusSubmitRequest()
// SdBusSubmitRequestAsync()
//
// These routines send SD request packets to the bus driver. The SubmitRequest
// version is synchronous, and must be called at IRQL < DISPATCH_LEVEL. The
// SubmitRequestAsync version is asynchronous, and the user must supply an IRP
// and completion routine.
//
// Arguments:
//
//  InterfaceContext - this is the context pointer returned by the
//                     SdBusOpenInterface() call.
//
//  Packet           - The parameters of the request are specified in this
//                     SDBUS_REQUEST_PACKET, which is allocated by the caller.
//
//  Irp              - The passed IRP will be used to transfer the request
//                     packet to the bus driver. It can either be a new irp
//                     allocated by the caller just for this request, or it can
//                     also be an IRP the caller is processing. The packet will
//                     be placed in the Parameters.Others.Argument1 of the IRP.
//
//  CompletionRoutine- When the request is completed by the bus driver, this
//                     completion routine will be called.
//
//  UserContext      - This context will be passed to the specified CompletionRoutine
//
// Notes:
//
//  Callers of SdBusSubmitRequest must be running at IRQL < DISPATCH_LEVEL.
//  Callers of SdBusSubmitRequestAsync must be running at IRQL <= DISPATCH_LEVEL.
//

NTSTATUS
SdBusSubmitRequest(
    IN PVOID InterfaceContext,
    IN PSDBUS_REQUEST_PACKET Packet
    );

NTSTATUS
SdBusSubmitRequestAsync(
    IN PVOID InterfaceContext,
    IN PSDBUS_REQUEST_PACKET Packet,
    IN PIRP Irp,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID UserContext
    );


//
// IoControlCode values used in this interface. There normally should be no
// need to use these values directly, as SDBUS.LIB provides the support routines
// which issue these IOCTLs to the bus driver.
//
//

#define IOCTL_SDBUS_BASE                FILE_DEVICE_CONTROLLER
#define IOCTL_SD_SUBMIT_REQUEST         CTL_CODE(IOCTL_SDBUS_BASE, 3100, METHOD_NEITHER, FILE_ANY_ACCESS)


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntddpcm.h ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    ntddpcm.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the PCMCIA Adapters.

--*/

#ifndef _NTDDPCMH_
#define _NTDDPCMH_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//
// Note: The IOCTL interface to pcmcia host controllers is turned off by
//       default. These IOCTLs are provided for testing purposes only. To
//       turn on this interface, add the following registry value:
// HKLM\SYSTEM\CurrentControlSet\Services\Pcmcia\Parameters\IoctlInterface : REG_DWORD : 1
//

#define IOCTL_PCMCIA_BASE                 FILE_DEVICE_CONTROLLER

#define DD_PCMCIA_DEVICE_NAME "\\\\.\\Pcmcia"

//
// IoControlCode values for this device.
//

#define IOCTL_GET_TUPLE_DATA         CTL_CODE(IOCTL_PCMCIA_BASE, 3000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SOCKET_INFORMATION     CTL_CODE(IOCTL_PCMCIA_BASE, 3004, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PCMCIA_HIDE_DEVICE     CTL_CODE(IOCTL_PCMCIA_BASE, 3010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_PCMCIA_REVEAL_DEVICE   CTL_CODE(IOCTL_PCMCIA_BASE, 3011, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Tuple request parameters.
//

typedef struct _PCMCIA_SOCKET_REQUEST {
   USHORT  Socket;
} PCMCIA_SOCKET_REQUEST, *PPCMCIA_SOCKET_REQUEST;

typedef struct _TUPLE_REQUEST {
   USHORT  Socket;
} TUPLE_REQUEST, *PTUPLE_REQUEST;

#define MANUFACTURER_NAME_LENGTH 64
#define DEVICE_IDENTIFIER_LENGTH 64
#define DRIVER_NAME_LENGTH       32

#define PcmciaInvalidControllerType 0xffffffff

//
// Controller classes returned in socket information structure.
//

typedef enum _PCMCIA_CONTROLLER_CLASS {
   PcmciaInvalidControllerClass = -1,
   PcmciaIntelCompatible,
   PcmciaCardBusCompatible,
   PcmciaElcController,
   PcmciaDatabook,     
   PcmciaPciPcmciaBridge,
   PcmciaCirrusLogic,  
   PcmciaTI,           
   PcmciaTopic,        
   PcmciaRicoh,        
   PcmciaDatabookCB,   
   PcmciaOpti,         
   PcmciaTrid,         
   PcmciaO2Micro,      
   PcmciaNEC,          
   PcmciaNEC_98                
} PCMCIA_CONTROLLER_CLASS, *PPCMCIA_CONTROLLER_CLASS;


typedef struct _PCMCIA_SOCKET_INFORMATION {
   USHORT  Socket;
   USHORT  TupleCrc;
   UCHAR   Manufacturer[MANUFACTURER_NAME_LENGTH];
   UCHAR   Identifier[DEVICE_IDENTIFIER_LENGTH];
   UCHAR   DriverName[DRIVER_NAME_LENGTH];
   UCHAR   DeviceFunctionId;
   UCHAR   Reserved;
   UCHAR   CardInSocket;
   UCHAR   CardEnabled;
   ULONG   ControllerType;
} PCMCIA_SOCKET_INFORMATION, *PPCMCIA_SOCKET_INFORMATION;

//
// macros to crack the ControllerId field of the socket info structure
//
#define PcmciaClassFromControllerType(type) ((PCMCIA_CONTROLLER_CLASS)((type) & 0xff))
#define PcmciaModelFromControllerType(type) (((type) >> 8) & 0x3ffff)
#define PcmciaRevisionFromControllerType(type) ((type) >> 26)

//
// Begin pcmcia exported interfaces to other drivers
//

#ifdef _NTDDK_

DEFINE_GUID( GUID_PCMCIA_INTERFACE_STANDARD,     0xbed5dadfL, 0x38fb, 0x11d1, 0x94, 0x62, 0x00, 0xc0, 0x4f, 0xb9, 0x60, 0xee);

#define  PCMCIA_MEMORY_8BIT_ACCESS     0
#define  PCMCIA_MEMORY_16BIT_ACCESS    1

typedef
BOOLEAN
(*PPCMCIA_MODIFY_MEMORY_WINDOW)(
                               IN   PVOID Context,
                               IN   ULONGLONG HostBase,
                               IN   ULONGLONG CardBase,
                               IN   BOOLEAN Enable,
                               IN   ULONG   WindowSize OPTIONAL,
                               IN   UCHAR   AccessSpeed OPTIONAL,
                               IN   UCHAR   BusWidth OPTIONAL,
                               IN   BOOLEAN IsAttributeMemory OPTIONAL
                               );

#define     PCMCIA_VPP_0V     0
#define     PCMCIA_VPP_12V    1
#define     PCMCIA_VPP_IS_VCC 2

typedef
BOOLEAN
(*PPCMCIA_SET_VPP)(
                  IN  PVOID Context,
                  IN  UCHAR VppLevel
                  );

typedef
BOOLEAN
(*PPCMCIA_IS_WRITE_PROTECTED)(
                             IN PVOID Context
                             );

//
// These are interfaces for manipulating memory windows, setting Vpp etc.,
// primarily used by flash memory card drivers
//
typedef struct _PCMCIA_INTERFACE_STANDARD {
   USHORT Size;
   USHORT Version;
   PINTERFACE_REFERENCE InterfaceReference;
   PINTERFACE_DEREFERENCE  InterfaceDereference;
   PVOID Context;
   PPCMCIA_MODIFY_MEMORY_WINDOW ModifyMemoryWindow;
   PPCMCIA_SET_VPP           SetVpp;
   PPCMCIA_IS_WRITE_PROTECTED     IsWriteProtected;
} PCMCIA_INTERFACE_STANDARD, *PPCMCIA_INTERFACE_STANDARD;

//
// Definitions for PCMCIA_BUS_INTERFACE_STANDARD.
// This interface is obtained using GUID_PCMCIA_BUS_INTERFACE_STANDARD
// and is used for reading/writing to PCMCIA config. space
//

typedef
ULONG
(*PPCMCIA_READ_WRITE_CONFIG) (
                             IN PVOID   Context,
                             IN ULONG   WhichSpace,
                             IN PUCHAR  Buffer,
                             IN ULONG   Offset,
                             IN ULONG   Length
                             );
//
// WhichSpace for IRP_MN_READ_CONFIG/WRITE_CONFIG
// and PCMCIA_BUS_INTERFACE_STANDARD
//
typedef ULONG MEMORY_SPACE;

#define    PCCARD_PCI_CONFIGURATION_SPACE    0  // for cardbus cards
#define    PCCARD_ATTRIBUTE_MEMORY           1
#define    PCCARD_COMMON_MEMORY              2
#define    PCCARD_ATTRIBUTE_MEMORY_INDIRECT  3
#define    PCCARD_COMMON_MEMORY_INDIRECT     4

// Legacy support
//
#define    PCMCIA_CONFIG_SPACE               PCCARD_ATTRIBUTE_MEMORY

typedef struct _PCMCIA_BUS_INTERFACE_STANDARD {
   //
   // generic interface header
   //
   USHORT Size;
   USHORT Version;
   PVOID Context;
   PINTERFACE_REFERENCE InterfaceReference;
   PINTERFACE_DEREFERENCE InterfaceDereference;
   //
   // standard PCMCIA bus interfaces
   //
   PPCMCIA_READ_WRITE_CONFIG ReadConfig;
   PPCMCIA_READ_WRITE_CONFIG WriteConfig;
} PCMCIA_BUS_INTERFACE_STANDARD, *PPCMCIA_BUS_INTERFACE_STANDARD;

#endif

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntifs.h ===
/*++ BUILD Version: 0146    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntifs.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to file system drivers.

Revision History:

--*/

#ifndef _NTIFS_
#define _NTIFS_

#define _NTIFS_INCLUDED_

#ifndef RC_INVOKED
#if _MSC_VER < 1300
#error Compiler version not supported by Windows DDK
#endif
#endif // RC_INVOKED

#ifndef __cplusplus
#pragma warning(disable:4116)       // TYPE_ALIGNMENT generates this - move it
                                    // outside the warning push/pop scope.
#endif

#define NT_INCLUDED
#define _NTMSV1_0_
#define _CTYPE_DISABLE_MACROS

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4115) // named type definition in parentheses
#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int


#include <ntddk.h>
#include <excpt.h>
#include <ntdef.h>
#include <ntnls.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>


//
//  These macros are used to test, set and clear flags respectivly
//

#ifndef FlagOn
#define FlagOn(_F,_SF)        ((_F) & (_SF))
#endif

#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF)   ((BOOLEAN)(((F) & (SF)) != 0))
#endif

#ifndef SetFlag
#define SetFlag(_F,_SF)       ((_F) |= (_SF))
#endif

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif

//
// Define types that are not exported.
//

typedef struct _BUS_HANDLER *PBUS_HANDLER;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _DEVICE_HANDLER_OBJECT *PDEVICE_HANDLER_OBJECT;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _KPROCESS *PKPROCESS ,*PRKPROCESS, *PEPROCESS;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD, *PETHREAD;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _PEB *PPEB;
typedef struct _ACL *PACL;

#ifdef __cplusplus
extern "C" {
#endif

#define PsGetCurrentProcess IoGetCurrentProcess

#if (NTDDI_VERSION >= NTDDI_VISTA)
extern NTSYSAPI volatile CCHAR KeNumberProcessors;
#else
#if (NTDDI_VERSION >= NTDDI_WINXP)
extern NTSYSAPI CCHAR KeNumberProcessors;
#else
extern PCCHAR KeNumberProcessors;
#endif
#endif

#ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
#define SID_IDENTIFIER_AUTHORITY_DEFINED
typedef struct _SID_IDENTIFIER_AUTHORITY {
    UCHAR Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;
#endif


#ifndef SID_DEFINED
#define SID_DEFINED
typedef struct _SID {
   UCHAR Revision;
   UCHAR SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
#ifdef MIDL_PASS
   [size_is(SubAuthorityCount)] ULONG SubAuthority[*];
#else // MIDL_PASS
   ULONG SubAuthority[ANYSIZE_ARRAY];
#endif // MIDL_PASS
} SID, *PISID;
#endif

#define SID_REVISION                     (1)    // Current revision level
#define SID_MAX_SUB_AUTHORITIES          (15)
#define SID_RECOMMENDED_SUB_AUTHORITIES  (1)    // Will change to around 6

                                                // in a future release.
#ifndef MIDL_PASS
#define SECURITY_MAX_SID_SIZE  \
      (sizeof(SID) - sizeof(ULONG) + (SID_MAX_SUB_AUTHORITIES * sizeof(ULONG)))
#endif // MIDL_PASS


typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {
    PSID Sid;
    ULONG Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;

#define SID_HASH_SIZE 32
typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
    ULONG SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[SID_HASH_SIZE];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID                     S-1-0-0                                //
//     World                        S-1-1-0                                //
//     Local                        S-1-2-0                                //
//     Creator Owner ID             S-1-3-0                                //
//     Creator Group ID             S-1-3-1                                //
//     Creator Owner Server ID      S-1-3-2                                //
//     Creator Group Server ID      S-1-3-3                                //
//                                                                         //
//     (Non-unique IDs)             S-1-4                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define SECURITY_NULL_SID_AUTHORITY         {0,0,0,0,0,0}
#define SECURITY_WORLD_SID_AUTHORITY        {0,0,0,0,0,1}
#define SECURITY_LOCAL_SID_AUTHORITY        {0,0,0,0,0,2}
#define SECURITY_CREATOR_SID_AUTHORITY      {0,0,0,0,0,3}
#define SECURITY_NON_UNIQUE_AUTHORITY       {0,0,0,0,0,4}
#define SECURITY_RESOURCE_MANAGER_AUTHORITY {0,0,0,0,0,9}

#define SECURITY_NULL_RID                 (0x00000000L)
#define SECURITY_WORLD_RID                (0x00000000L)
#define SECURITY_LOCAL_RID                (0x00000000L)

#define SECURITY_CREATOR_OWNER_RID        (0x00000000L)
#define SECURITY_CREATOR_GROUP_RID        (0x00000001L)

#define SECURITY_CREATOR_OWNER_SERVER_RID (0x00000002L)
#define SECURITY_CREATOR_GROUP_SERVER_RID (0x00000003L)

#define SECURITY_CREATOR_OWNER_RIGHTS_RID (0x00000004L)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// NT well-known SIDs                                                        //
//                                                                           //
//     NT Authority            S-1-5                                         //
//     Dialup                  S-1-5-1                                       //
//                                                                           //
//     Network                 S-1-5-2                                       //
//     Batch                   S-1-5-3                                       //
//     Interactive             S-1-5-4                                       //
//     (Logon IDs)             S-1-5-5-X-Y                                   //
//     Service                 S-1-5-6                                       //
//     AnonymousLogon          S-1-5-7       (aka null logon session)        //
//     Proxy                   S-1-5-8                                       //
//     Enterprise DC (EDC)     S-1-5-9       (aka domain controller account) //
//     Self                    S-1-5-10      (self RID)                      //
//     Authenticated User      S-1-5-11      (Authenticated user somewhere)  //
//     Restricted Code         S-1-5-12      (Running restricted code)       //
//     Terminal Server         S-1-5-13      (Running on Terminal Server)    //
//     Remote Logon            S-1-5-14      (Remote Interactive Logon)      //
//     This Organization       S-1-5-15                                      //
//                                                                           //
//     IUser                   S-1-5-17
//     Local System            S-1-5-18                                      //
//     Local Service           S-1-5-19                                      //
//     Network Service         S-1-5-20                                      //
//                                                                           //
//     (NT non-unique IDs)     S-1-5-0x15-... (NT Domain Sids)               //
//                                                                           //
//     (Built-in domain)       S-1-5-0x20                                    //
//                                                                           //
//     (Security Package IDs)  S-1-5-0x40                                    //
//     NTLM Authentication     S-1-5-0x40-10                                 //
//     SChannel Authentication S-1-5-0x40-14                                 //
//     Digest Authentication   S-1-5-0x40-21                                 //
//                                                                           //
//     Other Organization      S-1-5-1000    (>=1000 can not be filtered)    //
//                                                                           //
//                                                                           //
// NOTE: the relative identifier values (RIDs) determine which security      //
//       boundaries the SID is allowed to cross.  Before adding new RIDs,    //
//       a determination needs to be made regarding which range they should  //
//       be added to in order to ensure proper "SID filtering"               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#define SECURITY_NT_AUTHORITY           {0,0,0,0,0,5}   // ntifs

#define SECURITY_DIALUP_RID             (0x00000001L)
#define SECURITY_NETWORK_RID            (0x00000002L)
#define SECURITY_BATCH_RID              (0x00000003L)
#define SECURITY_INTERACTIVE_RID        (0x00000004L)
#define SECURITY_LOGON_IDS_RID          (0x00000005L)
#define SECURITY_LOGON_IDS_RID_COUNT    (3L)
#define SECURITY_SERVICE_RID            (0x00000006L)
#define SECURITY_ANONYMOUS_LOGON_RID    (0x00000007L)
#define SECURITY_PROXY_RID              (0x00000008L)
#define SECURITY_ENTERPRISE_CONTROLLERS_RID (0x00000009L)
#define SECURITY_SERVER_LOGON_RID       SECURITY_ENTERPRISE_CONTROLLERS_RID
#define SECURITY_PRINCIPAL_SELF_RID     (0x0000000AL)
#define SECURITY_AUTHENTICATED_USER_RID (0x0000000BL)
#define SECURITY_RESTRICTED_CODE_RID    (0x0000000CL)
#define SECURITY_TERMINAL_SERVER_RID    (0x0000000DL)
#define SECURITY_REMOTE_LOGON_RID       (0x0000000EL)
#define SECURITY_THIS_ORGANIZATION_RID  (0x0000000FL)
#define SECURITY_IUSER_RID              (0x00000011L)
#define SECURITY_LOCAL_SYSTEM_RID       (0x00000012L)
#define SECURITY_LOCAL_SERVICE_RID      (0x00000013L)
#define SECURITY_NETWORK_SERVICE_RID    (0x00000014L)

#define SECURITY_NT_NON_UNIQUE          (0x00000015L)
#define SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT  (3L)

#define SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID (0x00000016L)

#define SECURITY_BUILTIN_DOMAIN_RID     (0x00000020L)
#define SECURITY_WRITE_RESTRICTED_CODE_RID (0x00000021L)


#define SECURITY_PACKAGE_BASE_RID       (0x00000040L)
#define SECURITY_PACKAGE_RID_COUNT      (2L)
#define SECURITY_PACKAGE_NTLM_RID       (0x0000000AL)
#define SECURITY_PACKAGE_SCHANNEL_RID   (0x0000000EL)
#define SECURITY_PACKAGE_DIGEST_RID     (0x00000015L)

#define SECURITY_MIN_BASE_RID		(0x00000050L)

#define SECURITY_SERVICE_ID_BASE_RID    (0x00000050L)
#define SECURITY_SERVICE_ID_RID_COUNT   (6L)

#define SECURITY_RESERVED_ID_BASE_RID   (0x00000051L)

#define SECURITY_APPPOOL_ID_BASE_RID    (0x00000052L)
#define SECURITY_APPPOOL_ID_RID_COUNT   (6L)

#define SECURITY_VIRTUALSERVER_ID_BASE_RID    (0x00000053L)
#define SECURITY_VIRTUALSERVER_ID_RID_COUNT   (6L)

#define SECURITY_MAX_BASE_RID		(0x0000006FL)

#define SECURITY_MAX_ALWAYS_FILTERED    (0x000003E7L)
#define SECURITY_MIN_NEVER_FILTERED     (0x000003E8L)

#define SECURITY_OTHER_ORGANIZATION_RID (0x000003E8L)



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////



#define DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS (0x000001F2L)

#define FOREST_USER_RID_MAX            (0x000001F3L)

// Well-known users ...

#define DOMAIN_USER_RID_ADMIN          (0x000001F4L)
#define DOMAIN_USER_RID_GUEST          (0x000001F5L)
#define DOMAIN_USER_RID_KRBTGT         (0x000001F6L)

#define DOMAIN_USER_RID_MAX            (0x000003E7L)


// well-known groups ...

#define DOMAIN_GROUP_RID_ADMINS        (0x00000200L)
#define DOMAIN_GROUP_RID_USERS         (0x00000201L)
#define DOMAIN_GROUP_RID_GUESTS        (0x00000202L)
#define DOMAIN_GROUP_RID_COMPUTERS     (0x00000203L)
#define DOMAIN_GROUP_RID_CONTROLLERS   (0x00000204L)
#define DOMAIN_GROUP_RID_CERT_ADMINS   (0x00000205L)
#define DOMAIN_GROUP_RID_SCHEMA_ADMINS (0x00000206L)
#define DOMAIN_GROUP_RID_ENTERPRISE_ADMINS (0x00000207L)
#define DOMAIN_GROUP_RID_POLICY_ADMINS (0x00000208L)
#define DOMAIN_GROUP_RID_READONLY_CONTROLLERS (0x00000209L)

// well-known aliases ...

#define DOMAIN_ALIAS_RID_ADMINS                         (0x00000220L)
#define DOMAIN_ALIAS_RID_USERS                          (0x00000221L)
#define DOMAIN_ALIAS_RID_GUESTS                         (0x00000222L)
#define DOMAIN_ALIAS_RID_POWER_USERS                    (0x00000223L)

#define DOMAIN_ALIAS_RID_ACCOUNT_OPS                    (0x00000224L)
#define DOMAIN_ALIAS_RID_SYSTEM_OPS                     (0x00000225L)
#define DOMAIN_ALIAS_RID_PRINT_OPS                      (0x00000226L)
#define DOMAIN_ALIAS_RID_BACKUP_OPS                     (0x00000227L)

#define DOMAIN_ALIAS_RID_REPLICATOR                     (0x00000228L)
#define DOMAIN_ALIAS_RID_RAS_SERVERS                    (0x00000229L)
#define DOMAIN_ALIAS_RID_PREW2KCOMPACCESS               (0x0000022AL)
#define DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS           (0x0000022BL)
#define DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS      (0x0000022CL)
#define DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS (0x0000022DL)

#define DOMAIN_ALIAS_RID_MONITORING_USERS               (0x0000022EL)
#define DOMAIN_ALIAS_RID_LOGGING_USERS                  (0x0000022FL)
#define DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS            (0x00000230L)
#define DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS             (0x00000231L)
#define DOMAIN_ALIAS_RID_DCOM_USERS                     (0x00000232L)
#define DOMAIN_ALIAS_RID_IUSERS                         (0x00000238L)
#define DOMAIN_ALIAS_RID_CRYPTO_OPERATORS               (0x00000239L)
#define DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP     (0x0000023BL)
#define DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP (0x0000023CL)
#define DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP        (0x0000023DL)
#define DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP      (0x0000023EL)


#define SECURITY_MANDATORY_LABEL_AUTHORITY          {0,0,0,0,0,16}
#define SECURITY_MANDATORY_UNTRUSTED_RID            (0x00000000L)
#define SECURITY_MANDATORY_LOW_RID                  (0x00001000L)
#define SECURITY_MANDATORY_MEDIUM_RID               (0x00002000L)
#define SECURITY_MANDATORY_HIGH_RID                 (0x00003000L)
#define SECURITY_MANDATORY_SYSTEM_RID               (0x00004000L)
#define SECURITY_MANDATORY_PROTECTED_PROCESS_RID    (0x00005000L)

//
// SECURITY_MANDATORY_MAXIMUM_USER_RID is the highest RID that
// can be set by a usermode caller.
//

#define SECURITY_MANDATORY_MAXIMUM_USER_RID   SECURITY_MANDATORY_SYSTEM_RID

#define MANDATORY_LEVEL_TO_MANDATORY_RID(IL) (IL * 0x1000)

//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3e7 = 999)
//

#define SYSTEM_LUID                     { 0x3e7, 0x0 }
#define ANONYMOUS_LOGON_LUID            { 0x3e6, 0x0 }
#define LOCALSERVICE_LUID               { 0x3e5, 0x0 }
#define NETWORKSERVICE_LUID             { 0x3e4, 0x0 }
#define IUSER_LUID                      { 0x3e3, 0x0 }


//
//  The structure of an ACE is a common ace header followed by ace type
//  specific data.  Pictorally the structure of the common ace header is
//  as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |            AceSize            |    AceFlags   |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//
//  AceType denotes the type of the ace, there are some predefined ace
//  types
//
//  AceSize is the size, in bytes, of ace.
//
//  AceFlags are the Ace flags for audit and inheritance, defined shortly.

typedef struct _ACE_HEADER {
    UCHAR AceType;
    UCHAR AceFlags;
    USHORT AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;

//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//

#define ACCESS_MIN_MS_ACE_TYPE                  (0x0)
#define ACCESS_ALLOWED_ACE_TYPE                 (0x0)
#define ACCESS_DENIED_ACE_TYPE                  (0x1)
#define SYSTEM_AUDIT_ACE_TYPE                   (0x2)
#define SYSTEM_ALARM_ACE_TYPE                   (0x3)
#define ACCESS_MAX_MS_V2_ACE_TYPE               (0x3)

#define ACCESS_ALLOWED_COMPOUND_ACE_TYPE        (0x4)
#define ACCESS_MAX_MS_V3_ACE_TYPE               (0x4)

#define ACCESS_MIN_MS_OBJECT_ACE_TYPE           (0x5)
#define ACCESS_ALLOWED_OBJECT_ACE_TYPE          (0x5)
#define ACCESS_DENIED_OBJECT_ACE_TYPE           (0x6)
#define SYSTEM_AUDIT_OBJECT_ACE_TYPE            (0x7)
#define SYSTEM_ALARM_OBJECT_ACE_TYPE            (0x8)
#define ACCESS_MAX_MS_OBJECT_ACE_TYPE           (0x8)

#define ACCESS_MAX_MS_V4_ACE_TYPE               (0x8)
#define ACCESS_MAX_MS_ACE_TYPE                  (0x8)

#define ACCESS_ALLOWED_CALLBACK_ACE_TYPE        (0x9)
#define ACCESS_DENIED_CALLBACK_ACE_TYPE         (0xA)
#define ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE (0xB)
#define ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE  (0xC)
#define SYSTEM_AUDIT_CALLBACK_ACE_TYPE          (0xD)
#define SYSTEM_ALARM_CALLBACK_ACE_TYPE          (0xE)
#define SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE   (0xF)
#define SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE   (0x10)

#define SYSTEM_MANDATORY_LABEL_ACE_TYPE         (0x11)
#define ACCESS_MAX_MS_V5_ACE_TYPE               (0x11)

// end_winnt


// begin_winnt

//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//

#define OBJECT_INHERIT_ACE                (0x1)
#define CONTAINER_INHERIT_ACE             (0x2)
#define NO_PROPAGATE_INHERIT_ACE          (0x4)
#define INHERIT_ONLY_ACE                  (0x8)
#define INHERITED_ACE                     (0x10)
#define VALID_INHERIT_FLAGS               (0x1F)


//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//

//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//

#define SUCCESSFUL_ACCESS_ACE_FLAG       (0x40)
#define FAILED_ACCESS_ACE_FLAG           (0x80)


//
//  We'll define the structure of the predefined ACE types.  Pictorally
//  the structure of the predefined ACE's is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//      |                              Mask                             |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +                              Sid                              +
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +---------------------------------------------------------------+
//
//  Mask is the access mask associated with the ACE.  This is either the
//  access allowed, access denied, audit, or alarm mask.
//
//  Sid is the Sid associated with the ACE.
//

//  The following are the four predefined ACE types.

//  Examine the AceType field in the Header to determine
//  which structure is appropriate to use for casting.


typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

#define SYSTEM_MANDATORY_LABEL_NO_WRITE_UP         0x1
#define SYSTEM_MANDATORY_LABEL_NO_READ_UP          0x2
#define SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP       0x4

#define SYSTEM_MANDATORY_LABEL_VALID_MASK (SYSTEM_MANDATORY_LABEL_NO_WRITE_UP   | \
                                           SYSTEM_MANDATORY_LABEL_NO_READ_UP    | \
                                           SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP)

#define SECURITY_DESCRIPTOR_MIN_LENGTH   (sizeof(SECURITY_DESCRIPTOR))


typedef USHORT SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

#define SE_OWNER_DEFAULTED               (0x0001)
#define SE_GROUP_DEFAULTED               (0x0002)
#define SE_DACL_PRESENT                  (0x0004)
#define SE_DACL_DEFAULTED                (0x0008)
#define SE_SACL_PRESENT                  (0x0010)
#define SE_SACL_DEFAULTED                (0x0020)
// end_winnt
#define SE_DACL_UNTRUSTED                (0x0040)
#define SE_SERVER_SECURITY               (0x0080)
// begin_winnt
#define SE_DACL_AUTO_INHERIT_REQ         (0x0100)
#define SE_SACL_AUTO_INHERIT_REQ         (0x0200)
#define SE_DACL_AUTO_INHERITED           (0x0400)
#define SE_SACL_AUTO_INHERITED           (0x0800)
#define SE_DACL_PROTECTED                (0x1000)
#define SE_SACL_PROTECTED                (0x2000)
#define SE_RM_CONTROL_VALID              (0x4000)
#define SE_SELF_RELATIVE                 (0x8000)

//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
// end_winnt
//      SE_DACL_TRUSTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a trusted source
//          and does not require any editing of compound ACEs.  If this flag
//          is not set and a compound ACE is encountered, the system will
//          substitute known valid SIDs for the server SIDs in the ACEs.
//
//      SE_SERVER_SECURITY - This boolean flag, when set, indicates that the
//         caller wishes the system to create a Server ACL based on the
//         input ACL, regardess of its source (explicit or defaulting.
//         This is done by replacing all of the GRANT ACEs with compound
//         ACEs granting the current server.  This flag is only
//         meaningful if the subject is impersonating.
//
// begin_winnt
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//
//
//
// Pictorially the structure of a security descriptor is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------------------------------------------------------+
//      |            Control            |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                            Owner                              |
//      +---------------------------------------------------------------+
//      |                            Group                              |
//      +---------------------------------------------------------------+
//      |                            Sacl                               |
//      +---------------------------------------------------------------+
//      |                            Dacl                               |
//      +---------------------------------------------------------------+
//
// In general, this data structure should be treated opaquely to ensure future
// compatibility.
//
//

typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    UCHAR Revision;
    UCHAR Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    ULONG Owner;
    ULONG Group;
    ULONG Sacl;
    ULONG Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   UCHAR Revision;
   UCHAR Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Object Type list for AccessCheckByType               //
//                                                                    //
////////////////////////////////////////////////////////////////////////

typedef struct _OBJECT_TYPE_LIST {
    USHORT Level;
    USHORT Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;

//
// DS values for Level
//

#define ACCESS_OBJECT_GUID       0
#define ACCESS_PROPERTY_SET_GUID 1
#define ACCESS_PROPERTY_GUID     2

#define ACCESS_MAX_LEVEL         4

//
// Parameters to NtAccessCheckByTypeAndAditAlarm
//

typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;

#define AUDIT_ALLOW_NO_PRIVILEGE 0x1

//
// DS values for Source and ObjectTypeName
//

#define ACCESS_DS_SOURCE_A "DS"
#define ACCESS_DS_SOURCE_W L"DS"
#define ACCESS_DS_OBJECT_TYPE_NAME_A "Directory Service Object"
#define ACCESS_DS_OBJECT_TYPE_NAME_W L"Directory Service Object"


////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////


//
// Token Specific Access Rights.
//

#define TOKEN_ASSIGN_PRIMARY    (0x0001)
#define TOKEN_DUPLICATE         (0x0002)
#define TOKEN_IMPERSONATE       (0x0004)
#define TOKEN_QUERY             (0x0008)
#define TOKEN_QUERY_SOURCE      (0x0010)
#define TOKEN_ADJUST_PRIVILEGES (0x0020)
#define TOKEN_ADJUST_GROUPS     (0x0040)
#define TOKEN_ADJUST_DEFAULT    (0x0080)
#define TOKEN_ADJUST_SESSIONID  (0x0100)

#define TOKEN_ALL_ACCESS_P (STANDARD_RIGHTS_REQUIRED  |\
                          TOKEN_ASSIGN_PRIMARY      |\
                          TOKEN_DUPLICATE           |\
                          TOKEN_IMPERSONATE         |\
                          TOKEN_QUERY               |\
                          TOKEN_QUERY_SOURCE        |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT )

#if ((defined(_WIN32_WINNT) && (_WIN32_WINNT > 0x0400)) || (!defined(_WIN32_WINNT)))
#define TOKEN_ALL_ACCESS  (TOKEN_ALL_ACCESS_P |\
                          TOKEN_ADJUST_SESSIONID )
#else
#define TOKEN_ALL_ACCESS  (TOKEN_ALL_ACCESS_P)
#endif

#define TOKEN_READ       (STANDARD_RIGHTS_READ      |\
                          TOKEN_QUERY)


#define TOKEN_WRITE      (STANDARD_RIGHTS_WRITE     |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)

#define TOKEN_EXECUTE    (STANDARD_RIGHTS_EXECUTE)

//
//
// Token Types
//

typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;

//
// Token elevation values describe the relative strength of a given token.
// A full token is a token with all groups and privileges to which the principal
// is authorized.  A limited token is one with some groups or privileges removed.
//

typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;

//
// Token Information Classes.
//


typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    MaxTokenInfoClass  // MaxTokenInfoClass should always be the last enum
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

//
// Token information class structures
//


typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;

typedef struct _TOKEN_GROUPS {
    ULONG GroupCount;
    SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];
} TOKEN_GROUPS, *PTOKEN_GROUPS;


typedef struct _TOKEN_PRIVILEGES {
    ULONG PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;


typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    ULONG SidCount;
    ULONG SidLength;
    PSID_AND_ATTRIBUTES Sids;
    ULONG RestrictedSidCount;
    ULONG RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    ULONG PrivilegeCount;
    ULONG PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
    ULONG TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;

#define TOKEN_MANDATORY_POLICY_OFF             0x0
#define TOKEN_MANDATORY_POLICY_NO_WRITE_UP     0x1
#define TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN 0x2

#define TOKEN_MANDATORY_POLICY_VALID_MASK      (TOKEN_MANDATORY_POLICY_NO_WRITE_UP | \
                                                TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN)

typedef struct _TOKEN_MANDATORY_POLICY {
    ULONG Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    ULONG Flags;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;

//
// Valid bits for each TOKEN_AUDIT_POLICY policy mask field.
//

#define POLICY_AUDIT_SUBCATEGORY_COUNT (52)

typedef struct _TOKEN_AUDIT_POLICY {
    UCHAR PerUserPolicy[((POLICY_AUDIT_SUBCATEGORY_COUNT) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;

#define TOKEN_SOURCE_LENGTH 8

typedef struct _TOKEN_SOURCE {
    CHAR SourceName[TOKEN_SOURCE_LENGTH];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    ULONG DynamicCharged;
    ULONG DynamicAvailable;
    ULONG GroupCount;
    ULONG PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;

typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;

// end_winnt

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    __in HANDLE ThreadHandle,
    __in ACCESS_MASK DesiredAccess,
    __in BOOLEAN OpenAsSelf,
    __out PHANDLE TokenHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    __in HANDLE ThreadHandle,
    __in ACCESS_MASK DesiredAccess,
    __in BOOLEAN OpenAsSelf,
    __in ULONG HandleAttributes,
    __out PHANDLE TokenHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    __in HANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE TokenHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    __in HANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in ULONG HandleAttributes,
    __out PHANDLE TokenHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
NtOpenJobObjectToken(
    __in HANDLE JobHandle,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE TokenHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    __in HANDLE ExistingTokenHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in BOOLEAN EffectiveOnly,
    __in TOKEN_TYPE TokenType,
    __out PHANDLE NewTokenHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterToken (
    __in HANDLE ExistingTokenHandle,
    __in ULONG Flags,
    __in_opt PTOKEN_GROUPS SidsToDisable,
    __in_opt PTOKEN_PRIVILEGES PrivilegesToDelete,
    __in_opt PTOKEN_GROUPS RestrictedSids,
    __out PHANDLE NewTokenHandle
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    __in HANDLE ThreadHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationToken (
    __in HANDLE TokenHandle,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __out_bcount_part_opt(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    __in ULONG TokenInformationLength,
    __out PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationToken (
    __in HANDLE TokenHandle,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __in_bcount(TokenInformationLength) PVOID TokenInformation,
    __in ULONG TokenInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken (
    __in HANDLE TokenHandle,
    __in BOOLEAN DisableAllPrivileges,
    __in_opt PTOKEN_PRIVILEGES NewState,
    __in_opt ULONG BufferLength,
    __out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    __out_opt PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken (
    __in HANDLE TokenHandle,
    __in BOOLEAN ResetToDefault,
    __in_opt PTOKEN_GROUPS NewState,
    __in_opt ULONG BufferLength,
    __out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    __out PULONG ReturnLength
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeCheck (
    __in HANDLE ClientToken,
    __inout PPRIVILEGE_SET RequiredPrivileges,
    __out PBOOLEAN Result
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckAndAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ACCESS_MASK DesiredAccess,
    __in PGENERIC_MAPPING GenericMapping,
    __in BOOLEAN ObjectCreation,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus,
    __out PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeAndAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in ACCESS_MASK DesiredAccess,
    __in AUDIT_EVENT_TYPE AuditType,
    __in ULONG Flags,
    __in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __in BOOLEAN ObjectCreation,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus,
    __out PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in ACCESS_MASK DesiredAccess,
    __in AUDIT_EVENT_TYPE AuditType,
    __in ULONG Flags,
    __in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __in BOOLEAN ObjectCreation,
    __out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    __out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus,
    __out PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultListAndAuditAlarmByHandle (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in HANDLE ClientToken,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in ACCESS_MASK DesiredAccess,
    __in AUDIT_EVENT_TYPE AuditType,
    __in ULONG Flags,
    __in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __in BOOLEAN ObjectCreation,
    __out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    __out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus,
    __out PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenObjectAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in HANDLE ClientToken,
    __in ACCESS_MASK DesiredAccess,
    __in ACCESS_MASK GrantedAccess,
    __in_opt PPRIVILEGE_SET Privileges,
    __in BOOLEAN ObjectCreation,
    __in BOOLEAN AccessGranted,
    __out PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeObjectAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in HANDLE ClientToken,
    __in ACCESS_MASK DesiredAccess,
    __in PPRIVILEGE_SET Privileges,
    __in BOOLEAN AccessGranted
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtCloseObjectAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in BOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteObjectAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in BOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegedServiceAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in PUNICODE_STRING ServiceName,
    __in HANDLE ClientToken,
    __in PPRIVILEGE_SET Privileges,
    __in BOOLEAN AccessGranted
    );
#endif


//
// This enumerated type is used as the function return value of the function
// that is used to search the tree for a key. FoundNode indicates that the
// function found the key. Insert as left indicates that the key was not found
// and the node should be inserted as the left child of the parent. Insert as
// right indicates that the key was not found and the node should be inserted
//  as the right child of the parent.
//
typedef enum _TABLE_SEARCH_RESULT{
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

//
//  The results of a compare can be less than, equal, or greater than.
//

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

//
//  Define the Avl version of the generic table package.  Note a generic table
//  should really be an opaque type.  We provide routines to manipulate the structure.
//
//  A generic table is package for inserting, deleting, and looking up elements
//  in a table (e.g., in a symbol table).  To use this package the user
//  defines the structure of the elements stored in the table, provides a
//  comparison function, a memory allocation function, and a memory
//  deallocation function.
//
//  Note: the user compare function must impose a complete ordering among
//  all of the elements, and the table does not allow for duplicate entries.
//

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

struct _RTL_AVL_TABLE;

//
//  The comparison function takes as input pointers to elements containing
//  user defined structures and returns the results of comparing the two
//  elements.
//

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_AVL_COMPARE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

//
//  The allocation function is called by the generic table package whenever
//  it needs to allocate memory for the table.
//

typedef
PVOID
(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    CLONG ByteSize
    );

//
//  The deallocation function is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PRTL_AVL_FREE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    PVOID Buffer
    );

//
//  The match function takes as input the user data to be matched and a pointer
//  to some match data, which was passed along with the function pointer.  It
//  returns TRUE for a match and FALSE for no match.
//
//  RTL_AVL_MATCH_FUNCTION returns
//      STATUS_SUCCESS if the IndexRow matches
//      STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should
//          continue
//      STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration
//          should terminate
//


typedef
NTSTATUS
(NTAPI *PRTL_AVL_MATCH_FUNCTION) (
    struct _RTL_AVL_TABLE *Table,
    PVOID UserData,
    PVOID MatchData
    );

//
//  Define the balanced tree links and Balance field.  (No Rank field
//  defined at this time.)
//
//  Callers should treat this structure as opaque!
//
//  The root of a balanced binary tree is not a real node in the tree
//  but rather points to a real node which is the root.  It is always
//  in the table below, and its fields are used as follows:
//
//      Parent      Pointer to self, to allow for detection of the root.
//      LeftChild   NULL
//      RightChild  Pointer to real root
//      Balance     Undefined, however it is set to a convenient value
//                  (depending on the algorithm) prior to rebalancing
//                  in insert and delete routines.
//

typedef struct _RTL_BALANCED_LINKS {
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS;
typedef RTL_BALANCED_LINKS *PRTL_BALANCED_LINKS;

//
//  To use the generic table package the user declares a variable of type
//  GENERIC_TABLE and then uses the routines described below to initialize
//  the table and to manipulate the table.  Note that the generic table
//  should really be an opaque type.
//

typedef struct _RTL_AVL_TABLE {
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE;
typedef RTL_AVL_TABLE *PRTL_AVL_TABLE;

//
//  The procedure InitializeGenericTable takes as input an uninitialized
//  generic table variable and pointers to the three user supplied routines.
//  This must be called for every individual generic table variable before
//  it can be used.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_AVL_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function InsertElementGenericTable will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes AVL links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function InsertElementGenericTableFull will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes AVL links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//  This routine is passed the NodeOrParent and SearchResult from a
//  previous RtlLookupElementGenericTableFull.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function DeleteElementGenericTable will find and delete an element
//  from a generic table.  If the element is located and deleted the return
//  value is TRUE, otherwise if the element is not located the return value
//  is FALSE.  The user supplied input buffer is only used as a key in
//  locating the element in the table.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function LookupElementGenericTable will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element, otherwise if
//  the element is not located the return value is NULL.  The user supplied
//  input buffer is only used as a key in locating the element in the table.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function LookupElementGenericTableFull will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element.  If the element is not
//  located then a pointer to the parent for the insert location is returned.  The
//  user must look at the SearchResult value to determine which is being returned.
//  The user can use the SearchResult and parent for a subsequent FullInsertElement
//  call to optimize the insert.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function EnumerateGenericTable will return to the caller one-by-one
//  the elements of of a table.  The return value is a pointer to the user
//  defined structure associated with the element.  The input parameter
//  Restart indicates if the enumeration should start from the beginning
//  or should return the next element.  If the are no more new elements to
//  return the return value is NULL.  As an example of its use, to enumerate
//  all of the elements in a table the user would write:
//
//      for (ptr = EnumerateGenericTable(Table, TRUE);
//           ptr != NULL;
//           ptr = EnumerateGenericTable(Table, FALSE)) {
//              :
//      }
//
//  NOTE:   This routine does not modify the structure of the tree, but saves
//          the last node returned in the generic table itself, and for this
//          reason requires exclusive access to the table for the duration of
//          the enumeration.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl (
    PRTL_AVL_TABLE Table,
    BOOLEAN Restart
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function EnumerateGenericTableWithoutSplaying will return to the
//  caller one-by-one the elements of of a table.  The return value is a
//  pointer to the user defined structure associated with the element.
//  The input parameter RestartKey indicates if the enumeration should
//  start from the beginning or should return the next element.  If the
//  are no more new elements to return the return value is NULL.  As an
//  example of its use, to enumerate all of the elements in a table the
//  user would write:
//
//      RestartKey = NULL;
//      for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
//           ptr != NULL;
//           ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
//              :
//      }
//
//  If RestartKey is NULL, the package will start from the least entry in the
//  table, otherwise it will start from the last entry returned.
//
//  NOTE:   This routine does not modify either the structure of the tree
//          or the generic table itself, but must insure that no deletes
//          occur for the duration of the enumeration, typically by having
//          at least shared access to the table for the duration.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl (
    PRTL_AVL_TABLE Table,
    PVOID *RestartKey
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  RtlLookupFirstMatchingElementGenericTableAvl will return the left-most
//  element in the tree matching the data in Buffer.  If, for example, the tree
//  contains filenames there may exist several that differ only in case. A case-
//  blind searcher can use this routine to position himself in the tree at the
//  first match, and use an enumeration routine (such as RtlEnumerateGenericTableWithoutSplayingAvl
//  to return each subsequent match.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlLookupFirstMatchingElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer,
    OUT PVOID *RestartKey
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function EnumerateGenericTableLikeADirectory will return to the
//  caller one-by-one the elements of of a table.  The return value is a
//  pointer to the user defined structure associated with the element.
//  The input parameter RestartKey indicates if the enumeration should
//  start from the beginning or should return the next element.  If the
//  are no more new elements to return the return value is NULL.  As an
//  example of its use, to enumerate all of the elements in a table the
//  user would write:
//
//      RestartKey = NULL;
//      for (ptr = EnumerateGenericTableLikeADirectory(Table, &RestartKey, ...);
//           ptr != NULL;
//           ptr = EnumerateGenericTableLikeADirectory(Table, &RestartKey, ...)) {
//              :
//      }
//
//  If RestartKey is NULL, the package will start from the least entry in the
//  table, otherwise it will start from the last entry returned.
//
//  NOTE:   This routine does not modify either the structure of the tree
//          or the generic table itself.  The table must only be acquired
//          shared for the duration of this call, and all synchronization
//          may optionally be dropped between calls.  Enumeration is always
//          correctly resumed in the most efficient manner possible via the
//          IN OUT parameters provided.
//
//  ******  Explain NextFlag.  Directory enumeration resumes from a key
//          requires more thought.  Also need the match pattern and IgnoreCase.
//          Should some structure be introduced to carry it all?
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_MATCH_FUNCTION MatchFunction,
    IN PVOID MatchData,
    IN ULONG NextFlag,
    IN OUT PVOID *RestartKey,
    IN OUT PULONG DeleteCount,
    IN OUT PVOID Buffer
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
// The function GetElementGenericTable will return the i'th element
// inserted in the generic table.  I = 0 implies the first element,
// I = (RtlNumberGenericTableElements(Table)-1) will return the last element
// inserted into the generic table.  The type of I is ULONG.  Values
// of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
// an arbitrary element is deleted from the generic table it will cause
// all elements inserted after the deleted element to "move up".

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    ULONG I
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
// The function NumberGenericTableElements returns a ULONG value
// which is the number of generic table elements currently inserted
// in the generic table.

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl (
    PRTL_AVL_TABLE Table
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  The function IsGenericTableEmpty will return to the caller TRUE if
//  the input table is empty (i.e., does not contain any elements) and
//  FALSE otherwise.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl (
    PRTL_AVL_TABLE Table
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
//  As an aid to allowing existing generic table users to do (in most
//  cases) a single-line edit to switch over to Avl table use, we
//  have the following defines and inline routine definitions which
//  redirect calls and types.  Note that the type override (performed
//  by #define below) will not work in the unexpected event that someone
//  has used a pointer or type specifier in their own #define, since
//  #define processing is one pass and does not nest.  The __inline
//  declarations below do not have this limitation, however.
//
//  To switch to using Avl tables, add the following line before your
//  includes:
//
//  #define RTL_USE_AVL_TABLES 0
//

#ifdef RTL_USE_AVL_TABLES

#undef PRTL_GENERIC_COMPARE_ROUTINE
#undef PRTL_GENERIC_ALLOCATE_ROUTINE
#undef PRTL_GENERIC_FREE_ROUTINE
#undef RTL_GENERIC_TABLE
#undef PRTL_GENERIC_TABLE

#define PRTL_GENERIC_COMPARE_ROUTINE PRTL_AVL_COMPARE_ROUTINE
#define PRTL_GENERIC_ALLOCATE_ROUTINE PRTL_AVL_ALLOCATE_ROUTINE
#define PRTL_GENERIC_FREE_ROUTINE PRTL_AVL_FREE_ROUTINE
#define RTL_GENERIC_TABLE RTL_AVL_TABLE
#define PRTL_GENERIC_TABLE PRTL_AVL_TABLE

#define RtlInitializeGenericTable               RtlInitializeGenericTableAvl
#define RtlInsertElementGenericTable            RtlInsertElementGenericTableAvl
#define RtlInsertElementGenericTableFull        RtlInsertElementGenericTableFullAvl
#define RtlDeleteElementGenericTable            RtlDeleteElementGenericTableAvl
#define RtlLookupElementGenericTable            RtlLookupElementGenericTableAvl
#define RtlLookupElementGenericTableFull        RtlLookupElementGenericTableFullAvl
#define RtlEnumerateGenericTable                RtlEnumerateGenericTableAvl
#define RtlEnumerateGenericTableWithoutSplaying RtlEnumerateGenericTableWithoutSplayingAvl
#define RtlGetElementGenericTable               RtlGetElementGenericTableAvl
#define RtlNumberGenericTableElements           RtlNumberGenericTableElementsAvl
#define RtlIsGenericTableEmpty                  RtlIsGenericTableEmptyAvl

#endif // RTL_USE_AVL_TABLES


//
//  Define the splay links and the associated manipuliation macros and
//  routines.  Note that the splay_links should be an opaque type.
//  Routine are provided to traverse and manipulate the structure.
//

typedef struct _RTL_SPLAY_LINKS {
    struct _RTL_SPLAY_LINKS *Parent;
    struct _RTL_SPLAY_LINKS *LeftChild;
    struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS;
typedef RTL_SPLAY_LINKS *PRTL_SPLAY_LINKS;

//
//  The macro procedure InitializeSplayLinks takes as input a pointer to
//  splay link and initializes its substructure.  All splay link nodes must
//  be initialized before they are used in the different splay routines and
//  macros.
//
//  VOID
//  RtlInitializeSplayLinks (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlInitializeSplayLinks(Links) {    \
    PRTL_SPLAY_LINKS _SplayLinks;            \
    _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
    _SplayLinks->Parent = _SplayLinks;   \
    _SplayLinks->LeftChild = NULL;       \
    _SplayLinks->RightChild = NULL;      \
    }

//
//  The macro function Parent takes as input a pointer to a splay link in a
//  tree and returns a pointer to the splay link of the parent of the input
//  node.  If the input node is the root of the tree the return value is
//  equal to the input value.
//
//  PRTL_SPLAY_LINKS
//  RtlParent (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlParent(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->Parent \
    )

//
//  The macro function LeftChild takes as input a pointer to a splay link in
//  a tree and returns a pointer to the splay link of the left child of the
//  input node.  If the left child does not exist, the return value is NULL.
//
//  PRTL_SPLAY_LINKS
//  RtlLeftChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlLeftChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->LeftChild \
    )

//
//  The macro function RightChild takes as input a pointer to a splay link
//  in a tree and returns a pointer to the splay link of the right child of
//  the input node.  If the right child does not exist, the return value is
//  NULL.
//
//  PRTL_SPLAY_LINKS
//  RtlRightChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlRightChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->RightChild \
    )

//
//  The macro function IsRoot takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the root of the tree,
//  otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsRoot (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsRoot(Links) (                          \
    (RtlParent(Links) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro function IsLeftChild takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the left child of its
//  parent, otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsLeftChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsLeftChild(Links) (                                   \
    (RtlLeftChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro function IsRightChild takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the right child of its
//  parent, otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsRightChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsRightChild(Links) (                                   \
    (RtlRightChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro procedure InsertAsLeftChild takes as input a pointer to a splay
//  link in a tree and a pointer to a node not in a tree.  It inserts the
//  second node as the left child of the first node.  The first node must not
//  already have a left child, and the second node must not already have a
//  parent.
//
//  VOID
//  RtlInsertAsLeftChild (
//      PRTL_SPLAY_LINKS ParentLinks,
//      PRTL_SPLAY_LINKS ChildLinks
//      );
//

#define RtlInsertAsLeftChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                      \
    PRTL_SPLAY_LINKS _SplayChild;                       \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);     \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);       \
    _SplayParent->LeftChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;             \
    }

//
//  The macro procedure InsertAsRightChild takes as input a pointer to a splay
//  link in a tree and a pointer to a node not in a tree.  It inserts the
//  second node as the right child of the first node.  The first node must not
//  already have a right child, and the second node must not already have a
//  parent.
//
//  VOID
//  RtlInsertAsRightChild (
//      PRTL_SPLAY_LINKS ParentLinks,
//      PRTL_SPLAY_LINKS ChildLinks
//      );
//

#define RtlInsertAsRightChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                       \
    PRTL_SPLAY_LINKS _SplayChild;                        \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);      \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);        \
    _SplayParent->RightChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;              \
    }

//
//  The Splay function takes as input a pointer to a splay link in a tree
//  and splays the tree.  Its function return value is a pointer to the
//  root of the splayed tree.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSplay (
    PRTL_SPLAY_LINKS Links
    );
#endif

//
//  The Delete function takes as input a pointer to a splay link in a tree
//  and deletes that node from the tree.  Its function return value is a
//  pointer to the root of the tree.  If the tree is now empty, the return
//  value is NULL.
//


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlDelete (
    PRTL_SPLAY_LINKS Links
    );
#endif

//
//  The DeleteNoSplay function takes as input a pointer to a splay link in a tree,
//  the caller's pointer to the root of the tree and deletes that node from the
//  tree.  Upon return the caller's pointer to the root node will correctly point
//  at the root of the tree.
//
//  It operationally differs from RtlDelete only in that it will not splay the tree.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlDeleteNoSplay (
    PRTL_SPLAY_LINKS Links,
    PRTL_SPLAY_LINKS *Root
    );
#endif

//
//  The SubtreeSuccessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the successor of the input node of
//  the substree rooted at the input node.  If there is not a successor, the
//  return value is NULL.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor (
    PRTL_SPLAY_LINKS Links
    );
#endif

//
//  The SubtreePredecessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the predecessor of the input node of
//  the substree rooted at the input node.  If there is not a predecessor,
//  the return value is NULL.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor (
    PRTL_SPLAY_LINKS Links
    );
#endif

//
//  The RealSuccessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the successor of the input node within
//  the entire tree.  If there is not a successor, the return value is NULL.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor (
    PRTL_SPLAY_LINKS Links
    );
#endif

//
//  The RealPredecessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the predecessor of the input node
//  within the entire tree.  If there is not a predecessor, the return value
//  is NULL.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor (
    PRTL_SPLAY_LINKS Links
    );
#endif


//
//  Define the generic table package.  Note a generic table should really
//  be an opaque type.  We provide routines to manipulate the structure.
//
//  A generic table is package for inserting, deleting, and looking up elements
//  in a table (e.g., in a symbol table).  To use this package the user
//  defines the structure of the elements stored in the table, provides a
//  comparison function, a memory allocation function, and a memory
//  deallocation function.
//
//  Note: the user compare function must impose a complete ordering among
//  all of the elements, and the table does not allow for duplicate entries.
//

//
//  Do not do the following defines if using Avl
//

#ifndef RTL_USE_AVL_TABLES

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

struct _RTL_GENERIC_TABLE;

//
//  The comparison function takes as input pointers to elements containing
//  user defined structures and returns the results of comparing the two
//  elements.
//

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_GENERIC_COMPARE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

//
//  The allocation function is called by the generic table package whenever
//  it needs to allocate memory for the table.
//

typedef
PVOID
(NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    );

//
//  The deallocation function is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PRTL_GENERIC_FREE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    );

//
//  To use the generic table package the user declares a variable of type
//  GENERIC_TABLE and then uses the routines described below to initialize
//  the table and to manipulate the table.  Note that the generic table
//  should really be an opaque type.
//

typedef struct _RTL_GENERIC_TABLE {
    PRTL_SPLAY_LINKS TableRoot;
    LIST_ENTRY InsertOrderList;
    PLIST_ENTRY OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_GENERIC_TABLE;
typedef RTL_GENERIC_TABLE *PRTL_GENERIC_TABLE;

//
//  The procedure InitializeGenericTable takes as input an uninitialized
//  generic table variable and pointers to the three user supplied routines.
//  This must be called for every individual generic table variable before
//  it can be used.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTable (
    PRTL_GENERIC_TABLE Table,
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );
#endif

//
//  The function InsertElementGenericTable will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes splay links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );
#endif

//
//  The function InsertElementGenericTableFull will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes splay links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//  This routine is passed the NodeOrParent and SearchResult from a
//  previous RtlLookupElementGenericTableFull.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    );
#endif

//
//  The function DeleteElementGenericTable will find and delete an element
//  from a generic table.  If the element is located and deleted the return
//  value is TRUE, otherwise if the element is not located the return value
//  is FALSE.  The user supplied input buffer is only used as a key in
//  locating the element in the table.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );
#endif

//
//  The function LookupElementGenericTable will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element, otherwise if
//  the element is not located the return value is NULL.  The user supplied
//  input buffer is only used as a key in locating the element in the table.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );
#endif

//
//  The function LookupElementGenericTableFull will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element.  If the element is not
//  located then a pointer to the parent for the insert location is returned.  The
//  user must look at the SearchResult value to determine which is being returned.
//  The user can use the SearchResult and parent for a subsequent FullInsertElement
//  call to optimize the insert.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    );
#endif

//
//  The function EnumerateGenericTable will return to the caller one-by-one
//  the elements of of a table.  The return value is a pointer to the user
//  defined structure associated with the element.  The input parameter
//  Restart indicates if the enumeration should start from the beginning
//  or should return the next element.  If the are no more new elements to
//  return the return value is NULL.  As an example of its use, to enumerate
//  all of the elements in a table the user would write:
//
//      for (ptr = EnumerateGenericTable(Table, TRUE);
//           ptr != NULL;
//           ptr = EnumerateGenericTable(Table, FALSE)) {
//              :
//      }
//
//
//  PLEASE NOTE:
//
//      If you enumerate a GenericTable using RtlEnumerateGenericTable, you
//      will flatten the table, turning it into a sorted linked list.
//      To enumerate the table without perturbing the splay links, use
//      RtlEnumerateGenericTableWithoutSplaying

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTable (
    PRTL_GENERIC_TABLE Table,
    BOOLEAN Restart
    );
#endif

//
//  The function EnumerateGenericTableWithoutSplaying will return to the
//  caller one-by-one the elements of of a table.  The return value is a
//  pointer to the user defined structure associated with the element.
//  The input parameter RestartKey indicates if the enumeration should
//  start from the beginning or should return the next element.  If the
//  are no more new elements to return the return value is NULL.  As an
//  example of its use, to enumerate all of the elements in a table the
//  user would write:
//
//      RestartKey = NULL;
//      for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
//           ptr != NULL;
//           ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
//              :
//      }
//
//  If RestartKey is NULL, the package will start from the least entry in the
//  table, otherwise it will start from the last entry returned.
//
//
//  Note that unlike RtlEnumerateGenericTable, this routine will NOT perturb
//  the splay order of the tree.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying (
    PRTL_GENERIC_TABLE Table,
    PVOID *RestartKey
    );
#endif

//
// The function GetElementGenericTable will return the i'th element
// inserted in the generic table.  I = 0 implies the first element,
// I = (RtlNumberGenericTableElements(Table)-1) will return the last element
// inserted into the generic table.  The type of I is ULONG.  Values
// of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
// an arbitrary element is deleted from the generic table it will cause
// all elements inserted after the deleted element to "move up".

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTable(
    PRTL_GENERIC_TABLE Table,
    ULONG I
    );
#endif

//
// The function NumberGenericTableElements returns a ULONG value
// which is the number of generic table elements currently inserted
// in the generic table.

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElements(
    PRTL_GENERIC_TABLE Table
    );
#endif

//
//  The function IsGenericTableEmpty will return to the caller TRUE if
//  the input table is empty (i.e., does not contain any elements) and
//  FALSE otherwise.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty (
    PRTL_GENERIC_TABLE Table
    );
#endif

#endif // RTL_USE_AVL_TABLES


typedef NTSTATUS
(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
    IN PVOID Base,
    IN OUT PVOID *CommitAddress,
    IN OUT PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS {
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[ 2 ];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    __in     ULONG Flags,
    __in_opt PVOID HeapBase OPTIONAL,
    __in_opt SIZE_T ReserveSize OPTIONAL,
    __in_opt SIZE_T CommitSize OPTIONAL,
    __in_opt PVOID Lock OPTIONAL,
    __in_opt PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP


#define HEAP_NO_SERIALIZE               0x00000001      // winnt
#define HEAP_GROWABLE                   0x00000002      // winnt
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      // winnt
#define HEAP_ZERO_MEMORY                0x00000008      // winnt
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010      // winnt
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020      // winnt
#define HEAP_FREE_CHECKING_ENABLED      0x00000040      // winnt
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080      // winnt

#define HEAP_CREATE_ALIGN_16            0x00010000      // winnt Create heap with 16 byte alignment (obsolete)
#define HEAP_CREATE_ENABLE_TRACING      0x00020000      // winnt Create heap call tracing enabled (obsolete)
#define HEAP_CREATE_ENABLE_EXECUTE      0x00040000      // winnt Create heap with executable pages

#define HEAP_SETTABLE_USER_VALUE        0x00000100
#define HEAP_SETTABLE_USER_FLAG1        0x00000200
#define HEAP_SETTABLE_USER_FLAG2        0x00000400
#define HEAP_SETTABLE_USER_FLAG3        0x00000800
#define HEAP_SETTABLE_USER_FLAGS        0x00000E00

#define HEAP_CLASS_0                    0x00000000      // process heap
#define HEAP_CLASS_1                    0x00001000      // private heap
#define HEAP_CLASS_2                    0x00002000      // Kernel Heap
#define HEAP_CLASS_3                    0x00003000      // GDI heap
#define HEAP_CLASS_4                    0x00004000      // User heap
#define HEAP_CLASS_5                    0x00005000      // Console heap
#define HEAP_CLASS_6                    0x00006000      // User Desktop heap
#define HEAP_CLASS_7                    0x00007000      // Csrss Shared heap
#define HEAP_CLASS_8                    0x00008000      // Csr Port heap
#define HEAP_CLASS_MASK                 0x0000F000

#define HEAP_MAXIMUM_TAG                0x0FFF              // winnt
#define HEAP_GLOBAL_TAG                 0x0800
#define HEAP_PSEUDO_TAG_FLAG            0x8000              // winnt
#define HEAP_TAG_SHIFT                  18                  // winnt
#define HEAP_TAG_MASK                  (HEAP_MAXIMUM_TAG << HEAP_TAG_SHIFT)

#define HEAP_CREATE_VALID_MASK         (HEAP_NO_SERIALIZE |             \
                                        HEAP_GROWABLE |                 \
                                        HEAP_GENERATE_EXCEPTIONS |      \
                                        HEAP_ZERO_MEMORY |              \
                                        HEAP_REALLOC_IN_PLACE_ONLY |    \
                                        HEAP_TAIL_CHECKING_ENABLED |    \
                                        HEAP_FREE_CHECKING_ENABLED |    \
                                        HEAP_DISABLE_COALESCE_ON_FREE | \
                                        HEAP_CLASS_MASK |               \
                                        HEAP_CREATE_ALIGN_16 |          \
                                        HEAP_CREATE_ENABLE_TRACING |    \
                                        HEAP_CREATE_ENABLE_EXECUTE)

// begin_winnt
#if !defined(MIDL_PASS)
FORCEINLINE
ULONG
HEAP_MAKE_TAG_FLAGS (
    IN ULONG TagBase,
    IN ULONG Tag
    )

{
    __assume_bound(TagBase);
    return ((ULONG)((TagBase) + ((Tag) << HEAP_TAG_SHIFT)));
}
#endif
// end_winnt

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    __in PVOID HeapHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
__bcount_opt(Size) __allocator
PVOID
NTAPI
RtlAllocateHeap(
    __in PVOID HeapHandle,
    IN   ULONG Flags,
    IN   SIZE_T Size
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    __in     PVOID HeapHandle,
    __in_opt ULONG Flags,
    __in     PVOID BaseAddress
    );
#endif // NTDDI_VERSION >= NTDDI_WIN2K



#if (NTDDI_VERSION > NTDDI_WINXP)
NTSYSAPI
USHORT
NTAPI
RtlCaptureStackBackTrace(
    __in ULONG FramesToSkip,
    __in ULONG FramesToCapture,
    __out_ecount(FramesToCapture) PVOID *BackTrace,
    __out_opt PULONG BackTraceHash
   );
#endif

#if (NTDDI_VERSION > NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlCaptureContext (
    __out PCONTEXT ContextRecord
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlRandom (
    PULONG Seed
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
ULONG
NTAPI
RtlRandomEx (
    PULONG Seed
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    __out PUNICODE_STRING DestinationString,
    __in_opt PCWSTR SourceString
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_WS03)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitAnsiStringEx(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    __inout PUNICODE_STRING DestinationString,
    __in PCWSTR SourceString
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlAppendStringToString (
    PSTRING Destination,
    const STRING * Source
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToUnicodeString(
    __inout PUNICODE_STRING DestinationString,
    __in PCOEM_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToOemString(
    __inout POEM_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToOemString(
    __inout POEM_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToCountedUnicodeString(
    __inout PUNICODE_STRING DestinationString,
    __in PCOEM_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToCountedOemString(
    __inout POEM_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToCountedOemString(
    __inout POEM_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlValidateUnicodeString(
    IN ULONG Flags,
    IN const UNICODE_STRING *String
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP


#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    IN ULONG Flags,
    IN const UNICODE_STRING *StringIn,
    OUT UNICODE_STRING *StringOut
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    __inout PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlFreeOemString(
    __inout POEM_STRING OemString
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToOemSize(
    PCUNICODE_STRING UnicodeString
    );
#endif

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlUnicodeStringToOemSize(
//      PUNICODE_STRING UnicodeString
//      );
//

#define RtlUnicodeStringToOemSize(STRING) (                   \
    NLS_MB_OEM_CODE_PAGE_TAG ?                                \
    RtlxUnicodeStringToOemSize(STRING) :                      \
    ((STRING)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlxOemStringToUnicodeSize(
    PCOEM_STRING OemString
    );
#endif

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlOemStringToUnicodeSize(
//      POEM_STRING OemString
//      );
//

#define RtlOemStringToUnicodeSize(STRING) (                  \
    NLS_MB_OEM_CODE_PAGE_TAG ?                               \
    RtlxOemStringToUnicodeSize(STRING) :                     \
    ((STRING)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR) \
)

//
//  ULONG
//  RtlOemStringToCountedUnicodeSize(
//      POEM_STRING OemString
//      );
//

#define RtlOemStringToCountedUnicodeSize(STRING) (                    \
    (ULONG)(RtlOemStringToUnicodeSize(STRING) - sizeof(UNICODE_NULL)) \
    )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
    __out_bcount_part(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG MaxBytesInUnicodeString,
    __out_opt PULONG BytesInUnicodeString,
    __in_bcount(BytesInMultiByteString) PCSTR MultiByteString,
    __in ULONG BytesInMultiByteString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
    __out PULONG BytesInUnicodeString,
    __in PCSTR MultiByteString,
    __in ULONG BytesInMultiByteString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
    __out PULONG BytesInMultiByteString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteN(
    __out_bcount_part(MaxBytesInMultiByteString, *BytesInMultiByteString) PCHAR MultiByteString,
    __in ULONG MaxBytesInMultiByteString,
    __out_opt PULONG BytesInMultiByteString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToMultiByteN(
    __out_bcount_part(MaxBytesInMultiByteString, *BytesInMultiByteString) PCHAR MultiByteString,
    __in ULONG MaxBytesInMultiByteString,
    __out_opt PULONG BytesInMultiByteString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlOemToUnicodeN(
    __out_bcount_part(MaxBytesInUnicodeString, *BytesInUnicodeString) PWSTR UnicodeString,
    __in ULONG MaxBytesInUnicodeString,
    __out_opt PULONG BytesInUnicodeString,
    __in_bcount(BytesInOemString) PCH OemString,
    __in ULONG BytesInOemString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToOemN(
    __out_bcount_part(MaxBytesInOemString, *BytesInOemString) PCHAR OemString,
    __in ULONG MaxBytesInOemString,
    __out_opt PULONG BytesInOemString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToOemN(
    __out_bcount_part(MaxBytesInOemString, *BytesInOemString) PCHAR OemString,
    __in ULONG MaxBytesInOemString,
    __out_opt PULONG BytesInOemString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlNormalizeString(
    __in ULONG NormForm,
    __in PCWSTR SourceString,
    __in LONG SourceStringLength,
    __out_ecount_part(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    __inout PLONG DestinationStringLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlIsNormalizedString(
    __in ULONG NormForm,
    __in PCWSTR SourceString,
    __in LONG SourceStringLength,
    __out PBOOLEAN Normalized
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToAscii(
    __in ULONG Flags,
    __in PCWSTR SourceString,
    __in LONG SourceStringLength,
    __out_ecount_part(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    __inout PLONG DestinationStringLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToUnicode(
    __in ULONG Flags,
    __in PCWSTR SourceString,
    __in LONG SourceStringLength,
    __out_ecount_part(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    __inout PLONG DestinationStringLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlIdnToNameprepUnicode(
    __in ULONG Flags,
    __in PCWSTR SourceString,
    __in LONG SourceStringLength,
    __out_ecount_part(*DestinationStringLength, *DestinationStringLength) PWSTR DestinationString,
    __inout PLONG DestinationStringLength
    );
#endif


typedef
PVOID
(NTAPI *PRTL_ALLOCATE_STRING_ROUTINE) (
    SIZE_T NumberOfBytes
    );

#if _WIN32_WINNT >= 0x0600

typedef
PVOID
(NTAPI *PRTL_REALLOCATE_STRING_ROUTINE) (
    SIZE_T NumberOfBytes,
    PVOID Buffer
    );

#endif // _WIN32_WINNT >= 0x0600

typedef
VOID
(NTAPI *PRTL_FREE_STRING_ROUTINE) (
    PVOID Buffer
    );

extern const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine;
extern const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine;

#if _WIN32_WINNT >= 0x0600
extern const PRTL_REALLOCATE_STRING_ROUTINE RtlReallocateStringRoutine;
#endif // _WIN32_WINNT >= 0x0600

//
//  Defines and Routines for handling GUID's.
//

//
//  Routine for generating 8.3 names from long names.
//

//
//  The context structure is used when generating 8.3 names.  The caller must
//  always zero out the structure before starting a new generation sequence
//

typedef struct _GENERATE_NAME_CONTEXT {

    //
    //  The structure is divided into two strings.  The Name, and extension.
    //  Each part contains the value that was last inserted in the name.
    //  The length values are in terms of wchars and not bytes.  We also
    //  store the last index value used in the generation collision algorithm.
    //

    USHORT Checksum;
    BOOLEAN ChecksumInserted;

    UCHAR NameLength;         // not including extension
    WCHAR NameBuffer[8];      // e.g., "ntoskrnl"

    ULONG ExtensionLength;    // including dot
    WCHAR ExtensionBuffer[4]; // e.g., ".exe"

    ULONG LastIndexValue;

} GENERATE_NAME_CONTEXT;
typedef GENERATE_NAME_CONTEXT *PGENERATE_NAME_CONTEXT;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_VISTASP1)
//
//  In Vista SP1 and beyond this routine now returns
//  STATUS_FILE_SYSTEM_LIMITATION if the system can not generate a unique
//  shortname for a given file.  It returns this error after 1 million retry
//  attempts for a single given longname.
//

NTSYSAPI
NTSTATUS
NTAPI
RtlGenerate8dot3Name (
    IN PCUNICODE_STRING Name,
    IN BOOLEAN AllowExtendedCharacters,
    IN OUT PGENERATE_NAME_CONTEXT Context,
    OUT PUNICODE_STRING Name8dot3
    );
#else   // (NTDDI_VERSION < NTDDI_VISTASP1)
NTSYSAPI
VOID
NTAPI
RtlGenerate8dot3Name (
    IN PCUNICODE_STRING Name,
    IN BOOLEAN AllowExtendedCharacters,
    IN OUT PGENERATE_NAME_CONTEXT Context,
    OUT PUNICODE_STRING Name8dot3
    );
#endif
#endif  // (NTDDI_VERSION >= NTDDI_WIN2K)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameLegalDOS8Dot3 (
    IN PCUNICODE_STRING Name,
    IN OUT POEM_STRING OemName OPTIONAL,
    IN OUT PBOOLEAN NameContainsSpaces OPTIONAL
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidOemCharacter (
    __inout PWCHAR Char
    );
#endif

//
//  Prefix package types and procedures.
//
//  Note that the following two record structures should really be opaque
//  to the user of this package.  The only information about the two
//  structures available for the user should be the size and alignment
//  of the structures.
//

typedef struct _PREFIX_TABLE_ENTRY {
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    struct _PREFIX_TABLE_ENTRY *NextPrefixTree;
    RTL_SPLAY_LINKS Links;
    PSTRING Prefix;
} PREFIX_TABLE_ENTRY;
typedef PREFIX_TABLE_ENTRY *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE {
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE;
typedef PREFIX_TABLE *PPREFIX_TABLE;

//
//  The procedure prototypes for the prefix package
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
PfxInitialize (
    IN PPREFIX_TABLE PrefixTable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
PfxInsertPrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PSTRING Prefix,
    IN PPREFIX_TABLE_ENTRY PrefixTableEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
PfxRemovePrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PPREFIX_TABLE_ENTRY PrefixTableEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PSTRING FullName
    );
#endif

//
//  The following definitions are for the unicode version of the prefix
//  package.
//

typedef struct _UNICODE_PREFIX_TABLE_ENTRY {
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    struct _UNICODE_PREFIX_TABLE_ENTRY *NextPrefixTree;
    struct _UNICODE_PREFIX_TABLE_ENTRY *CaseMatch;
    RTL_SPLAY_LINKS Links;
    PUNICODE_STRING Prefix;
} UNICODE_PREFIX_TABLE_ENTRY;
typedef UNICODE_PREFIX_TABLE_ENTRY *PUNICODE_PREFIX_TABLE_ENTRY;

typedef struct _UNICODE_PREFIX_TABLE {
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    PUNICODE_PREFIX_TABLE_ENTRY NextPrefixTree;
    PUNICODE_PREFIX_TABLE_ENTRY LastNextEntry;
} UNICODE_PREFIX_TABLE;
typedef UNICODE_PREFIX_TABLE *PUNICODE_PREFIX_TABLE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlInitializeUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlInsertUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlRemoveUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlFindUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_STRING FullName,
    IN ULONG CaseInsensitiveIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlNextUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN BOOLEAN Restart
    );
#endif

//
//
//  Compression package types and procedures.
//

#define COMPRESSION_FORMAT_NONE          (0x0000)   // winnt
#define COMPRESSION_FORMAT_DEFAULT       (0x0001)   // winnt
#define COMPRESSION_FORMAT_LZNT1         (0x0002)   // winnt

#define COMPRESSION_ENGINE_STANDARD      (0x0000)   // winnt
#define COMPRESSION_ENGINE_MAXIMUM       (0x0100)   // winnt
#define COMPRESSION_ENGINE_HIBER         (0x0200)   // winnt

//
//  Compressed Data Information structure.  This structure is
//  used to describe the state of a compressed data buffer,
//  whose uncompressed size is known.  All compressed chunks
//  described by this structure must be compressed with the
//  same format.  On compressed reads, this entire structure
//  is an output, and on compressed writes the entire structure
//  is an input.
//

typedef struct _COMPRESSED_DATA_INFO {

    //
    //  Code for the compression format (and engine) as
    //  defined in ntrtl.h.  Note that COMPRESSION_FORMAT_NONE
    //  and COMPRESSION_FORMAT_DEFAULT are invalid if
    //  any of the described chunks are compressed.
    //

    USHORT CompressionFormatAndEngine;

    //
    //  Since chunks and compression units are expected to be
    //  powers of 2 in size, we express then log2.  So, for
    //  example (1 << ChunkShift) == ChunkSizeInBytes.  The
    //  ClusterShift indicates how much space must be saved
    //  to successfully compress a compression unit - each
    //  successfully compressed compression unit must occupy
    //  at least one cluster less in bytes than an uncompressed
    //  compression unit.
    //

    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved;

    //
    //  This is the number of entries in the CompressedChunkSizes
    //  array.
    //

    USHORT NumberOfChunks;

    //
    //  This is an array of the sizes of all chunks resident
    //  in the compressed data buffer.  There must be one entry
    //  in this array for each chunk possible in the uncompressed
    //  buffer size.  A size of FSRTL_CHUNK_SIZE indicates the
    //  corresponding chunk is uncompressed and occupies exactly
    //  that size.  A size of 0 indicates that the corresponding
    //  chunk contains nothing but binary 0's, and occupies no
    //  space in the compressed data.  All other sizes must be
    //  less than FSRTL_CHUNK_SIZE, and indicate the exact size
    //  of the compressed data in bytes.
    //

    ULONG CompressedChunkSizes[ANYSIZE_ARRAY];

} COMPRESSED_DATA_INFO;
typedef COMPRESSED_DATA_INFO *PCOMPRESSED_DATA_INFO;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize (
    IN USHORT CompressionFormatAndEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer (
    IN USHORT CompressionFormatAndEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressChunks (
    __out_bcount(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    __in ULONG UncompressedBufferSize,
    __in_bcount(CompressedBufferSize) PUCHAR CompressedBuffer,
    __in ULONG CompressedBufferSize,
    __in_bcount(CompressedTailSize) PUCHAR CompressedTail,
    __in ULONG CompressedTailSize,
    __in PCOMPRESSED_DATA_INFO CompressedDataInfo
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlCompressChunks (
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong (
    PVOID Source,
    SIZE_T Length,
    ULONG Pattern
    );

#endif

#if defined(_M_AMD64)

#if !defined(MIDL_PASS)

FORCEINLINE
VOID
RtlFillMemoryUlong (
    PVOID Destination,
    SIZE_T Length,
    ULONG Pattern
    )

{

    PULONG Address = (PULONG)Destination;

    //
    // If the number of DWORDs is not zero, then fill the specified buffer
    // with the specified pattern.
    //

    if ((Length /= 4) != 0) {

        //
        // If the destination is not quadword aligned (ignoring low bits),
        // then align the destination by storing one DWORD.
        //

        if (((ULONG64)Address & 4) != 0) {
            *Address = Pattern;
            if ((Length -= 1) == 0) {
                return;
            }

            Address += 1;
        }

        //
        // If the number of QWORDs is not zero, then fill the destination
        // buffer a QWORD at a time.
        //

         __stosq((PULONG64)(Address),
                 Pattern | ((ULONG64)Pattern << 32),
                 Length / 2);

        if ((Length & 1) != 0) {
            Address[Length - 1] = Pattern;
        }
    }

    return;
}

#define RtlFillMemoryUlonglong(Destination, Length, Pattern)                \
    __stosq((PULONG64)(Destination), Pattern, (Length) / 8)

#endif

#else

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong (
   PVOID Destination,
   SIZE_T Length,
   ULONG Pattern
   );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong (
   PVOID Destination,
   SIZE_T Length,
   ULONGLONG Pattern
   );
#endif

#endif // defined(_M_AMD64)



//
//  A 64 bit Time value -> Seconds since the start of 1980
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );
#endif

//
//  Seconds since the start of 1980 -> 64 bit Time value
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );
#endif

//
//  A 64 bit Time value -> Seconds since the start of 1970
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );
#endif

//
//  Seconds since the start of 1970 -> 64 bit Time value
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );
#endif


//++
//
// PCHAR
// RtlOffsetToPointer (
//     PVOID Base,
//     ULONG Offset
//     )
//
// Routine Description:
//
// This macro generates a pointer which points to the byte that is 'Offset'
// bytes beyond 'Base'. This is useful for referencing fields within
// self-relative data structures.
//
// Arguments:
//
//     Base - The address of the base of the structure.
//
//     Offset - An unsigned integer offset of the byte whose address is to
//         be generated.
//
// Return Value:
//
//     A PCHAR pointer to the byte that is 'Offset' bytes beyond 'Base'.
//
//
//--

#define RtlOffsetToPointer(B,O)  ((PCHAR)( ((PCHAR)(B)) + ((ULONG_PTR)(O))  ))


//++
//
// ULONG
// RtlPointerToOffset (
//     PVOID Base,
//     PVOID Pointer
//     )
//
// Routine Description:
//
// This macro calculates the offset from Base to Pointer.  This is useful
// for producing self-relative offsets for structures.
//
// Arguments:
//
//     Base - The address of the base of the structure.
//
//     Pointer - A pointer to a field, presumably within the structure
//         pointed to by Base.  This value must be larger than that specified
//         for Base.
//
// Return Value:
//
//     A ULONG offset from Base to Pointer.
//
//
//--

#define RtlPointerToOffset(B,P)  ((ULONG)( ((PCHAR)(P)) - ((PCHAR)(B))  ))

//
//  Security ID RTL routine definitions
//


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid (
    PSID Sid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid (
    PSID Sid1,
    PSID Sid2
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid (
    PSID Sid1,
    PSID Sid2
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid (
    ULONG SubAuthorityCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    IN PSID Sid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority0,
    IN ULONG SubAuthority1,
    IN ULONG SubAuthority2,
    IN ULONG SubAuthority3,
    IN ULONG SubAuthority4,
    IN ULONG SubAuthority5,
    IN ULONG SubAuthority6,
    IN ULONG SubAuthority7,
    OUT PSID *Sid
    );
#endif // NTDDI_VERSION >= NTDDI_WIN2K


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid (
    PSID Sid,
    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    UCHAR SubAuthorityCount
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid (
    PSID Sid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid (
    PSID Sid,
    ULONG SubAuthority
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid (
    PSID Sid
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlLengthSid (
    PSID Sid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid (
    ULONG DestinationSidLength,
    PSID DestinationSid,
    PSID SourceSid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateServiceSid(
    IN      UNICODE_STRING *pServiceName,
    OUT     PSID pServiceSid,
    IN OUT  PULONG cbServiceSid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlCopyLuid (
    PLUID DestinationLuid,
    PLUID SourceLuid
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl (
    PACL Acl,
    ULONG AclLength,
    ULONG AclRevision
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce (
    PACL Acl,
    ULONG AceRevision,
    ULONG StartingAceIndex,
    PVOID AceList,
    ULONG AceListLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce (
    PACL Acl,
    ULONG AceIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce (
    PACL Acl,
    ULONG AceIndex,
    PVOID *Ace
    );
#endif // NTDDI_VERSION >= NTDDI_WIN2K

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce (
    PACL Acl,
    ULONG AceRevision,
    ACCESS_MASK AccessMask,
    PSID Sid
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptorRelative (
    PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor,
    ULONG Revision
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID Owner,
    BOOLEAN OwnerDefaulted
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSYSAPI
NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor (
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Group OPTIONAL,
    IN BOOLEAN GroupDefaulted OPTIONAL
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD (
    __in PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    __out_bcount_part_opt(*BufferLength, *BufferLength) PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    __inout PULONG BufferLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD (
    __in PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    __out_bcount_part_opt(*AbsoluteSecurityDescriptorSize, *AbsoluteSecurityDescriptorSize) PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    __inout PULONG AbsoluteSecurityDescriptorSize,
    __out_bcount_part_opt(*DaclSize, *DaclSize) PACL Dacl,
    __inout PULONG DaclSize,
    __out_bcount_part_opt(*SaclSize, *SaclSize) PACL Sacl,
    __inout PULONG SaclSize,
    __out_bcount_part_opt(*OwnerSize, *OwnerSize) PSID Owner,
    __inout PULONG OwnerSize,
    __out_bcount_part_opt(*PrimaryGroupSize, *PrimaryGroupSize) PSID PrimaryGroup,
    __inout PULONG PrimaryGroupSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Owner,
    OUT PBOOLEAN OwnerDefaulted
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError (
   __in NTSTATUS Status
   );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb (
   __in NTSTATUS Status
   );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlCustomCPToUnicodeN(
    __in PCPTABLEINFO CustomCP,
    __out_bcount_part(MaxBytesInUnicodeString, *BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG MaxBytesInUnicodeString,
    __out_opt PULONG BytesInUnicodeString,
    __in_bcount(BytesInCustomCPString) PCH CustomCPString,
    __in ULONG BytesInCustomCPString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToCustomCPN(
    __in PCPTABLEINFO CustomCP,
    __out_bcount_part(MaxBytesInCustomCPString, *BytesInCustomCPString) PCH CustomCPString,
    __in ULONG MaxBytesInCustomCPString,
    __out_opt PULONG BytesInCustomCPString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToCustomCPN(
    __in PCPTABLEINFO CustomCP,
    __out_bcount_part(MaxBytesInCustomCPString, *BytesInCustomCPString) PCH CustomCPString,
    __in ULONG MaxBytesInCustomCPString,
    __out_opt PULONG BytesInCustomCPString,
    __in_bcount(BytesInUnicodeString) PWCH UnicodeString,
    __in ULONG BytesInUnicodeString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlInitCodePageTable(
    __in PUSHORT TableBase,
    __inout PCPTABLEINFO CodePageTable
    );
#endif


//
// Routine for verifying or creating the "System Volume Information"
// folder on NTFS volumes.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSystemVolumeInformationFolder(
    IN  PUNICODE_STRING VolumeRootPath
    );
#endif

#define RTL_SYSTEM_VOLUME_INFORMATION_FOLDER    L"System Volume Information"

//
//  Altitude Routines
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
LONG
NTAPI
RtlCompareAltitudes(
    __in PCUNICODE_STRING Altitude1,
    __in PCUNICODE_STRING Altitude2
    );
#endif

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Macro to extract buffering method out of the device io control code
//
#define METHOD_FROM_CTL_CODE(ctrlCode)          ((ULONG)(ctrlCode & 3))

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define some easier to comprehend aliases:
//   METHOD_DIRECT_TO_HARDWARE (writes, aka METHOD_IN_DIRECT)
//   METHOD_DIRECT_FROM_HARDWARE (reads, aka METHOD_OUT_DIRECT)
//

#define METHOD_DIRECT_TO_HARDWARE       METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE     METHOD_OUT_DIRECT

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe


#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationThread (
    __in HANDLE ThreadHandle,
    __in THREADINFOCLASS ThreadInformationClass,
    __in_bcount(ThreadInformationLength) PVOID ThreadInformation,
    __in ULONG ThreadInformationLength
    );

#endif // NTDDI_VERSION >= NTDDI_WINXP


//
// Security operation mode of the system is held in a control
// longword.
//

typedef ULONG  LSA_OPERATIONAL_MODE, *PLSA_OPERATIONAL_MODE;

//
// Used by a logon process to indicate what type of logon is being
// requested.
//

typedef enum _SECURITY_LOGON_TYPE {
    UndefinedLogonType = 0, // This is used to specify an undefied logon type
    Interactive = 2,      // Interactively logged on (locally or remotely)
    Network,              // Accessing system via network
    Batch,                // Started via a batch queue
    Service,              // Service started by service controller
    Proxy,                // Proxy logon
    Unlock,               // Unlock workstation
    NetworkCleartext,     // Network logon with cleartext credentials
    NewCredentials,       // Clone caller, new default credentials
    //The types below only exist in Windows XP and greater
#if (_WIN32_WINNT >= 0x0501)
    RemoteInteractive,  // Remote, yet interactive. Terminal server
    CachedInteractive,  // Try cached credentials without hitting the net.
    // The types below only exist in Windows Server 2003 and greater
#endif
#if (_WIN32_WINNT >= 0x0502)
    CachedRemoteInteractive, // Same as RemoteInteractive, this is used internally for auditing purpose
    CachedUnlock        // Cached Unlock workstation
#endif
} SECURITY_LOGON_TYPE, *PSECURITY_LOGON_TYPE;


//
// All of this stuff (between the Ifndef _NTLSA_AUDIT_ and its endif) were not
// present in NTIFS prior to Windows Server 2003 SP1. All of the definitions however
// exist down to windows 2000 (except for the few exceptions noted in the code).
//

#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Data types related to Auditing                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The following enumerated type is used between the reference monitor and
// LSA in the generation of audit messages.  It is used to indicate the
// type of data being passed as a parameter from the reference monitor
// to LSA.  LSA is responsible for transforming the specified data type
// into a set of unicode strings that are added to the event record in
// the audit log.
//

typedef enum _SE_ADT_PARAMETER_TYPE {

    SeAdtParmTypeNone = 0,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  a unicode string containing "-".
                                    //
                                    //Note:  This is typically used to
                                    //       indicate that a parameter value
                                    //       was not available.
                                    //

    SeAdtParmTypeString,            //Produces 1 parameter.
                                    //Received Value:
                                    //
                                    //  Unicode String (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  No transformation.  The string
                                    //  entered into the event record as
                                    //  received.
                                    //
                                    // The Address value of the audit info
                                    // should be a pointer to a UNICODE_STRING
                                    // structure.



    SeAdtParmTypeFileSpec,          //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  Unicode string containing a file or
                                    //  directory name.
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string with the prefix of the
                                    //  file's path replaced by a drive letter
                                    //  if possible.
                                    //




    SeAdtParmTypeUlong,             //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value.


    SeAdtParmTypeSid,               //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  SID (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  String representation of SID
                                    //




    SeAdtParmTypeLogonId,           //Produces 4 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Sid string
                                    //  param 2: Username string
                                    //  param 3: domain name string
                                    //  param 4: Logon ID (Luid) string


    SeAdtParmTypeNoLogonId,         //Produces 3 parameters.
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  param 1: "-"
                                    //  param 2: "-"
                                    //  param 3: "-"
                                    //  param 4: "-"
                                    //
                                    //Note:
                                    //
                                    //  This type is used when a logon ID
                                    //  is needed, but one is not available
                                    //  to pass.  For example, if an
                                    //  impersonation logon ID is expected
                                    //  but the subject is not impersonating
                                    //  anyone.
                                    //

    SeAdtParmTypeAccessMask,        //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //  ACCESS_MASK followed by
                                    //  a Unicode string.  The unicode
                                    //  string contains the name of the
                                    //  type of object the access mask
                                    //  applies to.  The event's source
                                    //  further qualifies the object type.
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string built to
                                    //  take advantage of the specified
                                    //  source's parameter message file.
                                    //
                                    //Note:
                                    //
                                    //  An access mask containing three
                                    //  access types for a Widget object
                                    //  type (defined by the Foozle source)
                                    //  might end up looking like:
                                    //
                                    //      %%1062\n\t\t%1066\n\t\t%%601
                                    //
                                    //  The %%numbers are signals to the
                                    //  event viewer to perform parameter
                                    //  substitution before display.
                                    //



    SeAdtParmTypePrivs,             //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string similar to
                                    //  that for access types.  Each priv
                                    //  will be formatted to be displayed
                                    //  on its own line.  E.g.,
                                    //
                                    //      %%642\n\t\t%%651\n\t\t%%655
                                    //

    SeAdtParmTypeObjectTypes,       //Produces 10 parameters with formatting.
                                    //Received value:
                                    //
                                    // Produces a list a stringized GUIDS along
                                    // with information similar to that for
                                    // an access mask.

    SeAdtParmTypeHexUlong,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

// In W2k this value did not exist, it was ParmTypeLUID

    SeAdtParmTypePtr,               //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  pointer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

//
// Everything below exists only in Windows XP and greater
//

    SeAdtParmTypeTime,              //Produces 2 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time.

                                    //
    SeAdtParmTypeGuid,              //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  GUID pointer
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of GUID
                                    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                                    //

//
// Everything below exists only in Windows Server 2003 and Greater
//

    SeAdtParmTypeLuid,              //
                                    //Produces 1 parameter
                                    //Received value:
                                    //
                                    // LUID
                                    //
                                    //Results in:
                                    //
                                    // Hex LUID
                                    //

    SeAdtParmTypeHexInt64,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  64 bit integer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

    SeAdtParmTypeStringList,        //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_STRING_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the strings in the list

    SeAdtParmTypeSidList,           //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_SID_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the SIDs in the list

    SeAdtParmTypeDuration,          //Produces 1 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // a duration.

    SeAdtParmTypeUserAccountControl,//Produces 3 parameters
                                    //Received value:
                                    //
                                    // old and new UserAccountControl values
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representations of
                                    // the flags in UserAccountControl.
                                    // 1 - old value in hex
                                    // 2 - new value in hex
                                    // 3 - difference as strings

    SeAdtParmTypeNoUac,             //Produces 3 parameters
                                    //Received value:
                                    //
                                    // none
                                    //
                                    //Results in:
                                    //
                                    // Three dashes ('-') as unicode strings.

    SeAdtParmTypeMessage,           //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  ULONG (MessageNo from msobjs.mc)
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // %%MessageNo which the event viewer
                                    // will replace with the message string
                                    // from msobjs.mc

    SeAdtParmTypeDateTime,          //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time (in _one_ string).

    SeAdtParmTypeSockAddr,          // Produces 2 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IP address string
                                    // param 2: Port number string
                                    //

//
// Everything below this exists only in Longhorn and greater
//

    SeAdtParmTypeSD,                // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SECURITY_DESCRIPTOR
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // SDDL string representation of SD
                                    //

    SeAdtParmTypeLogonHours,        // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to LOGON_HOURS
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // String representation of allowed logon hours
                                    //

    SeAdtParmTypeLogonIdNoSid,      //Produces 3 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Username string
                                    //  param 2: domain name string
                                    //  param 3: Logon ID (Luid) string

    SeAdtParmTypeUlongNoConv,       // Produces 1 parameter.
                                    // Received Value:
                                    // Ulong
                                    //
                                    //Results in:
                                    // Not converted to string
                                    //

    SeAdtParmTypeSockAddrNoPort     // Produces 1 parameter
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IPv4/IPv6 address string
                                    //

} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

typedef struct _SE_ADT_OBJECT_TYPE {
    GUID ObjectType;
    USHORT Flags;
#define SE_ADT_OBJECT_ONLY 0x1
    USHORT Level;
    ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {

    SE_ADT_PARAMETER_TYPE Type;
    ULONG Length;
    ULONG_PTR Data[2];
    PVOID Address;

} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;



//
// Structure that will be passed between the Reference Monitor and LSA
// to transmit auditing information.
//

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

typedef struct _SE_ADT_PARAMETER_ARRAY {

    ULONG CategoryId;
    ULONG AuditId;
    ULONG ParameterCount;
    ULONG Length;
    USHORT FlatSubCategoryId;
    USHORT Type;
    ULONG Flags;
    SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];

} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;


#define SE_ADT_PARAMETERS_SELF_RELATIVE     0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA       0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT   0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT      0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS  0x00000010


//
// This macro only existed in longhorn and after
//

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(AuditParameters)    \
     ( sizeof(SE_ADT_PARAMETER_ARRAY) -                           \
       sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) *                     \
       (SE_MAX_AUDIT_PARAMETERS - AuditParameters->ParameterCount) )

#endif // _NTLSA_AUDIT_

typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

NTSTATUS
NTAPI
LsaRegisterLogonProcess (
    __in PLSA_STRING LogonProcessName,
    __out PHANDLE LsaHandle,
    __out PLSA_OPERATIONAL_MODE SecurityMode
    );

//
// The function below did not exist in NTIFS before windows XP
// However, the function has always been there, so it is okay to use
// even on w2k
//

NTSTATUS
NTAPI
LsaLogonUser (
    __in HANDLE LsaHandle,
    __in PLSA_STRING OriginName,
    __in SECURITY_LOGON_TYPE LogonType,
    __in ULONG AuthenticationPackage,
    __in_bcount(AuthenticationInformationLength) PVOID AuthenticationInformation,
    __in ULONG AuthenticationInformationLength,
    __in_opt PTOKEN_GROUPS LocalGroups,
    __in PTOKEN_SOURCE SourceContext,
    __out PVOID *ProfileBuffer,
    __out PULONG ProfileBufferLength,
    __out PLUID LogonId,
    __out PHANDLE Token,
    __out PQUOTA_LIMITS Quotas,
    __out PNTSTATUS SubStatus
    );



NTSTATUS
NTAPI
LsaFreeReturnBuffer (
    __in PVOID Buffer
    );


#ifndef _NTLSA_IFS_
#define _NTLSA_IFS_
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Name of the MSV1_0 authentication package                           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

#define MSV1_0_PACKAGE_NAME     "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW    L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW_LENGTH sizeof(MSV1_0_PACKAGE_NAMEW) - sizeof(WCHAR)

//
// Location of MSV authentication package data
//
#define MSV1_0_SUBAUTHENTICATION_KEY "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0"
#define MSV1_0_SUBAUTHENTICATION_VALUE "Auth"


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Widely used MSV1_0 data types                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       LOGON      Related Data Structures
//
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// When a LsaLogonUser() call is dispatched to the MsV1_0 authentication
// package, the beginning of the AuthenticationInformation buffer is
// cast to a MSV1_0_LOGON_SUBMIT_TYPE to determine the type of logon
// being requested.  Similarly, upon return, the type of profile buffer
// can be determined by typecasting it to a MSV_1_0_PROFILE_BUFFER_TYPE.
//

//
//  MSV1.0 LsaLogonUser() submission message types.
//

typedef enum _MSV1_0_LOGON_SUBMIT_TYPE {
    MsV1_0InteractiveLogon = 2,
    MsV1_0Lm20Logon,
    MsV1_0NetworkLogon,
    MsV1_0SubAuthLogon,
    MsV1_0WorkstationUnlockLogon = 7,
    // defined in Longhorn and up
    MsV1_0S4ULogon = 12,
} MSV1_0_LOGON_SUBMIT_TYPE, *PMSV1_0_LOGON_SUBMIT_TYPE;


//
//  MSV1.0 LsaLogonUser() profile buffer types.
//

typedef enum _MSV1_0_PROFILE_BUFFER_TYPE {
    MsV1_0InteractiveProfile = 2,
    MsV1_0Lm20LogonProfile,
    MsV1_0SmartCardProfile
} MSV1_0_PROFILE_BUFFER_TYPE, *PMSV1_0_PROFILE_BUFFER_TYPE;

//
// MsV1_0InteractiveLogon
//
// The AuthenticationInformation buffer of an LsaLogonUser() call to
// perform an interactive logon contains the following data structure:
//

typedef struct _MSV1_0_INTERACTIVE_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
} MSV1_0_INTERACTIVE_LOGON, *PMSV1_0_INTERACTIVE_LOGON;

//
// Where:
//
//     MessageType - Contains the type of logon being requested.  This
//         field must be set to MsV1_0InteractiveLogon.
//
//     UserName - Is a string representing the user's account name.  The
//         name may be up to 255 characters long.  The name is treated case
//         insensitive.
//
//     Password - Is a string containing the user's cleartext password.
//         The password may be up to 255 characters long and contain any
//         UNICODE value.
//
//


//
// The ProfileBuffer returned upon a successful logon of this type
// contains the following data structure:
//

typedef struct _MSV1_0_INTERACTIVE_PROFILE {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    USHORT LogonCount;
    USHORT BadPasswordCount;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING LogonScript;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING FullName;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING LogonServer;
    ULONG UserFlags;
} MSV1_0_INTERACTIVE_PROFILE, *PMSV1_0_INTERACTIVE_PROFILE;

//
// where:
//
//     MessageType - Identifies the type of profile data being returned.
//         Contains the type of logon being requested.  This field must
//         be set to MsV1_0InteractiveProfile.
//
//     LogonCount - Number of times the user is currently logged on.
//
//     BadPasswordCount - Number of times a bad password was applied to
//         the account since last successful logon.
//
//     LogonTime - Time when user last logged on.  This is an absolute
//         format NT standard time value.
//
//     LogoffTime - Time when user should log off.  This is an absolute
//         format NT standard time value.
//
//     KickOffTime - Time when system should force user logoff.  This is
//         an absolute format NT standard time value.
//
//     PasswordLastChanged - Time and date the password was last
//         changed.  This is an absolute format NT standard time
//         value.
//
//     PasswordCanChange - Time and date when the user can change the
//         password.  This is an absolute format NT time value.  To
//         prevent a password from ever changing, set this field to a
//         date very far into the future.
//
//     PasswordMustChange - Time and date when the user must change the
//         password.  If the user can never change the password, this
//         field is undefined.  This is an absolute format NT time
//         value.
//
//     LogonScript - The (relative) path to the account's logon
//         script.
//
//     HomeDirectory - The home directory for the user.
//


//
// MsV1_0Lm20Logon and MsV1_0NetworkLogon
//
// The AuthenticationInformation buffer of an LsaLogonUser() call to
// perform an network logon contains the following data structure:
//
// MsV1_0NetworkLogon logon differs from MsV1_0Lm20Logon in that the
// ParameterControl field exists.
//

#define MSV1_0_CHALLENGE_LENGTH 8
#define MSV1_0_USER_SESSION_KEY_LENGTH 16
#define MSV1_0_LANMAN_SESSION_KEY_LENGTH 8

//
// Values for ParameterControl.
//

#define MSV1_0_CLEARTEXT_PASSWORD_ALLOWED    0x02
#define MSV1_0_UPDATE_LOGON_STATISTICS       0x04
#define MSV1_0_RETURN_USER_PARAMETERS        0x08
#define MSV1_0_DONT_TRY_GUEST_ACCOUNT        0x10
#define MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT    0x20
#define MSV1_0_RETURN_PASSWORD_EXPIRY        0x40
// this next flag says that CaseInsensitiveChallengeResponse
//  (aka LmResponse) contains a client challenge in the first 8 bytes
#define MSV1_0_USE_CLIENT_CHALLENGE          0x80
#define MSV1_0_TRY_GUEST_ACCOUNT_ONLY        0x100
#define MSV1_0_RETURN_PROFILE_PATH           0x200
#define MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY     0x400
#define MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT 0x800
//#if (_WIN32_WINNT >= 0x0501) -- Disabled until IIS fixes their target version.
#define MSV1_0_DISABLE_PERSONAL_FALLBACK     0x00001000
#define MSV1_0_ALLOW_FORCE_GUEST             0x00002000
//#endif
#if (_WIN32_WINNT >= 0x0502)
#define MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED   0x00004000
// Start
// Doesnt exist in Windows XP but does exist in Windows 2000 Security Rollup and up
#define MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY   0x00008000
#endif
#define MSV1_0_SUBAUTHENTICATION_DLL_EX      0x00100000
// Defined in Windows Server 2003 SP1 and above
#define MSV1_0_ALLOW_MSVCHAPV2               0x00010000

#if (_WIN32_WINNT >= 0x0600)

//Defined in Longhorn and up
#define MSV1_0_S4U2SELF                      0x00020000 // no password is needed
#define MSV1_0_CHECK_LOGONHOURS_FOR_S4U      0x00040000 // check logon hours for S4U logon

#endif

//
// The high order byte is a value indicating the SubAuthentication DLL.
//  Zero indicates no SubAuthentication DLL.
//
#define MSV1_0_SUBAUTHENTICATION_DLL         0xFF000000
#define MSV1_0_SUBAUTHENTICATION_DLL_SHIFT   24
#define MSV1_0_MNS_LOGON                     0x01000000

//
// This is the list of subauthentication dlls used in MS
//

#define MSV1_0_SUBAUTHENTICATION_DLL_RAS     2
#define MSV1_0_SUBAUTHENTICATION_DLL_IIS     132

typedef struct _MSV1_0_LM20_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING CaseSensitiveChallengeResponse;
    STRING CaseInsensitiveChallengeResponse;
    ULONG ParameterControl;
} MSV1_0_LM20_LOGON, * PMSV1_0_LM20_LOGON;

//
// NT 5.0 SubAuth dlls can use this struct
//

typedef struct _MSV1_0_SUBAUTH_LOGON{
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING AuthenticationInfo1;
    STRING AuthenticationInfo2;
    ULONG ParameterControl;
    ULONG SubAuthPackageId;
} MSV1_0_SUBAUTH_LOGON, * PMSV1_0_SUBAUTH_LOGON;

#if (_WIN32_WINNT >= 0x0600)

//
// s4u2self logon
//
// Defined in Longhorn and above

//
// request to enforce logon hours policy
//

#define MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS 0x2

typedef struct _MSV1_0_S4U_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    ULONG Flags;
    UNICODE_STRING UserPrincipalName; // username or username@domain
    UNICODE_STRING DomainName; // Optional: if missing, using the local machine
} MSV1_0_S4U_LOGON, *PMSV1_0_S4U_LOGON;

#endif 

//
// Values for UserFlags.
//

#define LOGON_GUEST                 0x01
#define LOGON_NOENCRYPTION          0x02
#define LOGON_CACHED_ACCOUNT        0x04
#define LOGON_USED_LM_PASSWORD      0x08
#define LOGON_EXTRA_SIDS            0x20
#define LOGON_SUBAUTH_SESSION_KEY   0x40
#define LOGON_SERVER_TRUST_ACCOUNT  0x80
#define LOGON_NTLMV2_ENABLED        0x100       // says DC understands NTLMv2
#define LOGON_RESOURCE_GROUPS       0x200
#define LOGON_PROFILE_PATH_RETURNED 0x400
// Defined in Longhorn and above
#define LOGON_NT_V2                 0x800   // NT response was used for validation
#define LOGON_LM_V2                 0x1000  // LM response was used for validation
#define LOGON_NTLM_V2               0x2000  // LM response was used to authenticate but NT response was used to derive the session key

#if (_WIN32_WINNT >= 0x0600)

#define LOGON_OPTIMIZED             0x4000  // this is an optimized logon
#define LOGON_WINLOGON              0x8000  // the logon session was created for winlogon
#define LOGON_PKINIT               0x10000  // Kerberos PKINIT extension was used to authenticate the user
#define LOGON_NO_OPTIMIZED         0x20000  // optimized logon has been disabled for this account

#endif

//
// The high order byte is reserved for return by SubAuthentication DLLs.
//

#define MSV1_0_SUBAUTHENTICATION_FLAGS 0xFF000000

// Values returned by the MSV1_0_MNS_LOGON SubAuthentication DLL
#define LOGON_GRACE_LOGON              0x01000000

typedef struct _MSV1_0_LM20_LOGON_PROFILE {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER LogoffTime;
    ULONG UserFlags;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UNICODE_STRING LogonDomainName;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    UNICODE_STRING LogonServer;
    UNICODE_STRING UserParameters;
} MSV1_0_LM20_LOGON_PROFILE, * PMSV1_0_LM20_LOGON_PROFILE;


//
// Supplemental credentials structure used for passing credentials into
// MSV1_0 from other packages
//

#define MSV1_0_OWF_PASSWORD_LENGTH 16
#define MSV1_0_CRED_LM_PRESENT 0x1
#define MSV1_0_CRED_NT_PRESENT 0x2
#define MSV1_0_CRED_VERSION 0

typedef struct _MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    ULONG Version;
    ULONG Flags;
    UCHAR LmPassword[MSV1_0_OWF_PASSWORD_LENGTH];
    UCHAR NtPassword[MSV1_0_OWF_PASSWORD_LENGTH];
} MSV1_0_SUPPLEMENTAL_CREDENTIAL, *PMSV1_0_SUPPLEMENTAL_CREDENTIAL;


//
// NTLM3 definitions.
//

#define MSV1_0_NTLM3_RESPONSE_LENGTH 16
#define MSV1_0_NTLM3_OWF_LENGTH 16

//
// this is the longest amount of time we'll allow challenge response
// pairs to be used. Note that this also has to allow for worst case clock skew
//
#if (_WIN32_WINNT == 0x0500)
#define MSV1_0_MAX_NTLM3_LIFE 1800     // 30 minutes (in seconds)
#else
#define MSV1_0_MAX_NTLM3_LIFE 129600     // 36 hours (in seconds)
#endif
#define MSV1_0_MAX_AVL_SIZE 64000

#if (_WIN32_WINNT >= 0x0501)
//
// MsvAvFlags bit values
//
// Exists only after Windows 2000
//

#define MSV1_0_AV_FLAG_FORCE_GUEST                  0x00000001
#if (_WIN32_WINNT >= 0x0600)
#define MSV1_0_AV_FLAG_MIC_HANDSHAKE_MESSAGES       0x00000002 // the client supports
                                                               // hand-shake messages integrity
#endif
#endif

// this is an MSV1_0 private data structure, defining the layout of an NTLM3 response, as sent by a
//  client in the NtChallengeResponse field of the NETLOGON_NETWORK_INFO structure. If can be differentiated
//  from an old style NT response by its length. This is crude, but it needs to pass through servers and
//  the servers' DCs that do not understand NTLM3 but that are willing to pass longer responses.
typedef struct _MSV1_0_NTLM3_RESPONSE {
    UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH]; // hash of OWF of password with all the following fields
    UCHAR RespType;     // id number of response; current is 1
    UCHAR HiRespType;   // highest id number understood by client
    USHORT Flags;       // reserved; must be sent as zero at this version
    ULONG MsgWord;      // 32 bit message from client to server (for use by auth protocol)
    ULONGLONG TimeStamp;    // time stamp when client generated response -- NT system time, quad part
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
    ULONG AvPairsOff;   // offset to start of AvPairs (to allow future expansion)
    UCHAR Buffer[1];    // start of buffer with AV pairs (or future stuff -- so use the offset)
} MSV1_0_NTLM3_RESPONSE, *PMSV1_0_NTLM3_RESPONSE;

#define MSV1_0_NTLM3_INPUT_LENGTH (sizeof(MSV1_0_NTLM3_RESPONSE) - MSV1_0_NTLM3_RESPONSE_LENGTH)
#if(_WIN32_WINNT >= 0x0502)
#define MSV1_0_NTLM3_MIN_NT_RESPONSE_LENGTH RTL_SIZEOF_THROUGH_FIELD(MSV1_0_NTLM3_RESPONSE, AvPairsOff)
#endif

typedef enum {
    MsvAvEOL,                 // end of list
    MsvAvNbComputerName,      // server's computer name -- NetBIOS
    MsvAvNbDomainName,        // server's domain name -- NetBIOS
    MsvAvDnsComputerName,     // server's computer name -- DNS
    MsvAvDnsDomainName,       // server's domain name -- DNS
#if (_WIN32_WINNT >= 0x0501)
    MsvAvDnsTreeName,         // server's tree name -- DNS
    MsvAvFlags,               // server's extended flags -- DWORD mask
#if (_WIN32_WINNT >= 0x0600)
    MsvAvTimestamp,           // contains the server's local time in FILETIME,
                              // (64 bit 100 ns ticks since 1602
                              // (UTC)) in little endian byte order
    MsvAvRestrictions,        // token restrictions                              
#endif
#endif
} MSV1_0_AVID;

typedef struct  _MSV1_0_AV_PAIR {
    USHORT AvId;
    USHORT AvLen;
    // Data is treated as byte array following structure
} MSV1_0_AV_PAIR, *PMSV1_0_AV_PAIR;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       CALL PACKAGE Related Data Structures                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
//  MSV1.0 LsaCallAuthenticationPackage() submission and response
//  message types.
//

typedef enum _MSV1_0_PROTOCOL_MESSAGE_TYPE {
    MsV1_0Lm20ChallengeRequest = 0,          // Both submission and response
    MsV1_0Lm20GetChallengeResponse,          // Both submission and response
    MsV1_0EnumerateUsers,                    // Both submission and response
    MsV1_0GetUserInfo,                       // Both submission and response
    MsV1_0ReLogonUsers,                      // Submission only
    MsV1_0ChangePassword,                    // Both submission and response
    MsV1_0ChangeCachedPassword,              // Both submission and response
    MsV1_0GenericPassthrough,                // Both submission and response
    MsV1_0CacheLogon,                        // Submission only, no response
    MsV1_0SubAuth,                           // Both submission and response
    MsV1_0DeriveCredential,                  // Both submission and response
    MsV1_0CacheLookup,                       // Both submission and response
#if (_WIN32_WINNT >= 0x0501)
    MsV1_0SetProcessOption,                  // Submission only, no response
#endif
#if (_WIN32_WINNT >= 0x0600)
    MsV1_0ConfigLocalAliases,
    MsV1_0ClearCachedCredentials,
#endif    
} MSV1_0_PROTOCOL_MESSAGE_TYPE, *PMSV1_0_PROTOCOL_MESSAGE_TYPE;

// end_ntsecapi

//
// MsV1_0Lm20ChallengeRequest submit buffer and response
//

typedef struct _MSV1_0_LM20_CHALLENGE_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
} MSV1_0_LM20_CHALLENGE_REQUEST, *PMSV1_0_LM20_CHALLENGE_REQUEST;

typedef struct _MSV1_0_LM20_CHALLENGE_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_LM20_CHALLENGE_RESPONSE, *PMSV1_0_LM20_CHALLENGE_RESPONSE;

//
// MsV1_0Lm20GetChallengeResponse submit buffer and response
//

#define USE_PRIMARY_PASSWORD            0x01
#define RETURN_PRIMARY_USERNAME         0x02
#define RETURN_PRIMARY_LOGON_DOMAINNAME 0x04
#define RETURN_NON_NT_USER_SESSION_KEY  0x08
#define GENERATE_CLIENT_CHALLENGE       0x10
#define GCR_NTLM3_PARMS                 0x20
#define GCR_TARGET_INFO                 0x40    // ServerName field contains target info AV pairs
#define RETURN_RESERVED_PARAMETER       0x80    // was 0x10
#define GCR_ALLOW_NTLM                 0x100    // allow the use of NTLM
// Exists in Windows XPSP2 and later
#define GCR_USE_OEM_SET                0x200    // response uses oem character set
#define GCR_MACHINE_CREDENTIAL         0x400
#define GCR_USE_OWF_PASSWORD           0x800    // use owf passwords
#define GCR_ALLOW_LM                  0x1000    // allow the use of LM
// Defined in Windows Server 2003 and above
#define GCR_ALLOW_NO_TARGET           0x2000    // allow no target server or target domain name

//
// version 1 of the GETCHALLENRESP structure, which was used by RAS and others.
// compiled before the additional fields added to GETCHALLENRESP_REQUEST.
// here to allow sizing operations for backwards compatibility.
//

typedef struct _MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG ParameterControl;
    LUID LogonId;
    UNICODE_STRING Password;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_GETCHALLENRESP_REQUEST_V1, *PMSV1_0_GETCHALLENRESP_REQUEST_V1;

typedef struct _MSV1_0_GETCHALLENRESP_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG ParameterControl;
    LUID LogonId;
    UNICODE_STRING Password;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];

    //
    // the following 3 fields are only present if GCR_NTLM3_PARMS is set in ParameterControl
    //

    UNICODE_STRING UserName;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING ServerName;      // server domain or target info AV pairs
} MSV1_0_GETCHALLENRESP_REQUEST, *PMSV1_0_GETCHALLENRESP_REQUEST;

typedef struct _MSV1_0_GETCHALLENRESP_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    STRING CaseSensitiveChallengeResponse;
    STRING CaseInsensitiveChallengeResponse;
    UNICODE_STRING UserName;
    UNICODE_STRING LogonDomainName;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
} MSV1_0_GETCHALLENRESP_RESPONSE, *PMSV1_0_GETCHALLENRESP_RESPONSE;

//
// MsV1_0EnumerateUsers submit buffer and response
//

typedef struct _MSV1_0_ENUMUSERS_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
} MSV1_0_ENUMUSERS_REQUEST, *PMSV1_0_ENUMUSERS_REQUEST;

typedef struct _MSV1_0_ENUMUSERS_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG NumberOfLoggedOnUsers;
    PLUID LogonIds;
    PULONG EnumHandles;
} MSV1_0_ENUMUSERS_RESPONSE, *PMSV1_0_ENUMUSERS_RESPONSE;

//
// MsV1_0GetUserInfo submit buffer and response
//

typedef struct _MSV1_0_GETUSERINFO_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
} MSV1_0_GETUSERINFO_REQUEST, *PMSV1_0_GETUSERINFO_REQUEST;

typedef struct _MSV1_0_GETUSERINFO_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PSID UserSid;
    UNICODE_STRING UserName;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING LogonServer;
    SECURITY_LOGON_TYPE LogonType;
} MSV1_0_GETUSERINFO_RESPONSE, *PMSV1_0_GETUSERINFO_RESPONSE;


//
// Define the I/O status information return values for requests for oplocks
// via NtFsControlFile
//

#define FILE_OPLOCK_BROKEN_TO_LEVEL_2   0x00000007
#define FILE_OPLOCK_BROKEN_TO_NONE      0x00000008

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
// when the sharing access fails but a batch oplock break is in progress
//

#define FILE_OPBATCH_BREAK_UNDERWAY     0x00000009

//
// Define the filter flags for NtNotifyChangeDirectoryFile
//

#define FILE_NOTIFY_CHANGE_FILE_NAME    0x00000001   // winnt
#define FILE_NOTIFY_CHANGE_DIR_NAME     0x00000002   // winnt
#define FILE_NOTIFY_CHANGE_NAME         0x00000003
#define FILE_NOTIFY_CHANGE_ATTRIBUTES   0x00000004   // winnt
#define FILE_NOTIFY_CHANGE_SIZE         0x00000008   // winnt
#define FILE_NOTIFY_CHANGE_LAST_WRITE   0x00000010   // winnt
#define FILE_NOTIFY_CHANGE_LAST_ACCESS  0x00000020   // winnt
#define FILE_NOTIFY_CHANGE_CREATION     0x00000040   // winnt
#define FILE_NOTIFY_CHANGE_EA           0x00000080
#define FILE_NOTIFY_CHANGE_SECURITY     0x00000100   // winnt
#define FILE_NOTIFY_CHANGE_STREAM_NAME  0x00000200
#define FILE_NOTIFY_CHANGE_STREAM_SIZE  0x00000400
#define FILE_NOTIFY_CHANGE_STREAM_WRITE 0x00000800
#define FILE_NOTIFY_VALID_MASK          0x00000fff

//
// Define the file action type codes for NtNotifyChangeDirectoryFile
//

#define FILE_ACTION_ADDED                   0x00000001   // winnt
#define FILE_ACTION_REMOVED                 0x00000002   // winnt
#define FILE_ACTION_MODIFIED                0x00000003   // winnt
#define FILE_ACTION_RENAMED_OLD_NAME        0x00000004   // winnt
#define FILE_ACTION_RENAMED_NEW_NAME        0x00000005   // winnt
#define FILE_ACTION_ADDED_STREAM            0x00000006
#define FILE_ACTION_REMOVED_STREAM          0x00000007
#define FILE_ACTION_MODIFIED_STREAM         0x00000008
#define FILE_ACTION_REMOVED_BY_DELETE       0x00000009
#define FILE_ACTION_ID_NOT_TUNNELLED        0x0000000A
#define FILE_ACTION_TUNNELLED_ID_COLLISION  0x0000000B

//
// Define the NamedPipeType flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_TYPE          0x00000000
#define FILE_PIPE_MESSAGE_TYPE              0x00000001

#define FILE_PIPE_ACCEPT_REMOTE_CLIENTS     0x00000000
#define FILE_PIPE_REJECT_REMOTE_CLIENTS     0x00000002

#define FILE_PIPE_TYPE_VALID_MASK           0x00000003

//
// Define the CompletionMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_QUEUE_OPERATION       0x00000000
#define FILE_PIPE_COMPLETE_OPERATION    0x00000001

//
// Define the ReadMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
#define FILE_PIPE_MESSAGE_MODE          0x00000001

//
// Define the NamedPipeConfiguration flags for NtQueryInformation
//

#define FILE_PIPE_INBOUND               0x00000000
#define FILE_PIPE_OUTBOUND              0x00000001
#define FILE_PIPE_FULL_DUPLEX           0x00000002

//
// Define the NamedPipeState flags for NtQueryInformation
//

#define FILE_PIPE_DISCONNECTED_STATE    0x00000001
#define FILE_PIPE_LISTENING_STATE       0x00000002
#define FILE_PIPE_CONNECTED_STATE       0x00000003
#define FILE_PIPE_CLOSING_STATE         0x00000004

//
// Define the NamedPipeEnd flags for NtQueryInformation
//

#define FILE_PIPE_CLIENT_END            0x00000000
#define FILE_PIPE_SERVER_END            0x00000001


//
// Define the file system attributes flags
//

#define FILE_CASE_SENSITIVE_SEARCH      0x00000001  // winnt
#define FILE_CASE_PRESERVED_NAMES       0x00000002  // winnt
#define FILE_UNICODE_ON_DISK            0x00000004  // winnt
#define FILE_PERSISTENT_ACLS            0x00000008  // winnt
#define FILE_FILE_COMPRESSION           0x00000010  // winnt
#define FILE_VOLUME_QUOTAS              0x00000020  // winnt
#define FILE_SUPPORTS_SPARSE_FILES      0x00000040  // winnt
#define FILE_SUPPORTS_REPARSE_POINTS    0x00000080  // winnt
#define FILE_SUPPORTS_REMOTE_STORAGE    0x00000100  // winnt
#define FILE_VOLUME_IS_COMPRESSED       0x00008000  // winnt
#define FILE_SUPPORTS_OBJECT_IDS        0x00010000  // winnt
#define FILE_SUPPORTS_ENCRYPTION        0x00020000  // winnt
#define FILE_NAMED_STREAMS              0x00040000  // winnt
#define FILE_READ_ONLY_VOLUME           0x00080000  // winnt
#define FILE_SEQUENTIAL_WRITE_ONCE      0x00100000  // winnt
#define FILE_SUPPORTS_TRANSACTIONS      0x00200000  // winnt

//
// Define the flags for NtSet(Query)EaFile service structure entries
//

#define FILE_NEED_EA                    0x00000080

//
// Define EA type values
//

#define FILE_EA_TYPE_BINARY             0xfffe
#define FILE_EA_TYPE_ASCII              0xfffd
#define FILE_EA_TYPE_BITMAP             0xfffb
#define FILE_EA_TYPE_METAFILE           0xfffa
#define FILE_EA_TYPE_ICON               0xfff9
#define FILE_EA_TYPE_EA                 0xffee
#define FILE_EA_TYPE_MVMT               0xffdf
#define FILE_EA_TYPE_MVST               0xffde
#define FILE_EA_TYPE_ASN1               0xffdd
#define FILE_EA_TYPE_FAMILY_IDS         0xff01


//
// Define the file notification information structure
//

typedef struct _FILE_NOTIFY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG Action;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;


//
// NtQueryDirectoryFile return types:
//
//      FILE_DIRECTORY_INFORMATION
//      FILE_FULL_DIR_INFORMATION
//      FILE_ID_FULL_DIR_INFORMATION
//      FILE_BOTH_DIR_INFORMATION
//      FILE_ID_BOTH_DIR_INFORMATION
//      FILE_NAMES_INFORMATION
//      FILE_OBJECTID_INFORMATION
//

typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    LARGE_INTEGER FileId;
    GUID LockingTransactionId;
    ULONG TxInfoFlags;
    WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED         0x00000001
#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX       0x00000002
#define FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX  0x00000004

typedef struct _FILE_OBJECTID_INFORMATION {
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        } DUMMYSTRUCTNAME;
        UCHAR ExtendedInfo[48];
    } DUMMYUNIONNAME;
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

//
//  The following constants provide addition meta characters to fully
//  support the more obscure aspects of DOS wild card processing.
//

#define ANSI_DOS_STAR   ('<')
#define ANSI_DOS_QM     ('>')
#define ANSI_DOS_DOT    ('"')

#define DOS_STAR        (L'<')
#define DOS_QM          (L'>')
#define DOS_DOT         (L'"')

//
// NtQuery(Set)InformationFile return types:
//
//      FILE_BASIC_INFORMATION
//      FILE_STANDARD_INFORMATION
//      FILE_INTERNAL_INFORMATION
//      FILE_EA_INFORMATION
//      FILE_ACCESS_INFORMATION
//      FILE_POSITION_INFORMATION
//      FILE_MODE_INFORMATION
//      FILE_ALIGNMENT_INFORMATION
//      FILE_NAME_INFORMATION
//      FILE_ALL_INFORMATION
//
//      FILE_NETWORK_OPEN_INFORMATION
//
//      FILE_ALLOCATION_INFORMATION
//      FILE_COMPRESSION_INFORMATION
//      FILE_DISPOSITION_INFORMATION
//      FILE_END_OF_FILE_INFORMATION
//      FILE_LINK_INFORMATION
//      FILE_MOVE_CLUSTER_INFORMATION
//      FILE_RENAME_INFORMATION
//      FILE_SHORT_NAME_INFORMATION
//      FILE_STREAM_INFORMATION
//      FILE_COMPLETION_INFORMATION
//
//      FILE_PIPE_INFORMATION
//      FILE_PIPE_LOCAL_INFORMATION
//      FILE_PIPE_REMOTE_INFORMATION
//
//      FILE_MAILSLOT_QUERY_INFORMATION
//      FILE_MAILSLOT_SET_INFORMATION
//      FILE_REPARSE_POINT_INFORMATION
//
//      FILE_NETWORK_PHYSICAL_NAME_INFORMATION
//


typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;


typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;


typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;


#ifdef _MAC
#pragma warning( disable : 4121)
#endif

typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;


#ifdef _MAC
#pragma warning( default : 4121 )
#endif

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

#ifdef _MAC
#pragma warning( disable : 4121)
#endif

typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

#ifdef _MAC
#pragma warning( default : 4121 )
#endif

typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

typedef struct _FILE_PIPE_INFORMATION {
     ULONG ReadMode;
     ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
     ULONG MaximumInstances;
     ULONG CurrentInstances;
     ULONG InboundQuota;
     ULONG ReadDataAvailable;
     ULONG OutboundQuota;
     ULONG WriteQuotaAvailable;
     ULONG NamedPipeState;
     ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
     LARGE_INTEGER CollectDataTime;
     ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;


typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
    ULONG NextEntryOffset;
    LONGLONG ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

//
// NtQuery(Set)EaFile
//
// The offset for the start of EaValue is EaName[EaNameLength + 1]
//
// begin_wdm


typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;


//
// NtQuery(Set)QuotaInformationFile
//

typedef struct _FILE_GET_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;


typedef struct _FILE_FS_ATTRIBUTE_INFORMATION {
    ULONG FileSystemAttributes;
    LONG MaximumComponentNameLength;
    ULONG FileSystemNameLength;
    WCHAR FileSystemName[1];
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;

typedef struct _FILE_FS_DRIVER_PATH_INFORMATION {
    BOOLEAN DriverInPath;
    ULONG   DriverNameLength;
    WCHAR   DriverName[1];
} FILE_FS_DRIVER_PATH_INFORMATION, *PFILE_FS_DRIVER_PATH_INFORMATION;

typedef struct _FILE_FS_VOLUME_FLAGS_INFORMATION {
    ULONG Flags;
} FILE_FS_VOLUME_FLAGS_INFORMATION, *PFILE_FS_VOLUME_FLAGS_INFORMATION;

//
// File system control flags
//

#define FILE_VC_QUOTA_NONE                  0x00000000
#define FILE_VC_QUOTA_TRACK                 0x00000001
#define FILE_VC_QUOTA_ENFORCE               0x00000002
#define FILE_VC_QUOTA_MASK                  0x00000003

#define FILE_VC_CONTENT_INDEX_DISABLED      0x00000008

#define FILE_VC_LOG_QUOTA_THRESHOLD         0x00000010
#define FILE_VC_LOG_QUOTA_LIMIT             0x00000020
#define FILE_VC_LOG_VOLUME_THRESHOLD        0x00000040
#define FILE_VC_LOG_VOLUME_LIMIT            0x00000080

#define FILE_VC_QUOTAS_INCOMPLETE           0x00000100
#define FILE_VC_QUOTAS_REBUILDING           0x00000200

#define FILE_VC_VALID_MASK                  0x000003ff

typedef struct _FILE_FS_CONTROL_INFORMATION {
    LARGE_INTEGER FreeSpaceStartFiltering;
    LARGE_INTEGER FreeSpaceThreshold;
    LARGE_INTEGER FreeSpaceStopFiltering;
    LARGE_INTEGER DefaultQuotaThreshold;
    LARGE_INTEGER DefaultQuotaLimit;
    ULONG FileSystemControlFlags;
} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateFile (
    __out PHANDLE FileHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_opt PLARGE_INTEGER AllocationSize,
    __in ULONG FileAttributes,
    __in ULONG ShareAccess,
    __in ULONG CreateDisposition,
    __in ULONG CreateOptions,
    __in_bcount_opt(EaLength) PVOID EaBuffer,
    __in ULONG EaLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG IoControlCode,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtFsControlFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG FsControlCode,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in PLARGE_INTEGER ByteOffset,
    __in PLARGE_INTEGER Length,
    __in ULONG Key,
    __in BOOLEAN FailImmediately,
    __in BOOLEAN ExclusiveLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenFile (
    __out PHANDLE FileHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG ShareAccess,
    __in ULONG OpenOptions
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass,
    __in BOOLEAN ReturnSingleEntry,
    __in_opt PUNICODE_STRING FileName,
    __in BOOLEAN RestartScan
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in BOOLEAN ReturnSingleEntry,
    __in_bcount_opt(SidListLength) PVOID SidList,
    __in ULONG SidListLength,
    __in_opt PSID StartSid,
    __in BOOLEAN RestartScan
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetVolumeInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in PLARGE_INTEGER ByteOffset,
    __in PLARGE_INTEGER Length,
    __in ULONG Key
    );
#endif

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//
// These macros are defined in devioctl.h which contains the portable IO
// definitions (for use by both DOS and NT)
//

//
// The IoGetFunctionCodeFromCtlCode( ControlCode ) Macro is defined in io.h
// This macro is used to extract the function code from an IOCTL (or FSCTL).
// The macro can only be used in kernel mode code.
//

//
// General File System control codes - Note that these values are valid
// regardless of the actual file system type
//

//
//  IMPORTANT:  These values have been arranged in order of increasing
//              control codes.  Do NOT breaks this!!  Add all new codes
//              at end of list regardless of functionality type.
//
//  Note: FSCTL_QUERY_RETRIEVAL_POINTER and FSCTL_MARK_AS_SYSTEM_HIVE only
//        work from Kernel mode on local paging files or the system hives.
//

// begin_winioctl

#ifndef _FILESYSTEMFSCTL_
#define _FILESYSTEMFSCTL_

//
// The following is a list of the native file system fsctls followed by
// additional network file system fsctls.  Some values have been
// decommissioned.
//

#define FSCTL_REQUEST_OPLOCK_LEVEL_1    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK_LEVEL_2    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_BATCH_OPLOCK      CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPBATCH_ACK_CLOSE_PENDING CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_NOTIFY       CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LOCK_VOLUME               CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  8, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                              9
#define FSCTL_IS_VOLUME_MOUNTED         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_PATHNAME_VALID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS) // PATHNAME_BUFFER,
#define FSCTL_MARK_VOLUME_DIRTY         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             13
#define FSCTL_QUERY_RETRIEVAL_POINTERS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
// decommissioned fsctl value                                             17
// decommissioned fsctl value                                             18
#define FSCTL_MARK_AS_SYSTEM_HIVE       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACK_NO_2     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_INVALIDATE_VOLUMES        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_FAT_BPB             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS) // FSCTL_QUERY_FAT_BPB_BUFFER
#define FSCTL_REQUEST_FILTER_OPLOCK     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILESYSTEM_GET_STATISTICS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILESYSTEM_STATISTICS

#if(_WIN32_WINNT >= 0x0400)
#define FSCTL_GET_NTFS_VOLUME_DATA      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_VOLUME_DATA_BUFFER
#define FSCTL_GET_NTFS_FILE_RECORD      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_FILE_RECORD_INPUT_BUFFER, NTFS_FILE_RECORD_OUTPUT_BUFFER
#define FSCTL_GET_VOLUME_BITMAP         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_NEITHER, FILE_ANY_ACCESS) // STARTING_LCN_INPUT_BUFFER, VOLUME_BITMAP_BUFFER
#define FSCTL_GET_RETRIEVAL_POINTERS    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_NEITHER, FILE_ANY_ACCESS) // STARTING_VCN_INPUT_BUFFER, RETRIEVAL_POINTERS_BUFFER
#define FSCTL_MOVE_FILE                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // MOVE_FILE_DATA,
#define FSCTL_IS_VOLUME_DIRTY           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decomissioned fsctl value                                              31
#define FSCTL_ALLOW_EXTENDED_DASD_IO    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 32, METHOD_NEITHER,  FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)
// decommissioned fsctl value                                             33
// decommissioned fsctl value                                             34
#define FSCTL_FIND_FILES_BY_SID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             36
// decommissioned fsctl value                                             37
#define FSCTL_SET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_GET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_DELETE_OBJECT_ID          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // REPARSE_DATA_BUFFER,
#define FSCTL_GET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS) // REPARSE_DATA_BUFFER
#define FSCTL_DELETE_REPARSE_POINT      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // REPARSE_DATA_BUFFER,
#define FSCTL_ENUM_USN_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_NEITHER, FILE_ANY_ACCESS) // MFT_ENUM_DATA,
#define FSCTL_SECURITY_ID_CHECK         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_NEITHER, FILE_READ_DATA)  // BULK_SECURITY_TEST_DATA,
#define FSCTL_READ_USN_JOURNAL          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_NEITHER, FILE_ANY_ACCESS) // READ_USN_JOURNAL_DATA, USN
#define FSCTL_SET_OBJECT_ID_EXTENDED    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_CREATE_OR_GET_OBJECT_ID   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_SET_SPARSE                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_ZERO_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA) // FILE_ZERO_DATA_INFORMATION,
#define FSCTL_QUERY_ALLOCATED_RANGES    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_NEITHER, FILE_READ_DATA)  // FILE_ALLOCATED_RANGE_BUFFER, FILE_ALLOCATED_RANGE_BUFFER
#define FSCTL_ENABLE_UPGRADE            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_SET_ENCRYPTION            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_NEITHER, FILE_ANY_ACCESS) // ENCRYPTION_BUFFER, DECRYPTION_STATUS_BUFFER
#define FSCTL_ENCRYPTION_FSCTL_IO       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_WRITE_RAW_ENCRYPTED       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_NEITHER, FILE_SPECIAL_ACCESS) // ENCRYPTED_DATA_INFO,
#define FSCTL_READ_RAW_ENCRYPTED        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_NEITHER, FILE_SPECIAL_ACCESS) // REQUEST_RAW_ENCRYPTED_DATA, ENCRYPTED_DATA_INFO
#define FSCTL_CREATE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_NEITHER, FILE_ANY_ACCESS) // CREATE_USN_JOURNAL_DATA,
#define FSCTL_READ_FILE_USN_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_NEITHER, FILE_ANY_ACCESS) // Read the Usn Record for a file
#define FSCTL_WRITE_USN_CLOSE_RECORD    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_NEITHER, FILE_ANY_ACCESS) // Generate Close Usn Record
#define FSCTL_EXTEND_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_USN_JOURNAL         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MARK_HANDLE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_COPYFILE              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_LINK_FILES            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_HSM_MSG                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 66, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
// decommissioned fsctl value                                             67
#define FSCTL_HSM_DATA                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 68, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_RECALL_FILE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             70
#define FSCTL_READ_FROM_PLEX            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 71, METHOD_OUT_DIRECT, FILE_READ_DATA)
#define FSCTL_FILE_PREFETCH             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // FILE_PREFETCH
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0600)
#define FSCTL_MAKE_MEDIA_COMPATIBLE         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 76, METHOD_BUFFERED, FILE_WRITE_DATA) // UDFS R/W
#define FSCTL_SET_DEFECT_MANAGEMENT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 77, METHOD_BUFFERED, FILE_WRITE_DATA) // UDFS R/W
#define FSCTL_QUERY_SPARING_INFO            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 78, METHOD_BUFFERED, FILE_ANY_ACCESS) // UDFS R/W
#define FSCTL_QUERY_ON_DISK_VOLUME_INFO     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 79, METHOD_BUFFERED, FILE_ANY_ACCESS) // C/UDFS
#define FSCTL_SET_VOLUME_COMPRESSION_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 80, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // VOLUME_COMPRESSION_STATE
#define FSCTL_TXFS_MODIFY_RM                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 81, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_QUERY_RM_INFORMATION     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 82, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
// decommissioned fsctl value                                                 83
#define FSCTL_TXFS_ROLLFORWARD_REDO         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 84, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_ROLLFORWARD_UNDO         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 85, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_START_RM                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 86, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_SHUTDOWN_RM              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 87, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_READ_BACKUP_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 88, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 89, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_CREATE_SECONDARY_RM      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 90, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_GET_METADATA_INFO        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 91, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_TXFS_GET_TRANSACTED_VERSION   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 92, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
// decommissioned fsctl value                                                 93
#define FSCTL_TXFS_SAVEPOINT_INFORMATION    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 94, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
#define FSCTL_TXFS_CREATE_MINIVERSION       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 95, METHOD_BUFFERED, FILE_WRITE_DATA) // TxF
// decommissioned fsctl value                                                 96
// decommissioned fsctl value                                                 97
// decommissioned fsctl value                                                 98
#define FSCTL_TXFS_TRANSACTION_ACTIVE       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 99, METHOD_BUFFERED, FILE_READ_DATA)  // TxF
#define FSCTL_SET_ZERO_ON_DEALLOCATION      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 101, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPAIR                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_REPAIR                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_WAIT_FOR_REPAIR               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                                 105
#define FSCTL_INITIATE_REPAIR               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSC_INTERNAL                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 107, METHOD_NEITHER, FILE_ANY_ACCESS) // CSC internal implementation
#define FSCTL_SHRINK_VOLUME                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 108, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // SHRINK_VOLUME_INFORMATION
#define FSCTL_SET_SHORT_NAME_BEHAVIOR       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFSR_SET_GHOST_HANDLE_STATE   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 110, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  Values 111 - 119 are reserved for FSRM.
//

#define FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES \
                                            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 120, METHOD_BUFFERED, FILE_READ_DATA) // TxF
#define FSCTL_TXFS_LIST_TRANSACTIONS        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 121, METHOD_BUFFERED, FILE_READ_DATA) // TxF
#define FSCTL_QUERY_PAGEFILE_ENCRYPTION     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 122, METHOD_BUFFERED, FILE_ANY_ACCESS)
//  Values 124 - 130 are available

//
//  Values 131 - 139 are reserved for FSRM.
//


#endif /* _WIN32_WINNT >= 0x0600 */


//
// The following long list of structs are associated with the preceeding
// file system fsctls.
//

//
// Structure for FSCTL_IS_PATHNAME_VALID
//

typedef struct _PATHNAME_BUFFER {

    ULONG PathNameLength;
    WCHAR Name[1];

} PATHNAME_BUFFER, *PPATHNAME_BUFFER;

//
// Structure for FSCTL_QUERY_BPB_INFO
//

typedef struct _FSCTL_QUERY_FAT_BPB_BUFFER {

    UCHAR First0x24BytesOfBootSector[0x24];

} FSCTL_QUERY_FAT_BPB_BUFFER, *PFSCTL_QUERY_FAT_BPB_BUFFER;

#if(_WIN32_WINNT >= 0x0400)
//
// Structures for FSCTL_GET_NTFS_VOLUME_DATA.
// The user must pass the basic buffer below.  Ntfs
// will return as many fields as available in the extended
// buffer which follows immediately after the VOLUME_DATA_BUFFER.
//

typedef struct {

    LARGE_INTEGER VolumeSerialNumber;
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER TotalClusters;
    LARGE_INTEGER FreeClusters;
    LARGE_INTEGER TotalReserved;
    ULONG BytesPerSector;
    ULONG BytesPerCluster;
    ULONG BytesPerFileRecordSegment;
    ULONG ClustersPerFileRecordSegment;
    LARGE_INTEGER MftValidDataLength;
    LARGE_INTEGER MftStartLcn;
    LARGE_INTEGER Mft2StartLcn;
    LARGE_INTEGER MftZoneStart;
    LARGE_INTEGER MftZoneEnd;

} NTFS_VOLUME_DATA_BUFFER, *PNTFS_VOLUME_DATA_BUFFER;

typedef struct {

    ULONG ByteCount;

    USHORT MajorVersion;
    USHORT MinorVersion;

} NTFS_EXTENDED_VOLUME_DATA, *PNTFS_EXTENDED_VOLUME_DATA;
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0400)
//
// Structure for FSCTL_GET_VOLUME_BITMAP
//

typedef struct {

    LARGE_INTEGER StartingLcn;

} STARTING_LCN_INPUT_BUFFER, *PSTARTING_LCN_INPUT_BUFFER;

typedef struct {

    LARGE_INTEGER StartingLcn;
    LARGE_INTEGER BitmapSize;
    UCHAR Buffer[1];

} VOLUME_BITMAP_BUFFER, *PVOLUME_BITMAP_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0400)
//
// Structure for FSCTL_GET_RETRIEVAL_POINTERS
//

typedef struct {

    LARGE_INTEGER StartingVcn;

} STARTING_VCN_INPUT_BUFFER, *PSTARTING_VCN_INPUT_BUFFER;

typedef struct RETRIEVAL_POINTERS_BUFFER {

    ULONG ExtentCount;
    LARGE_INTEGER StartingVcn;
    struct {
        LARGE_INTEGER NextVcn;
        LARGE_INTEGER Lcn;
    } Extents[1];

} RETRIEVAL_POINTERS_BUFFER, *PRETRIEVAL_POINTERS_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0400)
//
// Structures for FSCTL_GET_NTFS_FILE_RECORD
//

typedef struct {

    LARGE_INTEGER FileReferenceNumber;

} NTFS_FILE_RECORD_INPUT_BUFFER, *PNTFS_FILE_RECORD_INPUT_BUFFER;

typedef struct {

    LARGE_INTEGER FileReferenceNumber;
    ULONG FileRecordLength;
    UCHAR FileRecordBuffer[1];

} NTFS_FILE_RECORD_OUTPUT_BUFFER, *PNTFS_FILE_RECORD_OUTPUT_BUFFER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0400)
//
// Structure for FSCTL_MOVE_FILE
//

typedef struct {

    HANDLE FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    ULONG ClusterCount;

} MOVE_FILE_DATA, *PMOVE_FILE_DATA;

typedef struct {

    HANDLE FileHandle;
    LARGE_INTEGER SourceFileRecord;
    LARGE_INTEGER TargetFileRecord;

} MOVE_FILE_RECORD_DATA, *PMOVE_FILE_RECORD_DATA;


#if defined(_WIN64)
//
//  32/64 Bit thunking support structure
//

typedef struct _MOVE_FILE_DATA32 {

    UINT32 FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    ULONG ClusterCount;

} MOVE_FILE_DATA32, *PMOVE_FILE_DATA32;
#endif
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)
//
// Structures for FSCTL_FIND_FILES_BY_SID
//

typedef struct {
    ULONG Restart;
    SID Sid;
} FIND_BY_SID_DATA, *PFIND_BY_SID_DATA;

typedef struct {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FIND_BY_SID_OUTPUT, *PFIND_BY_SID_OUTPUT;

#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)
//
//  The following structures apply to Usn operations.
//

//
// Structure for FSCTL_ENUM_USN_DATA
//

typedef struct {

    ULONGLONG StartFileReferenceNumber;
    USN LowUsn;
    USN HighUsn;

} MFT_ENUM_DATA, *PMFT_ENUM_DATA;

//
// Structure for FSCTL_CREATE_USN_JOURNAL
//

typedef struct {

    ULONGLONG MaximumSize;
    ULONGLONG AllocationDelta;

} CREATE_USN_JOURNAL_DATA, *PCREATE_USN_JOURNAL_DATA;

//
// Structure for FSCTL_READ_USN_JOURNAL
//

typedef struct {

    USN StartUsn;
    ULONG ReasonMask;
    ULONG ReturnOnlyOnClose;
    ULONGLONG Timeout;
    ULONGLONG BytesToWaitFor;
    ULONGLONG UsnJournalID;

} READ_USN_JOURNAL_DATA, *PREAD_USN_JOURNAL_DATA;

//
//  The initial Major.Minor version of the Usn record will be 2.0.
//  In general, the MinorVersion may be changed if fields are added
//  to this structure in such a way that the previous version of the
//  software can still correctly the fields it knows about.  The
//  MajorVersion should only be changed if the previous version of
//  any software using this structure would incorrectly handle new
//  records due to structure changes.
//
//  The first update to this will force the structure to version 2.0.
//  This will add the extended information about the source as
//  well as indicate the file name offset within the structure.
//
//  The following structure is returned with these fsctls.
//
//      FSCTL_READ_USN_JOURNAL
//      FSCTL_READ_FILE_USN_DATA
//      FSCTL_ENUM_USN_DATA
//

typedef struct {

    ULONG RecordLength;
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONGLONG FileReferenceNumber;
    ULONGLONG ParentFileReferenceNumber;
    USN Usn;
    LARGE_INTEGER TimeStamp;
    ULONG Reason;
    ULONG SourceInfo;
    ULONG SecurityId;
    ULONG FileAttributes;
    USHORT FileNameLength;
    USHORT FileNameOffset;
    WCHAR FileName[1];

} USN_RECORD, *PUSN_RECORD;

#define USN_PAGE_SIZE                    (0x1000)

#define USN_REASON_DATA_OVERWRITE        (0x00000001)
#define USN_REASON_DATA_EXTEND           (0x00000002)
#define USN_REASON_DATA_TRUNCATION       (0x00000004)
#define USN_REASON_NAMED_DATA_OVERWRITE  (0x00000010)
#define USN_REASON_NAMED_DATA_EXTEND     (0x00000020)
#define USN_REASON_NAMED_DATA_TRUNCATION (0x00000040)
#define USN_REASON_FILE_CREATE           (0x00000100)
#define USN_REASON_FILE_DELETE           (0x00000200)
#define USN_REASON_EA_CHANGE             (0x00000400)
#define USN_REASON_SECURITY_CHANGE       (0x00000800)
#define USN_REASON_RENAME_OLD_NAME       (0x00001000)
#define USN_REASON_RENAME_NEW_NAME       (0x00002000)
#define USN_REASON_INDEXABLE_CHANGE      (0x00004000)
#define USN_REASON_BASIC_INFO_CHANGE     (0x00008000)
#define USN_REASON_HARD_LINK_CHANGE      (0x00010000)
#define USN_REASON_COMPRESSION_CHANGE    (0x00020000)
#define USN_REASON_ENCRYPTION_CHANGE     (0x00040000)
#define USN_REASON_OBJECT_ID_CHANGE      (0x00080000)
#define USN_REASON_REPARSE_POINT_CHANGE  (0x00100000)
#define USN_REASON_STREAM_CHANGE         (0x00200000)
#define USN_REASON_TRANSACTED_CHANGE     (0x00400000)
#define USN_REASON_CLOSE                 (0x80000000)

//
//  Structure for FSCTL_QUERY_USN_JOUNAL
//

typedef struct {

    ULONGLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    ULONGLONG MaximumSize;
    ULONGLONG AllocationDelta;

} USN_JOURNAL_DATA, *PUSN_JOURNAL_DATA;

//
//  Structure for FSCTL_DELETE_USN_JOURNAL
//

typedef struct {

    ULONGLONG UsnJournalID;
    ULONG DeleteFlags;

} DELETE_USN_JOURNAL_DATA, *PDELETE_USN_JOURNAL_DATA;

#define USN_DELETE_FLAG_DELETE              (0x00000001)
#define USN_DELETE_FLAG_NOTIFY              (0x00000002)

#define USN_DELETE_VALID_FLAGS              (0x00000003)

//
//  Structure for FSCTL_MARK_HANDLE
//

typedef struct {

    ULONG UsnSourceInfo;
    HANDLE VolumeHandle;
    ULONG HandleInfo;

} MARK_HANDLE_INFO, *PMARK_HANDLE_INFO;

#if defined(_WIN64)
//
//  32/64 Bit thunking support structure
//

typedef struct {

    ULONG UsnSourceInfo;
    UINT32 VolumeHandle;
    ULONG HandleInfo;

} MARK_HANDLE_INFO32, *PMARK_HANDLE_INFO32;
#endif

//
//  Flags for the additional source information above.
//
//      USN_SOURCE_DATA_MANAGEMENT - Service is not modifying the external view
//          of any part of the file.  Typical case is HSM moving data to
//          and from external storage.
//
//      USN_SOURCE_AUXILIARY_DATA - Service is not modifying the external view
//          of the file with regard to the application that created this file.
//          Can be used to add private data streams to a file.
//
//      USN_SOURCE_REPLICATION_MANAGEMENT - Service is modifying a file to match
//          the contents of the same file which exists in another member of the
//          replica set.
//

#define USN_SOURCE_DATA_MANAGEMENT          (0x00000001)
#define USN_SOURCE_AUXILIARY_DATA           (0x00000002)
#define USN_SOURCE_REPLICATION_MANAGEMENT   (0x00000004)

//
//  Flags for the HandleInfo field above
//
//  MARK_HANDLE_PROTECT_CLUSTERS - disallow any defragmenting (FSCTL_MOVE_FILE) until the
//      the handle is closed
//
//  MARK_HANDLE_TXF_SYSTEM_LOG - indicates that this stream is being used as the Txf
//      log for an RM on the volume.  Must be called in the kernel using
//      IRP_MN_KERNEL_CALL.
//
//  MARK_HANDLE_NOT_TXF_SYSTEM_LOG - indicates that this user is no longer using this
//      object as a log file.
//

#define MARK_HANDLE_PROTECT_CLUSTERS        (0x00000001)
#define MARK_HANDLE_TXF_SYSTEM_LOG          (0x00000004)
#define MARK_HANDLE_NOT_TXF_SYSTEM_LOG      (0x00000008)

#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)
//
// Structure for FSCTL_SECURITY_ID_CHECK
//

typedef struct {

    ACCESS_MASK DesiredAccess;
    ULONG SecurityIds[1];

} BULK_SECURITY_TEST_DATA, *PBULK_SECURITY_TEST_DATA;
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)
//
//  Output flags for the FSCTL_IS_VOLUME_DIRTY
//

#define VOLUME_IS_DIRTY                  (0x00000001)
#define VOLUME_UPGRADE_SCHEDULED         (0x00000002)
#define VOLUME_SESSION_OPEN              (0x00000004)
#endif /* _WIN32_WINNT >= 0x0500 */

//
// Structures for FSCTL_FILE_PREFETCH
//

typedef struct _FILE_PREFETCH {
    ULONG Type;
    ULONG Count;
    ULONGLONG Prefetch[1];
} FILE_PREFETCH, *PFILE_PREFETCH;

typedef struct _FILE_PREFETCH_EX {
    ULONG Type;
    ULONG Count;
    PVOID Context;
    ULONGLONG Prefetch[1];
} FILE_PREFETCH_EX, *PFILE_PREFETCH_EX;

#define FILE_PREFETCH_TYPE_FOR_CREATE       0x1
#define FILE_PREFETCH_TYPE_FOR_DIRENUM      0x2
#define FILE_PREFETCH_TYPE_FOR_CREATE_EX    0x3
#define FILE_PREFETCH_TYPE_FOR_DIRENUM_EX   0x4

#define FILE_PREFETCH_TYPE_MAX              0x4

//
// Structures for FSCTL_SET_VOLUME_COMPRESSION_STATE
//

typedef struct _VOLUME_COMPRESSION_STATE {
    BOOLEAN CompressNewFiles;
} VOLUME_COMPRESSION_STATE, *PVOLUME_COMPRESSION_STATE;

//
// Structures for FSCTL_FILESYSTEM_GET_STATISTICS
//
// Filesystem performance counters
//

typedef struct _FILESYSTEM_STATISTICS {

    USHORT FileSystemType;
    USHORT Version;                     // currently version 1

    ULONG SizeOfCompleteStructure;      // must by a mutiple of 64 bytes

    ULONG UserFileReads;
    ULONG UserFileReadBytes;
    ULONG UserDiskReads;
    ULONG UserFileWrites;
    ULONG UserFileWriteBytes;
    ULONG UserDiskWrites;

    ULONG MetaDataReads;
    ULONG MetaDataReadBytes;
    ULONG MetaDataDiskReads;
    ULONG MetaDataWrites;
    ULONG MetaDataWriteBytes;
    ULONG MetaDataDiskWrites;

    //
    //  The file system's private structure is appended here.
    //

} FILESYSTEM_STATISTICS, *PFILESYSTEM_STATISTICS;

// values for FS_STATISTICS.FileSystemType

#define FILESYSTEM_STATISTICS_TYPE_NTFS     1
#define FILESYSTEM_STATISTICS_TYPE_FAT      2
#define FILESYSTEM_STATISTICS_TYPE_EXFAT    3

//
//  File System Specific Statistics Data
//

typedef struct _FAT_STATISTICS {
    ULONG CreateHits;
    ULONG SuccessfulCreates;
    ULONG FailedCreates;

    ULONG NonCachedReads;
    ULONG NonCachedReadBytes;
    ULONG NonCachedWrites;
    ULONG NonCachedWriteBytes;

    ULONG NonCachedDiskReads;
    ULONG NonCachedDiskWrites;
} FAT_STATISTICS, *PFAT_STATISTICS;

typedef struct _EXFAT_STATISTICS {
    ULONG CreateHits;
    ULONG SuccessfulCreates;
    ULONG FailedCreates;

    ULONG NonCachedReads;
    ULONG NonCachedReadBytes;
    ULONG NonCachedWrites;
    ULONG NonCachedWriteBytes;

    ULONG NonCachedDiskReads;
    ULONG NonCachedDiskWrites;
} EXFAT_STATISTICS, *PEXFAT_STATISTICS;

typedef struct _NTFS_STATISTICS {

    ULONG LogFileFullExceptions;
    ULONG OtherExceptions;

    //
    // Other meta data io's
    //

    ULONG MftReads;
    ULONG MftReadBytes;
    ULONG MftWrites;
    ULONG MftWriteBytes;
    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } MftWritesUserLevel;

    USHORT MftWritesFlushForLogFileFull;
    USHORT MftWritesLazyWriter;
    USHORT MftWritesUserRequest;

    ULONG Mft2Writes;
    ULONG Mft2WriteBytes;
    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } Mft2WritesUserLevel;

    USHORT Mft2WritesFlushForLogFileFull;
    USHORT Mft2WritesLazyWriter;
    USHORT Mft2WritesUserRequest;

    ULONG RootIndexReads;
    ULONG RootIndexReadBytes;
    ULONG RootIndexWrites;
    ULONG RootIndexWriteBytes;

    ULONG BitmapReads;
    ULONG BitmapReadBytes;
    ULONG BitmapWrites;
    ULONG BitmapWriteBytes;

    USHORT BitmapWritesFlushForLogFileFull;
    USHORT BitmapWritesLazyWriter;
    USHORT BitmapWritesUserRequest;

    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
    } BitmapWritesUserLevel;

    ULONG MftBitmapReads;
    ULONG MftBitmapReadBytes;
    ULONG MftBitmapWrites;
    ULONG MftBitmapWriteBytes;

    USHORT MftBitmapWritesFlushForLogFileFull;
    USHORT MftBitmapWritesLazyWriter;
    USHORT MftBitmapWritesUserRequest;

    struct {
        USHORT Write;
        USHORT Create;
        USHORT SetInfo;
        USHORT Flush;
    } MftBitmapWritesUserLevel;

    ULONG UserIndexReads;
    ULONG UserIndexReadBytes;
    ULONG UserIndexWrites;
    ULONG UserIndexWriteBytes;

    //
    // Additions for NT 5.0
    //

    ULONG LogFileReads;
    ULONG LogFileReadBytes;
    ULONG LogFileWrites;
    ULONG LogFileWriteBytes;

    struct {
        ULONG Calls;                // number of individual calls to allocate clusters
        ULONG Clusters;             // number of clusters allocated
        ULONG Hints;                // number of times a hint was specified

        ULONG RunsReturned;         // number of runs used to satisify all the requests

        ULONG HintsHonored;         // number of times the hint was useful
        ULONG HintsClusters;        // number of clusters allocated via the hint
        ULONG Cache;                // number of times the cache was useful other than the hint
        ULONG CacheClusters;        // number of clusters allocated via the cache other than the hint
        ULONG CacheMiss;            // number of times the cache wasn't useful
        ULONG CacheMissClusters;    // number of clusters allocated without the cache
    } Allocate;

} NTFS_STATISTICS, *PNTFS_STATISTICS;

#if(_WIN32_WINNT >= 0x0500)
//
// Structure for FSCTL_SET_OBJECT_ID, FSCTL_GET_OBJECT_ID, and FSCTL_CREATE_OR_GET_OBJECT_ID
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)       // unnamed struct

typedef struct _FILE_OBJECTID_BUFFER {

    //
    //  This is the portion of the object id that is indexed.
    //

    UCHAR ObjectId[16];

    //
    //  This portion of the object id is not indexed, it's just
    //  some metadata for the user's benefit.
    //

    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        } DUMMYSTRUCTNAME;
        UCHAR ExtendedInfo[48];
    } DUMMYUNIONNAME;

} FILE_OBJECTID_BUFFER, *PFILE_OBJECTID_BUFFER;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) /* nonstandard extension used : nameless struct/union */
#endif

#endif /* _WIN32_WINNT >= 0x0500 */


#if(_WIN32_WINNT >= 0x0500)
//
// Structure for FSCTL_SET_SPARSE
//

typedef struct _FILE_SET_SPARSE_BUFFER {
    BOOLEAN SetSparse;
} FILE_SET_SPARSE_BUFFER, *PFILE_SET_SPARSE_BUFFER;


#endif /* _WIN32_WINNT >= 0x0500 */


#if(_WIN32_WINNT >= 0x0500)
//
// Structure for FSCTL_SET_ZERO_DATA
//

typedef struct _FILE_ZERO_DATA_INFORMATION {

    LARGE_INTEGER FileOffset;
    LARGE_INTEGER BeyondFinalZero;

} FILE_ZERO_DATA_INFORMATION, *PFILE_ZERO_DATA_INFORMATION;
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)
//
// Structure for FSCTL_QUERY_ALLOCATED_RANGES
//

//
// Querying the allocated ranges requires an output buffer to store the
// allocated ranges and an input buffer to specify the range to query.
// The input buffer contains a single entry, the output buffer is an
// array of the following structure.
//

typedef struct _FILE_ALLOCATED_RANGE_BUFFER {

    LARGE_INTEGER FileOffset;
    LARGE_INTEGER Length;

} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)
//
// Structures for FSCTL_SET_ENCRYPTION, FSCTL_WRITE_RAW_ENCRYPTED, and FSCTL_READ_RAW_ENCRYPTED
//

//
//  The input buffer to set encryption indicates whether we are to encrypt/decrypt a file
//  or an individual stream.
//

typedef struct _ENCRYPTION_BUFFER {

    ULONG EncryptionOperation;
    UCHAR Private[1];

} ENCRYPTION_BUFFER, *PENCRYPTION_BUFFER;

#define FILE_SET_ENCRYPTION         0x00000001
#define FILE_CLEAR_ENCRYPTION       0x00000002
#define STREAM_SET_ENCRYPTION       0x00000003
#define STREAM_CLEAR_ENCRYPTION     0x00000004

#define MAXIMUM_ENCRYPTION_VALUE    0x00000004

//
//  The optional output buffer to set encryption indicates that the last encrypted
//  stream in a file has been marked as decrypted.
//

typedef struct _DECRYPTION_STATUS_BUFFER {

    BOOLEAN NoEncryptedStreams;

} DECRYPTION_STATUS_BUFFER, *PDECRYPTION_STATUS_BUFFER;

#define ENCRYPTION_FORMAT_DEFAULT        (0x01)

#define COMPRESSION_FORMAT_SPARSE        (0x4000)

//
//  Request Encrypted Data structure.  This is used to indicate
//  the range of the file to read.  It also describes the
//  output buffer used to return the data.
//

typedef struct _REQUEST_RAW_ENCRYPTED_DATA {

    //
    //  Requested file offset and requested length to read.
    //  The fsctl will round the starting offset down
    //  to a file system boundary.  It will also
    //  round the length up to a file system boundary.
    //

    LONGLONG FileOffset;
    ULONG Length;

} REQUEST_RAW_ENCRYPTED_DATA, *PREQUEST_RAW_ENCRYPTED_DATA;

//
//  Encrypted Data Information structure.  This structure
//  is used to return raw encrypted data from a file in
//  order to perform off-line recovery.  The data will be
//  encrypted or encrypted and compressed.  The off-line
//  service will need to use the encryption and compression
//  format information to recover the file data.  In the
//  event that the data is both encrypted and compressed then
//  the decryption must occur before decompression.  All
//  the data units below must be encrypted and compressed
//  with the same format.
//
//  The data will be returned in units.  The data unit size
//  will be fixed per request.  If the data is compressed
//  then the data unit size will be the compression unit size.
//
//  This structure is at the beginning of the buffer used to
//  return the encrypted data.  The actual raw bytes from
//  the file will follow this buffer.  The offset of the
//  raw bytes from the beginning of this structure is
//  specified in the REQUEST_RAW_ENCRYPTED_DATA structure
//  described above.
//

typedef struct _ENCRYPTED_DATA_INFO {

    //
    //  This is the file offset for the first entry in the
    //  data block array.  The file system will round
    //  the requested start offset down to a boundary
    //  that is consistent with the format of the file.
    //

    ULONGLONG StartingFileOffset;

    //
    //  Data offset in output buffer.  The output buffer
    //  begins with an ENCRYPTED_DATA_INFO structure.
    //  The file system will then store the raw bytes from
    //  disk beginning at the following offset within the
    //  output buffer.
    //

    ULONG OutputBufferOffset;

    //
    //  The number of bytes being returned that are within
    //  the size of the file.  If this value is less than
    //  (NumberOfDataBlocks << DataUnitShift), it means the
    //  end of the file occurs within this transfer.  Any
    //  data beyond file size is invalid and was never
    //  passed to the encryption driver.
    //

    ULONG BytesWithinFileSize;

    //
    //  The number of bytes being returned that are below
    //  valid data length.  If this value is less than
    //  (NumberOfDataBlocks << DataUnitShift), it means the
    //  end of the valid data occurs within this transfer.
    //  After decrypting the data from this transfer, any
    //  byte(s) beyond valid data length must be zeroed.
    //

    ULONG BytesWithinValidDataLength;

    //
    //  Code for the compression format as defined in
    //  ntrtl.h.  Note that COMPRESSION_FORMAT_NONE
    //  and COMPRESSION_FORMAT_DEFAULT are invalid if
    //  any of the described chunks are compressed.
    //

    USHORT CompressionFormat;

    //
    //  The DataUnit is the granularity used to access the
    //  disk.  It will be the same as the compression unit
    //  size for a compressed file.  For an uncompressed
    //  file, it will be some cluster-aligned power of 2 that
    //  the file system deems convenient.  A caller should
    //  not expect that successive calls will have the
    //  same data unit shift value as the previous call.
    //
    //  Since chunks and compression units are expected to be
    //  powers of 2 in size, we express them log2.  So, for
    //  example (1 << ChunkShift) == ChunkSizeInBytes.  The
    //  ClusterShift indicates how much space must be saved
    //  to successfully compress a compression unit - each
    //  successfully compressed data unit must occupy
    //  at least one cluster less in bytes than an uncompressed
    //  data block unit.
    //

    UCHAR DataUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;

    //
    //  The format for the encryption.
    //

    UCHAR EncryptionFormat;

    //
    //  This is the number of entries in the data block size
    //  array.
    //

    USHORT NumberOfDataBlocks;

    //
    //  This is an array of sizes in the data block array.  There
    //  must be one entry in this array for each data block
    //  read from disk.  The size has a different meaning
    //  depending on whether the file is compressed.
    //
    //  A size of zero always indicates that the final data consists entirely
    //  of zeroes.  There is no decryption or decompression to
    //  perform.
    //
    //  If the file is compressed then the data block size indicates
    //  whether this block is compressed.  A size equal to
    //  the block size indicates that the corresponding block did
    //  not compress.  Any other non-zero size indicates the
    //  size of the compressed data which needs to be
    //  decrypted/decompressed.
    //
    //  If the file is not compressed then the data block size
    //  indicates the amount of data within the block that
    //  needs to be decrypted.  Any other non-zero size indicates
    //  that the remaining bytes in the data unit within the file
    //  consists of zeros.  An example of this is when the
    //  the read spans the valid data length of the file.  There
    //  is no data to decrypt past the valid data length.
    //

    ULONG DataBlockSize[ANYSIZE_ARRAY];

} ENCRYPTED_DATA_INFO;
typedef ENCRYPTED_DATA_INFO *PENCRYPTED_DATA_INFO;
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)
//
//  FSCTL_READ_FROM_PLEX support
//  Request Plex Read Data structure.  This is used to indicate
//  the range of the file to read.  It also describes
//  which plex to perform the read from.
//

typedef struct _PLEX_READ_DATA_REQUEST {

    //
    //  Requested offset and length to read.
    //  The offset can be the virtual offset (vbo) in to a file,
    //  or a volume. In the case of a file offset,
    //  the fsd will round the starting offset down
    //  to a file system boundary.  It will also
    //  round the length up to a file system boundary and
    //  enforce any other applicable limits.
    //

    LARGE_INTEGER ByteOffset;
    ULONG ByteLength;
    ULONG PlexNumber;

} PLEX_READ_DATA_REQUEST, *PPLEX_READ_DATA_REQUEST;
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)
//
// FSCTL_SIS_COPYFILE support
// Source and destination file names are passed in the FileNameBuffer.
// Both strings are null terminated, with the source name starting at
// the beginning of FileNameBuffer, and the destination name immediately
// following.  Length fields include terminating nulls.
//

typedef struct _SI_COPYFILE {
    ULONG SourceFileNameLength;
    ULONG DestinationFileNameLength;
    ULONG Flags;
    WCHAR FileNameBuffer[1];
} SI_COPYFILE, *PSI_COPYFILE;

#define COPYFILE_SIS_LINK       0x0001              // Copy only if source is SIS
#define COPYFILE_SIS_REPLACE    0x0002              // Replace destination if it exists, otherwise don't.
#define COPYFILE_SIS_FLAGS      0x0003
#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0600)
//
//  Input parameter structure for FSCTL_MAKE_COMPATIBLE
//

typedef struct _FILE_MAKE_COMPATIBLE_BUFFER {
    BOOLEAN CloseDisc;
} FILE_MAKE_COMPATIBLE_BUFFER, *PFILE_MAKE_COMPATIBLE_BUFFER;

//
//  Input parameter structure for FSCTL_SET_DEFECT_MANAGEMENT
//

typedef struct _FILE_SET_DEFECT_MGMT_BUFFER {
    BOOLEAN Disable;
} FILE_SET_DEFECT_MGMT_BUFFER, *PFILE_SET_DEFECT_MGMT_BUFFER;

//
//  Output structure for FSCTL_QUERY_SPARING_INFO
//

typedef struct _FILE_QUERY_SPARING_BUFFER {
    ULONG SparingUnitBytes;
    BOOLEAN SoftwareSparing;
    ULONG TotalSpareBlocks;
    ULONG FreeSpareBlocks;
} FILE_QUERY_SPARING_BUFFER, *PFILE_QUERY_SPARING_BUFFER;

//
//  Output structure for FSCTL_QUERY_ON_DISK_VOLUME_INFO
//

typedef struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    LARGE_INTEGER DirectoryCount;       // -1 = unknown
    LARGE_INTEGER FileCount;            // -1 = unknown
    USHORT FsFormatMajVersion;          // -1 = unknown or n/a
    USHORT FsFormatMinVersion;          // -1 = unknown or n/a
    WCHAR FsFormatName[ 12];
    LARGE_INTEGER FormatTime;
    LARGE_INTEGER LastUpdateTime;
    WCHAR CopyrightInfo[ 34];
    WCHAR AbstractInfo[ 34];
    WCHAR FormattingImplementationInfo[ 34];
    WCHAR LastModifyingImplementationInfo[ 34];
} FILE_QUERY_ON_DISK_VOL_INFO_BUFFER, *PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER;

//
//  Input flags for FSCTL_SET_REPAIR
//

#define SET_REPAIR_ENABLED                                      (0x00000001)
#define SET_REPAIR_VOLUME_BITMAP_SCAN                           (0x00000002)
#define SET_REPAIR_DELETE_CROSSLINK                             (0x00000004)
#define SET_REPAIR_WARN_ABOUT_DATA_LOSS                         (0x00000008)
#define SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT             (0x00000010)
#define SET_REPAIR_VALID_MASK                                   (0x0000001F)

//
//  Input structures for FSCTL_SHRINK_VOLUME.
//

typedef enum _SHRINK_VOLUME_REQUEST_TYPES
{
    ShrinkPrepare = 1,
    ShrinkCommit,
    ShrinkAbort

} SHRINK_VOLUME_REQUEST_TYPES, *PSHRINK_VOLUME_REQUEST_TYPES;

#define SHRINK_VOLUME_FLAG_FAIL_ON_BAD_CLUSTERS                (0x00000001)

typedef struct _SHRINK_VOLUME_INFORMATION
{
    SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
    ULONGLONG Flags;
    LONGLONG NewNumberOfSectors;

} SHRINK_VOLUME_INFORMATION, *PSHRINK_VOLUME_INFORMATION;

//
//  Structures for FSCTL_TXFS_MODIFY_RM and FSCTL_TXFS_QUERY_RM_INFORMATION
//
//  For ModifyRM, TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS and
//  TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT are mutually exclusive.
//  You can specify the log growth amount in number of containers or as a percentage.
//
//  For ModifyRM, TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX and
//  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX are mutually exclusive.
//
//  For ModifyRM, TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN and
//  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN are mutually exclusive.
//
//  For ModifyRM, TXFS_RM_FLAG_RESET_RM_AT_NEXT_START and
//  TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START are mutually exclusive and only
//  apply to default RMs.
//
//  For ModifyRM, TXFS_RM_FLAG_PREFER_CONSISTENCY and 
//  TXFS_RM_FLAG_PREFER_AVAILABILITY are mutually exclusive.  After calling ModifyRM
//  with one of these flags set the RM must be restarted for the change to take effect.
//

#define TXFS_RM_FLAG_LOGGING_MODE                           0x00000001
#define TXFS_RM_FLAG_RENAME_RM                              0x00000002
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX                0x00000004
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN                0x00000008
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS    0x00000010
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT           0x00000020
#define TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE             0x00000040
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX             0x00000080
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN             0x00000100
#define TXFS_RM_FLAG_GROW_LOG                               0x00000400
#define TXFS_RM_FLAG_SHRINK_LOG                             0x00000800
#define TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                   0x00001000
#define TXFS_RM_FLAG_PRESERVE_CHANGES                       0x00002000
#define TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                 0x00004000
#define TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START          0x00008000
#define TXFS_RM_FLAG_PREFER_CONSISTENCY                     0x00010000
#define TXFS_RM_FLAG_PREFER_AVAILABILITY                    0x00020000

#define TXFS_LOGGING_MODE_SIMPLE        (0x0001)
#define TXFS_LOGGING_MODE_FULL          (0x0002)

#define TXFS_TRANSACTION_STATE_NONE         0x00
#define TXFS_TRANSACTION_STATE_ACTIVE       0x01
#define TXFS_TRANSACTION_STATE_PREPARED     0x02
#define TXFS_TRANSACTION_STATE_NOTACTIVE    0x03

#define TXFS_MODIFY_RM_VALID_FLAGS                                      \
                (TXFS_RM_FLAG_LOGGING_MODE                          |   \
                 TXFS_RM_FLAG_RENAME_RM                             |   \
                 TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX               |   \
                 TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN               |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS   |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT          |   \
                 TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN            |   \
                 TXFS_RM_FLAG_SHRINK_LOG                            |   \
                 TXFS_RM_FLAG_GROW_LOG                              |   \
                 TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                  |   \
                 TXFS_RM_FLAG_PRESERVE_CHANGES                      |   \
                 TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                |   \
                 TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START         |   \
                 TXFS_RM_FLAG_PREFER_CONSISTENCY                    |   \
                 TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_MODIFY_RM {

    //
    //  TXFS_RM_FLAG_* flags
    //

    ULONG Flags;

    //
    //  Maximum log container count if TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX is set.
    //

    ULONG LogContainerCountMax;

    //
    //  Minimum log container count if TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN is set.
    //

    ULONG LogContainerCountMin;

    //
    //  Target log container count for TXFS_RM_FLAG_SHRINK_LOG or _GROW_LOG.
    //

    ULONG LogContainerCount;

    //
    //  When the log is full, increase its size by this much.  Indicated as either a percent of
    //  the log size or absolute container count, depending on which of the TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_*
    //  flags is set.
    //

    ULONG LogGrowthIncrement;

    //
    //  Sets autoshrink policy if TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE is set.  Autoshrink
    //  makes the log shrink so that no more than this percentage of the log is free at any time.
    //

    ULONG LogAutoShrinkPercentage;

    //
    //  Reserved.
    //

    ULONGLONG Reserved;

    //
    //  If TXFS_RM_FLAG_LOGGING_MODE is set, this must contain one of TXFS_LOGGING_MODE_SIMPLE
    //  or TXFS_LOGGING_MODE_FULL.
    //

    USHORT LoggingMode;

} TXFS_MODIFY_RM,
 *PTXFS_MODIFY_RM;

#define TXFS_RM_STATE_NOT_STARTED       0
#define TXFS_RM_STATE_STARTING          1
#define TXFS_RM_STATE_ACTIVE            2
#define TXFS_RM_STATE_SHUTTING_DOWN     3

//
//  The flags field for query RM information is used for the following information:
//
//  1)  To indicate whether the LogGrowthIncrement field is reported as a percent
//      or as a number of containers.  Possible flag values for this are:
//
//      TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS xor TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT
//
//  2)  To indicate that there is no set maximum or minimum container count.  Possible
//      flag values for this are:
//
//      TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX
//      TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN
//
//      Note that these flags are not mutually exclusive.
//
//  2)  To report whether the RM will be reset the next time it is started.  Note that
//      only the default RM will report a meaningful value (secondary RMs will always
//      report DO_NOT_RESET) Possible flag values for this are:
//
//      TXFS_RM_FLAG_RESET_RM_AT_NEXT_START xor TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START
//
//  3)  To report whether the RM is in consistency mode or availability mode.  Possible
//      flag values for this are:
//
//      TXFS_RM_FLAG_PREFER_CONSISTENCY xor TXFS_RM_FLAG_PREFER_AVAILABILITY
//
//  The RmState field can have exactly one of the above-defined TXF_RM_STATE_ values.
//

#define TXFS_QUERY_RM_INFORMATION_VALID_FLAGS                           \
                (TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS   |   \
                 TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT          |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX            |   \
                 TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN            |   \
                 TXFS_RM_FLAG_RESET_RM_AT_NEXT_START                |   \
                 TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START         |   \
                 TXFS_RM_FLAG_PREFER_CONSISTENCY                    |   \
                 TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_QUERY_RM_INFORMATION {

    //
    //  If the return value is STATUS_BUFFER_OVERFLOW (ERROR_MORE_DATA), this
    //  will indicate how much space is required to hold everything.
    //

    ULONG BytesRequired;

    //
    //  LSN of earliest available record in the RM's log.
    //

    ULONGLONG TailLsn;

    //
    //  LSN of most recently-written record in the RM's log.
    //

    ULONGLONG CurrentLsn;

    //
    //  LSN of the log's archive tail.
    //

    ULONGLONG ArchiveTailLsn;

    //
    //  Size of a log container in bytes.
    //

    ULONGLONG LogContainerSize;

    //
    //  Highest virtual clock value recorded in this RM's log.
    //

    LARGE_INTEGER HighestVirtualClock;

    //
    //  Number of containers in this RM's log.
    //

    ULONG LogContainerCount;

    //
    //  Maximum-allowed log container count.
    //

    ULONG LogContainerCountMax;

    //
    //  Minimum-allowed log container count.
    //

    ULONG LogContainerCountMin;

    //
    //  Amount by which log will grow when it gets full.  Indicated as either a percent of
    //  the log size or absolute container count, depending on which of the TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_*
    //  flags is set.
    //

    ULONG LogGrowthIncrement;

    //
    //  Reports on the autoshrink policy if.  Autoshrink makes the log shrink so that no more than this
    //  percentage of the log is free at any time.  A value of 0 indicates that autoshrink is off (i.e.
    //  the log will not automatically shrink).
    //

    ULONG LogAutoShrinkPercentage;

    //
    //  TXFS_RM_FLAG_* flags.  See the comment above at TXFS_QUERY_RM_INFORMATION_VALID_FLAGS to see
    //  what the flags here mean.
    //

    ULONG Flags;

    //
    //  Exactly one of TXFS_LOGGING_MODE_SIMPLE or TXFS_LOGGING_MODE_FULL.
    //

    USHORT LoggingMode;

    //
    //  Reserved.
    //

    USHORT Reserved;

    //
    //  Activity state of the RM.  May be exactly one of the above-defined TXF_RM_STATE_ values.
    //

    ULONG RmState;

    //
    //  Total capacity of the log in bytes.
    //

    ULONGLONG LogCapacity;

    //
    //  Amount of free space in the log in bytes.
    //

    ULONGLONG LogFree;

    //
    //  Size of $Tops in bytes.
    //

    ULONGLONG TopsSize;

    //
    //  Amount of space in $Tops in use.
    //

    ULONGLONG TopsUsed;

    //
    //  Number of transactions active in the RM at the time of the call.
    //

    ULONGLONG TransactionCount;

    //
    //  Total number of single-phase commits that have happened the RM.
    //

    ULONGLONG OnePCCount;

    //
    //  Total number of two-phase commits that have happened the RM.
    //

    ULONGLONG TwoPCCount;

    //
    //  Number of times the log has filled up.
    //

    ULONGLONG NumberLogFileFull;

    //
    //  Age of oldest active transaction in the RM, in milliseconds.
    //

    ULONGLONG OldestTransactionAge;

    //
    //  Name of the RM.
    //

    GUID RMName;

    //
    //  Offset in bytes from the beginning of this structure to a NULL-terminated Unicode
    //  string indicating the path to the RM's transaction manager's log.
    //

    ULONG TmLogPathOffset;

} TXFS_QUERY_RM_INFORMATION,
 *PTXFS_QUERY_RM_INFORMATION;

//
// Structures for FSCTL_TXFS_ROLLFORWARD_REDO
//

#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN        0x01
#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK   0x02

#define TXFS_ROLLFORWARD_REDO_VALID_FLAGS                               \
                (TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN |         \
                 TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK)

typedef struct _TXFS_ROLLFORWARD_REDO_INFORMATION {
    LARGE_INTEGER  LastVirtualClock;
    ULONGLONG LastRedoLsn;
    ULONGLONG HighestRecoveryLsn;
    ULONG Flags;
} TXFS_ROLLFORWARD_REDO_INFORMATION,
 *PTXFS_ROLLFORWARD_REDO_INFORMATION;

//
//  Structures for FSCTL_TXFS_START_RM
//
//  Note that TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS and
//  TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT are mutually exclusive.
//  You can specify the log growth amount in number of containers or as a percentage.
//
//  TXFS_START_RM_FLAG_CONTAINER_COUNT_MAX and TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX
//  are mutually exclusive.
//
//  TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN and TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN
//  are mutually exclusive.
//
//  TXFS_START_RM_FLAG_PREFER_CONSISTENCY and TXFS_START_RM_FLAG_PREFER_AVAILABILITY
//  are mutually exclusive.
//
//  Optional parameters will have system-supplied defaults applied if omitted.
//

#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX              0x00000001
#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN              0x00000002
#define TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                   0x00000004
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS  0x00000008
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT         0x00000010
#define TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE           0x00000020
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX           0x00000040
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN           0x00000080

#define TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                  0x00000200
#define TXFS_START_RM_FLAG_LOGGING_MODE                         0x00000400
#define TXFS_START_RM_FLAG_PRESERVE_CHANGES                     0x00000800

#define TXFS_START_RM_FLAG_PREFER_CONSISTENCY                   0x00001000
#define TXFS_START_RM_FLAG_PREFER_AVAILABILITY                  0x00002000

#define TXFS_START_RM_VALID_FLAGS                                           \
                (TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX             |   \
                 TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN             |   \
                 TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                  |   \
                 TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |   \
                 TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT        |   \
                 TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE          |   \
                 TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                 |   \
                 TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX          |   \
                 TXFS_START_RM_FLAG_LOGGING_MODE                        |   \
                 TXFS_START_RM_FLAG_PRESERVE_CHANGES                    |   \
                 TXFS_START_RM_FLAG_PREFER_CONSISTENCY                  |   \
                 TXFS_START_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_START_RM_INFORMATION {

    //
    //  TXFS_START_RM_FLAG_* flags.
    //

    ULONG Flags;

    //
    //  RM log container size, in bytes.  This parameter is optional.
    //

    ULONGLONG LogContainerSize;

    //
    //  RM minimum log container count.  This parameter is optional.
    //

    ULONG LogContainerCountMin;

    //
    //  RM maximum log container count.  This parameter is optional.
    //

    ULONG LogContainerCountMax;

    //
    //  RM log growth increment in number of containers or percent, as indicated
    //  by TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_* flag.  This parameter is
    //  optional.
    //

    ULONG LogGrowthIncrement;

    //
    //  RM log auto shrink percentage.  This parameter is optional.
    //

    ULONG LogAutoShrinkPercentage;

    //
    //  Offset from the beginning of this structure to the log path for the KTM
    //  instance to be used by this RM.  This must be a two-byte (WCHAR) aligned
    //  value.  This parameter is required.
    //

    ULONG TmLogPathOffset;

    //
    //  Length in bytes of log path for the KTM instance to be used by this RM.
    //  This parameter is required.
    //

    USHORT TmLogPathLength;

    //
    //  Logging mode for this RM.  One of TXFS_LOGGING_MODE_SIMPLE or
    //  TXFS_LOGGING_MODE_FULL (mutually exclusive).  This parameter is optional,
    //  and will default to TXFS_LOGGING_MODE_SIMPLE.
    //

    USHORT LoggingMode;

    //
    //  Length in bytes of the path to the log to be used by the RM.  This parameter
    //  is required.
    //

    USHORT LogPathLength;

    //
    //  Reserved.
    //

    USHORT Reserved;

    //
    //  The path to the log (in Unicode characters) to be used by the RM goes here.
    //  This parameter is required.
    //

    WCHAR LogPath[1];

} TXFS_START_RM_INFORMATION,
 *PTXFS_START_RM_INFORMATION;

//
//  Structures for FSCTL_TXFS_GET_METADATA_INFO
//

typedef struct _TXFS_GET_METADATA_INFO_OUT {

    //
    //  Returns the TxfId of the file referenced by the handle used to call this routine.
    //

    struct {
        LONGLONG LowPart;
        LONGLONG HighPart;
    } TxfFileId;

    //
    //  The GUID of the transaction that has the file locked, if applicable.
    //

    GUID LockingTransaction;

    //
    //  Returns the LSN for the most recent log record we've written for the file.
    //

    ULONGLONG LastLsn;

    //
    //  Transaction state, a TXFS_TRANSACTION_STATE_* value.
    //

    ULONG TransactionState;

} TXFS_GET_METADATA_INFO_OUT, *PTXFS_GET_METADATA_INFO_OUT;

//
//  Structures for FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES
//

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {

    //
    //  Offset in bytes from the beginning of the TXFS_LIST_TRANSACTION_LOCKED_FILES
    //  structure to the next TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY.
    //

    ULONGLONG Offset;

    //
    //  USN Reason flags: what the transaction did to this file.
    //

    ULONG UsnReason;

    //
    //  NTFS File ID of the file.
    //

    LONGLONG FileId;

    //
    //  Reserved.
    //

    ULONG Reserved1;
    ULONG Reserved2;
    LONGLONG Reserved3;

    //
    //  NULL-terminated Unicode path to this file, relative to RM root.
    //

    WCHAR FileName[1];
} TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY, *PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;


typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES {

    //
    //  GUID name of the KTM transaction that files should be enumerated from.
    //

    GUID KtmTransaction;

    //
    //  On output, the number of files involved in the transaction on this RM.
    //

    ULONGLONG NumberOfFiles;

    //
    //  The length of the buffer required to obtain the complete list of files.
    //  This value may change from call to call as the transaction locks more files.
    //

    ULONGLONG BufferSizeRequired;

    //
    //  Offset in bytes from the beginning of this structure to the first
    //  TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY.
    //

    ULONGLONG Offset;
} TXFS_LIST_TRANSACTION_LOCKED_FILES, *PTXFS_LIST_TRANSACTION_LOCKED_FILES;

//
//  Structures for FSCTL_TXFS_LIST_TRANSACTIONS
//

typedef struct _TXFS_LIST_TRANSACTIONS_ENTRY {

    //
    //  Transaction GUID.
    //

    GUID TransactionId;

    //
    //  Transaction state, a TXFS_TRANSACTION_STATE_* value.
    //

    ULONG TransactionState;

    //
    //  Reserved fields
    //

    ULONG Reserved1;
    ULONG Reserved2;
    LONGLONG Reserved3;
} TXFS_LIST_TRANSACTIONS_ENTRY, *PTXFS_LIST_TRANSACTIONS_ENTRY;

typedef struct _TXFS_LIST_TRANSACTIONS {

    //
    //  On output, the number of transactions involved in this RM.
    //

    ULONGLONG NumberOfTransactions;

    //
    //  The length of the buffer required to obtain the complete list of
    //  transactions.  Note that this value may change from call to call
    //  as transactions enter and exit the system.
    //

    ULONGLONG BufferSizeRequired;
} TXFS_LIST_TRANSACTIONS, *PTXFS_LIST_TRANSACTIONS;


//
//  Structures for FSCTL_TXFS_READ_BACKUP_INFORMATION
//

typedef struct _TXFS_READ_BACKUP_INFORMATION_OUT {
    union {

        //
        //  Used to return the required buffer size if return code is STATUS_BUFFER_OVERFLOW
        //

        ULONG BufferLength;

        //
        //  On success the data is copied here.
        //

        UCHAR Buffer[1];
    } DUMMYUNIONNAME;
} TXFS_READ_BACKUP_INFORMATION_OUT, *PTXFS_READ_BACKUP_INFORMATION_OUT;

//
//  Structures for FSCTL_TXFS_WRITE_BACKUP_INFORMATION
//

typedef struct _TXFS_WRITE_BACKUP_INFORMATION {

    //
    //  The data returned in the Buffer member of a previous call to
    //  FSCTL_TXFS_READ_BACKUP_INFORMATION goes here.
    //

    UCHAR Buffer[1];
} TXFS_WRITE_BACKUP_INFORMATION, *PTXFS_WRITE_BACKUP_INFORMATION;

//
//  Output structure for FSCTL_TXFS_GET_TRANSACTED_VERSION
//

#define TXFS_TRANSACTED_VERSION_NONTRANSACTED   0xFFFFFFFE
#define TXFS_TRANSACTED_VERSION_UNCOMMITTED     0xFFFFFFFF

typedef struct _TXFS_GET_TRANSACTED_VERSION {

    //
    //  The version that this handle is opened to.  This will be
    //  TXFS_TRANSACTED_VERSION_UNCOMMITTED for nontransacted and
    //  transactional writer handles.
    //

    ULONG ThisBaseVersion;

    //
    //  The most recent committed version available.
    //

    ULONG LatestVersion;

    //
    //  If this is a handle to a miniversion, the ID of the miniversion.
    //  If it is not a handle to a minivers, this field will be 0.
    //

    USHORT ThisMiniVersion;

    //
    //  The first available miniversion.  Unless the miniversions are
    //  visible to the transaction bound to this handle, this field will be zero.
    //

    USHORT FirstMiniVersion;

    //
    //  The latest available miniversion.  Unless the miniversions are
    //  visible to the transaction bound to this handle, this field will be zero.
    //

    USHORT LatestMiniVersion;

} TXFS_GET_TRANSACTED_VERSION, *PTXFS_GET_TRANSACTED_VERSION;

//
//  Structures for FSCTL_TXFS_SAVEPOINT_INFORMATION
//
//  Note that the TXFS_SAVEPOINT_INFORMATION structure is both and in and out structure.
//  The KtmTransaction and ActionCode members are always in-parameters, and the SavepointId
//  member is either an in-parameter, an out-parameter, or not used (see its definition below).
//

//
//  Create a new savepoint.
//

#define TXFS_SAVEPOINT_SET                      0x00000001

//
//  Roll back to a specified savepoint.
//

#define TXFS_SAVEPOINT_ROLLBACK                 0x00000002

//
//  Clear (make unavailable for rollback) the most recently set savepoint
//  that has not yet been cleared.
//

#define TXFS_SAVEPOINT_CLEAR                    0x00000004

//
//  Clear all savepoints from the transaction.
//

#define TXFS_SAVEPOINT_CLEAR_ALL                0x00000010

typedef struct _TXFS_SAVEPOINT_INFORMATION {

    //
    //  Handle to the transaction on which to perform the savepoint operation.
    //

    HANDLE KtmTransaction;

    //
    //  Specifies the savepoint action to take.  A TXFS_SAVEPOINT_* value.
    //

    ULONG ActionCode;

    //
    //  In-parameter for TXFS_ROLLBACK_TO_SAVEPOINT - specifies the savepoint to which
    //  to roll back.
    //
    //  Out-parameter for TXFS_SET_SAVEPOINT - the newly-created savepoint ID will be
    //  returned here.
    //
    //  Not used for TXFS_CLEAR_SAVEPOINT or TXFS_CLEAR_ALL_SAVEPOINTS.
    //

    ULONG SavepointId;

} TXFS_SAVEPOINT_INFORMATION, *PTXFS_SAVEPOINT_INFORMATION;

//
//  Structures for FSCTL_TXFS_CREATE_MINIVERSION
//
//      Only an out parameter is necessary.  That returns the identifier of the new miniversion created.
//

typedef struct _TXFS_CREATE_MINIVERSION_INFO {

    USHORT StructureVersion;

    USHORT StructureLength;

    //
    //  The base version for the newly created miniversion.
    //

    ULONG BaseVersion;

    //
    //  The miniversion that was just created.
    //

    USHORT MiniVersion;

} TXFS_CREATE_MINIVERSION_INFO, *PTXFS_CREATE_MINIVERSION_INFO;

//
//  Structure for FSCTL_TXFS_TRANSACTION_ACTIVE
//

typedef struct _TXFS_TRANSACTION_ACTIVE_INFO {

    //
    //  Whether or not the volume had active transactions when this snapshot was taken.
    //

    BOOLEAN TransactionsActiveAtSnapshot;

} TXFS_TRANSACTION_ACTIVE_INFO, *PTXFS_TRANSACTION_ACTIVE_INFO;

#endif /* _WIN32_WINNT >= 0x0600 */

#endif // _FILESYSTEMFSCTL_

// end_winioctl

//
// Structures for FSCTL_SET_REPARSE_POINT, FSCTL_GET_REPARSE_POINT, and FSCTL_DELETE_REPARSE_POINT
//

//
// The reparse structure is used by layered drivers to store data in a
// reparse point. The constraints on reparse tags are defined below.
// This version of the reparse data buffer is only for Microsoft tags.
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)       // unnamed struct

#define SYMLINK_FLAG_RELATIVE   1

typedef struct _REPARSE_DATA_BUFFER {
    ULONG  ReparseTag;
    USHORT ReparseDataLength;
    USHORT Reserved;
    union {
        struct {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            ULONG Flags;
            WCHAR PathBuffer[1];
        } SymbolicLinkReparseBuffer;
        struct {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            WCHAR PathBuffer[1];
        } MountPointReparseBuffer;
        struct {
            UCHAR  DataBuffer[1];
        } GenericReparseBuffer;
    } DUMMYUNIONNAME;
} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 )
#endif

#define REPARSE_DATA_BUFFER_HEADER_SIZE   FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)


// begin_winnt
//
// The reparse GUID structure is used by all 3rd party layered drivers to
// store data in a reparse point. For non-Microsoft tags, The GUID field
// cannot be GUID_NULL.
// The constraints on reparse tags are defined below.
// Microsoft tags can also be used with this format of the reparse point buffer.
//

typedef struct _REPARSE_GUID_DATA_BUFFER {
    ULONG  ReparseTag;
    USHORT ReparseDataLength;
    USHORT Reserved;
    GUID   ReparseGuid;
    struct {
        UCHAR  DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;

#define REPARSE_GUID_DATA_BUFFER_HEADER_SIZE   FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer)



//
// Maximum allowed size of the reparse data.
//

#define MAXIMUM_REPARSE_DATA_BUFFER_SIZE      ( 16 * 1024 )

//
// Predefined reparse tags.
// These tags need to avoid conflicting with IO_REMOUNT defined in ntos\inc\io.h
//

#define IO_REPARSE_TAG_RESERVED_ZERO             (0)
#define IO_REPARSE_TAG_RESERVED_ONE              (1)

//
// The value of the following constant needs to satisfy the following conditions:
//  (1) Be at least as large as the largest of the reserved tags.
//  (2) Be strictly smaller than all the tags in use.
//

#define IO_REPARSE_TAG_RESERVED_RANGE            IO_REPARSE_TAG_RESERVED_ONE

//
// The reparse tags are a ULONG. The 32 bits are laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-----------------------+-------------------------------+
//  |M|R|N|R|     Reserved bits     |       Reparse Tag Value       |
//  +-+-+-+-+-----------------------+-------------------------------+
//
// M is the Microsoft bit. When set to 1, it denotes a tag owned by Microsoft.
//   All ISVs must use a tag with a 0 in this position.
//   Note: If a Microsoft tag is used by non-Microsoft software, the
//   behavior is not defined.
//
// R is reserved.  Must be zero for non-Microsoft tags.
//
// N is name surrogate. When set to 1, the file represents another named
//   entity in the system.
//
// The M and N bits are OR-able.
// The following macros check for the M and N bit values:
//

//
// Macro to determine whether a reparse point tag corresponds to a tag
// owned by Microsoft.
//

#define IsReparseTagMicrosoft(_tag) (              \
                           ((_tag) & 0x80000000)   \
                           )

//
// Macro to determine whether a reparse point tag is a name surrogate
//

#define IsReparseTagNameSurrogate(_tag) (          \
                           ((_tag) & 0x20000000)   \
                           )

// end_winnt

//
// The following constant represents the bits that are valid to use in
// reparse tags.
//

#define IO_REPARSE_TAG_VALID_VALUES     (0xF000FFFF)

//
// Macro to determine whether a reparse tag is a valid tag.
//

#define IsReparseTagValid(_tag) (                               \
                  !((_tag) & ~IO_REPARSE_TAG_VALID_VALUES) &&   \
                  ((_tag) > IO_REPARSE_TAG_RESERVED_RANGE)      \
                 )

///////////////////////////////////////////////////////////////////////////////
//
// Microsoft tags for reparse points.
//
///////////////////////////////////////////////////////////////////////////////

#define IO_REPARSE_TAG_MOUNT_POINT              (0xA0000003L)       // winnt
#define IO_REPARSE_TAG_HSM                      (0xC0000004L)       // winnt
#define IO_REPARSE_TAG_DRIVE_EXTENDER           (0x80000005L)
#define IO_REPARSE_TAG_HSM2                     (0x80000006L)       // winnt
#define IO_REPARSE_TAG_SIS                      (0x80000007L)       // winnt
#define IO_REPARSE_TAG_DFS                      (0x8000000AL)       // winnt
#define IO_REPARSE_TAG_FILTER_MANAGER           (0x8000000BL)
#define IO_REPARSE_TAG_SYMLINK                  (0xA000000CL)       // winnt
#define IO_REPARSE_TAG_IIS_CACHE                (0xA0000010L)
#define IO_REPARSE_TAG_DFSR                     (0x80000012L)       // winnt



///////////////////////////////////////////////////////////////////////////////
//
// Non-Microsoft tags for reparse points
//
///////////////////////////////////////////////////////////////////////////////

//
// Tag allocated to CONGRUENT, May 2000. Used by IFSTEST
//

#define IO_REPARSE_TAG_IFSTEST_CONGRUENT        (0x00000009L)

//
//  Tag allocated to Moonwalk Univeral for HSM
//  GUID: 257ABE42-5A28-4C8C-AC46-8FEA5619F18F
//

#define IO_REPARSE_TAG_MOONWALK_HSM             (0x0000000AL)

//
//  Tag allocated to Tsinghua Univeristy for Research purposes
//  No released products should use this tag
//  GUID: b86dff51-a31e-4bac-b3cf-e8cfe75c9fc2
//

#define IO_REPARSE_TAG_TSINGHUA_UNIVERSITY_RESEARCH (0x0000000BL)

//
// Tag allocated to ARKIVIO for HSM
//

#define IO_REPARSE_TAG_ARKIVIO                  (0x0000000CL)

//
//  Tag allocated to SOLUTIONSOFT for name surrogate
//

#define IO_REPARSE_TAG_SOLUTIONSOFT             (0x2000000DL)

//
//  Tag allocated to COMMVAULT for HSM
//

#define IO_REPARSE_TAG_COMMVAULT                (0x0000000EL)

//
//  Tag allocated to Overtone Software for HSM
//

#define IO_REPARSE_TAG_OVERTONE                 (0x0000000FL)

//
//  Tag allocated to Symantec (formerly to KVS Inc) for HSM
//  GUID: A49F7BF6-77CA-493c-A0AA-18DBB28D1098
//

#define IO_REPARSE_TAG_SYMANTEC_HSM2            (0x00000010L)

//
//  Tag allocated to Enigma Data for HSM
//

#define IO_REPARSE_TAG_ENIGMA_HSM               (0x00000011L)

//
//  Tag allocated to Symantec for HSM
//  GUID: B99F4235-CF1C-48dd-9E6C-459FA289F8C7
//

#define IO_REPARSE_TAG_SYMANTEC_HSM             (0x00000012L)

//
//  Tag allocated to INTERCOPE for HSM
//  GUID: F204BE2D-AEEB-4728-A31C-C7F4E9BEA758}
//

#define IO_REPARSE_TAG_INTERCOPE_HSM            (0x00000013L)

//
//  Tag allocated to KOM Networks for HSM
//

#define IO_REPARSE_TAG_KOM_NETWORKS_HSM         (0x00000014L)

//
//  Tag allocated to MEMORY_TECH for HSM
//  GUID: E51BA456-046C-43ea-AEC7-DC1A87E1FD49
//

#define IO_REPARSE_TAG_MEMORY_TECH_HSM          (0x00000015L)

//
//  Tag allocated to BridgeHead Software for HSM
//  GUID: EBAFF6E3-F21D-4496-8342-58144B3D2BD0
//

#define IO_REPARSE_TAG_BRIDGEHEAD_HSM           (0x00000016L)

//
//  Tag allocated to OSR for samples reparse point filter
//  GUID: 3740c860-b19b-11d9-9669-0800200c9a66
//

#define IO_REPARSE_TAG_OSR_SAMPLE               (0x20000017L)

//
//  Tag allocated to Global 360 for HSM
//  GUID: C4B51F66-7F00-4c55-9441-8A1B159F209B
//

#define IO_REPARSE_TAG_GLOBAL360_HSM            (0x00000018L)

//
//  Tag allocated to Altiris for HSM
//  GUID: fc1047eb-fb2d-45f2-a2f4-a71c1032fa2dB
//

#define IO_REPARSE_TAG_ALTIRIS_HSM              (0x00000019L)

//
//  Tag allocated to Hermes for HSM
//  GUID: 437E0FD5-FCB4-42fe-877A-C785DA662AC2
//

#define IO_REPARSE_TAG_HERMES_HSM               (0x0000001AL)

//
//  Tag allocated to PointSoft for HSM
//  GUID: 547BC7FD-9604-4deb-AE07-B6514DF5FBC6
//

#define IO_REPARSE_TAG_POINTSOFT_HSM            (0x0000001BL)

//
//  Tag allocated to GRAU Data Storage for HSM
//  GUID: 6662D310-5653-4D10-8C31-F8E166D1A1BD
//

#define IO_REPARSE_TAG_GRAU_DATASTORAGE_HSM     (0x0000001CL)

//
//  Tag allocated to CommVault for HSM
//  GUID: cc38adf3-c583-4efa-b183-72c1671941de
//

#define IO_REPARSE_TAG_COMMVAULT_HSM            (0x0000001DL)


//
//  Tag allocated to Data Storage Group for single instance storage
//  GUID: C1182673-0562-447a-8E40-4F0549FDF817
//

#define IO_REPARSE_TAG_DATASTOR_SIS             (0x0000001EL)


//
//  Tag allocated to Enterprise Data Solutions, Inc. for HSM
//  GUID: EB63DF9D-8874-41cd-999A-A197542CDAFC
//

#define IO_REPARSE_TAG_EDSI_HSM                 (0x0000001FL)


//
//  Tag allocated to HP StorageWorks Reference Information Manager for Files (HSM)
//  GUID: 3B0F6B23-0C2E-4281-9C19-C6AEEBC88CD8
//

#define IO_REPARSE_TAG_HP_HSM                   (0x00000020L)


//
//  Tag allocated to SER Beteiligung Solutions Deutschland GmbH (HSM)
//  GUID: 55B673F0-978E-41c5-9ADB-AF99640BE90E
//

#define IO_REPARSE_TAG_SER_HSM                  (0x00000021L)


//
//  Tag allocated to Double-Take Software (formerly NSI Software, Inc.) for HSM
//  GUID: f7cb0ce8-453a-4ae1-9c56-db41b55f6ed4
//

#define IO_REPARSE_TAG_DOUBLE_TAKE_HSM          (0x00000022L)


//
//  Tag allocated to Beijing Wisdata Systems CO, LTD for HSM
//  GUID: d546500a-2aeb-45f6-9482-f4b1799c3177
//

#define IO_REPARSE_TAG_WISDATA_HSM              (0x00000023L)


//
//  Reparse point index keys.
//
//  The index with all the reparse points that exist in a volume at a
//  given time contains entries with keys of the form
//                        <reparse tag, file record id>.
//  The data part of these records is empty.
//

#pragma pack(4)

typedef struct _REPARSE_INDEX_KEY {

    //
    //  The tag of the reparse point.
    //

    ULONG FileReparseTag;

    //
    //  The file record Id where the reparse point is set.
    //

    LARGE_INTEGER FileId;

} REPARSE_INDEX_KEY, *PREPARSE_INDEX_KEY;

#pragma pack()



//
// The following three FSCTLs are placed in this file to facilitate sharing
// between the redirector and the IO subsystem
//
// This FSCTL is used to garner the link tracking information for a file.
// The data structures used for retreving the information are
// LINK_TRACKING_INFORMATION defined further down in this file.
//

#define FSCTL_LMR_GET_LINK_TRACKING_INFORMATION   CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM,58,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// This FSCTL is used to update the link tracking information on a server for
// an intra machine/ inter volume move on that server
//

#define FSCTL_LMR_SET_LINK_TRACKING_INFORMATION   CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM,59,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// The following IOCTL is used in link tracking implementation. It determines if the
// two file objects passed in are on the same server. This IOCTL is available in
// kernel mode only since it accepts FILE_OBJECT as parameters
//

#define IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM,60,METHOD_BUFFERED,FILE_ANY_ACCESS)



//
// Named Pipe file control code and structure declarations
//

//
// External named pipe file control operations
//

#define FSCTL_PIPE_ASSIGN_EVENT             CTL_CODE(FILE_DEVICE_NAMED_PIPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_DISCONNECT               CTL_CODE(FILE_DEVICE_NAMED_PIPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_LISTEN                   CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_PEEK                     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 3, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_PIPE_QUERY_EVENT              CTL_CODE(FILE_DEVICE_NAMED_PIPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_TRANSCEIVE               CTL_CODE(FILE_DEVICE_NAMED_PIPE, 5, METHOD_NEITHER,  FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_PIPE_WAIT                     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_IMPERSONATE              CTL_CODE(FILE_DEVICE_NAMED_PIPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_CLIENT_PROCESS       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_QUERY_CLIENT_PROCESS     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_PIPE_ATTRIBUTE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_PIPE_ATTRIBUTE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_CONNECTION_ATTRIBUTE CTL_CODE(FILE_DEVICE_NAMED_PIPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_GET_HANDLE_ATTRIBUTE     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_PIPE_SET_HANDLE_ATTRIBUTE     CTL_CODE(FILE_DEVICE_NAMED_PIPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Internal named pipe file control operations
//

#define FSCTL_PIPE_INTERNAL_READ        CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2045, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_PIPE_INTERNAL_WRITE       CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2046, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_PIPE_INTERNAL_TRANSCEIVE  CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2047, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_PIPE_INTERNAL_READ_OVFLOW CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2048, METHOD_BUFFERED, FILE_READ_DATA)

//
// Define entry types for query event information
//

#define FILE_PIPE_READ_DATA             0x00000000
#define FILE_PIPE_WRITE_SPACE           0x00000001

//
// Named pipe file system control structure declarations
//

// Control structure for FSCTL_PIPE_ASSIGN_EVENT

typedef struct _FILE_PIPE_ASSIGN_EVENT_BUFFER {
     HANDLE EventHandle;
     ULONG KeyValue;
} FILE_PIPE_ASSIGN_EVENT_BUFFER, *PFILE_PIPE_ASSIGN_EVENT_BUFFER;

// Control structure for FSCTL_PIPE_PEEK

typedef struct _FILE_PIPE_PEEK_BUFFER {
     ULONG NamedPipeState;
     ULONG ReadDataAvailable;
     ULONG NumberOfMessages;
     ULONG MessageLength;
     CHAR Data[1];
} FILE_PIPE_PEEK_BUFFER, *PFILE_PIPE_PEEK_BUFFER;

// Control structure for FSCTL_PIPE_QUERY_EVENT

typedef struct _FILE_PIPE_EVENT_BUFFER {
     ULONG NamedPipeState;
     ULONG EntryType;
     ULONG ByteCount;
     ULONG KeyValue;
     ULONG NumberRequests;
} FILE_PIPE_EVENT_BUFFER, *PFILE_PIPE_EVENT_BUFFER;

// Control structure for FSCTL_PIPE_WAIT

typedef struct _FILE_PIPE_WAIT_FOR_BUFFER {
     LARGE_INTEGER Timeout;
     ULONG NameLength;
     BOOLEAN TimeoutSpecified;
     WCHAR Name[1];
} FILE_PIPE_WAIT_FOR_BUFFER, *PFILE_PIPE_WAIT_FOR_BUFFER;

// Control structure for FSCTL_PIPE_SET_CLIENT_PROCESS and FSCTL_PIPE_QUERY_CLIENT_PROCESS

typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER {
#if !defined(BUILD_WOW6432)
     PVOID ClientSession;
     PVOID ClientProcess;
#else
     ULONGLONG ClientSession;
     ULONGLONG ClientProcess;
#endif
} FILE_PIPE_CLIENT_PROCESS_BUFFER, *PFILE_PIPE_CLIENT_PROCESS_BUFFER;

// This is an extension to the client process info buffer containing the client
// computer name

#define FILE_PIPE_COMPUTER_NAME_LENGTH 15

typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
#if !defined(BUILD_WOW6432)
    PVOID ClientSession;
    PVOID ClientProcess;
#else
     ULONGLONG ClientSession;
     ULONGLONG ClientProcess;
#endif
    USHORT ClientComputerNameLength; // in bytes
    WCHAR ClientComputerBuffer[FILE_PIPE_COMPUTER_NAME_LENGTH+1]; // terminated
} FILE_PIPE_CLIENT_PROCESS_BUFFER_EX, *PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX;

//
// Mailslot file control operations.
//

#define FSCTL_MAILSLOT_PEEK             CTL_CODE(FILE_DEVICE_MAILSLOT, 0, METHOD_NEITHER, FILE_READ_DATA) // ntifs

//
// Control structure for FSCTL_LMR_GET_LINK_TRACKING_INFORMATION
//

//
// For links on DFS volumes the volume id and machine id are returned for
// link tracking
//

typedef enum _LINK_TRACKING_INFORMATION_TYPE {
    NtfsLinkTrackingInformation,
    DfsLinkTrackingInformation
} LINK_TRACKING_INFORMATION_TYPE, *PLINK_TRACKING_INFORMATION_TYPE;

typedef struct _LINK_TRACKING_INFORMATION {
    LINK_TRACKING_INFORMATION_TYPE Type;
    UCHAR   VolumeId[16];
} LINK_TRACKING_INFORMATION, *PLINK_TRACKING_INFORMATION;

//
// Control structure for FSCTL_LMR_SET_LINK_TRACKING_INFORMATION
//

typedef struct _REMOTE_LINK_TRACKING_INFORMATION_ {
    PVOID       TargetFileObject;
    ULONG   TargetLinkTrackingInformationLength;
    UCHAR   TargetLinkTrackingInformationBuffer[1];
} REMOTE_LINK_TRACKING_INFORMATION,
 *PREMOTE_LINK_TRACKING_INFORMATION;


#if defined(USE_LPC6432)
#define LPC_CLIENT_ID CLIENT_ID64
#define LPC_SIZE_T ULONGLONG
#define LPC_PVOID ULONGLONG
#define LPC_HANDLE ULONGLONG
#else
#define LPC_CLIENT_ID CLIENT_ID
#define LPC_SIZE_T SIZE_T
#define LPC_PVOID PVOID
#define LPC_HANDLE HANDLE
#endif


typedef struct _PORT_MESSAGE {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        LPC_CLIENT_ID ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } DUMMYUNIONNAME3;
    ULONG MessageId;
    union {
        LPC_SIZE_T ClientViewSize;          // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } DUMMYUNIONNAME4;
//  UCHAR Data[];
} PORT_MESSAGE, *PPORT_MESSAGE;


//
// The following bit may be placed in the Type field of a message
// prior calling NtRequestPort or NtRequestWaitReplyPort.  If the
// previous mode is KernelMode, the bit it left as is and passed
// to the receiver of the message.  Otherwise the bit is clear.
//

#define LPC_KERNELMODE_MESSAGE      (CSHORT)((USHORT)0x8000)


typedef struct _PORT_VIEW {
    ULONG Length;
    LPC_HANDLE SectionHandle;
    ULONG SectionOffset;
    LPC_SIZE_T ViewSize;
    LPC_PVOID ViewBase;
    LPC_PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {
    ULONG Length;
    LPC_SIZE_T ViewSize;
    LPC_PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;


#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtConnectPort(
    __out PHANDLE PortHandle,
    __in PUNICODE_STRING PortName,
    __in PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    __inout_opt PPORT_VIEW ClientView,
    __inout_opt PREMOTE_PORT_VIEW ServerView,
    __out_opt PULONG MaxMessageLength,
    __inout_opt PVOID ConnectionInformation,
    __inout_opt PULONG ConnectionInformationLength
    );

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtSecureConnectPort(
    __out PHANDLE PortHandle,
    __in PUNICODE_STRING PortName,
    __in PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    __inout_opt PPORT_VIEW ClientView,
    __in_opt PSID RequiredServerSid,
    __inout_opt PREMOTE_PORT_VIEW ServerView,
    __out_opt PULONG MaxMessageLength,
    __inout_opt PVOID ConnectionInformation,
    __inout_opt PULONG ConnectionInformationLength
    );
#endif //  NTDDI_VERSION >= NTDDI_WINXP


#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    __in HANDLE PortHandle,
    __in PPORT_MESSAGE RequestMessage,
    __out PPORT_MESSAGE ReplyMessage
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP


//
// Object Information Classes
//

typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation = 0,
    ObjectTypeInformation = 2
} OBJECT_INFORMATION_CLASS;

//
//  Public Object Information definitions
//

typedef struct _PUBLIC_OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;

    ULONG Reserved[10];    // reserved for internal use

} PUBLIC_OBJECT_BASIC_INFORMATION, *PPUBLIC_OBJECT_BASIC_INFORMATION;

typedef struct __PUBLIC_OBJECT_TYPE_INFORMATION {

    UNICODE_STRING TypeName;

    ULONG Reserved [22];    // reserved for internal use

} PUBLIC_OBJECT_TYPE_INFORMATION, *PPUBLIC_OBJECT_TYPE_INFORMATION;

#if (NTDDI_VERSION >= NTDDI_NT4)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryObject (
    __in_opt HANDLE Handle,
    __in OBJECT_INFORMATION_CLASS ObjectInformationClass,
    __out_bcount_opt(ObjectInformationLength) PVOID ObjectInformation,
    __in ULONG ObjectInformationLength,
    __out_opt PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSecurityObject (
    __in HANDLE Handle,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityObject (
    __in HANDLE Handle,
    __in SECURITY_INFORMATION SecurityInformation,
    __out_bcount_opt(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG Length,
    __out PULONG LengthNeeded
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtClose (
    __in HANDLE Handle
    );
#endif // NTDDI_VERSION >= NTDDI_WIN2K

#define SEC_COMMIT        0x8000000     

#if (NTDDI_VERSION >= NTDDI_WINXP)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSection (
    __out PHANDLE SectionHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PLARGE_INTEGER MaximumSize,
    __in ULONG SectionPageProtection,
    __in ULONG AllocationAttributes,
    __in_opt HANDLE FileHandle
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP


#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory (
    __in HANDLE ProcessHandle,
    __inout PVOID *BaseAddress,
    __in ULONG_PTR ZeroBits,
    __inout PSIZE_T RegionSize,
    __in ULONG AllocationType,
    __in ULONG Protect
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory (
    __in HANDLE ProcessHandle,
    __inout PVOID *BaseAddress,
    __inout PSIZE_T RegionSize,
    __in ULONG FreeType
    );
#endif // NTDDI_VERSION >= NTDDI_WIN2K

//
// Data structure used to represent client security context for a thread.
// This data structure is used to support impersonation.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_CLIENT_CONTEXT {
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_TOKEN ClientToken;
    BOOLEAN DirectlyAccessClientToken;
    BOOLEAN DirectAccessEffectiveOnly;
    BOOLEAN ServerIsRemote;
    TOKEN_CONTROL ClientTokenControl;
    } SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

//
// where
//
//    SecurityQos - is the security quality of service information in effect
//        for this client.  This information is used when directly accessing
//        the client's token.  In this case, the information here over-rides
//        the information in the client's token.  If a copy of the client's
//        token is requested, it must be generated using this information,
//        not the information in the client's token.  In all cases, this
//        information may not provide greater access than the information
//        in the client's token.  In particular, if the client's token is
//        an impersonation token with an impersonation level of
//        "SecurityDelegation", but the information in this field indicates
//        an impersonation level of "SecurityIdentification", then
//        the server may only get a copy of the token with an Identification
//        level of impersonation.
//
//    ClientToken - If the DirectlyAccessClientToken field is FALSE,
//        then this field contains a pointer to a duplicate of the
//        client's token.  Otherwise, this field points directly to
//        the client's token.
//
//    DirectlyAccessClientToken - This boolean flag indicates whether the
//        token pointed to by ClientToken is a copy of the client's token
//        or is a direct reference to the client's token.  A value of TRUE
//        indicates the client's token is directly accessed, FALSE indicates
//        a copy has been made.
//
//    DirectAccessEffectiveOnly - This boolean flag indicates whether the
//        the disabled portions of the token that is currently directly
//        referenced may be enabled.  This field is only valid if the
//        DirectlyAccessClientToken field is TRUE.  In that case, this
//        value supersedes the EffectiveOnly value in the SecurityQos
//        FOR THE CURRENT TOKEN ONLY!  If the client changes to impersonate
//        another client, this value may change.  This value is always
//        minimized by the EffectiveOnly flag in the SecurityQos field.
//
//    ServerIsRemote - If TRUE indicates that the server of the client's
//        request is remote.  This is used for determining the legitimacy
//        of certain levels of impersonation and to determine how to
//        track context.
//
//    ClientTokenControl - If the ServerIsRemote flag is TRUE, and the
//        tracking mode is DYNAMIC, then this field contains a copy of
//        the TOKEN_SOURCE from the client's token to assist in deciding
//        whether the information at the remote server needs to be
//        updated to match the current state of the client's security
//        context.
//
//
//    NOTE: At some point, we may find it worthwhile to keep an array of
//          elements in this data structure, where each element of the
//          array contains {ClientToken, ClientTokenControl} fields.
//          This would allow efficient handling of the case where a client
//          thread was constantly switching between a couple different
//          contexts - presumably impersonating client's of its own.
//
#define NTKERNELAPI DECLSPEC_IMPORT     
#define NTHALAPI DECLSPEC_IMPORT            
//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0


//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1



//
// Memory priority definitions.
//

#define SYSTEM_PAGE_PRIORITY_BITS       3
#define SYSTEM_PAGE_PRIORITY_LEVELS     (1<<SYSTEM_PAGE_PRIORITY_BITS)


//
// Miscellaneous type definitions
//
// APC state
//
// N.B. The user APC pending field must be the last member of this structure.
//

typedef struct _KAPC_STATE {
    LIST_ENTRY ApcListHead[MaximumMode];
    struct _KPROCESS *Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE;

#define KAPC_STATE_ACTUAL_LENGTH                                             \
    (FIELD_OFFSET(KAPC_STATE, UserApcPending) + sizeof(BOOLEAN))

//
// Queue object
//

#define ASSERT_QUEUE(Q) NT_ASSERT(((Q)->Header.Type & KOBJECT_TYPE_MASK) == QueueObject);

// begin_ntosp

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE, *PRKQUEUE;

// end_ntosp

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
VOID
KeInitializeThreadedDpc (
    __out PRKDPC Dpc,
    __in PKDEFERRED_ROUTINE DeferredRoutine,
    __in_opt PVOID DeferredContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeMutant (
    __out PRKMUTANT Mutant,
    __in BOOLEAN InitialOwner
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
KeQueryOwnerMutant (
    __in PKMUTANT Mutant,
    __out PCLIENT_ID ClientId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeReadStateMutant (
    __in PRKMUTANT Mutant
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeReleaseMutant (
    __inout PRKMUTANT Mutant,
    __in KPRIORITY Increment,
    __in BOOLEAN Abandoned,
    __in BOOLEAN Wait
    );
#endif

//
// Queue Object.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeQueue (
    __out PRKQUEUE Queue,
    __in ULONG Count
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeReadStateQueue (
    __in PRKQUEUE Queue
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeInsertQueue (
    __inout PRKQUEUE Queue,
    __inout PLIST_ENTRY Entry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeInsertHeadQueue (
    __inout PRKQUEUE Queue,
    __inout PLIST_ENTRY Entry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PLIST_ENTRY
KeRemoveQueue (
    __inout PRKQUEUE Queue,
    __in KPROCESSOR_MODE WaitMode,
    __in_opt PLARGE_INTEGER Timeout
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PLIST_ENTRY
KeRundownQueue (
    __inout PRKQUEUE Queue
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeAttachProcess (
    __inout PRKPROCESS Process
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeDetachProcess (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeStackAttachProcess (
    __inout PRKPROCESS PROCESS,
    __out PRKAPC_STATE ApcState
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeUnstackDetachProcess (
    PRKAPC_STATE ApcState
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
UCHAR
KeSetIdealProcessorThread (
    __inout PKTHREAD Thread,
    __in UCHAR Processor
    );
#endif

// begin_ntosp
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeSetKernelStackSwapEnable (
    __in BOOLEAN Enable
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireQueuedSpinLock (
    __in KSPIN_LOCK_QUEUE_NUMBER Number
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeReleaseQueuedSpinLock (
    __in KSPIN_LOCK_QUEUE_NUMBER Number,
    __in KIRQL OldIrql
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_DECL_HAL_KE_IMPORT
LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLock (
    __in KSPIN_LOCK_QUEUE_NUMBER Number,
    __out PKIRQL OldIrql
    );
#endif

#if defined(_X86_)   

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#else 


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToSynch (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#endif 
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
SIZE_T
ExQueryPoolBlockSize (
    __in PVOID PoolBlock,
    __out PBOOLEAN QuotaCharged
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
PSLIST_ENTRY
FASTCALL
InterlockedPushListSList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY List,
    IN PSLIST_ENTRY ListEnd,
    IN ULONG Count
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
// Define interlocked lookaside list structure and allocation functions.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
VOID
ExAdjustLookasideDepth (
    VOID
    );
#endif


#if !defined(_X86AMD64_)

#if defined(_WIN64)

C_ASSERT(sizeof(ERESOURCE) == 0x68);
C_ASSERT(FIELD_OFFSET(ERESOURCE,ActiveCount) == 0x18);
C_ASSERT(FIELD_OFFSET(ERESOURCE,Flag) == 0x1a);

#else

C_ASSERT(sizeof(ERESOURCE) == 0x38);
C_ASSERT(FIELD_OFFSET(ERESOURCE,ActiveCount) == 0x0c);
C_ASSERT(FIELD_OFFSET(ERESOURCE,Flag) == 0x0e);

#endif

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExDisableResourceBoostLite (
    __in PERESOURCE Resource
    );
#endif

#if DBG

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)
VOID
ExCheckIfResourceOwned (
    VOID
    );
#endif

#endif

#define ExDisableResourceBoost ExDisableResourceBoostLite

//
// Push lock definitions
//
#define EX_PUSH_LOCK ULONG_PTR
#define PEX_PUSH_LOCK PULONG_PTR

VOID
ExInitializePushLock (
     __out PEX_PUSH_LOCK PushLock
     );

//
// Token Flags
//
// Flags that may be defined in the TokenFlags field of the token object,
// or in an ACCESS_STATE structure
//

#define TOKEN_HAS_TRAVERSE_PRIVILEGE    0x0001
#define TOKEN_HAS_BACKUP_PRIVILEGE      0x0002
#define TOKEN_HAS_RESTORE_PRIVILEGE     0x0004
#define TOKEN_WRITE_RESTRICTED          0x0008
#define TOKEN_IS_RESTRICTED             0x0010
#define TOKEN_SESSION_NOT_REFERENCED    0x0020
#define TOKEN_SANDBOX_INERT             0x0040
#define TOKEN_HAS_IMPERSONATE_PRIVILEGE 0x0080
#define SE_BACKUP_PRIVILEGES_CHECKED    0x0100
#define TOKEN_VIRTUALIZE_ALLOWED        0x0200
#define TOKEN_VIRTUALIZE_ENABLED        0x0400
#define TOKEN_IS_FILTERED               0x0800
#define TOKEN_UIACCESS                  0x1000


typedef struct _SE_EXPORTS {

    //
    // Privilege values
    //

    LUID    SeCreateTokenPrivilege;
    LUID    SeAssignPrimaryTokenPrivilege;
    LUID    SeLockMemoryPrivilege;
    LUID    SeIncreaseQuotaPrivilege;
    LUID    SeUnsolicitedInputPrivilege;
    LUID    SeTcbPrivilege;
    LUID    SeSecurityPrivilege;
    LUID    SeTakeOwnershipPrivilege;
    LUID    SeLoadDriverPrivilege;
    LUID    SeCreatePagefilePrivilege;
    LUID    SeIncreaseBasePriorityPrivilege;
    LUID    SeSystemProfilePrivilege;
    LUID    SeSystemtimePrivilege;
    LUID    SeProfileSingleProcessPrivilege;
    LUID    SeCreatePermanentPrivilege;
    LUID    SeBackupPrivilege;
    LUID    SeRestorePrivilege;
    LUID    SeShutdownPrivilege;
    LUID    SeDebugPrivilege;
    LUID    SeAuditPrivilege;
    LUID    SeSystemEnvironmentPrivilege;
    LUID    SeChangeNotifyPrivilege;
    LUID    SeRemoteShutdownPrivilege;


    //
    // Universally defined Sids
    //


    PSID  SeNullSid;
    PSID  SeWorldSid;
    PSID  SeLocalSid;
    PSID  SeCreatorOwnerSid;
    PSID  SeCreatorGroupSid;


    //
    // Nt defined Sids
    //


    PSID  SeNtAuthoritySid;
    PSID  SeDialupSid;
    PSID  SeNetworkSid;
    PSID  SeBatchSid;
    PSID  SeInteractiveSid;
    PSID  SeLocalSystemSid;
    PSID  SeAliasAdminsSid;
    PSID  SeAliasUsersSid;
    PSID  SeAliasGuestsSid;
    PSID  SeAliasPowerUsersSid;
    PSID  SeAliasAccountOpsSid;
    PSID  SeAliasSystemOpsSid;
    PSID  SeAliasPrintOpsSid;
    PSID  SeAliasBackupOpsSid;

    //
    // New Sids defined for NT5
    //

    PSID  SeAuthenticatedUsersSid;

    PSID  SeRestrictedSid;
    PSID  SeAnonymousLogonSid;

    //
    // New Privileges defined for NT5
    //

    LUID  SeUndockPrivilege;
    LUID  SeSyncAgentPrivilege;
    LUID  SeEnableDelegationPrivilege;

    //
    // New Sids defined for post-Windows 2000

    PSID  SeLocalServiceSid;
    PSID  SeNetworkServiceSid;

    //
    // New Privileges defined for post-Windows 2000
    //

    LUID  SeManageVolumePrivilege;
    LUID  SeImpersonatePrivilege;
    LUID  SeCreateGlobalPrivilege;

    //
    // New Privileges defined for post Windows Server 2003
    //

    LUID  SeTrustedCredManAccessPrivilege;
    LUID  SeRelabelPrivilege;
    LUID  SeIncreaseWorkingSetPrivilege;

    LUID  SeTimeZonePrivilege;
    LUID  SeCreateSymbolicLinkPrivilege;

    //
    // New Sids defined for post Windows Server 2003
    //

    PSID  SeIUserSid;

    //
    // Mandatory Sids, ordered lowest to highest.
    //

    PSID SeUntrustedMandatorySid;
    PSID SeLowMandatorySid;
    PSID SeMediumMandatorySid;
    PSID SeHighMandatorySid;
    PSID SeSystemMandatorySid;

    PSID SeOwnerRightsSid;

} SE_EXPORTS, *PSE_EXPORTS;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//              Logon session notification callback routines                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  These callback routines are used to notify file systems that have
//  registered of logon sessions being terminated, so they can cleanup state
//  associated with this logon session
//

typedef NTSTATUS
(*PSE_LOGON_SESSION_TERMINATED_ROUTINE)(
    IN PLUID LogonId);

//++
//
//  ULONG
//  SeLengthSid(
//      IN PSID Sid
//      );
//
//  Routine Description:
//
//      This routine computes the length of a SID.
//
//  Arguments:
//
//      Sid - Points to the SID whose length is to be returned.
//
//  Return Value:
//
//      The length, in bytes of the SID.
//
//--

#define SeLengthSid( Sid ) \
    (8 + (4 * ((SID *)Sid)->SubAuthorityCount))

//
//VOID
//SeDeleteClientSecurity(
//    IN PSECURITY_CLIENT_CONTEXT ClientContext
//    )
//
///*++
//
//Routine Description:
//
//    This service deletes a client security context block,
//    performing whatever cleanup might be necessary to do so.  In
//    particular, reference to any client token is removed.
//
//Arguments:
//
//    ClientContext - Points to the client security context block to be
//        deleted.
//
//
//Return Value:
//
//
//
//--*/
//--

// begin_ntosp
#define SeDeleteClientSecurity(C)  {                                           \
            if (SeTokenType((C)->ClientToken) == TokenPrimary) {               \
                PsDereferencePrimaryToken( (C)->ClientToken );                 \
            } else {                                                           \
                PsDereferenceImpersonationToken( (C)->ClientToken );           \
            }                                                                  \
        }


//++
//VOID
//SeStopImpersonatingClient()
//
///*++
//
//Routine Description:
//
//    This service is used to stop impersonating a client using an
//    impersonation token.  This service must be called in the context
//    of the server thread which wishes to stop impersonating its
//    client.
//
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//--

#define SeStopImpersonatingClient() PsRevertToSelf()


//++
//
//  PACCESS_TOKEN
//  SeQuerySubjectContextToken(
//      IN PSECURITY_SUBJECT_CONTEXT SubjectContext
//      );
//
//  Routine Description:
//
//      This routine returns the effective token from the subject context,
//      either the client token, if present, or the process token.
//
//  Arguments:
//
//      SubjectContext - Context to query
//
//  Return Value:
//
//      This routine returns the PACCESS_TOKEN for the effective token.
//      The pointer may be passed to SeQueryInformationToken.  This routine
//      does not affect the lock status of the token, i.e. the token is not
//      locked.  If the SubjectContext has been locked, the token remains locked,
//      if not, the token remains unlocked.
//
//--

#define SeQuerySubjectContextToken( SubjectContext ) \
        ( ARGUMENT_PRESENT( ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->ClientToken) ? \
            ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->ClientToken : \
            ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->PrimaryToken )


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeCaptureSubjectContext (
    __out PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeLockSubjectContext(
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeUnlockSubjectContext(
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeReleaseSubjectContext (
    __inout PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif


NTSTATUS
SeReportSecurityEventWithSubCategory(
    __in ULONG Flags,
    __in PUNICODE_STRING SourceName,
    __in_opt PSID UserSid,
    __in PSE_ADT_PARAMETER_ARRAY AuditParameters,
    __in ULONG AuditSubcategoryId
    );

BOOLEAN
SeAccessCheckFromState (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PTOKEN_ACCESS_INFORMATION PrimaryTokenInformation,
    IN PTOKEN_ACCESS_INFORMATION ClientTokenInformation OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN KPROCESSOR_MODE AccessMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SePrivilegeCheck(
    __inout PPRIVILEGE_SET RequiredPrivileges,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    __in KPROCESSOR_MODE AccessMode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeFreePrivileges(
    __in PPRIVILEGE_SET Privileges
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeOpenObjectAuditAlarm (
    __in PUNICODE_STRING ObjectTypeName,
    __in_opt PVOID Object,
    __in_opt PUNICODE_STRING AbsoluteObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PACCESS_STATE AccessState,
    __in BOOLEAN ObjectCreated,
    __in BOOLEAN AccessGranted,
    __in KPROCESSOR_MODE AccessMode,
    __out PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeOpenObjectAuditAlarmWithTransaction (
    __in PUNICODE_STRING ObjectTypeName,
    __in_opt PVOID Object,
    __in_opt PUNICODE_STRING AbsoluteObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PACCESS_STATE AccessState,
    __in BOOLEAN ObjectCreated,
    __in BOOLEAN AccessGranted,
    __in KPROCESSOR_MODE AccessMode,
    __in_opt GUID *TransactionId,
    __out PBOOLEAN GenerateOnClose
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeOpenObjectForDeleteAuditAlarm (
    __in PUNICODE_STRING ObjectTypeName,
    __in_opt PVOID Object,
    __in_opt PUNICODE_STRING AbsoluteObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PACCESS_STATE AccessState,
    __in BOOLEAN ObjectCreated,
    __in BOOLEAN AccessGranted,
    __in KPROCESSOR_MODE AccessMode,
    __out PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeOpenObjectForDeleteAuditAlarmWithTransaction (
    __in PUNICODE_STRING ObjectTypeName,
    __in_opt PVOID Object,
    __in_opt PUNICODE_STRING AbsoluteObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PACCESS_STATE AccessState,
    __in BOOLEAN ObjectCreated,
    __in BOOLEAN AccessGranted,
    __in KPROCESSOR_MODE AccessMode,
    __in_opt GUID *TransactionId,
    __out PBOOLEAN GenerateOnClose
    );

NTKERNELAPI
VOID
SeExamineSacl(
    __in PACL Sacl,
    __in PACCESS_TOKEN Token,
    __in ACCESS_MASK DesiredAccess,
    __in BOOLEAN AccessGranted,
    __out PBOOLEAN GenerateAudit,
    __out PBOOLEAN GenerateAlarm
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeDeleteObjectAuditAlarm(
    __in PVOID Object,
    __in HANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeDeleteObjectAuditAlarmWithTransaction(
    __in PVOID Object,
    __in HANDLE Handle,
    __in_opt GUID *TransactionId
    );



#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)              
NTKERNELAPI                                     
TOKEN_TYPE                                      
SeTokenType(                                    
    __in PACCESS_TOKEN Token                    
    );                                          
#endif                                          
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SeTokenIsAdmin(
    __in PACCESS_TOKEN Token
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SeTokenIsRestricted(
    __in PACCESS_TOKEN Token
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || (NTDDI_VERSION >= NTDDI_WINXPSP2 && NTDDI_VERSION < NTDDI_WS03))
NTKERNELAPI
BOOLEAN
SeTokenIsWriteRestricted(
    IN PACCESS_TOKEN Token
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
SeFilterToken (
    __in PACCESS_TOKEN ExistingToken,
    __in ULONG Flags,
    __in_opt PTOKEN_GROUPS SidsToDisable,
    __in_opt PTOKEN_PRIVILEGES PrivilegesToDelete,
    __in_opt PTOKEN_GROUPS RestrictedSids,
    __deref_out PACCESS_TOKEN * FilteredToken
    );
#endif

// begin_ntosp
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeQueryAuthenticationIdToken(
    __in PACCESS_TOKEN Token,
    __out PLUID AuthenticationId
    );
#endif

// end_ntosp

// begin_ntosp
#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeQueryTokenIntegrity(
    __in PACCESS_TOKEN Token,
    __inout PSID_AND_ATTRIBUTES IntegritySA
    );
#endif
// end_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeQuerySessionIdToken(
    __in PACCESS_TOKEN Token,
    __out PULONG SessionId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
SeSetSessionIdToken(
    __in PACCESS_TOKEN Token,
    __in ULONG SessionId
    );
#endif

// begin_ntosp
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeCreateClientSecurity (
    __in PETHREAD ClientThread,
    __in PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    __in BOOLEAN RemoteSession,
    __out PSECURITY_CLIENT_CONTEXT ClientContext
    );
#endif
// end_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeImpersonateClient(
    __in PSECURITY_CLIENT_CONTEXT ClientContext,
    __in_opt PETHREAD ServerThread
    );
#endif

// begin_ntosp
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeImpersonateClientEx(
    __in PSECURITY_CLIENT_CONTEXT ClientContext,
    __in_opt PETHREAD ServerThread
    );
#endif
// end_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeCreateClientSecurityFromSubjectContext (
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    __in BOOLEAN ServerIsRemote,
    __out PSECURITY_CLIENT_CONTEXT ClientContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeQuerySecurityDescriptorInfo (
    __in PSECURITY_INFORMATION SecurityInformation,
    __out_bcount(*Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    __inout PULONG Length,
    __deref_inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfo (
    __in_opt PVOID Object,
    __in PSECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR ModificationDescriptor,
    __inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    __in POOL_TYPE PoolType,
    __in PGENERIC_MAPPING GenericMapping
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfoEx (
    __in_opt PVOID Object,
    __in PSECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR ModificationDescriptor,
    __inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    __in ULONG AutoInheritFlags,
    __in POOL_TYPE PoolType,
    __in PGENERIC_MAPPING GenericMapping
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeAppendPrivileges(
    __inout PACCESS_STATE AccessState,
    __in PPRIVILEGE_SET Privileges
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
SeAuditHardLinkCreation(
    __in IN PUNICODE_STRING FileName,
    __in IN PUNICODE_STRING LinkName,
    __in IN BOOLEAN bSuccess
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI                                                
VOID                                                       
SeAuditHardLinkCreationWithTransaction(                                   
    __in PUNICODE_STRING FileName,                           
    __in PUNICODE_STRING LinkName,                           
    __in BOOLEAN bSuccess,
    __in_opt GUID *TransactionId
    );                                                     
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI                                                
VOID                                                       
SeAuditTransactionStateChange(                                   
    __in GUID *TransactionId,
    __in GUID *ResourceManagerId,
    __in ULONG NewTransactionState
    );                                                     
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SeAuditingFileEvents(
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
NTKERNELAPI
BOOLEAN
SeAuditingFileEventsWithContext(
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
NTKERNELAPI
BOOLEAN
SeAuditingHardLinkEvents(
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
NTKERNELAPI
BOOLEAN
SeAuditingHardLinkEventsWithContext(
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SeAuditingFileOrGlobalEvents(
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
BOOLEAN
FASTCALL
SeAuditingWithTokenForSubcategory(
    __in ULONG Subcategory,
    __in_opt PACCESS_TOKEN AccessToken
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
VOID
SeSetAccessStateGenericMapping (
    __inout PACCESS_STATE AccessState,
    __in PGENERIC_MAPPING GenericMapping
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeRegisterLogonSessionTerminatedRoutine(
    IN PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeUnregisterLogonSessionTerminatedRoutine(
    IN PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeMarkLogonSessionForTerminationNotification(
    IN PLUID LogonId
    );
#endif

// begin_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeQueryInformationToken (
    __in PACCESS_TOKEN Token,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __deref_out PVOID *TokenInformation
    );
#endif

NTSTATUS
SeLocateProcessImageName(
    __in PEPROCESS Process,
    __deref_out PUNICODE_STRING *pImageFileName
    );

//
//  Grants access to SeExports structure
//

extern NTKERNELAPI PSE_EXPORTS SeExports;


#if !defined(_PSGETCURRENTTHREAD_)

#define _PSGETCURRENTTHREAD_

FORCEINLINE
PETHREAD
PsGetCurrentThread (
    VOID
    )

/*++

Routine Description:

    This function returns a pointer to the current executive thread object.

Arguments:

    None.

Return Value:

    A pointer to the current executive thread object.

--*/

{

    return (PETHREAD)KeGetCurrentThread();
}

#endif


//
// Security Support
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PsAssignImpersonationToken(
    __in PETHREAD Thread,
    __in_opt HANDLE Token
    );
#endif

// begin_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PACCESS_TOKEN
PsReferencePrimaryToken (
    __inout PEPROCESS Process
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
PsDereferencePrimaryToken(
    __in PACCESS_TOKEN PrimaryToken
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
PsDereferenceImpersonationToken(
    __in PACCESS_TOKEN ImpersonationToken
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PACCESS_TOKEN
PsReferenceImpersonationToken(
    __inout PETHREAD Thread,
    __out PBOOLEAN CopyOnOpen,
    __out PBOOLEAN EffectiveOnly,
    __out PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LARGE_INTEGER
PsGetProcessExitTime(
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
PsIsThreadTerminating(
    __in PETHREAD Thread
    );
#endif

// begin_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PsImpersonateClient(
    __inout PETHREAD Thread,
    __in PACCESS_TOKEN Token,
    __in BOOLEAN CopyOnOpen,
    __in BOOLEAN EffectiveOnly,
    __in SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
#endif

// end_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
PsDisableImpersonation(
    __inout PETHREAD Thread,
    __inout PSE_IMPERSONATION_STATE ImpersonationState
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PsRestoreImpersonation(
    __inout PETHREAD Thread,
    __in PSE_IMPERSONATION_STATE ImpersonationState
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PsRevertToSelf(
    VOID
    );
#endif


NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
    __in HANDLE ProcessId,
    __deref_out PEPROCESS *Process
    );

NTKERNELAPI
NTSTATUS
PsLookupThreadByThreadId(
    __in HANDLE ThreadId,
    __deref_out PETHREAD *Thread
    );

//
// Quota Operations
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PsChargePoolQuota (
    __in PEPROCESS Process,
    __in POOL_TYPE PoolType,
    __in ULONG_PTR Amount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
PsChargeProcessPoolQuota (
    __in PEPROCESS Process,
    __in POOL_TYPE PoolType,
    __in ULONG_PTR Amount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PsReturnPoolQuota(
    __in PEPROCESS Process,
    __in POOL_TYPE PoolType,
    __in ULONG_PTR Amount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)  
NTKERNELAPI                         
BOOLEAN                             
PsIsSystemThread(                   
    __in PETHREAD Thread            
    );                              
#endif                              

#define IO_OPEN_PAGING_FILE             0x0002
#define IO_OPEN_TARGET_DIRECTORY        0x0004

#define IO_STOP_ON_SYMLINK              0x0008


#define IO_MM_PAGING_FILE               0x0010


//
// Define driver FS notification change routine type.
//

typedef
VOID
DRIVER_FS_NOTIFICATION (
    __in struct _DEVICE_OBJECT *DeviceObject,
    __in BOOLEAN FsActive
    );

typedef DRIVER_FS_NOTIFICATION *PDRIVER_FS_NOTIFICATION;


//
//  Valid values for FS_FILTER_PARAMETERS.AcquireForSectionSynchronization.SyncType
//

typedef enum _FS_FILTER_SECTION_SYNC_TYPE {
    SyncTypeOther = 0,
    SyncTypeCreateSection
} FS_FILTER_SECTION_SYNC_TYPE, *PFS_FILTER_SECTION_SYNC_TYPE;

//
//  Valid values for FS_FILTER_PARAMETERS.NotifyStreamFileObject.NotificationType
//

typedef enum _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {
    NotifyTypeCreate = 0,
    NotifyTypeRetired
} FS_FILTER_STREAM_FO_NOTIFICATION_TYPE, *PFS_FILTER_STREAM_FO_NOTIFICATION_TYPE;

//
//  Parameters union for the operations that
//  are exposed to the filters through the
//  FsFilterCallbacks registration mechanism.
//

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef union _FS_FILTER_PARAMETERS {

    //
    //  AcquireForModifiedPageWriter
    //

    struct {
        PLARGE_INTEGER EndingOffset;
        PERESOURCE *ResourceToRelease;
    } AcquireForModifiedPageWriter;

    //
    //  ReleaseForModifiedPageWriter
    //

    struct {
        PERESOURCE ResourceToRelease;
    } ReleaseForModifiedPageWriter;

    //
    //  AcquireForSectionSynchronization
    //

    struct {
        FS_FILTER_SECTION_SYNC_TYPE SyncType;
        ULONG PageProtection;
    } AcquireForSectionSynchronization;

    //
    //  NotifyStreamFileObjectCreation
    //

    struct {
        FS_FILTER_STREAM_FO_NOTIFICATION_TYPE NotificationType;
        BOOLEAN POINTER_ALIGNMENT SafeToRecurse;
    } NotifyStreamFileObject;

    //
    //  Other
    //

    struct {
        PVOID Argument1;
        PVOID Argument2;
        PVOID Argument3;
        PVOID Argument4;
        PVOID Argument5;
    } Others;

} FS_FILTER_PARAMETERS, *PFS_FILTER_PARAMETERS;

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

//
//  These are the valid values for the Operation field
//  of the FS_FILTER_CALLBACK_DATA structure.
//

#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION      (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION      (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                    (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                    (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                     (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                     (UCHAR)-6

typedef struct _FS_FILTER_CALLBACK_DATA {

    ULONG SizeOfFsFilterCallbackData;
    UCHAR Operation;
    UCHAR Reserved;

    struct _DEVICE_OBJECT *DeviceObject;
    struct _FILE_OBJECT *FileObject;

    FS_FILTER_PARAMETERS Parameters;

} FS_FILTER_CALLBACK_DATA, *PFS_FILTER_CALLBACK_DATA;

//
//  Prototype for the callbacks received before an operation
//  is passed to the base file system.
//
//  A filter can fail this operation, but consistant failure
//  will halt system progress.
//

typedef
NTSTATUS
(*PFS_FILTER_CALLBACK) (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    );

//
//  Prototype for the completion callback received after an
//  operation is completed.
//

typedef
VOID
(*PFS_FILTER_COMPLETION_CALLBACK) (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    );

//
//  This is the structure that the file system filter fills in to
//  receive notifications for these locking operations.
//
//  A filter should set the field to NULL for any notification callback
//  it doesn't wish to receive.
//

typedef struct _FS_FILTER_CALLBACKS {

    ULONG SizeOfFsFilterCallbacks;
    ULONG Reserved; //  For alignment

    PFS_FILTER_CALLBACK PreAcquireForSectionSynchronization;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForSectionSynchronization;
    PFS_FILTER_CALLBACK PreReleaseForSectionSynchronization;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForSectionSynchronization;
    PFS_FILTER_CALLBACK PreAcquireForCcFlush;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForCcFlush;
    PFS_FILTER_CALLBACK PreReleaseForCcFlush;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForCcFlush;
    PFS_FILTER_CALLBACK PreAcquireForModifiedPageWriter;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForModifiedPageWriter;
    PFS_FILTER_CALLBACK PreReleaseForModifiedPageWriter;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForModifiedPageWriter;

} FS_FILTER_CALLBACKS, *PFS_FILTER_CALLBACKS;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
FsRtlRegisterFileSystemFilterCallbacks (
    __in struct _DRIVER_OBJECT *FilterDriverObject,
    __in PFS_FILTER_CALLBACKS Callbacks
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
FsRtlNotifyStreamFileObject (
    IN struct _FILE_OBJECT * StreamFileObject,
    IN struct _DEVICE_OBJECT *DeviceObjectHint OPTIONAL,
    IN FS_FILTER_STREAM_FO_NOTIFICATION_TYPE NotificationType,
    IN BOOLEAN SafeToRecurse
    );
#endif // NTDDI_VERSION >= NTDDI_VISTA

#define DO_VERIFY_VOLUME                0x00000002      
#define DO_BUFFERED_IO                  0x00000004      
#define DO_EXCLUSIVE                    0x00000008      
#define DO_DIRECT_IO                    0x00000010      
#define DO_MAP_IO_BUFFER                0x00000020      
#define DO_DEVICE_HAS_NAME              0x00000040      
#define DO_DEVICE_INITIALIZING          0x00000080      
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      
#define DO_LONG_TERM_REQUESTS           0x00000200      
#define DO_NEVER_LAST_DEVICE            0x00000400      
#define DO_SHUTDOWN_REGISTERED          0x00000800      
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      
#define DO_POWER_PAGABLE                0x00002000      
#define DO_POWER_INRUSH                 0x00004000      
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      
#define DO_SUPPORTS_TRANSACTIONS        0x00040000      
#define DO_FORCE_NEITHER_IO             0x00080000      

//
// The following are global counters used by the I/O system to indicate the
// amount of I/O being performed in the system.  The first three counters
// are just that, counts of operations that have been requested, while the
// last three counters track the amount of data transferred for each type
// of I/O request.
//

extern KSPIN_LOCK IoStatisticsLock;
extern ULONG IoReadOperationCount;
extern ULONG IoWriteOperationCount;
extern ULONG IoOtherOperationCount;
extern LARGE_INTEGER IoReadTransferCount;
extern LARGE_INTEGER IoWriteTransferCount;
extern LARGE_INTEGER IoOtherTransferCount;

//
// It is difficult for cached file systems to properly charge quota
// for the storage that they allocate on behalf of user file handles,
// so the following amount of additional quota is charged against each
// handle as a "best guess" as to the amount of quota the file system
// will allocate on behalf of this handle.
//

//
// These numbers are totally arbitrary, and can be changed if it turns out
// that the file systems actually allocate more (or less) on behalf of
// their file objects.  The non-paged pool charge constant is added to the
// size of a FILE_OBJECT to get the actual charge amount.
//

#define IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE    64
#define IO_FILE_OBJECT_PAGED_POOL_CHARGE        1024



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoAcquireVpbSpinLock(
    __out PKIRQL Irql
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCheckDesiredAccess(
    __inout PACCESS_MASK DesiredAccess,
    __in ACCESS_MASK GrantedAccess
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCheckEaBufferValidity(
    __in  PFILE_FULL_EA_INFORMATION EaBuffer,
    __in  ULONG EaLength,
    __out PULONG ErrorOffset
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCheckFunctionAccess(
    __in ACCESS_MASK GrantedAccess,
    __in UCHAR MajorFunction,
    __in UCHAR MinorFunction,
    __in ULONG IoControlCode,
    __in_opt PVOID Arg1,
    __in_opt PVOID Arg2
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCheckQuerySetFileInformation(
    __in FILE_INFORMATION_CLASS FileInformationClass,
    __in ULONG Length,
    __in BOOLEAN SetOperation
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCheckQuerySetVolumeInformation(
    __in FS_INFORMATION_CLASS FsInformationClass,
    __in ULONG Length,
    __in BOOLEAN SetOperation
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCheckQuotaBufferValidity(
    __in  PFILE_QUOTA_INFORMATION QuotaBuffer,
    __in  ULONG QuotaLength,
    __out PULONG ErrorOffset
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObject(
    __in_opt PFILE_OBJECT FileObject,
    __in_opt PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObjectEx(
    __in_opt  PFILE_OBJECT FileObject,
    __in_opt  PDEVICE_OBJECT DeviceObject,
    __out_opt PHANDLE FileObjectHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObjectLite(
    __in_opt PFILE_OBJECT FileObject,
    __in_opt PDEVICE_OBJECT DeviceObject
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
IoFastQueryNetworkAttributes(
    __in  POBJECT_ATTRIBUTES ObjectAttributes,
    __in  ACCESS_MASK DesiredAccess,
    __in  ULONG OpenOptions,
    __out PIO_STATUS_BLOCK IoStatus,
    __out PFILE_NETWORK_OPEN_INFORMATION Buffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoPageRead(
    __in  PFILE_OBJECT FileObject,
    __in  PMDL MemoryDescriptorList,
    __in  PLARGE_INTEGER StartingOffset,
    __in  PKEVENT Event,
    __out PIO_STATUS_BLOCK IoStatusBlock
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PDEVICE_OBJECT
IoGetAttachedDevice(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)          // wdm
NTKERNELAPI                                 // wdm
PDEVICE_OBJECT                              // wdm
IoGetAttachedDeviceReference(               // wdm
    __in PDEVICE_OBJECT DeviceObject        // wdm
    );                                      // wdm
#endif                                      // wdm
                                            // wdm
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PDEVICE_OBJECT
IoGetBaseFileSystemDeviceObject(
    __in PFILE_OBJECT FileObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)          // ntddk
NTKERNELAPI                                 // ntddk ntosp
PCONFIGURATION_INFORMATION                  // ntddk ntosp
IoGetConfigurationInformation( VOID );      // ntddk ntosp
#endif                                      // ntddk


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
IoGetRequestorProcessId(
    __in PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PEPROCESS
IoGetRequestorProcess(
    __in PIRP Irp
    );
#endif

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIRP
IoGetTopLevelIrp(
    VOID
    );
#endif

// VOID
// IoInitializeTheadedDpcRequest(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIO_DPC_ROUTINE DpcRoutine
//     )
//
// begin_wdm
// Routine Description:
//
//     This routine is invoked to initialize the DPC in a device object for a
//     device driver during its initialization routine.  The DPC is used later
//     when the driver interrupt service routine requests that a DPC routine
//     be queued for later execution.
//
// Arguments:
//
//     DeviceObject - Pointer to the device object that the request is for.
//
//     DpcRoutine - Address of the driver's DPC routine to be executed when
//         the DPC is dequeued for processing.
//
// Return Value:
//
//     None.
//
//--
#define IoInitializeThreadedDpcRequest( DeviceObject, DpcRoutine ) (\
    KeInitializeThreadedDpc( &(DeviceObject)->Dpc,                  \
                     (PKDEFERRED_ROUTINE) (DpcRoutine),           \
                     (DeviceObject) ) )

//++
//
// BOOLEAN
// IoIsFileOpenedExclusively(
//     IN PFILE_OBJECT FileObject
//     )
//
// Routine Description:
//
//     This routine is invoked to determine whether the file open represented
//     by the specified file object is opened exclusively.
//
// Arguments:
//
//     FileObject - Pointer to the file object that represents the open instance
//         of the target file to be tested for exclusive access.
//
// Return Value:
//
//     The function value is TRUE if the open instance of the file is exclusive;
//     otherwise FALSE is returned.
//
//--

#define IoIsFileOpenedExclusively( FileObject ) (\
    (BOOLEAN) !((FileObject)->SharedRead || (FileObject)->SharedWrite || (FileObject)->SharedDelete))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
IoIsOperationSynchronous(
    __in PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
IoIsSystemThread(
    __in PETHREAD Thread
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
IoIsValidNameGraftingBuffer(
    __in PIRP Irp,
    __in PREPARSE_DATA_BUFFER ReparseBuffer
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoQueryFileDosDeviceName(
    __in  PFILE_OBJECT FileObject,
    __out POBJECT_NAME_INFORMATION *ObjectNameInformation
    );
#endif

// begin_ntosp
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoQueryFileInformation(
    __in  PFILE_OBJECT FileObject,
    __in  FILE_INFORMATION_CLASS FileInformationClass,
    __in  ULONG Length,
    __out PVOID FileInformation,
    __out PULONG ReturnedLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoQueryVolumeInformation(
    __in  PFILE_OBJECT FileObject,
    __in  FS_INFORMATION_CLASS FsInformationClass,
    __in  ULONG Length,
    __out PVOID FsInformation,
    __out PULONG ReturnedLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoQueueThreadIrp(
    __in PIRP Irp
    );
#endif

// end_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoRegisterFileSystem(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoRegisterFsRegistrationChange(
    __in PDRIVER_OBJECT DriverObject,
    __in PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    );
#endif

#if (NTDDI_VERSION == NTDDI_WIN2K)
//  This API only exists in W2K, it does not exist in any later OS
NTKERNELAPI
NTSTATUS
IoRegisterFsRegistrationChangeEx(
    __in PDRIVER_OBJECT DriverObject,
    __in PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
NTSTATUS
IoEnumerateRegisteredFiltersList(
    __out_bcount_part_opt(DriverObjectListSize,(*ActualNumberDriverObjects)*sizeof(PDRIVER_OBJECT)) PDRIVER_OBJECT *DriverObjectList,
    __in  ULONG  DriverObjectListSize,          //in bytes
    __out PULONG ActualNumberDriverObjects      //in elements
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoReleaseVpbSpinLock(
    __in KIRQL Irql
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoSetDeviceToVerify(
    __in PETHREAD Thread,
    __in PDEVICE_OBJECT DeviceObject
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoSetInformation(
    __in PFILE_OBJECT FileObject,
    __in FILE_INFORMATION_CLASS FileInformationClass,
    __in ULONG Length,
    __in PVOID FileInformation
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoSetTopLevelIrp(
    __in_opt PIRP Irp
    );
#endif


//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStartNextPacket(
    __in PDEVICE_OBJECT DeviceObject,
    __in BOOLEAN Cancelable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStartNextPacketByKey(
    __in PDEVICE_OBJECT DeviceObject,
    __in BOOLEAN Cancelable,
    __in ULONG Key
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStartPacket(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp,
    __in_opt PULONG Key,
    __in_opt PDRIVER_CANCEL CancelFunction
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
VOID
IoSetStartIoAttributes(
    __in PDEVICE_OBJECT DeviceObject,
    __in BOOLEAN DeferredStartIo,
    __in BOOLEAN NonCancelable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStartTimer(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStopTimer(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

// end_wdm end_ntosp
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoSynchronousPageWrite(
    __in  PFILE_OBJECT FileObject,
    __in  PMDL MemoryDescriptorList,
    __in  PLARGE_INTEGER StartingOffset,
    __in  PKEVENT Event,
    __out PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

// begin_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PEPROCESS
IoThreadToProcess(
    __in PETHREAD Thread
    );
#endif
// end_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoUnregisterFileSystem(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoUnregisterFsRegistrationChange(
    __in PDRIVER_OBJECT DriverObject,
    __in PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoVerifyVolume(
    __in PDEVICE_OBJECT DeviceObject,
    __in BOOLEAN AllowRawMount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)              // wdm
NTKERNELAPI                                     // wdm
VOID                                            // wdm
IoWriteErrorLogEntry(                           // wdm
    __in PVOID ElEntry                          // wdm
    );                                          // wdm
#endif                                          // wdm


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoGetRequestorSessionId(
    __in  PIRP Irp,
    __out PULONG pSessionId
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoEnumerateDeviceObjectList(
    __in  PDRIVER_OBJECT DriverObject,
    __out_bcount_part_opt(DeviceObjectListSize,(*ActualNumberDeviceObjects)*sizeof(PDEVICE_OBJECT)) PDEVICE_OBJECT *DeviceObjectList,
    __in  ULONG          DeviceObjectListSize,
    __out PULONG         ActualNumberDeviceObjects
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PDEVICE_OBJECT
IoGetLowerDeviceObject(
    __in  PDEVICE_OBJECT  DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoGetDiskDeviceObject(
    __in  PDEVICE_OBJECT FileSystemDeviceObject,
    __out PDEVICE_OBJECT *DiskDeviceObject
    );
#endif


//
//  IoPrioirityHint support
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _IO_PRIORITY_INFO {
    ULONG Size;
    ULONG ThreadPriority;
    ULONG PagePriority;
    IO_PRIORITY_HINT IoPriority;
} IO_PRIORITY_INFO, *PIO_PRIORITY_INFO;
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
FORCEINLINE
IoInitializePriorityInfo(
    __in PIO_PRIORITY_INFO PriorityInfo
    )
{
    PriorityInfo->Size = sizeof(IO_PRIORITY_INFO);
    PriorityInfo->ThreadPriority = 0xffff;
    PriorityInfo->IoPriority = IoPriorityNormal;
    PriorityInfo->PagePriority = 0;
}
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
PoRegisterSystemState (
    __inout_opt PVOID StateHandle,
    __in EXECUTION_STATE Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PoUnregisterSystemState (
    __in PVOID StateHandle
    );
#endif

// begin_nthal

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
POWER_STATE
PoSetPowerState (
    __in PDEVICE_OBJECT   DeviceObject,
    __in POWER_STATE_TYPE Type,
    __in POWER_STATE      State
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PoCallDriver (
    __in PDEVICE_OBJECT DeviceObject,
    __inout PIRP        Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PoStartNextPowerIrp(
    __in PIRP   Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PULONG
PoRegisterDeviceForIdleDetection (
    __in PDEVICE_OBJECT     DeviceObject,
    __in ULONG              ConservationIdleTime,
    __in ULONG              PerformanceIdleTime,
    __in DEVICE_POWER_STATE State
    );
#endif

#define PoSetDeviceBusy(IdlePointer) \
    *IdlePointer = 0
    
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
NTKERNELAPI
VOID
PoSetDeviceBusyEx (
    __inout PULONG IdlePointer
    );
#endif

typedef NTSTATUS (*PPOWER_SETTING_CALLBACK) (  
    IN LPCGUID SettingGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN PVOID Context
);

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
PoRegisterPowerSettingCallback (
    __in_opt PDEVICE_OBJECT         DeviceObject,
    __in LPCGUID                    SettingGuid,
    __in PPOWER_SETTING_CALLBACK    Callback,
    __in_opt PVOID                  Context,
    __out_opt PVOID                 * Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
PoUnregisterPowerSettingCallback(
    __inout PVOID   Handle
    );
#endif

//
// \Callback\PowerState values
//

#define PO_CB_SYSTEM_POWER_POLICY       0
#define PO_CB_AC_STATUS                 1
#define PO_CB_BUTTON_COLLISION          2
#define PO_CB_SYSTEM_STATE_LOCK         3
#define PO_CB_LID_SWITCH_STATE          4
#define PO_CB_PROCESSOR_POWER_POLICY    5

// end_ntddk end_wdm end_nthal

// Used for queuing work items to be performed at shutdown time.  Same
// rules apply as per Ex work queues.
#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
PoQueueShutdownWorkItem(
    __inout PWORK_QUEUE_ITEM    WorkItem
    );
#endif

#if defined(_IA64_)                             
                                                
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use GetDmaRequirement
NTHALAPI
ULONG
HalGetDmaAlignmentRequirement (
    VOID
    );
#endif

#endif                                          
                                                
#if defined(_M_IX86) || defined(_M_AMD64)       
                                                
#define HalGetDmaAlignmentRequirement() 1L      
#endif                                          
                                                

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
MmIsRecursiveIoFault(
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
MmForceSectionClosed (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in BOOLEAN DelayClose
    );
#endif


typedef enum _MMFLUSH_TYPE {
    MmFlushForDelete,
    MmFlushForWrite
} MMFLUSH_TYPE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
MmFlushImageSection (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in MMFLUSH_TYPE FlushType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
MmCanFileBeTruncated (
    __in PSECTION_OBJECT_POINTERS SectionPointer,
    __in_opt PLARGE_INTEGER NewFileSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
MmSetAddressRangeModified (
    __in_bcount (Length) PVOID Address,
    __in SIZE_T Length
    );
#endif


//
// Prefetch public interface.
//

typedef struct _READ_LIST {
    PFILE_OBJECT FileObject;
    ULONG NumberOfEntries;
    LOGICAL IsImage;
    FILE_SEGMENT_ELEMENT List[ANYSIZE_ARRAY];
} READ_LIST, *PREAD_LIST;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef union _MM_PREFETCH_FLAGS {
    struct {
        ULONG Priority : SYSTEM_PAGE_PRIORITY_BITS;
        ULONG RepurposePriority : SYSTEM_PAGE_PRIORITY_BITS;
    } Flags;
    ULONG AllFlags;

} MM_PREFETCH_FLAGS, *PMM_PREFETCH_FLAGS;

#define MM_PREFETCH_FLAGS_MASK  ((1 << (2*SYSTEM_PAGE_PRIORITY_BITS)) - 1)

NTKERNELAPI
NTSTATUS
MmPrefetchPages (
    __in ULONG NumberOfLists,
    __in_ecount (NumberOfLists) PREAD_LIST *ReadLists
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
//
//  This routine is used by local file systems to detect  the case where the
//  user has closed the file handles and the section handles, but still has
//  open writable views to the file
//

NTKERNELAPI
ULONG
MmDoesFileHaveUserWritableReferences (
    __in PSECTION_OBJECT_POINTERS SectionPointer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObInsertObject(
    __in PVOID Object,
    __inout_opt PACCESS_STATE PassedAccessState,
    __in_opt ACCESS_MASK DesiredAccess,
    __in ULONG ObjectPointerBias,
    __out_opt PVOID *NewObject,
    __out_opt PHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObOpenObjectByPointer(
    __in PVOID Object,
    __in ULONG HandleAttributes,
    __in_opt PACCESS_STATE PassedAccessState OPTIONAL,
    __in ACCESS_MASK DesiredAccess OPTIONAL,
    __in_opt POBJECT_TYPE ObjectType OPTIONAL,
    __in KPROCESSOR_MODE AccessMode,
    __out PHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ObMakeTemporaryObject(
    __in PVOID Object
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
ObDereferenceObjectDeferDelete(
    __in PVOID Object
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObQueryNameString(
    __in PVOID Object,
    __out_bcount_opt(Length) POBJECT_NAME_INFORMATION ObjectNameInfo,
    __in ULONG Length,
    __out PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
BOOLEAN
ObIsKernelHandle (
    __in HANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObQueryObjectAuditingByHandle(
    __in HANDLE Handle,
    __out PBOOLEAN GenerateOnClose
    );
#endif


//
//  The following are globally used definitions for an LBN and a VBN
//

typedef ULONG LBN;
typedef LBN *PLBN;

typedef ULONG VBN;
typedef VBN *PVBN;


//
//  Every file system that uses the cache manager must have FsContext
//  of the file object point to a common fcb header structure.
//

typedef enum _FAST_IO_POSSIBLE {
    FastIoIsNotPossible = 0,
    FastIoIsPossible,
    FastIoIsQuestionable
} FAST_IO_POSSIBLE;


typedef struct _FSRTL_COMMON_FCB_HEADER {

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    //  General flags available to FsRtl.
    //

    UCHAR Flags;

    //
    //  Indicates if fast I/O is possible or if we should be calling
    //  the check for fast I/O routine which is found via the driver
    //  object.
    //

    UCHAR IsFastIoPossible; // really type FAST_IO_POSSIBLE

    //
    //  Second Flags Field
    //

    UCHAR Flags2;

    //
    //  The following reserved field should always be 0
    //

    UCHAR Reserved : 4 ;

    //
    //  Indicates the version of this header
    //

    UCHAR Version : 4 ;

    PERESOURCE Resource;

    PERESOURCE PagingIoResource;

    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER FileSize;
    LARGE_INTEGER ValidDataLength;

} FSRTL_COMMON_FCB_HEADER;
typedef FSRTL_COMMON_FCB_HEADER *PFSRTL_COMMON_FCB_HEADER;


//
//  NodeTypeCode values used ranges
//
//  CDFS                    - 0x0300 - 0x033F
//  CLFS                    - 0x0400 - 0x043F
//  WINFS                   - 0x0440 - 0x047F
//  FASTFAT                 - 0x0500 - 0x053F
//  RAW                     - 0x0600 - 0x063F
//  NTFS                    - 0x0700 - 0x07FF
//  UDFS                    - 0x0900 - 0x093F
//  EXFAT                   - 0x0D00 - 0x0D3F
//                          - 0x8000 - 0xBFFF       reserved for 3rd party file systems
//  WIMFilter               - 0x1000 - 0x103F
//  NCFILTER                - 0x2200 - 0x223F       sample minifilter
//  RDBSS                   - 0xEB00 - 0xECFF
//  NULMRX                  - 0xFF00 - 0xFF3F       sample redirector



//
//  This Fcb header is used for files which support caching
//  of compressed data, and related new support.
//
//  We start out by prefixing this structure with the normal
//  FsRtl header from above, which we have to do two different
//  ways for c++ or c.
//

#ifdef __cplusplus
typedef struct _FSRTL_ADVANCED_FCB_HEADER:FSRTL_COMMON_FCB_HEADER {
#else   // __cplusplus

typedef struct _FSRTL_ADVANCED_FCB_HEADER {

    //
    //  Put in the standard FsRtl header fields
    //

    FSRTL_COMMON_FCB_HEADER DUMMYSTRUCTNAME;

#endif  // __cplusplus

    //
    //  The following two fields are supported only if
    //  Flags2 contains FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS
    //

    //
    //  This is a pointer to a Fast Mutex which may be used to
    //  properly synchronize access to the FsRtl header.  The
    //  Fast Mutex must be nonpaged.
    //

    PFAST_MUTEX FastMutex;

    //
    // This is a pointer to a list of stream context structures belonging to
    // filesystem filter drivers that are linked above the filesystem.
    // Each structure is headed by FSRTL_FILTER_CONTEXT.
    //

    LIST_ENTRY FilterContexts;

    //
    //  The following fields are valid only if the Version
    //  field in the FSRTL_COMMON_FCB_HEADER is greater than
    //  or equal to FSRTL_FCB_HEADER_V1
    //

    //
    //  This is a pushlock which is used to properly synchronize access
    //  to the list of stream contexts
    //

    EX_PUSH_LOCK PushLock;

    //
    //  This is a pointer to a blob of information that is
    //  associated with the opened file in the filesystem
    //  corresponding to the structure containing this
    //  FSRTL_ADVANCED_FCB_HEADER.
    //

    PVOID* FileContextSupportPointer;

} FSRTL_ADVANCED_FCB_HEADER;
typedef FSRTL_ADVANCED_FCB_HEADER *PFSRTL_ADVANCED_FCB_HEADER;

//
//  Define FsRtl common header versions
//

#define FSRTL_FCB_HEADER_V0             (0x00)
#define FSRTL_FCB_HEADER_V1             (0x01)


//
//  Define FsRtl common header flags
//

#define FSRTL_FLAG_FILE_MODIFIED        (0x01)
#define FSRTL_FLAG_FILE_LENGTH_CHANGED  (0x02)
#define FSRTL_FLAG_LIMIT_MODIFIED_PAGES (0x04)

//
//  Following flags determine how the modified page writer should
//  acquire the file.  These flags can't change while either resource
//  is acquired.  If neither of these flags is set then the
//  modified/mapped page writer will attempt to acquire the paging io
//  resource shared.
//

#define FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX (0x08)
#define FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH (0x10)

//
//  This flag will be set by the Cache Manager if a view is mapped
//  to a file.
//

#define FSRTL_FLAG_USER_MAPPED_FILE     (0x20)

//  This flag indicates that the file system is using the
//  FSRTL_ADVANCED_FCB_HEADER structure instead of the FSRTL_COMMON_FCB_HEADER
//  structure.
//

#define FSRTL_FLAG_ADVANCED_HEADER      (0x40)

//  This flag determines whether there currently is an Eof advance
//  in progress.  All such advances must be serialized.
//

#define FSRTL_FLAG_EOF_ADVANCE_ACTIVE   (0x80)

//
//  Flag values for Flags2
//
//  All unused bits are reserved and should NOT be modified.
//

//
//  If this flag is set, the Cache Manager will allow modified writing
//  in spite of the value of FsContext2.
//

#define FSRTL_FLAG2_DO_MODIFIED_WRITE        (0x01)

//
//  If this flag is set, the additional fields FilterContexts and FastMutex
//  are supported in FSRTL_COMMON_HEADER, and can be used to associate
//  context for filesystem filters with streams.
//

#define FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS  (0x02)

//
//  If this flag is set, the cache manager will flush and purge the cache map when
//  a user first maps a file
//

#define FSRTL_FLAG2_PURGE_WHEN_MAPPED (0x04)

//  If set this represents a PAGING file
//

#define FSRTL_FLAG2_IS_PAGING_FILE (0x08)


// begin_ntosp
//
//
//  The following constants are used to block top level Irp processing when
//  (in either the fast io or cc case) file system resources have been
//  acquired above the file system, or we are in an Fsp thread.
//

#define FSRTL_FSP_TOP_LEVEL_IRP         ((LONG_PTR)0x01)
#define FSRTL_CACHE_TOP_LEVEL_IRP       ((LONG_PTR)0x02)
#define FSRTL_MOD_WRITE_TOP_LEVEL_IRP   ((LONG_PTR)0x03)
#define FSRTL_FAST_IO_TOP_LEVEL_IRP     ((LONG_PTR)0x04)
#define FSRTL_NETWORK1_TOP_LEVEL_IRP    ((LONG_PTR)0x05)
#define FSRTL_NETWORK2_TOP_LEVEL_IRP    ((LONG_PTR)0x06)
#define FSRTL_MAX_TOP_LEVEL_IRP_FLAG    ((LONG_PTR)0xFFFF)

// end_ntosp

//
//  The following structure is used to synchronize Eof extends.
//

typedef struct _EOF_WAIT_BLOCK {

    LIST_ENTRY EofWaitLinks;
    KEVENT Event;

} EOF_WAIT_BLOCK;

typedef EOF_WAIT_BLOCK *PEOF_WAIT_BLOCK;

// begin_ntosp
//
//  Normal uncompressed Copy and Mdl Apis
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlCopyRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __out_bcount(Length) PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlCopyWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __in_bcount(Length) PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlMdlReadDev (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __deref_out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlMdlReadCompleteDev (
    __in PFILE_OBJECT FileObject,
    __in PMDL MdlChain,
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlPrepareMdlWriteDev (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __deref_out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlMdlWriteCompleteDev (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PMDL MdlChain,
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

//
//  In Irps, compressed reads and writes are  designated by the
//  subfunction IRP_MN_COMPRESSED must be set and the Compressed
//  Data Info buffer must be described by the following structure
//  pointed to by Irp->Tail.Overlay.AuxiliaryBuffer.
//

typedef struct _FSRTL_AUXILIARY_BUFFER {

    //
    //  Buffer description with length.
    //

    PVOID Buffer;
    ULONG Length;

    //
    //  Flags
    //

    ULONG Flags;

    //
    //  Pointer to optional Mdl mapping buffer for file system use
    //

    PMDL Mdl;

} FSRTL_AUXILIARY_BUFFER;
typedef FSRTL_AUXILIARY_BUFFER *PFSRTL_AUXILIARY_BUFFER;

//
//  If this flag is set, the auxiliary buffer structure is
//  deallocated on Irp completion.  The caller has the
//  option in this case of appending this structure to the
//  structure being described, causing it all to be
//  deallocated at once.  If this flag is clear, no deallocate
//  occurs.
//

#define FSRTL_AUXILIARY_FLAG_DEALLOCATE 0x00000001

//
//  The following two routines are called from NtCreateSection to avoid
//  deadlocks with the file systems.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlAcquireFileExclusive (
    __in PFILE_OBJECT FileObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlReleaseFile (
    __in PFILE_OBJECT FileObject
    );
#endif

//
//  These routines provide a simple interface for the common operations
//  of query/set file size.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSTATUS
FsRtlGetFileSize(
    __in PFILE_OBJECT FileObject,
    __out PLARGE_INTEGER FileSize
    );
#endif

//
// Determine if there is a complete device failure on an error.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlIsTotalDeviceFailure(
    __in NTSTATUS Status
    );
#endif

// end_ntddk end_ntosp

//
//  Byte range file lock routines, implemented in FileLock.c
//
//  The file lock info record is used to return enumerated information
//  about a file lock
//

typedef struct _FILE_LOCK_INFO {

    //
    //  A description of the current locked range, and if the lock
    //  is exclusive or shared
    //

    LARGE_INTEGER StartingByte;
    LARGE_INTEGER Length;
    BOOLEAN ExclusiveLock;

    //
    //  The following fields describe the owner of the lock.
    //

    ULONG Key;
    PFILE_OBJECT FileObject;
    PVOID ProcessId;

    //
    //  The following field is used internally by FsRtl
    //

    LARGE_INTEGER EndingByte;

} FILE_LOCK_INFO;
typedef FILE_LOCK_INFO *PFILE_LOCK_INFO;

//
//  The following two procedure prototypes are used by the caller of the
//  file lock package to supply an alternate routine to call when
//  completing an IRP and when unlocking a byte range.  Note that the only
//  utility to us this interface is currently the redirector, all other file
//  system will probably let the IRP complete normally with IoCompleteRequest.
//  The user supplied routine returns any value other than success then the
//  lock package will remove any lock that we just inserted.
//

typedef NTSTATUS (*PCOMPLETE_LOCK_IRP_ROUTINE) (
    __in PVOID Context,
    __in PIRP Irp
    );

typedef VOID (*PUNLOCK_ROUTINE) (
    __in PVOID Context,
    __in PFILE_LOCK_INFO FileLockInfo
    );

//
//  A FILE_LOCK is an opaque structure but we need to declare the size of
//  it here so that users can allocate space for one.
//

typedef struct _FILE_LOCK {

    //
    //  The optional procedure to call to complete a request
    //

    PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;

    //
    //  The optional procedure to call when unlocking a byte range
    //

    PUNLOCK_ROUTINE UnlockRoutine;

    //
    //  FastIoIsQuestionable is set to true whenever the filesystem require
    //  additional checking about whether the fast path can be taken.  As an
    //  example Ntfs requires checking for disk space before the writes can
    //  occur.
    //

    BOOLEAN FastIoIsQuestionable;
    BOOLEAN SpareC[3];

    //
    //  FsRtl lock information
    //

    PVOID   LockInformation;

    //
    //  Contains continuation information for FsRtlGetNextFileLock
    //

    FILE_LOCK_INFO  LastReturnedLockInfo;
    PVOID           LastReturnedLock;

} FILE_LOCK;
typedef FILE_LOCK *PFILE_LOCK;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PFILE_LOCK
FsRtlAllocateFileLock (
    __in_opt PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine,
    __in_opt PUNLOCK_ROUTINE UnlockRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlFreeFileLock (
    __in PFILE_LOCK FileLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlInitializeFileLock (
    __in PFILE_LOCK FileLock,
    __in_opt PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine,
    __in_opt PUNLOCK_ROUTINE UnlockRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlUninitializeFileLock (
    __in PFILE_LOCK FileLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlProcessFileLock (
    __in PFILE_LOCK FileLock,
    __in PIRP Irp,
    __in_opt PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlCheckLockForReadAccess (
    __in PFILE_LOCK FileLock,
    __in PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlCheckLockForWriteAccess (
    __in PFILE_LOCK FileLock,
    __in PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlFastCheckLockForRead (
    __in PFILE_LOCK FileLock,
    __in PLARGE_INTEGER StartingByte,
    __in PLARGE_INTEGER Length,
    __in ULONG Key,
    __in PFILE_OBJECT FileObject,
    __in PVOID ProcessId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlFastCheckLockForWrite (
    __in PFILE_LOCK FileLock,
    __in PLARGE_INTEGER StartingByte,
    __in PLARGE_INTEGER Length,
    __in ULONG Key,
    __in PVOID FileObject,
    __in PVOID ProcessId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PFILE_LOCK_INFO
FsRtlGetNextFileLock (
    __in PFILE_LOCK FileLock,
    __in BOOLEAN Restart
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlFastUnlockSingle (
    __in PFILE_LOCK FileLock,
    __in PFILE_OBJECT FileObject,
    __in LARGE_INTEGER UNALIGNED *FileOffset,
    __in PLARGE_INTEGER Length,
    __in PEPROCESS ProcessId,
    __in ULONG Key,
    __in_opt PVOID Context,
    __in BOOLEAN AlreadySynchronized
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlFastUnlockAll (
    __in PFILE_LOCK FileLock,
    __in PFILE_OBJECT FileObject,
    __in PEPROCESS ProcessId,
    __in_opt PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlFastUnlockAllByKey (
    __in PFILE_LOCK FileLock,
    __in PFILE_OBJECT FileObject,
    __in PEPROCESS ProcessId,
    __in ULONG Key,
    __in_opt PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlPrivateLock (
    __in PFILE_LOCK FileLock,
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PLARGE_INTEGER Length,
    __in PEPROCESS ProcessId,
    __in ULONG Key,
    __in BOOLEAN FailImmediately,
    __in BOOLEAN ExclusiveLock,
    __out PIO_STATUS_BLOCK Iosb,
    __in_opt PIRP Irp,
    __in_opt PVOID Context,
    __in BOOLEAN AlreadySynchronized
    );
#endif

//
//  BOOLEAN
//  FsRtlFastLock (
//      __in PFILE_LOCK FileLock,
//      __in PFILE_OBJECT FileObject,
//      __in PLARGE_INTEGER FileOffset,
//      __in PLARGE_INTEGER Length,
//      __in PEPROCESS ProcessId,
//      __in ULONG Key,
//      __in BOOLEAN FailImmediately,
//      __in BOOLEAN ExclusiveLock,
//      __out PIO_STATUS_BLOCK Iosb,
//      __in PVOID Context OPTIONAL,
//      __in BOOLEAN AlreadySynchronized
//      );
//

#define FsRtlFastLock(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11) ( \
    FsRtlPrivateLock( A1,   /* FileLock            */       \
                      A2,   /* FileObject          */       \
                      A3,   /* FileOffset          */       \
                      A4,   /* Length              */       \
                      A5,   /* ProcessId           */       \
                      A6,   /* Key                 */       \
                      A7,   /* FailImmediately     */       \
                      A8,   /* ExclusiveLock       */       \
                      A9,   /* Iosb                */       \
                      NULL, /* Irp                 */       \
                      A10,  /* Context             */       \
                      A11   /* AlreadySynchronized */ )     \
)

//
//  BOOLEAN
//  FsRtlAreThereCurrentFileLocks (
//      __in PFILE_LOCK FileLock
//      );
//

#define FsRtlAreThereCurrentFileLocks(FL) ( \
    ((FL)->FastIoIsQuestionable))



//
//  Filesystem property tunneling, implemented in tunnel.c
//

//
//  Tunnel cache structure
//

typedef struct {

    //
    //  Mutex for cache manipulation
    //

    FAST_MUTEX          Mutex;

    //
    //  Splay Tree of tunneled information keyed by
    //  DirKey ## Name
    //

    PRTL_SPLAY_LINKS    Cache;

    //
    //  Timer queue used to age entries out of the main cache
    //

    LIST_ENTRY          TimerQueue;

    //
    //  Keep track of the number of entries in the cache to prevent
    //  excessive use of memory
    //

    USHORT              NumEntries;

} TUNNEL, *PTUNNEL;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlInitializeTunnelCache (
    __in TUNNEL *Cache
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlAddToTunnelCache (
    __in TUNNEL *Cache,
    __in ULONGLONG DirectoryKey,
    __in UNICODE_STRING *ShortName,
    __in UNICODE_STRING *LongName,
    __in BOOLEAN KeyByShortName,
    __in ULONG DataLength,
    __in_bcount(DataLength) VOID *Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlFindInTunnelCache (
    __in TUNNEL *Cache,
    __in ULONGLONG DirectoryKey,
    __in UNICODE_STRING *Name,
    __out UNICODE_STRING *ShortName,
    __out UNICODE_STRING *LongName,
    __inout ULONG  *DataLength,
    __out_bcount_part(*DataLength, *DataLength) VOID *Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlDeleteKeyFromTunnelCache (
    __in TUNNEL *Cache,
    __in ULONGLONG DirectoryKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlDeleteTunnelCache (
    __in TUNNEL *Cache
    );
#endif


//
//  Dbcs name support routines, implemented in DbcsName.c
//

//
//  The following enumerated type is used to denote the result of name
//  comparisons
//

typedef enum _FSRTL_COMPARISON_RESULT {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} FSRTL_COMPARISON_RESULT;

#ifdef NLS_MB_CODE_PAGE_TAG
#undef NLS_MB_CODE_PAGE_TAG
#endif // NLS_MB_CODE_PAGE_TAG


#define LEGAL_ANSI_CHARACTER_ARRAY        (*FsRtlLegalAnsiCharacterArray) // ntosp
#define NLS_MB_CODE_PAGE_TAG              (*NlsMbOemCodePageTag)
#define NLS_OEM_LEAD_BYTE_INFO            (*NlsOemLeadByteInfo) // ntosp


extern UCHAR const* const LEGAL_ANSI_CHARACTER_ARRAY;
extern PUSHORT NLS_OEM_LEAD_BYTE_INFO;  // Lead byte info. for ACP

//
//  These following bit values are set in the FsRtlLegalDbcsCharacterArray
//

#define FSRTL_FAT_LEGAL         0x01
#define FSRTL_HPFS_LEGAL        0x02
#define FSRTL_NTFS_LEGAL        0x04
#define FSRTL_WILD_CHARACTER    0x08
#define FSRTL_OLE_LEGAL         0x10
#define FSRTL_NTFS_STREAM_LEGAL (FSRTL_NTFS_LEGAL | FSRTL_OLE_LEGAL)

//
//  The following macro is used to determine if an Ansi character is wild.
//

#define FsRtlIsAnsiCharacterWild(C) (                               \
    FsRtlTestAnsiCharacter((C), FALSE, FALSE, FSRTL_WILD_CHARACTER) \
)

//
//  The following macro is used to determine if an Ansi character is Fat legal.
//

#define FsRtlIsAnsiCharacterLegalFat(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_FAT_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is Hpfs legal.
//

#define FsRtlIsAnsiCharacterLegalHpfs(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_HPFS_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is Ntfs legal.
//

#define FsRtlIsAnsiCharacterLegalNtfs(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is
//  legal in an Ntfs stream name
//

#define FsRtlIsAnsiCharacterLegalNtfsStream(C,WILD_OK) (                    \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_STREAM_LEGAL)   \
)

//
//  The following macro is used to determine if an Ansi character is legal,
//  according to the caller's specification.
//

#define FsRtlIsAnsiCharacterLegal(C,FLAGS) (          \
    FsRtlTestAnsiCharacter((C), TRUE, FALSE, (FLAGS)) \
)

//
//  The following macro is used to test attributes of an Ansi character,
//  according to the caller's specified flags.
//

#define FsRtlTestAnsiCharacter(C, DEFAULT_RET, WILD_OK, FLAGS) (            \
        ((SCHAR)(C) < 0) ? DEFAULT_RET :                                    \
                           FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)],         \
                                   (FLAGS) |                                \
                                   ((WILD_OK) ? FSRTL_WILD_CHARACTER : 0) ) \
)


//
//  The following two macros use global data defined in ntos\rtl\nlsdata.c
//
//  BOOLEAN
//  FsRtlIsLeadDbcsCharacter (
//      __in UCHAR DbcsCharacter
//      );
//
//  /*++
//
//  Routine Description:
//
//      This routine takes the first bytes of a Dbcs character and
//      returns whether it is a lead byte in the system code page.
//
//  Arguments:
//
//      DbcsCharacter - Supplies the input character being examined
//
//  Return Value:
//
//      BOOLEAN - TRUE if the input character is a dbcs lead and
//              FALSE otherwise
//
//  --*/
//
//

#define FsRtlIsLeadDbcsCharacter(DBCS_CHAR) (                      \
    (BOOLEAN)((UCHAR)(DBCS_CHAR) < 0x80 ? FALSE :                  \
              (NLS_MB_CODE_PAGE_TAG &&                             \
               (NLS_OEM_LEAD_BYTE_INFO[(UCHAR)(DBCS_CHAR)] != 0))) \
)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlDissectDbcs (
    __in ANSI_STRING Path,
    __out PANSI_STRING FirstName,
    __out PANSI_STRING RemainingName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlDoesDbcsContainWildCards (
    __in PANSI_STRING Name
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlIsDbcsInExpression (
    __in PANSI_STRING Expression,
    __in PANSI_STRING Name
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlIsFatDbcsLegal (
    __in ANSI_STRING DbcsName,
    __in BOOLEAN WildCardsPermissible,
    __in BOOLEAN PathNamePermissible,
    __in BOOLEAN LeadingBackslashPermissible
    );
#endif

// end_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlIsHpfsDbcsLegal (
    __in ANSI_STRING DbcsName,
    __in BOOLEAN WildCardsPermissible,
    __in BOOLEAN PathNamePermissible,
    __in BOOLEAN LeadingBackslashPermissible
    );
#endif


//
//  Exception filter routines, implemented in Filter.c
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlNormalizeNtstatus (
    __in NTSTATUS Exception,
    __in NTSTATUS GenericException
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlIsNtstatusExpected (
    __in NTSTATUS Exception
    );
#endif

//
//  The following procedures are used to allocate executive pool and raise
//  insufficient resource status if pool isn't currently available.
//

#define FsRtlAllocatePoolWithTag(PoolType, NumberOfBytes, Tag)                \
    ExAllocatePoolWithTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \
                          NumberOfBytes,                                      \
                          Tag)


#define FsRtlAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, Tag)           \
    ExAllocatePoolWithQuotaTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \
                               NumberOfBytes,                                 \
                               Tag)

//
//  The following function allocates a resource from the FsRtl pool.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PERESOURCE
FsRtlAllocateResource (
    VOID
    );
#endif


//
//  Large Integer Mapped Control Blocks routines, implemented in LargeMcb.c
//
//  Originally this structure was truly opaque and code outside largemcb was
//  never allowed to examine or alter the structures.  However, for performance
//  reasons we want to allow ntfs the ability to quickly truncate down the
//  mcb without the overhead of an actual call to largemcb.c.  So to do that we
//  need to export the structure.  This structure is not exact.  The Mapping field
//  is declared here as a pvoid but largemcb.c it is a pointer to mapping pairs.
//

typedef struct _BASE_MCB {
    ULONG MaximumPairCount;
    ULONG PairCount;
    USHORT PoolType;
    USHORT Flags;
    PVOID Mapping;
} BASE_MCB;
typedef BASE_MCB *PBASE_MCB;

typedef struct _LARGE_MCB {
    PKGUARDED_MUTEX GuardedMutex;
    BASE_MCB BaseMcb;
} LARGE_MCB;
typedef LARGE_MCB *PLARGE_MCB;

#define MCB_FLAG_RAISE_ON_ALLOCATION_FAILURE 1

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlInitializeLargeMcb (
    __in PLARGE_MCB Mcb,
    __in POOL_TYPE PoolType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlUninitializeLargeMcb (
    __in PLARGE_MCB Mcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlResetLargeMcb (
    __in PLARGE_MCB Mcb,
    __in BOOLEAN SelfSynchronized
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlTruncateLargeMcb (
    __in PLARGE_MCB Mcb,
    __in LONGLONG Vbn
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlAddLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __in LONGLONG Vbn,
    __in LONGLONG Lbn,
    __in LONGLONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlRemoveLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __in LONGLONG Vbn,
    __in LONGLONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlLookupLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __in LONGLONG Vbn,
    __out_opt PLONGLONG Lbn,
    __out_opt PLONGLONG SectorCountFromLbn,
    __out_opt PLONGLONG StartingLbn,
    __out_opt PLONGLONG SectorCountFromStartingLbn,
    __out_opt PULONG Index
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlLookupLastLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __out PLONGLONG Vbn,
    __out PLONGLONG Lbn
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlLookupLastLargeMcbEntryAndIndex (
    __in PLARGE_MCB OpaqueMcb,
    __out PLONGLONG LargeVbn,
    __out PLONGLONG LargeLbn,
    __out PULONG Index
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
FsRtlNumberOfRunsInLargeMcb (
    __in PLARGE_MCB Mcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlGetNextLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __in ULONG RunIndex,
    __out PLONGLONG Vbn,
    __out PLONGLONG Lbn,
    __out PLONGLONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlSplitLargeMcb (
    __in PLARGE_MCB Mcb,
    __in LONGLONG Vbn,
    __in LONGLONG Amount
    );
#endif

//
//  Unsynchronzied base mcb functions. There is one of these for every
//  large mcb equivalent function - they are identical other than lack of
//  synchronization
//

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
VOID
FsRtlInitializeBaseMcb (
    __in PBASE_MCB Mcb,
    __in POOL_TYPE PoolType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
BOOLEAN
FsRtlInitializeBaseMcbEx (
    __in PBASE_MCB Mcb,
    __in POOL_TYPE PoolType,
    __in USHORT Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
VOID
FsRtlUninitializeBaseMcb (
    __in PBASE_MCB Mcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
VOID
FsRtlResetBaseMcb (
    __in PBASE_MCB Mcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
VOID
FsRtlTruncateBaseMcb (
    __in PBASE_MCB Mcb,
    __in LONGLONG Vbn
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FsRtlAddBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __in LONGLONG Vbn,
    __in LONGLONG Lbn,
    __in LONGLONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
FsRtlAddBaseMcbEntryEx (
    __in PBASE_MCB Mcb,
    __in LONGLONG Vbn,
    __in LONGLONG Lbn,
    __in LONGLONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FsRtlRemoveBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __in LONGLONG Vbn,
    __in LONGLONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FsRtlLookupBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __in LONGLONG Vbn,
    __out_opt PLONGLONG Lbn,
    __out_opt PLONGLONG SectorCountFromLbn,
    __out_opt PLONGLONG StartingLbn,
    __out_opt PLONGLONG SectorCountFromStartingLbn,
    __out_opt PULONG Index
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FsRtlLookupLastBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __out PLONGLONG Vbn,
    __out PLONGLONG Lbn
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FsRtlLookupLastBaseMcbEntryAndIndex (
    __in PBASE_MCB OpaqueMcb,
    __inout PLONGLONG LargeVbn,
    __inout PLONGLONG LargeLbn,
    __inout PULONG Index
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
ULONG
FsRtlNumberOfRunsInBaseMcb (
    __in PBASE_MCB Mcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FsRtlGetNextBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __in ULONG RunIndex,
    __out PLONGLONG Vbn,
    __out PLONGLONG Lbn,
    __out PLONGLONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FsRtlSplitBaseMcb (
    __in PBASE_MCB Mcb,
    __in LONGLONG Vbn,
    __in LONGLONG Amount
    );
#endif


//
//  Mapped Control Blocks routines, implemented in Mcb.c
//
//  An MCB is an opaque structure but we need to declare the size of
//  it here so that users can allocate space for one.  Consequently the
//  size computation here must be updated by hand if the MCB changes.
//

typedef struct _MCB {
    LARGE_MCB DummyFieldThatSizesThisStructureCorrectly;
} MCB;
typedef MCB *PMCB;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlInitializeMcb (
    __in PMCB Mcb,
    __in POOL_TYPE PoolType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlUninitializeMcb (
    __in PMCB Mcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlTruncateMcb (
    __in PMCB Mcb,
    __in VBN Vbn
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlAddMcbEntry (
    __in PMCB Mcb,
    __in VBN Vbn,
    __in LBN Lbn,
    __in ULONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlRemoveMcbEntry (
    __in PMCB Mcb,
    __in VBN Vbn,
    __in ULONG SectorCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlLookupMcbEntry (
    __in PMCB Mcb,
    __in VBN Vbn,
    __out PLBN Lbn,
    __out_opt PULONG SectorCount,
    __out PULONG Index
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlLookupLastMcbEntry (
    __in PMCB Mcb,
    __out PVBN Vbn,
    __out PLBN Lbn
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
FsRtlNumberOfRunsInMcb (
    __in PMCB Mcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlGetNextMcbEntry (
    __in PMCB Mcb,
    __in ULONG RunIndex,
    __out PVBN Vbn,
    __out PLBN Lbn,
    __out PULONG SectorCount
    );
#endif


//
//  Fault Tolerance routines, implemented in FaultTol.c
//
//  The routines in this package implement routines that help file
//  systems interact with the FT device drivers.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlBalanceReads (
    __in PDEVICE_OBJECT TargetDevice
    );
#endif


//
//  Oplock routines, implemented in Oplock.c
//
//  An OPLOCK is an opaque structure, we declare it as a PVOID and
//  allocate the actual memory only when needed.
//

typedef PVOID OPLOCK, *POPLOCK;

typedef
VOID
(*POPLOCK_WAIT_COMPLETE_ROUTINE) (
    __in PVOID Context,
    __in PIRP Irp
    );

typedef
VOID
(*POPLOCK_FS_PREPOST_IRP) (
    __in PVOID Context,
    __in PIRP Irp
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlInitializeOplock (
    __inout POPLOCK Oplock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlUninitializeOplock (
    __inout POPLOCK Oplock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlOplockFsctrl (
    __in POPLOCK Oplock,
    __in PIRP Irp,
    __in ULONG OpenCount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlCheckOplock (
    __in POPLOCK Oplock,
    __in PIRP Irp,
    __in_opt PVOID Context,
    __in_opt POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine,
    __in_opt POPLOCK_FS_PREPOST_IRP PostIrpRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTASP1)

#define OPLOCK_FLAG_COMPLETE_IF_OPLOCKED 0x00000001

NTKERNELAPI
NTSTATUS
FsRtlCheckOplockEx (
    __in POPLOCK Oplock,
    __in PIRP Irp,
    __in ULONG Flags,
    __in_opt PVOID Context,
    __in_opt POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine,
    __in_opt POPLOCK_FS_PREPOST_IRP PostIrpRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlOplockIsFastIoPossible (
    __in POPLOCK Oplock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlCurrentBatchOplock (
    __in POPLOCK Oplock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
BOOLEAN
FsRtlCurrentOplock (
    __in POPLOCK Oplock
    );

NTKERNELAPI
NTSTATUS
FsRtlOplockBreakToNone (
    __inout POPLOCK Oplock,
    __in PIO_STACK_LOCATION IrpSp,
    __in PIRP Irp,
    __in_opt PVOID Context,
    __in_opt POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine,
    __in_opt POPLOCK_FS_PREPOST_IRP PostIrpRoutine
    );
#endif



//
//  Volume lock/unlock notification routines, implemented in PnP.c
//
//  These routines provide PnP volume lock notification support
//  for all filesystems.
//

#define FSRTL_VOLUME_DISMOUNT           1
#define FSRTL_VOLUME_DISMOUNT_FAILED    2
#define FSRTL_VOLUME_LOCK               3
#define FSRTL_VOLUME_LOCK_FAILED        4
#define FSRTL_VOLUME_UNLOCK             5
#define FSRTL_VOLUME_MOUNT              6
#define FSRTL_VOLUME_NEEDS_CHKDSK       7
#define FSRTL_VOLUME_WORM_NEAR_FULL     8
#define FSRTL_VOLUME_WEARING_OUT        9
#define FSRTL_VOLUME_FORCED_CLOSED      10
#define FSRTL_VOLUME_INFO_MAKE_COMPAT   11
#define FSRTL_VOLUME_PREPARING_EJECT    12
#define FSRTL_VOLUME_CHANGE_SIZE        13

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlNotifyVolumeEvent (
    __in PFILE_OBJECT FileObject,
    __in ULONG EventCode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
FsRtlNotifyVolumeEventEx (
    __in PFILE_OBJECT FileObject,
    __in ULONG EventCode,
    __in PTARGET_DEVICE_CUSTOM_NOTIFICATION Event
    );
#endif


//
//  Notify Change routines, implemented in Notify.c
//
//  These routines provide Notify Change support for all filesystems.
//  Any of the 'Full' notify routines will support returning the
//  change information into the user's buffer.
//

typedef PVOID PNOTIFY_SYNC;

typedef
BOOLEAN (*PCHECK_FOR_TRAVERSE_ACCESS) (
    __in PVOID NotifyContext,
    __in_opt PVOID TargetContext,
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

typedef
BOOLEAN (*PFILTER_REPORT_CHANGE) (
    __in PVOID NotifyContext,
    __in PVOID FilterContext
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlNotifyInitializeSync (
    __in PNOTIFY_SYNC *NotifySync
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlNotifyUninitializeSync (
    __in PNOTIFY_SYNC *NotifySync
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlNotifyFullChangeDirectory (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PVOID FsContext,
    __in PSTRING FullDirectoryName,
    __in BOOLEAN WatchTree,
    __in BOOLEAN IgnoreBuffer,
    __in ULONG CompletionFilter,
    __in_opt PIRP NotifyIrp,
    __in_opt PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FsRtlNotifyFilterChangeDirectory (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PVOID FsContext,
    __in PSTRING FullDirectoryName,
    __in BOOLEAN WatchTree,
    __in BOOLEAN IgnoreBuffer,
    __in ULONG CompletionFilter,
    __in_opt PIRP NotifyIrp,
    __in_opt PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in_opt PFILTER_REPORT_CHANGE FilterCallback
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlNotifyFilterReportChange (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PSTRING FullTargetName,
    __in USHORT TargetNameOffset,
    __in_opt PSTRING StreamName,
    __in_opt PSTRING NormalizedParentName,
    __in ULONG FilterMatch,
    __in ULONG Action,
    __in_opt PVOID TargetContext,
    __in_opt PVOID FilterContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlNotifyFullReportChange (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PSTRING FullTargetName,
    __in USHORT TargetNameOffset,
    __in_opt PSTRING StreamName,
    __in_opt PSTRING NormalizedParentName,
    __in ULONG FilterMatch,
    __in ULONG Action,
    __in_opt PVOID TargetContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlNotifyCleanup (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PVOID FsContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
FsRtlNotifyCleanupAll (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList
    );
#endif


//
//  Unicode Name support routines, implemented in Name.c
//
//  The routines here are used to manipulate unicode names
//

//
//  The following macro is used to determine if a character is wild.
//

#define FsRtlIsUnicodeCharacterWild(C) (                                \
      (((C) >= 0x40) ? FALSE : FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)], \
                                       FSRTL_WILD_CHARACTER ) )         \
)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlDissectName (
    __in UNICODE_STRING Path,
    __out PUNICODE_STRING FirstName,
    __out PUNICODE_STRING RemainingName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlDoesNameContainWildCards (
    __in PUNICODE_STRING Name
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlAreNamesEqual (
    __in PCUNICODE_STRING ConstantNameA,
    __in PCUNICODE_STRING ConstantNameB,
    __in BOOLEAN IgnoreCase,
    __in_ecount_opt(0x10000) PCWCH UpcaseTable
    );
#endif

// begin_ntosp

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FsRtlIsNameInExpression (
    __in PUNICODE_STRING Expression,
    __in PUNICODE_STRING Name,
    __in BOOLEAN IgnoreCase,
    __in_opt PWCH UpcaseTable
    );
#endif

// end_ntosp


//
//  Stack Overflow support routine, implemented in StackOvf.c
//

typedef
VOID
(*PFSRTL_STACK_OVERFLOW_ROUTINE) (
    __in PVOID Context,
    __in PKEVENT Event
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlPostStackOverflow (
    __in PVOID Context,
    __in PKEVENT Event,
    __in PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlPostPagingFileStackOverflow (
    __in PVOID Context,
    __in PKEVENT Event,
    __in PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
    );
#endif


//
// UNC Provider support
//

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
//  Flags passed in to FsRtlRegisterUncProviderEx
//

#define FSRTL_UNC_PROVIDER_FLAGS_MAILSLOTS_SUPPORTED  0x1
#define FSRTL_UNC_PROVIDER_FLAGS_CSC_ENABLED          0x2

NTSTATUS
FsRtlRegisterUncProviderEx(
    __out PHANDLE MupHandle,
    __in PUNICODE_STRING RedirDevName,
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FsRtlRegisterUncProvider(
    __out PHANDLE MupHandle,
    __in PUNICODE_STRING RedirectorDeviceName,
    __in BOOLEAN MailslotsSupported
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlDeregisterUncProvider(
    __in HANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
NTSTATUS
FsRtlCancellableWaitForSingleObject(
    __in PVOID Object,
    __in_opt PLARGE_INTEGER Timeout,
    __in_opt PIRP Irp
    );

NTKERNELAPI
NTSTATUS
FsRtlCancellableWaitForMultipleObjects(
    __in ULONG Count,
    __in_ecount(Count) PVOID ObjectArray[],
    __in WAIT_TYPE WaitType,
    __in_opt PLARGE_INTEGER Timeout,
    __in_opt PKWAIT_BLOCK WaitBlockArray,
    __in_opt PIRP Irp
    );

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
//  For use by filter drivers to get information on provider corresponding to a given
//  fileobject on the remote filesystem stack. Without this, filters will always end up
//  getting \Device\Mup for providers registering with FsRtlRegisterUncProviderEx().
//


NTKERNELAPI
NTSTATUS
FsRtlMupGetProviderInfoFromFileObject(
    __in                        PFILE_OBJECT    pFileObject,
    __in                        ULONG           Level,
    __out_bcount(*pBufferSize)  PVOID           pBuffer,
    __inout                     PULONG          pBufferSize
    );

//
//  Format of output in pBuffer.
//

//
//  Level 1.
//


typedef struct _FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
    ULONG32         ProviderId;         // ID for quick comparison, stable across provider load/unload.

} FSRTL_MUP_PROVIDER_INFO_LEVEL_1, *PFSRTL_MUP_PROVIDER_INFO_LEVEL_1;

typedef struct _FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
    ULONG32         ProviderId;         // ID for quick comparison, stable across provider load/unload.
    UNICODE_STRING  ProviderName;       // Device name of provider.

} FSRTL_MUP_PROVIDER_INFO_LEVEL_2, *PFSRTL_MUP_PROVIDER_INFO_LEVEL_2;


NTKERNELAPI
NTSTATUS
FsRtlMupGetProviderIdFromName(
    __in    PUNICODE_STRING pProviderName,
    __out   PULONG32        pProviderId
    );


#endif



//
//  File System Filter PerFile Context Support
//

//
//  Filesystem filter drivers use these APIs to associate context
//  with open files (for filesystems that support this).
//

//
//  OwnerId should uniquely identify a particular filter driver
//  (e.g. the address of the driver's device object).
//  InstanceId can be used to distinguish distinct contexts associated
//  by a filter driver with a single file
//

//
//  This structure needs to be embedded within the users context that
//  they want to associate with a given file
//

typedef struct _FSRTL_PER_FILE_CONTEXT {
    //
    //  This is linked into the FileContext list maintained by the
    //  kernel
    //

    LIST_ENTRY Links;

    //
    //  A Unique ID for this filter (ex: address of Driver Object, Device
    //  Object, or Device Extension)
    //

    PVOID OwnerId;

    //
    //  An optional ID to differentiate different contexts for the same
    //  filter.
    //

    PVOID InstanceId;

    //
    //  A callback routine which is called by the underlying file system
    //  when the per-file structure is being torn down.  When this routine is called
    //  the given context has already been removed from the context linked
    //  list.  The callback routine cannot recursively call down into the
    //  filesystem or acquire any of their resources which they might hold
    //  when calling the filesystem outside of the callback.  This must
    //  be defined.
    //

    PFREE_FUNCTION FreeCallback;

} FSRTL_PER_FILE_CONTEXT, *PFSRTL_PER_FILE_CONTEXT;


//
//  This will initialize the given FSRTL_PER_FILE_CONTEXT structure.  This
//  should be used before calling "FsRtlInsertPerFileContext".
//

#define FsRtlInitPerFileContext( _fc, _owner, _inst, _cb)   \
    ((_fc)->OwnerId = (_owner),                               \
     (_fc)->InstanceId = (_inst),                             \
     (_fc)->FreeCallback = (_cb))

//
//  Given a FileObject this will return the FileContext pointer that
//  needs to be passed into the other FsRtl PerFile Context routines.
//  If the file system does not support filter file contexts then
//  NULL is returned
//

#define FsRtlGetPerFileContextPointer(_fo) \
    (FsRtlSupportsPerFileContexts(_fo) ? \
        FsRtlGetPerStreamContextPointer(_fo)->FileContextSupportPointer : \
        NULL)

//
//  This will test to see if PerFile contexts are supported for the given
//  FileObject
//

#define FsRtlSupportsPerFileContexts(_fo)                     \
    ((FsRtlGetPerStreamContextPointer(_fo) != NULL) &&        \
     (FsRtlGetPerStreamContextPointer(_fo)->Version >= FSRTL_FCB_HEADER_V1) &&  \
     (FsRtlGetPerStreamContextPointer(_fo)->FileContextSupportPointer != NULL))


//
//  Associate the context at Ptr with the given file.  The Ptr structure
//  should be filled in by the caller before calling this routine (see
//  FsRtlInitPerFileContext).  If the underlying filesystem does not support
//  filter file contexts, STATUS_INVALID_DEVICE_REQUEST will be returned.
//

NTKERNELAPI
NTSTATUS
FsRtlInsertPerFileContext (
    __in PVOID* PerFileContextPointer,
    __in PFSRTL_PER_FILE_CONTEXT Ptr
    );

//
//  Lookup a filter context associated with the file specified.  The first
//  context matching OwnerId (and InstanceId, if present) is returned.  By not
//  specifying InstanceId, a filter driver can search for any context that it
//  has previously associated with a stream.  If no matching context is found,
//  NULL is returned.  If the file system does not support filter contexts,
//  NULL is returned.
//


NTKERNELAPI
PFSRTL_PER_FILE_CONTEXT
FsRtlLookupPerFileContext (
    __in PVOID* PerFileContextPointer,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
    );


//
//  Normally, contexts should be deleted when the file system notifies the
//  filter that the file is being closed.  There are cases when a filter
//  may want to remove all existing contexts for a specific volume.  This
//  routine should be called at those times.  This routine should NOT be
//  called for the following cases:
//      - Inside your FreeCallback handler - The underlying file system has
//        already removed it from the linked list).
//      - Inside your IRP_CLOSE handler - If you do this then you will not
//        be notified when the stream is torn down.
//
//  This functions identically to FsRtlLookupPerFileContext, except that the
//  returned context has been removed from the list.
//

NTKERNELAPI
PFSRTL_PER_FILE_CONTEXT
FsRtlRemovePerFileContext (
    __in PVOID* PerFileContextPointer,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
    );


//
//  APIs for file systems to use for initializing and cleaning up
//  the Advaned FCB Header fields for PerStreamContext and
//  PerFileContext support
//

//
//  This will properly initialize the advanced header so that it can be
//  used with PerStream contexts and PerFile contexts.
//  Note:  A fast mutex must be placed in an advanced header.  It is the
//         caller's responsibility to properly create and initialize this
//         mutex before calling this macro.  The mutex field is only set
//         if a non-NULL value is passed in.
//  If the file system supports filter file contexts then it must
//  initialize the FileContextSupportPointer field to point to a PVOID
//  embedded in its per-file structure (FCB). If a NULL is passed in,
//  then the macro assumes that the file system does not support filter
//  file contexts
//

#define FsRtlSetupAdvancedHeaderEx( _advhdr, _fmutx, _fctxptr )                     \
{                                                                                   \
    FsRtlSetupAdvancedHeader( _advhdr, _fmutx );                                    \
    if ((_fctxptr) != NULL) {                                                       \
        (_advhdr)->FileContextSupportPointer = (_fctxptr);                          \
    }                                                                               \
}

//
//  File systems call this API to free any filter contexts still associated
//  with a per-file structure (FCB) that they are tearing down.
//  The FreeCallback routine for each filter context will be called.
//

NTKERNELAPI
VOID
FsRtlTeardownPerFileContexts (
    __in PVOID* PerFileContextPointer
    );


//
//  File System Filter PerStream Context Support
//

//
//  Filesystem filter drivers use these APIs to associate context
//  with open streams (for filesystems that support this).
//

//
//  OwnerId should uniquely identify a particular filter driver
//  (e.g. the address of the driver's device object).
//  InstanceId can be used to distinguish distinct contexts associated
//  by a filter driver with a single stream (e.g. the address of the
//  PerStream Context structure).
//

//
//  This structure needs to be embedded within the users context that
//  they want to associate with a given stream
//

typedef struct _FSRTL_PER_STREAM_CONTEXT {
    //
    //  This is linked into the StreamContext list inside the
    //  FSRTL_ADVANCED_FCB_HEADER structure.
    //

    LIST_ENTRY Links;

    //
    //  A Unique ID for this filter (ex: address of Driver Object, Device
    //  Object, or Device Extension)
    //

    PVOID OwnerId;

    //
    //  An optional ID to differentiate different contexts for the same
    //  filter.
    //

    PVOID InstanceId;

    //
    //  A callback routine which is called by the underlying file system
    //  when the stream is being torn down.  When this routine is called
    //  the given context has already been removed from the context linked
    //  list.  The callback routine cannot recursively call down into the
    //  filesystem or acquire any of their resources which they might hold
    //  when calling the filesystem outside of the callback.  This must
    //  be defined.
    //

    PFREE_FUNCTION FreeCallback;

} FSRTL_PER_STREAM_CONTEXT, *PFSRTL_PER_STREAM_CONTEXT;


//
//  This will initialize the given FSRTL_PER_STREAM_CONTEXT structure.  This
//  should be used before calling "FsRtlInsertPerStreamContext".
//

#define FsRtlInitPerStreamContext( _fc, _owner, _inst, _cb)   \
    ((_fc)->OwnerId = (_owner),                               \
     (_fc)->InstanceId = (_inst),                             \
     (_fc)->FreeCallback = (_cb))

//
//  Given a FileObject this will return the StreamContext pointer that
//  needs to be passed into the other FsRtl PerStream Context routines.
//

#define FsRtlGetPerStreamContextPointer(_fo) \
    ((PFSRTL_ADVANCED_FCB_HEADER)((_fo)->FsContext))

//
//  This will test to see if PerStream contexts are supported for the given
//  FileObject
//

#define FsRtlSupportsPerStreamContexts(_fo)                     \
    ((NULL != FsRtlGetPerStreamContextPointer(_fo)) &&          \
     FlagOn(FsRtlGetPerStreamContextPointer(_fo)->Flags2,       \
                    FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS))

//
//  Associate the context at Ptr with the given stream.  The Ptr structure
//  should be filled in by the caller before calling this routine (see
//  FsRtlInitPerStreamContext).  If the underlying filesystem does not support
//  filter contexts, STATUS_INVALID_DEVICE_REQUEST will be returned.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
FsRtlInsertPerStreamContext (
    __in PFSRTL_ADVANCED_FCB_HEADER PerStreamContext,
    __in PFSRTL_PER_STREAM_CONTEXT Ptr
    );
#endif

//
//  Lookup a filter context associated with the stream specified.  The first
//  context matching OwnerId (and InstanceId, if present) is returned.  By not
//  specifying InstanceId, a filter driver can search for any context that it
//  has previously associated with a stream.  If no matching context is found,
//  NULL is returned.  If the file system does not support filter contexts,
//  NULL is returned.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
FsRtlLookupPerStreamContextInternal (
    __in PFSRTL_ADVANCED_FCB_HEADER StreamContext,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
    );
#endif

#define FsRtlLookupPerStreamContext(_sc, _oid, _iid)                          \
 (((NULL != (_sc)) &&                                                         \
   FlagOn((_sc)->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS) &&              \
   !IsListEmpty(&(_sc)->FilterContexts)) ?                                    \
        FsRtlLookupPerStreamContextInternal((_sc), (_oid), (_iid)) :          \
        NULL)

//
//  Normally, contexts should be deleted when the file system notifies the
//  filter that the stream is being closed.  There are cases when a filter
//  may want to remove all existing contexts for a specific volume.  This
//  routine should be called at those times.  This routine should NOT be
//  called for the following cases:
//      - Inside your FreeCallback handler - The underlying file system has
//        already removed it from the linked list).
//      - Inside your IRP_CLOSE handler - If you do this then you will not
//        be notified when the stream is torn down.
//
//  This functions identically to FsRtlLookupPerStreamContext, except that the
//  returned context has been removed from the list.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
FsRtlRemovePerStreamContext (
    __in PFSRTL_ADVANCED_FCB_HEADER StreamContext,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
    );
#endif


//
//  APIs for file systems to use for initializing and cleaning up
//  the Advaned FCB Header fields for PerStreamContext support
//

//
//  This will properly initialize the advanced header so that it can be
//  used with PerStream contexts.
//  Note:  A fast mutex must be placed in an advanced header.  It is the
//         caller's responsibility to properly create and initialize this
//         mutex before calling this macro.  The mutex field is only set
//         if a non-NULL value is passed in.
//

#define FsRtlSetupAdvancedHeader( _advhdr, _fmutx )                         \
{                                                                           \
    SetFlag( (_advhdr)->Flags, FSRTL_FLAG_ADVANCED_HEADER );                \
    SetFlag( (_advhdr)->Flags2, FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS );     \
    (_advhdr)->Version = FSRTL_FCB_HEADER_V1;                               \
    InitializeListHead( &(_advhdr)->FilterContexts );                       \
    if ((_fmutx) != NULL) {                                                 \
        (_advhdr)->FastMutex = (_fmutx);                                    \
    }                                                                       \
    *((PULONG_PTR)(&(_advhdr)->PushLock)) = 0;                              \
    /*ExInitializePushLock( &(_advhdr)->PushLock ); API Not avaliable downlevel*/\
    (_advhdr)->FileContextSupportPointer = NULL;                            \
}

//
// File systems call this API to free any filter contexts still associated
// with an FSRTL_COMMON_FCB_HEADER that they are tearing down.
// The FreeCallback routine for each filter context will be called.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FsRtlTeardownPerStreamContexts (
    __in PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader
    );

//
//  Function pointer to above routine for modules that need to dynamically import
//

typedef VOID (*PFN_FSRTLTEARDOWNPERSTREAMCONTEXTS) (__in PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader);
#endif

//
//  File System Filter PerFileObject Context Support
//

//
//  Filesystem filter drivers use these APIs to associate context
//  with individual open files.  For now these are only supported on file
//  objects with a FileObject extension which are only created by using
//  IoCreateFileSpecifyDeviceObjectHint.
//

//
//  OwnerId should uniquely identify a particular filter driver
//  (e.g. the address of the driver's device object).
//  InstanceId can be used to distinguish distinct contexts associated
//  by a filter driver with a single stream (e.g. the address of the
//  fileobject).
//

//
//  This structure needs to be embedded within the users context that
//  they want to associate with a given stream
//

typedef struct _FSRTL_PER_FILEOBJECT_CONTEXT {
    //
    //  This is linked into the File Object
    //

    LIST_ENTRY Links;

    //
    //  A Unique ID for this filter (ex: address of Driver Object, Device
    //  Object, or Device Extension)
    //

    PVOID OwnerId;

    //
    //  An optional ID to differentiate different contexts for the same
    //  filter.
    //

    PVOID InstanceId;

} FSRTL_PER_FILEOBJECT_CONTEXT, *PFSRTL_PER_FILEOBJECT_CONTEXT;


//
//  This will initialize the given FSRTL_PER_FILEOBJECT_CONTEXT structure.  This
//  should be used before calling "FsRtlInsertPerFileObjectContext".
//

#define FsRtlInitPerFileObjectContext( _fc, _owner, _inst )         \
    ((_fc)->OwnerId = (_owner),                                     \
     (_fc)->InstanceId = (_inst))                                   \

//
//  Associate the context at Ptr with the given FileObject.  The Ptr
//  structure should be filled in by the caller before calling this
//  routine (see FsRtlInitPerFileObjectContext).  If this file object does not
//  support filter contexts, STATUS_INVALID_DEVICE_REQUEST will be returned.
//

NTKERNELAPI
NTSTATUS
FsRtlInsertPerFileObjectContext (
    __in PFILE_OBJECT FileObject,
    __in PFSRTL_PER_FILEOBJECT_CONTEXT Ptr
    );

//
//  Lookup a filter context associated with the FileObject specified.  The first
//  context matching OwnerId (and InstanceId, if present) is returned.  By not
//  specifying InstanceId, a filter driver can search for any context that it
//  has previously associated with a stream.  If no matching context is found,
//  NULL is returned.  If the FileObject does not support contexts,
//  NULL is returned.
//

NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
FsRtlLookupPerFileObjectContext (
    __in PFILE_OBJECT FileObject,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
    );

//
//  Normally, contexts should be deleted when the IoManager notifies the
//  filter that the FileObject is being freed.  There are cases when a filter
//  may want to remove all existing contexts for a specific volume.  This
//  routine should be called at those times.  This routine should NOT be
//  called for the following case:
//      - Inside your FreeCallback handler - The IoManager has already removed
//        it from the linked list.
//
//  This functions identically to FsRtlLookupPerFileObjectContext, except that
//  the returned context has been removed from the list.
//

NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
FsRtlRemovePerFileObjectContext (
    __in PFILE_OBJECT FileObject,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
    );

//++
//
//  VOID
//  FsRtlCompleteRequest (
//      __in PIRP Irp,
//      __in NTSTATUS Status
//      );
//
//  Routine Description:
//
//      This routine is used to complete an IRP with the indicated
//      status.  It does the necessary raise and lower of IRQL.
//
//  Arguments:
//
//      Irp - Supplies a pointer to the Irp to complete
//
//      Status - Supplies the completion status for the Irp
//
//  Return Value:
//
//      None.
//
//--

#define FsRtlCompleteRequest(IRP,STATUS) {         \
    (IRP)->IoStatus.Status = (STATUS);             \
    IoCompleteRequest( (IRP), IO_DISK_INCREMENT ); \
}


//++
//
//  VOID
//  FsRtlEnterFileSystem (
//      );
//
//  Routine Description:
//
//      This routine is used when entering a file system (e.g., through its
//      Fsd entry point).  It ensures that the file system cannot be suspended
//      while running and thus block other file I/O requests.  Upon exit
//      the file system must call FsRtlExitFileSystem.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//--

#define FsRtlEnterFileSystem() { \
    KeEnterCriticalRegion();     \
}

//++
//
//  VOID
//  FsRtlExitFileSystem (
//      );
//
//  Routine Description:
//
//      This routine is used when exiting a file system (e.g., through its
//      Fsd entry point).
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//--

#define FsRtlExitFileSystem() { \
    KeLeaveCriticalRegion();    \
}

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FsRtlIncrementCcFastReadNotPossible(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FsRtlIncrementCcFastReadWait(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FsRtlIncrementCcFastReadNoWait(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FsRtlIncrementCcFastReadResourceMiss(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
FsRtlIncrementCcFastMdlReadWait(
    VOID
    );
#endif

//
//  Returns TRUE if the given fileObject represents a paging file, returns
//  FALSE otherwise.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
LOGICAL
FsRtlIsPagingFile (
    __in PFILE_OBJECT FileObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
//
//  This routine is available on:
//  * Windows 2000 SP4 plus URP
//  * Windows XP SP2 plus QFE ?
//  * Windows Server 2003 SP1
//
NTKERNELAPI
NTSTATUS
FsRtlCreateSectionForDataScan(
    __out PHANDLE SectionHandle,
    __deref_out PVOID *SectionObject,
    __out_opt PLARGE_INTEGER SectionFileSize,
    __in PFILE_OBJECT FileObject,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PLARGE_INTEGER MaximumSize,
    __in ULONG SectionPageProtection,
    __in ULONG AllocationAttributes,
    __in ULONG Flags
    );
#endif

//
// Reparse Routines
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
FsRtlValidateReparsePointBuffer (
    __in ULONG BufferLength,
    __in_bcount(BufferLength) PREPARSE_DATA_BUFFER ReparseBuffer
);

NTKERNELAPI
NTSTATUS
FsRtlRemoveDotsFromPath(
    __inout_bcount(PathLength) PWSTR OriginalString,
    __in USHORT PathLength,
    __out USHORT *NewLength
);
#endif

// begin_ntosp
//////////////////////////////////////////////////////////////////////////
//
//              Extra Create Parameter Support routines
//
//  These routines are used when processing a create IRP to allow passing
//  extra information up and down the file system stack.  This is used by
//  file system filters, Client Side Encryption, Transactions etc.
//
//////////////////////////////////////////////////////////////////////////
#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _ECP_LIST *PECP_LIST;

//
//  Prototype for the ECP cleanup routine callback
//

typedef VOID
(*PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK) (
    __inout PVOID EcpContext,
    __in LPCGUID EcpType
    );

//
//  Basic ECP functions
//

//
//  Flags used by FsRtlAllocateExtraCreateParameterList
//

typedef ULONG FSRTL_ALLOCATE_ECPLIST_FLAGS;

    //
    //  Charge this memory against the quota of the current process
    //

    #define FSRTL_ALLOCATE_ECPLIST_FLAG_CHARGE_QUOTA    0x00000001


NTKERNELAPI
NTSTATUS
FsRtlAllocateExtraCreateParameterList (
    __in FSRTL_ALLOCATE_ECPLIST_FLAGS Flags,
    __deref_out PECP_LIST *EcpList
    );


NTKERNELAPI
VOID
FsRtlFreeExtraCreateParameterList (
    __in PECP_LIST EcpList
    );


//
//  Flags used by FsRtlAllocateExtraCreateParameter
//            and FsRtlAllocateExtraCreateParameterFromLookasideList
//

typedef ULONG FSRTL_ALLOCATE_ECP_FLAGS;

    //
    //  If set charage quota against the current process for this
    //  allocation.  This flag is ignored if using a lookaside list
    //

    #define FSRTL_ALLOCATE_ECP_FLAG_CHARGE_QUOTA    0x00000001

    //
    //  If set allocate the ECP from non-paged pool
    //  Else use paged pool
    //

    #define FSRTL_ALLOCATE_ECP_FLAG_NONPAGED_POOL   0x00000002


NTKERNELAPI
NTSTATUS
FsRtlAllocateExtraCreateParameter (
    __in LPCGUID EcpType,
    __in ULONG SizeOfContext,
    __in FSRTL_ALLOCATE_ECP_FLAGS Flags,
    __in_opt PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,
    __in ULONG PoolTag,
    __deref_out PVOID *EcpContext
    );


NTKERNELAPI
VOID
FsRtlFreeExtraCreateParameter (
    __in PVOID EcpContext
    );


//
//  Flags used by FsRtlInitExtraCreateParameterLookasideList
//

typedef ULONG FSRTL_ECP_LOOKASIDE_FLAGS;

    //
    //  If set this is a NON-PAGED lookaside list
    //  ELSE this is a PAGED lookaside list
    //

    #define FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL 0x00000002


NTKERNELAPI
VOID
FsRtlInitExtraCreateParameterLookasideList (
    __inout PVOID Lookaside,
    __in FSRTL_ECP_LOOKASIDE_FLAGS Flags,
    __in SIZE_T Size,
    __in ULONG Tag
    );

VOID
FsRtlDeleteExtraCreateParameterLookasideList (
    __inout PVOID Lookaside,
    __in FSRTL_ECP_LOOKASIDE_FLAGS Flags
    );

NTKERNELAPI
NTSTATUS
FsRtlAllocateExtraCreateParameterFromLookasideList (
    __in LPCGUID EcpType,
    __in_bound ULONG SizeOfContext,
    __in FSRTL_ALLOCATE_ECP_FLAGS Flags,
    __in_opt PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,
    __inout PVOID LookasideList,
    __deref_out PVOID *EcpContext
    );


NTKERNELAPI
NTSTATUS
FsRtlInsertExtraCreateParameter (
    __inout PECP_LIST EcpList,
    __inout PVOID EcpContext
    );


NTKERNELAPI
NTSTATUS
FsRtlFindExtraCreateParameter (
    __in PECP_LIST EcpList,
    __in LPCGUID EcpType,
    __deref_opt_out PVOID *EcpContext,
    __out_opt ULONG *EcpContextSize
    );


NTKERNELAPI
NTSTATUS
FsRtlRemoveExtraCreateParameter (
    __inout PECP_LIST EcpList,
    __in LPCGUID EcpType,
    __deref_out PVOID *EcpContext,
    __out_opt ULONG *EcpContextSize
    );

//
//  Functions to get and set Extra Create Parameters into/out of a create IRP
//


NTKERNELAPI
NTSTATUS
FsRtlGetEcpListFromIrp (
    __in PIRP Irp,
    __deref_out PECP_LIST *EcpList
    );


NTKERNELAPI
NTSTATUS
FsRtlSetEcpListIntoIrp (
    __inout PIRP Irp,
    __in PECP_LIST EcpList
    );


//
//   Additional functions used for full functionality
//


NTKERNELAPI
NTSTATUS
FsRtlGetNextExtraCreateParameter (
    __in PECP_LIST EcpList,
    __in_opt PVOID CurrentEcpContext,
    __out_opt LPGUID NextEcpType,
    __deref_opt_out PVOID *NextEcpContext,
    __out_opt ULONG *NextEcpContextSize
    );


NTKERNELAPI
VOID
FsRtlAcknowledgeEcp (
    __in PVOID EcpContext
    );


NTKERNELAPI
BOOLEAN
FsRtlIsEcpAcknowledged (
    __in PVOID EcpContext
    );


NTKERNELAPI
BOOLEAN
FsRtlIsEcpFromUserMode (
    __in PVOID EcpContext
    );
#endif //(NTDDI_VERSION >= NTDDI_VISTA)

// end_ntosp

//////////////////////////////////////////////////////////////////////////////
//
//      This contains public ECP definitions
//
//////////////////////////////////////////////////////////////////////////////
#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// Start of NETWORK_OPEN_ECP_CONTEXT structures and definitions.
// This ECP can be used as a way to pass extra information at create time
// to network redirectors.
//

typedef enum {

    NetworkOpenLocationAny,         // No restrictions.
    NetworkOpenLocationRemote,      // Restrict to remote only.
    NetworkOpenLocationLoopback     // Restrict to local-machine only.

} NETWORK_OPEN_LOCATION_QUALIFIER;


typedef enum {

    NetworkOpenIntegrityAny,        // No restrictions on signing/encryption etc.
    NetworkOpenIntegrityNone,       // No signing/encryption.
    NetworkOpenIntegritySigned,     // Signed end to end.
    NetworkOpenIntegrityEncrypted,  // encrypted end-end.
    NetworkOpenIntegrityMaximum     // Best available.

} NETWORK_OPEN_INTEGRITY_QUALIFIER;

//
// ECP context for network create parameters.
//

typedef struct _NETWORK_OPEN_ECP_CONTEXT {

    USHORT Size;        // Must be set to the size of this structure.
    USHORT Reserved;    // Must be set to zero.

    struct {

        //
        // Pre-create restrictions
        //

        struct {

            NETWORK_OPEN_LOCATION_QUALIFIER Location;
            NETWORK_OPEN_INTEGRITY_QUALIFIER Integrity;

        } in;

        //
        // Post create information returned to the caller.
        //

        struct {

            NETWORK_OPEN_LOCATION_QUALIFIER Location;
            NETWORK_OPEN_INTEGRITY_QUALIFIER Integrity;

        } out;

    } DUMMYSTRUCTNAME;

} NETWORK_OPEN_ECP_CONTEXT, *PNETWORK_OPEN_ECP_CONTEXT;

//
//  The GUID used for the NETWORK_OPEN_ECP_CONTEXT structure
//

DEFINE_GUID( GUID_ECP_NETWORK_OPEN_CONTEXT, 0xc584edbf, 0x00df, 0x4d28, 0xb8, 0x84, 0x35, 0xba, 0xca, 0x89, 0x11, 0xe8 );

//
// End NETWORK_OPEN_ECP_CONTEXT definitions
//

//
// Start of PREFETCH_OPEN_ECP_CONTEXT structures and definitions.
// This ECP is used to communicate the fact that a given open request is done
// by the prefetcher.
//

//
// ECP structure for prefetcher opens.
//

typedef struct _PREFETCH_OPEN_ECP_CONTEXT {

    PVOID Context;      // Opaque context associated with the open.

} PREFETCH_OPEN_ECP_CONTEXT, *PPREFETCH_OPEN_ECP_CONTEXT;

//
//  The GUID used for the PREFETCH_OPEN_ECP_CONTEXT structure
//

DEFINE_GUID( GUID_ECP_PREFETCH_OPEN, 0xe1777b21, 0x847e, 0x4837, 0xaa, 0x45, 0x64, 0x16, 0x1d, 0x28, 0x6, 0x55 );

//
// End PREFETCH_OPEN_ECP_CONTEXT definitions
//


#endif //(NTDDI_VERSION >= NTDDI_VISTA)


//
//  This routine allows the caller to change the referenced file object that
//  is pointed to by either:
//  - One of Mm's image control areas for this stream
//  - Mm's data control area for this stream
//  - Cc's shared cache map for this stream
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef enum _FSRTL_CHANGE_BACKING_TYPE {

    ChangeDataControlArea,
    ChangeImageControlArea,
    ChangeSharedCacheMap

} FSRTL_CHANGE_BACKING_TYPE, *PFSRTL_CHANGE_BACKING_TYPE;

NTKERNELAPI
NTSTATUS
FsRtlChangeBackingFileObject (
    __in_opt PFILE_OBJECT CurrentFileObject,
    __in PFILE_OBJECT NewFileObject,
    __in FSRTL_CHANGE_BACKING_TYPE ChangeBackingType,
    __in ULONG Flags                //reserved, must be zero
    );

#endif

//
// Flags for FsRtlLogCcFlushError
//

#define FSRTL_CC_FLUSH_ERROR_FLAG_NO_HARD_ERROR  0x1
#define FSRTL_CC_FLUSH_ERROR_FLAG_NO_LOG_ENTRY   0x2

#if (NTDDI_VERSION >= NTDDI_VISTA)

NTKERNELAPI
NTSTATUS
FsRtlLogCcFlushError(
    __in PUNICODE_STRING FileName,
    __in PDEVICE_OBJECT DeviceObject,
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in NTSTATUS FlushError,
    __in ULONG Flags
    );

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
//  Routine to query whether volume startup application such as autochk
//  have completed.
//

NTKERNELAPI
BOOLEAN
FsRtlAreVolumeStartupApplicationsComplete(
    VOID
    );

#endif

//
//  Define two constants describing the view size (and alignment)
//  that the Cache Manager uses to map files.
//

#define VACB_MAPPING_GRANULARITY         (0x40000)
#define VACB_OFFSET_SHIFT                (18)

//
// Public portion of BCB
//

typedef struct _PUBLIC_BCB {

    //
    // Type and size of this record
    //
    // NOTE: The first four fields must be the same as the BCB in cc.h.
    //

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    // Description of range of file which is currently mapped.
    //

    ULONG MappedLength;
    LARGE_INTEGER MappedFileOffset;
} PUBLIC_BCB, *PPUBLIC_BCB;

//
//  File Sizes structure.
//

typedef struct _CC_FILE_SIZES {

    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER FileSize;
    LARGE_INTEGER ValidDataLength;

} CC_FILE_SIZES, *PCC_FILE_SIZES;

//
// Define a Cache Manager callback structure.  These routines are required
// by the Lazy Writer, so that it can acquire resources in the right order
// to avoid deadlocks.  Note that otherwise you would have most FS requests
// acquiring FS resources first and caching structures second, while the
// Lazy Writer needs to acquire its own resources first, and then FS
// structures later as it calls the file system.
//

//
// First define the procedure pointer typedefs
//

//
// This routine is called by the Lazy Writer prior to doing a write,
// since this will require some file system resources associated with
// this cached file. The context parameter supplied is whatever the FS
// passed as the LazyWriteContext parameter when is called
// CcInitializeCacheMap.
//

typedef
BOOLEAN (*PACQUIRE_FOR_LAZY_WRITE) (
     __in PVOID Context,
     __in BOOLEAN Wait
     );

//
// This routine releases the Context acquired above.
//

typedef
VOID (*PRELEASE_FROM_LAZY_WRITE) (
     __in PVOID Context
     );

//
// This routine is called by the Lazy Writer prior to doing a readahead.
//

typedef
BOOLEAN (*PACQUIRE_FOR_READ_AHEAD) (
     __in PVOID Context,
     __in BOOLEAN Wait
     );

//
// This routine releases the Context acquired above.
//

typedef
VOID (*PRELEASE_FROM_READ_AHEAD) (
     __in PVOID Context
     );

typedef struct _CACHE_MANAGER_CALLBACKS {

    PACQUIRE_FOR_LAZY_WRITE AcquireForLazyWrite;
    PRELEASE_FROM_LAZY_WRITE ReleaseFromLazyWrite;
    PACQUIRE_FOR_READ_AHEAD AcquireForReadAhead;
    PRELEASE_FROM_READ_AHEAD ReleaseFromReadAhead;

} CACHE_MANAGER_CALLBACKS, *PCACHE_MANAGER_CALLBACKS;

//
//  This structure is passed into CcUninitializeCacheMap
//  if the caller wants to know when the cache map is deleted.
//

typedef struct _CACHE_UNINITIALIZE_EVENT {
    struct _CACHE_UNINITIALIZE_EVENT *Next;
    KEVENT Event;
} CACHE_UNINITIALIZE_EVENT, *PCACHE_UNINITIALIZE_EVENT;

//
// Callback routine for retrieving dirty pages from Cache Manager.
//

typedef
VOID (*PDIRTY_PAGE_ROUTINE) (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in PLARGE_INTEGER OldestLsn,
    __in PLARGE_INTEGER NewestLsn,
    __in PVOID Context1,
    __in PVOID Context2
    );

//
// Callback routine for doing log file flushes to Lsn.
//

typedef
VOID (*PFLUSH_TO_LSN) (
    __in PVOID LogHandle,
    __in LARGE_INTEGER Lsn
    );

//
// Macro to test whether a file is cached or not.
//

#define CcIsFileCached(FO) (                                                         \
    ((FO)->SectionObjectPointer != NULL) &&                                          \
    (((PSECTION_OBJECT_POINTERS)(FO)->SectionObjectPointer)->SharedCacheMap != NULL) \
)

extern ULONG CcFastMdlReadWait;             
//
// The following routines are intended for use by File Systems Only.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcInitializeCacheMap (
    __in PFILE_OBJECT FileObject,
    __in PCC_FILE_SIZES FileSizes,
    __in BOOLEAN PinAccess,
    __in PCACHE_MANAGER_CALLBACKS Callbacks,
    __in PVOID LazyWriteContext
    );
#endif    

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcUninitializeCacheMap (
    __in PFILE_OBJECT FileObject,
    __in_opt PLARGE_INTEGER TruncateSize,
    __in_opt PCACHE_UNINITIALIZE_EVENT UninitializeEvent
    );
#endif    

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcSetFileSizes (
    __in PFILE_OBJECT FileObject,
    __in PCC_FILE_SIZES FileSizes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
CcSetFileSizesEx (
    __in PFILE_OBJECT FileObject,
    __in PCC_FILE_SIZES FileSizes
    );
#endif

#define CcGetFileSizePointer(FO) (                                     \
    ((PLARGE_INTEGER)((FO)->SectionObjectPointer->SharedCacheMap) + 1) \
)

//
//  Flags for CcPurgeCacheSection
//

//
//  UNINITIALIZE_CACHE_MAPS - All private cache maps will be uninitialized 
//     before purging the data.  This pattern may be specified as TRUE.
//

#define UNINITIALIZE_CACHE_MAPS          (1)

//
//  DO_NOT_RETRY_PURGE - CcPurgeCacheSection will not retry purging the file
//     on purge failure even if Mm says the file can be truncated.  The return 
//     value will specify whether or not the purge succeeded.
//

#define DO_NOT_RETRY_PURGE               (2)

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
BOOLEAN
CcPurgeCacheSection (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in_opt PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG Flags
    );

#elif (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
BOOLEAN
CcPurgeCacheSection (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in_opt PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN UninitializeCacheMaps
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcSetDirtyPageThreshold (
    __in PFILE_OBJECT FileObject,
    __in ULONG DirtyPageThreshold
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcFlushCache (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in_opt PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __out_opt PIO_STATUS_BLOCK IoStatus
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LARGE_INTEGER
CcGetFlushedValidData (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in BOOLEAN BcbListHeld
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcZeroData (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER StartOffset,
    __in PLARGE_INTEGER EndOffset,
    __in BOOLEAN Wait
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
CcRemapBcb (
    __in PVOID Bcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcRepinBcb (
    __in PVOID Bcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcUnpinRepinnedBcb (
    __in PVOID Bcb,
    __in BOOLEAN WriteThrough,
    __out PIO_STATUS_BLOCK IoStatus
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PFILE_OBJECT
CcGetFileObjectFromSectionPtrs (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
PFILE_OBJECT
CcGetFileObjectFromSectionPtrsRef (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PFILE_OBJECT
CcGetFileObjectFromBcb (
    __in PVOID Bcb
    );
#endif


//
// These routines are implemented to support write throttling.
//

//
//  BOOLEAN
//  CcCopyWriteWontFlush (
//      IN PFILE_OBJECT FileObject,
//      IN PLARGE_INTEGER FileOffset,
//      IN ULONG Length
//      );
//

#define CcCopyWriteWontFlush(FO,FOFF,LEN) ((LEN) <= 0X10000)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcCanIWrite (
    __in PFILE_OBJECT FileObject,
    __in ULONG BytesToWrite,
    __in BOOLEAN Wait,
    __in UCHAR Retrying
    );
#endif

typedef
VOID (*PCC_POST_DEFERRED_WRITE) (
    __in PVOID Context1,
    __in PVOID Context2
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcDeferWrite (
    __in PFILE_OBJECT FileObject,
    __in PCC_POST_DEFERRED_WRITE PostRoutine,
    __in PVOID Context1,
    __in PVOID Context2,
    __in ULONG BytesToWrite,
    __in BOOLEAN Retrying
    );
#endif

//
// The following routines provide a data copy interface to the cache, and
// are intended for use by File Servers and File Systems.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcCopyRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __out_bcount(Length) PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcFastCopyRead (
    __in PFILE_OBJECT FileObject,
    __in ULONG FileOffset,
    __in ULONG Length,
    __in ULONG PageCount,
    __out_bcount(Length) PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus
    );
#endif    

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcCopyWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in_bcount(Length) PVOID Buffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcFastCopyWrite (
    __in PFILE_OBJECT FileObject,
    __in ULONG FileOffset,
    __in ULONG Length,
    __in_bcount(Length) PVOID Buffer
    );
#endif

//
//  The following routines provide an Mdl interface for transfers to and
//  from the cache, and are primarily intended for File Servers.
//
//  NOBODY SHOULD BE CALLING THESE MDL ROUTINES DIRECTLY, USE FSRTL AND
//  FASTIO INTERFACES.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcMdlRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus
    );
#endif

//
//  This routine is now a wrapper for FastIo if present or CcMdlReadComplete2
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcMdlReadComplete (
    __in PFILE_OBJECT FileObject,
    __in PMDL MdlChain
    );
#endif
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcPrepareMdlWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus
    );
#endif
//
//  This routine is now a wrapper for FastIo if present or CcMdlWriteComplete2
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcMdlWriteComplete (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PMDL MdlChain
    );
#endif    

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
CcMdlWriteAbort (
    __in PFILE_OBJECT FileObject,
    __in PMDL MdlChain
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP

//
// Common ReadAhead call for Copy Read and Mdl Read.
//
// ReadAhead should always be invoked by calling the CcReadAhead macro,
// which tests first to see if the read is large enough to warrant read
// ahead.  Measurements have shown that, calling the read ahead routine
// actually decreases performance for small reads, such as issued by
// many compilers and linkers.  Compilers simply want all of the include
// files to stay in memory after being read the first time.
//

#define CcReadAhead(FO,FOFF,LEN) {                       \
    if ((LEN) >= 256) {                                  \
        CcScheduleReadAhead((FO),(FOFF),(LEN));          \
    }                                                    \
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcScheduleReadAhead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length
    );
#endif

//
//  The following routine allows a caller to wait for the next batch
//  of lazy writer work to complete.  In particular, this provides a
//  mechanism for a caller to be sure that all avaliable lazy closes
//  at the time of this call have issued.
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
CcWaitForCurrentLazyWriterActivity (
    VOID
    );
#endif

//
// This routine changes the read ahead granularity for a file, which is
// PAGE_SIZE by default.
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcSetReadAheadGranularity (
    __in PFILE_OBJECT FileObject,
    __in ULONG Granularity
    );
#endif

//
// The following routines provide direct access data which is pinned in the
// cache, and is primarily intended for use by File Systems.  In particular,
// this mode of access is ideal for dealing with volume structures.
//

//
//  Flags for pinning 
//
//  Note: The flags for pinning and the flags for mapping cannot overlap unless
//     the flag has the same meaning.
//

//
//  Synchronous Wait - normally specified.  This pattern may be specified as TRUE.
//

#define PIN_WAIT                         (1)

//
//  Acquire metadata Bcb exclusive (default is shared, Lazy Writer uses exclusive).
//
//  Must be set with PIN_WAIT.
//

#define PIN_EXCLUSIVE                    (2)

//
//  Acquire metadata Bcb but do not fault data in.  Default is to fault the data in.
//  This unusual flag is only used by Ntfs for cache coherency synchronization between
//  compressed and uncompressed streams for the same compressed file.
//
//  Must be set with PIN_WAIT.
//

#define PIN_NO_READ                      (4)

//
//  This option may be used to pin data only if the Bcb already exists.  If the Bcb
//  does not already exist - the pin is unsuccessful and no Bcb is returned.  This routine
//  provides a way to see if data is already pinned (and possibly dirty) in the cache,
//  without forcing a fault if the data is not there.
//

#define PIN_IF_BCB                       (8)

//
//  If this option is specified, the caller is responsible for tracking the
//  dirty ranges and calling MmSetAddressRangeModified on these ranges before
//  they are flushed.  Ranges should only be pinned via this manner if the
//  entire range will be written or purged (one or the other must occur).
//

#define PIN_CALLER_TRACKS_DIRTY_DATA      (32)

//
//  If this option is specified, Cc will used reserved views to map the data
//  requested if Mm has no views to give Cc at the time of mapping the data.
//  This flag should only be used for critical data, like file system metadata
//  or other data critical to the file system remaining consistent.  This is 
//  a best effort attempt to ensure that we have enough kernel VA space for
//  critical system mappings, but once they are all gone, the call will fail
//  with insufficient resources.
//
//

#define PIN_HIGH_PRIORITY                 (64)

//
//  Flags for mapping
//

//
//  Synchronous Wait - normally specified.  This pattern may be specified as TRUE.
//

#define MAP_WAIT                          (1)

//
//  Acquire metadata Bcb but do not fault data in.  Default is to fault the data in.
//  This should not overlap with any of the PIN_ flags so they can be passed down to
//  CcPinFileData
//

#define MAP_NO_READ                       (16)

//
//  If this option is specified, Cc will used reserved views to map the data
//  requested if Mm has no views to give Cc at the time of mapping the data.
//  This flag should only be used for critical data, like file system metadata
//  or other data critical to the file system remaining consistent.  This is 
//  a best effort attempt to ensure that we have enough kernel VA space for
//  critical system mappings, but once they are all gone, the call will fail
//  with insufficient resources.
//
//

#define MAP_HIGH_PRIORITY                 (64)


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcPinRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG Flags,
    __deref_out PVOID *Bcb,
    __deref_out_bcount(Length) PVOID *Buffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
BOOLEAN
CcMapData (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG Flags,
    __deref_out PVOID *Bcb,
    __deref_out_bcount(Length) PVOID *Buffer
    );
#elif (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
BOOLEAN
CcMapData (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __deref_out PVOID *Bcb,
    __deref_out_bcount(Length) PVOID *Buffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcPinMappedData (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG Flags,
    __deref_inout PVOID *Bcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcPreparePinWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Zero,
    __in ULONG Flags,
    __deref_out PVOID *Bcb,
    __deref_out_bcount(Length) PVOID *Buffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcSetDirtyPinnedData (
    __in PVOID BcbVoid,
    __in_opt PLARGE_INTEGER Lsn
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcUnpinData (
    __in PVOID Bcb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcSetBcbOwnerPointer (
    __in PVOID Bcb,
    __in PVOID OwnerPointer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcUnpinDataForThread (
    __in PVOID Bcb,
    __in ERESOURCE_THREAD ResourceThreadId
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
CcSetAdditionalCacheAttributes (
    __in PFILE_OBJECT FileObject,
    __in BOOLEAN DisableReadAhead,
    __in BOOLEAN DisableWriteBehind
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
CcSetParallelFlushFile (
    __in PFILE_OBJECT FileObject,
    __in BOOLEAN EnableParallelFlush
    );
#endif // NTDDI_VERSION >= NTDDI_VISTA

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
CcSetLogHandleForFile (
    __in PFILE_OBJECT FileObject,
    __in PVOID LogHandle,
    __in PFLUSH_TO_LSN FlushToLsnRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
LARGE_INTEGER
CcGetDirtyPages (
    __in PVOID LogHandle,
    __in PDIRTY_PAGE_ROUTINE DirtyPageRoutine,
    __in PVOID Context1,
    __in PVOID Context2
    );
#endif // NTDDI_VERSION >= NTDDI_WINXP    

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
CcIsThereDirtyData (
    __in PVPB Vpb
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
BOOLEAN
CcIsThereDirtyDataEx (
    __in PVPB Vpb,
    __in_opt PULONG NumberOfDirtyPages
    );
#endif

#ifndef __SSPI_H__
#define __SSPI_H__
#define ISSP_LEVEL  32          
#define ISSP_MODE   0           

#if defined(_NO_KSECDD_IMPORT_)

#define KSECDDDECLSPEC

#else

#define KSECDDDECLSPEC __declspec(dllimport)

#endif

typedef WCHAR SEC_WCHAR;
typedef CHAR SEC_CHAR;

#ifndef __SECSTATUS_DEFINED__
typedef LONG SECURITY_STATUS;
#define __SECSTATUS_DEFINED__
#endif

#define SEC_TEXT TEXT
#define SEC_FAR
#define SEC_ENTRY __stdcall


#ifndef __SECHANDLE_DEFINED__
typedef struct _SecHandle
{
    ULONG_PTR dwLower ;
    ULONG_PTR dwUpper ;
} SecHandle, * PSecHandle ;

#define __SECHANDLE_DEFINED__
#endif // __SECHANDLE_DEFINED__

#define SecInvalidateHandle( x )    \
            ((PSecHandle) (x))->dwLower = ((PSecHandle) (x))->dwUpper = ((ULONG_PTR) ((INT_PTR)-1)) ;

#define SecIsValidHandle( x ) \
            ( ( ((PSecHandle) (x))->dwLower != ((ULONG_PTR) ((INT_PTR) -1 ))) && \
              ( ((PSecHandle) (x))->dwUpper != ((ULONG_PTR) ((INT_PTR) -1 ))) )

//
// pseudo handle value: the handle has already been deleted
//

#define SEC_DELETED_HANDLE  ((ULONG_PTR) (-2))

typedef SecHandle CredHandle;
typedef PSecHandle PCredHandle;

typedef SecHandle CtxtHandle;
typedef PSecHandle PCtxtHandle;

typedef LARGE_INTEGER _SECURITY_INTEGER, SECURITY_INTEGER, *PSECURITY_INTEGER; 
typedef SECURITY_INTEGER TimeStamp;                 
typedef SECURITY_INTEGER * PTimeStamp;      
typedef UNICODE_STRING SECURITY_STRING, *PSECURITY_STRING;  

//
// SecPkgInfo structure
//
//  Provides general information about a security provider
//

typedef struct _SecPkgInfoW
{
    unsigned long fCapabilities;        // Capability bitmask
    unsigned short wVersion;            // Version of driver
    unsigned short wRPCID;              // ID for RPC Runtime
    unsigned long cbMaxToken;           // Size of authentication token (max)
#ifdef MIDL_PASS
    [string]
#endif
    SEC_WCHAR * Name;           // Text name

#ifdef MIDL_PASS
    [string]
#endif
    SEC_WCHAR * Comment;        // Comment
} SecPkgInfoW, * PSecPkgInfoW;

#  define SecPkgInfo SecPkgInfoW        
#  define PSecPkgInfo PSecPkgInfoW      

//
//  Security Package Capabilities
//
#define SECPKG_FLAG_INTEGRITY                   0x00000001  // Supports integrity on messages
#define SECPKG_FLAG_PRIVACY                     0x00000002  // Supports privacy (confidentiality)
#define SECPKG_FLAG_TOKEN_ONLY                  0x00000004  // Only security token needed
#define SECPKG_FLAG_DATAGRAM                    0x00000008  // Datagram RPC support
#define SECPKG_FLAG_CONNECTION                  0x00000010  // Connection oriented RPC support
#define SECPKG_FLAG_MULTI_REQUIRED              0x00000020  // Full 3-leg required for re-auth.
#define SECPKG_FLAG_CLIENT_ONLY                 0x00000040  // Server side functionality not available
#define SECPKG_FLAG_EXTENDED_ERROR              0x00000080  // Supports extended error msgs
#define SECPKG_FLAG_IMPERSONATION               0x00000100  // Supports impersonation
#define SECPKG_FLAG_ACCEPT_WIN32_NAME           0x00000200  // Accepts Win32 names
#define SECPKG_FLAG_STREAM                      0x00000400  // Supports stream semantics
#define SECPKG_FLAG_NEGOTIABLE                  0x00000800  // Can be used by the negotiate package
#define SECPKG_FLAG_GSS_COMPATIBLE              0x00001000  // GSS Compatibility Available
#define SECPKG_FLAG_LOGON                       0x00002000  // Supports common LsaLogonUser
#define SECPKG_FLAG_ASCII_BUFFERS               0x00004000  // Token Buffers are in ASCII
#define SECPKG_FLAG_FRAGMENT                    0x00008000  // Package can fragment to fit
#define SECPKG_FLAG_MUTUAL_AUTH                 0x00010000  // Package can perform mutual authentication
#define SECPKG_FLAG_DELEGATION                  0x00020000  // Package can delegate
#define SECPKG_FLAG_READONLY_WITH_CHECKSUM      0x00040000  // Package can delegate
#define SECPKG_FLAG_RESTRICTED_TOKENS           0x00080000  // Package supports restricted callers

#define SECPKG_ID_NONE      0xFFFF


//
// SecBuffer
//
//  Generic memory descriptors for buffers passed in to the security
//  API
//

typedef struct _SecBuffer {
    unsigned long cbBuffer;             // Size of the buffer, in bytes
    unsigned long BufferType;           // Type of the buffer (below)
    __field_bcount(cbBuffer) void SEC_FAR * pvBuffer;            // Pointer to the buffer
} SecBuffer, * PSecBuffer;

typedef struct _SecBufferDesc {
    unsigned long ulVersion;            // Version number
    unsigned long cBuffers;             // Number of buffers
#ifdef MIDL_PASS
    [size_is(cBuffers)]
#endif
    __field_ecount(cBuffers) PSecBuffer pBuffers;                // Pointer to array of buffers
} SecBufferDesc, SEC_FAR * PSecBufferDesc;

#define SECBUFFER_VERSION           0

#define SECBUFFER_EMPTY             0   // Undefined, replaced by provider
#define SECBUFFER_DATA              1   // Packet data
#define SECBUFFER_TOKEN             2   // Security token
#define SECBUFFER_PKG_PARAMS        3   // Package specific parameters
#define SECBUFFER_MISSING           4   // Missing Data indicator
#define SECBUFFER_EXTRA             5   // Extra data
#define SECBUFFER_STREAM_TRAILER    6   // Security Trailer
#define SECBUFFER_STREAM_HEADER     7   // Security Header
#define SECBUFFER_NEGOTIATION_INFO  8   // Hints from the negotiation pkg
#define SECBUFFER_PADDING           9   // non-data padding
#define SECBUFFER_STREAM            10  // whole encrypted message
#define SECBUFFER_MECHLIST          11
#define SECBUFFER_MECHLIST_SIGNATURE 12
#define SECBUFFER_TARGET            13  // obsolete
#define SECBUFFER_CHANNEL_BINDINGS  14
#define SECBUFFER_CHANGE_PASS_RESPONSE 15

#define SECBUFFER_ATTRMASK                      0xF0000000
#define SECBUFFER_READONLY                      0x80000000  // Buffer is read-only, no checksum
#define SECBUFFER_READONLY_WITH_CHECKSUM        0x10000000  // Buffer is read-only, and checksummed
#define SECBUFFER_RESERVED                      0x60000000  // Flags reserved to security system


typedef struct _SEC_NEGOTIATION_INFO {
    unsigned long       Size;           // Size of this structure
    unsigned long       NameLength;     // Length of name hint
    SEC_WCHAR * Name;           // Name hint
    void *      Reserved;       // Reserved
} SEC_NEGOTIATION_INFO, * PSEC_NEGOTIATION_INFO ;

typedef struct _SEC_CHANNEL_BINDINGS {
    unsigned long  dwInitiatorAddrType;
    unsigned long  cbInitiatorLength;
    unsigned long  dwInitiatorOffset;
    unsigned long  dwAcceptorAddrType;
    unsigned long  cbAcceptorLength;
    unsigned long  dwAcceptorOffset;
    unsigned long  cbApplicationDataLength;
    unsigned long  dwApplicationDataOffset;
} SEC_CHANNEL_BINDINGS, * PSEC_CHANNEL_BINDINGS ;


//
//  Data Representation Constant:
//
#define SECURITY_NATIVE_DREP        0x00000010
#define SECURITY_NETWORK_DREP       0x00000000

//
//  Credential Use Flags
//
#define SECPKG_CRED_INBOUND         0x00000001
#define SECPKG_CRED_OUTBOUND        0x00000002
#define SECPKG_CRED_BOTH            0x00000003
#define SECPKG_CRED_DEFAULT         0x00000004
#define SECPKG_CRED_RESERVED        0xF0000000

//
//  InitializeSecurityContext Requirement and return flags:
//

#define ISC_REQ_DELEGATE                0x00000001
#define ISC_REQ_MUTUAL_AUTH             0x00000002
#define ISC_REQ_REPLAY_DETECT           0x00000004
#define ISC_REQ_SEQUENCE_DETECT         0x00000008
#define ISC_REQ_CONFIDENTIALITY         0x00000010
#define ISC_REQ_USE_SESSION_KEY         0x00000020
#define ISC_REQ_PROMPT_FOR_CREDS        0x00000040
#define ISC_REQ_USE_SUPPLIED_CREDS      0x00000080
#define ISC_REQ_ALLOCATE_MEMORY         0x00000100
#define ISC_REQ_USE_DCE_STYLE           0x00000200
#define ISC_REQ_DATAGRAM                0x00000400
#define ISC_REQ_CONNECTION              0x00000800
#define ISC_REQ_CALL_LEVEL              0x00001000
#define ISC_REQ_FRAGMENT_SUPPLIED       0x00002000
#define ISC_REQ_EXTENDED_ERROR          0x00004000
#define ISC_REQ_STREAM                  0x00008000
#define ISC_REQ_INTEGRITY               0x00010000
#define ISC_REQ_IDENTIFY                0x00020000
#define ISC_REQ_NULL_SESSION            0x00040000
#define ISC_REQ_MANUAL_CRED_VALIDATION  0x00080000
#define ISC_REQ_RESERVED1               0x00100000
#define ISC_REQ_FRAGMENT_TO_FIT         0x00200000
// This exists only in Longhorn and greater
#define ISC_REQ_FORWARD_CREDENTIALS     0x00400000
#define ISC_REQ_NO_INTEGRITY            0x00800000 // honored only by SPNEGO

#define ISC_RET_DELEGATE                0x00000001
#define ISC_RET_MUTUAL_AUTH             0x00000002
#define ISC_RET_REPLAY_DETECT           0x00000004
#define ISC_RET_SEQUENCE_DETECT         0x00000008
#define ISC_RET_CONFIDENTIALITY         0x00000010
#define ISC_RET_USE_SESSION_KEY         0x00000020
#define ISC_RET_USED_COLLECTED_CREDS    0x00000040
#define ISC_RET_USED_SUPPLIED_CREDS     0x00000080
#define ISC_RET_ALLOCATED_MEMORY        0x00000100
#define ISC_RET_USED_DCE_STYLE          0x00000200
#define ISC_RET_DATAGRAM                0x00000400
#define ISC_RET_CONNECTION              0x00000800
#define ISC_RET_INTERMEDIATE_RETURN     0x00001000
#define ISC_RET_CALL_LEVEL              0x00002000
#define ISC_RET_EXTENDED_ERROR          0x00004000
#define ISC_RET_STREAM                  0x00008000
#define ISC_RET_INTEGRITY               0x00010000
#define ISC_RET_IDENTIFY                0x00020000
#define ISC_RET_NULL_SESSION            0x00040000
#define ISC_RET_MANUAL_CRED_VALIDATION  0x00080000
#define ISC_RET_RESERVED1               0x00100000
#define ISC_RET_FRAGMENT_ONLY           0x00200000
// This exists only in Longhorn and greater
#define ISC_RET_FORWARD_CREDENTIALS     0x00400000
#define ISC_RET_NO_ADDITIONAL_TOKEN     0x02000000  // *INTERNAL*

#define ASC_REQ_DELEGATE                0x00000001
#define ASC_REQ_MUTUAL_AUTH             0x00000002
#define ASC_REQ_REPLAY_DETECT           0x00000004
#define ASC_REQ_SEQUENCE_DETECT         0x00000008
#define ASC_REQ_CONFIDENTIALITY         0x00000010
#define ASC_REQ_USE_SESSION_KEY         0x00000020
#define ASC_REQ_ALLOCATE_MEMORY         0x00000100
#define ASC_REQ_USE_DCE_STYLE           0x00000200
#define ASC_REQ_DATAGRAM                0x00000400
#define ASC_REQ_CONNECTION              0x00000800
#define ASC_REQ_CALL_LEVEL              0x00001000
#define ASC_REQ_EXTENDED_ERROR          0x00008000
#define ASC_REQ_STREAM                  0x00010000
#define ASC_REQ_INTEGRITY               0x00020000
#define ASC_REQ_LICENSING               0x00040000
#define ASC_REQ_IDENTIFY                0x00080000
#define ASC_REQ_ALLOW_NULL_SESSION      0x00100000
#define ASC_REQ_ALLOW_NON_USER_LOGONS   0x00200000
#define ASC_REQ_ALLOW_CONTEXT_REPLAY    0x00400000
#define ASC_REQ_FRAGMENT_TO_FIT         0x00800000
#define ASC_REQ_FRAGMENT_SUPPLIED       0x00002000
#define ASC_REQ_NO_TOKEN                0x01000000

#define ASC_RET_DELEGATE                0x00000001
#define ASC_RET_MUTUAL_AUTH             0x00000002
#define ASC_RET_REPLAY_DETECT           0x00000004
#define ASC_RET_SEQUENCE_DETECT         0x00000008
#define ASC_RET_CONFIDENTIALITY         0x00000010
#define ASC_RET_USE_SESSION_KEY         0x00000020
#define ASC_RET_ALLOCATED_MEMORY        0x00000100
#define ASC_RET_USED_DCE_STYLE          0x00000200
#define ASC_RET_DATAGRAM                0x00000400
#define ASC_RET_CONNECTION              0x00000800
#define ASC_RET_CALL_LEVEL              0x00002000 // skipped 1000 to be like ISC_
#define ASC_RET_THIRD_LEG_FAILED        0x00004000
#define ASC_RET_EXTENDED_ERROR          0x00008000
#define ASC_RET_STREAM                  0x00010000
#define ASC_RET_INTEGRITY               0x00020000
#define ASC_RET_LICENSING               0x00040000
#define ASC_RET_IDENTIFY                0x00080000
#define ASC_RET_NULL_SESSION            0x00100000
#define ASC_RET_ALLOW_NON_USER_LOGONS   0x00200000
#define ASC_RET_ALLOW_CONTEXT_REPLAY    0x00400000  // deprecated - don't use this flag!!!
#define ASC_RET_FRAGMENT_ONLY           0x00800000
#define ASC_RET_NO_TOKEN                0x01000000
#define ASC_RET_NO_ADDITIONAL_TOKEN     0x02000000  // *INTERNAL*

//
//  Security Credentials Attributes:
//

#define SECPKG_CRED_ATTR_NAMES        1
#define SECPKG_CRED_ATTR_SSI_PROVIDER 2

typedef struct _SecPkgCredentials_NamesW
{
    SEC_WCHAR * sUserName;
} SecPkgCredentials_NamesW, * PSecPkgCredentials_NamesW;

#  define SecPkgCredentials_Names SecPkgCredentials_NamesW      
#  define PSecPkgCredentials_Names PSecPkgCredentials_NamesW    

#if NTDDI_VERSION > NTDDI_WS03
typedef struct _SecPkgCredentials_SSIProviderW
{
    SEC_WCHAR * sProviderName;
    unsigned long       ProviderInfoLength;
    char *      ProviderInfo;
} SecPkgCredentials_SSIProviderW, * PSecPkgCredentials_SSIProviderW;
#endif // End W2k3SP1 and greater
#  define SecPkgCredentials_SSIProvider SecPkgCredentials_SSIProviderW      
#  define PSecPkgCredentials_SSIProvider PSecPkgCredentials_SSIProviderW    

//
//  Security Context Attributes:
//

#define SECPKG_ATTR_SIZES           0
#define SECPKG_ATTR_NAMES           1
#define SECPKG_ATTR_LIFESPAN        2
#define SECPKG_ATTR_DCE_INFO        3
#define SECPKG_ATTR_STREAM_SIZES    4
#define SECPKG_ATTR_KEY_INFO        5
#define SECPKG_ATTR_AUTHORITY       6
#define SECPKG_ATTR_PROTO_INFO      7
#define SECPKG_ATTR_PASSWORD_EXPIRY 8
#define SECPKG_ATTR_SESSION_KEY     9
#define SECPKG_ATTR_PACKAGE_INFO    10
#define SECPKG_ATTR_USER_FLAGS      11
#define SECPKG_ATTR_NEGOTIATION_INFO 12
#define SECPKG_ATTR_NATIVE_NAMES    13
#define SECPKG_ATTR_FLAGS           14
// These attributes exist only in Win XP and greater
#define SECPKG_ATTR_USE_VALIDATED   15
#define SECPKG_ATTR_CREDENTIAL_NAME 16
#define SECPKG_ATTR_TARGET_INFORMATION 17
#define SECPKG_ATTR_ACCESS_TOKEN    18
// These attributes exist only in Win2K3 and greater
#define SECPKG_ATTR_TARGET          19
#define SECPKG_ATTR_AUTHENTICATION_ID  20
// These attributes exist only in Win2K3SP1 and greater
#define SECPKG_ATTR_LOGOFF_TIME     21


typedef struct _SecPkgContext_Sizes
{
    unsigned long cbMaxToken;
    unsigned long cbMaxSignature;
    unsigned long cbBlockSize;
    unsigned long cbSecurityTrailer;
} SecPkgContext_Sizes, * PSecPkgContext_Sizes;

typedef struct _SecPkgContext_StreamSizes
{
    unsigned long   cbHeader;
    unsigned long   cbTrailer;
    unsigned long   cbMaximumMessage;
    unsigned long   cBuffers;
    unsigned long   cbBlockSize;
} SecPkgContext_StreamSizes, * PSecPkgContext_StreamSizes;

typedef struct _SecPkgContext_NamesW
{
    SEC_WCHAR * sUserName;
} SecPkgContext_NamesW, * PSecPkgContext_NamesW;

#  define SecPkgContext_Names SecPkgContext_NamesW          
#  define PSecPkgContext_Names PSecPkgContext_NamesW        

typedef struct _SecPkgContext_Lifespan
{
    TimeStamp tsStart;
    TimeStamp tsExpiry;
} SecPkgContext_Lifespan, * PSecPkgContext_Lifespan;

typedef struct _SecPkgContext_DceInfo
{
    unsigned long AuthzSvc;
    void * pPac;
} SecPkgContext_DceInfo, * PSecPkgContext_DceInfo;


typedef struct _SecPkgContext_KeyInfoW
{
    SEC_WCHAR * sSignatureAlgorithmName;
    SEC_WCHAR * sEncryptAlgorithmName;
    unsigned long       KeySize;
    unsigned long       SignatureAlgorithm;
    unsigned long       EncryptAlgorithm;
} SecPkgContext_KeyInfoW, * PSecPkgContext_KeyInfoW;

#define SecPkgContext_KeyInfo   SecPkgContext_KeyInfoW      
#define PSecPkgContext_KeyInfo  PSecPkgContext_KeyInfoW     

typedef struct _SecPkgContext_AuthorityW
{
    SEC_WCHAR * sAuthorityName;
} SecPkgContext_AuthorityW, * PSecPkgContext_AuthorityW;

#define SecPkgContext_Authority SecPkgContext_AuthorityW        
#define PSecPkgContext_Authority    PSecPkgContext_AuthorityW   

typedef struct _SecPkgContext_ProtoInfoW
{
    SEC_WCHAR * sProtocolName;
    unsigned long       majorVersion;
    unsigned long       minorVersion;
} SecPkgContext_ProtoInfoW, * PSecPkgContext_ProtoInfoW;

#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoW      
#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoW     

typedef struct _SecPkgContext_PasswordExpiry
{
    TimeStamp tsPasswordExpires;
} SecPkgContext_PasswordExpiry, * PSecPkgContext_PasswordExpiry;

#if NTDDI_VERSION > NTDDI_WS03
typedef struct _SecPkgContext_LogoffTime
{
    TimeStamp tsLogoffTime;
} SecPkgContext_LogoffTime, * PSecPkgContext_LogoffTime;
#endif // Greater than Windows Server 2003 RTM (SP1 and greater contains this)

typedef struct _SecPkgContext_SessionKey
{
    unsigned long SessionKeyLength;
    __field_bcount(SessionKeyLength) unsigned char * SessionKey;
} SecPkgContext_SessionKey, *PSecPkgContext_SessionKey;


typedef struct _SecPkgContext_PackageInfoW
{
    PSecPkgInfoW PackageInfo;
} SecPkgContext_PackageInfoW, * PSecPkgContext_PackageInfoW;


typedef struct _SecPkgContext_UserFlags
{
    unsigned long UserFlags;
} SecPkgContext_UserFlags, * PSecPkgContext_UserFlags;

typedef struct _SecPkgContext_Flags
{
    unsigned long Flags;
} SecPkgContext_Flags, * PSecPkgContext_Flags;

#define SecPkgContext_PackageInfo   SecPkgContext_PackageInfoW      
#define PSecPkgContext_PackageInfo  PSecPkgContext_PackageInfoW     
typedef struct _SecPkgContext_NegotiationInfoW
{
    PSecPkgInfoW    PackageInfo ;
    unsigned long   NegotiationState ;
} SecPkgContext_NegotiationInfoW, * PSecPkgContext_NegotiationInfoW ;

#  define SecPkgContext_NativeNames SecPkgContext_NativeNamesW          
#  define PSecPkgContext_NativeNames PSecPkgContext_NativeNamesW        

#if OSVER(NTDDI_VERSION) > NTDDI_WIN2K

typedef struct _SecPkgContext_CredentialNameW
{
    unsigned long CredentialType;
    SEC_WCHAR *sCredentialName;
} SecPkgContext_CredentialNameW, * PSecPkgContext_CredentialNameW;

#endif // Later than win2k
#  define SecPkgContext_CredentialName SecPkgContext_CredentialNameW          
#  define PSecPkgContext_CredentialName PSecPkgContext_CredentialNameW        

typedef void
(SEC_ENTRY * SEC_GET_KEY_FN) (
    void * Arg,                 // Argument passed in
    void * Principal,           // Principal ID
    unsigned long KeyVer,               // Key Version
    void * * Key,       // Returned ptr to key
    SECURITY_STATUS * Status    // returned status
    );

//
// Flags for ExportSecurityContext
//

#define SECPKG_CONTEXT_EXPORT_RESET_NEW         0x00000001      // New context is reset to initial state
#define SECPKG_CONTEXT_EXPORT_DELETE_OLD        0x00000002      // Old context is deleted during export
// This is only valid in W2K3SP1 and greater
#define SECPKG_CONTEXT_EXPORT_TO_KERNEL         0x00000004      // Context is to be transferred to the kernel


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleW(
#if ISSP_MODE == 0     // For Kernel mode
    __in_opt  PSECURITY_STRING pPrincipal,
    __in      PSECURITY_STRING pPackage,
#else
    __in_opt  SEC_WCHAR * pszPrincipal,   // Name of principal
    __in      SEC_WCHAR * pszPackage,     // Name of package
#endif
    __in      unsigned long fCredentialUse,       // Flags indicating use
    __in_opt  void * pvLogonId,           // Pointer to logon ID
    __in_opt  void * pAuthData,           // Package specific data
    __in_opt  SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    __in_opt  void * pvGetKeyArgument,    // Value to pass to GetKey()
    __out     PCredHandle phCredential,           // (out) Cred Handle
    __out_opt PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ACQUIRE_CREDENTIALS_HANDLE_FN_W)(
#if ISSP_MODE == 0
    PSECURITY_STRING,
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
    SEC_WCHAR *,
#endif
    unsigned long,
    void *,
    void *,
    SEC_GET_KEY_FN,
    void *,
    PCredHandle,
    PTimeStamp);

#  define AcquireCredentialsHandle AcquireCredentialsHandleW            
#  define ACQUIRE_CREDENTIALS_HANDLE_FN ACQUIRE_CREDENTIALS_HANDLE_FN_W 

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    __in PCredHandle phCredential            // Handle to free
    );

typedef SECURITY_STATUS
(SEC_ENTRY * FREE_CREDENTIALS_HANDLE_FN)(
    PCredHandle );

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
AddCredentialsW(
    __in      PCredHandle hCredentials,
#if ISSP_MODE == 0      // For Kernel mode
    __in_opt  PSECURITY_STRING pPrincipal,
    __in      PSECURITY_STRING pPackage,
#else
    __in_opt  SEC_WCHAR * pszPrincipal,   // Name of principal
    __in      SEC_WCHAR * pszPackage,     // Name of package
#endif
    __in      unsigned long fCredentialUse,       // Flags indicating use
    __in_opt  void * pAuthData,           // Package specific data
    __in_opt  SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    __in_opt  void * pvGetKeyArgument,    // Value to pass to GetKey()
    __out_opt PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ADD_CREDENTIALS_FN_W)(
    PCredHandle,
#if ISSP_MODE == 0
    PSECURITY_STRING,
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
    SEC_WCHAR *,
#endif
    unsigned long,
    void *,
    SEC_GET_KEY_FN,
    void *,
    PTimeStamp);

SECURITY_STATUS SEC_ENTRY
AddCredentialsA(
    __in PCredHandle hCredentials,
    __in_opt SEC_CHAR * pszPrincipal,   // Name of principal
    __in SEC_CHAR * pszPackage,     // Name of package
    __in unsigned long fCredentialUse,       // Flags indicating use
    __in_opt void * pAuthData,           // Package specific data
    __in_opt SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    __in_opt void * pvGetKeyArgument,    // Value to pass to GetKey()
    __out_opt PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ADD_CREDENTIALS_FN_A)(
    PCredHandle,
    SEC_CHAR *,
    SEC_CHAR *,
    unsigned long,
    void *,
    SEC_GET_KEY_FN,
    void *,
    PTimeStamp);

#ifdef UNICODE
#define AddCredentials  AddCredentialsW
#define ADD_CREDENTIALS_FN  ADD_CREDENTIALS_FN_W
#else
#define AddCredentials  AddCredentialsA
#define ADD_CREDENTIALS_FN ADD_CREDENTIALS_FN_A
#endif

////////////////////////////////////////////////////////////////////////
///
/// Password Change Functions
///
////////////////////////////////////////////////////////////////////////

#if ISSP_MODE != 0

SECURITY_STATUS SEC_ENTRY
ChangeAccountPasswordW(
    __in    SEC_WCHAR *  pszPackageName,
    __in    SEC_WCHAR *  pszDomainName,
    __in    SEC_WCHAR *  pszAccountName,
    __in    SEC_WCHAR *  pszOldPassword,
    __in    SEC_WCHAR *  pszNewPassword,
    __in    BOOLEAN              bImpersonating,
    __in    unsigned long        dwReserved,
    __inout PSecBufferDesc       pOutput
    );

typedef SECURITY_STATUS
(SEC_ENTRY * CHANGE_PASSWORD_FN_W)(
    SEC_WCHAR *,
    SEC_WCHAR *,
    SEC_WCHAR *,
    SEC_WCHAR *,
    SEC_WCHAR *,
    BOOLEAN,
    unsigned long,
    PSecBufferDesc
    );



SECURITY_STATUS SEC_ENTRY
ChangeAccountPasswordA(
    __in    SEC_CHAR *  pszPackageName,
    __in    SEC_CHAR *  pszDomainName,
    __in    SEC_CHAR *  pszAccountName,
    __in    SEC_CHAR *  pszOldPassword,
    __in    SEC_CHAR *  pszNewPassword,
    __in    BOOLEAN             bImpersonating,
    __in    unsigned long       dwReserved,
    __inout PSecBufferDesc      pOutput
    );

typedef SECURITY_STATUS
(SEC_ENTRY * CHANGE_PASSWORD_FN_A)(
    SEC_CHAR *,
    SEC_CHAR *,
    SEC_CHAR *,
    SEC_CHAR *,
    SEC_CHAR *,
    BOOLEAN,
    unsigned long,
    PSecBufferDesc
    );

#ifdef UNICODE
#  define ChangeAccountPassword ChangeAccountPasswordW
#  define CHANGE_PASSWORD_FN CHANGE_PASSWORD_FN_W
#else
#  define ChangeAccountPassword ChangeAccountPasswordA
#  define CHANGE_PASSWORD_FN CHANGE_PASSWORD_FN_A
#endif // !UNICODE

#endif // ISSP_MODE


////////////////////////////////////////////////////////////////////////
///
/// Context Management Functions
///
////////////////////////////////////////////////////////////////////////

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    __in_opt    PCredHandle phCredential,               // Cred to base context
    __in_opt    PCtxtHandle phContext,                  // Existing context (OPT)
#if ISSP_MODE == 0
    __in_opt PSECURITY_STRING pTargetName,
#else
    __in_opt SEC_WCHAR * pszTargetName,         // Name of target
#endif
    __in        unsigned long fContextReq,              // Context Requirements
    __in        unsigned long Reserved1,                // Reserved, MBZ
    __in        unsigned long TargetDataRep,            // Data rep of target
    __in_opt    PSecBufferDesc pInput,                  // Input Buffers
    __in        unsigned long Reserved2,                // Reserved, MBZ
    __inout_opt PCtxtHandle phNewContext,               // (out) New Context handle
    __inout_opt PSecBufferDesc pOutput,                 // (inout) Output Buffers
    __out       unsigned long * pfContextAttr,  // (out) Context attrs
    __out_opt   PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * INITIALIZE_SECURITY_CONTEXT_FN_W)(
    PCredHandle,
    PCtxtHandle,
#if ISSP_MODE == 0
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
#endif
    unsigned long,
    unsigned long,
    unsigned long,
    PSecBufferDesc,
    unsigned long,
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long *,
    PTimeStamp);

#  define InitializeSecurityContext InitializeSecurityContextW              
#  define INITIALIZE_SECURITY_CONTEXT_FN INITIALIZE_SECURITY_CONTEXT_FN_W   

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    __in_opt  PCredHandle phCredential,               // Cred to base context
    __in_opt  PCtxtHandle phContext,                  // Existing context (OPT)
    __in_opt  PSecBufferDesc pInput,                  // Input buffer
    __in      unsigned long fContextReq,              // Context Requirements
    __in      unsigned long TargetDataRep,            // Target Data Rep
    __in_opt  PCtxtHandle phNewContext,               // (out) New context handle
    __in_opt  PSecBufferDesc pOutput,                 // (inout) Output buffers
    __out     unsigned long * pfContextAttr,  // (out) Context attributes
    __out_opt PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ACCEPT_SECURITY_CONTEXT_FN)(
    PCredHandle,
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long,
    unsigned long,
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long *,
    PTimeStamp);



SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    __in PCtxtHandle phContext,              // Context to complete
    __in PSecBufferDesc pToken               // Token to complete
    );

typedef SECURITY_STATUS
(SEC_ENTRY * COMPLETE_AUTH_TOKEN_FN)(
    PCtxtHandle,
    PSecBufferDesc);

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    __in PCtxtHandle phContext               // Context to impersonate
    );

typedef SECURITY_STATUS
(SEC_ENTRY * IMPERSONATE_SECURITY_CONTEXT_FN)(
    PCtxtHandle);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    __in PCtxtHandle phContext               // Context from which to re
    );

typedef SECURITY_STATUS
(SEC_ENTRY * REVERT_SECURITY_CONTEXT_FN)(
    PCtxtHandle);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
QuerySecurityContextToken(
    __in  PCtxtHandle phContext,
    __out void * * Token
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_SECURITY_CONTEXT_TOKEN_FN)(
    PCtxtHandle, void * *);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    __in PCtxtHandle phContext               // Context to delete
    );

typedef SECURITY_STATUS
(SEC_ENTRY * DELETE_SECURITY_CONTEXT_FN)(
    PCtxtHandle);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    __in PCtxtHandle phContext,              // Context to modify
    __in PSecBufferDesc pInput               // Input token to apply
    );

typedef SECURITY_STATUS
(SEC_ENTRY * APPLY_CONTROL_TOKEN_FN)(
    PCtxtHandle, PSecBufferDesc);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
QueryContextAttributesW(
    __in  PCtxtHandle phContext,              // Context to query
    __in  unsigned long ulAttribute,          // Attribute to query
    __out void * pBuffer              // Buffer for attributes
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_CONTEXT_ATTRIBUTES_FN_W)(
    PCtxtHandle,
    unsigned long,
    void *);

#  define QueryContextAttributes QueryContextAttributesW            
#  define QUERY_CONTEXT_ATTRIBUTES_FN QUERY_CONTEXT_ATTRIBUTES_FN_W 

#if (OSVER(NTDDI_VERSION) > NTDDI_WIN2K)

SECURITY_STATUS SEC_ENTRY
SetContextAttributesW(
    __in PCtxtHandle phContext,                   // Context to Set
    __in unsigned long ulAttribute,               // Attribute to Set
    __in_bcount(cbBuffer) void * pBuffer, // Buffer for attributes
    __in unsigned long cbBuffer                   // Size (in bytes) of Buffer
    );

typedef SECURITY_STATUS
(SEC_ENTRY * SET_CONTEXT_ATTRIBUTES_FN_W)(
    PCtxtHandle,
    unsigned long,
    void *,
    unsigned long );

#endif // Greater than w2k

#  define SetContextAttributes SetContextAttributesW            
#  define SET_CONTEXT_ATTRIBUTES_FN SET_CONTEXT_ATTRIBUTES_FN_W 

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
QueryCredentialsAttributesW(
    __in    PCredHandle phCredential,           // Credential to query
    __in    unsigned long ulAttribute,          // Attribute to query
    __inout void * pBuffer              // Buffer for attributes
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_CREDENTIALS_ATTRIBUTES_FN_W)(
    PCredHandle,
    unsigned long,
    void *);

#  define QueryCredentialsAttributes QueryCredentialsAttributesW            
#  define QUERY_CREDENTIALS_ATTRIBUTES_FN QUERY_CREDENTIALS_ATTRIBUTES_FN_W 

#if NTDDI_VERSION > NTDDI_WS03

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
SetCredentialsAttributesW(
    __in PCredHandle phCredential,                // Credential to Set
    __in unsigned long ulAttribute,               // Attribute to Set
    __in_bcount(cbBuffer) void * pBuffer, // Buffer for attributes
    __in unsigned long cbBuffer                   // Size (in bytes) of Buffer
    );

typedef SECURITY_STATUS
(SEC_ENTRY * SET_CREDENTIALS_ATTRIBUTES_FN_W)(
    PCredHandle,
    unsigned long,
    void *,
    unsigned long );

#endif // For W2k3SP1 and greater

#  define SetCredentialsAttributes SetCredentialsAttributesW            
#  define SET_CREDENTIALS_ATTRIBUTES_FN SET_CREDENTIALS_ATTRIBUTES_FN_W 

SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    __inout PVOID pvContextBuffer      // buffer to free
    );

typedef SECURITY_STATUS
(SEC_ENTRY * FREE_CONTEXT_BUFFER_FN)(
    __inout PVOID
    );

///////////////////////////////////////////////////////////////////
////
////    Message Support API
////
//////////////////////////////////////////////////////////////////

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
MakeSignature(
    __in PCtxtHandle phContext,              // Context to use
    __in unsigned long fQOP,                 // Quality of Protection
    __in PSecBufferDesc pMessage,            // Message to sign
    __in unsigned long MessageSeqNo          // Message Sequence Num.
    );

typedef SECURITY_STATUS
(SEC_ENTRY * MAKE_SIGNATURE_FN)(
    PCtxtHandle,
    unsigned long,
    PSecBufferDesc,
    unsigned long);


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
VerifySignature(
    __in  PCtxtHandle phContext,              // Context to use
    __in  PSecBufferDesc pMessage,            // Message to verify
    __in  unsigned long MessageSeqNo,         // Sequence Num.
    __out unsigned long * pfQOP       // QOP used
    );

typedef SECURITY_STATUS
(SEC_ENTRY * VERIFY_SIGNATURE_FN)(
    PCtxtHandle,
    PSecBufferDesc,
    unsigned long,
    unsigned long *);

// This only exists win Win2k3 and Greater
#define SECQOP_WRAP_NO_ENCRYPT      0x80000001
#define SECQOP_WRAP_OOB_DATA        0x40000000

SECURITY_STATUS SEC_ENTRY
EncryptMessage( __in    PCtxtHandle         phContext,
                __in    unsigned long       fQOP,
                __inout PSecBufferDesc      pMessage,
                __in    unsigned long       MessageSeqNo);

typedef SECURITY_STATUS
(SEC_ENTRY * ENCRYPT_MESSAGE_FN)(
    PCtxtHandle, unsigned long, PSecBufferDesc, unsigned long);


SECURITY_STATUS SEC_ENTRY
DecryptMessage( __in      PCtxtHandle         phContext,
                __inout   PSecBufferDesc      pMessage,
                __in      unsigned long       MessageSeqNo,
                __out_opt unsigned long *     pfQOP);


typedef SECURITY_STATUS
(SEC_ENTRY * DECRYPT_MESSAGE_FN)(
    PCtxtHandle, PSecBufferDesc, unsigned long,
    unsigned long *);


///////////////////////////////////////////////////////////////////////////
////
////    Misc.
////
///////////////////////////////////////////////////////////////////////////

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesW(
    __out       unsigned long * pcPackages,     // Receives num. packages
    __deref_out PSecPkgInfoW  * ppPackageInfo    // Receives array of info
    );

typedef SECURITY_STATUS
(SEC_ENTRY * ENUMERATE_SECURITY_PACKAGES_FN_W)(
    unsigned long *,
    PSecPkgInfoW *);

#  define EnumerateSecurityPackages EnumerateSecurityPackagesW              
#  define ENUMERATE_SECURITY_PACKAGES_FN ENUMERATE_SECURITY_PACKAGES_FN_W   

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(
#if ISSP_MODE == 0
    __in        PSECURITY_STRING pPackageName,
#else
    __in        SEC_WCHAR * pszPackageName,     // Name of package
#endif
    __deref_out PSecPkgInfoW *ppPackageInfo     // Receives package info
    );

typedef SECURITY_STATUS
(SEC_ENTRY * QUERY_SECURITY_PACKAGE_INFO_FN_W)(
#if ISSP_MODE == 0
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
#endif
    PSecPkgInfoW *);

#  define QuerySecurityPackageInfo QuerySecurityPackageInfoW                
#  define QUERY_SECURITY_PACKAGE_INFO_FN QUERY_SECURITY_PACKAGE_INFO_FN_W   

///////////////////////////////////////////////////////////////////////////
////
////    Context export/import
////
///////////////////////////////////////////////////////////////////////////


KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
ExportSecurityContext(
    __in  PCtxtHandle          phContext,             // (in) context to export
    __in  ULONG                fFlags,                // (in) option flags
    __out PSecBuffer           pPackedContext,        // (out) marshalled context
    __out void * * pToken             // (out, optional) token handle for impersonation
    );

typedef SECURITY_STATUS
(SEC_ENTRY * EXPORT_SECURITY_CONTEXT_FN)(
    PCtxtHandle,
    ULONG,
    PSecBuffer,
    void * *
    );

KSECDDDECLSPEC
SECURITY_STATUS SEC_ENTRY
ImportSecurityContextW(
#if ISSP_MODE == 0
    __in  PSECURITY_STRING     pszPackage,
#else
    __in  SEC_WCHAR * pszPackage,
#endif
    __in  PSecBuffer           pPackedContext,        // (in) marshalled context
    __in  void *       Token,                 // (in, optional) handle to token for context
    __out PCtxtHandle          phContext              // (out) new context handle
    );

typedef SECURITY_STATUS
(SEC_ENTRY * IMPORT_SECURITY_CONTEXT_FN_W)(
#if ISSP_MODE == 0
    PSECURITY_STRING,
#else
    SEC_WCHAR *,
#endif
    PSecBuffer,
    VOID *,
    PCtxtHandle
    );

#  define ImportSecurityContext ImportSecurityContextW              
#  define IMPORT_SECURITY_CONTEXT_FN IMPORT_SECURITY_CONTEXT_FN_W   

#if ISSP_MODE == 0
KSECDDDECLSPEC
NTSTATUS
NTAPI
SecMakeSPN(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG Length OPTIONAL,
    IN BOOLEAN Allocate
    );

#if OSVER(NTDDI_VERSION) > NTDD_WIN2K

KSECDDDECLSPEC
NTSTATUS
NTAPI
SecMakeSPNEx(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN PUNICODE_STRING TargetInfo OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG Length OPTIONAL,
    IN BOOLEAN Allocate
    );

#if OSVER(NTDDI_VERSION) > NTDDI_WS03

KSECDDDECLSPEC
NTSTATUS
NTAPI
SecMakeSPNEx2(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN PUNICODE_STRING InTargetInfo OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG TotalSize OPTIONAL,
    IN BOOLEAN Allocate,
    IN BOOLEAN IsTargetInfoMarshaled
    );

#endif // Longhorn and greater

KSECDDDECLSPEC
NTSTATUS
SEC_ENTRY
SecLookupAccountSid(
    __in      PSID Sid,
    __out     PULONG NameSize,
    __inout   PUNICODE_STRING NameBuffer,
    __out     PULONG DomainSize OPTIONAL,
    __out_opt PUNICODE_STRING DomainBuffer OPTIONAL,
    __out     PSID_NAME_USE NameUse
    );

KSECDDDECLSPEC
NTSTATUS
SEC_ENTRY
SecLookupAccountName(
    __in        PUNICODE_STRING Name,
    __inout     PULONG SidSize,
    __out       PSID Sid,
    __out       PSID_NAME_USE NameUse,
    __out       PULONG DomainSize OPTIONAL,
    __inout_opt PUNICODE_STRING ReferencedDomain OPTIONAL
    );

#endif // Greater than W2k

#if OSVER(NTDDI_VERSION) > NTDDI_WINXP

KSECDDDECLSPEC
NTSTATUS
SEC_ENTRY
SecLookupWellKnownSid(
    __in        WELL_KNOWN_SID_TYPE SidType,
    __out       PSID Sid,
    __in        ULONG SidBufferSize,
    __inout_opt PULONG SidSize OPTIONAL
    );

#endif // Greater than XP


#endif

#define SECURITY_ENTRYPOINTW SEC_TEXT("InitSecurityInterfaceW")     
#    define SECURITY_ENTRYPOINT SECURITY_ENTRYPOINTW                

#define FreeCredentialHandle FreeCredentialsHandle

typedef struct _SECURITY_FUNCTION_TABLE_W {
    unsigned long                       dwVersion;
    ENUMERATE_SECURITY_PACKAGES_FN_W    EnumerateSecurityPackagesW;
    QUERY_CREDENTIALS_ATTRIBUTES_FN_W   QueryCredentialsAttributesW;
    ACQUIRE_CREDENTIALS_HANDLE_FN_W     AcquireCredentialsHandleW;
    FREE_CREDENTIALS_HANDLE_FN          FreeCredentialsHandle;
    void *                      Reserved2;
    INITIALIZE_SECURITY_CONTEXT_FN_W    InitializeSecurityContextW;
    ACCEPT_SECURITY_CONTEXT_FN          AcceptSecurityContext;
    COMPLETE_AUTH_TOKEN_FN              CompleteAuthToken;
    DELETE_SECURITY_CONTEXT_FN          DeleteSecurityContext;
    APPLY_CONTROL_TOKEN_FN              ApplyControlToken;
    QUERY_CONTEXT_ATTRIBUTES_FN_W       QueryContextAttributesW;
    IMPERSONATE_SECURITY_CONTEXT_FN     ImpersonateSecurityContext;
    REVERT_SECURITY_CONTEXT_FN          RevertSecurityContext;
    MAKE_SIGNATURE_FN                   MakeSignature;
    VERIFY_SIGNATURE_FN                 VerifySignature;
    FREE_CONTEXT_BUFFER_FN              FreeContextBuffer;
    QUERY_SECURITY_PACKAGE_INFO_FN_W    QuerySecurityPackageInfoW;
    void *                      Reserved3;
    void *                      Reserved4;
    EXPORT_SECURITY_CONTEXT_FN          ExportSecurityContext;
    IMPORT_SECURITY_CONTEXT_FN_W        ImportSecurityContextW;
    ADD_CREDENTIALS_FN_W                AddCredentialsW ;
    void *                      Reserved8;
    QUERY_SECURITY_CONTEXT_TOKEN_FN     QuerySecurityContextToken;
    ENCRYPT_MESSAGE_FN                  EncryptMessage;
    DECRYPT_MESSAGE_FN                  DecryptMessage;
#if OSVER(NTDDI_VERSION) > NTDDI_WIN2K
    // Fields below this are available in OSes after w2k
    SET_CONTEXT_ATTRIBUTES_FN_W         SetContextAttributesW;
#endif // greater thean 2K

#if NTDDI_VERSION > NTDDI_WS03SP1
    // Fields below this are available in OSes after W2k3SP1
    SET_CREDENTIALS_ATTRIBUTES_FN_W     SetCredentialsAttributesW;
#endif
#if ISSP_MODE != 0
    CHANGE_PASSWORD_FN_W                ChangeAccountPasswordW;
#else
    void *                      Reserved9;
#endif
} SecurityFunctionTableW, * PSecurityFunctionTableW;

#  define SecurityFunctionTable SecurityFunctionTableW      
#  define PSecurityFunctionTable PSecurityFunctionTableW    
#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION     1   
#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2   2   
#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_3   3   
#define SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_4   4   

KSECDDDECLSPEC
PSecurityFunctionTableW SEC_ENTRY
InitSecurityInterfaceW(
    void
    );

typedef PSecurityFunctionTableW
(SEC_ENTRY * INIT_SECURITY_INTERFACE_W)(void);

#  define InitSecurityInterface InitSecurityInterfaceW          
#  define INIT_SECURITY_INTERFACE INIT_SECURITY_INTERFACE_W     

#ifndef _AUTH_IDENTITY_DEFINED
#define _AUTH_IDENTITY_DEFINED

//
// This was not defined in NTIFS.h for windows 2000 however
// this struct has always been there and are safe to use
// in windows 2000 and above.
//

#define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short *User;
  unsigned long UserLength;
  unsigned short *Domain;
  unsigned long DomainLength;
  unsigned short *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W       
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W     
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W     

#endif //_AUTH_IDENTITY_DEFINED                                 // ntifs

//
// This is the combined authentication identity structure that may be
// used with the negotiate package, NTLM, Kerberos, or SCHANNEL
//

#ifndef SEC_WINNT_AUTH_IDENTITY_VERSION
#define SEC_WINNT_AUTH_IDENTITY_VERSION 0x200

typedef struct _SEC_WINNT_AUTH_IDENTITY_EXW {
    unsigned long Version;
    unsigned long Length;
    unsigned short *User;
    unsigned long UserLength;
    unsigned short *Domain;
    unsigned long DomainLength;
    unsigned short *Password;
    unsigned long PasswordLength;
    unsigned long Flags;
    unsigned short * PackageList;
    unsigned long PackageListLength;
} SEC_WINNT_AUTH_IDENTITY_EXW, *PSEC_WINNT_AUTH_IDENTITY_EXW;

#define SEC_WINNT_AUTH_IDENTITY_EX  SEC_WINNT_AUTH_IDENTITY_EXW    
#define PSEC_WINNT_AUTH_IDENTITY_EX PSEC_WINNT_AUTH_IDENTITY_EXW   
#endif // SEC_WINNT_AUTH_IDENTITY_VERSION


//
// Common types used by negotiable security packages
//
// These are defined after W2K
//

#define SEC_WINNT_AUTH_IDENTITY_MARSHALLED      0x4     // all data is in one buffer
#define SEC_WINNT_AUTH_IDENTITY_ONLY            0x8     // these credentials are for identity only - no PAC needed

#endif // __SSPI_H__

#ifndef SECURITY_USER_DATA_DEFINED
#define SECURITY_USER_DATA_DEFINED

typedef struct _SECURITY_USER_DATA {
    SECURITY_STRING UserName;           // User name
    SECURITY_STRING LogonDomainName;    // Domain the user logged on to
    SECURITY_STRING LogonServer;        // Server that logged the user on
    PSID            pSid;               // SID of user
} SECURITY_USER_DATA, *PSECURITY_USER_DATA;

typedef SECURITY_USER_DATA SecurityUserData, * PSecurityUserData;


#define UNDERSTANDS_LONG_NAMES  1
#define NO_LONG_NAMES           2

#endif // SECURITY_USER_DATA_DEFINED

HRESULT SEC_ENTRY
GetSecurityUserInfo(
    __in        PLUID LogonId,
    __in        ULONG Flags,
    __deref_out PSecurityUserData * UserInformation
    );

SECURITY_STATUS SEC_ENTRY
MapSecurityError( SECURITY_STATUS SecStatus );

#define DD_MUP_DEVICE_NAME L"\\Device\\Mup"    


//
// The actual prefix resolution IOCTL issued by MUP to
// redirectors to determine who is responsible for a
// \\server\share prefix.
//

//
// For use with legacy providers, which register with
// FsRtlRegisterUncProvider().
//

#define IOCTL_REDIR_QUERY_PATH              CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 99, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// For use by redirectors conforming to the Vista redirector model.
// These register with FsRtlRegisterUncProviderEx().
//

#define IOCTL_REDIR_QUERY_PATH_EX       CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, 100, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Used by MUP prefix resolution.
// For use with legacy providers, which register with
// FsRtlRegisterUncProvider().
//

typedef struct _QUERY_PATH_REQUEST {
    ULONG                   PathNameLength;
    PIO_SECURITY_CONTEXT    SecurityContext;
    WCHAR                   FilePathName[1];
} QUERY_PATH_REQUEST, *PQUERY_PATH_REQUEST;

//
// Used by MUP prefix resolution.
// Issued to providers which register with FsRtlRegisterUncProviderEx()
// These are providers conforming to the Vista redirector model.
//

typedef struct _QUERY_PATH_REQUEST_EX {
    PIO_SECURITY_CONTEXT    pSecurityContext;
    ULONG                   EaLength;
    PVOID                   pEaBuffer;

    //
    // Pointer to filename will be passed to provider.
    // Provider MUST NOT muck with that memory.
    //

    UNICODE_STRING          PathName;

    //
    // Reserved 
    // 

    ULONG_PTR               Reserved[ 5 ];
} QUERY_PATH_REQUEST_EX, *PQUERY_PATH_REQUEST_EX;

typedef struct _QUERY_PATH_RESPONSE {
    ULONG LengthAccepted;
} QUERY_PATH_RESPONSE, *PQUERY_PATH_RESPONSE;

#define VOLSNAPCONTROLTYPE                              0x00000053 // 'S'
#define IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES             CTL_CODE(VOLSNAPCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) 

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryObject(
    __in_opt HANDLE Handle,
    __in OBJECT_INFORMATION_CLASS ObjectInformationClass,
    __out_bcount_opt(ObjectInformationLength) PVOID ObjectInformation,
    __in ULONG ObjectInformationLength,
    __out_opt PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeKey(
    __in HANDLE KeyHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG CompletionFilter,
    __in BOOLEAN WatchTree,
    __out_bcount_opt(BufferSize) PVOID Buffer,
    __in ULONG BufferSize,
    __in BOOLEAN Asynchronous
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent (
    __out PHANDLE EventHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in EVENT_TYPE EventType,
    __in BOOLEAN InitialState
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    __in POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG IoControlCode,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass,
    __in BOOLEAN ReturnSingleEntry,
    __in_opt PUNICODE_STRING FileName,
    __in BOOLEAN RestartScan
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwSetVolumeInformationFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG FsControlCode,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
    __in HANDLE SourceProcessHandle,
    __in HANDLE SourceHandle,
    __in_opt HANDLE TargetProcessHandle,
    __out_opt PHANDLE TargetHandle,
    __in ACCESS_MASK DesiredAccess,
    __in ULONG HandleAttributes,
    __in ULONG Options
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
    __out PHANDLE DirectoryHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    __in HANDLE ProcessHandle,
    __inout PVOID *BaseAddress,
    __in ULONG_PTR ZeroBits,
    __inout PSIZE_T RegionSize,
    __in ULONG AllocationType,
    __in ULONG Protect
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory(
    __in HANDLE ProcessHandle,
    __inout PVOID *BaseAddress,
    __inout PSIZE_T RegionSize,
    __in ULONG FreeType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
    __in HANDLE Handle,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent (
    __in HANDLE EventHandle,
    __out_opt PLONG PreviousState
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushVirtualMemory(
    __in HANDLE ProcessHandle,
    __inout PVOID *BaseAddress,
    __inout PSIZE_T RegionSize,
    __out PIO_STATUS_BLOCK IoStatus
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
    __in HANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in ULONG HandleAttributes,
    __out PHANDLE TokenHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
    __in HANDLE ThreadHandle,
    __in ACCESS_MASK DesiredAccess,
    __in BOOLEAN OpenAsSelf,
    __in ULONG HandleAttributes,
    __out PHANDLE TokenHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationToken (
    __in HANDLE TokenHandle,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __in_bcount(TokenInformationLength) PVOID TokenInformation,
    __in ULONG TokenInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationToken (
    __in HANDLE TokenHandle,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __out_bcount_part(TokenInformationLength,*ReturnLength) PVOID TokenInformation,
    __in ULONG TokenInformationLength,
    __out PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
    __in HANDLE Handle,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
    __in HANDLE Handle,
    __in SECURITY_INFORMATION SecurityInformation,
    __out_bcount_part(Length,*LengthNeeded) PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG Length,
    __out PULONG LengthNeeded
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
ZwLockFile(
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in PLARGE_INTEGER ByteOffset,
    __in PLARGE_INTEGER Length,
    __in ULONG Key,
    __in BOOLEAN FailImmediately,
    __in BOOLEAN ExclusiveLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in PLARGE_INTEGER ByteOffset,
    __in PLARGE_INTEGER Length,
    __in ULONG Key
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryQuotaInformationFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in BOOLEAN ReturnSingleEntry,
    __in_bcount_opt(SidListLength) PVOID SidList,
    __in ULONG SidListLength,
    __in_opt PSID StartSid,
    __in BOOLEAN RestartScan
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
ZwSetQuotaInformationFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
ZwConnectPort(
    __out PHANDLE PortHandle,
    __in PUNICODE_STRING PortName,
    __in PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    __inout_opt PPORT_VIEW ClientView,
    __inout_opt PREMOTE_PORT_VIEW ServerView,
    __out_opt PULONG MaxMessageLength,
    __inout_opt PVOID ConnectionInformation,
    __inout_opt PULONG ConnectionInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSYSAPI
NTSTATUS
NTAPI
ZwSecureConnectPort(
    __out PHANDLE PortHandle,
    __in PUNICODE_STRING PortName,
    __in PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    __inout_opt PPORT_VIEW ClientView,
    __in_opt PSID RequiredServerSid,
    __inout_opt PREMOTE_PORT_VIEW ServerView,
    __out_opt PULONG MaxMessageLength,
    __inout_opt PVOID ConnectionInformation,
    __inout_opt PULONG ConnectionInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    __in HANDLE PortHandle,
    __in PPORT_MESSAGE RequestMessage,
    __out PPORT_MESSAGE ReplyMessage
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
ZwFlushBuffersFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

NTSTATUS
ZwQueryEaFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in BOOLEAN ReturnSingleEntry,
    __in_bcount_opt(EaListLength) PVOID EaList,
    __in ULONG EaListLength,
    __in_opt PULONG EaIndex,
    __in BOOLEAN RestartScan
    );

NTSTATUS
ZwSetEaFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );



#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4115)
#pragma warning(default:4201)
#pragma warning(default:4214)
#endif

#endif // _NTIFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntddnlb.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    ntddnlb.h

Abstract:

    This header describes the structures and interfaces required to interact
    with the NLB intermediate device driver.

Revision History:

--*/

#ifndef __NTDDNLB_H__
#define __NTDDNLB_H__

#pragma once

#if (NTDDI_VERSION >= NTDDI_WS03)

/*
 * Note: This file is intended for inclusion by kernel-mode components that
 *       wish to utilize the public kernel-mode NLB connection notification 
 *       interface or the public kernel-mode NLB hook IOCTLs.  In order to 
 *       include only those definitions that are relevant to user-level 
 *       programs (i.e., registry key names), ensure that the following 
 *       macro is defined prior to including this file either via the 
 *       compiler command line:
 *
 *       -DNTDDNLB_USER_MODE_DEFINITIONS_ONLY=1
 *
 *       or in the source file(s) before inclusion of this file:
 *
 *       #define NTDDNLB_USER_MODE_DEFINITIONS_ONLY
 *
 *       Failing to define this macro before including this file in a user-
 *       level program will otherwise result in compilation failure.
 */

/*
  This registry key can be used to configure NLB to allow inter-host 
  communication in a unicast cluster under the following conditions:

  (i)  EVERY host in the cluster is properly configured with a Dedicated
       IP address, where "properly configured" implies:

       (a) The Dedicated IP address configured in NLB is valid
       (b) The Dedicated IP address configured in NLB has been added to
           to the TCP/IP properties IP address list OF THE NLB ADAPTER
       (c) The Dedicated IP address is the FIRST IP address listed in
           the TCP/IP properties IP address list OF THE NLB ADAPTER

       If any of these conditions is not met, do not expect inter-host 
       communication to work between all hosts, nor under all circumstances.

  (ii) The host is operating in unicast mode

  If the host is operating in eith multicast mode (multicast or IGMP multicast, 
  this feature is not needed, as hosts can already communication between one 
  another without additional support.

  This registry key will not exist by default, but can be created and
  set on a per-adapter basis under the following registry hive:
        
    HKLM\System\CurrentControlSet\Services\WLBS\Parameters\Interface\{GUID}\

  where {GUID} is the GUID of the particular NLB instance (use the "ClusterIP
  Address" key in this hive to identify clusters).  This key is boolean in 
  nature and is interpreted as follows:

    = 0 -> The feature is not active
    > 0 -> The feature is active

  ** This feature is intended solely for the purpose of inter-host communication 
  within a clustered firewall application (for example, Microsoft ISA Server).  
  Though its use outside of these types of applications is not precluded, ITS 
  USE OUTSIDE OF THESE APPLICATIONS IS EXPLICITLY NOT SUPPORTED BY MICROSOFT.
*/
#define NLB_INTERHOST_COMM_SUPPORT_KEY    L"UnicastInterHostCommSupport"

/*
  These registry keys instruct NLB on which notification mechanism to use.
  When deciding what notifications to use for a given type of notification X, 
  NLB checks the following, in this order:

  (i)  NLB first looks for the Enable[X]Notification registry key under 
        
       HKLM\System\CurrentControlSet\Services\WLBS\Parameters\Global\
        
       This key has three possible values that instruct NLB on which 
       notifications to listen for. They are:

         0 = Do not use any notifications.
         1 = Use the TCP/IP stack's internal notifications.
         2 = Use the NLB public callback notifications.

  (ii) If the Enable[X]Notification registry key is not present, NLB
       defaults to using the internal TCP/IP notifications.
  
  Note: The EnableSYNAttackNotification and EnableTimerStarvationNotification
  keys are not available in Windows Server 2003. Also, post-Windows Server 
  2003, a value of 0 is not permitted for the EnableTCPNotification key.
*/
#define NLB_CONNECTION_CALLBACK_KEY       L"EnableTCPNotification"
#define NLB_SYN_ATTACK_CALLBACK_KEY       L"EnableSYNAttackNotification"
#define NLB_TIMER_STARVATION_CALLBACK_KEY L"EnableTimerStarvationNotification"

/* Each of the above keys can be set to one of the values listed below. */
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define NLB_NOTIFICATION_NONE             0
#define NLB_NOTIFICATION_TCPIP            1
#define NLB_NOTIFICATION_ALTERNATE        2
#else
/* The following are legacy definitions from Windows Server 2003. */
#define NLB_CONNECTION_CALLBACK_NONE      0
#define NLB_CONNECTION_CALLBACK_TCP       1
#define NLB_CONNECTION_CALLBACK_ALTERNATE 2
#endif

/* This is the public callback object on which NLB will listen for all
   public notifications.  Currently, the types of notifications accepted by 
   NLB are session state notifications for TCP (protocol=6), SYN attack
   notifications, and timer starvation notifications (*).
  
   To notify NLB of the beginning/end of a SYN attack or timer starvation,
   open the callback object and call ExNotifyCallback with the following
   parameters:

   CallbackObject - The handle to the NLB public callback object.
   Argument1 - A callback code of type NLB_PUBLIC_CALLBACK_CODE, set to the
               NLBSYNAttackBegins[Ends] or NLBTimerStarvationBegins[Ends] 
               value.
   Argument2 - NULL (this parameter is unused)
   
   NLB requires that each begin notification is accompanied by a
   corresponding end notification. Furthermore, NLB makes no guarantees as 
   to the order in which multiple begin/end notifications are processed; it 
   is up to the caller to provide any necessary serialization.

   To notify NLB when connections change state, open the callback object,
   and call ExNotifyCallback with the following parameters (**):
   
   CallbackObject - The handle to the NLB public callback object.
   Argument1 - A callback code of type NLB_PUBLIC_CALLBACK_CODE, set to the 
               NLBSessionStateChange value.
   Argument2 - A pointer to an NLBConnectionInfo block, defined below.

   For TCP connections, NLB needs to be notified of the following state
   changes:

   CLOSED -> SYN_RCVD: A new incoming connection is being established.  This
   notification requires the IP interface index on which the SYN was
   received.  NLB will create state on the appropriate interface to track
   this TCP connection.
   
   CLOSED -> SYN_SENT: A new outgoing connection is being established.  At
   this time, it is unknown on which interface the connection will
   ultimately be established, so the IP interface index is NOT required for
   this notification.  NLB will create temporary state to track this
   connection should it return on an NLB interface.

   SYN_SENT -> ESTAB: An outgoing connection has been established.  This
   nofication requires the IP interface index on which the connection was
   ultimately established.  If the interface was NLB, state will be created
   to track the new connection; if the interface was not NLB, the temporary
   state created by the SYN_SENT notification is cleaned up.

   SYN_RCVD -> ESTAB: An incoming connection has been established.  This
   notification is not currently required by NLB.

   SYN_SENT -> CLOSED: An outgoing connection has been prematurely
   terminated (the connection never reached the ESTABlished state).  This
   notification does not require the IP interface index.  NLB will destroy
   any state created to track this connection.

   SYN_RCVD -> CLOSED: An outgoing connection has been prematurely
   terminated (the connection never reached the ESTABlished state).  This
   notification does not require the IP interface index.  NLB will destroy
   any state created to track this connection.
   
   ESTAB -> CLOSED: A connection has been *completely* terminated (i.e., the
   connection has gone through TIME_WAIT, if necessary, already).  This
   notification does not require the IP interface index.  NLB will destroy
   any state created to track this connection.

   (*) SYN attack and timer starvation notifications are not available in
   Windows Server 2003.

   (**) In Windows Server 2003, the pointer to the NLBConnectionInfo block
   is passed in Argument1 and Argument2 is set to NULL (unused).
*/
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define NLB_PUBLIC_CALLBACK_NAME          L"\\Callback\\NLBPublicCallback"
#else
/* The following are legacy definitions from Windows Server 2003. */
#define NLB_CONNECTION_CALLBACK_NAME      L"\\Callback\\NLBConnectionCallback"
#endif

/* This enumerated type is used to indicate the type of notification that is
   being sent to the NLB connection callback object. */
typedef enum {
    NLBSessionStateChange,                  /* The state of a session (e.g. a TCP connection) has changed. */
    NLBSYNAttackBegins,                     /* A SYN attack has begun on the machine. */
    NLBSYNAttackEnds,                       /* A SYN attack has ended on the machine. */
    NLBTimerStarvationBegins,               /* Timer starvation has begun on the machine. */
    NLBTimerStarvationEnds                  /* Timer starvation has ended on the machine. */
} NLB_PUBLIC_CALLBACK_CODE;

#define NLB_TCPIP_PROTOCOL_TCP            6 /* IP protocol ID for TCP. */

#define NLB_TCP_CLOSED                    1 /* The TCP connection is/was CLOSED. */
#define NLB_TCP_SYN_SENT                  3 /* The TCP connection is/was in SYN_SENT. */
#define NLB_TCP_SYN_RCVD                  4 /* The TCP connection is/was in SYN_RCVD. */
#define NLB_TCP_ESTAB                     5 /* The TCP connection is/was ESTABlished. */

/* Force default alignment on the callback buffers. */
#pragma pack(push)
#pragma pack()
typedef struct NLBTCPAddressInfo_v1 {
    ULONG             RemoteIPAddress;      /* The remote (client) IP address, in network byte order. */
    ULONG             LocalIPAddress;       /* The local (server) IP address, in network byte order. */
    USHORT            RemotePort;           /* The remote (client) TCP port, in network byte order. */
    USHORT            LocalPort;            /* The local (server) TCP port, in network byte order. */
} NLBTCPAddressInfo_v1;

typedef struct NLBTCPAddressInfo_v2 {
    ADDRESS_FAMILY    AddressFamily;        /* The address family of the remote/local IP addresses (AF_INET or AF_INET6). */
    const UCHAR *     RemoteIPAddress;      /* The remote (client) IP address, in network byte order. */
    const UCHAR *     LocalIPAddress;       /* The local (server) IP address, in network byte order. */
    USHORT            RemotePort;           /* The remote (client) TCP port, in network byte order. */
    USHORT            LocalPort;            /* The local (server) TCP port, in network byte order. */
} NLBTCPAddressInfo_v2;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef NLBTCPAddressInfo_v2 NLBTCPAddressInfo;
#else 
typedef NLBTCPAddressInfo_v1 NLBTCPAddressInfo;
#endif

typedef struct NLBTCPConnectionInfo {
    ULONG             PreviousState;        /* The previous state for the connection, as defined above. */
    ULONG             CurrentState;         /* The new state for the connection, as defined above. */
    ULONG             IPInterface;          /* The IP interface index on which the connection was, or is being, established. */
    NLBTCPAddressInfo Address;              /* A pointer to a block containing the IP tuple for the connection. */
} NLBTCPConnectionInfo;

typedef struct NLBConnectionInfo {
    UCHAR                      Protocol;    /* The protocol of the connection (currently, only TCP is supported). */
    union {
        NLBTCPConnectionInfo * pTCPInfo;    /* A pointer to the TCP connection information block. */
    };
} NLBConnectionInfo;

#pragma pack(pop)

#if !defined (NTDDNLB_USER_MODE_DEFINITIONS_ONLY)

//#include <ndis.h>
//#include <ntddndis.h>
//#include <devioctl.h>

#define NLB_DEVICE_NAME            L"\\Device\\WLBS"                            /* The NLB device name for use in ZwCreateFile, for instance. */

/* 
   This IOCTL registers or de-registers a kernel-mode hook with NLB. The 
   IOCTL must be called at IRQL = PASSIVE_LEVEL.
   
   Returns:
   o STATUS_SUCCESS - if the (de)registration succeeds.
   o STATUS_INVALID_PARAMETER - if a parameter is invalid. E.g.,
       - The I/O buffers are missing or the incorrect size.
       - The HookIdentifier does not match a known NLB hook GUID.
       - The HookTable entry is non-NULL, but the DeregisterCallback is NULL.
       - The HookTable entry is non-NULL, but all hook function pointers are NULL.
       - The HookTable entry is NULL, but no function is registered for this hook.
   o STATUS_ACCESS_DENIED - if the operation will NOT be permitted by NLB. E.g.,
       - The request to (de)register a hook does not come from kernel-mode.
       - The request to (de)register a hook is called at an IRQL > PASSIVE_LEVEL.
       - The de-register information provided is for a hook that was registered
         by a different component, as identified by the RegisteringEntity.
       - The specified hook has already been registered by somebody (anybody).
         Components wishing to change their hook must first de-register it.
*/
#define NLB_IOCTL_REGISTER_HOOK    CTL_CODE(0xc0c0, 18, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define NLB_HOOK_IDENTIFIER_LENGTH 39                                           /* 39 is sufficient for {GUID}. */

#define NLB_FILTER_HOOK_INTERFACE  L"{069267c4-7eee-4aff-832c-02e22e00f96f}"    /* The filter interface includes hooks for influencing the NLB
                                                                                   load-balancing decision on either the send path, receive path,
                                                                                   or both.  This hook will be called for any packet for which
                                                                                   NLB would normally apply load-balancing policy.  Components 
                                                                                   registering this interface should use an NLB_FILTER_HOOK_TABLE
                                                                                   as the hook table in the NLB_IOCTL_REGISTER_HOOK_REQUEST. */

/* The de-register callback must be specifed for all register 
   operations.  This function is called by NLB whenever a 
   registered hook is de-registered, either gracefully by the 
   registrar, or forcefully by NLB itself (as a result of the 
   NLB device driver getting unloaded). */
typedef VOID (* NLBHookDeregister) (PWCHAR pHookIdentifier, HANDLE RegisteringEntity, ULONG Flags);

/* Bit settings for the Flags field of the de-register callback. */
#define NLB_HOOK_DEREGISTER_FLAGS_FORCED 0x00000001

/* This enumerated type is the feedback for all filter hooks. */
typedef enum {
    NLB_FILTER_HOOK_PROCEED_WITH_HASH,                                          /* Continue to load-balance normally; i.e., the hook has no specific feedback. */
    NLB_FILTER_HOOK_REVERSE_HASH,                                               /* Use reverse hashing (use destination parameters, rather than source). */
    NLB_FILTER_HOOK_FORWARD_HASH,                                               /* Use conventional forward hashing (use source parameters). */
    NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY,                                     /* By-pass load-balancing and accept the packet unconditionally. */
    NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY                                      /* By-pass load-balancing and reject the packet unconditionally. */
} NLB_FILTER_HOOK_DIRECTIVE;

/* 
   Filter hooks:

   The adapter GUID (1st parameter) will allow the hook consumer to
   determine the adapter on which the packet is being sent or received.  
   Note that the length parameters are not necesarily indicative of the 
   actual length of the media header or payload themselves, but rather 
   indicate how much of the buffers pointed to are contiguously 
   accessible from the provided pointer.  For instance, the payload
   length may just be the length of an IP header, meaning that only
   the IP header can be found at that pointer.  However, it might
   be equal to the total size of the packet payload, in which case, 
   that pointer can be used to access subsequent pieces of the 
   packet, such as the TCP header.  If the payload length provided
   is not sufficient to find all necessary packet information, the
   packet pointer can be used to traverse the packet buffers manually 
   to try and find the information needed.  However, note that the 
   packet may not always be available (it may be NULL).
*/

/* The send filter hook is invoked for every packet sent on any
   adapter to which NLB is bound for which NLB would normally 
   apply load-balancing policy.  ARPs, for instance, are not 
   filtered by NLB, so such packets would not be indicated to 
   this hook. */
typedef NLB_FILTER_HOOK_DIRECTIVE (* NLBSendFilterHook_v1) (
    const WCHAR *       pAdapter,                                               /* The GUID of the adapter on which the packet is being sent. */
/* Even though this type is versioned, a compile error occurs if the
   NDIS_PACKET type is referenced from a non-legacy (NDIS 6.0+) driver. */
#ifndef NDIS60
    const NDIS_PACKET * pPacket,                                                /* A pointer to the NDIS packet, which CAN be NULL if not available. */
#else
    const VOID *        pPacket,
#endif
    const UCHAR *       pMediaHeader,                                           /* A pointer to the media header (ethernet, since NLB supports only ethernet). */
    ULONG               cMediaHeaderLength,                                     /* The length of contiguous memory accessible from the media header pointer. */
    const UCHAR *       pPayload,                                               /* A pointer to the payload of the packet. */
    ULONG               cPayloadLength,                                         /* The length of contiguous memory accesible from the payload pointer. */
    ULONG               Flags);                                                 /* Hook-related flags including whether or not the cluster is stopped. */

typedef NLB_FILTER_HOOK_DIRECTIVE (* NLBSendFilterHook_v2) (
    const WCHAR *       pAdapter,                                               /* The GUID of the adapter on which the packet is being sent. */
    const NET_BUFFER *  pPacket,                                                /* A pointer to the NDIS packet, which CAN be NULL if not available. */
    const UCHAR *       pMediaHeader,                                           /* A pointer to the media header (ethernet, since NLB supports only ethernet). */
    ULONG               cMediaHeaderLength,                                     /* The length of contiguous memory accessible from the media header pointer. */
    const UCHAR *       pPayload,                                               /* A pointer to the payload of the packet. */
    ULONG               cPayloadLength,                                         /* The length of contiguous memory accesible from the payload pointer. */
    ULONG               Flags);                                                 /* Hook-related flags including whether or not the cluster is stopped. */

/* The receive filter hook is invoked for every packet received 
   on any adapter to which NLB is bound for which NLB would 
   normally apply load-balancing policy.  Some protocols, such
   as ARP, or NLB-specific packets not normally seen by the 
   protocol(s) bound to NLB (heartbeats, remote control requests)
   are not filtered by NLB and will not be indicated to the hook. */
typedef NLB_FILTER_HOOK_DIRECTIVE (* NLBReceiveFilterHook_v1) (
    const WCHAR *       pAdapter,                                               /* The GUID of the adapter on which the packet was received. */
/* Even though this type is versioned, a compile error occurs if the
   NDIS_PACKET type is referenced from a non-legacy (NDIS 6.0+) driver. */
#ifndef NDIS60
    const NDIS_PACKET * pPacket,                                                /* A pointer to the NDIS packet, which CAN be NULL if not available. */
#else
    const VOID *        pPacket,
#endif
    const UCHAR *       pMediaHeader,                                           /* A pointer to the media header (ethernet, since NLB supports only ethernet). */
    ULONG               cMediaHeaderLength,                                     /* The length of contiguous memory accessible from the media header pointer. */
    const UCHAR *       pPayload,                                               /* A pointer to the payload of the packet. */
    ULONG               cPayloadLength,                                         /* The length of contiguous memory accesible from the payload pointer. */
    ULONG               Flags);                                                 /* Hook-related flags including whether or not the cluster is stopped. */

typedef NLB_FILTER_HOOK_DIRECTIVE (* NLBReceiveFilterHook_v2) (
    const WCHAR *       pAdapter,                                               /* The GUID of the adapter on which the packet was received. */
    const NET_BUFFER *  pPacket,                                                /* A pointer to the NDIS packet, which CAN be NULL if not available. */
    const UCHAR *       pMediaHeader,                                           /* A pointer to the media header (ethernet, since NLB supports only ethernet). */
    ULONG               cMediaHeaderLength,                                     /* The length of contiguous memory accessible from the media header pointer. */
    const UCHAR *       pPayload,                                               /* A pointer to the payload of the packet. */
    ULONG               cPayloadLength,                                         /* The length of contiguous memory accesible from the payload pointer. */
    ULONG               Flags);                                                 /* Hook-related flags including whether or not the cluster is stopped. */

/* The query filter hook is invoked in cases where the NLB driver
   needs to invoke its hashing algorithm and therefore needs to 
   know whether or not the hook will influence the way in which 
   manner NLB performs the hash, if at all. */
typedef NLB_FILTER_HOOK_DIRECTIVE (* NLBQueryFilterHook_v1) (
    const WCHAR *       pAdapter,                                               /* The GUID of the adapter on which the packet was received. */
    ULONG               ServerIPAddress,                                        /* The server IP address of the "packet" in NETWORK byte order. */
    USHORT              ServerPort,                                             /* The server port of the "packet" (if applicable to the Protocol) in HOST byte order. */
    ULONG               ClientIPAddress,                                        /* The client IP address of the "packet" in NETWORK byte order. */
    USHORT              ClientPort,                                             /* The client port of the "packet" (if applicable to the Protocol) in HOST byte order. */
    UCHAR               Protocol,                                               /* The IP protocol of the "packet"; TCP, UDP, ICMP, GRE, etc. */
    BOOLEAN             bReceiveContext,                                        /* A boolean to indicate whether the packet is being processed in send or receive context. */
    ULONG               Flags);                                                 /* Hook-related flags including whether or not the cluster is stopped. */

typedef NLB_FILTER_HOOK_DIRECTIVE (* NLBQueryFilterHook_v2) (
    const WCHAR *       pAdapter,                                               /* The GUID of the adapter on which the packet was received. */
    ADDRESS_FAMILY      AddressFamily,                                          /* The address family of the server/client IP addresses (AF_INET or AF_INET6). */
    const UCHAR *       ServerIPAddress,                                        /* The server IP address of the "packet" in NETWORK byte order. */
    USHORT              ServerPort,                                             /* The server port of the "packet" (if applicable to the Protocol) in HOST byte order. */
    const UCHAR *       ClientIPAddress,                                        /* The client IP address of the "packet" in NETWORK byte order. */
    USHORT              ClientPort,                                             /* The client port of the "packet" (if applicable to the Protocol) in HOST byte order. */
    UCHAR               Protocol,                                               /* The IP protocol of the "packet"; TCP, UDP, ICMP, GRE, etc. */
    BOOLEAN             bReceiveContext,                                        /* A boolean to indicate whether the packet is being processed in send or receive context. */
    ULONG               Flags);                                                 /* Hook-related flags including whether or not the cluster is stopped. */

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef NLBSendFilterHook_v2 NLBSendFilterHook;
typedef NLBReceiveFilterHook_v2 NLBReceiveFilterHook;
typedef NLBQueryFilterHook_v2 NLBQueryFilterHook;
#else 
typedef NLBSendFilterHook_v1 NLBSendFilterHook;
typedef NLBReceiveFilterHook_v1 NLBReceiveFilterHook;
typedef NLBQueryFilterHook_v1 NLBQueryFilterHook; 
#endif

/* Bit settings for the Flags field of the filter hooks. */
#define NLB_FILTER_HOOK_FLAGS_STOPPED  0x00000001
#define NLB_FILTER_HOOK_FLAGS_DRAINING 0x00000002

/* Force default alignment on the IOCTL buffers. */
#pragma pack(push)
#pragma pack()
/* This table contains function pointers to register or de-register
   a packet filter hook.  To register a hook, set the appropriate
   function pointer.  Those not being specified (for instance if
   you want to register a receive hook, but not a send hook) should
   be set to NULL.  The QueryHook should ONLY be specified if in 
   conjunction with setting either the send or receive hook; i.e.
   a user may not ONLY register the QueryHook.  Further, if regis-
   tering a send or receive hook (or both), the QueryHook MUST be
   provided in order for NLB to query the hook response for cases
   where a hashing decision is needed, but we are not in the context
   of sending or receiving a packet; most notably, in a connection
   up or down notification from IPSec or TCP. */
typedef struct {
    NLBSendFilterHook    SendHook;
    NLBQueryFilterHook   QueryHook;
    NLBReceiveFilterHook ReceiveHook;
} NLB_FILTER_HOOK_TABLE, * PNLB_FILTER_HOOK_TABLE;

/* This is the input buffer for the hook (de)register IOCTL.  There is
   no corresponding output buffer.  This structure identifies the hook 
   interface being (de)registered, the entity registering the hook and
   all appropriate function pointers (callbacks).  Note that hooks are
   registered in groups, called interfaces, which prevents different
   related hooks from being owned by different entities (for example,
   it prevents one entity owned the send hook, but another owned the 
   receive hook).  Interfaces are identified by a GUID, and to set any
   hook in the interface requires ownership of the entire interface - 
   even if not all hooks in the interface are being specified.  The hook
   table should be a pointer to a hook table of the type required by the
   specified hook identifier.  To de-register a hook, set the hook table 
   pointer to NULL. 

   Note: The HookTable pointer does NOT need to be valid following the 
   completion of the IOCTL.  That is, this pointer is only referenced
   within the context of the IOCTL.
*/
typedef struct {
    WCHAR             HookIdentifier[NLB_HOOK_IDENTIFIER_LENGTH];               /* The GUID identifying the hook interface being registered. */
    HANDLE            RegisteringEntity;                                        /* The open file handle on the NLB driver, which uniquely identifies the registrar. */
    PVOID             HookTable;                                                /* A pointer to the appropriate hook table containing the hook function pointers. */
    NLBHookDeregister DeregisterCallback;                                       /* The de-register callback function, which MUST be non-NULL if the operation is a registration. */
} NLB_IOCTL_REGISTER_HOOK_REQUEST, * PNLB_IOCTL_REGISTER_HOOK_REQUEST;
#pragma pack(pop)

#endif /* !USER_MODE_DEFINITIONS_ONLY */

#endif /* (NTDDI_VERSION >= NTDDI_WS03) */

#endif /* __NTDDNLB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntintsafe.h ===
/******************************************************************
*                                                                 *
*  ntintsafe.h -- This module defines helper functions to prevent *
*                 integer overflow bugs for drivers. A similar    *
*                 file, intsafe.h, is available for applications. *
*                                                                 *
*  Copyright (c) Microsoft Corp.  All rights reserved.            *
*                                                                 *
******************************************************************/
#ifndef _NTINTSAFE_H_INCLUDED_
#define _NTINTSAFE_H_INCLUDED_

#if (_MSC_VER > 1000)
#pragma once
#endif

#include <specstrings.h>    // for __in, etc.

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && (_MSC_VER >= 1300)
#define _W64 __w64
#else
#define _W64
#endif
#endif

//
// typedefs
//
typedef char                CHAR;
typedef signed char         INT8;
typedef unsigned char       UCHAR;
typedef unsigned char       UINT8;
typedef unsigned char       BYTE;
typedef short               SHORT;
typedef signed short        INT16;
typedef unsigned short      USHORT;
typedef unsigned short      UINT16;
typedef unsigned short      WORD;
typedef int                 INT;
typedef signed int          INT32;
typedef unsigned int        UINT;
typedef unsigned int        UINT32;
typedef long                LONG;
typedef unsigned long       ULONG;
typedef unsigned long       DWORD;
typedef __int64             LONGLONG;
typedef __int64             LONG64;
typedef signed __int64      RtlINT64;
typedef unsigned __int64    ULONGLONG;
typedef unsigned __int64    DWORDLONG;
typedef unsigned __int64    ULONG64;
typedef unsigned __int64    DWORD64;
typedef unsigned __int64    UINT64;

#if (__midl > 501)
typedef [public]          __int3264 INT_PTR;
typedef [public] unsigned __int3264 UINT_PTR;
typedef [public]          __int3264 LONG_PTR;
typedef [public] unsigned __int3264 ULONG_PTR;
#else
#ifdef _WIN64
typedef __int64             INT_PTR;
typedef unsigned __int64    UINT_PTR;
typedef __int64             LONG_PTR;
typedef unsigned __int64    ULONG_PTR;
#else
typedef _W64 int            INT_PTR;
typedef _W64 unsigned int   UINT_PTR;
typedef _W64 long           LONG_PTR;
typedef _W64 unsigned long  ULONG_PTR;
#endif // WIN64
#endif // (__midl > 501)

#ifdef _WIN64
typedef __int64             ptrdiff_t;
typedef unsigned __int64    size_t;
#else
typedef _W64 int            ptrdiff_t;
typedef _W64 unsigned int   size_t;
#endif

typedef ULONG_PTR   DWORD_PTR;
typedef LONG_PTR    SSIZE_T;
typedef ULONG_PTR   SIZE_T;

#undef _USE_INTRINSIC_MULTIPLY128

#if !defined(_M_CEE) && (defined(_AMD64_) || (defined(_IA64_) && (_MSC_VER >= 1400)))
#define _USE_INTRINSIC_MULTIPLY128
#endif

#if defined(_USE_INTRINSIC_MULTIPLY128)
#ifdef __cplusplus
extern "C" {
#endif

#define UnsignedMultiply128 _umul128

ULONG64
UnsignedMultiply128 (
    __in ULONG64  Multiplier,
    __in ULONG64  Multiplicand,
    __out __deref_out_range(==,Multiplier * Multiplicand) ULONG64 *HighProduct
    );
#pragma intrinsic(_umul128)

#ifdef __cplusplus
}
#endif
#endif // _USE_INTRINSIC_MULTIPLY128



typedef __success(return >= 0) long NTSTATUS;

#define NT_SUCCESS(Status)  (((NTSTATUS)(Status)) >= 0)

#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#ifndef SORTPP_PASS 
// compiletime asserts (failure results in error C2118: negative subscript)
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#else
#define C_ASSERT(e)
#endif

//
// UInt32x32To64 macro
//
#if defined(MIDL_PASS) || defined(RC_INVOKED) || defined(_M_CEE_PURE) \
    || defined(_68K_) || defined(_MPPC_) \
    || defined(_M_IA64) || defined(_M_AMD64)
#define UInt32x32To64(a, b) (((unsigned __int64)((unsigned int)(a))) * ((unsigned __int64)((unsigned int)(b))))
#elif defined(_M_IX86)
#define UInt32x32To64(a, b) ((unsigned __int64)(((unsigned __int64)((unsigned int)(a))) * ((unsigned int)(b))))
#else
#error Must define a target architecture.
#endif

//
// Min/Max type values
//
#define INT8_MIN        (-127i8 - 1)
#define SHORT_MIN       (-32768)
#define INT16_MIN       (-32767i16 - 1)
#define INT_MIN         (-2147483647 - 1)
#define INT32_MIN       (-2147483647i32 - 1)
#define LONG_MIN        (-2147483647L - 1)
#define LONGLONG_MIN    (-9223372036854775807i64 - 1)
#define LONG64_MIN      (-9223372036854775807i64 - 1)
#define INT64_MIN       (-9223372036854775807i64 - 1)
#define INT128_MIN      (-170141183460469231731687303715884105727i128 - 1)

#ifdef _WIN64
#define INT_PTR_MIN     (-9223372036854775807i64 - 1)
#define LONG_PTR_MIN    (-9223372036854775807i64 - 1)
#define PTRDIFF_T_MIN   (-9223372036854775807i64 - 1)
#define SSIZE_T_MIN     (-9223372036854775807i64 - 1)
#else
#define INT_PTR_MIN     (-2147483647 - 1)
#define LONG_PTR_MIN    (-2147483647L - 1)
#define PTRDIFF_T_MIN   (-2147483647 - 1)
#define SSIZE_T_MIN     (-2147483647L - 1)
#endif

#define INT8_MAX        127i8
#define UINT8_MAX       0xffui8
#define BYTE_MAX        0xff
#define SHORT_MAX       32767
#define INT16_MAX       32767i16
#define USHORT_MAX      0xffff
#define UINT16_MAX      0xffffui16
#define WORD_MAX        0xffff
#define INT_MAX         2147483647
#define INT32_MAX       2147483647i32
#define UINT_MAX        0xffffffff
#define UINT32_MAX      0xffffffffui32
#define LONG_MAX        2147483647L
#define ULONG_MAX       0xffffffffUL
#define DWORD_MAX       0xffffffffUL
#define LONGLONG_MAX    9223372036854775807i64
#define LONG64_MAX      9223372036854775807i64
#define INT64_MAX       9223372036854775807i64
#define ULONGLONG_MAX   0xffffffffffffffffui64
#define DWORDLONG_MAX   0xffffffffffffffffui64
#define ULONG64_MAX     0xffffffffffffffffui64
#define DWORD64_MAX     0xffffffffffffffffui64
#define UINT64_MAX      0xffffffffffffffffui64
#define INT128_MAX      170141183460469231731687303715884105727i128
#define UINT128_MAX     0xffffffffffffffffffffffffffffffffui128

#undef SIZE_T_MAX

#ifdef _WIN64
#define INT_PTR_MAX     9223372036854775807i64
#define UINT_PTR_MAX    0xffffffffffffffffui64
#define LONG_PTR_MAX    9223372036854775807i64
#define ULONG_PTR_MAX   0xffffffffffffffffui64
#define DWORD_PTR_MAX   0xffffffffffffffffui64
#define PTRDIFF_T_MAX   9223372036854775807i64
#define SIZE_T_MAX      0xffffffffffffffffui64
#define SSIZE_T_MAX     9223372036854775807i64
#define _SIZE_T_MAX     0xffffffffffffffffui64
#else
#define INT_PTR_MAX     2147483647 
#define UINT_PTR_MAX    0xffffffff
#define LONG_PTR_MAX    2147483647L
#define ULONG_PTR_MAX   0xffffffffUL
#define DWORD_PTR_MAX   0xffffffffUL
#define PTRDIFF_T_MAX   2147483647
#define SIZE_T_MAX      0xffffffff
#define SSIZE_T_MAX     2147483647L
#define _SIZE_T_MAX     0xffffffffUL
#endif


//
// It is common for -1 to be used as an error value
//
#define INT8_ERROR      (-1i8)
#define UINT8_ERROR     0xffui8
#define BYTE_ERROR      0xff
#define SHORT_ERROR     (-1)
#define INT16_ERROR     (-1i16)
#define USHORT_ERROR    0xffff
#define UINT16_ERROR    0xffffui16
#define WORD_ERROR      0xffff
#define INT_ERROR       (-1)
#define INT32_ERROR     (-1i32)
#define UINT_ERROR      0xffffffff
#define UINT32_ERROR    0xffffffffui32
#define LONG_ERROR      (-1L)
#define ULONG_ERROR     0xffffffffUL
#define DWORD_ERROR     0xffffffffUL
#define LONGLONG_ERROR  (-1i64)
#define LONG64_ERROR    (-1i64)
#define INT64_ERROR     (-1i64)
#define ULONGLONG_ERROR 0xffffffffffffffffui64
#define DWORDLONG_ERROR 0xffffffffffffffffui64
#define ULONG64_ERROR   0xffffffffffffffffui64
#define UINT64_ERROR    0xffffffffffffffffui64

#ifdef _WIN64
#define INT_PTR_ERROR   (-1i64)
#define UINT_PTR_ERROR  0xffffffffffffffffui64
#define LONG_PTR_ERROR  (-1i64)
#define ULONG_PTR_ERROR 0xffffffffffffffffui64
#define DWORD_PTR_ERROR 0xffffffffffffffffui64
#define PTRDIFF_T_ERROR (-1i64)
#define SIZE_T_ERROR    0xffffffffffffffffui64
#define SSIZE_T_ERROR   (-1i64)
#define _SIZE_T_ERROR   0xffffffffffffffffui64
#else
#define INT_PTR_ERROR   (-1) 
#define UINT_PTR_ERROR  0xffffffff
#define LONG_PTR_ERROR  (-1L)
#define ULONG_PTR_ERROR 0xffffffffUL
#define DWORD_PTR_ERROR 0xffffffffUL
#define PTRDIFF_T_ERROR (-1)
#define SIZE_T_ERROR    0xffffffff
#define SSIZE_T_ERROR   (-1L)
#define _SIZE_T_ERROR   0xffffffffUL
#endif


//
// We make some assumptions about the sizes of various types. Let's be
// explicit about those assumptions and check them.
//
C_ASSERT(sizeof(USHORT) == 2);
C_ASSERT(sizeof(INT) == 4);
C_ASSERT(sizeof(UINT) == 4);
C_ASSERT(sizeof(LONG) == 4);
C_ASSERT(sizeof(ULONG) == 4);
C_ASSERT(sizeof(UINT_PTR) == sizeof(ULONG_PTR));


//=============================================================================
// Conversion functions
//
// There are three reasons for having conversion functions:
//
// 1. We are converting from a signed type to an unsigned type of the same
//    size, or vice-versa.
//
//    Since we only have unsigned math functions, this allows people to convert
//    to unsigned, do the math, and then convert back to signed.
//
// 2. We are converting to a smaller type, and we could therefore possibly
//    overflow.
//
// 3. We are converting to a bigger type, and we are signed and the type we are
//    converting to is unsigned.
//
//=============================================================================


//
// INT8 -> UCHAR conversion
//
__inline
NTSTATUS
RtlInt8ToUChar(
    __in INT8 i8Operand,
    __out __deref_out_range(==,i8Operand) UCHAR* pch)
{
    NTSTATUS status;

    if (i8Operand >= 0)
    {
        *pch = (UCHAR)i8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT8 -> UINT8 conversion
//
__inline
NTSTATUS
RtlInt8ToUInt8(
    __in INT8 i8Operand,
    __out __deref_out_range(==,i8Operand) UINT8* pu8Result)
{
    NTSTATUS status;
    
    if (i8Operand >= 0)
    {
        *pu8Result = (UINT8)i8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT8 -> BYTE conversion
//
#define RtlInt8ToByte  RtlInt8ToUInt8

//
// INT8 -> USHORT conversion
//
__inline
NTSTATUS
RtlInt8ToUShort(
    __in INT8 i8Operand,
    __out __deref_out_range(==,i8Operand) USHORT* pusResult)
{
    NTSTATUS status;
    
    if (i8Operand >= 0)
    {
        *pusResult = (USHORT)i8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT8 -> UINT16 conversion
//
#define RtlInt8ToUInt16    RtlInt8ToUShort

//
// INT8 -> WORD conversion
//
#define RtlInt8ToWord  RtlInt8ToUShort

//
// INT8 -> UINT conversion
//
__inline
NTSTATUS
RtlInt8ToUInt(
    __in INT8 i8Operand,
    __out __deref_out_range(==,i8Operand) UINT* puResult)
{
    NTSTATUS status;
    
    if (i8Operand >= 0)
    {
        *puResult = (UINT)i8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT8 -> UINT32 conversion
//
#define RtlInt8ToUInt32    RtlInt8ToUInt

//
// INT8 -> UINT_PTR conversion
//
__inline
NTSTATUS
RtlInt8ToUIntPtr(
    __in INT8 i8Operand,
    __out __deref_out_range(==,i8Operand) UINT_PTR* puResult)
{
    NTSTATUS status;
    
    if (i8Operand >= 0)
    {
        *puResult = (UINT_PTR)i8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT8 -> ULONG conversion
//
__inline
NTSTATUS
RtlInt8ToULong(
    __in INT8 i8Operand,
    __out __deref_out_range(==,i8Operand) ULONG* pulResult)
{
    NTSTATUS status;
    
    if (i8Operand >= 0)
    {
        *pulResult = (ULONG)i8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT8 -> ULONG_PTR conversion
//
__inline
NTSTATUS
RtlInt8ToULongPtr(
    __in INT8 i8Operand,
    __out __deref_out_range(==,i8Operand) ULONG_PTR* pulResult)
{
    NTSTATUS status;
    
    if (i8Operand >= 0)
    {
        *pulResult = (ULONG_PTR)i8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT8 -> DWORD conversion
//
#define RtlInt8ToDWord RtlInt8ToULong

//
// INT8 -> DWORD_PTR conversion
//
#define RtlInt8ToDWordPtr  RtlInt8ToULongPtr

//
// INT8 -> ULONGLONG conversion
//
__inline
NTSTATUS
RtlInt8ToULongLong(
    __in INT8 i8Operand,
    __out __deref_out_range(==,i8Operand) ULONGLONG* pullResult)
{
    NTSTATUS status;
    
    if (i8Operand >= 0)
    {
        *pullResult = (ULONGLONG)i8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT8 -> DWORDLONG conversion
//
#define RtlInt8ToDWordLong RtlInt8ToULongLong

//
// INT8 -> ULONG64 conversion
//
#define RtlInt8ToULong64   RtlInt8ToULongLong

//
// INT8 -> DWORD64 conversion
//
#define RtlInt8ToDWord64   RtlInt8ToULongLong

//
// INT8 -> UINT64 conversion
//
#define RtlInt8ToUInt64    RtlInt8ToULongLong

//
// INT8 -> size_t conversion
//
#define RtlInt8ToSizeT RtlInt8ToUIntPtr

//
// INT8 -> SIZE_T conversion
//
#define RtlInt8ToSIZET RtlInt8ToULongPtr

//
// UINT8 -> INT8 conversion
//
__inline
NTSTATUS
RtlUInt8ToInt8(
    __in UINT8 u8Operand,
    __out __deref_out_range(==,u8Operand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if (u8Operand <= INT8_MAX)
    {
        *pi8Result = (INT8)u8Operand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT8 -> CHAR conversion
//
__forceinline
NTSTATUS
RtlUInt8ToChar(
    __in UINT8 u8Operand,
    __out __deref_out_range(==,u8Operand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    *pch = (CHAR)u8Operand;
    return STATUS_SUCCESS;
#else
    return RtlUInt8ToInt8(u8Operand, (INT8*)pch);
#endif
}

//
// BYTE -> INT8 conversion
//
__inline
NTSTATUS
RtlByteToInt8(
    __in BYTE bOperand,
    __out __deref_out_range(==,bOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if (bOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)bOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// BYTE -> CHAR conversion
//
__forceinline
NTSTATUS
RtlByteToChar(
    __in BYTE bOperand,
    __out __deref_out_range(==,bOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    *pch = (CHAR)bOperand;
    return STATUS_SUCCESS;
#else
    return RtlByteToInt8(bOperand, (INT8*)pch);
#endif
}

//
// SHORT -> INT8 conversion
//
__inline
NTSTATUS
RtlShortToInt8(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) INT8* pi8Result)
{
    NTSTATUS status;

    if ((sOperand >= INT8_MIN) && (sOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// SHORT -> UCHAR conversion
//
__inline
NTSTATUS
RtlShortToUChar(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) UCHAR* pch)
{
    NTSTATUS status;

    if ((sOperand >= 0) && (sOperand <= 255))
    {
        *pch = (UCHAR)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// SHORT -> CHAR conversion
//
__forceinline
NTSTATUS
RtlShortToChar(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlShortToUChar(sOperand, (UCHAR*)pch);
#else
    return RtlShortToInt8(sOperand, (INT8*)pch);
#endif // _CHAR_UNSIGNED
}

//
// SHORT -> UINT8 conversion
//
__inline
NTSTATUS
RtlShortToUInt8(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) UINT8* pui8Result)
{
    NTSTATUS status;

    if ((sOperand >= 0) && (sOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// SHORT -> BYTE conversion
//
#define RtlShortToByte  RtlShortToUInt8

//
// SHORT -> USHORT conversion
//
__inline
NTSTATUS
RtlShortToUShort(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) USHORT* pusResult)
{
    NTSTATUS status;

    if (sOperand >= 0)
    {
        *pusResult = (USHORT)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// SHORT -> UINT16 conversion
//
#define RtlShortToUInt16   RtlShortToUShort

//
// SHORT -> WORD conversion
//
#define RtlShortToWord RtlShortToUShort

//
// SHORT -> UINT conversion
//
__inline
NTSTATUS
RtlShortToUInt(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) UINT* puResult)
{
    NTSTATUS status;

    if (sOperand >= 0)
    {
        *puResult = (UINT)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// SHORT -> UINT32 conversion
//
#define RtlShortToUInt32   RtlShortToUInt

//
// SHORT -> UINT_PTR conversion
//
__inline
NTSTATUS
RtlShortToUIntPtr(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) UINT_PTR* puResult)
{
    NTSTATUS status;

    if (sOperand >= 0)
    {
        *puResult = (UINT_PTR)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// SHORT -> ULONG conversion
//
__inline
NTSTATUS
RtlShortToULong(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) ULONG* pulResult)
{
    NTSTATUS status;
    
    if (sOperand >= 0)
    {
        *pulResult = (ULONG)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// SHORT -> ULONG_PTR conversion
//
__inline
NTSTATUS
RtlShortToULongPtr(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) ULONG_PTR* pulResult)
{
    NTSTATUS status;
    
    if (sOperand >= 0)
    {
        *pulResult = (ULONG_PTR)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// SHORT -> DWORD conversion
//
#define RtlShortToDWord    RtlShortToULong

//
// SHORT -> DWORD_PTR conversion
//
__inline
NTSTATUS
RtlShortToDWordPtr(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) DWORD_PTR* pdwResult)
{
    NTSTATUS status;
    
    if (sOperand >= 0)
    {
        *pdwResult = (DWORD_PTR)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pdwResult = DWORD_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// SHORT -> ULONGLONG conversion
//
__inline
NTSTATUS
RtlShortToULongLong(
    __in SHORT sOperand,
    __out __deref_out_range(==,sOperand) ULONGLONG* pullResult)
{
    NTSTATUS status;

    if (sOperand >= 0)
    {
        *pullResult = (ULONGLONG)sOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// SHORT -> DWORDLONG conversion
//
#define RtlShortToDWordLong    RtlShortToULongLong

//
// SHORT -> ULONG64 conversion
//
#define RtlShortToULong64  RtlShortToULongLong

//
// SHORT -> DWORD64 conversion
//
#define RtlShortToDWord64  RtlShortToULongLong

//
// SHORT -> UINT64 conversion
//
#define RtlShortToUInt64   RtlShortToULongLong

//
// SHORT -> size_t conversion
//
#define RtlShortToSizeT    RtlShortToUIntPtr

//
// SHORT -> SIZE_T conversion
//
#define RtlShortToSIZET    RtlShortToULongPtr

//
// INT16 -> CHAR conversion
//
#define RtlInt16ToChar RtlShortToChar

//
// INT16 -> INT8 conversion
//
#define RtlInt16ToInt8 RtlShortToInt8

//
// INT16 -> UCHAR conversion
//
#define RtlInt16ToUChar    RtlShortToUChar

//
// INT16 -> UINT8 conversion
//
#define RtlInt16ToUInt8    RtlShortToUInt8

//
// INT16 -> BYTE conversion
//
#define RtlInt16ToByte RtlShortToUInt8

//
// INT16 -> USHORT conversion
//
#define RtlInt16ToUShort   RtlShortToUShort

//
// INT16 -> UINT16 conversion
//
#define RtlInt16ToUInt16   RtlShortToUShort

//
// INT16 -> WORD conversion
//
#define RtlInt16ToWord RtlShortToUShort

//
// INT16 -> UINT conversion
//
#define RtlInt16ToUInt RtlShortToUInt

//
// INT16 -> UINT32 conversion
//
#define RtlInt16ToUInt32   RtlShortToUInt

//
// INT16 -> UINT_PTR conversion
//
#define RtlInt16ToUIntPtr  RtlShortToUIntPtr

//
// INT16 -> ULONG conversion
//
#define RtlInt16ToULong    RtlShortToULong

//
// INT16 -> ULONG_PTR conversion
//
#define RtlInt16ToULongPtr RtlShortToULongPtr

//
// INT16 -> DWORD conversion
//
#define RtlInt16ToDWord    RtlShortToULong

//
// INT16 -> DWORD_PTR conversion
//
#define RtlInt16ToDWordPtr RtlShortToULongPtr

//
// INT16 -> ULONGLONG conversion
//
#define RtlInt16ToULongLong    RtlShortToULongLong

//
// INT16 -> DWORDLONG conversion
//
#define RtlInt16ToDWordLong    RtlShortToULongLong

//
// INT16 -> ULONG64 conversion
//
#define RtlInt16ToULong64  RtlShortToULongLong

//
// INT16 -> DWORD64 conversion
//
#define RtlInt16ToDWord64  RtlShortToULongLong

//
// INT16 -> UINT64 conversion
//
#define RtlInt16ToUInt64   RtlShortToULongLong

//
// INT16 -> size_t conversion
//
#define RtlInt16ToSizeT    RtlShortToUIntPtr

//
// INT16 -> SIZE_T conversion
//
#define RtlInt16ToSIZET    RtlShortToULongPtr

//
// USHORT -> INT8 conversion
//
__inline
NTSTATUS
RtlUShortToInt8(
    __in USHORT usOperand,
    __out __deref_out_range(==,usOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if (usOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)usOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// USHORT -> UCHAR conversion
//
__inline
NTSTATUS
RtlUShortToUChar(
    __in USHORT usOperand,
    __out __deref_out_range(==,usOperand) UCHAR* pch)
{
    NTSTATUS status;

    if (usOperand <= 255)
    {
        *pch = (UCHAR)usOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// USHORT -> CHAR conversion
//
__forceinline
NTSTATUS
RtlUShortToChar(
    __in USHORT usOperand,
    __out __deref_out_range(==,usOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlUShortToUChar(usOperand, (UCHAR*)pch);
#else
    return RtlUShortToInt8(usOperand, (INT8*)pch);
#endif // _CHAR_UNSIGNED
}

//
// USHORT -> UINT8 conversion
//
__inline
NTSTATUS
RtlUShortToUInt8(
    __in USHORT usOperand,
    __out __deref_out_range(==,usOperand) UINT8* pui8Result)
{
    NTSTATUS status;
    
    if (usOperand <= UINT8_MAX)
    {
        *pui8Result = (UINT8)usOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// USHORT -> BYTE conversion
//
#define RtlUShortToByte    RtlUShortToUInt8

//
// USHORT -> SHORT conversion
//
__inline
NTSTATUS
RtlUShortToShort(
    __in USHORT usOperand,
    __out __deref_out_range(==,usOperand) SHORT* psResult)
{
    NTSTATUS status;

    if (usOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)usOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// USHORT -> INT16 conversion
//
#define RtlUShortToInt16   RtlUShortToShort

//
// UINT16 -> CHAR conversion
//
#define RtlUInt16ToChar    RtlUShortToChar

//
// UINT16 -> INT8 conversion
//
#define RtlUInt16ToInt8    RtlUShortToInt8

//
// UINT16 -> UCHAR conversion
//
#define RtlUInt16ToUChar   RtlUShortToUChar

//
// UINT16 -> UINT8 conversion
//
#define RtlUInt16ToUInt8   RtlUShortToUInt8

//
// UINT16 -> BYTE conversion
//
#define RtlUInt16ToByte    RtlUShortToUInt8

//
// UINT16 -> SHORT conversion
//
#define RtlUInt16ToShort   RtlUShortToShort

//
// UINT16 -> INT16 conversion
//
#define RtlUInt16ToInt16   RtlUShortToShort

//
// WORD -> INT8 conversion
//
#define RtlWordToInt8  RtlUShortToInt8

//
// WORD -> CHAR conversion
//
#define RtlWordToChar  RtlUShortToChar

//
// WORD -> UCHAR conversion
//
#define RtlWordToUChar RtlUShortToUChar

//
// WORD -> UINT8 conversion
//
#define RtlWordToUInt8 RtlUShortToUInt8

//
// WORD -> BYTE conversion
//
#define RtlWordToByte  RtlUShortToUInt8

//
// WORD -> SHORT conversion
//
#define RtlWordToShort RtlUShortToShort

//
// WORD -> INT16 conversion
//
#define RtlWordToInt16 RtlUShortToShort

//
// INT -> INT8 conversion
//
__inline
NTSTATUS
RtlIntToInt8(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if ((iOperand >= INT8_MIN) && (iOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT -> UCHAR conversion
//
__inline
NTSTATUS
RtlIntToUChar(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) UCHAR* pch)
{
    NTSTATUS status;

    if ((iOperand >= 0) && (iOperand <= 255))
    {
        *pch = (UCHAR)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT -> CHAR conversion
//
__forceinline
NTSTATUS
RtlIntToChar(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlIntToUChar(iOperand, (UCHAR*)pch);
#else
    return RtlIntToInt8(iOperand, (INT8*)pch);
#endif // _CHAR_UNSIGNED
}

//
// INT -> BYTE conversion
//
#define RtlIntToByte   RtlIntToUInt8

//
// INT -> UINT8 conversion
//
__inline
NTSTATUS
RtlIntToUInt8(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) UINT8* pui8Result)
{
    NTSTATUS status;
    
    if ((iOperand >= 0) && (iOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT -> SHORT conversion
//
__inline
NTSTATUS
RtlIntToShort(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) SHORT* psResult)
{
    NTSTATUS status;

    if ((iOperand >= SHORT_MIN) && (iOperand <= SHORT_MAX))
    {
        *psResult = (SHORT)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT -> INT16 conversion
//
#define RtlIntToInt16  RtlIntToShort

//
// INT -> USHORT conversion
//
__inline
NTSTATUS
RtlIntToUShort(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) USHORT* pusResult)
{
    NTSTATUS status;

    if ((iOperand >= 0) && (iOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT -> UINT16 conversion
//
#define RtlIntToUInt16  RtlIntToUShort

//
// INT -> WORD conversion
//
#define RtlIntToWord   RtlIntToUShort

//
// INT -> UINT conversion
//
__inline
NTSTATUS
RtlIntToUInt(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) UINT* puResult)
{
    NTSTATUS status;

    if (iOperand >= 0)
    {
        *puResult = (UINT)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT -> UINT_PTR conversion
//
#ifdef _WIN64
#define RtlIntToUIntPtr    RtlIntToULongLong
#else
#define RtlIntToUIntPtr    RtlIntToUInt
#endif

//
// INT -> ULONG conversion
//
__inline
NTSTATUS
RtlIntToULong(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) ULONG* pulResult)
{
    NTSTATUS status;

    if (iOperand >= 0)
    {
        *pulResult = (ULONG)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT -> ULONG_PTR conversion
//
#ifdef _WIN64
#define RtlIntToULongPtr   RtlIntToULongLong
#else
#define RtlIntToULongPtr   RtlIntToULong
#endif

//
// INT -> DWORD conversion
//
#define RtlIntToDWord  RtlIntToULong

//
// INT -> DWORD_PTR conversion
//
#define RtlIntToDWordPtr   RtlIntToULongPtr

//
// INT -> ULONGLONG conversion
//
__inline
NTSTATUS
RtlIntToULongLong(
    __in INT iOperand,
    __out __deref_out_range(==,iOperand) ULONGLONG* pullResult)
{
    NTSTATUS status;

    if (iOperand >= 0)
    {
        *pullResult = (ULONGLONG)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT -> DWORDLONG conversion
//
#define RtlIntToDWordLong  RtlIntToULongLong

//
// INT -> ULONG64 conversion
//
#define RtlIntToULong64    RtlIntToULongLong

//
// INT -> DWORD64 conversion
//
#define RtlIntToDWord64    RtlIntToULongLong

//
// INT -> UINT64 conversion
//
#define RtlIntToUInt64 RtlIntToULongLong

//
// INT -> size_t conversion
//
#define RtlIntToSizeT  RtlIntToUIntPtr

//
// INT -> SIZE_T conversion
//
#define RtlIntToSIZET  RtlIntToULongPtr

//
// INT32 -> CHAR conversion
//
#define RtlInt32ToChar RtlIntToChar

//
// INT32 -> INT328 conversion
//
#define RtlInt32ToInt8 RtlIntToInt8

//
// INT32 -> UCHAR conversion
//
#define RtlInt32ToUChar    RtlIntToUChar

//
// INT32 -> BYTE conversion
//
#define RtlInt32ToByte RtlIntToUInt8

//
// INT32 -> UINT8 conversion
//
#define RtlInt32ToUInt8    RtlIntToUInt8

//
// INT32 -> SHORT conversion
//
#define RtlInt32ToShort    RtlIntToShort

//
// INT32 -> INT16 conversion
//
#define RtlInt32ToInt16    RtlIntToShort

//
// INT32 -> USHORT conversion
//
#define RtlInt32ToUShort   RtlIntToUShort

//
// INT32 -> UINT16 conversion
//
#define RtlInt32ToUInt16   RtlIntToUShort

//
// INT32 -> WORD conversion
//
#define RtlInt32ToWord RtlIntToUShort

//
// INT32 -> UINT conversion
//
#define RtlInt32ToUInt RtlIntToUInt

//
// INT32 -> UINT32 conversion
//
#define RtlInt32ToUInt32   RtlIntToUInt

//
// INT32 -> UINT_PTR conversion
//
#define RtlInt32ToUIntPtr  RtlIntToUIntPtr

//
// INT32 -> ULONG conversion
//
#define RtlInt32ToULong    RtlIntToULong

//
// INT32 -> ULONG_PTR conversion
//
#define RtlInt32ToULongPtr RtlIntToULongPtr

//
// INT32 -> DWORD conversion
//
#define RtlInt32ToDWord    RtlIntToULong

//
// INT32 -> DWORD_PTR conversion
//
#define RtlInt32ToDWordPtr RtlIntToULongPtr

//
// INT32 -> ULONGLONG conversion
//
#define RtlInt32ToULongLong    RtlIntToULongLong

//
// INT32 -> DWORDLONG conversion
//
#define RtlInt32ToDWordLong    RtlIntToULongLong

//
// INT32 -> ULONG64 conversion
//
#define RtlInt32ToULong64  RtlIntToULongLong

//
// INT32 -> DWORD64 conversion
//
#define RtlInt32ToDWord64  RtlIntToULongLong

//
// INT32 -> UINT64 conversion
//
#define RtlInt32ToUInt64   RtlIntToULongLong

//
// INT32 -> size_t conversion
//
#define RtlInt32ToSizeT    RtlIntToUIntPtr

//
// INT32 -> SIZE_T conversion
//
#define RtlInt32ToSIZET    RtlIntToULongPtr

//
// INT_PTR -> INT8 conversion
//
__inline
NTSTATUS
RtlIntPtrToInt8(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if ((iOperand >= INT8_MIN) && (iOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT_PTR -> UCHAR conversion
//
__inline
NTSTATUS
RtlIntPtrToUChar(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) UCHAR* pch)
{
    NTSTATUS status;

    if ((iOperand >= 0) && (iOperand <= 255))
    {
        *pch = (UCHAR)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT_PTR -> CHAR conversion
//
__forceinline
NTSTATUS
RtlIntPtrToChar(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlIntPtrToUChar(iOperand, (UCHAR*)pch);
#else
    return RtlIntPtrToInt8(iOperand, (INT8*)pch);
#endif // _CHAR_UNSIGNED
}

//
// INT_PTR -> UINT8 conversion
//
__inline
NTSTATUS
RtlIntPtrToUInt8(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) UINT8* pui8Result)
{
    NTSTATUS status;
    
    if ((iOperand >= 0) && (iOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// INT_PTR -> BYTE conversion
//
#define RtlIntPtrToByte    RtlIntPtrToUInt8

//
// INT_PTR -> SHORT conversion
//
__inline
NTSTATUS
RtlIntPtrToShort(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) SHORT* psResult)
{
    NTSTATUS status;

    if ((iOperand >= SHORT_MIN) && (iOperand <= SHORT_MAX))
    {
        *psResult = (SHORT)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT_PTR -> INT16 conversion
//
#define RtlIntPtrToInt16   RtlIntPtrToShort

//
// INT_PTR -> USHORT conversion
//
__inline
NTSTATUS
RtlIntPtrToUShort(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) USHORT* pusResult)
{
    NTSTATUS status;

    if ((iOperand >= 0) && (iOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// INT_PTR -> UINT16 conversion
//
#define RtlIntPtrToUInt16  RtlIntPtrToUShort

//
// INT_PTR -> WORD conversion
//
#define RtlIntPtrToWord    RtlIntPtrToUShort

//
// INT_PTR -> INT conversion
//
#ifdef _WIN64
#define RtlIntPtrToInt RtlLongLongToInt
#else
__inline
NTSTATUS
RtlIntPtrToInt(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) INT* piResult)
{
    *piResult = (INT)iOperand;
    return STATUS_SUCCESS;
}
#endif

//
// INT_PTR -> INT32 conversion
//
#define RtlIntPtrToInt32   RtlIntPtrToInt

//
// INT_PTR -> UINT conversion
//
#ifdef _WIN64
#define RtlIntPtrToUInt    RtlLongLongToUInt
#else
__inline
NTSTATUS
RtlIntPtrToUInt(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) UINT* puResult)
{
    NTSTATUS status;

    if (iOperand >= 0)
    {
        *puResult = (UINT)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}
#endif

//
// INT_PTR -> UINT32 conversion
//
#define RtlIntPtrToUInt32  RtlIntPtrToUInt

//
// INT_PTR -> UINT_PTR conversion
//
#ifdef _WIN64
#define RtlIntPtrToUIntPtr RtlLongLongToULongLong
#else
__inline
NTSTATUS
RtlIntPtrToUIntPtr(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) UINT_PTR* puResult)
{
    NTSTATUS status;

    if (iOperand >= 0)
    {
        *puResult = (UINT_PTR)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}
#endif

//
// INT_PTR -> LONG conversion
//
#ifdef _WIN64
#define RtlIntPtrToLong    RtlLongLongToLong
#else
__inline
NTSTATUS
RtlIntPtrToLong(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) LONG* plResult)
{
    *plResult = (LONG)iOperand;
    return STATUS_SUCCESS;
}
#endif

//
// INT_PTR -> LONG_PTR conversion
//
__inline
NTSTATUS
RtlIntPtrToLongPtr(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) LONG_PTR* plResult)
{
    *plResult = (LONG_PTR)iOperand;
    return STATUS_SUCCESS;
}

//
// INT_PTR -> ULONG conversion
//
#ifdef _WIN64
#define RtlIntPtrToULong   RtlLongLongToULong
#else
__inline
NTSTATUS
RtlIntPtrToULong(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) ULONG* pulResult)
{
    NTSTATUS status;

    if (iOperand >= 0)
    {
        *pulResult = (ULONG)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}
#endif

//
// INT_PTR -> ULONG_PTR conversion
//
#ifdef _WIN64
#define RtlIntPtrToULongPtr    RtlLongLongToULongLong
#else
__inline
NTSTATUS
RtlIntPtrToULongPtr(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) ULONG_PTR* pulResult)
{
    NTSTATUS status;

    if (iOperand >= 0)
    {
        *pulResult = (ULONG_PTR)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}
#endif

//
// INT_PTR -> DWORD conversion
//
#define RtlIntPtrToDWord   RtlIntPtrToULong

//    
// INT_PTR -> DWORD_PTR conversion
//
#define RtlIntPtrToDWordPtr    RtlIntPtrToULongPtr

//
// INT_PTR -> ULONGLONG conversion
//
#ifdef _WIN64
#define RtlIntPtrToULongLong   RtlLongLongToULongLong
#else
__inline
NTSTATUS
RtlIntPtrToULongLong(
    __in INT_PTR iOperand,
    __out __deref_out_range(==,iOperand) ULONGLONG* pullResult)
{
    NTSTATUS status;

    if (iOperand >= 0)
    {
        *pullResult = (ULONGLONG)iOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}   
#endif

//
// INT_PTR -> DWORDLONG conversion
//
#define RtlIntPtrToDWordLong   RtlIntPtrToULongLong

//
// INT_PTR -> ULONG64 conversion
//
#define RtlIntPtrToULong64 RtlIntPtrToULongLong

//
// INT_PTR -> DWORD64 conversion
//
#define RtlIntPtrToDWord64 RtlIntPtrToULongLong

//
// INT_PTR -> UINT64 conversion
//
#define RtlIntPtrToUInt64  RtlIntPtrToULongLong

//
// INT_PTR -> size_t conversion
//
#define RtlIntPtrToSizeT   RtlIntPtrToUIntPtr

//
// INT_PTR -> SIZE_T conversion
//
#define RtlIntPtrToSIZET   RtlIntPtrToULongPtr

//
// UINT -> INT8 conversion
//
__inline
NTSTATUS
RtlUIntToInt8(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if (uOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}    

//
// UINT -> UCHAR conversion
//
__inline
NTSTATUS
RtlUIntToUChar(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) UCHAR* pch)
{
    NTSTATUS status;

    if (uOperand <= 255)
    {
        *pch = (UCHAR)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// UINT -> CHAR conversion
//
__forceinline
NTSTATUS
RtlUIntToChar(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlUIntToUChar(uOperand, (UCHAR*)pch);
#else
    return RtlUIntToInt8(uOperand, (INT8*)pch);
#endif
}

//
// UINT -> UINT8 conversion
//
__inline
NTSTATUS
RtlUIntToUInt8(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) UINT8* pui8Result)
{
    NTSTATUS status;
    
    if (uOperand <= UINT8_MAX)
    {
        *pui8Result = (UINT8)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}    
    
//
// UINT -> BYTE conversion
//
#define RtlUIntToByte   RtlUIntToUInt8

//
// UINT -> SHORT conversion
//
__inline
NTSTATUS
RtlUIntToShort(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) SHORT* psResult)
{
    NTSTATUS status;

    if (uOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// UINT -> INT16 conversion
//
#define RtlUIntToInt16 RtlUIntToShort

//
// UINT -> USHORT conversion
//
__inline
NTSTATUS
RtlUIntToUShort(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) USHORT* pusResult)
{
    NTSTATUS status;

    if (uOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// UINT -> UINT16 conversion
//
#define RtlUIntToUInt16    RtlUIntToUShort

//
// UINT -> WORD conversion
//
#define RtlUIntToWord  RtlUIntToUShort

//
// UINT -> INT conversion
//
__inline
NTSTATUS
RtlUIntToInt(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) INT* piResult)
{
    NTSTATUS status;

    if (uOperand <= INT_MAX)
    {
        *piResult = (INT)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *piResult = INT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// UINT -> INT32 conversion
//
#define RtlUIntToInt32 RtlUIntToInt

//
// UINT -> INT_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlUIntToIntPtr(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) INT_PTR* piResult)
{
    *piResult = uOperand;
    return STATUS_SUCCESS;
}
#else
#define RtlUIntToIntPtr    RtlUIntToInt
#endif

//
// UINT -> LONG conversion
//
__inline
NTSTATUS
RtlUIntToLong(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) LONG* plResult)
{
    NTSTATUS status;

    if (uOperand <= LONG_MAX)
    {
        *plResult = (LONG)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT -> LONG_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlUIntToLongPtr(
    __in UINT uOperand,
    __out __deref_out_range(==,uOperand) LONG_PTR* plResult)
{
    *plResult = uOperand;
    return STATUS_SUCCESS;
}
#else
#define RtlUIntToLongPtr   RtlUIntToLong
#endif

//
// UINT -> ptrdiff_t conversion
//
#define RtlUIntToPtrdiffT  RtlUIntToIntPtr

//
// UINT -> SSIZE_T conversion
//
#define RtlUIntToSSIZET    RtlUIntToLongPtr

//
// UINT32 -> CHAR conversion
//
#define RtlUInt32ToChar    RtlUIntToChar

//
// UINT32 -> INT8 conversion
//
#define RtlUInt32ToInt8    RtlUIntToInt8

//
// UINT32 -> UCHAR conversion
//
#define RtlUInt32ToUChar   RtlUIntToUChar

//
// UINT32 -> UINT8 conversion
//
#define RtlUInt32ToUInt8   RtlUIntToUInt8

//
// UINT32 -> BYTE conversion
//
#define RtlUInt32ToByte    RtlUInt32ToUInt8

//
// UINT32 -> SHORT conversion
//
#define RtlUInt32ToShort   RtlUIntToShort

//
// UINT32 -> INT16 conversion
//
#define RtlUInt32ToInt16   RtlUIntToShort

//
// UINT32 -> USHORT conversion
//
#define RtlUInt32ToUShort  RtlUIntToUShort

//
// UINT32 -> UINT16 conversion
//
#define RtlUInt32ToUInt16  RtlUIntToUShort

//
// UINT32 -> WORD conversion
//
#define RtlUInt32ToWord    RtlUIntToUShort

//
// UINT32 -> INT conversion
//
#define RtlUInt32ToInt RtlUIntToInt

//
// UINT32 -> INT_PTR conversion
//
#define RtlUInt32ToIntPtr  RtlUIntToIntPtr

//
// UINT32 -> INT32 conversion
//
#define RtlUInt32ToInt32   RtlUIntToInt

//
// UINT32 -> LONG conversion
//
#define RtlUInt32ToLong    RtlUIntToLong

//
// UINT32 -> LONG_PTR conversion
//
#define RtlUInt32ToLongPtr RtlUIntToLongPtr

//
// UINT32 -> ptrdiff_t conversion
//
#define RtlUInt32ToPtrdiffT    RtlUIntToPtrdiffT

//
// UINT32 -> SSIZE_T conversion
//
#define RtlUInt32ToSSIZET  RtlUIntToSSIZET

//
// UINT_PTR -> INT8 conversion
//
__inline
NTSTATUS
RtlUIntPtrToInt8(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if (uOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT_PTR -> UCHAR conversion
//
__inline
NTSTATUS
RtlUIntPtrToUChar(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) UCHAR* pch)
{
    NTSTATUS status;

    if (uOperand <= 255)
    {
        *pch = (UCHAR)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// UINT_PTR -> CHAR conversion
//
__forceinline
NTSTATUS
RtlUIntPtrToChar(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlUIntPtrToUChar(uOperand, (UCHAR*)pch);
#else
    return RtlUIntPtrToInt8(uOperand, (INT8*)pch);
#endif
}

//
// UINT_PTR -> UINT8 conversion
//
__inline
NTSTATUS
RtlUIntPtrToUInt8(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) UINT8* pu8Result)
{
    NTSTATUS status;
    
    if (uOperand <= UINT8_MAX)
    {
        *pu8Result = (UINT8)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT_PTR -> BYTE conversion
//
#define RtlUIntPtrToByte   RtlUIntPtrToUInt8

//
// UINT_PTR -> SHORT conversion
//
__inline
NTSTATUS
RtlUIntPtrToShort(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) SHORT* psResult)
{
    NTSTATUS status;

    if (uOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status; 
}

//
// UINT_PTR -> INT16 conversion
//
__inline
NTSTATUS
RtlUIntPtrToInt16(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) INT16* pi16Result)
{
    NTSTATUS status;
    
    if (uOperand <= INT16_MAX)
    {
        *pi16Result = (INT16)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi16Result = INT16_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT_PTR -> USHORT conversion
//
__inline
NTSTATUS
RtlUIntPtrToUShort(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) USHORT* pusResult)
{
    NTSTATUS status;

    if (uOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// UINT_PTR -> UINT16 conversion
//
__inline
NTSTATUS
RtlUIntPtrToUInt16(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) UINT16* pu16Result)
{
    NTSTATUS status;
    
    if (uOperand <= UINT16_MAX)
    {
        *pu16Result = (UINT16)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pu16Result = UINT16_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT_PTR -> WORD conversion
//
#define RtlUIntPtrToWord   RtlUIntPtrToUShort

//
// UINT_PTR -> INT conversion
//
__inline
NTSTATUS
RtlUIntPtrToInt(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) INT* piResult)
{
    NTSTATUS status;

    if (uOperand <= INT_MAX)
    {
        *piResult = (INT)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *piResult = INT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// UINT_PTR -> INT32 conversion
//
#define RtlUIntPtrToInt32  RtlUIntPtrToInt

//
// UINT_PTR -> INT_PTR conversion
//
__inline
NTSTATUS
RtlUIntPtrToIntPtr(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) INT_PTR* piResult)
{
    NTSTATUS status;

    if (uOperand <= INT_PTR_MAX)
    {
        *piResult = (INT_PTR)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *piResult = INT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// UINT_PTR -> UINT conversion
//
#ifdef _WIN64
#define RtlUIntPtrToUInt   RtlULongLongToUInt
#else
__inline
NTSTATUS
RtlUIntPtrToUInt(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) UINT* puResult)
{
    *puResult = (UINT)uOperand;
    return STATUS_SUCCESS;
}
#endif

//
// UINT_PTR -> UINT32 conversion
//
#define RtlUIntPtrToUInt32 RtlUIntPtrToUInt

//
// UINT_PTR -> LONG conversion
//
__inline
NTSTATUS
RtlUIntPtrToLong(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) LONG* plResult)
{
    NTSTATUS status;

    if (uOperand <= LONG_MAX)
    {
        *plResult = (LONG)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT_PTR -> LONG_PTR conversion
//
__inline
NTSTATUS
RtlUIntPtrToLongPtr(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) LONG_PTR* plResult)
{
    NTSTATUS status;

    if (uOperand <= LONG_PTR_MAX)
    {
        *plResult = (LONG_PTR)uOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT_PTR -> ULONG conversion
//
#ifdef _WIN64
#define RtlUIntPtrToULong  RtlULongLongToULong
#else
__inline
NTSTATUS
RtlUIntPtrToULong(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) ULONG* pulResult)
{
    *pulResult = (ULONG)uOperand;
    return STATUS_SUCCESS;
}
#endif

//
// UINT_PTR -> DWORD conversion
//
#define RtlUIntPtrToDWord  RtlUIntPtrToULong

//
// UINT_PTR -> LONGLONG conversion
//
#ifdef _WIN64
#define RtlUIntPtrToLongLong   RtlULongLongToLongLong
#else
__inline
NTSTATUS
RtlUIntPtrToLongLong(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) LONGLONG* pllResult)
{
    *pllResult = (LONGLONG)uOperand;
    return STATUS_SUCCESS;
}
#endif

//
// UINT_PTR -> LONG64 conversion
//
#define RtlUIntPtrToLong64 RtlUIntPtrToLongLong

//
// UINT_PTR -> RtlINT64 conversion
//
#define RtlUIntPtrToInt64  RtlUIntPtrToLongLong

//
// UINT_PTR -> ptrdiff_t conversion
//
#define RtlUIntPtrToPtrdiffT   RtlUIntPtrToIntPtr

//
// UINT_PTR -> SSIZE_T conversion
//
#define RtlUIntPtrToSSIZET RtlUIntPtrToLongPtr

//
// LONG -> INT8 conversion
//
__inline
NTSTATUS
RtlLongToInt8(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if ((lOperand >= INT8_MIN) && (lOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG -> UCHAR conversion
//
__inline
NTSTATUS
RtlLongToUChar(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) UCHAR* pch)
{
    NTSTATUS status;

    if ((lOperand >= 0) && (lOperand <= 255))
    {
        *pch = (UCHAR)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// LONG -> CHAR conversion
//
__forceinline
NTSTATUS
RtlLongToChar(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlLongToUChar(lOperand, (UCHAR*)pch);
#else
    return RtlLongToInt8(lOperand, (INT8*)pch);
#endif
}

//
// LONG -> UINT8 conversion
//
__inline
NTSTATUS
RtlLongToUInt8(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) UINT8* pui8Result)
{
    NTSTATUS status;
    
    if ((lOperand >= 0) && (lOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG -> BYTE conversion
//
#define RtlLongToByte  RtlLongToUInt8

//
// LONG -> SHORT conversion
//
__inline
NTSTATUS
RtlLongToShort(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) SHORT* psResult)
{
    NTSTATUS status;
     
    if ((lOperand >= SHORT_MIN) && (lOperand <= SHORT_MAX))
    {
       *psResult = (SHORT)lOperand;
       status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
     
    return status;
}

//
// LONG -> INT16 conversion
//
#define RtlLongToInt16 RtlLongToShort

//
// LONG -> USHORT conversion
//
__inline
NTSTATUS
RtlLongToUShort(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) USHORT* pusResult)
{
    NTSTATUS status;
    
    if ((lOperand >= 0) && (lOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG -> UINT16 conversion
//
#define RtlLongToUInt16    RtlLongToUShort

//   
// LONG -> WORD conversion
//
#define RtlLongToWord  RtlLongToUShort

//
// LONG -> INT conversion
//
__inline
NTSTATUS
RtlLongToInt(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) INT* piResult)
{
    C_ASSERT(sizeof(INT) == sizeof(LONG));
    *piResult = (INT)lOperand;
    return STATUS_SUCCESS;
}

//
// LONG -> INT32 conversion
//
#define RtlLongToInt32 RtlLongToInt

//
// LONG -> INT_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlLongToIntPtr(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) INT_PTR* piResult)
{
    *piResult = lOperand;
    return STATUS_SUCCESS;
}
#else
#define RtlLongToIntPtr    RtlLongToInt
#endif

//
// LONG -> UINT conversion
//
__inline
NTSTATUS
RtlLongToUInt(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) UINT* puResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG -> UINT32 conversion
//
#define RtlLongToUInt32    RtlLongToUInt

//
// LONG -> UINT_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlLongToUIntPtr(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) UINT_PTR* puResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT_PTR)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#else
#define RtlLongToUIntPtr   RtlLongToUInt
#endif

//
// LONG -> ULONG conversion
//
__inline
NTSTATUS
RtlLongToULong(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) ULONG* pulResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG -> ULONG_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlLongToULongPtr(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) ULONG_PTR* pulResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG_PTR)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#else
#define RtlLongToULongPtr  RtlLongToULong
#endif

//
// LONG -> DWORD conversion
//
#define RtlLongToDWord RtlLongToULong

//
// LONG -> DWORD_PTR conversion
//
#define RtlLongToDWordPtr  RtlLongToULongPtr

//
// LONG -> ULONGLONG conversion
//
__inline
NTSTATUS
RtlLongToULongLong(
    __in LONG lOperand,
    __out __deref_out_range(==,lOperand) ULONGLONG* pullResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *pullResult = (ULONGLONG)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG -> DWORDLONG conversion
//
#define RtlLongToDWordLong RtlLongToULongLong

//
// LONG -> ULONG64 conversion
//
#define RtlLongToULong64   RtlLongToULongLong

//
// LONG -> DWORD64 conversion
//
#define RtlLongToDWord64   RtlLongToULongLong

//
// LONG -> UINT64 conversion
//
#define RtlLongToUInt64    RtlLongToULongLong

//
// LONG -> ptrdiff_t conversion
//
#define RtlLongToPtrdiffT  RtlLongToIntPtr

//
// LONG -> size_t conversion
//
#define RtlLongToSizeT RtlLongToUIntPtr

//
// LONG -> SIZE_T conversion
//
#define RtlLongToSIZET RtlLongToULongPtr

//
// LONG_PTR -> INT8 conversion
//
__inline
NTSTATUS
RtlLongPtrToInt8(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if ((lOperand >= INT8_MIN) && (lOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG_PTR -> UCHAR conversion
//
__inline
NTSTATUS
RtlLongPtrToUChar(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) UCHAR* pch)
{
    NTSTATUS status;
    
    if ((lOperand >= 0) && (lOperand <= 255))
    {
        *pch = (UCHAR)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG_PTR -> CHAR conversion
//
__forceinline
NTSTATUS
RtlLongPtrToChar(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlLongPtrToUChar(lOperand, (UCHAR*)pch);
#else
    return RtlLongPtrToInt8(lOperand, (INT8*)pch);
#endif
}

//
// LONG_PTR -> UINT8 conversion
//
__inline
NTSTATUS
RtlLongPtrToUInt8(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) UINT8* pui8Result)
{
    NTSTATUS status;
    
    if ((lOperand >= 0) && (lOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG_PTR -> BYTE conversion
//
#define RtlLongPtrToByte   RtlLongPtrToUInt8

//
// LONG_PTR -> SHORT conversion
//
__inline
NTSTATUS
RtlLongPtrToShort(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) SHORT* psResult)
{
    NTSTATUS status;
    
    if ((lOperand >= SHORT_MIN) && (lOperand <= SHORT_MAX))
    {
        *psResult = (SHORT)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}    

//
// LONG_PTR -> INT16 conversion
//
#define RtlLongPtrToInt16  RtlLongPtrToShort

//
// LONG_PTR -> USHORT conversion
//
__inline
NTSTATUS
RtlLongPtrToUShort(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) USHORT* pusResult)
{
    NTSTATUS status;
    
    if ((lOperand >= 0) && (lOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG_PTR -> UINT16 conversion
//
#define RtlLongPtrToUInt16 RtlLongPtrToUShort

//
// LONG_PTR -> WORD conversion
//
#define RtlLongPtrToWord   RtlLongPtrToUShort

//
// LONG_PTR -> INT conversion
//
#ifdef _WIN64
#define RtlLongPtrToInt    RtlLongLongToInt
#else
__inline
NTSTATUS
RtlLongPtrToInt(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) INT* piResult)
{
    C_ASSERT(sizeof(INT) == sizeof(LONG_PTR));
    *piResult = (INT)lOperand;
    return STATUS_SUCCESS;
}   
#endif

//
// LONG_PTR -> INT32 conversion
//
#define RtlLongPtrToInt32  RtlLongPtrToInt

//
// LONG_PTR -> INT_PTR conversion
//
__inline
NTSTATUS
RtlLongPtrToIntPtr(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) INT_PTR* piResult)
{
    C_ASSERT(sizeof(LONG_PTR) == sizeof(INT_PTR));
    *piResult = (INT_PTR)lOperand;
    return STATUS_SUCCESS;
}

//
// LONG_PTR -> UINT conversion
//
#ifdef _WIN64
#define RtlLongPtrToUInt   RtlLongLongToUInt
#else
__inline
NTSTATUS
RtlLongPtrToUInt(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) UINT* puResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif

//
// LONG_PTR -> UINT32 conversion
//
#define RtlLongPtrToUInt32 RtlLongPtrToUInt

//
// LONG_PTR -> UINT_PTR conversion
//
__inline
NTSTATUS
RtlLongPtrToUIntPtr(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) UINT_PTR* puResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT_PTR)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG_PTR -> LONG conversion
//
#ifdef _WIN64
#define RtlLongPtrToLong   RtlLongLongToLong
#else
__inline
NTSTATUS
RtlLongPtrToLong(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) LONG* plResult)
{
    *plResult = (LONG)lOperand;
    return STATUS_SUCCESS;
}
#endif

//    
// LONG_PTR -> ULONG conversion
//
#ifdef _WIN64
#define RtlLongPtrToULong  RtlLongLongToULong
#else
__inline
NTSTATUS
RtlLongPtrToULong(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) ULONG* pulResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif

//
// LONG_PTR -> ULONG_PTR conversion
//
__inline
NTSTATUS
RtlLongPtrToULongPtr(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) ULONG_PTR* pulResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG_PTR)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG_PTR -> DWORD conversion
//
#define RtlLongPtrToDWord  RtlLongPtrToULong

//
// LONG_PTR -> DWORD_PTR conversion
//
#define RtlLongPtrToDWordPtr   RtlLongPtrToULongPtr 

//
// LONG_PTR -> ULONGLONG conversion
//
__inline
NTSTATUS
RtlLongPtrToULongLong(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==,lOperand) ULONGLONG* pullResult)
{
    NTSTATUS status;
    
    if (lOperand >= 0)
    {
        *pullResult = (ULONGLONG)lOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONG_PTR -> DWORDLONG conversion
//
#define RtlLongPtrToDWordLong  RtlLongPtrToULongLong

//
// LONG_PTR -> ULONG64 conversion
//
#define RtlLongPtrToULong64    RtlLongPtrToULongLong

//
// LONG_PTR -> DWORD64 conversion
//
#define RtlLongPtrToDWord64    RtlLongPtrToULongLong

//
// LONG_PTR -> UINT64 conversion
//
#define RtlLongPtrToUInt64 RtlLongPtrToULongLong

//
// LONG_PTR -> size_t conversion
//
#define RtlLongPtrToSizeT  RtlLongPtrToUIntPtr

//
// LONG_PTR -> SIZE_T conversion
//
#define RtlLongPtrToSIZET  RtlLongPtrToULongPtr

//
// ULONG -> INT8 conversion
//
__inline
NTSTATUS
RtlULongToInt8(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if (ulOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG -> UCHAR conversion
//
__inline
NTSTATUS
RtlULongToUChar(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) UCHAR* pch)
{
    NTSTATUS status;

    if (ulOperand <= 255)
    {
        *pch = (UCHAR)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// ULONG -> CHAR conversion
//
__forceinline
NTSTATUS
RtlULongToChar(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlULongToUChar(ulOperand, (UCHAR*)pch);
#else
    return RtlULongToInt8(ulOperand, (INT8*)pch);
#endif
}

//
// ULONG -> UINT8 conversion
//
__inline
NTSTATUS
RtlULongToUInt8(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) UINT8* pui8Result)
{
    NTSTATUS status;
    
    if (ulOperand <= UINT8_MAX)
    {
        *pui8Result = (UINT8)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}    

//
// ULONG -> BYTE conversion
//
#define RtlULongToByte RtlULongToUInt8

//
// ULONG -> SHORT conversion
//
__inline
NTSTATUS
RtlULongToShort(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) SHORT* psResult)
{
    NTSTATUS status;

    if (ulOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// ULONG -> INT16 conversion
//
#define RtlULongToInt16    RtlULongToShort

//
// ULONG -> USHORT conversion
//
__inline
NTSTATUS
RtlULongToUShort(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) USHORT* pusResult)
{
    NTSTATUS status;

    if (ulOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// ULONG -> UINT16 conversion
//
#define RtlULongToUInt16   RtlULongToUShort

//
// ULONG -> WORD conversion
//
#define RtlULongToWord RtlULongToUShort

//
// ULONG -> INT conversion
//
__inline
NTSTATUS
RtlULongToInt(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) INT* piResult)
{
    NTSTATUS status;
    
    if (ulOperand <= INT_MAX)
    {
        *piResult = (INT)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *piResult = INT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG -> INT32 conversion
//
#define RtlULongToInt32    RtlULongToInt

//
// ULONG -> INT_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlULongToIntPtr(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) INT_PTR* piResult)
{
    *piResult = (INT_PTR)ulOperand;
    return STATUS_SUCCESS;
}
#else
#define RtlULongToIntPtr   RtlULongToInt
#endif

//
// ULONG -> UINT conversion
//
__inline
NTSTATUS
RtlULongToUInt(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) UINT* puResult)
{
    C_ASSERT(sizeof(ULONG) == sizeof(UINT));
    *puResult = (UINT)ulOperand;    
    return STATUS_SUCCESS;
}

//
// ULONG -> UINT32 conversion
//
#define RtlULongToUInt32   RtlULongToUInt

//
// ULONG -> UINT_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlULongToUIntPtr(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) UINT_PTR* puiResult)
{
    C_ASSERT(sizeof(UINT_PTR) > sizeof(ULONG));
    *puiResult = (UINT_PTR)ulOperand;
    return STATUS_SUCCESS;
}
#else
#define RtlULongToUIntPtr  RtlULongToUInt
#endif

//
// ULONG -> LONG conversion
//
__inline
NTSTATUS
RtlULongToLong(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) LONG* plResult)
{
    NTSTATUS status;
    
    if (ulOperand <= LONG_MAX)
    {
        *plResult = (LONG)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG -> LONG_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlULongToLongPtr(
    __in ULONG ulOperand,
    __out __deref_out_range(==,ulOperand) LONG_PTR* plResult)
{
    C_ASSERT(sizeof(LONG_PTR) > sizeof(ULONG));
    *plResult = (LONG_PTR)ulOperand;
    return STATUS_SUCCESS;
}
#else
#define RtlULongToLongPtr  RtlULongToLong
#endif

//
// ULONG -> ptrdiff_t conversion
//
#define RtlULongToPtrdiffT RtlULongToIntPtr

//
// ULONG -> SSIZE_T conversion
//
#define RtlULongToSSIZET   RtlULongToLongPtr

//
// ULONG_PTR -> INT8 conversion
//
__inline
NTSTATUS
RtlULongPtrToInt8(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if (ulOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG_PTR -> UCHAR conversion
//
__inline
NTSTATUS
RtlULongPtrToUChar(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) UCHAR* pch)
{
    NTSTATUS status;

    if (ulOperand <= 255)
    {
        *pch = (UCHAR)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// ULONG_PTR -> CHAR conversion
//
__forceinline
NTSTATUS
RtlULongPtrToChar(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlULongPtrToUChar(ulOperand, (UCHAR*)pch);
#else
    return RtlULongPtrToInt8(ulOperand, (INT8*)pch);
#endif
}

//
// ULONG_PTR -> UINT8 conversion
//
__inline
NTSTATUS
RtlULongPtrToUInt8(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) UINT8* pui8Result)
{
    NTSTATUS status;
    
    if (ulOperand <= UINT8_MAX)
    {
        *pui8Result = (UINT8)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//    
// ULONG_PTR -> BYTE conversion
//
#define RtlULongPtrToByte  RtlULongPtrToUInt8

//
// ULONG_PTR -> SHORT conversion
//
__inline
NTSTATUS
RtlULongPtrToShort(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) SHORT* psResult)
{
    NTSTATUS status;

    if (ulOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status; 
}

//
// ULONG_PTR -> INT16 conversion
//
#define RtlULongPtrToInt16 RtlULongPtrToShort

//
// ULONG_PTR -> USHORT conversion
//
__inline
NTSTATUS
RtlULongPtrToUShort(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) USHORT* pusResult)
{
    NTSTATUS status;

    if (ulOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// ULONG_PTR -> UINT16 conversion
//
#define RtlULongPtrToUInt16    RtlULongPtrToUShort

//
// ULONG_PTR -> WORD conversion
//
#define RtlULongPtrToWord  RtlULongPtrToUShort

//
// ULONG_PTR -> INT conversion
//
__inline
NTSTATUS
RtlULongPtrToInt(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) INT* piResult)
{
    NTSTATUS status;
    
    if (ulOperand <= INT_MAX)
    {
        *piResult = (INT)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *piResult = INT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG_PTR -> INT32 conversion
//
#define RtlULongPtrToInt32 RtlULongPtrToInt

//
// ULONG_PTR -> INT_PTR conversion
//
__inline
NTSTATUS
RtlULongPtrToIntPtr(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) INT_PTR* piResult)
{
    NTSTATUS status;
    
    if (ulOperand <= INT_PTR_MAX)
    {
        *piResult = (INT_PTR)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *piResult = INT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG_PTR -> UINT conversion
//
#ifdef _WIN64
#define RtlULongPtrToUInt  RtlULongLongToUInt
#else
__inline
NTSTATUS
RtlULongPtrToUInt(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) UINT* puResult)
{
    C_ASSERT(sizeof(ULONG_PTR) == sizeof(UINT));
    *puResult = (UINT)ulOperand;    
    return STATUS_SUCCESS;
}
#endif

//
// ULONG_PTR -> UINT32 conversion
//
#define RtlULongPtrToUInt32    RtlULongPtrToUInt

//
// ULONG_PTR -> UINT_PTR conversion
//
__inline
NTSTATUS
RtlULongPtrToUIntPtr(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) UINT_PTR* puResult)
{
    *puResult = (UINT_PTR)ulOperand;
    return STATUS_SUCCESS;
}

//
// ULONG_PTR -> LONG conversion
//
__inline
NTSTATUS
RtlULongPtrToLong(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) LONG* plResult)
{
    NTSTATUS status;
    
    if (ulOperand <= LONG_MAX)
    {
        *plResult = (LONG)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//        
// ULONG_PTR -> LONG_PTR conversion
//
__inline
NTSTATUS
RtlULongPtrToLongPtr(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) LONG_PTR* plResult)
{
    NTSTATUS status;
    
    if (ulOperand <= LONG_PTR_MAX)
    {
        *plResult = (LONG_PTR)ulOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG_PTR -> ULONG conversion
//
#ifdef _WIN64
#define RtlULongPtrToULong RtlULongLongToULong
#else
__inline
NTSTATUS
RtlULongPtrToULong(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) ULONG* pulResult)
{
    *pulResult = (ULONG)ulOperand;
    return STATUS_SUCCESS;
}
#endif    

//
// ULONG_PTR -> DWORD conversion
//
#define RtlULongPtrToDWord RtlULongPtrToULong

//
// ULONG_PTR -> LONGLONG conversion
//
#ifdef _WIN64
#define RtlULongPtrToLongLong  RtlULongLongToLongLong
#else
__inline
NTSTATUS
RtlULongPtrToLongLong(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==,ulOperand) LONGLONG* pllResult)
{
    *pllResult = (LONGLONG)ulOperand;
    return STATUS_SUCCESS;
}
#endif

//
// ULONG_PTR -> LONG64 conversion
//
#define RtlULongPtrToLong64    RtlULongPtrToLongLong

//
// ULONG_PTR -> RtlINT64
//
#define RtlULongPtrToInt64 RtlULongPtrToLongLong

//
// ULONG_PTR -> ptrdiff_t conversion
//
#define RtlULongPtrToPtrdiffT  RtlULongPtrToIntPtr

//
// ULONG_PTR -> SSIZE_T conversion
//
#define RtlULongPtrToSSIZET    RtlULongPtrToLongPtr

//
// DWORD -> INT8 conversion
//
#define RtlDWordToInt8 RtlULongToInt8

//
// DWORD -> CHAR conversion
//
#define RtlDWordToChar RtlULongToChar

//
// DWORD -> UCHAR conversion
//
#define RtlDWordToUChar    RtlULongToUChar

//
// DWORD -> UINT8 conversion
//
#define RtlDWordToUInt8    RtlULongToUInt8

//
// DWORD -> BYTE conversion
//
#define RtlDWordToByte RtlULongToUInt8

//
// DWORD -> SHORT conversion
//
#define RtlDWordToShort    RtlULongToShort

//
// DWORD -> INT16 conversion
//
#define RtlDWordToInt16    RtlULongToShort

//
// DWORD -> USHORT conversion
//
#define RtlDWordToUShort   RtlULongToUShort

//
// DWORD -> UINT16 conversion
//
#define RtlDWordToUInt16   RtlULongToUShort

//
// DWORD -> WORD conversion
//
#define RtlDWordToWord RtlULongToUShort

//
// DWORD -> INT conversion
//
#define RtlDWordToInt  RtlULongToInt

//
// DWORD -> INT32 conversion
//
#define RtlDWordToInt32    RtlULongToInt

//
// DWORD -> INT_PTR conversion
//
#define RtlDWordToIntPtr   RtlULongToIntPtr

//
// DWORD -> UINT conversion
//
#define RtlDWordToUInt RtlULongToUInt

//
// DWORD -> UINT32 conversion
//
#define RtlDWordToUInt32   RtlULongToUInt

//
// DWORD -> UINT_PTR conversion
//
#define RtlDWordToUIntPtr  RtlULongToUIntPtr

//
// DWORD -> LONG conversion
//
#define RtlDWordToLong RtlULongToLong

//
// DWORD -> LONG_PTR conversion
//
#define RtlDWordToLongPtr  RtlULongToLongPtr

//
// DWORD -> ptrdiff_t conversion
//
#define RtlDWordToPtrdiffT RtlULongToIntPtr

//
// DWORD -> SSIZE_T conversion
//
#define RtlDWordToSSIZET   RtlULongToLongPtr

//
// DWORD_PTR -> INT8 conversion
//
#define RtlDWordPtrToInt8  RtlULongPtrToInt8

//
// DWORD_PTR -> UCHAR conversion
//
#define RtlDWordPtrToUChar RtlULongPtrToUChar

//
// DWORD_PTR -> CHAR conversion
//
#define RtlDWordPtrToChar  RtlULongPtrToChar

//
// DWORD_PTR -> UINT8 conversion
//
#define RtlDWordPtrToUInt8 RtlULongPtrToUInt8

//
// DWORD_PTR -> BYTE conversion
//
#define RtlDWordPtrToByte  RtlULongPtrToUInt8

//
// DWORD_PTR -> SHORT conversion
//
#define RtlDWordPtrToShort RtlULongPtrToShort

//
// DWORD_PTR -> INT16 conversion
//
#define RtlDWordPtrToInt16 RtlULongPtrToShort

//
// DWORD_PTR -> USHORT conversion
//
#define RtlDWordPtrToUShort    RtlULongPtrToUShort

//
// DWORD_PTR -> UINT16 conversion
//
#define RtlDWordPtrToUInt16    RtlULongPtrToUShort

//
// DWORD_PTR -> WORD conversion
//
#define RtlDWordPtrToWord  RtlULongPtrToUShort

//
// DWORD_PTR -> INT conversion
//
#define RtlDWordPtrToInt   RtlULongPtrToInt

//
// DWORD_PTR -> INT32 conversion
//
#define RtlDWordPtrToInt32 RtlULongPtrToInt

//
// DWORD_PTR -> INT_PTR conversion
//
#define RtlDWordPtrToIntPtr    RtlULongPtrToIntPtr

//
// DWORD_PTR -> UINT conversion
//
#define RtlDWordPtrToUInt  RtlULongPtrToUInt

//
// DWORD_PTR -> UINT32 conversion
//
#define RtlDWordPtrToUInt32    RtlULongPtrToUInt

//
// DWODR_PTR -> UINT_PTR conversion
//
#define RtlDWordPtrToUIntPtr   RtlULongPtrToUIntPtr

//
// DWORD_PTR -> LONG conversion
//
#define RtlDWordPtrToLong  RtlULongPtrToLong

//
// DWORD_PTR -> LONG_PTR conversion
//
#define RtlDWordPtrToLongPtr   RtlULongPtrToLongPtr

//
// DWORD_PTR -> ULONG conversion
//
#define RtlDWordPtrToULong RtlULongPtrToULong

//
// DWORD_PTR -> DWORD conversion
//
#define RtlDWordPtrToDWord RtlULongPtrToULong

//
// DWORD_PTR -> LONGLONG conversion
//
#define RtlDWordPtrToLongLong  RtlULongPtrToLongLong

//
// DWORD_PTR -> LONG64 conversion
//
#define RtlDWordPtrToLong64    RtlULongPtrToLongLong

//
// DWORD_PTR -> RtlINT64 conversion
//
#define RtlDWordPtrToInt64 RtlULongPtrToLongLong

//
// DWORD_PTR -> ptrdiff_t conversion
//
#define RtlDWordPtrToPtrdiffT  RtlULongPtrToIntPtr

//
// DWORD_PTR -> SSIZE_T conversion
//
#define RtlDWordPtrToSSIZET    RtlULongPtrToLongPtr

//
// LONGLONG -> INT8 conversion
//
__inline
NTSTATUS
RtlLongLongToInt8(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if ((llOperand >= INT8_MIN) && (llOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

    return status;
}

//
// LONGLONG -> UCHAR conversion
//
__inline
NTSTATUS
RtlLongLongToUChar(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) UCHAR* pch)
{
    NTSTATUS status;

    if ((llOperand >= 0) && (llOperand <= 255))
    {
        *pch = (UCHAR)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONGLONG -> CHAR conversion
//
__forceinline
NTSTATUS
RtlLongLongToChar(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlLongLongToUChar(llOperand, (UCHAR*)pch);
#else
    return RtlLongLongToInt8(llOperand, (INT8*)pch);
#endif
}

//
// LONGLONG -> UINT8 conversion
//
__inline
NTSTATUS
RtlLongLongToUInt8(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) UINT8* pu8Result)
{
    NTSTATUS status;
    
    if ((llOperand >= 0) && (llOperand <= UINT8_MAX))
    {
        *pu8Result = (UINT8)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONGLONG -> BYTE conversion
//
#define RtlLongLongToByte  RtlLongLongToUInt8

//
// LONGLONG -> SHORT conversion
//
__inline
NTSTATUS
RtlLongLongToShort(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) SHORT* psResult)
{
    NTSTATUS status;
    
    if ((llOperand >= SHORT_MIN) && (llOperand <= SHORT_MAX))
    {
        *psResult = (SHORT)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONGLONG -> INT16 conversion
//
#define RtlLongLongToInt16 RtlLongLongToShort

//
// LONGLONG -> USHORT conversion
//
__inline
NTSTATUS
RtlLongLongToUShort(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) USHORT* pusResult)
{
    NTSTATUS status;
    
    if ((llOperand >= 0) && (llOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONGLONG -> UINT16 conversion
//
#define RtlLongLongToUInt16    RtlLongLongToUShort

//
// LONGLONG -> WORD conversion
//
#define RtlLongLongToWord  RtlLongLongToUShort

//
// LONGLONG -> INT conversion
//
__inline
NTSTATUS
RtlLongLongToInt(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) INT* piResult)
{
    NTSTATUS status;
    
    if ((llOperand >= INT_MIN) && (llOperand <= INT_MAX))
    {
        *piResult = (INT)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *piResult = INT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// LONGLONG -> INT32 conversion
//
#define RtlLongLongToInt32 RtlLongLongToInt

//
// LONGLONG -> INT_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlLongLongToIntPtr(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) INT_PTR* piResult)
{
    *piResult = llOperand;
    return STATUS_SUCCESS;
}
#else
#define RtlLongLongToIntPtr   RtlLongLongToInt
#endif

//
// LONGLONG -> UINT conversion
//
__inline
NTSTATUS
RtlLongLongToUInt(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) UINT* puResult)
{
    NTSTATUS status;
    
    if ((llOperand >= 0) && (llOperand <= UINT_MAX))
    {
        *puResult = (UINT)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;    
}

//
// LONGLONG -> UINT32 conversion
//
#define RtlLongLongToUInt32    RtlLongLongToUInt

//
// LONGLONG -> UINT_PTR conversion
//
#ifdef _WIN64
#define RtlLongLongToUIntPtr  RtlLongLongToULongLong
#else
#define RtlLongLongToUIntPtr  RtlLongLongToUInt
#endif

//
// LONGLONG -> LONG conversion
//
__inline
NTSTATUS
RtlLongLongToLong(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) LONG* plResult)
{
    NTSTATUS status;
    
    if ((llOperand >= LONG_MIN) && (llOperand <= LONG_MAX))
    {
        *plResult = (LONG)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;    
}

//
// LONGLONG -> LONG_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlLongLongToLongPtr(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) LONG_PTR* plResult)
{
    *plResult = (LONG_PTR)llOperand;
    return STATUS_SUCCESS;
}    
#else
#define RtlLongLongToLongPtr  RtlLongLongToLong
#endif

//
// LONGLONG -> ULONG conversion
//
__inline
NTSTATUS
RtlLongLongToULong(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) ULONG* pulResult)
{
    NTSTATUS status;
    
    if ((llOperand >= 0) && (llOperand <= ULONG_MAX))
    {
        *pulResult = (ULONG)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;    
}

//
// LONGLONG -> ULONG_PTR conversion
//
#ifdef _WIN64
#define RtlLongLongToULongPtr RtlLongLongToULongLong
#else
#define RtlLongLongToULongPtr RtlLongLongToULong
#endif

//
// LONGLONG -> DWORD conversion
//
#define RtlLongLongToDWord    RtlLongLongToULong

//
// LONGLONG -> DWORD_PTR conversion
//
#define RtlLongLongToDWordPtr RtlLongLongToULongPtr

//
// LONGLONG -> ULONGLONG conversion
//
__inline
NTSTATUS
RtlLongLongToULongLong(
    __in LONGLONG llOperand,
    __out __deref_out_range(==,llOperand) ULONGLONG* pullResult)
{
    NTSTATUS status;
    
    if (llOperand >= 0)
    {
        *pullResult = (ULONGLONG)llOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status; 
}

//
// LONGLONG -> DWORDLONG conversion
//
#define RtlLongLongToDWordLong RtlLongLongToULongLong

//
// LONGLONG -> ULONG64 conversion
//
#define RtlLongLongToULong64   RtlLongLongToULongLong

//
// LONGLONG -> DWORD64 conversion
//
#define RtlLongLongToDWord64   RtlLongLongToULongLong

//
// LONGLONG -> UINT64 conversion
//
#define RtlLongLongToUInt64    RtlLongLongToULongLong

//
// LONGLONG -> ptrdiff_t conversion
//
#define RtlLongLongToPtrdiffT RtlLongLongToIntPtr

//
// LONGLONG -> size_t conversion
//
#define RtlLongLongToSizeT    RtlLongLongToUIntPtr

//
// LONGLONG -> SSIZE_T conversion
//
#define RtlLongLongToSSIZET   RtlLongLongToLongPtr

//
// LONGLONG -> SIZE_T conversion
//
#define RtlLongLongToSIZET    RtlLongLongToULongPtr

//
// LONG64 -> CHAR conversion
//
#define RtlLong64ToChar    RtlLongLongToChar

//
// LONG64 -> INT8 conversion
//
#define RtlLong64ToInt8    RtlLongLongToInt8

//
// LONG64 -> UCHAR conversion
//
#define RtlLong64ToUChar   RtlLongLongToUChar

//
// LONG64 -> UINT8 conversion
//
#define RtlLong64ToUInt8   RtlLongLongToUInt8

//
// LONG64 -> BYTE conversion
//
#define RtlLong64ToByte    RtlLongLongToUInt8

//
// LONG64 -> SHORT conversion
//
#define RtlLong64ToShort   RtlLongLongToShort

//
// LONG64 -> INT16 conversion
//
#define RtlLong64ToInt16   RtlLongLongToShort

//
// LONG64 -> USHORT conversion
//
#define RtlLong64ToUShort  RtlLongLongToUShort

//
// LONG64 -> UINT16 conversion
//
#define RtlLong64ToUInt16  RtlLongLongToUShort

//
// LONG64 -> WORD conversion
//
#define RtlLong64ToWord    RtlLongLongToUShort

//
// LONG64 -> INT conversion
//
#define RtlLong64ToInt RtlLongLongToInt

//
// LONG64 -> INT32 conversion
//
#define RtlLong64ToInt32   RtlLongLongToInt

//
// LONG64 -> INT_PTR conversion
//
#define RtlLong64ToIntPtr  RtlLongLongToIntPtr

//
// LONG64 -> UINT conversion
//
#define RtlLong64ToUInt    RtlLongLongToUInt

//
// LONG64 -> UINT32 conversion
//
#define RtlLong64ToUInt32  RtlLongLongToUInt

//
// LONG64 -> UINT_PTR conversion
//
#define RtlLong64ToUIntPtr RtlLongLongToUIntPtr

//
// LONG64 -> LONG conversion
//
#define RtlLong64ToLong    RtlLongLongToLong

//
// LONG64 -> LONG_PTR conversion
//
#define RtlLong64ToLongPtr RtlLongLongToLongPtr

//
// LONG64 -> ULONG conversion
//
#define RtlLong64ToULong   RtlLongLongToULong

//
// LONG64 -> ULONG_PTR conversion
//
#define RtlLong64ToULongPtr    RtlLongLongToULongPtr

//
// LONG64 -> DWORD conversion
//
#define RtlLong64ToDWord   RtlLongLongToULong

//
// LONG64 -> DWORD_PTR conversion
//
#define RtlLong64ToDWordPtr    RtlLongLongToULongPtr  

//
// LONG64 -> ULONGLONG conversion
//
#define RtlLong64ToULongLong   RtlLongLongToULongLong

//
// LONG64 -> ptrdiff_t conversion
//
#define RtlLong64ToPtrdiffT    RtlLongLongToIntPtr

//
// LONG64 -> size_t conversion
//
#define RtlLong64ToSizeT   RtlLongLongToUIntPtr

//
// LONG64 -> SSIZE_T conversion
//
#define RtlLong64ToSSIZET  RtlLongLongToLongPtr

//
// LONG64 -> SIZE_T conversion
//
#define RtlLong64ToSIZET   RtlLongLongToULongPtr

//
// RtlINT64 -> CHAR conversion
//
#define RtlInt64ToChar RtlLongLongToChar

//
// RtlINT64 -> INT8 conversion
//
#define RtlInt64ToInt8 RtlLongLongToInt8

//
// RtlINT64 -> UCHAR conversion
//
#define RtlInt64ToUChar    RtlLongLongToUChar

//
// RtlINT64 -> UINT8 conversion
//
#define RtlInt64ToUInt8    RtlLongLongToUInt8

//
// RtlINT64 -> BYTE conversion
//
#define RtlInt64ToByte RtlLongLongToUInt8

//
// RtlINT64 -> SHORT conversion
//
#define RtlInt64ToShort    RtlLongLongToShort

//
// RtlINT64 -> INT16 conversion
//
#define RtlInt64ToInt16    RtlLongLongToShort

//
// RtlINT64 -> USHORT conversion
//
#define RtlInt64ToUShort   RtlLongLongToUShort

//
// RtlINT64 -> UINT16 conversion
//
#define RtlInt64ToUInt16   RtlLongLongToUShort

//
// RtlINT64 -> WORD conversion
//
#define RtlInt64ToWord RtlLongLongToUShort

//
// RtlINT64 -> INT conversion
//
#define RtlInt64ToInt  RtlLongLongToInt

//
// RtlINT64 -> INT32 conversion
//
#define RtlInt64ToInt32    RtlLongLongToInt

//
// RtlINT64 -> INT_PTR conversion
//
#define RtlInt64ToIntPtr   RtlLongLongToIntPtr

//
// RtlINT64 -> UINT conversion
//
#define RtlInt64ToUInt RtlLongLongToUInt

//
// RtlINT64 -> UINT32 conversion
//
#define RtlInt64ToUInt32   RtlLongLongToUInt

//
// RtlINT64 -> UINT_PTR conversion
//
#define RtlInt64ToUIntPtr  RtlLongLongToUIntPtr

//
// RtlINT64 -> LONG conversion
//
#define RtlInt64ToLong RtlLongLongToLong

//
// RtlINT64 -> LONG_PTR conversion
//
#define RtlInt64ToLongPtr  RtlLongLongToLongPtr

//
// RtlINT64 -> ULONG conversion
//
#define RtlInt64ToULong    RtlLongLongToULong

//
// RtlINT64 -> ULONG_PTR conversion
//
#define RtlInt64ToULongPtr RtlLongLongToULongPtr

//
// RtlINT64 -> DWORD conversion
//
#define RtlInt64ToDWord    RtlLongLongToULong

//
// RtlINT64 -> DWORD_PTR conversion
//
#define RtlInt64ToDWordPtr RtlLongLongToULongPtr

//
// RtlINT64 -> ULONGLONG conversion
//
#define RtlInt64ToULongLong    RtlLongLongToULongLong

//
// RtlINT64 -> DWORDLONG conversion
//
#define RtlInt64ToDWordLong    RtlLongLongToULongLong

//
// RtlINT64 -> ULONG64 conversion
//
#define RtlInt64ToULong64  RtlLongLongToULongLong

//
// RtlINT64 -> DWORD64 conversion
//
#define RtlInt64ToDWord64  RtlLongLongToULongLong

//
// RtlINT64 -> UINT64 conversion
//
#define RtlInt64ToUInt64   RtlLongLongToULongLong

//
// RtlINT64 -> ptrdiff_t conversion
//
#define RtlInt64ToPtrdiffT RtlLongLongToIntPtr

//
// RtlINT64 -> size_t conversion
//
#define RtlInt64ToSizeT    RtlLongLongToUIntPtr

//
// RtlINT64 -> SSIZE_T conversion
//
#define RtlInt64ToSSIZET   RtlLongLongToLongPtr

//
// RtlINT64 -> SIZE_T conversion
//
#define RtlInt64ToSIZET    RtlLongLongToULongPtr

//
// ULONGLONG -> INT8 conversion
//
__inline
NTSTATUS
RtlULongLongToInt8(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) INT8* pi8Result)
{
    NTSTATUS status;
    
    if (ullOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> UCHAR conversion
//
__inline
NTSTATUS
RtlULongLongToUChar(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) UCHAR* pch)
{
    NTSTATUS status;
    
    if (ullOperand <= 255)
    {
        *pch = (UCHAR)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pch = '\0';
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> CHAR conversion
//
__forceinline
NTSTATUS
RtlULongLongToChar(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return RtlULongLongToUChar(ullOperand, (UCHAR*)pch);
#else
    return RtlULongLongToInt8(ullOperand, (INT8*)pch);
#endif
}

//
// ULONGLONG -> UINT8 conversion
//
__inline
NTSTATUS
RtlULongLongToUInt8(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) UINT8* pu8Result)
{
    NTSTATUS status;
    
    if (ullOperand <= UINT8_MAX)
    {
        *pu8Result = (UINT8)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> BYTE conversion
//
#define RtlULongLongToByte RtlULongLongToUInt8

//
// ULONGLONG -> SHORT conversion
//
__inline
NTSTATUS
RtlULongLongToShort(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) SHORT* psResult)
{
    NTSTATUS status;
    
    if (ullOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *psResult = SHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> INT16 conversion
//
#define RtlULongLongToInt16    RtlULongLongToShort

//
// ULONGLONG -> USHORT conversion
//
__inline
NTSTATUS
RtlULongLongToUShort(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) USHORT* pusResult)
{
    NTSTATUS status;
    
    if (ullOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> UINT16 conversion
//
#define RtlULongLongToUInt16   RtlULongLongToUShort

//
// ULONGLONG -> WORD conversion
//
#define RtlULongLongToWord RtlULongLongToUShort

//
// ULONGLONG -> INT conversion
//
__inline
NTSTATUS
RtlULongLongToInt(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) INT* piResult)
{
    NTSTATUS status;
    
    if (ullOperand <= INT_MAX)
    {
        *piResult = (INT)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *piResult = INT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> INT32 conversion
//
#define RtlULongLongToInt32    RtlULongLongToInt

//
// ULONGLONG -> INT_PTR conversion
//
#ifdef _WIN64
#define RtlULongLongToIntPtr   RtlULongLongToLongLong
#else
#define RtlULongLongToIntPtr   RtlULongLongToInt
#endif

//
// ULONGLONG -> UINT conversion
//
__inline
NTSTATUS
RtlULongLongToUInt(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) UINT* puResult)
{
    NTSTATUS status;
    
    if (ullOperand <= UINT_MAX)
    {
        *puResult = (UINT)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> UINT32 conversion
//
#define RtlULongLongToUInt32   RtlULongLongToUInt

//
// ULONGLONG -> UINT_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlULongLongToUIntPtr(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) UINT_PTR* puResult)
{
    *puResult = ullOperand;
    return STATUS_SUCCESS;
}
#else    
#define RtlULongLongToUIntPtr  RtlULongLongToUInt
#endif

//
// ULONGLONG -> LONG conversion
//
__inline
NTSTATUS
RtlULongLongToLong(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) LONG* plResult)
{
    NTSTATUS status;
    
    if (ullOperand <= LONG_MAX)
    {
        *plResult = (LONG)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> LONG_PTR conversion
//
__inline
NTSTATUS
RtlULongLongToLongPtr(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) LONG_PTR* plResult)
{
    NTSTATUS status;
    
    if (ullOperand <= LONG_PTR_MAX)
    {
        *plResult = (LONG_PTR)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *plResult = LONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> ULONG conversion
//
__inline
NTSTATUS
RtlULongLongToULong(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) ULONG* pulResult)
{
    NTSTATUS status;
    
    if (ullOperand <= ULONG_MAX)
    {
        *pulResult = (ULONG)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> ULONG_PTR conversion
//
#ifdef _WIN64
__inline
NTSTATUS
RtlULongLongToULongPtr(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) ULONG_PTR* pulResult)
{
    *pulResult = ullOperand;
    return STATUS_SUCCESS;
}
#else
#define RtlULongLongToULongPtr RtlULongLongToULong
#endif

//
// ULONGLONG -> DWORD conversion
//
#define RtlULongLongToDWord    RtlULongLongToULong

//
// ULONGLONG -> DWORD_PTR conversion
//
#define RtlULongLongToDWordPtr RtlULongLongToULongPtr

//
// ULONGLONG -> LONGLONG conversion
//
__inline
NTSTATUS
RtlULongLongToLongLong(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==,ullOperand) LONGLONG* pllResult)
{
    NTSTATUS status;
    
    if (ullOperand <= LONGLONG_MAX)
    {
        *pllResult = (LONGLONG)ullOperand;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pllResult = LONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONGLONG -> RtlINT64 conversion
//
#define RtlULongLongToInt64    RtlULongLongToLongLong

//
// ULONGLONG -> LONG64 conversion
//
#define RtlULongLongToLong64   RtlULongLongToLongLong

//
// ULONGLONG -> ptrdiff_t conversion
//
#define RtlULongLongToPtrdiffT RtlULongLongToIntPtr

//
// ULONGLONG -> size_t conversion
//
#define RtlULongLongToSizeT    RtlULongLongToUIntPtr

//
// ULONGLONG -> SSIZE_T conversion
//
#define RtlULongLongToSSIZET   RtlULongLongToLongPtr

//
// ULONGLONG -> SIZE_T conversion
//
#define RtlULongLongToSIZET    RtlULongLongToULongPtr

//
// DWORDLONG -> CHAR conversion
//
#define RtlDWordLongToChar RtlULongLongToChar

//
// DWORDLONG -> INT8 conversion
//
#define RtlDWordLongToInt8 RtlULongLongToInt8

//
// DWORDLONG -> UCHAR conversion
//
#define RtlDWordLongToUChar    RtlULongLongToUChar

//
// DWORDLONG -> UINT8 conversion
//
#define RtlDWordLongToUInt8    RtlULongLongToUInt8

//
// DWORDLONG -> BYTE conversion
//
#define RtlDWordLongToByte RtlULongLongToUInt8

//
// DWORDLONG -> SHORT conversion
//
#define RtlDWordLongToShort    RtlULongLongToShort

//
// DWORDLONG -> INT16 conversion
//
#define RtlDWordLongToInt16    RtlULongLongToShort

//
// DWORDLONG -> USHORT conversion
//
#define RtlDWordLongToUShort   RtlULongLongToUShort

//
// DWORDLONG -> UINT16 conversion
//
#define RtlDWordLongToUInt16   RtlULongLongToUShort

//
// DWORDLONG -> WORD conversion
//
#define RtlDWordLongToWord RtlULongLongToUShort

//
// DWORDLONG -> INT conversion
//
#define RtlDWordLongToInt  RtlULongLongToInt

//
// DWORDLONG -> INT32 conversion
//
#define RtlDWordLongToInt32    RtlULongLongToInt

//
// DWORDLONG -> INT_PTR conversion
//
#define RtlDWordLongToIntPtr   RtlULongLongToIntPtr

//
// DWORDLONG -> UINT conversion
//
#define RtlDWordLongToUInt RtlULongLongToUInt

//
// DWORDLONG -> UINT32 conversion
//
#define RtlDWordLongToUInt32   RtlULongLongToUInt

//
// DWORDLONG -> UINT_PTR conversion
//
#define RtlDWordLongToUIntPtr  RtlULongLongToUIntPtr

//
// DWORDLONG -> LONG conversion
//
#define RtlDWordLongToLong RtlULongLongToLong

//
// DWORDLONG -> LONG_PTR conversion
//
#define RtlDWordLongToLongPtr  RtlULongLongToLongPtr

//
// DWORDLONG -> ULONG conversion
//
#define RtlDWordLongToULong    RtlULongLongToULong

//
// DWORDLONG -> ULONG_PTR conversion
//
#define RtlDWordLongToULongPtr RtlULongLongToULongPtr

//
// DWORDLONG -> DWORD conversion
//
#define RtlDWordLongToDWord    RtlULongLongToULong

//
// DWORDLONG -> DWORD_PTR conversion
//
#define RtlDWordLongToDWordPtr RtlULongLongToULongPtr

//
// DWORDLONG -> LONGLONG conversion
//
#define RtlDWordLongToLongLong RtlULongLongToLongLong

//
// DWORDLONG -> LONG64 conversion
//
#define RtlDWordLongToLong64   RtlULongLongToLongLong

//
// DWORDLONG -> RtlINT64 conversion
//
#define RtlDWordLongToInt64    RtlULongLongToLongLong

//
// DWORDLONG -> ptrdiff_t conversion
//
#define RtlDWordLongToPtrdiffT RtlULongLongToIntPtr

//
// DWORDLONG -> size_t conversion
//
#define RtlDWordLongToSizeT    RtlULongLongToUIntPtr

//
// DWORDLONG -> SSIZE_T conversion
//
#define RtlDWordLongToSSIZET   RtlULongLongToLongPtr

//
// DWORDLONG -> SIZE_T conversion
//
#define RtlDWordLongToSIZET    RtlULongLongToULongPtr

//
// ULONG64 -> CHAR conversion
//
#define RtlULong64ToChar   RtlULongLongToChar

//
// ULONG64 -> INT8 conversion
//
#define RtlULong64ToInt8   RtlULongLongToInt8

//
// ULONG64 -> UCHAR conversion
//
#define RtlULong64ToUChar  RtlULongLongToUChar

//
// ULONG64 -> UINT8 conversion
//
#define RtlULong64ToUInt8  RtlULongLongToUInt8

//
// ULONG64 -> BYTE conversion
//
#define RtlULong64ToByte   RtlULongLongToUInt8

//
// ULONG64 -> SHORT conversion
//
#define RtlULong64ToShort  RtlULongLongToShort

//
// ULONG64 -> INT16 conversion
//
#define RtlULong64ToInt16  RtlULongLongToShort

//
// ULONG64 -> USHORT conversion
//
#define RtlULong64ToUShort RtlULongLongToUShort

//
// ULONG64 -> UINT16 conversion
//
#define RtlULong64ToUInt16 RtlULongLongToUShort

//
// ULONG64 -> WORD conversion
//
#define RtlULong64ToWord   RtlULongLongToUShort

//
// ULONG64 -> INT conversion
//
#define RtlULong64ToInt    RtlULongLongToInt

//
// ULONG64 -> INT32 conversion
//
#define RtlULong64ToInt32  RtlULongLongToInt

//
// ULONG64 -> INT_PTR conversion
//
#define RtlULong64ToIntPtr RtlULongLongToIntPtr

//
// ULONG64 -> UINT conversion
//
#define RtlULong64ToUInt   RtlULongLongToUInt

//
// ULONG64 -> UINT32 conversion
//
#define RtlULong64ToUInt32 RtlULongLongToUInt

//
// ULONG64 -> UINT_PTR conversion
//
#define RtlULong64ToUIntPtr    RtlULongLongToUIntPtr

//
// ULONG64 -> LONG conversion
//
#define RtlULong64ToLong   RtlULongLongToLong

//
// ULONG64 -> LONG_PTR conversion
//
#define RtlULong64ToLongPtr    RtlULongLongToLongPtr

//
// ULONG64 -> ULONG conversion
//
#define RtlULong64ToULong  RtlULongLongToULong

//
// ULONG64 -> ULONG_PTR conversion
//
#define RtlULong64ToULongPtr   RtlULongLongToULongPtr

//
// ULONG64 -> DWORD conversion
//
#define RtlULong64ToDWord  RtlULongLongToULong

//
// ULONG64 -> DWORD_PTR conversion
//
#define RtlULong64ToDWordPtr   RtlULongLongToULongPtr

//
// ULONG64 -> LONGLONG conversion
//
#define RtlULong64ToLongLong   RtlULongLongToLongLong

//
// ULONG64 -> LONG64 conversion
//
#define RtlULong64ToLong64 RtlULongLongToLongLong

//
// ULONG64 -> RtlINT64 conversion
//
#define RtlULong64ToInt64  RtlULongLongToLongLong

//
// ULONG64 -> ptrdiff_t conversion
//
#define RtlULong64ToPtrdiffT   RtlULongLongToIntPtr

//
// ULONG64 -> size_t conversion
//
#define RtlULong64ToSizeT  RtlULongLongToUIntPtr

//
// ULONG64 -> SSIZE_T conversion
//
#define RtlULong64ToSSIZET RtlULongLongToLongPtr

//
// ULONG64 -> SIZE_T conversion
//
#define RtlULong64ToSIZET  RtlULongLongToULongPtr

//
// DWORD64 -> CHAR conversion
//
#define RtlDWord64ToChar   RtlULongLongToChar

//
// DWORD64 -> INT8 conversion
//
#define RtlDWord64ToInt8   RtlULongLongToInt8

//
// DWORD64 -> UCHAR conversion
//
#define RtlDWord64ToUChar  RtlULongLongToUChar

//
// DWORD64 -> UINT8 conversion
//
#define RtlDWord64ToUInt8  RtlULongLongToUInt8

//
// DWORD64 -> BYTE conversion
//
#define RtlDWord64ToByte   RtlULongLongToUInt8

//
// DWORD64 -> SHORT conversion
//
#define RtlDWord64ToShort  RtlULongLongToShort

//
// DWORD64 -> INT16 conversion
//
#define RtlDWord64ToInt16  RtlULongLongToShort

//
// DWORD64 -> USHORT conversion
//
#define RtlDWord64ToUShort RtlULongLongToUShort

//
// DWORD64 -> UINT16 conversion
//
#define RtlDWord64ToUInt16 RtlULongLongToUShort

//
// DWORD64 -> WORD conversion
//
#define RtlDWord64ToWord   RtlULongLongToUShort

//
// DWORD64 -> INT conversion
//
#define RtlDWord64ToInt    RtlULongLongToInt

//
// DWORD64 -> INT32 conversion
//
#define RtlDWord64ToInt32  RtlULongLongToInt

//
// DWORD64 -> INT_PTR conversion
//
#define RtlDWord64ToIntPtr RtlULongLongToIntPtr

//
// DWORD64 -> UINT conversion
//
#define RtlDWord64ToUInt   RtlULongLongToUInt

//
// DWORD64 -> UINT32 conversion
//
#define RtlDWord64ToUInt32 RtlULongLongToUInt

//
// DWORD64 -> UINT_PTR conversion
//
#define RtlDWord64ToUIntPtr    RtlULongLongToUIntPtr

//
// DWORD64 -> LONG conversion
//
#define RtlDWord64ToLong   RtlULongLongToLong

//
// DWORD64 -> LONG_PTR conversion
//
#define RtlDWord64ToLongPtr    RtlULongLongToLongPtr

//
// DWORD64 -> ULONG conversion
//
#define RtlDWord64ToULong  RtlULongLongToULong

//
// DWORD64 -> ULONG_PTR conversion
//
#define RtlDWord64ToULongPtr   RtlULongLongToULongPtr

//
// DWORD64 -> DWORD conversion
//
#define RtlDWord64ToDWord  RtlULongLongToULong

//
// DWORD64 -> DWORD_PTR conversion
//
#define RtlDWord64ToDWordPtr   RtlULongLongToULongPtr

//
// DWORD64 -> LONGLONG conversion
//
#define RtlDWord64ToLongLong   RtlULongLongToLongLong

//
// DWORD64 -> LONG64 conversion
//
#define RtlDWord64ToLong64 RtlULongLongToLongLong

//
// DWORD64 -> RtlINT64 conversion
//
#define RtlDWord64ToInt64  RtlULongLongToLongLong

//
// DWORD64 -> ptrdiff_t conversion
//
#define RtlDWord64ToPtrdiffT   RtlULongLongToIntPtr

//
// DWORD64 -> size_t conversion
//
#define RtlDWord64ToSizeT  RtlULongLongToUIntPtr

//
// DWORD64 -> SSIZE_T conversion
//
#define RtlDWord64ToSSIZET RtlULongLongToLongPtr

//
// DWORD64 -> SIZE_T conversion
//
#define RtlDWord64ToSIZET  RtlULongLongToULongPtr

//
// UINT64 -> CHAR conversion
//
#define RtlUInt64ToChar    RtlULongLongToChar

//
// UINT64 -> INT8 conversion
//
#define RtlUInt64ToInt8    RtlULongLongToInt8

//
// UINT64 -> UCHAR conversion
//
#define RtlUInt64ToUChar   RtlULongLongToUChar

//
// UINT64 -> UINT8 conversion
//
#define RtlUInt64ToUInt8   RtlULongLongToUInt8

//
// UINT64 -> BYTE conversion
//
#define RtlUInt64ToByte    RtlULongLongToUInt8

//
// UINT64 -> SHORT conversion
//
#define RtlUInt64ToShort   RtlULongLongToShort

//
// UINT64 -> INT16 conversion
//
//
#define RtlUInt64ToInt16   RtlULongLongToShort

//
// UINT64 -> USHORT conversion
//
#define RtlUInt64ToUShort  RtlULongLongToUShort

//
// UINT64 -> UINT16 conversion
//
#define RtlUInt64ToUInt16  RtlULongLongToUShort

//
// UINT64 -> WORD conversion
//
#define RtlUInt64ToWord    RtlULongLongToUShort

//
// UINT64 -> INT conversion
//
#define RtlUInt64ToInt RtlULongLongToInt

//
// UINT64 -> INT32 conversion
//
#define RtlUInt64ToInt32   RtlULongLongToInt

//
// UINT64 -> INT_PTR conversion
//
#define RtlUInt64ToIntPtr  RtlULongLongToIntPtr

//
// UINT64 -> UINT conversion
//
#define RtlUInt64ToUInt    RtlULongLongToUInt

//
// UINT64 -> UINT32 conversion
//
#define RtlUInt64ToUInt32  RtlULongLongToUInt

//
// UINT64 -> UINT_PTR conversion
//
#define RtlUInt64ToUIntPtr RtlULongLongToUIntPtr

//
// UINT64 -> LONG conversion
//
#define RtlUInt64ToLong    RtlULongLongToLong

//
// UINT64 -> LONG_PTR conversion
//
#define RtlUInt64ToLongPtr RtlULongLongToLongPtr

//
// UINT64 -> ULONG conversion
//
#define RtlUInt64ToULong   RtlULongLongToULong

//
// UINT64 -> ULONG_PTR conversion
//
#define RtlUInt64ToULongPtr    RtlULongLongToULongPtr

//
// UINT64 -> DWORD conversion
//
#define RtlUInt64ToDWord   RtlULongLongToULong

//
// UINT64 -> DWORD_PTR conversion
//
#define RtlUInt64ToDWordPtr    RtlULongLongToULongPtr

//
// UINT64 -> LONGLONG conversion
//
#define RtlUInt64ToLongLong    RtlULongLongToLongLong

//
// UINT64 -> LONG64 conversion
//
#define RtlUInt64ToLong64  RtlULongLongToLongLong

//
// UINT64 -> RtlINT64 conversion
//
#define RtlUInt64ToInt64   RtlULongLongToLongLong

//
// UINT64 -> ptrdiff_t conversion
//
#define RtlUInt64ToPtrdiffT    RtlULongLongToIntPtr

//
// UINT64 -> size_t conversion
//
#define RtlUInt64ToSizeT   RtlULongLongToUIntPtr

//
// UINT64 -> SSIZE_T conversion
//
#define RtlUInt64ToSSIZET  RtlULongLongToLongPtr

//
// UINT64 -> SIZE_T conversion
//
#define RtlUInt64ToSIZET  RtlULongLongToULongPtr

//
// ptrdiff_t -> CHAR conversion
//
#define RtlPtrdiffTToChar  RtlIntPtrToChar

//
// ptrdiff_t -> INT8 conversion
//
#define RtlPtrdiffTToInt8  RtlIntPtrToInt8

//
// ptrdiff_t -> UCHAR conversion
//
#define RtlPtrdiffTToUChar RtlIntPtrToUChar

//
// ptrdiff_t -> UINT8 conversion
//
#define RtlPtrdiffTToUInt8 RtlIntPtrToUInt8

//
// ptrdiff_t -> BYTE conversion
//
#define RtlPtrdiffTToByte  RtlIntPtrToUInt8

//
// ptrdiff_t -> SHORT conversion
//
#define RtlPtrdiffTToShort RtlIntPtrToShort

//
// ptrdiff_t -> INT16 conversion
//
#define RtlPtrdiffTToInt16 RtlIntPtrToShort

//
// ptrdiff_t -> USHORT conversion
//
#define RtlPtrdiffTToUShort    RtlIntPtrToUShort

//
// ptrdiff_t -> UINT16 conversion
//
#define RtlPtrdiffTToUInt16    RtlIntPtrToUShort

//
// ptrdiff_t -> WORD conversion
//
#define RtlPtrdiffTToWord  RtlIntPtrToUShort

//
// ptrdiff_t -> INT conversion
//
#define RtlPtrdiffTToInt   RtlIntPtrToInt

//
// ptrdiff_t -> INT32 conversion
//
#define RtlPtrdiffTToInt32 RtlIntPtrToInt

//
// ptrdiff_t -> UINT conversion
//
#define RtlPtrdiffTToUInt  RtlIntPtrToUInt

//
// ptrdiff_t -> UINT32 conversion
//
#define RtlPtrdiffTToUInt32    RtlIntPtrToUInt

//
// ptrdiff_t -> UINT_PTR conversion
//
#define RtlPtrdiffTToUIntPtr   RtlIntPtrToUIntPtr

//
// ptrdiff_t -> LONG conversion
//
#define RtlPtrdiffTToLong  RtlIntPtrToLong

//
// ptrdiff_t -> LONG_PTR conversion
//
#define RtlPtrdiffTToLongPtr   RtlIntPtrToLongPtr

//
// ptrdiff_t -> ULONG conversion
//
#define RtlPtrdiffTToULong RtlIntPtrToULong

//
// ptrdiff_t -> ULONG_PTR conversion
//
#define RtlPtrdiffTToULongPtr  RtlIntPtrToULongPtr

//
// ptrdiff_t -> DWORD conversion
//
#define RtlPtrdiffTToDWord RtlIntPtrToULong

//
// ptrdiff_t -> DWORD_PTR conversion
//
#define RtlPtrdiffTToDWordPtr  RtlIntPtrToULongPtr

//
// ptrdiff_t -> ULONGLONG conversion
//
#define RtlPtrdiffTToULongLong RtlIntPtrToULongLong

//
// ptrdiff_t -> DWORDLONG conversion
//
#define RtlPtrdiffTToDWordLong RtlIntPtrToULongLong

//
// ptrdiff_t -> ULONG64 conversion
//
#define RtlPtrdiffTToULong64   RtlIntPtrToULongLong

//
// ptrdiff_t -> DWORD64 conversion
//
#define RtlPtrdiffTToDWord64   RtlIntPtrToULongLong

//
// ptrdiff_t -> UINT64 conversion
//
#define RtlPtrdiffTToUInt64    RtlIntPtrToULongLong

//
// ptrdiff_t -> size_t conversion
//
#define RtlPtrdiffTToSizeT RtlIntPtrToUIntPtr

//
// ptrdiff_t -> SIZE_T conversion
//
#define RtlPtrdiffTToSIZET RtlIntPtrToULongPtr

//
// size_t -> INT8 conversion
//
#define RtlSizeTToInt8 RtlUIntPtrToInt8

//
// size_t -> UCHAR conversion
//
#define RtlSizeTToUChar    RtlUIntPtrToUChar

//
// size_t -> CHAR conversion
//
#define RtlSizeTToChar RtlUIntPtrToChar

//
// size_t -> UINT8 conversion
//
#define RtlSizeTToUInt8    RtlUIntPtrToUInt8

//
// size_t -> BYTE conversion
//
#define RtlSizeTToByte RtlUIntPtrToUInt8

//
// size_t -> SHORT conversion
//
#define RtlSizeTToShort    RtlUIntPtrToShort

//
// size_t -> INT16 conversion
//
#define RtlSizeTToInt16    RtlUIntPtrToShort

//
// size_t -> USHORT conversion
//
#define RtlSizeTToUShort   RtlUIntPtrToUShort

//
// size_t -> UINT16 conversion
//
#define RtlSizeTToUInt16   RtlUIntPtrToUShort

//
// size_t -> WORD
//
#define RtlSizeTToWord RtlUIntPtrToUShort

//
// size_t -> INT conversion
//
#define RtlSizeTToInt  RtlUIntPtrToInt

//
// size_t -> INT32 conversion
//
#define RtlSizeTToInt32    RtlUIntPtrToInt

//
// size_t -> INT_PTR conversion
//
#define RtlSizeTToIntPtr   RtlUIntPtrToIntPtr

//
// size_t -> UINT conversion
//
#define RtlSizeTToUInt RtlUIntPtrToUInt

//
// size_t -> UINT32 conversion
//
#define RtlSizeTToUInt32   RtlUIntPtrToUInt

//
// size_t -> LONG conversion
//
#define RtlSizeTToLong RtlUIntPtrToLong

//
// size_t -> LONG_PTR conversion
//
#define RtlSizeTToLongPtr  RtlUIntPtrToLongPtr

//
// size_t -> ULONG conversion
//
#define RtlSizeTToULong    RtlUIntPtrToULong

//
// size_t -> DWORD conversion
//
#define RtlSizeTToDWord    RtlUIntPtrToULong

//
// size_t -> LONGLONG conversion
//
#define RtlSizeTToLongLong RtlUIntPtrToLongLong

//
// size_t -> LONG64 conversion
//
#define RtlSizeTToLong64   RtlUIntPtrToLongLong

//
// size_t -> RtlINT64
//
#define RtlSizeTToInt64    RtlUIntPtrToLongLong

//   
// size_t -> ptrdiff_t conversion
//
#define RtlSizeTToPtrdiffT RtlUIntPtrToIntPtr

//
// size_t -> SSIZE_T conversion
//
#define RtlSizeTToSSIZET   RtlUIntPtrToLongPtr

//
// SSIZE_T -> INT8 conversion
//
#define RtlSSIZETToInt8    RtlLongPtrToInt8

//
// SSIZE_T -> UCHAR conversion
//
#define RtlSSIZETToUChar   RtlLongPtrToUChar

//
// SSIZE_T -> CHAR conversion
//
#define RtlSSIZETToChar    RtlLongPtrToChar

//
// SSIZE_T -> UINT8 conversion
//
#define RtlSSIZETToUInt8   RtlLongPtrToUInt8

//
// SSIZE_T -> BYTE conversion
//
#define RtlSSIZETToByte    RtlLongPtrToUInt8

//
// SSIZE_T -> SHORT conversion
//
#define RtlSSIZETToShort   RtlLongPtrToShort

//
// SSIZE_T -> INT16 conversion
//
#define RtlSSIZETToInt16   RtlLongPtrToShort

//
// SSIZE_T -> USHORT conversion
//
#define RtlSSIZETToUShort  RtlLongPtrToUShort

//
// SSIZE_T -> UINT16 conversion
//
#define RtlSSIZETToUInt16  RtlLongPtrToUShort

//
// SSIZE_T -> WORD conversion
//
#define RtlSSIZETToWord    RtlLongPtrToUShort

//
// SSIZE_T -> INT conversion
//
#define RtlSSIZETToInt RtlLongPtrToInt

//
// SSIZE_T -> INT32 conversion
//
#define RtlSSIZETToInt32   RtlLongPtrToInt

//
// SSIZE_T -> INT_PTR conversion
//
#define RtlSSIZETToIntPtr  RtlLongPtrToIntPtr

//
// SSIZE_T -> UINT conversion
//
#define RtlSSIZETToUInt    RtlLongPtrToUInt

//
// SSIZE_T -> UINT32 conversion
//
#define RtlSSIZETToUInt32  RtlLongPtrToUInt

//
// SSIZE_T -> UINT_PTR conversion
//
#define RtlSSIZETToUIntPtr RtlLongPtrToUIntPtr

//
// SSIZE_T -> LONG conversion
//
#define RtlSSIZETToLong    RtlLongPtrToLong

//
// SSIZE_T -> ULONG conversion
//
#define RtlSSIZETToULong   RtlLongPtrToULong

//
// SSIZE_T -> ULONG_PTR conversion
//
#define RtlSSIZETToULongPtr    RtlLongPtrToULongPtr

//
// SSIZE_T -> DWORD conversion
//
#define RtlSSIZETToDWord   RtlLongPtrToULong

//
// SSIZE_T -> DWORD_PTR conversion
//
#define RtlSSIZETToDWordPtr    RtlLongPtrToULongPtr

//
// SSIZE_T -> ULONGLONG conversion
//
#define RtlSSIZETToULongLong   RtlLongPtrToULongLong

//
// SSIZE_T -> DWORDLONG conversion
//
#define RtlSSIZETToDWordLong   RtlLongPtrToULongLong

//
// SSIZE_T -> ULONG64 conversion
//
#define RtlSSIZETToULong64 RtlLongPtrToULongLong

//
// SSIZE_T -> DWORD64 conversion
//
#define RtlSSIZETToDWord64 RtlLongPtrToULongLong

//
// SSIZE_T -> UINT64 conversion
//
#define RtlSSIZETToUInt64  RtlLongPtrToULongLong

//
// SSIZE_T -> size_t conversion
//
#define RtlSSIZETToSizeT   RtlLongPtrToUIntPtr

//
// SSIZE_T -> SIZE_T conversion
//
#define RtlSSIZETToSIZET   RtlLongPtrToULongPtr

//
// SIZE_T -> INT8 conversion
//
#define RtlSIZETToInt8 RtlULongPtrToInt8

//
// SIZE_T -> UCHAR conversion
//
#define RtlSIZETToUChar    RtlULongPtrToUChar

//
// SIZE_T -> CHAR conversion
//
#define RtlSIZETToChar RtlULongPtrToChar

//
// SIZE_T -> UINT8 conversion
//
#define RtlSIZETToUInt8    RtlULongPtrToUInt8

//
// SIZE_T -> BYTE conversion
//
#define RtlSIZETToByte RtlULongPtrToUInt8

//
// SIZE_T -> SHORT conversion
//
#define RtlSIZETToShort    RtlULongPtrToShort

//
// SIZE_T -> INT16 conversion
//
#define RtlSIZETToInt16    RtlULongPtrToShort

//
// SIZE_T -> USHORT conversion
//
#define RtlSIZETToUShort   RtlULongPtrToUShort

//
// SIZE_T -> UINT16 conversion
//
#define RtlSIZETToUInt16   RtlULongPtrToUShort

//
// SIZE_T -> WORD
//
#define RtlSIZETToWord RtlULongPtrToUShort

//
// SIZE_T -> INT conversion
//
#define RtlSIZETToInt  RtlULongPtrToInt

//
// SIZE_T -> INT32 conversion
//
#define RtlSIZETToInt32    RtlULongPtrToInt

//
// SIZE_T -> INT_PTR conversion
//
#define RtlSIZETToIntPtr   RtlULongPtrToIntPtr

//
// SIZE_T -> UINT conversion
//
#define RtlSIZETToUInt RtlULongPtrToUInt

//
// SIZE_T -> UINT32 conversion
//
#define RtlSIZETToUInt32   RtlULongPtrToUInt

//
// SIZE_T -> UINT_PTR conversion
//
#define RtlSIZETToUIntPtr  RtlULongPtrToUIntPtr

//
// SIZE_T -> LONG conversion
//
#define RtlSIZETToLong RtlULongPtrToLong

//
// SIZE_T -> LONG_PTR conversion
//
#define RtlSIZETToLongPtr  RtlULongPtrToLongPtr

//
// SIZE_T -> ULONG conversion
//
#define RtlSIZETToULong    RtlULongPtrToULong

//
// SIZE_T -> DWORD conversion
//
#define RtlSIZETToDWord    RtlULongPtrToULong

//
// SIZE_T -> LONGLONG conversion
//
#define RtlSIZETToLongLong RtlULongPtrToLongLong

//
// SIZE_T -> LONG64 conversion
//
#define RtlSIZETToLong64   RtlULongPtrToLongLong

//
// SIZE_T -> RtlINT64
//
#define RtlSIZETToInt64    RtlULongPtrToLongLong

//
// SIZE_T -> ptrdiff_t conversion
//
#define RtlSIZETToPtrdiffT RtlULongPtrToIntPtr

//
// SIZE_T -> SSIZE_T conversion
//
#define RtlSIZETToSSIZET   RtlULongPtrToLongPtr


//=============================================================================
// Addition functions
//=============================================================================

//
// UINT8 addition
//
__inline
NTSTATUS
RtlUInt8Add(
    __in UINT8 u8Augend,
    __in UINT8 u8Addend,
    __out __deref_out_range(==,u8Augend + u8Addend) UINT8* pu8Result)
{
    NTSTATUS status;

    if (((UINT8)(u8Augend + u8Addend)) >= u8Augend)
    {
        *pu8Result = (UINT8)(u8Augend + u8Addend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// USHORT addition
//
__inline
NTSTATUS
RtlUShortAdd(
    __in USHORT usAugend,
    __in USHORT usAddend,
    __out __deref_out_range(==,usAugend + usAddend) USHORT* pusResult)
{
    NTSTATUS status;

    if (((USHORT)(usAugend + usAddend)) >= usAugend)
    {
        *pusResult = (USHORT)(usAugend + usAddend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT16 addition
//
#define RtlUInt16Add   RtlUShortAdd

//
// WORD addtition
//
#define RtlWordAdd     RtlUShortAdd

//
// UINT addition
//
__inline
NTSTATUS
RtlUIntAdd(
    __in UINT uAugend,
    __in UINT uAddend,
    __out __deref_out_range(==,uAugend + uAddend) UINT* puResult)
{
    NTSTATUS status;

    if ((uAugend + uAddend) >= uAugend)
    {
        *puResult = (uAugend + uAddend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT32 addition
//
#define RtlUInt32Add   RtlUIntAdd

//
// UINT_PTR addition
//
#ifdef _WIN64
#define RtlUIntPtrAdd      RtlULongLongAdd
#else
__inline
NTSTATUS
RtlUIntPtrAdd(
    __in UINT_PTR uAugend,
    __in UINT_PTR uAddend,
    __out __deref_out_range(==,uAugend + uAddend) UINT_PTR* puResult)
{
    NTSTATUS status;

    if ((uAugend + uAddend) >= uAugend)
    {
        *puResult = (uAugend + uAddend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif // _WIN64

//
// ULONG addition
//
__inline
NTSTATUS
RtlULongAdd(
    __in ULONG ulAugend,
    __in ULONG ulAddend,
    __out __deref_out_range(==,ulAugend + ulAddend) ULONG* pulResult)
{
    NTSTATUS status;

    if ((ulAugend + ulAddend) >= ulAugend)
    {
        *pulResult = (ulAugend + ulAddend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG_PTR addition
//
#ifdef _WIN64
#define RtlULongPtrAdd     RtlULongLongAdd
#else
__inline
NTSTATUS
RtlULongPtrAdd(
    __in ULONG_PTR ulAugend,
    __in ULONG_PTR ulAddend,
    __out __deref_out_range(==,ulAugend + ulAddend) ULONG_PTR* pulResult)
{
    NTSTATUS status;

    if ((ulAugend + ulAddend) >= ulAugend)
    {
        *pulResult = (ulAugend + ulAddend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif // _WIN64

//
// DWORD addition
//
#define RtlDWordAdd        RtlULongAdd

//
// DWORD_PTR addition
//
#ifdef _WIN64
#define RtlDWordPtrAdd     RtlULongLongAdd
#else
__inline
NTSTATUS
RtlDWordPtrAdd(
    __in DWORD_PTR dwAugend,
    __in DWORD_PTR dwAddend,
    __out __deref_out_range(==,dwAugend + dwAddend) DWORD_PTR* pdwResult)
{
    NTSTATUS status;

    if ((dwAugend + dwAddend) >= dwAugend)
    {
        *pdwResult = (dwAugend + dwAddend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pdwResult = DWORD_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif // _WIN64

//
// size_t addition
//
__inline
NTSTATUS
RtlSizeTAdd(
    __in size_t Augend,
    __in size_t Addend,
    __out __deref_out_range(==,Augend + Addend) size_t* pResult)
{
    NTSTATUS status;

    if ((Augend + Addend) >= Augend)
    {
        *pResult = (Augend + Addend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pResult = SIZE_T_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// SIZE_T addition
//
#ifdef _WIN64
#define RtlSIZETAdd      RtlULongLongAdd
#else
__inline
NTSTATUS
RtlSIZETAdd(
    __in SIZE_T Augend,
    __in SIZE_T Addend,
    __out __deref_out_range(==,Augend + Addend) SIZE_T* pResult)
{
    NTSTATUS status;

    if ((Augend + Addend) >= Augend)
    {
        *pResult = (Augend + Addend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pResult = _SIZE_T_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif // _WIN64

//
// ULONGLONG addition
//
__inline
NTSTATUS
RtlULongLongAdd(
    __in ULONGLONG ullAugend,
    __in ULONGLONG ullAddend,
    __out __deref_out_range(==,ullAugend + ullAddend) ULONGLONG* pullResult)
{
    NTSTATUS status;

    if ((ullAugend + ullAddend) >= ullAugend)
    {
        *pullResult = (ullAugend + ullAddend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// DWORDLONG addition
//
#define RtlDWordLongAdd    RtlULongLongAdd

//
// ULONG64 addition
//
#define RtlULong64Add  RtlULongLongAdd

//
// DWORD64 addition
//
#define RtlDWord64Add  RtlULongLongAdd

//
// UINT64 addition
//
#define RtlUInt64Add   RtlULongLongAdd


//=============================================================================
// Subtraction functions
//=============================================================================

//
// UINT8 subtraction
//
__inline
NTSTATUS
RtlUInt8Sub(
    __in UINT8 u8Minuend,
    __in UINT8 u8Subtrahend,
    __out __deref_out_range(==,u8Minuend - u8Subtrahend) UINT8* pu8Result)
{
    NTSTATUS status;
    
    if (u8Minuend >= u8Subtrahend)
    {
        *pu8Result = (UINT8)(u8Minuend - u8Subtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// USHORT subtraction
//
__inline
NTSTATUS
RtlUShortSub(
    __in USHORT usMinuend,
    __in USHORT usSubtrahend,
    __out __deref_out_range(==,usMinuend - usSubtrahend) USHORT* pusResult)
{
    NTSTATUS status;

    if (usMinuend >= usSubtrahend)
    {
        *pusResult = (USHORT)(usMinuend - usSubtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT16 subtraction
//
#define RtlUInt16Sub   RtlUShortSub

//
// WORD subtraction
//
#define RtlWordSub     RtlUShortSub


//
// UINT subtraction
//
__inline
NTSTATUS
RtlUIntSub(
    __in UINT uMinuend,
    __in UINT uSubtrahend,
    __out __deref_out_range(==,uMinuend - uSubtrahend) UINT* puResult)
{
    NTSTATUS status;

    if (uMinuend >= uSubtrahend)
    {
        *puResult = (uMinuend - uSubtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// UINT32 subtraction
//
#define RtlUInt32Sub   RtlUIntSub

//
// UINT_PTR subtraction
//
#ifdef _WIN64
#define RtlUIntPtrSub  RtlULongLongSub
#else
__inline
NTSTATUS
RtlUIntPtrSub(
    __in UINT_PTR uMinuend,
    __in UINT_PTR uSubtrahend,
    __out __deref_out_range(==,uMinuend - uSubtrahend) UINT_PTR* puResult)
{
    NTSTATUS status;

    if (uMinuend >= uSubtrahend)
    {
        *puResult = (uMinuend - uSubtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif // _WIN64

//
// ULONG subtraction
//
__inline
NTSTATUS
RtlULongSub(
    __in ULONG ulMinuend,
    __in ULONG ulSubtrahend,
    __out __deref_out_range(==,ulMinuend - ulSubtrahend) ULONG* pulResult)
{
    NTSTATUS status;

    if (ulMinuend >= ulSubtrahend)
    {
        *pulResult = (ulMinuend - ulSubtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// ULONG_PTR subtraction
//
#ifdef _WIN64
#define RtlULongPtrSub RtlULongLongSub
#else
__inline
NTSTATUS
RtlULongPtrSub(
    __in ULONG_PTR ulMinuend,
    __in ULONG_PTR ulSubtrahend,
    __out __deref_out_range(==,ulMinuend - ulSubtrahend) ULONG_PTR* pulResult)
{
    NTSTATUS status;

    if (ulMinuend >= ulSubtrahend)
    {
        *pulResult = (ulMinuend - ulSubtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif // _WIN64


//
// DWORD subtraction
//
#define RtlDWordSub        RtlULongSub

//
// DWORD_PTR subtraction
//
#ifdef _WIN64
#define RtlDWordPtrSub     RtlULongLongSub
#else
__inline
NTSTATUS
RtlDWordPtrSub(
    __in DWORD_PTR dwMinuend,
    __in DWORD_PTR dwSubtrahend,
    __out __deref_out_range(==,dwMinuend - dwSubtrahend) DWORD_PTR* pdwResult)
{
    NTSTATUS status;

    if (dwMinuend >= dwSubtrahend)
    {
        *pdwResult = (dwMinuend - dwSubtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pdwResult = DWORD_PTR_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
} 
#endif // _WIN64

//
// size_t subtraction
//
__inline
NTSTATUS
RtlSizeTSub(
    __in size_t Minuend,
    __in size_t Subtrahend,
    __out __deref_out_range(==,Minuend - Subtrahend) size_t* pResult)
{
    NTSTATUS status;

    if (Minuend >= Subtrahend)
    {
        *pResult = (Minuend - Subtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pResult = SIZE_T_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// SIZE_T subtraction
//
#ifdef _WIN64
#define RtlSIZETSub    RtlULongLongSub
#else
__inline
NTSTATUS
RtlSIZETSub(
    __in SIZE_T Minuend,
    __in SIZE_T Subtrahend,
    __out __deref_out_range(==,Minuend - Subtrahend) SIZE_T* pResult)
{
    NTSTATUS status;

    if (Minuend >= Subtrahend)
    {
        *pResult = (Minuend - Subtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pResult = _SIZE_T_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}
#endif // _WIN64

//
// ULONGLONG subtraction
//
__inline
NTSTATUS
RtlULongLongSub(
    __in ULONGLONG ullMinuend,
    __in ULONGLONG ullSubtrahend,
    __out __deref_out_range(==,ullMinuend - ullSubtrahend) ULONGLONG* pullResult)
{
    NTSTATUS status;

    if (ullMinuend >= ullSubtrahend)
    {
        *pullResult = (ullMinuend - ullSubtrahend);
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    
    return status;
}

//
// DWORDLONG subtraction
//
#define RtlDWordLongSub    RtlULongLongSub

//
// ULONG64 subtraction
//
#define RtlULong64Sub  RtlULongLongSub

//
// DWORD64 subtraction
//
#define RtlDWord64Sub  RtlULongLongSub

//
// UINT64 subtraction
//
#define RtlUInt64Sub   RtlULongLongSub


//=============================================================================
// Multiplication functions
//=============================================================================

//
// UINT8 multiplication
//
__inline
NTSTATUS
RtlUInt8Mult(
    __in UINT8 u8Multiplicand,
    __in UINT8 u8Multiplier,
    __out __deref_out_range(==,u8Multiplier * u8Multiplicand) UINT8* pu8Result)
{
    UINT uResult = ((UINT)u8Multiplicand) * ((UINT)u8Multiplier);
    
    return RtlUIntToUInt8(uResult, pu8Result);
}    

//
// USHORT multiplication
//
__inline
NTSTATUS
RtlUShortMult(
    __in USHORT usMultiplicand,
    __in USHORT usMultiplier,
    __out __deref_out_range(==,usMultiplier * usMultiplicand)USHORT* pusResult)
{
    ULONG ulResult = ((ULONG)usMultiplicand) * ((ULONG)usMultiplier);
    
    return RtlULongToUShort(ulResult, pusResult);
}

//
// UINT16 multiplication
//
#define RtlUInt16Mult  RtlUShortMult

//
// WORD multiplication
//
#define RtlWordMult    RtlUShortMult

//
// UINT multiplication
//
__inline
NTSTATUS
RtlUIntMult(
    __in UINT uMultiplicand,
    __in UINT uMultiplier,
    __out __deref_out_range(==,uMultiplier * uMultiplicand) UINT* puResult)
{
    ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

    return RtlULongLongToUInt(ull64Result, puResult);
}

//
// UINT32 multiplication
//
#define RtlUInt32Mult  RtlUIntMult

//
// UINT_PTR multiplication
//
#ifdef _WIN64
#define RtlUIntPtrMult     RtlULongLongMult
#else
__inline
NTSTATUS
RtlUIntPtrMult(
    __in UINT_PTR uMultiplicand,
    __in UINT_PTR uMultiplier,
    __out __deref_out_range(==,uMultiplier * uMultiplicand) UINT_PTR* puResult)
{
    ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

    return RtlULongLongToUIntPtr(ull64Result, puResult);
}
#endif // _WIN64

//
// ULONG multiplication
//
__inline
NTSTATUS
RtlULongMult(
    __in ULONG ulMultiplicand,
    __in ULONG ulMultiplier,
    __out __deref_out_range(==,ulMultiplier * ulMultiplicand) ULONG* pulResult)
{
    ULONGLONG ull64Result = UInt32x32To64(ulMultiplicand, ulMultiplier);
    
    return RtlULongLongToULong(ull64Result, pulResult);
}

//
// ULONG_PTR multiplication
//
#ifdef _WIN64
#define RtlULongPtrMult    RtlULongLongMult
#else
__inline
NTSTATUS
RtlULongPtrMult(
    __in ULONG_PTR ulMultiplicand,
    __in ULONG_PTR ulMultiplier,
    __out __deref_out_range(==,ulMultiplier * ulMultiplicand) ULONG_PTR* pulResult)
{
    ULONGLONG ull64Result = UInt32x32To64(ulMultiplicand, ulMultiplier);
    
    return RtlULongLongToULongPtr(ull64Result, pulResult);
}
#endif // _WIN64

//
// DWORD multiplication
//
#define RtlDWordMult       RtlULongMult

//
// DWORD_PTR multiplication
//
#ifdef _WIN64
#define RtlDWordPtrMult    RtlULongLongMult
#else
__inline
NTSTATUS
RtlDWordPtrMult(
    __in DWORD_PTR dwMultiplicand,
    __in DWORD_PTR dwMultiplier,
    __out __deref_out_range(==,dwMultiplier * dwMultiplicand) DWORD_PTR* pdwResult)
{
    ULONGLONG ull64Result = UInt32x32To64(dwMultiplicand, dwMultiplier);
    
    return RtlULongLongToDWordPtr(ull64Result, pdwResult);
}
#endif // _WIN64

//
// size_t multiplication
//

#ifdef _WIN64
#define RtlSizeTMult       RtlULongLongMult
#else
__inline
NTSTATUS
RtlSizeTMult(
    __in size_t Multiplicand,
    __in size_t Multiplier,
    __out __deref_out_range(==,Multiplier * Multiplicand) size_t* pResult)
{
    ULONGLONG ull64Result = UInt32x32To64(Multiplicand, Multiplier);

    return RtlULongLongToSizeT(ull64Result, pResult);
}
#endif // _WIN64

//
// SIZE_T multiplication
//
#ifdef _WIN64
#define RtlSIZETMult       RtlULongLongMult
#else
__inline
NTSTATUS
RtlSIZETMult(
    __in SIZE_T Multiplicand,
    __in SIZE_T Multiplier,
    __out __deref_out_range(==,Multiplier * Multiplicand) SIZE_T* pResult)
{
    ULONGLONG ull64Result = UInt32x32To64(Multiplicand, Multiplier);
    
    return RtlULongLongToSIZET(ull64Result, pResult);
}
#endif // _WIN64

//
// ULONGLONG multiplication
//
__inline
NTSTATUS
RtlULongLongMult(
    __in ULONGLONG ullMultiplicand,
    __in ULONGLONG ullMultiplier,
    __out __deref_out_range(==,ullMultiplier * ullMultiplicand) ULONGLONG* pullResult)
{
    NTSTATUS status;
#if defined(_USE_INTRINSIC_MULTIPLY128)
    ULONGLONG u64ResultHigh;
    ULONGLONG u64ResultLow;
    
    u64ResultLow = UnsignedMultiply128(ullMultiplicand, ullMultiplier, &u64ResultHigh);
    if (u64ResultHigh == 0)
    {
        *pullResult = u64ResultLow;
        status = STATUS_SUCCESS;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
#else
    // 64x64 into 128 is like 32.32 x 32.32.
    //
    // a.b * c.d = a*(c.d) + .b*(c.d) = a*c + a*.d + .b*c + .b*.d
    // back in non-decimal notation where A=a*2^32 and C=c*2^32:  
    // A*C + A*d + b*C + b*d
    // So there are four components to add together.
    //   result = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)
    //
    // a * c must be 0 or there would be bits in the high 64-bits
    // a * d must be less than 2^32 or there would be bits in the high 64-bits
    // b * c must be less than 2^32 or there would be bits in the high 64-bits
    // then there must be no overflow of the resulting values summed up.
    
    ULONG dw_a;
    ULONG dw_b;
    ULONG dw_c;
    ULONG dw_d;
    ULONGLONG ad = 0;
    ULONGLONG bc = 0;
    ULONGLONG bd = 0;
    ULONGLONG ullResult = 0;

    status = STATUS_INTEGER_OVERFLOW;
    
    dw_a = (ULONG)(ullMultiplicand >> 32);
    dw_c = (ULONG)(ullMultiplier >> 32);

    // common case -- if high dwords are both zero, no chance for overflow
    if ((dw_a == 0) && (dw_c == 0))
    {
        dw_b = (DWORD)ullMultiplicand;
        dw_d = (DWORD)ullMultiplier;

        *pullResult = (((ULONGLONG)dw_b) * (ULONGLONG)dw_d);
        status = STATUS_SUCCESS;
    }
    else
    {
        // a * c must be 0 or there would be bits set in the high 64-bits
        if ((dw_a == 0) ||
            (dw_c == 0))
        {
            dw_d = (DWORD)ullMultiplier;

            // a * d must be less than 2^32 or there would be bits set in the high 64-bits
            ad = (((ULONGLONG)dw_a) * (ULONGLONG)dw_d);
            if ((ad & 0xffffffff00000000) == 0)
            {
                dw_b = (DWORD)ullMultiplicand;

                // b * c must be less than 2^32 or there would be bits set in the high 64-bits
                bc = (((ULONGLONG)dw_b) * (ULONGLONG)dw_c);
                if ((bc & 0xffffffff00000000) == 0)
                {
                    // now sum them all up checking for overflow.
                    // shifting is safe because we already checked for overflow above
                    if (NT_SUCCESS(RtlULongLongAdd(bc << 32, ad << 32, &ullResult)))                        
                    {
                        // b * d
                        bd = (((ULONGLONG)dw_b) * (ULONGLONG)dw_d);
                    
                        if (NT_SUCCESS(RtlULongLongAdd(ullResult, bd, &ullResult)))
                        {
                            *pullResult = ullResult;
                            status = STATUS_SUCCESS;
                        }
                    }
                }
            }
        }
    }

    if (!NT_SUCCESS(status))
    {
        *pullResult = ULONGLONG_ERROR;
    }
#endif // _USE_INTRINSIC_MULTIPLY128
    
    return status;
}

//
// DWORDLONG multiplication
//
#define RtlDWordLongMult   RtlULongLongMult

//
// ULONG64 multiplication
//
#define RtlULong64Mult RtlULongLongMult

//
// DWORD64 multiplication
//
#define RtlDWord64Mult RtlULongLongMult

//
// UINT64 multiplication
//
#define RtlUInt64Mult  RtlULongLongMult


/////////////////////////////////////////////////////////////////////////
//
// signed operations
//
// Strongly consider using unsigned numbers.
//
// Signed numbers are often used where unsigned numbers should be used.
// For example file sizes and array indices should always be unsigned.
// (File sizes should be 64bit integers; array indices should be size_t.)
// Subtracting a larger positive signed number from a smaller positive
// signed number with RtlIntSub will succeed, producing a negative number,
// that then must not be used as an array index (but can occasionally be
// used as a pointer index.) Similarly for adding a larger magnitude
// negative number to a smaller magnitude positive number.
//
// intsafe.h does not protect you from such errors. It tells you if your
// integer operations overflowed, not if you are doing the right thing
// with your non-overflowed integers.
//
// Likewise you can overflow a buffer with a non-overflowed unsigned index.
//
#if defined(ENABLE_INTSAFE_SIGNED_FUNCTIONS)

#if defined(_USE_INTRINSIC_MULTIPLY128)
#ifdef __cplusplus
extern "C" {
#endif

#define Multiply128 _mul128

LONG64
Multiply128(
    __in LONG64  Multiplier,
    __in LONG64  Multiplicand,
    __out LONG64 *HighProduct
    );
#pragma intrinsic(_mul128)

#ifdef __cplusplus
}
#endif
#endif // _USE_INTRINSIC_MULTIPLY128

__inline
NTSTATUS
RtlInt8Add(
    __in INT8 a,
    __in INT8 b,
    __out INT8* pc
    )
{
    C_ASSERT(sizeof(long) > sizeof(INT8));
    return RtlLongToInt8((((long)a) + ((long)b)), pc);
}

__inline
NTSTATUS
RtlShortAdd(
    __in short a,
    __in short b,
    __out short* pc
    )
{
    C_ASSERT(sizeof(long) > sizeof(short));
    return RtlLongToShort((((long)a) + ((long)b)), pc);
}

__inline
NTSTATUS
RtlIntAdd(
    __in int a,
    __in int b,
    __out int* pc
    )
{
    C_ASSERT(sizeof(__int64) > sizeof(int));
    return RtlInt64ToInt((((__int64)a) + ((__int64)b)), pc);
}

__inline
NTSTATUS
RtlLongAdd(
    __in long a,
    __in long b,
    __out long* pc
    )
{
    C_ASSERT(sizeof(int) == sizeof(long));
    C_ASSERT(INT_ERROR == LONG_ERROR);
    return RtlIntAdd((int)a, (int)b, (int*)pc);
}

__inline
NTSTATUS
RtlInt64Add(
    __in __int64 a,
    __in __int64 b,
    __out __int64* pc
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    __int64 c = (a + b);
    //
    // Adding positive to negative never overflows.
    // If you add two positive numbers, you expect a positive result.
    // If you add two negative numbers, you expect a negative result.
    // Overflow if inputs are the same sign and output is not that sign.
    //
    if (((a < 0) == (b < 0)) && ((a < 0) != (c < 0)))
    {
        c = INT64_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    *pc = c;
    return status;
}

__inline
NTSTATUS
RtlInt8Sub(
    __in INT8 a,
    __in INT8 b,
    __out INT8* pc
    )
{
    C_ASSERT(sizeof(long) > sizeof(INT8));
    return RtlLongToInt8((((long)a) - ((long)b)), pc);
}

__inline
NTSTATUS
RtlShortSub(
    __in short a,
    __in short b,
    __out short* pc
    )
{
    C_ASSERT(sizeof(long) > sizeof(short));
    return RtlLongToShort((((long)a) - ((long)b)), pc);
}

__inline
NTSTATUS
RtlIntSub(
    __in int a,
    __in int b,
    __out int* pc
    )
{
    C_ASSERT(sizeof(__int64) > sizeof(int));
    return RtlInt64ToInt((((__int64)a) - ((__int64)b)), pc);
}

__inline
NTSTATUS
RtlLongSub(
    __in long a,
    __in long b,
    __out long* pc
    )
{
    C_ASSERT(sizeof(int) == sizeof(long));
    C_ASSERT(INT_ERROR == LONG_ERROR);
    return RtlIntSub((int)a, (int)b, (int*)pc);
}

__inline
NTSTATUS
RtlInt64Sub(
    __in __int64 a,
    __in __int64 b,
    __out __int64* pc
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    __int64 c = (a - b);
    //
    // Subtracting a positive number from a positive number never overflows.
    // Subtracting a negative number from a negative number never overflows.
    // If you subtract a negative number from a positive number, you expect a positive result.
    // If you subtract a positive number from a negative number, you expect a negative result.
    // Overflow if inputs vary in sign and the output does not have the same sign as the first input.
    //
    if (((a < 0) != (b < 0)) && ((a < 0) != (c < 0)))
    {
        c = INT64_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }
    *pc = c;
    return status;
}

__inline
NTSTATUS
RtlInt8Mult(
    __in INT8 a,
    __in INT8 b,
    __out INT8* pc
    )
{
    C_ASSERT(sizeof(long) > sizeof(INT8));
    return RtlLongToInt8((((long)a) * ((long)b)), pc);
}

__inline
NTSTATUS
RtlShortMult(
    __in short a,
    __in short b,
    __out short* pc
    )
{
    C_ASSERT(sizeof(long) > sizeof(short));
    return RtlLongToShort((((long)a) * ((long)b)), pc);
}

__inline
NTSTATUS
RtlIntMult(
    __in int a,
    __in int b,
    __out int* pc
    )
{
    C_ASSERT(sizeof(__int64) > sizeof(int));
    return RtlInt64ToInt((((__int64)a) * ((__int64)b)), pc);
}

__inline
NTSTATUS
RtlLongMult(
    __in long a,
    __in long b,
    __out long* pc
    )
{
    C_ASSERT(sizeof(int) == sizeof(long));
    C_ASSERT(INT_ERROR == LONG_ERROR);
    return RtlIntMult((int)a, (int)b, (int*)pc);
}

__inline
NTSTATUS
RtlInt64Mult(
    __in __int64 a,
    __in __int64 b,
    __out __int64* pc
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    __int64 c;

#if defined(_USE_INTRINSIC_MULTIPLY128)

    __int64 c_high;
    
    c = Multiply128(a, b, &c_high);
    if (   ((c < 0) && (c_high != -1))
        || ((c >= 0) && (c_high != 0)))
    {
        c = INT64_ERROR;
        status = STATUS_INTEGER_OVERFLOW;
    }

#else // _USE_INTRINSIC_MULTIPLY128

    //
    // Split into sign and magnitude, do unsigned operation, apply sign.
    //
    unsigned __int64 ua;
    unsigned __int64 ub;
    unsigned __int64 uc;
    const unsigned sign_a = (a < 0);
    const unsigned sign_b = (b < 0);
    const unsigned __int64 INT64_MIN_MAGNITUDE = ((((unsigned __int64) - (INT64_MIN + 1))) + 1);

    if (sign_a)
    {
        //
        // Avoid negating the most negative number.
        //
        ua = (((unsigned __int64) - (a + 1)) + 1);
    }
    else
    {
        ua = (unsigned __int64) a;
    }

    if (sign_b)
    {
        ub = (((unsigned __int64) - (b + 1)) + 1);
    }
    else
    {
        ub = (unsigned __int64) b;
    }

    status = RtlUInt64Mult(ua, ub, &uc);
    if (NT_SUCCESS(status))
    {
        if (sign_a != sign_b)
        {
            if (uc > INT64_MIN_MAGNITUDE)
            {
                c = INT64_ERROR;
                status = STATUS_INTEGER_OVERFLOW;
            }
            else
            {
                c = - (__int64) uc;
            }
        }
        else
        {
            if (uc > INT64_MAX)
            {
                c = INT64_ERROR;
                status = STATUS_INTEGER_OVERFLOW;
            }
            else
            {
                c = (__int64) uc;
            }
        }
    }
    else
    {
        c = INT64_ERROR;
    }

#endif // _USE_INTRINSIC_MULTIPLY128
    
    *pc = c;
    return status;
}

#define RtlInt16Add RtlShortAdd
#define RtlInt16Sub RtlShortSub
#define RtlInt16Mult RtlShortMult

#define RtlInt32Add RtlIntAdd
#define RtlInt32Sub RtlIntSub
#define RtlInt32Mult RtlIntMult

//
// LONG32 is surprisingly int where long would be expected, see basetsd.h.
//
#define RtlLong32Add RtlIntAdd
#define RtlLong32Sub RtlIntSub
#define RtlLong32Mult RtlIntMult

#define RtlLong64Add RtlInt64Add
#define RtlLong64Sub RtlInt64Sub
#define RtlLong64Mult RtlInt64Mult

#define RtlLongLongAdd RtlInt64Add
#define RtlLongLongSub RtlInt64Sub
#define RtlLongLongMult RtlInt64Mult

#if defined(_WIN64)
#define RtlIntPtrAdd RtlInt64Add
#define RtlIntPtrSub RtlInt64Sub
#define RtlIntPtrMult RtlInt64Mult
#define RtlLongPtrAdd RtlInt64Add
#define RtlLongPtrSub RtlInt64Sub
#define RtlLongPtrMult RtlInt64Mult
#else
#define RtlIntPtrAdd RtlIntAdd
#define RtlIntPtrSub RtlIntSub
#define RtlIntPtrMult RtlIntMult
#define RtlLongPtrAdd RtlLongAdd
#define RtlLongPtrSub RtlLongSub
#define RtlLongPtrMult RtlLongMult
#endif

#define RtlPtrdiffTAdd RtlIntPtrAdd
#define RtlPtrdiffTSub RtlIntPtrSub
#define RtlPtrdiffTMult RtlIntPtrMult

#define RtlSSIZETAdd RtlLongPtrAdd
#define RtlSSIZETSub RtlLongPtrSub
#define RtlSSIZETMult RtlLongPtrMult

#endif // ENABLE_INTSAFE_SIGNED_FUNCTIONS

//
// Macros that are no longer used in this header but which clients may
// depend on being defined here.
//
#define LOWORD(_dw)     ((WORD)(((DWORD_PTR)(_dw)) & 0xffff))
#define HIWORD(_dw)     ((WORD)((((DWORD_PTR)(_dw)) >> 16) & 0xffff))
#define LODWORD(_qw)    ((DWORD)(_qw))
#define HIDWORD(_qw)    ((DWORD)(((_qw) >> 32) & 0xffffffff))

#endif // _NTINTSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntimage.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntimage.h

Abstract:

    This is the include file that describes all image structures.

--*/

#ifndef _NTIMAGE_
#define _NTIMAGE_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4201) /* nonstandard extension used : nameless struct/union */
#pragma warning (disable:4214) /* nonstandard extension used : bit field types other then int */

//
// Define the linker version number.  This is temporary to aid
// in debugging with people trying to load images built with
// an older linker.  This is not required in the final product.
//

#define IMAGE_MAJOR_LINKER_VERSION 2

// begin_winnt


//
// Image Format
//


#ifndef _MAC

#include "pshpack4.h"                   // 4 byte packing is the default

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_VXD_SIGNATURE                 0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00

#include "pshpack2.h"                   // 16 bit headers are 2 byte packed

#else

#include "pshpack1.h"

#define IMAGE_DOS_SIGNATURE                 0x4D5A      // MZ
#define IMAGE_OS2_SIGNATURE                 0x4E45      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x4C45      // LE
#define IMAGE_NT_SIGNATURE                  0x50450000  // PE00
#endif

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    USHORT e_magic;                     // Magic number
    USHORT e_cblp;                      // Bytes on last page of file
    USHORT e_cp;                        // Pages in file
    USHORT e_crlc;                      // Relocations
    USHORT e_cparhdr;                   // Size of header in paragraphs
    USHORT e_minalloc;                  // Minimum extra paragraphs needed
    USHORT e_maxalloc;                  // Maximum extra paragraphs needed
    USHORT e_ss;                        // Initial (relative) SS value
    USHORT e_sp;                        // Initial SP value
    USHORT e_csum;                      // Checksum
    USHORT e_ip;                        // Initial IP value
    USHORT e_cs;                        // Initial (relative) CS value
    USHORT e_lfarlc;                    // File address of relocation table
    USHORT e_ovno;                      // Overlay number
    USHORT e_res[4];                    // Reserved words
    USHORT e_oemid;                     // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;                   // OEM information; e_oemid specific
    USHORT e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    USHORT ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    USHORT ne_enttab;                   // Offset of Entry Table
    USHORT ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    USHORT ne_flags;                    // Flag word
    USHORT ne_autodata;                 // Automatic data segment number
    USHORT ne_heap;                     // Initial heap allocation
    USHORT ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    USHORT ne_cseg;                     // Count of file segments
    USHORT ne_cmod;                     // Entries in Module Reference Table
    USHORT ne_cbnrestab;                // Size of non-resident name table
    USHORT ne_segtab;                   // Offset of Segment Table
    USHORT ne_rsrctab;                  // Offset of Resource Table
    USHORT ne_restab;                   // Offset of resident name table
    USHORT ne_modtab;                   // Offset of Module Reference Table
    USHORT ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    USHORT ne_cmovent;                  // Count of movable entries
    USHORT ne_align;                    // Segment alignment shift count
    USHORT ne_cres;                     // Count of resource segments
    UCHAR  ne_exetyp;                   // Target Operating system
    UCHAR  ne_flagsothers;              // Other .EXE flags
    USHORT ne_pretthunks;               // offset to return thunks
    USHORT ne_psegrefbytes;             // offset to segment ref. bytes
    USHORT ne_swaparea;                 // Minimum code swap area size
    USHORT ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {      // Windows VXD header
    USHORT e32_magic;                   // Magic number
    UCHAR  e32_border;                  // The byte ordering for the VXD
    UCHAR  e32_worder;                  // The word ordering for the VXD
    ULONG  e32_level;                   // The EXE format level for now = 0
    USHORT e32_cpu;                     // The CPU type
    USHORT e32_os;                      // The OS type
    ULONG  e32_ver;                     // Module version
    ULONG  e32_mflags;                  // Module flags
    ULONG  e32_mpages;                  // Module # pages
    ULONG  e32_startobj;                // Object # for instruction pointer
    ULONG  e32_eip;                     // Extended instruction pointer
    ULONG  e32_stackobj;                // Object # for stack pointer
    ULONG  e32_esp;                     // Extended stack pointer
    ULONG  e32_pagesize;                // VXD page size
    ULONG  e32_lastpagesize;            // Last page size in VXD
    ULONG  e32_fixupsize;               // Fixup section size
    ULONG  e32_fixupsum;                // Fixup section checksum
    ULONG  e32_ldrsize;                 // Loader section size
    ULONG  e32_ldrsum;                  // Loader section checksum
    ULONG  e32_objtab;                  // Object table offset
    ULONG  e32_objcnt;                  // Number of objects in module
    ULONG  e32_objmap;                  // Object page map offset
    ULONG  e32_itermap;                 // Object iterated data map offset
    ULONG  e32_rsrctab;                 // Offset of Resource Table
    ULONG  e32_rsrccnt;                 // Number of resource entries
    ULONG  e32_restab;                  // Offset of resident name table
    ULONG  e32_enttab;                  // Offset of Entry Table
    ULONG  e32_dirtab;                  // Offset of Module Directive Table
    ULONG  e32_dircnt;                  // Number of module directives
    ULONG  e32_fpagetab;                // Offset of Fixup Page Table
    ULONG  e32_frectab;                 // Offset of Fixup Record Table
    ULONG  e32_impmod;                  // Offset of Import Module Name Table
    ULONG  e32_impmodcnt;               // Number of entries in Import Module Name Table
    ULONG  e32_impproc;                 // Offset of Import Procedure Name Table
    ULONG  e32_pagesum;                 // Offset of Per-Page Checksum Table
    ULONG  e32_datapage;                // Offset of Enumerated Data Pages
    ULONG  e32_preload;                 // Number of preload pages
    ULONG  e32_nrestab;                 // Offset of Non-resident Names Table
    ULONG  e32_cbnrestab;               // Size of Non-resident Name Table
    ULONG  e32_nressum;                 // Non-resident Name Table Checksum
    ULONG  e32_autodata;                // Object # for automatic data object
    ULONG  e32_debuginfo;               // Offset of the debugging information
    ULONG  e32_debuglen;                // The length of the debugging info. in bytes
    ULONG  e32_instpreload;             // Number of instance pages in preload section of VXD file
    ULONG  e32_instdemand;              // Number of instance pages in demand load section of VXD file
    ULONG  e32_heapsize;                // Size of heap - for 16-bit apps
    UCHAR  e32_res3[12];                // Reserved words
    ULONG  e32_winresoff;
    ULONG  e32_winreslen;
    USHORT e32_devid;                   // Device ID for VxD
    USHORT e32_ddkver;                  // DDK version for VxD
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;

#ifndef _MAC
#include "poppack.h"                    // Back to 4 byte packing
#endif

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    USHORT  Machine;
    USHORT  NumberOfSections;
    ULONG   TimeDateStamp;
    ULONG   PointerToSymbolTable;
    ULONG   NumberOfSymbols;
    USHORT  SizeOfOptionalHeader;
    USHORT  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Agressively trim working set
#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle >2gb addresses
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.
#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x014c  // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x0162  // MIPS little-endian, 0x160 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x0166  // MIPS little-endian
#define IMAGE_FILE_MACHINE_R10000            0x0168  // MIPS little-endian
#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  // MIPS little-endian WCE v2
#define IMAGE_FILE_MACHINE_ALPHA             0x0184  // Alpha_AXP
#define IMAGE_FILE_MACHINE_SH3               0x01a2  // SH3 little-endian
#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3
#define IMAGE_FILE_MACHINE_SH3E              0x01a4  // SH3E little-endian
#define IMAGE_FILE_MACHINE_SH4               0x01a6  // SH4 little-endian
#define IMAGE_FILE_MACHINE_SH5               0x01a8  // SH5
#define IMAGE_FILE_MACHINE_ARM               0x01c0  // ARM Little-Endian
#define IMAGE_FILE_MACHINE_THUMB             0x01c2
#define IMAGE_FILE_MACHINE_AM33              0x01d3
#define IMAGE_FILE_MACHINE_POWERPC           0x01F0  // IBM PowerPC Little-Endian
#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1
#define IMAGE_FILE_MACHINE_IA64              0x0200  // Intel 64
#define IMAGE_FILE_MACHINE_MIPS16            0x0266  // MIPS
#define IMAGE_FILE_MACHINE_ALPHA64           0x0284  // ALPHA64
#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366  // MIPS
#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  // MIPS
#define IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64
#define IMAGE_FILE_MACHINE_TRICORE           0x0520  // Infineon
#define IMAGE_FILE_MACHINE_CEF               0x0CEF
#define IMAGE_FILE_MACHINE_EBC               0x0EBC  // EFI Byte Code
#define IMAGE_FILE_MACHINE_AMD64             0x8664  // AMD64 (K8)
#define IMAGE_FILE_MACHINE_M32R              0x9041  // M32R little-endian
#define IMAGE_FILE_MACHINE_CEE               0xC0EE

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    ULONG   VirtualAddress;
    ULONG   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    USHORT  Magic;
    UCHAR   MajorLinkerVersion;
    UCHAR   MinorLinkerVersion;
    ULONG   SizeOfCode;
    ULONG   SizeOfInitializedData;
    ULONG   SizeOfUninitializedData;
    ULONG   AddressOfEntryPoint;
    ULONG   BaseOfCode;
    ULONG   BaseOfData;

    //
    // NT additional fields.
    //

    ULONG   ImageBase;
    ULONG   SectionAlignment;
    ULONG   FileAlignment;
    USHORT  MajorOperatingSystemVersion;
    USHORT  MinorOperatingSystemVersion;
    USHORT  MajorImageVersion;
    USHORT  MinorImageVersion;
    USHORT  MajorSubsystemVersion;
    USHORT  MinorSubsystemVersion;
    ULONG   Win32VersionValue;
    ULONG   SizeOfImage;
    ULONG   SizeOfHeaders;
    ULONG   CheckSum;
    USHORT  Subsystem;
    USHORT  DllCharacteristics;
    ULONG   SizeOfStackReserve;
    ULONG   SizeOfStackCommit;
    ULONG   SizeOfHeapReserve;
    ULONG   SizeOfHeapCommit;
    ULONG   LoaderFlags;
    ULONG   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    USHORT Magic;
    UCHAR  MajorLinkerVersion;
    UCHAR  MinorLinkerVersion;
    ULONG  SizeOfCode;
    ULONG  SizeOfInitializedData;
    ULONG  SizeOfUninitializedData;
    ULONG  AddressOfEntryPoint;
    ULONG  BaseOfCode;
    ULONG  BaseOfData;
    ULONG  BaseOfBss;
    ULONG  GprMask;
    ULONG  CprMask[4];
    ULONG  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    USHORT      Magic;
    UCHAR       MajorLinkerVersion;
    UCHAR       MinorLinkerVersion;
    ULONG       SizeOfCode;
    ULONG       SizeOfInitializedData;
    ULONG       SizeOfUninitializedData;
    ULONG       AddressOfEntryPoint;
    ULONG       BaseOfCode;
    ULONGLONG   ImageBase;
    ULONG       SectionAlignment;
    ULONG       FileAlignment;
    USHORT      MajorOperatingSystemVersion;
    USHORT      MinorOperatingSystemVersion;
    USHORT      MajorImageVersion;
    USHORT      MinorImageVersion;
    USHORT      MajorSubsystemVersion;
    USHORT      MinorSubsystemVersion;
    ULONG       Win32VersionValue;
    ULONG       SizeOfImage;
    ULONG       SizeOfHeaders;
    ULONG       CheckSum;
    USHORT      Subsystem;
    USHORT      DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    ULONG       LoaderFlags;
    ULONG       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

#ifdef _WIN64
typedef IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;
#define IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR64_MAGIC
#else
typedef IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;
#define IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR32_MAGIC
#endif

typedef struct _IMAGE_NT_HEADERS64 {
    ULONG Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    ULONG Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#ifdef _WIN64
typedef IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64                 PIMAGE_NT_HEADERS;
#else
typedef IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS32                 PIMAGE_NT_HEADERS;
#endif

// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is the same either way.

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
// end_winnt
// reserved                                  4   // Old Windows CE subsystem.
// begin_winnt
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image runs in the Posix character subsystem.
#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   // image is a native Win9x driver.
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       9   // Image runs in the Windows CE subsystem.
#define IMAGE_SUBSYSTEM_EFI_APPLICATION      10  //
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  11   //
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER   12  //
#define IMAGE_SUBSYSTEM_EFI_ROM              13
#define IMAGE_SUBSYSTEM_XBOX                 14
#define IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16

// DllCharacteristics Entries

//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.
//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.
//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.
//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040     // DLL can move.
#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY    0x0080     // Code Integrity Image
#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT    0x0100     // Image is NX compatible
#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200     // Image understands isolation and doesn't want it
#define IMAGE_DLLCHARACTERISTICS_NO_SEH       0x0400     // Image does not use SEH.  No SE handler may reside in this image
#define IMAGE_DLLCHARACTERISTICS_NO_BIND      0x0800     // Do not bind this image.
//                                            0x1000     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER   0x2000     // Driver uses WDM model
//                                            0x4000     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE     0x8000
// end_winnt
#define IMAGE_DLLCHARACTERISTICS_BROWSERHOSTED   0x1000 // Image is a browser hosted windows client executable
#define IMAGE_DLLCHARACTERISTICS_X86_THUNK   0x1000 // Image is a Wx86 Thunk DLL
// Note: The Borland linker sets IMAGE_LIBRARY_xxx flags in DllCharacteristics

// LoaderFlags Values

#define IMAGE_LOADER_FLAGS_COMPLUS             0x00000001   // COM+ image
#define IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL       0x01000000   // Global subsections apply across TS sessions.

// begin_winnt

// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor

//
// Non-COFF Object file header
//

typedef struct ANON_OBJECT_HEADER {
    USHORT  Sig1;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    USHORT  Sig2;            // Must be 0xffff
    USHORT  Version;         // >= 1 (implies the CLSID field is present)
    USHORT  Machine;
    ULONG   TimeDateStamp;
    CLSID   ClassID;         // Used to invoke CoCreateInstance
    ULONG   SizeOfData;      // Size of data that follows the header
} ANON_OBJECT_HEADER;

typedef struct ANON_OBJECT_HEADER_V2 {
    USHORT  Sig1;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    USHORT  Sig2;            // Must be 0xffff
    USHORT  Version;         // >= 2 (implies the Flags field is present - otherwise V1)
    USHORT  Machine;
    ULONG   TimeDateStamp;
    CLSID   ClassID;         // Used to invoke CoCreateInstance
    ULONG   SizeOfData;      // Size of data that follows the header
    ULONG   Flags;           // 0x1 -> contains metadata
    ULONG   MetaDataSize;    // Size of CLR metadata
    ULONG   MetaDataOffset;  // Offset of CLR metadata
} ANON_OBJECT_HEADER_V2;
//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UCHAR   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            ULONG   PhysicalAddress;
            ULONG   VirtualSize;
    } Misc;
    ULONG   VirtualAddress;
    ULONG   SizeOfRawData;
    ULONG   PointerToRawData;
    ULONG   PointerToRelocations;
    ULONG   PointerToLinenumbers;
    USHORT  NumberOfRelocations;
    USHORT  NumberOfLinenumbers;
    ULONG   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
//                                           0x00002000  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
#define IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  // Reset speculative exceptions handling bits in the TLB entries for this section.
#define IMAGE_SCN_GPREL                      0x00008000  // Section content can be accessed relative to GP
#define IMAGE_SCN_MEM_FARDATA                0x00008000
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000
#define IMAGE_SCN_MEM_16BIT                  0x00020000
#define IMAGE_SCN_MEM_LOCKED                 0x00040000
#define IMAGE_SCN_MEM_PRELOAD                0x00080000

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
#define IMAGE_SCN_ALIGN_128BYTES             0x00800000  //
#define IMAGE_SCN_ALIGN_256BYTES             0x00900000  //
#define IMAGE_SCN_ALIGN_512BYTES             0x00A00000  //
#define IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  //
#define IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  //
#define IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  //
#define IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  //
// Unused                                    0x00F00000
#define IMAGE_SCN_ALIGN_MASK                 0x00F00000

#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

//
// TLS Chaacteristic Flags
//
#define IMAGE_SCN_SCALE_INDEX                0x00000001  // Tls index is scaled

#ifndef _MAC
#include "pshpack2.h"                       // Symbols, relocs, and linenumbers are 2 byte packed
#endif

//
// Symbol format.
//

typedef struct _IMAGE_SYMBOL {
    union {
        UCHAR   ShortName[8];
        struct {
            ULONG   Short;     // if 0, use LongName
            ULONG   Long;      // offset into string table
        } Name;
        ULONG   LongName[2];    // PUCHAR[2]
    } N;
    ULONG   Value;
    SHORT   SectionNumber;
    USHORT  Type;
    UCHAR   StorageClass;
    UCHAR   NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL UNALIGNED *PIMAGE_SYMBOL;


#define IMAGE_SIZEOF_SYMBOL                  18

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED           (SHORT)0          // Symbol is undefined or is common.
#define IMAGE_SYM_ABSOLUTE            (SHORT)-1         // Symbol is an absolute value.
#define IMAGE_SYM_DEBUG               (SHORT)-2         // Symbol is a special debug item.
#define IMAGE_SYM_SECTION_MAX         0xFEFF            // Values 0xFF00-0xFFFF are special

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL                 0x0000  // no type.
#define IMAGE_SYM_TYPE_VOID                 0x0001  //
#define IMAGE_SYM_TYPE_CHAR                 0x0002  // type character.
#define IMAGE_SYM_TYPE_SHORT                0x0003  // type short integer.
#define IMAGE_SYM_TYPE_INT                  0x0004  //
#define IMAGE_SYM_TYPE_LONG                 0x0005  //
#define IMAGE_SYM_TYPE_FLOAT                0x0006  //
#define IMAGE_SYM_TYPE_DOUBLE               0x0007  //
#define IMAGE_SYM_TYPE_STRUCT               0x0008  //
#define IMAGE_SYM_TYPE_UNION                0x0009  //
#define IMAGE_SYM_TYPE_ENUM                 0x000A  // enumeration.
#define IMAGE_SYM_TYPE_MOE                  0x000B  // member of enumeration.
#define IMAGE_SYM_TYPE_UCHAR                0x000C  //
#define IMAGE_SYM_TYPE_USHORT               0x000D  //
#define IMAGE_SYM_TYPE_UINT                 0x000E  //
#define IMAGE_SYM_TYPE_ULONG                0x000F  //
#define IMAGE_SYM_TYPE_PCODE                0x8000  //
//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL                0       // no derived type.
#define IMAGE_SYM_DTYPE_POINTER             1       // pointer.
#define IMAGE_SYM_DTYPE_FUNCTION            2       // function.
#define IMAGE_SYM_DTYPE_ARRAY               3       // array.

//
// Storage classes.
//
#define IMAGE_SYM_CLASS_END_OF_FUNCTION     (UCHAR)-1
#define IMAGE_SYM_CLASS_NULL                0x0000
#define IMAGE_SYM_CLASS_AUTOMATIC           0x0001
#define IMAGE_SYM_CLASS_EXTERNAL            0x0002
#define IMAGE_SYM_CLASS_STATIC              0x0003
#define IMAGE_SYM_CLASS_REGISTER            0x0004
#define IMAGE_SYM_CLASS_EXTERNAL_DEF        0x0005
#define IMAGE_SYM_CLASS_LABEL               0x0006
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL     0x0007
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    0x0008
#define IMAGE_SYM_CLASS_ARGUMENT            0x0009
#define IMAGE_SYM_CLASS_STRUCT_TAG          0x000A
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION     0x000B
#define IMAGE_SYM_CLASS_UNION_TAG           0x000C
#define IMAGE_SYM_CLASS_TYPE_DEFINITION     0x000D
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC    0x000E
#define IMAGE_SYM_CLASS_ENUM_TAG            0x000F
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM      0x0010
#define IMAGE_SYM_CLASS_REGISTER_PARAM      0x0011
#define IMAGE_SYM_CLASS_BIT_FIELD           0x0012

#define IMAGE_SYM_CLASS_FAR_EXTERNAL        0x0044  //

#define IMAGE_SYM_CLASS_BLOCK               0x0064
#define IMAGE_SYM_CLASS_FUNCTION            0x0065
#define IMAGE_SYM_CLASS_END_OF_STRUCT       0x0066
#define IMAGE_SYM_CLASS_FILE                0x0067
// new
#define IMAGE_SYM_CLASS_SECTION             0x0068
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL       0x0069

#define IMAGE_SYM_CLASS_CLR_TOKEN           0x006B

// type packing constants

#define N_BTMASK                            0x000F
#define N_TMASK                             0x0030
#define N_TMASK1                            0x00C0
#define N_TMASK2                            0x00F0
#define N_BTSHFT                            4
#define N_TSHIFT                            2
// MACROS

// Basic Type of  x
#define BTYPE(x) ((x) & N_BTMASK)

// Is x a pointer?
#ifndef ISPTR
#define ISPTR(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
#endif

// Is x a function?
#ifndef ISFCN
#define ISFCN(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
#endif

// Is x an array?

#ifndef ISARY
#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
#endif

// Is x a structure, union, or enumeration TAG?
#ifndef ISTAG
#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
#endif

#ifndef INCREF
#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
#endif
#ifndef DECREF
#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
#endif

//
// Auxiliary entry format.
//

typedef union _IMAGE_AUX_SYMBOL {
    struct {
        ULONG    TagIndex;                      // struct, union, or enum tag index
        union {
            struct {
                USHORT  Linenumber;             // declaration line number
                USHORT  Size;                   // size of struct, union, or enum
            } LnSz;
           ULONG    TotalSize;
        } Misc;
        union {
            struct {                            // if ISFCN, tag, or .bb
                ULONG    PointerToLinenumber;
                ULONG    PointerToNextFunction;
            } Function;
            struct {                            // if ISARY, up to 4 dimen.
                USHORT   Dimension[4];
            } Array;
        } FcnAry;
        USHORT  TvIndex;                        // tv index
    } Sym;
    struct {
        UCHAR   Name[IMAGE_SIZEOF_SYMBOL];
    } File;
    struct {
        ULONG   Length;                         // section length
        USHORT  NumberOfRelocations;            // number of relocation entries
        USHORT  NumberOfLinenumbers;            // number of line numbers
        ULONG   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        UCHAR   Selection;                      // communal selection type
    } Section;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL UNALIGNED *PIMAGE_AUX_SYMBOL;

typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;

#include <pshpack2.h>

typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    UCHAR bAuxType;                  // IMAGE_AUX_SYMBOL_TYPE
    UCHAR bReserved;                 // Must be 0
    ULONG SymbolTableIndex;
    UCHAR rgbReserved[12];           // Must be 0
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF UNALIGNED *PIMAGE_AUX_SYMBOL_TOKEN_DEF;

#include <poppack.h>

//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_NODUPLICATES    1
#define IMAGE_COMDAT_SELECT_ANY             2
#define IMAGE_COMDAT_SELECT_SAME_SIZE       3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH     4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE     5
#define IMAGE_COMDAT_SELECT_LARGEST         6
#define IMAGE_COMDAT_SELECT_NEWEST          7

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS      3

//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    union {
        ULONG   VirtualAddress;
        ULONG   RelocCount;             // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
    } DUMMYUNIONNAME;
    ULONG   SymbolTableIndex;
    USHORT  Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION;

//
// I386 relocation types.
//
#define IMAGE_REL_I386_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16            0x0001  // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16            0x0002  // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32            0x0006  // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB          0x0007  // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12            0x0009  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION          0x000A
#define IMAGE_REL_I386_SECREL           0x000B
#define IMAGE_REL_I386_TOKEN            0x000C  // clr token
#define IMAGE_REL_I386_SECREL7          0x000D  // 7 bit offset from base of section containing target
#define IMAGE_REL_I386_REL32            0x0014  // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//
#define IMAGE_REL_MIPS_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_MIPS_REFHALF          0x0001
#define IMAGE_REL_MIPS_REFWORD          0x0002
#define IMAGE_REL_MIPS_JMPADDR          0x0003
#define IMAGE_REL_MIPS_REFHI            0x0004
#define IMAGE_REL_MIPS_REFLO            0x0005
#define IMAGE_REL_MIPS_GPREL            0x0006
#define IMAGE_REL_MIPS_LITERAL          0x0007
#define IMAGE_REL_MIPS_SECTION          0x000A
#define IMAGE_REL_MIPS_SECREL           0x000B
#define IMAGE_REL_MIPS_SECRELLO         0x000C  // Low 16-bit section relative referemce (used for >32k TLS)
#define IMAGE_REL_MIPS_SECRELHI         0x000D  // High 16-bit section relative reference (used for >32k TLS)
#define IMAGE_REL_MIPS_TOKEN            0x000E  // clr token
#define IMAGE_REL_MIPS_JMPADDR16        0x0010
#define IMAGE_REL_MIPS_REFWORDNB        0x0022
#define IMAGE_REL_MIPS_PAIR             0x0025

//
// Alpha Relocation types.
//
#define IMAGE_REL_ALPHA_ABSOLUTE        0x0000
#define IMAGE_REL_ALPHA_REFLONG         0x0001
#define IMAGE_REL_ALPHA_REFQUAD         0x0002
#define IMAGE_REL_ALPHA_GPREL32         0x0003
#define IMAGE_REL_ALPHA_LITERAL         0x0004
#define IMAGE_REL_ALPHA_LITUSE          0x0005
#define IMAGE_REL_ALPHA_GPDISP          0x0006
#define IMAGE_REL_ALPHA_BRADDR          0x0007
#define IMAGE_REL_ALPHA_HINT            0x0008
#define IMAGE_REL_ALPHA_INLINE_REFLONG  0x0009
#define IMAGE_REL_ALPHA_REFHI           0x000A
#define IMAGE_REL_ALPHA_REFLO           0x000B
#define IMAGE_REL_ALPHA_PAIR            0x000C
#define IMAGE_REL_ALPHA_MATCH           0x000D
#define IMAGE_REL_ALPHA_SECTION         0x000E
#define IMAGE_REL_ALPHA_SECREL          0x000F
#define IMAGE_REL_ALPHA_REFLONGNB       0x0010
#define IMAGE_REL_ALPHA_SECRELLO        0x0011  // Low 16-bit section relative reference
#define IMAGE_REL_ALPHA_SECRELHI        0x0012  // High 16-bit section relative reference
#define IMAGE_REL_ALPHA_REFQ3           0x0013  // High 16 bits of 48 bit reference
#define IMAGE_REL_ALPHA_REFQ2           0x0014  // Middle 16 bits of 48 bit reference
#define IMAGE_REL_ALPHA_REFQ1           0x0015  // Low 16 bits of 48 bit reference
#define IMAGE_REL_ALPHA_GPRELLO         0x0016  // Low 16-bit GP relative reference
#define IMAGE_REL_ALPHA_GPRELHI         0x0017  // High 16-bit GP relative reference

//
// IBM PowerPC relocation types.
//
#define IMAGE_REL_PPC_ABSOLUTE          0x0000  // NOP
#define IMAGE_REL_PPC_ADDR64            0x0001  // 64-bit address
#define IMAGE_REL_PPC_ADDR32            0x0002  // 32-bit address
#define IMAGE_REL_PPC_ADDR24            0x0003  // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_PPC_ADDR16            0x0004  // 16-bit address
#define IMAGE_REL_PPC_ADDR14            0x0005  // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_PPC_REL24             0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_PPC_REL14             0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_PPC_TOCREL16          0x0008  // 16-bit offset from TOC base
#define IMAGE_REL_PPC_TOCREL14          0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)

#define IMAGE_REL_PPC_ADDR32NB          0x000A  // 32-bit addr w/o image base
#define IMAGE_REL_PPC_SECREL            0x000B  // va of containing section (as in an image sectionhdr)
#define IMAGE_REL_PPC_SECTION           0x000C  // sectionheader number
#define IMAGE_REL_PPC_IFGLUE            0x000D  // substitute TOC restore instruction iff symbol is glue code
#define IMAGE_REL_PPC_IMGLUE            0x000E  // symbol is glue code; virtual address is TOC restore instruction
#define IMAGE_REL_PPC_SECREL16          0x000F  // va of containing section (limited to 16 bits)
#define IMAGE_REL_PPC_REFHI             0x0010
#define IMAGE_REL_PPC_REFLO             0x0011
#define IMAGE_REL_PPC_PAIR              0x0012
#define IMAGE_REL_PPC_SECRELLO          0x0013  // Low 16-bit section relative reference (used for >32k TLS)
#define IMAGE_REL_PPC_SECRELHI          0x0014  // High 16-bit section relative reference (used for >32k TLS)
#define IMAGE_REL_PPC_GPREL             0x0015
#define IMAGE_REL_PPC_TOKEN             0x0016  // clr token

#define IMAGE_REL_PPC_TYPEMASK          0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

#define IMAGE_REL_PPC_NEG               0x0100  // subtract reloc value rather than adding it
#define IMAGE_REL_PPC_BRTAKEN           0x0200  // fix branch prediction bit to predict branch taken
#define IMAGE_REL_PPC_BRNTAKEN          0x0400  // fix branch prediction bit to predict branch not taken
#define IMAGE_REL_PPC_TOCDEFN           0x0800  // toc slot defined in file (or, data in toc)

//
// Hitachi SH3 relocation types.
//
#define IMAGE_REL_SH3_ABSOLUTE          0x0000  // No relocation
#define IMAGE_REL_SH3_DIRECT16          0x0001  // 16 bit direct
#define IMAGE_REL_SH3_DIRECT32          0x0002  // 32 bit direct
#define IMAGE_REL_SH3_DIRECT8           0x0003  // 8 bit direct, -128..255
#define IMAGE_REL_SH3_DIRECT8_WORD      0x0004  // 8 bit direct .W (0 ext.)
#define IMAGE_REL_SH3_DIRECT8_LONG      0x0005  // 8 bit direct .L (0 ext.)
#define IMAGE_REL_SH3_DIRECT4           0x0006  // 4 bit direct (0 ext.)
#define IMAGE_REL_SH3_DIRECT4_WORD      0x0007  // 4 bit direct .W (0 ext.)
#define IMAGE_REL_SH3_DIRECT4_LONG      0x0008  // 4 bit direct .L (0 ext.)
#define IMAGE_REL_SH3_PCREL8_WORD       0x0009  // 8 bit PC relative .W
#define IMAGE_REL_SH3_PCREL8_LONG       0x000A  // 8 bit PC relative .L
#define IMAGE_REL_SH3_PCREL12_WORD      0x000B  // 12 LSB PC relative .W
#define IMAGE_REL_SH3_STARTOF_SECTION   0x000C  // Start of EXE section
#define IMAGE_REL_SH3_SIZEOF_SECTION    0x000D  // Size of EXE section
#define IMAGE_REL_SH3_SECTION           0x000E  // Section table index
#define IMAGE_REL_SH3_SECREL            0x000F  // Offset within section
#define IMAGE_REL_SH3_DIRECT32_NB       0x0010  // 32 bit direct not based
#define IMAGE_REL_SH3_GPREL4_LONG       0x0011  // GP-relative addressing
#define IMAGE_REL_SH3_TOKEN             0x0012  // clr token
#define IMAGE_REL_SHM_PCRELPT           0x0013  // Offset from current
                                                //  instruction in longwords
                                                //  if not NOMODE, insert the
                                                //  inverse of the low bit at
                                                //  bit 32 to select PTA/PTB
#define IMAGE_REL_SHM_REFLO             0x0014  // Low bits of 32-bit address
#define IMAGE_REL_SHM_REFHALF           0x0015  // High bits of 32-bit address
#define IMAGE_REL_SHM_RELLO             0x0016  // Low bits of relative reference
#define IMAGE_REL_SHM_RELHALF           0x0017  // High bits of relative reference
#define IMAGE_REL_SHM_PAIR              0x0018  // offset operand for relocation

#define IMAGE_REL_SH_NOMODE             0x8000  // relocation ignores section mode


#define IMAGE_REL_ARM_ABSOLUTE          0x0000  // No relocation required
#define IMAGE_REL_ARM_ADDR32            0x0001  // 32 bit address
#define IMAGE_REL_ARM_ADDR32NB          0x0002  // 32 bit address w/o image base
#define IMAGE_REL_ARM_BRANCH24          0x0003  // 24 bit offset << 2 & sign ext.
#define IMAGE_REL_ARM_BRANCH11          0x0004  // Thumb: 2 11 bit offsets
#define IMAGE_REL_ARM_TOKEN             0x0005  // clr token
#define IMAGE_REL_ARM_GPREL12           0x0006  // GP-relative addressing (ARM)
#define IMAGE_REL_ARM_GPREL7            0x0007  // GP-relative addressing (Thumb)
#define IMAGE_REL_ARM_BLX24             0x0008
#define IMAGE_REL_ARM_BLX11             0x0009
#define IMAGE_REL_ARM_SECTION           0x000E  // Section table index
#define IMAGE_REL_ARM_SECREL            0x000F  // Offset within section

#define IMAGE_REL_AM_ABSOLUTE           0x0000
#define IMAGE_REL_AM_ADDR32             0x0001
#define IMAGE_REL_AM_ADDR32NB           0x0002
#define IMAGE_REL_AM_CALL32             0x0003
#define IMAGE_REL_AM_FUNCINFO           0x0004
#define IMAGE_REL_AM_REL32_1            0x0005
#define IMAGE_REL_AM_REL32_2            0x0006
#define IMAGE_REL_AM_SECREL             0x0007
#define IMAGE_REL_AM_SECTION            0x0008
#define IMAGE_REL_AM_TOKEN              0x0009

//
// x64 relocations
//
#define IMAGE_REL_AMD64_ABSOLUTE        0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_AMD64_ADDR64          0x0001  // 64-bit address (VA).
#define IMAGE_REL_AMD64_ADDR32          0x0002  // 32-bit address (VA).
#define IMAGE_REL_AMD64_ADDR32NB        0x0003  // 32-bit address w/o image base (RVA).
#define IMAGE_REL_AMD64_REL32           0x0004  // 32-bit relative address from byte following reloc
#define IMAGE_REL_AMD64_REL32_1         0x0005  // 32-bit relative address from byte distance 1 from reloc
#define IMAGE_REL_AMD64_REL32_2         0x0006  // 32-bit relative address from byte distance 2 from reloc
#define IMAGE_REL_AMD64_REL32_3         0x0007  // 32-bit relative address from byte distance 3 from reloc
#define IMAGE_REL_AMD64_REL32_4         0x0008  // 32-bit relative address from byte distance 4 from reloc
#define IMAGE_REL_AMD64_REL32_5         0x0009  // 32-bit relative address from byte distance 5 from reloc
#define IMAGE_REL_AMD64_SECTION         0x000A  // Section index
#define IMAGE_REL_AMD64_SECREL          0x000B  // 32 bit offset from base of section containing target
#define IMAGE_REL_AMD64_SECREL7         0x000C  // 7 bit unsigned offset from base of section containing target
#define IMAGE_REL_AMD64_TOKEN           0x000D  // 32 bit metadata token
#define IMAGE_REL_AMD64_SREL32          0x000E  // 32 bit signed span-dependent value emitted into object
#define IMAGE_REL_AMD64_PAIR            0x000F
#define IMAGE_REL_AMD64_SSPAN32         0x0010  // 32 bit signed span-dependent value applied at link time

//
// IA64 relocation types.
//
#define IMAGE_REL_IA64_ABSOLUTE         0x0000
#define IMAGE_REL_IA64_IMM14            0x0001
#define IMAGE_REL_IA64_IMM22            0x0002
#define IMAGE_REL_IA64_IMM64            0x0003
#define IMAGE_REL_IA64_DIR32            0x0004
#define IMAGE_REL_IA64_DIR64            0x0005
#define IMAGE_REL_IA64_PCREL21B         0x0006
#define IMAGE_REL_IA64_PCREL21M         0x0007
#define IMAGE_REL_IA64_PCREL21F         0x0008
#define IMAGE_REL_IA64_GPREL22          0x0009
#define IMAGE_REL_IA64_LTOFF22          0x000A
#define IMAGE_REL_IA64_SECTION          0x000B
#define IMAGE_REL_IA64_SECREL22         0x000C
#define IMAGE_REL_IA64_SECREL64I        0x000D
#define IMAGE_REL_IA64_SECREL32         0x000E
//
#define IMAGE_REL_IA64_DIR32NB          0x0010
#define IMAGE_REL_IA64_SREL14           0x0011
#define IMAGE_REL_IA64_SREL22           0x0012
#define IMAGE_REL_IA64_SREL32           0x0013
#define IMAGE_REL_IA64_UREL32           0x0014
#define IMAGE_REL_IA64_PCREL60X         0x0015  // This is always a BRL and never converted
#define IMAGE_REL_IA64_PCREL60B         0x0016  // If possible, convert to MBB bundle with NOP.B in slot 1
#define IMAGE_REL_IA64_PCREL60F         0x0017  // If possible, convert to MFB bundle with NOP.F in slot 1
#define IMAGE_REL_IA64_PCREL60I         0x0018  // If possible, convert to MIB bundle with NOP.I in slot 1
#define IMAGE_REL_IA64_PCREL60M         0x0019  // If possible, convert to MMB bundle with NOP.M in slot 1
#define IMAGE_REL_IA64_IMMGPREL64       0x001A
#define IMAGE_REL_IA64_TOKEN            0x001B  // clr token
#define IMAGE_REL_IA64_GPREL32          0x001C
#define IMAGE_REL_IA64_ADDEND           0x001F

//
// CEF relocation types.
//
#define IMAGE_REL_CEF_ABSOLUTE          0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_CEF_ADDR32            0x0001  // 32-bit address (VA).
#define IMAGE_REL_CEF_ADDR64            0x0002  // 64-bit address (VA).
#define IMAGE_REL_CEF_ADDR32NB          0x0003  // 32-bit address w/o image base (RVA).
#define IMAGE_REL_CEF_SECTION           0x0004  // Section index
#define IMAGE_REL_CEF_SECREL            0x0005  // 32 bit offset from base of section containing target
#define IMAGE_REL_CEF_TOKEN             0x0006  // 32 bit metadata token

//
// clr relocation types.
//
#define IMAGE_REL_CEE_ABSOLUTE          0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_CEE_ADDR32            0x0001  // 32-bit address (VA).
#define IMAGE_REL_CEE_ADDR64            0x0002  // 64-bit address (VA).
#define IMAGE_REL_CEE_ADDR32NB          0x0003  // 32-bit address w/o image base (RVA).
#define IMAGE_REL_CEE_SECTION           0x0004  // Section index
#define IMAGE_REL_CEE_SECREL            0x0005  // 32 bit offset from base of section containing target
#define IMAGE_REL_CEE_TOKEN             0x0006  // 32 bit metadata token


#define IMAGE_REL_M32R_ABSOLUTE         0x0000  // No relocation required
#define IMAGE_REL_M32R_ADDR32           0x0001  // 32 bit address
#define IMAGE_REL_M32R_ADDR32NB         0x0002  // 32 bit address w/o image base
#define IMAGE_REL_M32R_ADDR24           0x0003  // 24 bit address
#define IMAGE_REL_M32R_GPREL16          0x0004  // GP relative addressing
#define IMAGE_REL_M32R_PCREL24          0x0005  // 24 bit offset << 2 & sign ext.
#define IMAGE_REL_M32R_PCREL16          0x0006  // 16 bit offset << 2 & sign ext.
#define IMAGE_REL_M32R_PCREL8           0x0007  // 8 bit offset << 2 & sign ext.
#define IMAGE_REL_M32R_REFHALF          0x0008  // 16 MSBs
#define IMAGE_REL_M32R_REFHI            0x0009  // 16 MSBs; adj for LSB sign ext.
#define IMAGE_REL_M32R_REFLO            0x000A  // 16 LSBs
#define IMAGE_REL_M32R_PAIR             0x000B  // Link HI and LO
#define IMAGE_REL_M32R_SECTION          0x000C  // Section table index
#define IMAGE_REL_M32R_SECREL32         0x000D  // 32 bit section relative reference
#define IMAGE_REL_M32R_TOKEN            0x000E  // clr token

#define IMAGE_REL_EBC_ABSOLUTE          0x0000  // No relocation required
#define IMAGE_REL_EBC_ADDR32NB          0x0001  // 32 bit address w/o image base
#define IMAGE_REL_EBC_REL32             0x0002  // 32-bit relative address from byte following reloc
#define IMAGE_REL_EBC_SECTION           0x0003  // Section table index
#define IMAGE_REL_EBC_SECREL            0x0004  // Offset within section

#define EXT_IMM64(Value, Address, Size, InstPos, ValPos)  /* Intel-IA64-Filler */           \
    Value |= (((ULONGLONG)((*(Address) >> InstPos) & (((ULONGLONG)1 << Size) - 1))) << ValPos)  // Intel-IA64-Filler

#define INS_IMM64(Value, Address, Size, InstPos, ValPos)  /* Intel-IA64-Filler */\
    *(PULONG)Address = (*(PULONG)Address & ~(((1 << Size) - 1) << InstPos)) | /* Intel-IA64-Filler */\
          ((ULONG)((((ULONGLONG)Value >> ValPos) & (((ULONGLONG)1 << Size) - 1))) << InstPos)  // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM7B_INST_WORD_X         3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM7B_SIZE_X              7  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X     4  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM7B_VAL_POS_X           0  // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM9D_INST_WORD_X         3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM9D_SIZE_X              9  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X     18 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM9D_VAL_POS_X           7  // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM5C_INST_WORD_X         3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM5C_SIZE_X              5  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X     13 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM5C_VAL_POS_X           16 // Intel-IA64-Filler

#define EMARCH_ENC_I17_IC_INST_WORD_X            3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IC_SIZE_X                 1  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IC_INST_WORD_POS_X        12 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IC_VAL_POS_X              21 // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM41a_INST_WORD_X        1  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41a_SIZE_X             10 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X    14 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41a_VAL_POS_X          22 // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM41b_INST_WORD_X        1  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41b_SIZE_X             8  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X    24 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41b_VAL_POS_X          32 // Intel-IA64-Filler

#define EMARCH_ENC_I17_IMM41c_INST_WORD_X        2  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41c_SIZE_X             23 // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X    0  // Intel-IA64-Filler
#define EMARCH_ENC_I17_IMM41c_VAL_POS_X          40 // Intel-IA64-Filler

#define EMARCH_ENC_I17_SIGN_INST_WORD_X          3  // Intel-IA64-Filler
#define EMARCH_ENC_I17_SIGN_SIZE_X               1  // Intel-IA64-Filler
#define EMARCH_ENC_I17_SIGN_INST_WORD_POS_X      27 // Intel-IA64-Filler
#define EMARCH_ENC_I17_SIGN_VAL_POS_X            63 // Intel-IA64-Filler

#define X3_OPCODE_INST_WORD_X                    3  // Intel-IA64-Filler
#define X3_OPCODE_SIZE_X                         4  // Intel-IA64-Filler
#define X3_OPCODE_INST_WORD_POS_X                28 // Intel-IA64-Filler
#define X3_OPCODE_SIGN_VAL_POS_X                 0  // Intel-IA64-Filler

#define X3_I_INST_WORD_X                         3  // Intel-IA64-Filler
#define X3_I_SIZE_X                              1  // Intel-IA64-Filler
#define X3_I_INST_WORD_POS_X                     27 // Intel-IA64-Filler
#define X3_I_SIGN_VAL_POS_X                      59 // Intel-IA64-Filler

#define X3_D_WH_INST_WORD_X                      3  // Intel-IA64-Filler
#define X3_D_WH_SIZE_X                           3  // Intel-IA64-Filler
#define X3_D_WH_INST_WORD_POS_X                  24 // Intel-IA64-Filler
#define X3_D_WH_SIGN_VAL_POS_X                   0  // Intel-IA64-Filler

#define X3_IMM20_INST_WORD_X                     3  // Intel-IA64-Filler
#define X3_IMM20_SIZE_X                          20 // Intel-IA64-Filler
#define X3_IMM20_INST_WORD_POS_X                 4  // Intel-IA64-Filler
#define X3_IMM20_SIGN_VAL_POS_X                  0  // Intel-IA64-Filler

#define X3_IMM39_1_INST_WORD_X                   2  // Intel-IA64-Filler
#define X3_IMM39_1_SIZE_X                        23 // Intel-IA64-Filler
#define X3_IMM39_1_INST_WORD_POS_X               0  // Intel-IA64-Filler
#define X3_IMM39_1_SIGN_VAL_POS_X                36 // Intel-IA64-Filler

#define X3_IMM39_2_INST_WORD_X                   1  // Intel-IA64-Filler
#define X3_IMM39_2_SIZE_X                        16 // Intel-IA64-Filler
#define X3_IMM39_2_INST_WORD_POS_X               16 // Intel-IA64-Filler
#define X3_IMM39_2_SIGN_VAL_POS_X                20 // Intel-IA64-Filler

#define X3_P_INST_WORD_X                         3  // Intel-IA64-Filler
#define X3_P_SIZE_X                              4  // Intel-IA64-Filler
#define X3_P_INST_WORD_POS_X                     0  // Intel-IA64-Filler
#define X3_P_SIGN_VAL_POS_X                      0  // Intel-IA64-Filler

#define X3_TMPLT_INST_WORD_X                     0  // Intel-IA64-Filler
#define X3_TMPLT_SIZE_X                          4  // Intel-IA64-Filler
#define X3_TMPLT_INST_WORD_POS_X                 0  // Intel-IA64-Filler
#define X3_TMPLT_SIGN_VAL_POS_X                  0  // Intel-IA64-Filler

#define X3_BTYPE_QP_INST_WORD_X                  2  // Intel-IA64-Filler
#define X3_BTYPE_QP_SIZE_X                       9  // Intel-IA64-Filler
#define X3_BTYPE_QP_INST_WORD_POS_X              23 // Intel-IA64-Filler
#define X3_BTYPE_QP_INST_VAL_POS_X               0  // Intel-IA64-Filler

#define X3_EMPTY_INST_WORD_X                     1  // Intel-IA64-Filler
#define X3_EMPTY_SIZE_X                          2  // Intel-IA64-Filler
#define X3_EMPTY_INST_WORD_POS_X                 14 // Intel-IA64-Filler
#define X3_EMPTY_INST_VAL_POS_X                  0  // Intel-IA64-Filler

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        ULONG   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
        ULONG   VirtualAddress;                 // Virtual address of line number.
    } Type;
    USHORT  Linenumber;                         // Line number.
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER UNALIGNED *PIMAGE_LINENUMBER;

#ifndef _MAC
#include "poppack.h"                        // Back to 4 byte packing
#endif

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    ULONG   VirtualAddress;
    ULONG   SizeOfBlock;
//  USHORT  TypeOffset[1];
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5
// end_winnt
#define IMAGE_REL_BASED_SECTION               6
#define IMAGE_REL_BASED_REL32                 7
//      IMAGE_REL_BASED_VXD_RELATIVE          8
// begin_winnt
#define IMAGE_REL_BASED_MIPS_JMPADDR16        9
#define IMAGE_REL_BASED_IA64_IMM64            9
#define IMAGE_REL_BASED_DIR64                 10


//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    UCHAR    Name[16];                          // File member name - `/' terminated.
    UCHAR    Date[12];                          // File member date - decimal.
    UCHAR    UserID[6];                         // File member user id - decimal.
    UCHAR    GroupID[6];                        // File member group id - decimal.
    UCHAR    Mode[8];                           // File member mode - octal.
    UCHAR    Size[10];                          // File member size - decimal.
    UCHAR    EndHeader[2];                      // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Name;
    ULONG   Base;
    ULONG   NumberOfFunctions;
    ULONG   NumberOfNames;
    ULONG   AddressOfFunctions;     // RVA from base of image
    ULONG   AddressOfNames;         // RVA from base of image
    ULONG   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    USHORT  Hint;
    UCHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

#include "pshpack8.h"                       // Use align 8 for the 64-bit IAT.

typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  // PUCHAR
        ULONGLONG Function;         // PULONG
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

#include "poppack.h"                        // Back to 4 byte packing

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        ULONG ForwarderString;      // PUCHAR
        ULONG Function;             // PULONG
        ULONG Ordinal;
        ULONG AddressOfData;        // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000
#define IMAGE_ORDINAL_FLAG32 0x80000000
#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffff)
#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)
#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)
#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)

//
// Thread Local Storage
//

typedef VOID
(NTAPI *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    ULONG Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG   StartAddressOfRawData;
    ULONGLONG   EndAddressOfRawData;
    ULONGLONG   AddressOfIndex;         // PULONG
    ULONGLONG   AddressOfCallBacks;     // PIMAGE_TLS_CALLBACK *;
    ULONG   SizeOfZeroFill;
    ULONG   Characteristics;
} IMAGE_TLS_DIRECTORY64;
typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    ULONG   StartAddressOfRawData;
    ULONG   EndAddressOfRawData;
    ULONG   AddressOfIndex;             // PULONG
    ULONG   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK *
    ULONG   SizeOfZeroFill;
    ULONG   Characteristics;
} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;

#ifdef _WIN64
#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG64
#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL64(Ordinal)
typedef IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;
#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL64(Ordinal)
typedef IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;
#else
#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG32
#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL32(Ordinal)
typedef IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;
#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL32(Ordinal)
typedef IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;
#endif

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        ULONG   Characteristics;            // 0 for terminating null import descriptor
        ULONG   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    ULONG   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    ULONG   ForwarderChain;                 // -1 if no forwarders
    ULONG   Name;
    ULONG   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;

//
// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
//

typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    ULONG   TimeDateStamp;
    USHORT  OffsetModuleName;
    USHORT  NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    ULONG   TimeDateStamp;
    USHORT  OffsetModuleName;
    USHORT  Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  NumberOfNamedEntries;
    USHORT  NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000
//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            ULONG NameOffset:31;
            ULONG NameIsString:1;
        } DUMMYSTRUCTNAME;
        ULONG   Name;
        USHORT  Id;
    } DUMMYUNIONNAME;
    union {
        ULONG   OffsetToData;
        struct {
            ULONG   OffsetToDirectory:31;
            ULONG   DataIsDirectory:1;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME2;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    USHORT  Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    USHORT  Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    ULONG   OffsetToData;
    ULONG   Size;
    ULONG   CodePage;
    ULONG   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

//
// Load Configuration Directory Entry
//

typedef struct {
    ULONG   Size;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   GlobalFlagsClear;
    ULONG   GlobalFlagsSet;
    ULONG   CriticalSectionDefaultTimeout;
    ULONG   DeCommitFreeBlockThreshold;
    ULONG   DeCommitTotalFreeThreshold;
    ULONG   LockPrefixTable;            // VA
    ULONG   MaximumAllocationSize;
    ULONG   VirtualMemoryThreshold;
    ULONG   ProcessHeapFlags;
    ULONG   ProcessAffinityMask;
    USHORT  CSDVersion;
    USHORT  Reserved1;
    ULONG   EditList;                   // VA
    ULONG   SecurityCookie;             // VA
    ULONG   SEHandlerTable;             // VA
    ULONG   SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct {
    ULONG      Size;
    ULONG      TimeDateStamp;
    USHORT     MajorVersion;
    USHORT     MinorVersion;
    ULONG      GlobalFlagsClear;
    ULONG      GlobalFlagsSet;
    ULONG      CriticalSectionDefaultTimeout;
    ULONGLONG  DeCommitFreeBlockThreshold;
    ULONGLONG  DeCommitTotalFreeThreshold;
    ULONGLONG  LockPrefixTable;         // VA
    ULONGLONG  MaximumAllocationSize;
    ULONGLONG  VirtualMemoryThreshold;
    ULONGLONG  ProcessAffinityMask;
    ULONG      ProcessHeapFlags;
    USHORT     CSDVersion;
    USHORT     Reserved1;
    ULONGLONG  EditList;                // VA
    ULONGLONG  SecurityCookie;          // VA
    ULONGLONG  SEHandlerTable;          // VA
    ULONGLONG  SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;

#ifdef _WIN64
typedef IMAGE_LOAD_CONFIG_DIRECTORY64     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64    PIMAGE_LOAD_CONFIG_DIRECTORY;
#else
typedef IMAGE_LOAD_CONFIG_DIRECTORY32     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY32    PIMAGE_LOAD_CONFIG_DIRECTORY;
#endif

//
// WIN CE Exception table format
//

//
// Function table entry format.  Function table is pointed to by the
// IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
//

typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    ULONG FuncStart;
    ULONG PrologLen : 8;
    ULONG FuncLen : 22;
    ULONG ThirtyTwoBit : 1;
    ULONG ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    ULONG BeginAddress;
    ULONG EndAddress;
    ULONG ExceptionHandler;
    ULONG HandlerData;
    ULONG PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    ULONG BeginAddress;
    ULONG EndAddress;
    ULONG UnwindInfoAddress;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;

#if defined(_AXP64_)

typedef  IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY  IMAGE_AXP64_RUNTIME_FUNCTION_ENTRY;
typedef PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY PIMAGE_AXP64_RUNTIME_FUNCTION_ENTRY;
typedef  IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#elif defined(_ALPHA_)

typedef  IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#else

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#endif

//
// Debug Format
//

typedef struct _IMAGE_DEBUG_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Type;
    ULONG   SizeOfData;
    ULONG   AddressOfRawData;
    ULONG   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

#define IMAGE_DEBUG_TYPE_UNKNOWN          0
#define IMAGE_DEBUG_TYPE_COFF             1
#define IMAGE_DEBUG_TYPE_CODEVIEW         2
#define IMAGE_DEBUG_TYPE_FPO              3
#define IMAGE_DEBUG_TYPE_MISC             4
#define IMAGE_DEBUG_TYPE_EXCEPTION        5
#define IMAGE_DEBUG_TYPE_FIXUP            6
#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC      7
#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    8
#define IMAGE_DEBUG_TYPE_BORLAND          9
#define IMAGE_DEBUG_TYPE_RESERVED10       10
#define IMAGE_DEBUG_TYPE_CLSID            11

// end_winnt

// IMAGE_DEBUG_TYPE values > 0x7FFFFFFF are reserved for BBT

// begin_winnt

typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    ULONG   NumberOfSymbols;
    ULONG   LvaToFirstSymbol;
    ULONG   NumberOfLinenumbers;
    ULONG   LvaToFirstLinenumber;
    ULONG   RvaToFirstByteOfCode;
    ULONG   RvaToLastByteOfCode;
    ULONG   RvaToFirstByteOfData;
    ULONG   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;

#define FRAME_FPO       0
#define FRAME_TRAP      1
#define FRAME_TSS       2
#define FRAME_NONFPO    3

typedef struct _FPO_DATA {
    ULONG       ulOffStart;             // offset 1st byte of function code
    ULONG       cbProcSize;             // # bytes in function
    ULONG       cdwLocals;              // # bytes in locals/4
    USHORT      cdwParams;              // # bytes in params/4
    USHORT      cbProlog : 8;           // # bytes in prolog
    USHORT      cbRegs   : 3;           // # regs saved
    USHORT      fHasSEH  : 1;           // TRUE if SEH in func
    USHORT      fUseBP   : 1;           // TRUE if EBP has been allocated
    USHORT      reserved : 1;           // reserved for future use
    USHORT      cbFrame  : 2;           // frame type
} FPO_DATA, *PFPO_DATA;
#define SIZEOF_RFPO_DATA 16


#define IMAGE_DEBUG_MISC_EXENAME    1

typedef struct _IMAGE_DEBUG_MISC {
    ULONG       DataType;               // type of misc data, see defines
    ULONG       Length;                 // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN     Unicode;                // TRUE if data is unicode string
    UCHAR       Reserved[ 3 ];
    UCHAR       Data[ 1 ];              // Actual data
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;


//
// Function table extracted from MIPS/ALPHA/IA64 images.  Does not contain
// information needed only for runtime support.  Just those fields for
// each entry needed by a debugger.
//

typedef struct _IMAGE_FUNCTION_ENTRY {
    ULONG   StartingAddress;
    ULONG   EndingAddress;
    ULONG   EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG   StartingAddress;
    ULONGLONG   EndingAddress;
    union {
        ULONGLONG   EndOfPrologue;
        ULONGLONG   UnwindInfoAddress;
    } DUMMYUNIONNAME;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;

//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    USHORT      Signature;
    USHORT      Flags;
    USHORT      Machine;
    USHORT      Characteristics;
    ULONG       TimeDateStamp;
    ULONG       CheckSum;
    ULONG       ImageBase;
    ULONG       SizeOfImage;
    ULONG       NumberOfSections;
    ULONG       ExportedNamesSize;
    ULONG       DebugDirectorySize;
    ULONG       SectionAlignment;
    ULONG       Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

typedef struct _NON_PAGED_DEBUG_INFO {
    USHORT      Signature;
    USHORT      Flags;
    ULONG       Size;
    USHORT      Machine;
    USHORT      Characteristics;
    ULONG       TimeDateStamp;
    ULONG       CheckSum;
    ULONG       SizeOfImage;
    ULONGLONG   ImageBase;
    //DebugDirectorySize
    //IMAGE_DEBUG_DIRECTORY
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;

#ifndef _MAC
#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944
#define NON_PAGED_DEBUG_SIGNATURE      0x494E
#else
#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4449  // DI
#define NON_PAGED_DEBUG_SIGNATURE      0x4E49  // NI
#endif

#define IMAGE_SEPARATE_DEBUG_FLAGS_MASK 0x8000
#define IMAGE_SEPARATE_DEBUG_MISMATCH   0x8000  // when DBG was updated, the
                                                // old checksum didn't match.

//
//  The .arch section is made up of headers, each describing an amask position/value
//  pointing to an array of IMAGE_ARCHITECTURE_ENTRY's.  Each "array" (both the header
//  and entry arrays) are terminiated by a quadword of 0xffffffffL.
//
//  NOTE: There may be quadwords of 0 sprinkled around and must be skipped.
//

typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1;                 // 1 -> code section depends on mask bit
                                                // 0 -> new instruction depends on mask bit
    int :7;                                     // MBZ
    unsigned int AmaskShift: 8;                 // Amask bit in question for this fixup
    int :16;                                    // MBZ
    ULONG FirstEntryRVA;                        // RVA into .arch section to array of ARCHITECTURE_ENTRY's
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    ULONG FixupInstRVA;                         // RVA of instruction to fixup
    ULONG NewInst;                              // fixup instruction (see alphaops.h)
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;

#include "poppack.h"                // Back to the initial value

// The following structure defines the new import object.  Note the values of the first two fields,
// which must be set as stated in order to differentiate old and new import members.
// Following this structure, the linker emits two null-terminated strings used to recreate the
// import at the time of use.  The first string is the import's name, the second is the dll's name.

#define IMPORT_OBJECT_HDR_SIG2  0xffff

typedef struct IMPORT_OBJECT_HEADER {
    USHORT  Sig1;                       // Must be IMAGE_FILE_MACHINE_UNKNOWN
    USHORT  Sig2;                       // Must be IMPORT_OBJECT_HDR_SIG2.
    USHORT  Version;
    USHORT  Machine;
    ULONG   TimeDateStamp;              // Time/date stamp
    ULONG   SizeOfData;                 // particularly useful for incremental links

    union {
        USHORT  Ordinal;                // if grf & IMPORT_OBJECT_ORDINAL
        USHORT  Hint;
    } DUMMYUNIONNAME;

    USHORT  Type : 2;                   // IMPORT_TYPE
    USHORT  NameType : 3;               // IMPORT_NAME_TYPE
    USHORT  Reserved : 11;              // Reserved. Must be zero.
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,          // Import by ordinal
    IMPORT_OBJECT_NAME = 1,             // Import name == public symbol name.
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   // Import name == public symbol name skipping leading ?, @, or optionally _.
    IMPORT_OBJECT_NAME_UNDECORATE = 3,  // Import name == public symbol name skipping leading ?, @, or optionally _
                                        // and truncating at first @
} IMPORT_OBJECT_NAME_TYPE;

// end_winnt

// The structure is used by the NT loader for clr URT support.  It
// is a duplicate of the definition in corhdr.h.

// begin_winnt

#ifndef __IMAGE_COR20_HEADER_DEFINED__
#define __IMAGE_COR20_HEADER_DEFINED__

typedef enum ReplacesCorHdrNumericDefines
{
// COM+ Header entry point flags.
    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT    =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,

// Version flags for image.
    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =0,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB                  =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,
    IMAGE_COR_MIH_BASICBLOCK            =0x08,

// V-table constants
    COR_VTABLE_32BIT                    =0x01,          // V-table slots are 32-bits in size.
    COR_VTABLE_64BIT                    =0x02,          // V-table slots are 64-bits in size.
    COR_VTABLE_FROM_UNMANAGED           =0x04,          // If set, transition from unmanaged.
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN  =0x08,  // If set, transition from unmanaged with keeping the current appdomain.
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE           =32,            // Size of a jump thunk reserved range.

// Max name lengths
    //@todo: Change to unlimited name lengths.
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;

// CLR 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    ULONG                   cb;
    USHORT                  MajorRuntimeVersion;
    USHORT                  MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;
    ULONG                   Flags;

    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint.
    union {
        ULONG               EntryPointToken;
        ULONG               EntryPointRVA;
    } DUMMYUNIONNAME;

    // Binding information
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;

} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#endif // __IMAGE_COR20_HEADER_DEFINED__

//
// End Image Format
//

// end_winnt

typedef IMAGE_OS2_HEADER UNALIGNED * PUIMAGE_OS2_HEADER;
typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED CONST *PCIMAGE_IMPORT_DESCRIPTOR;
typedef CONST IMAGE_BOUND_IMPORT_DESCRIPTOR *PCIMAGE_BOUND_IMPORT_DESCRIPTOR;
typedef CONST IMAGE_BOUND_FORWARDER_REF     *PCIMAGE_BOUND_FORWARDER_REF;
typedef CONST IMAGE_IMPORT_BY_NAME          *PCIMAGE_IMPORT_BY_NAME;
typedef CONST IMAGE_THUNK_DATA              *PCIMAGE_THUNK_DATA;
typedef CONST IMAGE_THUNK_DATA32            *PCIMAGE_THUNK_DATA32;
typedef CONST IMAGE_THUNK_DATA64            *PCIMAGE_THUNK_DATA64;
typedef CONST IMAGE_TLS_DIRECTORY           *PCIMAGE_TLS_DIRECTORY;
typedef CONST IMAGE_TLS_DIRECTORY32         *PCIMAGE_TLS_DIRECTORY32;
typedef CONST IMAGE_TLS_DIRECTORY64         *PCIMAGE_TLS_DIRECTORY64;
typedef CONST IMAGE_EXPORT_DIRECTORY        *PCIMAGE_EXPORT_DIRECTORY;
typedef CONST IMAGE_SECTION_HEADER          *PCIMAGE_SECTION_HEADER;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif // _NTIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntlmsp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       ntlmsp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//
//--------------------------------------------------------------------------

#ifndef _NTLMSP_H_
#define _NTLMSP_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntmsv1_0.h>

#ifdef __cplusplus
extern "C" {
#endif

////////////////////////////////////////////////////////////////////////
//
// Name of the package to pass in to AcquireCredentialsHandle, etc.
//
////////////////////////////////////////////////////////////////////////

#ifndef NTLMSP_NAME_A

#define NTLMSP_NAME_A            "NTLM"
#define NTLMSP_NAME              L"NTLM"        // ntifs

#endif // NTLMSP_NAME_A

#define NTLMSP_NAME_SIZE        (sizeof(NTLMSP_NAME) - sizeof(WCHAR))  // ntifs
#define NTLMSP_COMMENT_A         "NTLM Security Package"
#define NTLMSP_COMMENT           L"NTLM Security Package"
#define NTLMSP_CAPABILITIES     (SECPKG_FLAG_TOKEN_ONLY | \
                                 SECPKG_FLAG_MULTI_REQUIRED | \
                                 SECPKG_FLAG_CONNECTION | \
                                 SECPKG_FLAG_INTEGRITY | \
                                 SECPKG_FLAG_PRIVACY)

#define NTLMSP_VERSION          1
#define NTLMSP_RPCID            10  // RPC_C_AUTHN_WINNT from rpcdce.h

////////////////////////////////////////////////////////////////////////
//
// Opaque Messages passed between client and server
//
////////////////////////////////////////////////////////////////////////

// begin_ntifs

#define NTLMSSP_SIGNATURE "NTLMSSP"

//
// GetKey argument for AcquireCredentialsHandle that indicates that
// old style LM is required:
//

#define NTLMSP_NTLM_CREDENTIAL ((PVOID) 1)

//
// MessageType for the following messages.
//

typedef enum {
    NtLmNegotiate = 1,
    NtLmChallenge,
    NtLmAuthenticate,
    NtLmUnknown
} NTLM_MESSAGE_TYPE;

//
// Valid values of NegotiateFlags
//

#define NTLMSSP_NEGOTIATE_UNICODE               0x00000001  // Text strings are in unicode
#define NTLMSSP_NEGOTIATE_OEM                   0x00000002  // Text strings are in OEM
#define NTLMSSP_REQUEST_TARGET                  0x00000004  // Server should return its authentication realm

#define NTLMSSP_NEGOTIATE_SIGN                  0x00000010  // Request signature capability
#define NTLMSSP_NEGOTIATE_SEAL                  0x00000020  // Request confidentiality
#define NTLMSSP_NEGOTIATE_DATAGRAM              0x00000040  // Use datagram style authentication
#define NTLMSSP_NEGOTIATE_LM_KEY                0x00000080  // Use LM session key for sign/seal

#define NTLMSSP_NEGOTIATE_NETWARE               0x00000100  // NetWare authentication
#define NTLMSSP_NEGOTIATE_NTLM                  0x00000200  // NTLM authentication
#define NTLMSSP_NEGOTIATE_NT_ONLY               0x00000400  // NT authentication only (no LM)
#define NTLMSSP_NEGOTIATE_NULL_SESSION          0x00000800  // NULL Sessions on NT 5.0 and beyand

#define NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED       0x1000  // Domain Name supplied on negotiate
#define NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED  0x2000  // Workstation Name supplied on negotiate
#define NTLMSSP_NEGOTIATE_LOCAL_CALL            0x00004000  // Indicates client/server are same machine
#define NTLMSSP_NEGOTIATE_ALWAYS_SIGN           0x00008000  // Sign for all security levels

//
// Valid target types returned by the server in Negotiate Flags
//

#define NTLMSSP_TARGET_TYPE_DOMAIN              0x00010000  // TargetName is a domain name
#define NTLMSSP_TARGET_TYPE_SERVER              0x00020000  // TargetName is a server name
#define NTLMSSP_TARGET_TYPE_SHARE               0x00040000  // TargetName is a share name
#define NTLMSSP_NEGOTIATE_NTLM2                 0x00080000  // NTLM2 authentication added for NT4-SP4

#define NTLMSSP_NEGOTIATE_IDENTIFY              0x00100000  // Create identify level token

//
// Valid requests for additional output buffers
//

#define NTLMSSP_REQUEST_INIT_RESPONSE           0x00100000  // get back session keys
#define NTLMSSP_REQUEST_ACCEPT_RESPONSE         0x00200000  // get back session key, LUID
#define NTLMSSP_REQUEST_NON_NT_SESSION_KEY      0x00400000  // request non-nt session key
#define NTLMSSP_NEGOTIATE_TARGET_INFO           0x00800000  // target info present in challenge message

#define NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT      0x01000000  // It's an exported context
#define NTLMSSP_NEGOTIATE_VERSION               0x02000000  // version control

#define NTLMSSP_NEGOTIATE_128                   0x20000000  // negotiate 128 bit encryption
#define NTLMSSP_NEGOTIATE_KEY_EXCH              0x40000000  // exchange a key using key exchange key
#define NTLMSSP_NEGOTIATE_56                    0x80000000  // negotiate 56 bit encryption

// flags used in client space to control sign and seal; never appear on the wire
#define NTLMSSP_APP_SEQ                         0x00000040  // Use application provided seq num

// end_ntifs

//
// Opaque message returned from first call to InitializeSecurityContext
//

typedef struct _NEGOTIATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    ULONG NegotiateFlags;
    STRING32 OemDomainName;
    STRING32 OemWorkstationName;
    ULONG64 Version;
} NEGOTIATE_MESSAGE, *PNEGOTIATE_MESSAGE;


//
// Old version of the message, for old clients
//
// begin_ntifs

typedef struct _OLD_NEGOTIATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    ULONG NegotiateFlags;
} OLD_NEGOTIATE_MESSAGE, *POLD_NEGOTIATE_MESSAGE;

//
// Opaque message returned from first call to AcceptSecurityContext
//
typedef struct _CHALLENGE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING32 TargetName;
    ULONG NegotiateFlags;
    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];
    ULONG64 ServerContextHandle;
    STRING32 TargetInfo;
    ULONG64 Version;
} CHALLENGE_MESSAGE, *PCHALLENGE_MESSAGE;

//
// Old version of the challenge message
//

typedef struct _OLD_CHALLENGE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING32 TargetName;
    ULONG NegotiateFlags;
    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];
} OLD_CHALLENGE_MESSAGE, *POLD_CHALLENGE_MESSAGE;

//
// Opaque message returned from second call to InitializeSecurityContext
//
typedef struct _AUTHENTICATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING32 LmChallengeResponse;
    STRING32 NtChallengeResponse;
    STRING32 DomainName;
    STRING32 UserName;
    STRING32 Workstation;
    STRING32 SessionKey;
    ULONG NegotiateFlags;
    ULONG64 Version;
    UCHAR HandShakeMessagesMIC[16];  // contains the HMAC-MD5 of all handshake messages,
                                     // where MD5DIGESTLEN == 16
} AUTHENTICATE_MESSAGE, *PAUTHENTICATE_MESSAGE;

typedef struct _OLD_AUTHENTICATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING32 LmChallengeResponse;
    STRING32 NtChallengeResponse;
    STRING32 DomainName;
    STRING32 UserName;
    STRING32 Workstation;
} OLD_AUTHENTICATE_MESSAGE, *POLD_AUTHENTICATE_MESSAGE;


//
// Additional input message to Initialize for clients to provide a
// user-supplied password
//

typedef struct _NTLM_CHALLENGE_MESSAGE {
    UNICODE_STRING32 Password;
    UNICODE_STRING32 UserName;
    UNICODE_STRING32 DomainName;
} NTLM_CHALLENGE_MESSAGE, *PNTLM_CHALLENGE_MESSAGE;


//
// Non-opaque message returned from second call to InitializeSecurityContext
//

typedef struct _NTLM_INITIALIZE_RESPONSE {
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
} NTLM_INITIALIZE_RESPONSE, *PNTLM_INITIALIZE_RESPONSE;

//
// Additional input message to Accept for trusted client skipping the first
// call to Accept and providing their own challenge
//

typedef struct _NTLM_AUTHENTICATE_MESSAGE {
    CHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    ULONG ParameterControl;
} NTLM_AUTHENTICATE_MESSAGE, *PNTLM_AUTHENTICATE_MESSAGE;


//
// Non-opaque message returned from second call to AcceptSecurityContext
//

typedef struct _NTLM_ACCEPT_RESPONSE {
    LUID LogonId;
    LARGE_INTEGER KickoffTime;
    ULONG UserFlags;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
} NTLM_ACCEPT_RESPONSE, *PNTLM_ACCEPT_RESPONSE;

// end_ntifs

//
// Size of the largest message
//  (The largest message is the AUTHENTICATE_MESSAGE)
//

#define DNSLEN 256  // length of DNS name

#define LSA_INFO_MAX_SIZE 20 // max LSA_INFO size

//
// sizeof(ULONG64) is for MsvAvTimestamp
//

#define TARGET_INFO_LEN ((3 * DNSLEN + DNLEN + CNLEN) * sizeof(WCHAR) + sizeof(ULONG64) + LSA_INFO_MAX_SIZE + \
                         9 * sizeof(MSV1_0_AV_PAIR) + sizeof(ULONG) * 2)

// length of NTLM2 response
#define NTLM2_RESPONSE_LENGTH (sizeof(MSV1_0_NTLM3_RESPONSE) + \
                               TARGET_INFO_LEN)

#define NTLMSSP_MAX_MESSAGE_SIZE (sizeof(AUTHENTICATE_MESSAGE) +  \
                                  LM_RESPONSE_LENGTH +            \
                                  NTLM2_RESPONSE_LENGTH +         \
                                  (DNSLEN + 1) * sizeof(WCHAR) +   \
                                  (UNLEN + 1) * sizeof(WCHAR) +   \
                                  (CNLEN + 1) * sizeof(WCHAR))

typedef struct _NTLMSSP_MESSAGE_SIGNATURE {
    ULONG   Version;
    ULONG   RandomPad;
    ULONG   CheckSum;
    ULONG   Nonce;
} NTLMSSP_MESSAGE_SIGNATURE, *PNTLMSSP_MESSAGE_SIGNATURE;

#define NTLMSSP_MESSAGE_SIGNATURE_SIZE sizeof(NTLMSSP_MESSAGE_SIGNATURE)
//
// Version 1 is the structure above, using stream RC4 to encrypt the trailing
// 12 bytes.
//
#define NTLM_SIGN_VERSION   1



#ifdef __cplusplus
}
#endif

#endif // _NTLMSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntpoapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntpoapi.h

Abstract:

    This module contains the user APIs for the NT Power Management.

Author:

Revision History:

--*/

#if (NTDDI_VERSION >= NTDDI_VISTA)
// begin_ntminiport begin_wdm begin_winnt

//
// =========================================
// Define GUIDs which represent well-known power schemes
// =========================================
//

//
// Maximum Power Savings - indicates that very aggressive power savings measures will be used to help
//                         stretch battery life.
//
// {a1841308-3541-4fab-bc81-f71556f20b4a}
//
DEFINE_GUID( GUID_MAX_POWER_SAVINGS, 0xA1841308, 0x3541, 0x4FAB, 0xBC, 0x81, 0xF7, 0x15, 0x56, 0xF2, 0x0B, 0x4A );

//
// No Power Savings - indicates that almost no power savings measures will be used.
//
// {8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c}
//
DEFINE_GUID( GUID_MIN_POWER_SAVINGS, 0x8C5E7FDA, 0xE8BF, 0x4A96, 0x9A, 0x85, 0xA6, 0xE2, 0x3A, 0x8C, 0x63, 0x5C );

//
// Typical Power Savings - indicates that fairly aggressive power savings measures will be used.
//
// {381b4222-f694-41f0-9685-ff5bb260df2e}
//
DEFINE_GUID( GUID_TYPICAL_POWER_SAVINGS, 0x381B4222, 0xF694, 0x41F0, 0x96, 0x85, 0xFF, 0x5B, 0xB2, 0x60, 0xDF, 0x2E );

//
// This is a special GUID that represents "no subgroup" of settings.  That is, it indicates
// that settings that are in the root of the power policy hierarchy as opposed to settings
// that are buried under a subgroup of settings.  This should be used when querying for
// power settings that may not fall into a subgroup.
//
DEFINE_GUID( NO_SUBGROUP_GUID, 0xFEA3413E, 0x7E05, 0x4911, 0x9A, 0x71, 0x70, 0x03, 0x31, 0xF1, 0xC2, 0x94 );

//
// This is a special GUID that represents "every power scheme".  That is, it indicates
// that any write to this power scheme should be reflected to every scheme present.
// This allows users to write a single setting once and have it apply to all schemes.  They
// can then apply custom settings to specific power schemes that they care about.
//
DEFINE_GUID( ALL_POWERSCHEMES_GUID, 0x68A1E95E, 0x13EA, 0x41E1, 0x80, 0x11, 0x0C, 0x49, 0x6C, 0xA4, 0x90, 0xB0 );

//
// This is a special GUID that represents a 'personality' that each power scheme will have.
// In other words, each power scheme will have this key indicating "I'm most like *this* base
// power scheme."  This individual setting will have one of three settings:
// GUID_MAX_POWER_SAVINGS
// GUID_MIN_POWER_SAVINGS
// GUID_TYPICAL_POWER_SAVINGS
//
// This allows several features:
// 1. Drivers and applications can register for notification of this GUID.  So when this power
//    scheme is activiated, this GUID's setting will be sent across the system and drivers/applications
//    can see "GUID_MAX_POWER_SAVINGS" which will tell them in a generic fashion "get real aggressive
//    about conserving power".
// 2. UserB may install a driver or application which creates power settings, and UserB may modify
//    those power settings.  Now UserA logs in.  How does he see those settings?  They simply don't
//    exist in his private power key.  Well they do exist over in the system power key.  When we
//    enumerate all the power settings in this system power key and don't find a corresponding entry
//    in the user's private power key, then we can go look at this "personality" key in the users
//    power scheme.  We can then go get a default value for the power setting, depending on which
//    "personality" power scheme is being operated on.  Here's an example:
//    A. UserB installs an application that creates a power setting Seetting1
//    B. UserB changes Setting1 to have a value of 50 because that's one of the possible settings
//       available for setting1.
//    C. UserB logs out
//    D. UserA logs in and his active power scheme is some custom scheme that was derived from
//       the GUID_TYPICAL_POWER_SAVINGS.  But remember that UserA has no setting1 in his
//       private power key.
//    E. When activating UserA's selected power scheme, all power settings in the system power key will
//       be enumerated (including Setting1).
//    F. The power manager will see that UserA has no Setting1 power setting in his private power scheme.
//    G. The power manager will query UserA's power scheme for its personality and retrieve
//       GUID_TYPICAL_POWER_SAVINGS.
//    H. The power manager then looks in Setting1 in the system power key and looks in its set of default
//       values for the corresponding value for GUID_TYPICAL_POWER_SAVINGS power schemes.
//    I. This derived power setting is applied.
DEFINE_GUID( GUID_POWERSCHEME_PERSONALITY, 0x245D8541, 0x3943, 0x4422, 0xB0, 0x25, 0x13, 0xA7, 0x84, 0xF6, 0x79, 0xB7 );

//
// Define a special GUID which will be used to define the active power scheme.
// User will register for this power setting GUID, and when the active power
// scheme changes, they'll get a callback where the payload is the GUID
// representing the active powerscheme.
// ( 31F9F286-5084-42FE-B720-2B0264993763 }
//
DEFINE_GUID( GUID_ACTIVE_POWERSCHEME, 0x31F9F286, 0x5084, 0x42FE, 0xB7, 0x20, 0x2B, 0x02, 0x64, 0x99, 0x37, 0x63 );

//
// =========================================
// Define GUIDs which represent well-known power settings
// =========================================
//

// Video settings
// --------------
//
// Specifies the subgroup which will contain all of the video
// settings for a single policy.
//
DEFINE_GUID( GUID_VIDEO_SUBGROUP, 0x7516B95F, 0xF776, 0x4464, 0x8C, 0x53, 0x06, 0x16, 0x7F, 0x40, 0xCC, 0x99 );

//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we power off the video.
//
DEFINE_GUID( GUID_VIDEO_POWERDOWN_TIMEOUT, 0x3C0BC021, 0xC8A8, 0x4E07, 0xA9, 0x73, 0x6B, 0x14, 0xCB, 0xCB, 0x2B, 0x7E );

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the video,
//
DEFINE_GUID( GUID_VIDEO_ADAPTIVE_POWERDOWN, 0x90959D22, 0xD6A1, 0x49B9, 0xAF, 0x93, 0xBC, 0xE8, 0x85, 0xAD, 0x33, 0x5B );

//
// Specifies if the monitor is currently being powered or not.
// 02731015-4510-4526-99E6-E5A17EBD1AEA
//
DEFINE_GUID( GUID_MONITOR_POWER_ON, 0x02731015, 0x4510, 0x4526, 0x99, 0xE6, 0xE5, 0xA1, 0x7E, 0xBD, 0x1A, 0xEA );

// Harddisk settings
// -----------------
//
// Specifies the subgroup which will contain all of the harddisk
// settings for a single policy.
//
DEFINE_GUID( GUID_DISK_SUBGROUP, 0x0012EE47, 0x9041, 0x4B5D, 0x9B, 0x77, 0x53, 0x5F, 0xBA, 0x8B, 0x14, 0x42 );

//
// Specifies (in seconds) how long we wait after the last disk access
// before we power off the disk.
//
DEFINE_GUID( GUID_DISK_POWERDOWN_TIMEOUT, 0x6738E2C4, 0xE8A5, 0x4A42, 0xB1, 0x6A, 0xE0, 0x40, 0xE7, 0x69, 0x75, 0x6E );

//
// Specifies the amount of contiguous disk activity time to ignore when
// calculating disk idleness.
//
// 80e3c60e-bb94-4ad8-bbe0-0d3195efc663
//

DEFINE_GUID( GUID_DISK_BURST_IGNORE_THRESHOLD, 0x80e3c60e, 0xbb94, 0x4ad8, 0xbb, 0xe0, 0x0d, 0x31, 0x95, 0xef, 0xc6, 0x63 );

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the disk,
//
DEFINE_GUID( GUID_DISK_ADAPTIVE_POWERDOWN, 0x396A32E1, 0x499A, 0x40B2, 0x91, 0x24, 0xA9, 0x6A, 0xFE, 0x70, 0x76, 0x67 );

// System sleep settings
// ---------------------
//
// Specifies the subgroup which will contain all of the sleep
// settings for a single policy.
// { 238C9FA8-0AAD-41ED-83F4-97BE242C8F20 }
//
DEFINE_GUID( GUID_SLEEP_SUBGROUP, 0x238C9FA8, 0x0AAD, 0x41ED, 0x83, 0xF4, 0x97, 0xBE, 0x24, 0x2C, 0x8F, 0x20 );

//
// Specifies an idle treshold percentage (0-100). The system must be this idle
// over a period of time in order to idle to sleep.
//
DEFINE_GUID( GUID_SLEEP_IDLE_THRESHOLD, 0x81cd32e0, 0x7833, 0x44f3, 0x87, 0x37, 0x70, 0x81, 0xf3, 0x8d, 0x1f, 0x70 );

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to standby (S1, S2 or S3).
//
DEFINE_GUID( GUID_STANDBY_TIMEOUT, 0x29F6C1DB, 0x86DA, 0x48C5, 0x9F, 0xDB, 0xF2, 0xB6, 0x7B, 0x1F, 0x44, 0xDA );

//
// Specifies (in seconds) how long the system should go back to sleep after
// waking unattended. 0 indicates that the standard standby/hibernate idle
// policy should be used instead.
//
// {7bc4a2f9-d8fc-4469-b07b-33eb785aaca0}
//
DEFINE_GUID( GUID_UNATTEND_SLEEP_TIMEOUT, 0x7bc4a2f9, 0xd8fc, 0x4469, 0xb0, 0x7b, 0x33, 0xeb, 0x78, 0x5a, 0xac, 0xa0 );

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to hibernate (S4).
//
DEFINE_GUID( GUID_HIBERNATE_TIMEOUT, 0x9D7815A6, 0x7EE4, 0x497E, 0x88, 0x88, 0x51, 0x5A, 0x05, 0xF0, 0x23, 0x64 );

//
// Specifies whether or not Fast S4 should be enabled if the system supports it
// 94AC6D29-73CE-41A6-809F-6363BA21B47E
//
DEFINE_GUID( GUID_HIBERNATE_FASTS4_POLICY, 0x94AC6D29, 0x73CE, 0x41A6, 0x80, 0x9F, 0x63, 0x63, 0xBA, 0x21, 0xB4, 0x7E );

//
// Define a GUID for controlling the criticality of sleep state transitions.
// Critical sleep transitions do not query applications, services or drivers
// before transitioning the platform to a sleep state.
//
// {B7A27025-E569-46c2-A504-2B96CAD225A1}
//
DEFINE_GUID( GUID_CRITICAL_POWER_TRANSITION,  0xB7A27025, 0xE569, 0x46c2, 0xA5, 0x04, 0x2B, 0x96, 0xCA, 0xD2, 0x25, 0xA1);

//
// Specifies if the system is entering or exiting 'away mode'.
// 98A7F580-01F7-48AA-9C0F-44352C29E5C0
//
DEFINE_GUID( GUID_SYSTEM_AWAYMODE, 0x98A7F580, 0x01F7, 0x48AA, 0x9C, 0x0F, 0x44, 0x35, 0x2C, 0x29, 0xE5, 0xC0 );

// Specify whether away mode is allowed
//
// {25DFA149-5DD1-4736-B5AB-E8A37B5B8187}
//
DEFINE_GUID( GUID_ALLOW_AWAYMODE, 0x25dfa149, 0x5dd1, 0x4736, 0xb5, 0xab, 0xe8, 0xa3, 0x7b, 0x5b, 0x81, 0x87 );

//
// Defines a guid for enabling/disabling standby (S1-S3) states. This does not
// affect hibernation (S4).
//
// {abfc2519-3608-4c2a-94ea-171b0ed546ab}
//
DEFINE_GUID( GUID_ALLOW_STANDBY_STATES, 0xabfc2519, 0x3608, 0x4c2a, 0x94, 0xea, 0x17, 0x1b, 0x0e, 0xd5, 0x46, 0xab );

//
// Defines a guid for enabling/disabling the ability to wake via RTC.
//
// {BD3B718A-0680-4D9D-8AB2-E1D2B4AC806D}
//
DEFINE_GUID( GUID_ALLOW_RTC_WAKE, 0xBD3B718A, 0x0680, 0x4D9D, 0x8A, 0xB2, 0xE1, 0xD2, 0xB4, 0xAC, 0x80, 0x6D );

// System button actions
// ---------------------
//
//
// Specifies the subgroup which will contain all of the system button
// settings for a single policy.
//
DEFINE_GUID( GUID_SYSTEM_BUTTON_SUBGROUP, 0x4F971E89, 0xEEBD, 0x4455, 0xA8, 0xDE, 0x9E, 0x59, 0x04, 0x0E, 0x73, 0x47 );

// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system power button is pressed.
//
DEFINE_GUID( GUID_POWERBUTTON_ACTION, 0x7648EFA3, 0xDD9C, 0x4E3E, 0xB5, 0x66, 0x50, 0xF9, 0x29, 0x38, 0x62, 0x80 );
DEFINE_GUID( GUID_POWERBUTTON_ACTION_FLAGS, 0x857E7FAC, 0x034B, 0x4704, 0xAB, 0xB1, 0xBC, 0xA5, 0x4A, 0xA3, 0x14, 0x78 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
//
DEFINE_GUID( GUID_SLEEPBUTTON_ACTION, 0x96996BC0, 0xAD50, 0x47EC, 0x92, 0x3B, 0x6F, 0x41, 0x87, 0x4D, 0xD9, 0xEB );
DEFINE_GUID( GUID_SLEEPBUTTON_ACTION_FLAGS, 0x2A160AB1, 0xB69D, 0x4743, 0xB7, 0x18, 0xBF, 0x14, 0x41, 0xD5, 0xE4, 0x93 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
// { A7066653-8D6C-40A8-910E-A1F54B84C7E5 }
//
DEFINE_GUID( GUID_USERINTERFACEBUTTON_ACTION, 0xA7066653, 0x8D6C, 0x40A8, 0x91, 0x0E, 0xA1, 0xF5, 0x4B, 0x84, 0xC7, 0xE5 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system lid is closed.
//
DEFINE_GUID( GUID_LIDCLOSE_ACTION, 0x5CA83367, 0x6E45, 0x459F, 0xA2, 0x7B, 0x47, 0x6B, 0x1D, 0x01, 0xC9, 0x36 );
DEFINE_GUID( GUID_LIDCLOSE_ACTION_FLAGS, 0x97E969AC, 0x0D6C, 0x4D08, 0x92, 0x7C, 0xD7, 0xBD, 0x7A, 0xD7, 0x85, 0x7B );
DEFINE_GUID( GUID_LIDOPEN_POWERSTATE, 0x99FF10E7, 0x23B1, 0x4C07, 0xA9, 0xD1, 0x5C, 0x32, 0x06, 0xD7, 0x41, 0xB4 );


// Battery Discharge Settings
// --------------------------
//
// Specifies the subgroup which will contain all of the battery discharge
// settings for a single policy.
//
DEFINE_GUID( GUID_BATTERY_SUBGROUP, 0xE73A048D, 0xBF27, 0x4F12, 0x97, 0x31, 0x8B, 0x20, 0x76, 0xE8, 0x89, 0x1F );

//
// 4 battery discharge alarm settings.
//
// GUID_BATTERY_DISCHARGE_ACTION_x - This is the action to take.  It is a value
//                                   of type POWER_ACTION
// GUID_BATTERY_DISCHARGE_LEVEL_x  - This is the battery level (%)
// GUID_BATTERY_DISCHARGE_FLAGS_x  - Flags defined below:
//                                   POWER_ACTION_POLICY->EventCode flags
//                                   BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK
//                                   BATTERY_DISCHARGE_FLAGS_ENABLE
DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_0, 0x637EA02F, 0xBBCB, 0x4015, 0x8E, 0x2C, 0xA1, 0xC7, 0xB9, 0xC0, 0xB5, 0x46 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_0, 0x9A66D8D7, 0x4FF7, 0x4EF9, 0xB5, 0xA2, 0x5A, 0x32, 0x6C, 0xA2, 0xA4, 0x69 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_0, 0x5dbb7c9f, 0x38e9, 0x40d2, 0x97, 0x49, 0x4f, 0x8a, 0x0e, 0x9f, 0x64, 0x0f );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_1, 0xD8742DCB, 0x3E6A, 0x4B3C, 0xB3, 0xFE, 0x37, 0x46, 0x23, 0xCD, 0xCF, 0x06 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_1, 0x8183BA9A, 0xE910, 0x48DA, 0x87, 0x69, 0x14, 0xAE, 0x6D, 0xC1, 0x17, 0x0A );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_1, 0xbcded951, 0x187b, 0x4d05, 0xbc, 0xcc, 0xf7, 0xe5, 0x19, 0x60, 0xc2, 0x58 );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_2, 0x421CBA38, 0x1A8E, 0x4881, 0xAC, 0x89, 0xE3, 0x3A, 0x8B, 0x04, 0xEC, 0xE4 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_2, 0x07A07CA2, 0xADAF, 0x40D7, 0xB0, 0x77, 0x53, 0x3A, 0xAD, 0xED, 0x1B, 0xFA );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_2, 0x7fd2f0c4, 0xfeb7, 0x4da3, 0x81, 0x17, 0xe3, 0xfb, 0xed, 0xc4, 0x65, 0x82 );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_3, 0x80472613, 0x9780, 0x455E, 0xB3, 0x08, 0x72, 0xD3, 0x00, 0x3C, 0xF2, 0xF8 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_3, 0x58AFD5A6, 0xC2DD, 0x47D2, 0x9F, 0xBF, 0xEF, 0x70, 0xCC, 0x5C, 0x59, 0x65 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_3, 0x73613ccf, 0xdbfa, 0x4279, 0x83, 0x56, 0x49, 0x35, 0xf6, 0xbf, 0x62, 0xf3 );

// Processor power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the processor
// settings for a single policy.
//
DEFINE_GUID( GUID_PROCESSOR_SETTINGS_SUBGROUP, 0x54533251, 0x82BE, 0x4824, 0x96, 0xC1, 0x47, 0xB6, 0x0B, 0x74, 0x0D, 0x00 );


DEFINE_GUID( GUID_PROCESSOR_THROTTLE_POLICY, 0x57027304, 0x4AF6, 0x4104, 0x92, 0x60, 0xE3, 0xD9, 0x52, 0x48, 0xFC, 0x36 );

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should never go above.  For example, if this value is set to 80, then
// the processor frequency will never be throttled above 80 percent of its
// maximum frequency by the system.
//
DEFINE_GUID( GUID_PROCESSOR_THROTTLE_MAXIMUM, 0xBC5038F7, 0x23E0, 0x4960, 0x96, 0xDA, 0x33, 0xAB, 0xAF, 0x59, 0x35, 0xEC );

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should not drop below.  For example, if this value is set to 50, then the
// processor frequency will never be throttled below 50 percent of its
// maximum frequency by the system.
//
DEFINE_GUID( GUID_PROCESSOR_THROTTLE_MINIMUM, 0x893DEE8E, 0x2BEF, 0x41E0, 0x89, 0xC6, 0xB5, 0x5D, 0x09, 0x29, 0x96, 0x4C );

//
// Specifies whether throttle states are allowed to be used even when
// performance states are available.
//
// {3b04d4fd-1cc7-4f23-ab1c-d1337819c4bb}
//
DEFINE_GUID( GUID_PROCESSOR_ALLOW_THROTTLING, 0x3b04d4fd, 0x1cc7, 0x4f23, 0xab, 0x1c, 0xd1, 0x33, 0x78, 0x19, 0xc4, 0xbb );

//
// Specifies processor power settings for CState policy data
// {68F262A7-F621-4069-B9A5-4874169BE23C}
//
DEFINE_GUID( GUID_PROCESSOR_IDLESTATE_POLICY, 0x68f262a7, 0xf621, 0x4069, 0xb9, 0xa5, 0x48, 0x74, 0x16, 0x9b, 0xe2, 0x3c);

//
// Specifies processor power settings for PerfState policy data
// {BBDC3814-18E9-4463-8A55-D197327C45C0}
//
DEFINE_GUID( GUID_PROCESSOR_PERFSTATE_POLICY, 0xBBDC3814, 0x18E9, 0x4463, 0x8A, 0x55, 0xD1, 0x97, 0x32, 0x7C, 0x45, 0xC0);

//
// Specifies active vs passive cooling.  Although not directly related to
// processor settings, it is the processor that gets throttled if we're doing
// passive cooling, so it is fairly strongly related.
// {94D3A615-A899-4AC5-AE2B-E4D8F634367F}
//
DEFINE_GUID( GUID_SYSTEM_COOLING_POLICY, 0x94D3A615, 0xA899, 0x4AC5, 0xAE, 0x2B, 0xE4, 0xD8, 0xF6, 0x34, 0x36, 0x7F);

// Lock Console on Wake
// --------------------
//

// Specifies the behavior of the system when we wake from standby or
// hibernate.  If this is set, then we will cause the console to lock
// after we resume.
//
DEFINE_GUID( GUID_LOCK_CONSOLE_ON_WAKE, 0x0E796BDB, 0x100D, 0x47D6, 0xA2, 0xD5, 0xF7, 0xD2, 0xDA, 0xA5, 0x1F, 0x51 );

// Device idle characteristics
// ---------------------------
//
// Specifies whether to use the "performance" or "conservative" timeouts for
// device idle management.
//
// 4faab71a-92e5-4726-b531-224559672d19
//
DEFINE_GUID( GUID_DEVICE_IDLE_POLICY, 0x4faab71a, 0x92e5, 0x4726, 0xb5, 0x31, 0x22, 0x45, 0x59, 0x67, 0x2d, 0x19 );

#define POWER_DEVICE_IDLE_POLICY_PERFORMANCE  0
#define POWER_DEVICE_IDLE_POLICY_CONSERVATIVE 1

// AC/DC power source
// ------------------
//

// Specifies the power source for the system.  consumers may register for
// notification when the power source changes and will be notified with
// one of 3 values:
// 0 - Indicates the system is being powered by an AC power source.
// 1 - Indicates the system is being powered by a DC power source.
// 2 - Indicates the system is being powered by a short-term DC power
//     source.  For example, this would be the case if the system is
//     being powed by a short-term battery supply in a backing UPS
//     system.  When this value is recieved, the consumer should make
//     preparations for either a system hibernate or system shutdown.
//
// { 5D3E9A59-E9D5-4B00-A6BD-FF34FF516548 }
DEFINE_GUID( GUID_ACDC_POWER_SOURCE, 0x5D3E9A59, 0xE9D5, 0x4B00, 0xA6, 0xBD, 0xFF, 0x34, 0xFF, 0x51, 0x65, 0x48 );

// Lid state changes
// -----------------
//
// Specifies the current state of the lid (open or closed). The callback won't
// be called at all until a lid device is found and its current state is known.
//
// Values:
//
// 0 - closed
// 1 - opened
//
// { BA3E0F4D-B817-4094-A2D1-D56379E6A0F3 }
//

DEFINE_GUID( GUID_LIDSWITCH_STATE_CHANGE,  0xBA3E0F4D, 0xB817, 0x4094, 0xA2, 0xD1, 0xD5, 0x63, 0x79, 0xE6, 0xA0, 0xF3 );

// Battery life remaining
// ----------------------
//

// Specifies the percentage of battery life remaining.  The consumer
// may register for notification in order to track battery life in
// a fine-grained manner.
//
// Once registered, the consumer can expect to be notified as the battery
// life percentage changes.
//
// The consumer will recieve a value between 0 and 100 (inclusive) which
// indicates percent battery life remaining.
//
// { A7AD8041-B45A-4CAE-87A3-EECBB468A9E1 }
DEFINE_GUID( GUID_BATTERY_PERCENTAGE_REMAINING, 0xA7AD8041, 0xB45A, 0x4CAE, 0x87, 0xA3, 0xEE, 0xCB, 0xB4, 0x68, 0xA9, 0xE1 );


// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
DEFINE_GUID( GUID_IDLE_BACKGROUND_TASK, 0x515C31D8, 0xF734, 0x163D, 0xA0, 0xFD, 0x11, 0xA0, 0x8C, 0x91, 0xE8, 0xF1 );

// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
// { CF23F240-2A54-48D8-B114-DE1518FF052E }
DEFINE_GUID( GUID_BACKGROUND_TASK_NOTIFICATION, 0xCF23F240, 0x2A54, 0x48D8, 0xB1, 0x14, 0xDE, 0x15, 0x18, 0xFF, 0x05, 0x2E );

// Define a GUID that will represent the action of a direct experience button
// on the platform.  Users will register for this DPPE setting and recieve
// notification when the h/w button is pressed.
//
// { 1A689231-7399-4E9A-8F99-B71F999DB3FA }
//
DEFINE_GUID( GUID_APPLAUNCH_BUTTON, 0x1A689231, 0x7399, 0x4E9A, 0x8F, 0x99, 0xB7, 0x1F, 0x99, 0x9D, 0xB3, 0xFA );

// PCI Express power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the PCI Express
// settings for a single policy.
//
// {501a4d13-42af-4429-9fd1-a8218c268e20}
//
DEFINE_GUID( GUID_PCIEXPRESS_SETTINGS_SUBGROUP, 0x501a4d13, 0x42af,0x4429, 0x9f, 0xd1, 0xa8, 0x21, 0x8c, 0x26, 0x8e, 0x20 );

// Specifies the PCI Express ASPM power policy.
//
// {ee12f906-d277-404b-b6da-e5fa1a576df5}
//
DEFINE_GUID( GUID_PCIEXPRESS_ASPM_POLICY, 0xee12f906, 0xd277, 0x404b, 0xb6, 0xda, 0xe5, 0xfa, 0x1a, 0x57, 0x6d, 0xf5 );

// end_winnt  end_wdm end_ntminiport
#endif // (NTDDI_VERSION >= NTDDI_VISTA)




#ifndef _NTPOAPI_
#define _NTPOAPI_


#ifdef __cplusplus
extern "C" {
#endif

//
// Power Management user APIs
//

// begin_ntminiport begin_wdm

#ifndef _PO_DDK_
#define _PO_DDK_

// begin_winnt

typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking     = 1,
    PowerSystemSleeping1   = 2,
    PowerSystemSleeping2   = 3,
    PowerSystemSleeping3   = 4,
    PowerSystemHibernate   = 5,
    PowerSystemShutdown    = 6,
    PowerSystemMaximum     = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;

#define POWER_SYSTEM_MAXIMUM 7

typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;


// end_winnt

typedef union _POWER_STATE {
    SYSTEM_POWER_STATE SystemState;
    DEVICE_POWER_STATE DeviceState;
} POWER_STATE, *PPOWER_STATE;

typedef enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState
} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _SYSTEM_POWER_STATE_CONTEXT {
    union {
        struct {
            ULONG   Reserved1             : 8;
            ULONG   TargetSystemState     : 4;
            ULONG   EffectiveSystemState  : 4;
            ULONG   CurrentSystemState    : 4;
            ULONG   IgnoreHibernationPath : 1;
            ULONG   PseudoTransition      : 1;
            ULONG   Reserved2             : 10;
        } DUMMYSTRUCTNAME;

        ULONG ContextAsUlong;
    } DUMMYUNIONNAME;
} SYSTEM_POWER_STATE_CONTEXT, *PSYSTEM_POWER_STATE_CONTEXT;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
// Generic power related IOCTLs
//

#define IOCTL_QUERY_DEVICE_POWER_STATE  \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x0, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_SET_DEVICE_WAKE           \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CANCEL_DEVICE_WAKE        \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x2, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Defines for W32 interfaces
//

// begin_winnt

#define ES_SYSTEM_REQUIRED   ((ULONG)0x00000001)
#define ES_DISPLAY_REQUIRED  ((ULONG)0x00000002)
#define ES_USER_PRESENT      ((ULONG)0x00000004)
#define ES_AWAYMODE_REQUIRED ((ULONG)0x00000040)
#define ES_CONTINUOUS        ((ULONG)0x80000000)

typedef ULONG EXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;

// end_ntminiport

#if (NTDDI_VERSION >= NTDDI_WINXP)

//-----------------------------------------------------------------------------
// Device Power Information
// Accessable via CM_Get_DevInst_Registry_Property_Ex(CM_DRP_DEVICE_POWER_DATA)
//-----------------------------------------------------------------------------

#define PDCAP_D0_SUPPORTED              0x00000001
#define PDCAP_D1_SUPPORTED              0x00000002
#define PDCAP_D2_SUPPORTED              0x00000004
#define PDCAP_D3_SUPPORTED              0x00000008
#define PDCAP_WAKE_FROM_D0_SUPPORTED    0x00000010
#define PDCAP_WAKE_FROM_D1_SUPPORTED    0x00000020
#define PDCAP_WAKE_FROM_D2_SUPPORTED    0x00000040
#define PDCAP_WAKE_FROM_D3_SUPPORTED    0x00000080
#define PDCAP_WARM_EJECT_SUPPORTED      0x00000100

typedef struct CM_Power_Data_s {
    ULONG               PD_Size;
    DEVICE_POWER_STATE  PD_MostRecentPowerState;
    ULONG               PD_Capabilities;
    ULONG               PD_D1Latency;
    ULONG               PD_D2Latency;
    ULONG               PD_D3Latency;
    DEVICE_POWER_STATE  PD_PowerStateMapping[POWER_SYSTEM_MAXIMUM];
    SYSTEM_POWER_STATE  PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// begin_wdm

typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,                                   // Compare with KeQueryInterruptTime()
    LastSleepTime,                                  // Compare with KeQueryInterruptTime()
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    GetPowerTransitionVetoes,
    SetPowerTransitionVeto,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorThrottleStates,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities
} POWER_INFORMATION_LEVEL;

//
// Power Transition Vetos
//

#define PO_TRANSITION_VETO_TYPE_WINDOW  0x00000001
#define PO_TRANSITION_VETO_TYPE_SERVICE 0x00000002
//#define PO_TRANSITION_VETO_TYPE_DRIVER  0x00000004

#define PO_TRANSITION_VETO_TYPE_ALL     \
    (PO_TRANSITION_VETO_TYPE_WINDOW | PO_TRANSITION_VETO_TYPE_SERVICE)

typedef struct _PO_TRANSITION_VETO_REASON {
    ULONG ResourceId;
    ULONG ModuleNameOffset;
} PO_TRANSITION_VETO_REASON, *PPO_TRANSITION_VETO_REASON;

typedef struct _PO_TRANSITION_VETO_WINDOW {
    HANDLE Handle;
} PO_TRANSITION_VETO_WINDOW, *PPO_TRANSITION_VETO_WINDOW;

typedef struct _PO_TRANSITION_VETO_SERVICE {
    ULONG ServiceNameOffset;
} PO_TRANSITION_VETO_SERVICE, *PPO_TRANSITION_VETO_SERVICE;

/*

typedef struct _PO_TRANSITION_VETO_DRIVER {
    ULONG InstancePathOffset;
    ULONG DriverNameOffset;
} PO_TRANSITION_VETO_DRIVER, *PPO_TRANSITION_VETO_DRIVER;

*/

typedef struct _PO_TRANSITION_VETO {
    ULONG Type;
    PO_TRANSITION_VETO_REASON Reason;
    ULONG ProcessId;

    union {
        PO_TRANSITION_VETO_WINDOW Window;
        PO_TRANSITION_VETO_SERVICE Service;
        //PO_TRANSITION_VETO_DRIVER Driver;
    } DUMMYUNIONNAME;
} PO_TRANSITION_VETO, *PPO_TRANSITION_VETO;

typedef struct _PO_TRANSITION_VETOES {
    ULONG Count;
    PO_TRANSITION_VETO Vetoes[ANYSIZE_ARRAY];
} PO_TRANSITION_VETOES, *PPO_TRANSITION_VETOES;

//
// Power Setting definitions
//

typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {

    //
    // Version of this structure.  Currently should be set to
    // POWER_SETTING_VALUE_VERSION.
    //
    ULONG       Version;


    //
    // GUID representing the power setting being applied.
    //
    GUID        Guid;


    //
    // What power state should this setting be applied to?  E.g.
    // AC, DC, thermal, ...
    //
    SYSTEM_POWER_CONDITION PowerCondition;

    //
    // Length (in bytes) of the 'Data' member.
    //
    ULONG       DataLength;

    //
    // Data which contains the actual setting value.
    //
    UCHAR   Data[ANYSIZE_ARRAY];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;

#define POWER_SETTING_VALUE_VERSION (0x1)

typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;

//
// Package definition for an experience button device notification.  When
// someone registers for GUID_EXPERIENCE_BUTTON, this is the definition of
// the setting data they'll get.
//
typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {

    //
    // System time when the most recent button press ocurred.  Note that this is
    // specified in 100ns internvals since January 1, 1601.
    //
    LARGE_INTEGER       ActivationTime;

    //
    // Reserved for internal use.
    //
    ULONG               Flags;

    //
    // which instance of this device was pressed?
    //
    ULONG               ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;

//
// define platform roles
//

typedef enum {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE;

//
// Wake source tracking
//

typedef enum {
    DeviceWakeSourceType,
    FixedWakeSourceType
} PO_WAKE_SOURCE_TYPE, *PPO_WAKE_SOURCE_TYPE;

typedef enum {
    FixedWakeSourcePowerButton,
    FixedWakeSourceSleepButton,
    FixedWakeSourceRtc
} PO_FIXED_WAKE_SOURCE_TYPE, *PPO_FIXED_WAKE_SOURCE_TYPE;

typedef struct _PO_WAKE_SOURCE_HEADER {
    PO_WAKE_SOURCE_TYPE Type;
    ULONG Size;
} PO_WAKE_SOURCE_HEADER, *PPO_WAKE_SOURCE_HEADER;

typedef struct _PO_WAKE_SOURCE_DEVICE {
    PO_WAKE_SOURCE_HEADER Header;
    WCHAR InstancePath[ANYSIZE_ARRAY];
} PO_WAKE_SOURCE_DEVICE, *PPO_WAKE_SOURCE_DEVICE;

typedef struct _PO_WAKE_SOURCE_FIXED {
    PO_WAKE_SOURCE_HEADER Header;
    PO_FIXED_WAKE_SOURCE_TYPE FixedWakeSourceType;
} PO_WAKE_SOURCE_FIXED, *PPO_WAKE_SOURCE_FIXED;

typedef struct _PO_WAKE_SOURCE_INFO {
    ULONG Count;
    ULONG Offsets[ANYSIZE_ARRAY];
} PO_WAKE_SOURCE_INFO, *PPO_WAKE_SOURCE_INFO;

typedef struct _PO_WAKE_SOURCE_HISTORY {
    ULONG Count;
    ULONG Offsets[ANYSIZE_ARRAY];
} PO_WAKE_SOURCE_HISTORY, *PPO_WAKE_SOURCE_HISTORY;

//
// System power manager capabilities
//

#if (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_)
typedef struct {
    ULONG       Granularity;
    ULONG       Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_)

// end_winnt
#endif // !_PO_DDK_
// end_wdm end_ntminiport
// begin_nthal

#define POWER_PERF_SCALE    100
#define PERF_LEVEL_TO_PERCENT(_x_) ((_x_ * 1000) / (POWER_PERF_SCALE * 10))
#define PERCENT_TO_PERF_LEVEL(_x_) ((_x_ * POWER_PERF_SCALE * 10) / 1000)

//
// Policy manager state handler interfaces
//

// power state handlers

typedef enum {
    PowerStateSleeping1 = 0,
    PowerStateSleeping2 = 1,
    PowerStateSleeping3 = 2,
    PowerStateSleeping4 = 3,
    PowerStateShutdownOff = 4,
    PowerStateShutdownReset = 5,
    PowerStateSleeping4Firmware = 6,
    PowerStateMaximum = 7
} POWER_STATE_HANDLER_TYPE, *PPOWER_STATE_HANDLER_TYPE;

#define POWER_STATE_HANDLER_TYPE_MAX 8

typedef
NTSTATUS
(*PENTER_STATE_SYSTEM_HANDLER)(
    IN PVOID                        SystemContext
    );

typedef
NTSTATUS
(*PENTER_STATE_HANDLER)(
    IN          PVOID                        Context,
    IN          PENTER_STATE_SYSTEM_HANDLER  SystemHandler,    OPTIONAL
    IN          PVOID                        SystemContext,
    IN          LONG                         NumberProcessors,
    IN          LONG volatile                *Number
    );

typedef struct {
    POWER_STATE_HANDLER_TYPE    Type;
    BOOLEAN                     RtcWake;
    UCHAR                       Spare[3];
    PENTER_STATE_HANDLER        Handler;
    PVOID                       Context;
} POWER_STATE_HANDLER, *PPOWER_STATE_HANDLER;


#if (NTDDI_VERSION >= NTDDI_WINXP)

typedef
NTSTATUS
(*PENTER_STATE_NOTIFY_HANDLER)(
    IN POWER_STATE_HANDLER_TYPE   State,
    IN PVOID                      Context,
    IN BOOLEAN                    Entering
    );

typedef struct {
    PENTER_STATE_NOTIFY_HANDLER Handler;
    PVOID                       Context;
} POWER_STATE_NOTIFY_HANDLER, *PPOWER_STATE_NOTIFY_HANDLER;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtPowerInformation(
    __in POWER_INFORMATION_LEVEL InformationLevel,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength
    );

//
// Processor Power Management external interface definitions / info.
//

//
// Defines PPM Idle Handler types.
//
#define IDLE_STATES_LINEAR  0
#define IDLE_STATES_DYNAMIC 1

typedef struct {
    ULONG64 StartTime;
    ULONG64 EndTime;
    ULONG Reserved[4];
} PROCESSOR_IDLE_TIMES, *PPROCESSOR_IDLE_TIMES;

typedef
NTSTATUS
(FASTCALL *PPROCESSOR_IDLE_HANDLER) (
    __in ULONG_PTR Context,
    __inout PPROCESSOR_IDLE_TIMES IdleTimes
    );

//
// Enhanced idle handler and flags.
//

#define IDLE_HANDLER_USING_HYPERVISOR 0x00000001

typedef
NTSTATUS
(FASTCALL *PPROCESSOR_IDLE_HANDLER_EX) (
    __inout PVOID Context,
    __in ULONG Flags
    );

//
// PROCESSOR_IDLE_STATE "StateFlags" definitions.
//

#define IDLE_STATE_FLAGS_C1_HLT     0x01        // describes C1 only
#define IDLE_STATE_FLAGS_C1_IO_HLT  0x02        // describes C1 only
#define IDLE_STATE_FLAGS_IO         0x04        // describes C2 and C3 only
#define IDLE_STATE_FLAGS_MWAIT      0x08        // describes C1, C2, C3, C4, ...

typedef struct _PROCESSOR_IDLE_STATE {
    UCHAR StateType;
    ULONG StateFlags;
    ULONG HardwareLatency;
    ULONG Power;
    ULONG_PTR Context;
    PPROCESSOR_IDLE_HANDLER Handler;
} PROCESSOR_IDLE_STATE, *PPROCESSOR_IDLE_STATE;

typedef struct _PROCESSOR_IDLE_STATE_EX {
    UCHAR StateType;
    ULONG StateFlags;
    ULONG HardwareLatency;
    ULONG Power;
    PVOID Context;
    PPROCESSOR_IDLE_HANDLER_EX Handler;
} PROCESSOR_IDLE_STATE_EX, *PPROCESSOR_IDLE_STATE_EX;

typedef struct _PROCESSOR_IDLE_STATES {
    ULONG Size;
    ULONG Revision;
    ULONG Count;
    ULONG Type;
    KAFFINITY TargetProcessors;
    PROCESSOR_IDLE_STATE State[ANYSIZE_ARRAY];
} PROCESSOR_IDLE_STATES, *PPROCESSOR_IDLE_STATES;

typedef struct _PROCESSOR_IDLE_STATES_EX {
    ULONG Size;
    ULONG Revision;
    ULONG Count;
    ULONG Type;
    KAFFINITY TargetProcessors;
    PROCESSOR_IDLE_STATE_EX State[ANYSIZE_ARRAY];
} PROCESSOR_IDLE_STATES_EX, *PPROCESSOR_IDLE_STATES_EX;

// PPM Perf.

#define PROCESSOR_STATE_TYPE_PERFORMANCE    0x1
#define PROCESSOR_STATE_TYPE_THROTTLE       0x2

#define INVALID_PERF_STATE                  0xFFFFFFFF

typedef
NTSTATUS
(FASTCALL *PPROCESSOR_PERF_HANDLER) (
    __in ULONG_PTR Context,
    __in ULONG64 ControlValue,
    __in ULONG64 StatusValue
    );

typedef
ULONG
(FASTCALL *PPROCESSOR_FEEDBACK_HANDLER) (
    __in BOOLEAN Reset
    );

typedef struct {
    ULONG Frequency;
    ULONG Power;
    USHORT Latency;
    UCHAR Type;
    UCHAR Spare;
    ULONG64 Control;
    ULONG64 Status;
} PROCESSOR_PERF_STATE, *PPROCESSOR_PERF_STATE;

typedef struct {
    ULONG Size;
    USHORT Revision;
    USHORT Type;                            // domain coordination
    ULONG Count;
    ULONG MaxFrequency;
    KAFFINITY TargetProcessors;             // domain affinity
    PPROCESSOR_PERF_HANDLER PStateHandler;
    ULONG_PTR PStateContext;
    ULONG PStateCap;
    PPROCESSOR_PERF_HANDLER TStateHandler;
    ULONG_PTR TStateContext;
    ULONG TStateCap;
    PPROCESSOR_FEEDBACK_HANDLER FeedbackHandler;
    PROCESSOR_PERF_STATE State[ANYSIZE_ARRAY];
} PROCESSOR_PERF_STATES, *PPROCESSOR_PERF_STATES;

//
// begin_winnt
//

typedef struct {
    BOOLEAN Enabled;
    UCHAR PercentBusy[MAXIMUM_PROCESSORS];
} PPM_SIMULATED_PROCESSOR_LOAD, *PPPM_SIMULATED_PROCESSOR_LOAD;

typedef struct {
    ULONG   Frequency;
    ULONG   Flags;
    ULONG   PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

typedef struct {
    ULONG Latency;
    ULONG Power;
    ULONG TimeCheck;
    UCHAR PromotePercent;
    UCHAR DemotePercent;
    UCHAR StateType;
    UCHAR Reserved;
    ULONG StateFlags;
    ULONG Context;
    ULONG IdleHandler;
    ULONG Reserved1;            // reserved for future use
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

typedef struct {
    ULONG Type;
    ULONG Count;
    ULONG TargetState;          // current idle state
    ULONG OldState;             // previous idle state
    ULONG64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[ANYSIZE_ARRAY];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

typedef struct {
    ULONG Frequency;            // in Mhz
    ULONG Power;                // in milliwatts
    UCHAR PercentFrequency;
    UCHAR IncreaseLevel;        // goto higher state
    UCHAR DecreaseLevel;        // goto lower state
    UCHAR Type;                 // performance or throttle
    ULONG IncreaseTime;         // in tick counts
    ULONG DecreaseTime;         // in tick counts
    ULONG64 Control;            // control value
    ULONG64 Status;             // control value
    ULONG HitCount;
    ULONG Reserved1;            // reserved for future use
    ULONG64 Reserved2;
    ULONG64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

typedef struct {
    ULONG Count;
    ULONG MaxFrequency;
    ULONG CurrentState;         // current state
    ULONG MaxPerfState;         // fastest state considering policy restrictions
    ULONG MinPerfState;         // slowest state considering policy restrictions
    ULONG LowestPerfState;      // slowest perf state, fixed, aka the "knee"
    ULONG ThermalConstraint;
    UCHAR BusyAdjThreshold;
    UCHAR PolicyType;           // domain coordination
    UCHAR Type;
    UCHAR Reserved;
    ULONG TimerInterval;
    ULONG64 TargetProcessors;   // domain affinity
    ULONG PStateHandler;
    ULONG PStateContext;
    ULONG TStateHandler;
    ULONG TStateContext;
    ULONG FeedbackHandler;
    ULONG Reserved1;
    ULONG64 Reserved2;
    PPM_WMI_PERF_STATE State[ANYSIZE_ARRAY];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

//
// Accounting info.
//

#define PROC_IDLE_BUCKET_COUNT  6

typedef struct {
    ULONG IdleTransitions;
    ULONG FailedTransitions;
    ULONG InvalidBucketIndex;
    ULONG64 TotalTime;
    ULONG IdleTimeBuckets[PROC_IDLE_BUCKET_COUNT];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

typedef struct {
    ULONG StateCount;
    ULONG TotalTransitions;
    ULONG ResetCount;
    ULONG64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[ANYSIZE_ARRAY];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;

//
// Definitions of coordination types for _PSD, _TSD, and _CSD BIOS objects from
// the Acpi 3.0 specification
//

#define ACPI_PPM_SOFTWARE_ALL     0xFC
#define ACPI_PPM_SOFTWARE_ANY     0xFD
#define ACPI_PPM_HARDWARE_ALL     0xFE

//
// Definition of Microsoft PPM coordination types.
//

#define MS_PPM_SOFTWARE_ALL       0x1



//
// Processor Power Management WMI interface.
//

// {A5B32DDD-7F39-4abc-B892-900E43B59EBB}
DEFINE_GUID(PPM_PERFSTATE_CHANGE_GUID,
0xa5b32ddd, 0x7f39, 0x4abc, 0xb8, 0x92, 0x90, 0xe, 0x43, 0xb5, 0x9e, 0xbb);

// {995e6b7f-d653-497a-b978-36a30c29bf01}
DEFINE_GUID(PPM_PERFSTATE_DOMAIN_CHANGE_GUID,
0x995e6b7f, 0xd653, 0x497a, 0xb9, 0x78, 0x36, 0xa3, 0xc, 0x29, 0xbf, 0x1);

// {4838fe4f-f71c-4e51-9ecc-8430a7ac4c6c}
DEFINE_GUID(PPM_IDLESTATE_CHANGE_GUID,
0x4838fe4f, 0xf71c, 0x4e51, 0x9e, 0xcc, 0x84, 0x30, 0xa7, 0xac, 0x4c, 0x6c);

// {5708cc20-7d40-4bf4-b4aa-2b01338d0126}
DEFINE_GUID(PPM_PERFSTATES_DATA_GUID,
0x5708cc20, 0x7d40, 0x4bf4, 0xb4, 0xaa, 0x2b, 0x01, 0x33, 0x8d, 0x01, 0x26);

// {ba138e10-e250-4ad7-8616-cf1a7ad410e7}
DEFINE_GUID(PPM_IDLESTATES_DATA_GUID,
0xba138e10, 0xe250, 0x4ad7, 0x86, 0x16, 0xcf, 0x1a, 0x7a, 0xd4, 0x10, 0xe7);

// {e2a26f78-ae07-4ee0-a30f-ce354f5a94cd}
DEFINE_GUID(PPM_IDLE_ACCOUNTING_GUID,
0xe2a26f78, 0xae07, 0x4ee0, 0xa3, 0x0f, 0xce, 0x54, 0xf5, 0x5a, 0x94, 0xcd);

// {a852c2c8-1a4c-423b-8c2c-f30d82931a88}
DEFINE_GUID(PPM_THERMALCONSTRAINT_GUID,
0xa852c2c8, 0x1a4c, 0x423b, 0x8c, 0x2c, 0xf3, 0x0d, 0x82, 0x93, 0x1a, 0x88);

// {7fd18652-0cfe-40d2-b0a1-0b066a87759e}
DEFINE_GUID(PPM_PERFMON_PERFSTATE_GUID,
0x7fd18652, 0xcfe, 0x40d2, 0xb0, 0xa1, 0xb, 0x6, 0x6a, 0x87, 0x75, 0x9e);

// {48f377b8-6880-4c7b-8bdc-380176c6654d}
DEFINE_GUID(PPM_THERMAL_POLICY_CHANGE_GUID,
0x48f377b8, 0x6880, 0x4c7b, 0x8b, 0xdc, 0x38, 0x1, 0x76, 0xc6, 0x65, 0x4d);


typedef struct {
    ULONG State;
    ULONG Status;
    ULONG Latency;
    ULONG Speed;
    ULONG Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

typedef struct {
    ULONG State;
    ULONG Latency;
    ULONG Speed;
    ULONG64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

typedef struct {
    ULONG NewState;
    ULONG OldState;
    ULONG64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

typedef struct {
    ULONG ThermalConstraint;
    ULONG64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable:4121)

typedef struct {
    UCHAR Mode;
    ULONG64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)

// Power Policy Management interfaces
//

typedef struct {
    POWER_ACTION    Action;
    ULONG           Flags;
    ULONG           EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;

// POWER_ACTION_POLICY->Flags:
#define POWER_ACTION_QUERY_ALLOWED      0x00000001
#define POWER_ACTION_UI_ALLOWED         0x00000002
#define POWER_ACTION_OVERRIDE_APPS      0x00000004
#define POWER_ACTION_PSEUDO_TRANSITION  0x08000000
#define POWER_ACTION_LIGHTEST_FIRST     0x10000000
#define POWER_ACTION_LOCK_CONSOLE       0x20000000
#define POWER_ACTION_DISABLE_WAKES      0x40000000
#define POWER_ACTION_CRITICAL           0x80000000

// POWER_ACTION_POLICY->EventCode flags
#define POWER_LEVEL_USER_NOTIFY_TEXT    0x00000001
#define POWER_LEVEL_USER_NOTIFY_SOUND   0x00000002
#define POWER_LEVEL_USER_NOTIFY_EXEC    0x00000004
#define POWER_USER_NOTIFY_BUTTON        0x00000008
#define POWER_USER_NOTIFY_SHUTDOWN      0x00000010
#define POWER_FORCE_TRIGGER_RESET       0x80000000

// Note: for battery alarm EventCodes, the ID of the battery alarm << 16 is ORed
// into the flags.  For example: DISCHARGE_POLICY_LOW << 16

//
// The GUID_BATTERY_DISCHARGE_FLAGS_x power settings use a subset of EventCode
// flags.  The POWER_FORCE_TRIGGER_RESET flag doesn't make sense for a battery
// alarm so it is overloaded for other purposes (gerneral enable/disable).
#define BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK  0x00000007
#define BATTERY_DISCHARGE_FLAGS_ENABLE  0x80000000

// system battery drain policies
typedef struct {
    BOOLEAN                 Enable;
    UCHAR                   Spare[3];
    ULONG                   BatteryLevel;
    POWER_ACTION_POLICY     PowerPolicy;
    SYSTEM_POWER_STATE      MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;

// Discharge policy constants
#define NUM_DISCHARGE_POLICIES      4
#define DISCHARGE_POLICY_CRITICAL   0
#define DISCHARGE_POLICY_LOW        1


// system power policies
typedef struct _SYSTEM_POWER_POLICY {
    ULONG                   Revision;       // 1

    // events
    POWER_ACTION_POLICY     PowerButton;
    POWER_ACTION_POLICY     SleepButton;
    POWER_ACTION_POLICY     LidClose;
    SYSTEM_POWER_STATE      LidOpenWake;
    ULONG                   Reserved;

    // "system idle" detection
    POWER_ACTION_POLICY     Idle;
    ULONG                   IdleTimeout;
    UCHAR                   IdleSensitivity;

    UCHAR                   DynamicThrottle;
    UCHAR                   Spare2[2];

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;
    SYSTEM_POWER_STATE      ReducedLatencySleep;
    ULONG                   WinLogonFlags;

    ULONG                   Spare3;

    // parameters for dozing
    //
    ULONG                   DozeS4Timeout;

    // battery policies
    ULONG                   BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL      DischargePolicy[NUM_DISCHARGE_POLICIES];

    // video policies
    ULONG                   VideoTimeout;
    BOOLEAN                 VideoDimDisplay;
    ULONG                   VideoReserved[3];

    // hard disk policies
    ULONG                   SpindownTimeout;

    // processor policies
    BOOLEAN                 OptimizeForPower;
    UCHAR                   FanThrottleTolerance;
    UCHAR                   ForcedThrottle;
    UCHAR                   MinThrottle;
    POWER_ACTION_POLICY     OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;


// processor power policy state

//
// Processor Idle State Policy.
//

#define PROCESSOR_IDLESTATE_POLICY_COUNT 0x3

typedef struct {
    ULONG TimeCheck;
    UCHAR DemotePercent;
    UCHAR PromotePercent;
    UCHAR Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

typedef struct {
    USHORT Revision;
    union {
        USHORT AsUSHORT;
        struct {
            USHORT AllowScaling : 1;
            USHORT Disabled : 1;
            USHORT Reserved : 14;
        } DUMMYSTRUCTNAME;
    } Flags;

    ULONG PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[PROCESSOR_IDLESTATE_POLICY_COUNT];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;

//
// Legacy Processor Policy.  This is only provided to allow legacy
// applications to compile.  New applications must use
// PROCESSOR_IDLESTATE_POLICY.
//

#define PO_THROTTLE_NONE            0
#define PO_THROTTLE_CONSTANT        1
#define PO_THROTTLE_DEGRADE         2
#define PO_THROTTLE_ADAPTIVE        3
#define PO_THROTTLE_MAXIMUM         4   // not a policy, just a limit


typedef struct _PROCESSOR_POWER_POLICY_INFO {

    // Time based information (will be converted to kernel units)
    ULONG                   TimeCheck;                      // in US
    ULONG                   DemoteLimit;                    // in US
    ULONG                   PromoteLimit;                   // in US

    // Percentage based information
    UCHAR                   DemotePercent;
    UCHAR                   PromotePercent;
    UCHAR                   Spare[2];

    // Flags
    ULONG                   AllowDemotion:1;
    ULONG                   AllowPromotion:1;
    ULONG                   Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;

// processor power policy
typedef struct _PROCESSOR_POWER_POLICY {
    ULONG                       Revision;       // 1

    // Dynamic Throttling Policy
    UCHAR                       DynamicThrottle;
    UCHAR                       Spare[3];

    // Flags
    ULONG                       DisableCStates:1;
    ULONG                       Reserved:31;

    // System policy information
    // The Array is last, in case it needs to be grown and the structure
    // revision incremented.
    ULONG                       PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;

//
// Processor Perf State Policy.
//

#define PERFSTATE_POLICY_CHANGE_IDEAL  0x00
#define PERFSTATE_POLICY_CHANGE_SINGLE 0x01
#define PERFSTATE_POLICY_CHANGE_ROCKET 0x02
#define PERFSTATE_POLICY_CHANGE_MAX PERFSTATE_POLICY_CHANGE_ROCKET

typedef struct {
    ULONG Revision;
    UCHAR MaxThrottle;
    UCHAR MinThrottle;
    UCHAR BusyAdjThreshold;
    union {
        UCHAR Spare;
        union {
            UCHAR AsUCHAR;
            struct {
                UCHAR NoDomainAccounting : 1;
                UCHAR IncreasePolicy: 2;
                UCHAR DecreasePolicy: 2;
                UCHAR Reserved : 3;
            } DUMMYSTRUCTNAME;
        } Flags;
    } DUMMYUNIONNAME;
    
    ULONG TimeCheck;
    ULONG IncreaseTime;
    ULONG DecreaseTime;
    ULONG IncreasePercent;
    ULONG DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;

// administrator power policy overrides
typedef struct _ADMINISTRATOR_POWER_POLICY {

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;

    // video policies
    ULONG                   MinVideoTimeout;
    ULONG                   MaxVideoTimeout;

    // disk policies
    ULONG                   MinSpindownTimeout;
    ULONG                   MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;



// end_winnt

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetThreadExecutionState(
    __in EXECUTION_STATE esFlags,               // ES_xxx flags
    __out EXECUTION_STATE *PreviousFlags
    );

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestWakeupLatency(
    __in LATENCY_TIME latency
    );

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitiatePowerAction(
    __in POWER_ACTION SystemAction,
    __in SYSTEM_POWER_STATE MinSystemState,
    __in ULONG Flags,                 // POWER_ACTION_xxx flags
    __in BOOLEAN Asynchronous
    );


__kernel_entry NTSYSCALLAPI                        // only called by WinLogon
NTSTATUS
NTAPI
NtSetSystemPowerState(
    __in POWER_ACTION SystemAction,
    __in SYSTEM_POWER_STATE MinSystemState,
    __in ULONG Flags                  // POWER_ACTION_xxx flags
    );

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetDevicePowerState(
    __in HANDLE Device,
    __out DEVICE_POWER_STATE *State
    );

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelDeviceWakeupRequest(
    __in HANDLE Device
    );

__kernel_entry NTSYSCALLAPI
BOOLEAN
NTAPI
NtIsSystemResumeAutomatic(
    VOID
    );

__kernel_entry NTSYSCALLAPI
NTSTATUS
NTAPI
NtRequestDeviceWakeup(
    __in HANDLE Device
    );


// WinLogonFlags:
#define WINLOGON_LOCK_ON_SLEEP  0x00000001


// begin_winnt

typedef struct {
    // Misc supported system features
    BOOLEAN             PowerButtonPresent;
    BOOLEAN             SleepButtonPresent;
    BOOLEAN             LidPresent;
    BOOLEAN             SystemS1;
    BOOLEAN             SystemS2;
    BOOLEAN             SystemS3;
    BOOLEAN             SystemS4;           // hibernate
    BOOLEAN             SystemS5;           // off
    BOOLEAN             HiberFilePresent;
    BOOLEAN             FullWake;
    BOOLEAN             VideoDimPresent;
    BOOLEAN             ApmPresent;
    BOOLEAN             UpsPresent;

    // Processors
    BOOLEAN             ThermalControl;
    BOOLEAN             ProcessorThrottle;
    UCHAR               ProcessorMinThrottle;

#if (NTDDI_VERSION < NTDDI_WINXP)
    UCHAR               ProcessorThrottleScale;
    UCHAR               spare2[4];
#else
    UCHAR               ProcessorMaxThrottle;
    BOOLEAN             FastSystemS4;
    UCHAR               spare2[3];
#endif // (NTDDI_VERSION < NTDDI_WINXP)

    // Disk
    BOOLEAN             DiskSpinDown;
    UCHAR               spare3[8];

    // System Battery
    BOOLEAN             SystemBatteriesPresent;
    BOOLEAN             BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];

    // Wake
    SYSTEM_POWER_STATE  AcOnLineWake;
    SYSTEM_POWER_STATE  SoftLidWake;
    SYSTEM_POWER_STATE  RtcWake;
    SYSTEM_POWER_STATE  MinDeviceWakeState; // note this may change on driver load
    SYSTEM_POWER_STATE  DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN             AcOnLine;
    BOOLEAN             BatteryPresent;
    BOOLEAN             Charging;
    BOOLEAN             Discharging;
    BOOLEAN             Spare1[4];

    ULONG               MaxCapacity;
    ULONG               RemainingCapacity;
    ULONG               Rate;
    ULONG               EstimatedTime;

    ULONG               DefaultAlert1;
    ULONG               DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;

// end_winnt

//
// valid flags for SYSTEM_POWER_STATE_DISABLE_REASON.PowerReasonCode
//
#define SPSD_REASON_NONE                        0x00000000
#define SPSD_REASON_NOBIOSSUPPORT               0x00000001
#define SPSD_REASON_BIOSINCOMPATIBLE            0x00000002
#define SPSD_REASON_NOOSPM                      0x00000003
#define SPSD_REASON_LEGACYDRIVER                0x00000004
#define SPSD_REASON_HIBERSTACK                  0x00000005
#define SPSD_REASON_HIBERFILE                   0x00000006
#define SPSD_REASON_POINTERNAL                  0x00000007
#define SPSD_REASON_MEMORYLIMIT                 0x00000008
#define SPSD_REASON_MPOVERRIDE                  0x00000009
#define SPSD_REASON_DRIVERDOWNGRADE             0x0000000A
#define SPSD_REASON_PREVIOUSATTEMPTFAILED       0x0000000B
#define SPSD_REASON_UNKNOWN                     0x0000000C
#define SPSD_REASON_INTERNALLYDISABLED          0x0000000D
#define SPSD_REASON_DISABLEDBYPOLICY            0x0000000E

typedef struct _SYSTEM_POWER_STATE_DISABLE_REASON {
    BOOLEAN AffectedState[POWER_STATE_HANDLER_TYPE_MAX];
    ULONG PowerReasonCode;
    ULONG PowerReasonLength;
    //UCHAR PowerReasonInfo[ANYSIZE_ARRAY];
} SYSTEM_POWER_STATE_DISABLE_REASON, *PSYSTEM_POWER_STATE_DISABLE_REASON;

//
// valid flags for SYSTEM_POWER_LOGGING_ENTRY.LoggingType
//
#define LOGGING_TYPE_SPSD                       0x00000001
#define LOGGING_TYPE_POWERTRANSITION            0x00000002

typedef struct _SYSTEM_POWER_LOGGING_ENTRY {
        ULONG LoggingType;
        PVOID LoggingEntry;
} SYSTEM_POWER_LOGGING_ENTRY, *PSYSTEM_POWER_LOGGING_ENTRY;

#if (NTDDI_VERSION < NTDDI_WINXP) // win2k only

//
// Power structure in each processors PRCB
//
struct _PROCESSOR_POWER_STATE;      // forward ref

typedef
VOID
(FASTCALL *PPROCESSOR_IDLE_FUNCTION) (
    struct _PROCESSOR_POWER_STATE   *PState
    );

typedef struct _PROCESSOR_POWER_STATE {
    PPROCESSOR_IDLE_FUNCTION    IdleFunction;
    ULONG                       Idle0KernelTimeLimit;
    ULONG                       Idle0LastTime;

    PVOID                       IdleState;
    ULONGLONG                   LastCheck;
    PROCESSOR_IDLE_TIMES        IdleTimes;

    ULONG                       IdleTime1;
    ULONG                       PromotionCheck;
    ULONG                       IdleTime2;

    UCHAR                       CurrentThrottle;    // current throttle setting
    UCHAR                       ThrottleLimit;      // max available throttle setting
    UCHAR                       Spare1[2];

    ULONG                       SetMember;
    PVOID                       AbortThrottle;

// temp for debugging
    ULONGLONG                   DebugDelta;
    ULONG                       DebugCount;

    ULONG                       LastSysTime;
    ULONG                       Spare2[10];
} PROCESSOR_POWER_STATE, *PPROCESSOR_POWER_STATE;

#endif // (NTDDI_VERSION < NTDDI_WINXP)

typedef struct _PROCESSOR_POWER_INFORMATION {
    ULONG                   Number;
    ULONG                   MaxMhz;
    ULONG                   CurrentMhz;
    ULONG                   MhzLimit;
    ULONG                   MaxIdleState;
    ULONG                   CurrentIdleState;
} PROCESSOR_POWER_INFORMATION, *PPROCESSOR_POWER_INFORMATION;

typedef struct _SYSTEM_POWER_INFORMATION {
    ULONG                   MaxIdlenessAllowed;
    ULONG                   Idleness;
    ULONG                   TimeRemaining;
    UCHAR                   CoolingMode;
} SYSTEM_POWER_INFORMATION, *PSYSTEM_POWER_INFORMATION;

// end_nthal

typedef struct _SYSTEM_HIBERFILE_INFORMATION {
    ULONG NumberOfMcbPairs;
    LARGE_INTEGER Mcb[1];
} SYSTEM_HIBERFILE_INFORMATION, *PSYSTEM_HIBERFILE_INFORMATION;

#ifdef __cplusplus
}
#endif

#endif // _NTPOAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntnls.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntnls.h

Abstract:

    NLS file formats and data types


Revision History:

--*/

#ifndef _NTNLS_
#define _NTNLS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define MAXIMUM_LEADBYTES   12

typedef struct _CPTABLEINFO {
    USHORT CodePage;                    // code page number
    USHORT MaximumCharacterSize;        // max length (bytes) of a char
    USHORT DefaultChar;                 // default character (MB)
    USHORT UniDefaultChar;              // default character (Unicode)
    USHORT TransDefaultChar;            // translation of default char (Unicode)
    USHORT TransUniDefaultChar;         // translation of Unic default char (MB)
    USHORT DBCSCodePage;                // Non 0 for DBCS code pages
    UCHAR  LeadByte[MAXIMUM_LEADBYTES]; // lead byte ranges
    PUSHORT MultiByteTable;             // pointer to MB translation table
    PVOID   WideCharTable;              // pointer to WC translation table
    PUSHORT DBCSRanges;                 // pointer to DBCS ranges
    PUSHORT DBCSOffsets;                // pointer to DBCS offsets
} CPTABLEINFO, *PCPTABLEINFO;

typedef struct _NLSTABLEINFO {
    CPTABLEINFO OemTableInfo;
    CPTABLEINFO AnsiTableInfo;
    PUSHORT UpperCaseTable;             // 844 format upcase table
    PUSHORT LowerCaseTable;             // 844 format lower case table
} NLSTABLEINFO, *PNLSTABLEINFO;

#ifdef __cplusplus
}
#endif

#endif // _NTNLS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntsam.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ntsam.h

Abstract:

    This module describes the data types and procedure prototypes
    that make up the NT Security Accounts Manager. This includes
    API's exported by SAM and related subsystems.

Author:

--*/

#ifndef _NTSAM_
#define _NTSAM_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PPULONG
typedef PULONG *PPULONG;
#endif  //PPULONG

//
// An attempt to lookup more than this number of names or SIDs in
// a single call will be rejected with an INSUFFICIENT_RESOURCES
// status.
//

#define SAM_MAXIMUM_LOOKUP_COUNT    (1000)


//
// An attempt to pass names totalling more than the following number
// of bytes in length will be rejected with an INSUFFICIENT_RESOURCES
// status.
//

#define SAM_MAXIMUM_LOOKUP_LENGTH   (32000)

//
// An attempt to set a password longer than this number of characters
// will fail.
//

#define SAM_MAX_PASSWORD_LENGTH     (256)


//
// Length of the salt used in the clear password encryption
//

#define SAM_PASSWORD_ENCRYPTION_SALT_LEN  (16)






#ifndef _NTSAM_SAM_HANDLE_               // ntsubauth
typedef PVOID SAM_HANDLE, *PSAM_HANDLE;  // ntsubauth
#define _NTSAM_SAM_HANDLE_               // ntsubauth
#endif                                   // ntsubauth

typedef ULONG SAM_ENUMERATE_HANDLE, *PSAM_ENUMERATE_HANDLE;

typedef struct _SAM_RID_ENUMERATION {
    ULONG RelativeId;
    UNICODE_STRING Name;
} SAM_RID_ENUMERATION, *PSAM_RID_ENUMERATION;

typedef struct _SAM_SID_ENUMERATION {
    PSID Sid;
    UNICODE_STRING Name;
} SAM_SID_ENUMERATION, *PSAM_SID_ENUMERATION;

#ifdef MIDL_PASS
#define SIZE_IS(x)      [size_is(x)]
#define SWITCH_IS(x)    [switch_is(x)]
#define SWITCH_TYPE(x)  [switch_type(x)]
#define CASE(x)         [case(x)]
#define RANGE(x,y)      [range(x,y)]
#define VAR_SIZE_ARRAY
#else
#define SIZE_IS(x)
#define SWITCH_IS(x)
#define SWITCH_TYPE(x)
#define CASE(x)
#define RANGE(x,y)      __in_range(x,y)
#define VAR_SIZE_ARRAY  (1)
#endif

typedef struct _SAM_BYTE_ARRAY {

                            ULONG   Size;
    SIZE_IS( Size )         PUCHAR  Data;

} SAM_BYTE_ARRAY, *PSAM_BYTE_ARRAY;

typedef struct _SAM_BYTE_ARRAY_32K {

    RANGE( 0, MAXSHORT )    ULONG   Size;
    SIZE_IS( Size )         PUCHAR  Data;

} SAM_BYTE_ARRAY_32K, *PSAM_BYTE_ARRAY_32K;

typedef SAM_BYTE_ARRAY_32K  SAM_SHELL_OBJECT_PROPERTIES, *PSAM_SHELL_OBJECT_PROPERTIES;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// obsolete well-known account names.                                      //
// These became obsolete with the flexadmin model.                         //
// These will be deleted shortly - DON'T USE THESE                         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define DOMAIN_ADMIN_USER_NAME         "ADMIN"
#define DOMAIN_ADMIN_NAME              "D_ADMIN"
#define DOMAIN_ADMIN_NAMEW             L"D_ADMIN"
#define DOMAIN_USERS_NAME              "D_USERS"
#define DOMAIN_USERS_NAMEW             L"D_USERS"
#define DOMAIN_GUESTS_NAME             "D_GUESTS"
#define DOMAIN_ACCOUNT_OPERATORS_NAME  "D_ACCOUN"
#define DOMAIN_ACCOUNT_OPERATORS_NAMEW L"D_ACCOUN"
#define DOMAIN_SERVER_OPERATORS_NAME   "D_SERVER"
#define DOMAIN_SERVER_OPERATORS_NAMEW L"D_SERVER"
#define DOMAIN_PRINT_OPERATORS_NAME    "D_PRINT"
#define DOMAIN_PRINT_OPERATORS_NAMEW  L"D_PRINT"
#define DOMAIN_COMM_OPERATORS_NAME     "D_COMM"
#define DOMAIN_COMM_OPERATORS_NAMEW   L"D_COMM"
#define DOMAIN_BACKUP_OPERATORS_NAME   "D_BACKUP"
#define DOMAIN_RESTORE_OPERATORS_NAME  "D_RESTOR"





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Server Object Related Definitions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Access rights for server object
//

#define SAM_SERVER_CONNECT               0x0001
#define SAM_SERVER_SHUTDOWN              0x0002
#define SAM_SERVER_INITIALIZE            0x0004
#define SAM_SERVER_CREATE_DOMAIN         0x0008
#define SAM_SERVER_ENUMERATE_DOMAINS     0x0010
#define SAM_SERVER_LOOKUP_DOMAIN         0x0020


#define SAM_SERVER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED     |\
                               SAM_SERVER_CONNECT           |\
                               SAM_SERVER_INITIALIZE        |\
                               SAM_SERVER_CREATE_DOMAIN     |\
                               SAM_SERVER_SHUTDOWN          |\
                               SAM_SERVER_ENUMERATE_DOMAINS |\
                               SAM_SERVER_LOOKUP_DOMAIN)

#define SAM_SERVER_READ       (STANDARD_RIGHTS_READ         |\
                               SAM_SERVER_ENUMERATE_DOMAINS)

#define SAM_SERVER_WRITE      (STANDARD_RIGHTS_WRITE        |\
                               SAM_SERVER_INITIALIZE        |\
                               SAM_SERVER_CREATE_DOMAIN     |\
                               SAM_SERVER_SHUTDOWN)

#define SAM_SERVER_EXECUTE    (STANDARD_RIGHTS_EXECUTE      |\
                               SAM_SERVER_CONNECT           |\
                               SAM_SERVER_LOOKUP_DOMAIN)






///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Domain Object Related Definitions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// Access rights for domain object
//

#define DOMAIN_READ_PASSWORD_PARAMETERS  0x0001
#define DOMAIN_WRITE_PASSWORD_PARAMS     0x0002
#define DOMAIN_READ_OTHER_PARAMETERS     0x0004
#define DOMAIN_WRITE_OTHER_PARAMETERS    0x0008
#define DOMAIN_CREATE_USER               0x0010
#define DOMAIN_CREATE_GROUP              0x0020
#define DOMAIN_CREATE_ALIAS              0x0040
#define DOMAIN_GET_ALIAS_MEMBERSHIP      0x0080
#define DOMAIN_LIST_ACCOUNTS             0x0100
#define DOMAIN_LOOKUP                    0x0200
#define DOMAIN_ADMINISTER_SERVER         0x0400

#define DOMAIN_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED         |\
                           DOMAIN_READ_OTHER_PARAMETERS     |\
                           DOMAIN_WRITE_OTHER_PARAMETERS    |\
                           DOMAIN_WRITE_PASSWORD_PARAMS     |\
                           DOMAIN_CREATE_USER               |\
                           DOMAIN_CREATE_GROUP              |\
                           DOMAIN_CREATE_ALIAS              |\
                           DOMAIN_GET_ALIAS_MEMBERSHIP      |\
                           DOMAIN_LIST_ACCOUNTS             |\
                           DOMAIN_READ_PASSWORD_PARAMETERS  |\
                           DOMAIN_LOOKUP                    |\
                           DOMAIN_ADMINISTER_SERVER)

#define DOMAIN_READ        (STANDARD_RIGHTS_READ            |\
                           DOMAIN_GET_ALIAS_MEMBERSHIP      |\
                           DOMAIN_READ_OTHER_PARAMETERS)


#define DOMAIN_WRITE       (STANDARD_RIGHTS_WRITE           |\
                           DOMAIN_WRITE_OTHER_PARAMETERS    |\
                           DOMAIN_WRITE_PASSWORD_PARAMS     |\
                           DOMAIN_CREATE_USER               |\
                           DOMAIN_CREATE_GROUP              |\
                           DOMAIN_CREATE_ALIAS              |\
                           DOMAIN_ADMINISTER_SERVER)

#define DOMAIN_EXECUTE     (STANDARD_RIGHTS_EXECUTE         |\
                           DOMAIN_READ_PASSWORD_PARAMETERS  |\
                           DOMAIN_LIST_ACCOUNTS             |\
                           DOMAIN_LOOKUP)



//
// Normal modifications cause a domain's ModifiedCount to be
// incremented by 1.  Domain promotion to Primary domain controller
// cause the ModifiedCount to be incremented by the following
// amount.  This causes the upper 24-bits of the ModifiedCount
// to be a promotion count and the lower 40-bits as a modification
// count.
//

#define DOMAIN_PROMOTION_INCREMENT      {0x0,0x10}
#define DOMAIN_PROMOTION_MASK           {0x0,0xFFFFFFF0}

//
// Domain information classes and their corresponding data structures
//

typedef enum _DOMAIN_INFORMATION_CLASS {
    DomainPasswordInformation = 1,
    DomainGeneralInformation,
    DomainLogoffInformation,
    DomainOemInformation,
    DomainNameInformation,
    DomainReplicationInformation,
    DomainServerRoleInformation,
    DomainModifiedInformation,
    DomainStateInformation,
    DomainUasInformation,
    DomainGeneralInformation2,
    DomainLockoutInformation,
    DomainModifiedInformation2
} DOMAIN_INFORMATION_CLASS;

typedef enum _DOMAIN_SERVER_ENABLE_STATE {
    DomainServerEnabled = 1,
    DomainServerDisabled
} DOMAIN_SERVER_ENABLE_STATE, *PDOMAIN_SERVER_ENABLE_STATE;

typedef enum _DOMAIN_SERVER_ROLE {
    DomainServerRoleBackup = 2,
    DomainServerRolePrimary
} DOMAIN_SERVER_ROLE, *PDOMAIN_SERVER_ROLE;

#include "pshpack4.h"
typedef struct _DOMAIN_GENERAL_INFORMATION {
    LARGE_INTEGER ForceLogoff;
    UNICODE_STRING OemInformation;
    UNICODE_STRING DomainName;
    UNICODE_STRING ReplicaSourceNodeName;
    LARGE_INTEGER DomainModifiedCount;
    DOMAIN_SERVER_ENABLE_STATE DomainServerState;
    DOMAIN_SERVER_ROLE DomainServerRole;
    BOOLEAN UasCompatibilityRequired;
    ULONG UserCount;
    ULONG GroupCount;
    ULONG AliasCount;
} DOMAIN_GENERAL_INFORMATION, *PDOMAIN_GENERAL_INFORMATION;
#include "poppack.h"

#include "pshpack4.h"
typedef struct _DOMAIN_GENERAL_INFORMATION2 {

    DOMAIN_GENERAL_INFORMATION    I1;

    //
    // New fields added for this structure (NT1.0A).
    //

    LARGE_INTEGER               LockoutDuration;          //Must be a Delta time
    LARGE_INTEGER               LockoutObservationWindow; //Must be a Delta time
    USHORT                      LockoutThreshold;
} DOMAIN_GENERAL_INFORMATION2, *PDOMAIN_GENERAL_INFORMATION2;
#include "poppack.h"

typedef struct _DOMAIN_UAS_INFORMATION {
    BOOLEAN UasCompatibilityRequired;
} DOMAIN_UAS_INFORMATION;

//
// This needs to be guarded, because ntsecapi.h is a generated
// public file, and ntsam.h is an internal file, but people like
// to mix and match them anyway.
//

// begin_ntsecapi
#ifndef _DOMAIN_PASSWORD_INFORMATION_DEFINED
#define _DOMAIN_PASSWORD_INFORMATION_DEFINED
typedef struct _DOMAIN_PASSWORD_INFORMATION {
    USHORT MinPasswordLength;
    USHORT PasswordHistoryLength;
    ULONG PasswordProperties;
#if defined(MIDL_PASS)
    OLD_LARGE_INTEGER MaxPasswordAge;
    OLD_LARGE_INTEGER MinPasswordAge;
#else
    LARGE_INTEGER MaxPasswordAge;
    LARGE_INTEGER MinPasswordAge;
#endif
} DOMAIN_PASSWORD_INFORMATION, *PDOMAIN_PASSWORD_INFORMATION;
#endif

#if (_WIN32_WINNT >= 0x0501)
//
// PasswordProperties flags
//

#define DOMAIN_PASSWORD_COMPLEX             0x00000001L
#define DOMAIN_PASSWORD_NO_ANON_CHANGE      0x00000002L
#define DOMAIN_PASSWORD_NO_CLEAR_CHANGE     0x00000004L
#define DOMAIN_LOCKOUT_ADMINS               0x00000008L
#define DOMAIN_PASSWORD_STORE_CLEARTEXT     0x00000010L
#define DOMAIN_REFUSE_PASSWORD_CHANGE       0x00000020L
#if(_WIN32_WINNT >= 0x0502)
#define DOMAIN_NO_LM_OWF_CHANGE             0x00000040L
#endif
#endif

// end_ntsecapi

typedef enum _DOMAIN_PASSWORD_CONSTRUCTION {
    DomainPasswordSimple = 1,
    DomainPasswordComplex
} DOMAIN_PASSWORD_CONSTRUCTION;

typedef struct _DOMAIN_LOGOFF_INFORMATION {
#if defined(MIDL_PASS)
    OLD_LARGE_INTEGER ForceLogoff;
#else
    LARGE_INTEGER ForceLogoff;
#endif
} DOMAIN_LOGOFF_INFORMATION, *PDOMAIN_LOGOFF_INFORMATION;

typedef struct _DOMAIN_OEM_INFORMATION {
    UNICODE_STRING OemInformation;
} DOMAIN_OEM_INFORMATION, *PDOMAIN_OEM_INFORMATION;

typedef struct _DOMAIN_NAME_INFORMATION {
    UNICODE_STRING DomainName;
} DOMAIN_NAME_INFORMATION, *PDOMAIN_NAME_INFORMATION;

typedef struct _DOMAIN_SERVER_ROLE_INFORMATION {
    DOMAIN_SERVER_ROLE DomainServerRole;
} DOMAIN_SERVER_ROLE_INFORMATION, *PDOMAIN_SERVER_ROLE_INFORMATION;

typedef struct _DOMAIN_REPLICATION_INFORMATION {
    UNICODE_STRING ReplicaSourceNodeName;
} DOMAIN_REPLICATION_INFORMATION, *PDOMAIN_REPLICATION_INFORMATION;

typedef struct _DOMAIN_MODIFIED_INFORMATION {
#if defined(MIDL_PASS)
    OLD_LARGE_INTEGER DomainModifiedCount;
    OLD_LARGE_INTEGER CreationTime;
#else
    LARGE_INTEGER DomainModifiedCount;
    LARGE_INTEGER CreationTime;
#endif
} DOMAIN_MODIFIED_INFORMATION, *PDOMAIN_MODIFIED_INFORMATION;

typedef struct _DOMAIN_MODIFIED_INFORMATION2 {
#if defined(MIDL_PASS)
    OLD_LARGE_INTEGER DomainModifiedCount;
    OLD_LARGE_INTEGER CreationTime;
    OLD_LARGE_INTEGER ModifiedCountAtLastPromotion;
#else
    LARGE_INTEGER DomainModifiedCount;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER ModifiedCountAtLastPromotion;
#endif
} DOMAIN_MODIFIED_INFORMATION2, *PDOMAIN_MODIFIED_INFORMATION2;

typedef struct _DOMAIN_STATE_INFORMATION {
    DOMAIN_SERVER_ENABLE_STATE DomainServerState;
} DOMAIN_STATE_INFORMATION, *PDOMAIN_STATE_INFORMATION;

typedef struct _DOMAIN_LOCKOUT_INFORMATION {
#if defined(MIDL_PASS)
    OLD_LARGE_INTEGER           LockoutDuration;          //Must be a Delta time
    OLD_LARGE_INTEGER           LockoutObservationWindow; //Must be a Delta time
#else
    LARGE_INTEGER               LockoutDuration;          //Must be a Delta time
    LARGE_INTEGER               LockoutObservationWindow; //Must be a Delta time
#endif
    USHORT                      LockoutThreshold;         //Zero means no lockout
} DOMAIN_LOCKOUT_INFORMATION, *PDOMAIN_LOCKOUT_INFORMATION;


//
// Types used by the SamQueryDisplayInformation API
//

typedef enum _DOMAIN_DISPLAY_INFORMATION {
    DomainDisplayUser = 1,
    DomainDisplayMachine,
    DomainDisplayGroup,         // Added in NT1.0A
    DomainDisplayOemUser,       // Added in NT1.0A
    DomainDisplayOemGroup,      // Added in NT1.0A
    DomainDisplayServer         // Added in NT5 to support query of servers
} DOMAIN_DISPLAY_INFORMATION, *PDOMAIN_DISPLAY_INFORMATION;


typedef struct _DOMAIN_DISPLAY_USER {
    ULONG           Index;
    ULONG           Rid;
    ULONG           AccountControl;
    UNICODE_STRING  LogonName;
    UNICODE_STRING  AdminComment;
    UNICODE_STRING  FullName;
} DOMAIN_DISPLAY_USER, *PDOMAIN_DISPLAY_USER;

typedef struct _DOMAIN_DISPLAY_MACHINE {
    ULONG           Index;
    ULONG           Rid;
    ULONG           AccountControl;
    UNICODE_STRING  Machine;
    UNICODE_STRING  Comment;
} DOMAIN_DISPLAY_MACHINE, *PDOMAIN_DISPLAY_MACHINE;

typedef struct _DOMAIN_DISPLAY_GROUP {      // Added in NT1.0A
    ULONG           Index;
    ULONG           Rid;
    ULONG           Attributes;
    UNICODE_STRING  Group;
    UNICODE_STRING  Comment;
} DOMAIN_DISPLAY_GROUP, *PDOMAIN_DISPLAY_GROUP;

typedef struct _DOMAIN_DISPLAY_OEM_USER {      // Added in NT1.0A
    ULONG           Index;
    OEM_STRING     User;
} DOMAIN_DISPLAY_OEM_USER, *PDOMAIN_DISPLAY_OEM_USER;

typedef struct _DOMAIN_DISPLAY_OEM_GROUP {      // Added in NT1.0A
    ULONG           Index;
    OEM_STRING     Group;
} DOMAIN_DISPLAY_OEM_GROUP, *PDOMAIN_DISPLAY_OEM_GROUP;

//
// Types for SamQueryLocalizableAccountsInDomain
//

typedef enum _DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION {
    DomainLocalizableAccountsBasic = 1,
} DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION, *PDOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION;

typedef struct _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY {
    ULONG           Rid;
    SID_NAME_USE    Use;
    UNICODE_STRING  Name;
    UNICODE_STRING  AdminComment;
} DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY, *PDOMAIN_LOCALIZABLE_ACCOUNT_ENTRY;

typedef struct _DOMAIN_LOCALIZABLE_ACCOUNTS {
    ULONG                             Count;
#ifdef MIDL_PASS
    [size_is(Count)]
#endif
    DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY  *Entries;
} DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC, *PDOMAIN_LOCALIZABLE_ACCOUNTS_BASIC;


typedef
#ifdef MIDL_PASS
    [switch_type(DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION)]
#endif
    union _DOMAIN_LOCALIZABLE_INFO_BUFFER {
#ifdef MIDL_PASS
        [case(DomainLocalizableAccountsBasic)]
#endif
        DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC        Basic;
} DOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER, *PDOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Group Object Related Definitions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// Access rights for group object
//

#define GROUP_READ_INFORMATION           0x0001
#define GROUP_WRITE_ACCOUNT              0x0002
#define GROUP_ADD_MEMBER                 0x0004
#define GROUP_REMOVE_MEMBER              0x0008
#define GROUP_LIST_MEMBERS               0x0010

#define GROUP_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED  |\
                          GROUP_LIST_MEMBERS        |\
                          GROUP_WRITE_ACCOUNT       |\
                          GROUP_ADD_MEMBER          |\
                          GROUP_REMOVE_MEMBER       |\
                          GROUP_READ_INFORMATION)


#define GROUP_READ       (STANDARD_RIGHTS_READ      |\
                          GROUP_LIST_MEMBERS)


#define GROUP_WRITE      (STANDARD_RIGHTS_WRITE     |\
                          GROUP_WRITE_ACCOUNT       |\
                          GROUP_ADD_MEMBER          |\
                          GROUP_REMOVE_MEMBER)

#define GROUP_EXECUTE    (STANDARD_RIGHTS_EXECUTE   |\
                          GROUP_READ_INFORMATION)


//
// Group object types
//

typedef struct _GROUP_MEMBERSHIP {
    ULONG RelativeId;
    ULONG Attributes;
} GROUP_MEMBERSHIP, *PGROUP_MEMBERSHIP;


typedef enum _GROUP_INFORMATION_CLASS {
    GroupGeneralInformation = 1,
    GroupNameInformation,
    GroupAttributeInformation,
    GroupAdminCommentInformation,
    GroupReplicationInformation
} GROUP_INFORMATION_CLASS;

typedef struct _GROUP_GENERAL_INFORMATION {
    UNICODE_STRING Name;
    ULONG Attributes;
    ULONG MemberCount;
    UNICODE_STRING AdminComment;
} GROUP_GENERAL_INFORMATION,  *PGROUP_GENERAL_INFORMATION;

typedef struct _GROUP_NAME_INFORMATION {
    UNICODE_STRING Name;
} GROUP_NAME_INFORMATION, *PGROUP_NAME_INFORMATION;

typedef struct _GROUP_ATTRIBUTE_INFORMATION {
    ULONG Attributes;
} GROUP_ATTRIBUTE_INFORMATION, *PGROUP_ATTRIBUTE_INFORMATION;

typedef struct _GROUP_ADM_COMMENT_INFORMATION {
    UNICODE_STRING AdminComment;
} GROUP_ADM_COMMENT_INFORMATION, *PGROUP_ADM_COMMENT_INFORMATION;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Alias Object Related Definitions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Access rights for alias object
//

#define ALIAS_ADD_MEMBER                 0x0001
#define ALIAS_REMOVE_MEMBER              0x0002
#define ALIAS_LIST_MEMBERS               0x0004
#define ALIAS_READ_INFORMATION           0x0008
#define ALIAS_WRITE_ACCOUNT              0x0010

#define ALIAS_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED  |\
                          ALIAS_READ_INFORMATION    |\
                          ALIAS_WRITE_ACCOUNT       |\
                          ALIAS_LIST_MEMBERS        |\
                          ALIAS_ADD_MEMBER          |\
                          ALIAS_REMOVE_MEMBER)


#define ALIAS_READ       (STANDARD_RIGHTS_READ      |\
                          ALIAS_LIST_MEMBERS)


#define ALIAS_WRITE      (STANDARD_RIGHTS_WRITE     |\
                          ALIAS_WRITE_ACCOUNT       |\
                          ALIAS_ADD_MEMBER          |\
                          ALIAS_REMOVE_MEMBER)

#define ALIAS_EXECUTE    (STANDARD_RIGHTS_EXECUTE   |\
                          ALIAS_READ_INFORMATION)

//
// Alias object types
//

typedef enum _ALIAS_INFORMATION_CLASS {
    AliasGeneralInformation = 1,
    AliasNameInformation,
    AliasAdminCommentInformation,
    AliasReplicationInformation,
    AliasExtendedInformation,
} ALIAS_INFORMATION_CLASS;

typedef struct _ALIAS_GENERAL_INFORMATION {
    UNICODE_STRING Name;
    ULONG MemberCount;
    UNICODE_STRING AdminComment;
} ALIAS_GENERAL_INFORMATION,  *PALIAS_GENERAL_INFORMATION;

typedef struct _ALIAS_NAME_INFORMATION {
    UNICODE_STRING Name;
} ALIAS_NAME_INFORMATION, *PALIAS_NAME_INFORMATION;

typedef struct _ALIAS_ADM_COMMENT_INFORMATION {
    UNICODE_STRING AdminComment;
} ALIAS_ADM_COMMENT_INFORMATION, *PALIAS_ADM_COMMENT_INFORMATION;

#define ALIAS_ALL_NAME                              (0x00000001L)
#define ALIAS_ALL_MEMBER_COUNT                      (0x00000002L)
#define ALIAS_ALL_ADMIN_COMMENT                     (0x00000004L)
#define ALIAS_ALL_SHELL_ADMIN_OBJECT_PROPERTIES     (0x00000008L)

typedef struct _ALIAS_EXTENDED_INFORMATION {

    ULONG                       WhichFields;
    SAM_SHELL_OBJECT_PROPERTIES ShellAdminObjectProperties;

} ALIAS_EXTENDED_INFORMATION, *PALIAS_EXTENDED_INFORMATION;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//    NT5+ Limited Groups Related Definitions                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//
// Group Flag Definitions to determine Type of Group
//

#define GROUP_TYPE_BUILTIN_LOCAL_GROUP   0x00000001
#define GROUP_TYPE_ACCOUNT_GROUP         0x00000002
#define GROUP_TYPE_RESOURCE_GROUP        0x00000004
#define GROUP_TYPE_UNIVERSAL_GROUP       0x00000008
#define GROUP_TYPE_APP_BASIC_GROUP       0x00000010
#define GROUP_TYPE_APP_QUERY_GROUP       0x00000020
#define GROUP_TYPE_SECURITY_ENABLED      0x80000000


#define GROUP_TYPE_RESOURCE_BEHAVOIR     (GROUP_TYPE_RESOURCE_GROUP    | \
                                          GROUP_TYPE_APP_BASIC_GROUP   | \
                                          GROUP_TYPE_APP_QUERY_GROUP)



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   User  Object Related Definitions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//
// Access rights for user object
//

#define USER_READ_GENERAL                0x0001
#define USER_READ_PREFERENCES            0x0002
#define USER_WRITE_PREFERENCES           0x0004
#define USER_READ_LOGON                  0x0008
#define USER_READ_ACCOUNT                0x0010
#define USER_WRITE_ACCOUNT               0x0020
#define USER_CHANGE_PASSWORD             0x0040
#define USER_FORCE_PASSWORD_CHANGE       0x0080
#define USER_LIST_GROUPS                 0x0100
#define USER_READ_GROUP_INFORMATION      0x0200
#define USER_WRITE_GROUP_INFORMATION     0x0400

#define USER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED       |\
                         USER_READ_PREFERENCES          |\
                         USER_READ_LOGON                |\
                         USER_LIST_GROUPS               |\
                         USER_READ_GROUP_INFORMATION    |\
                         USER_WRITE_PREFERENCES         |\
                         USER_CHANGE_PASSWORD           |\
                         USER_FORCE_PASSWORD_CHANGE     |\
                         USER_READ_GENERAL              |\
                         USER_READ_ACCOUNT              |\
                         USER_WRITE_ACCOUNT             |\
                         USER_WRITE_GROUP_INFORMATION)



#define USER_READ       (STANDARD_RIGHTS_READ           |\
                         USER_READ_PREFERENCES          |\
                         USER_READ_LOGON                |\
                         USER_READ_ACCOUNT              |\
                         USER_LIST_GROUPS               |\
                         USER_READ_GROUP_INFORMATION)


#define USER_WRITE      (STANDARD_RIGHTS_WRITE          |\
                         USER_WRITE_PREFERENCES         |\
                         USER_CHANGE_PASSWORD)

#define USER_EXECUTE    (STANDARD_RIGHTS_EXECUTE        |\
                         USER_READ_GENERAL              |\
                         USER_CHANGE_PASSWORD)


//
// User object types
//

// begin_ntsubauth
#ifndef _NTSAM_USER_ACCOUNT_FLAGS_

//
// User account control flags...
//

#define USER_ACCOUNT_DISABLED                       (0x00000001)
#define USER_HOME_DIRECTORY_REQUIRED                (0x00000002)
#define USER_PASSWORD_NOT_REQUIRED                  (0x00000004)
#define USER_TEMP_DUPLICATE_ACCOUNT                 (0x00000008)
#define USER_NORMAL_ACCOUNT                         (0x00000010)
#define USER_MNS_LOGON_ACCOUNT                      (0x00000020)
#define USER_INTERDOMAIN_TRUST_ACCOUNT              (0x00000040)
#define USER_WORKSTATION_TRUST_ACCOUNT              (0x00000080)
#define USER_SERVER_TRUST_ACCOUNT                   (0x00000100)
#define USER_DONT_EXPIRE_PASSWORD                   (0x00000200)
#define USER_ACCOUNT_AUTO_LOCKED                    (0x00000400)
#define USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED        (0x00000800)
#define USER_SMARTCARD_REQUIRED                     (0x00001000)
#define USER_TRUSTED_FOR_DELEGATION                 (0x00002000)
#define USER_NOT_DELEGATED                          (0x00004000)
#define USER_USE_DES_KEY_ONLY                       (0x00008000)
#define USER_DONT_REQUIRE_PREAUTH                   (0x00010000)
#define USER_PASSWORD_EXPIRED                       (0x00020000)
#define USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION (0x00040000)
#define USER_NO_AUTH_DATA_REQUIRED                  (0x00080000)
#define USER_PARTIAL_SECRETS_ACCOUNT                (0x00100000)
#define USER_USE_AES_KEYS                           (0x00200000)
// end_ntsubauth

//
// The previous bit (USER_USE_AES_KEYS) is not used in the product.
//  To be clearer, this bit is stored and retrieved but is never
//  used by any component.
// We've shipped Vista with it, therefore we have to leave it behind.
//
// !!!! <<<<< DO NOT, AGAIN DO NOT INTRODUCE ANY NEW BITS >>>>> !!!!
//  See Windows OS Bug 1962665 and Windows SE Bug 201918
//
// Also see the use of begin_ntsubauth and end_ntsubauth which is used
//  for generating ntsubauth.h file
//

// begin_ntsubauth
#define NEXT_FREE_ACCOUNT_CONTROL_BIT (USER_USE_AES_KEYS << 1)

#define USER_MACHINE_ACCOUNT_MASK      \
            ( USER_INTERDOMAIN_TRUST_ACCOUNT |\
              USER_WORKSTATION_TRUST_ACCOUNT |\
              USER_SERVER_TRUST_ACCOUNT)

#define USER_ACCOUNT_TYPE_MASK         \
            ( USER_TEMP_DUPLICATE_ACCOUNT |\
              USER_NORMAL_ACCOUNT |\
              USER_MACHINE_ACCOUNT_MASK )

#define USER_COMPUTED_ACCOUNT_CONTROL_BITS  \
            (USER_ACCOUNT_AUTO_LOCKED |     \
             USER_PASSWORD_EXPIRED      )



//
// Logon times may be expressed in day, hour, or minute granularity.
//
//              Days per week    = 7
//              Hours per week   = 168
//              Minutes per week = 10080
//

#define SAM_DAYS_PER_WEEK    (7)
#define SAM_HOURS_PER_WEEK   (24 * SAM_DAYS_PER_WEEK)
#define SAM_MINUTES_PER_WEEK (60 * SAM_HOURS_PER_WEEK)

typedef struct _LOGON_HOURS {

    USHORT UnitsPerWeek;

    //
    // UnitsPerWeek is the number of equal length time units the week is
    // divided into.  This value is used to compute the length of the bit
    // string in logon_hours.  Must be less than or equal to
    // SAM_UNITS_PER_WEEK (10080) for this release.
    //
    // LogonHours is a bit map of valid logon times.  Each bit represents
    // a unique division in a week.  The largest bit map supported is 1260
    // bytes (10080 bits), which represents minutes per week.  In this case
    // the first bit (bit 0, byte 0) is Sunday, 00:00:00 - 00-00:59; bit 1,
    // byte 0 is Sunday, 00:01:00 - 00:01:59, etc.  A NULL pointer means
    // DONT_CHANGE for SamSetInformationUser() calls.
    //

    PUCHAR LogonHours;

} LOGON_HOURS, *PLOGON_HOURS;

typedef struct _SR_SECURITY_DESCRIPTOR {
    ULONG Length;
    PUCHAR SecurityDescriptor;
} SR_SECURITY_DESCRIPTOR, *PSR_SECURITY_DESCRIPTOR;

#define _NTSAM_USER_ACCOUNT_FLAG_
#endif
// end_ntsubauth

typedef enum _USER_INFORMATION_CLASS {
    UserGeneralInformation = 1,
    UserPreferencesInformation,
    UserLogonInformation,
    UserLogonHoursInformation,
    UserAccountInformation,
    UserNameInformation,
    UserAccountNameInformation,
    UserFullNameInformation,
    UserPrimaryGroupInformation,
    UserHomeInformation,
    UserScriptInformation,
    UserProfileInformation,
    UserAdminCommentInformation,
    UserWorkStationsInformation,
    UserSetPasswordInformation,
    UserControlInformation,
    UserExpiresInformation,
    UserInternal1Information,
    UserInternal2Information,
    UserParametersInformation,
    UserAllInformation,
    UserInternal3Information,
    UserInternal4Information,
    UserInternal5Information,
    UserInternal4InformationNew,
    UserInternal5InformationNew,
    UserInternal6Information,
    UserExtendedInformation,
    UserLogonUIInformation,
} USER_INFORMATION_CLASS, *PUSER_INFORMATION_CLASS;

// begin_ntsubauth
#ifndef _NTSAM_USER_ALL_INFO_
#include "pshpack4.h"
typedef struct _USER_ALL_INFORMATION {
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    UNICODE_STRING UserComment;
    UNICODE_STRING Parameters;
    UNICODE_STRING LmPassword;
    UNICODE_STRING NtPassword;
    UNICODE_STRING PrivateData;
    SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
} USER_ALL_INFORMATION,  *PUSER_ALL_INFORMATION;
#include "poppack.h"
#define _NTSAM_USER_ALL_INFO_
#endif
// end_ntsubauth

//
// Bits to be used in UserAllInformation's WhichFields field (to indicate
// which items were queried or set).
//

#define USER_ALL_USERNAME           0x00000001
#define USER_ALL_FULLNAME           0x00000002
#define USER_ALL_USERID             0x00000004
#define USER_ALL_PRIMARYGROUPID     0x00000008
#define USER_ALL_ADMINCOMMENT       0x00000010
#define USER_ALL_USERCOMMENT        0x00000020
#define USER_ALL_HOMEDIRECTORY      0x00000040
#define USER_ALL_HOMEDIRECTORYDRIVE 0x00000080
#define USER_ALL_SCRIPTPATH         0x00000100
#define USER_ALL_PROFILEPATH        0x00000200
#define USER_ALL_WORKSTATIONS       0x00000400
#define USER_ALL_LASTLOGON          0x00000800
#define USER_ALL_LASTLOGOFF         0x00001000
#define USER_ALL_LOGONHOURS         0x00002000
#define USER_ALL_BADPASSWORDCOUNT   0x00004000
#define USER_ALL_LOGONCOUNT         0x00008000
#define USER_ALL_PASSWORDCANCHANGE  0x00010000
#define USER_ALL_PASSWORDMUSTCHANGE 0x00020000
#define USER_ALL_PASSWORDLASTSET    0x00040000
#define USER_ALL_ACCOUNTEXPIRES     0x00080000
#define USER_ALL_USERACCOUNTCONTROL 0x00100000
#ifndef _NTSAM_SAM_USER_PARMS_                 // ntsubauth
#define USER_ALL_PARAMETERS         0x00200000 // ntsubauth
#define _NTSAM_SAM_USER_PARMS_                 // ntsubauth
#endif                                         // ntsubauth
#define USER_ALL_COUNTRYCODE        0x00400000
#define USER_ALL_CODEPAGE           0x00800000
#define USER_ALL_NTPASSWORDPRESENT  0x01000000  // field AND boolean
#define USER_ALL_LMPASSWORDPRESENT  0x02000000  // field AND boolean
#define USER_ALL_PRIVATEDATA        0x04000000  // field AND boolean
#define USER_ALL_PASSWORDEXPIRED    0x08000000
#define USER_ALL_SECURITYDESCRIPTOR 0x10000000
#define USER_ALL_OWFPASSWORD        0x20000000  // boolean

#define USER_ALL_UNDEFINED_MASK     0xC0000000

//
// Now define masks for fields that are accessed for read by the same
// access type.
//
// Fields that require READ_GENERAL access to read.
//

#define USER_ALL_READ_GENERAL_MASK  (USER_ALL_USERNAME               | \
                                    USER_ALL_FULLNAME                | \
                                    USER_ALL_USERID                  | \
                                    USER_ALL_PRIMARYGROUPID          | \
                                    USER_ALL_ADMINCOMMENT            | \
                                    USER_ALL_USERCOMMENT)

//
// Fields that require READ_LOGON access to read.
//

#define USER_ALL_READ_LOGON_MASK    (USER_ALL_HOMEDIRECTORY          | \
                                    USER_ALL_HOMEDIRECTORYDRIVE      | \
                                    USER_ALL_SCRIPTPATH              | \
                                    USER_ALL_PROFILEPATH             | \
                                    USER_ALL_WORKSTATIONS            | \
                                    USER_ALL_LASTLOGON               | \
                                    USER_ALL_LASTLOGOFF              | \
                                    USER_ALL_LOGONHOURS              | \
                                    USER_ALL_BADPASSWORDCOUNT        | \
                                    USER_ALL_LOGONCOUNT              | \
                                    USER_ALL_PASSWORDCANCHANGE       | \
                                    USER_ALL_PASSWORDMUSTCHANGE)

//
// Fields that require READ_ACCOUNT access to read.
//

#define USER_ALL_READ_ACCOUNT_MASK  (USER_ALL_PASSWORDLASTSET        | \
                                    USER_ALL_ACCOUNTEXPIRES          | \
                                    USER_ALL_USERACCOUNTCONTROL      | \
                                    USER_ALL_PARAMETERS)

//
// Fields that require READ_PREFERENCES access to read.
//

#define USER_ALL_READ_PREFERENCES_MASK (USER_ALL_COUNTRYCODE         | \
                                    USER_ALL_CODEPAGE)

//
// Fields that can only be read by trusted clients.
//

#define USER_ALL_READ_TRUSTED_MASK  (USER_ALL_NTPASSWORDPRESENT      | \
                                    USER_ALL_LMPASSWORDPRESENT       | \
                                    USER_ALL_PASSWORDEXPIRED         | \
                                    USER_ALL_SECURITYDESCRIPTOR      | \
                                    USER_ALL_PRIVATEDATA)

//
// Fields that can't be read.
//

#define USER_ALL_READ_CANT_MASK     USER_ALL_UNDEFINED_MASK


//
// Now define masks for fields that are accessed for write by the same
// access type.
//
// Fields that require WRITE_ACCOUNT access to write.
//

#define USER_ALL_WRITE_ACCOUNT_MASK     (USER_ALL_USERNAME           | \
                                        USER_ALL_FULLNAME            | \
                                        USER_ALL_PRIMARYGROUPID      | \
                                        USER_ALL_HOMEDIRECTORY       | \
                                        USER_ALL_HOMEDIRECTORYDRIVE  | \
                                        USER_ALL_SCRIPTPATH          | \
                                        USER_ALL_PROFILEPATH         | \
                                        USER_ALL_ADMINCOMMENT        | \
                                        USER_ALL_WORKSTATIONS        | \
                                        USER_ALL_LOGONHOURS          | \
                                        USER_ALL_ACCOUNTEXPIRES      | \
                                        USER_ALL_USERACCOUNTCONTROL  | \
                                        USER_ALL_PARAMETERS)

//
// Fields that require WRITE_PREFERENCES access to write.
//

#define USER_ALL_WRITE_PREFERENCES_MASK (USER_ALL_USERCOMMENT        | \
                                        USER_ALL_COUNTRYCODE         | \
                                        USER_ALL_CODEPAGE)

//
// Fields that require FORCE_PASSWORD_CHANGE access to write.
//
// Note that non-trusted clients only set the NT password as a
// UNICODE string.  The wrapper will convert it to an LM password,
// OWF and encrypt both versions.  Trusted clients can pass in OWF
// versions of either or both.
//

#define USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK                      \
                                        (USER_ALL_NTPASSWORDPRESENT  | \
                                        USER_ALL_LMPASSWORDPRESENT   | \
                                        USER_ALL_PASSWORDEXPIRED)

//
// Fields that can only be written by trusted clients.
//

#define USER_ALL_WRITE_TRUSTED_MASK     (USER_ALL_LASTLOGON          | \
                                        USER_ALL_LASTLOGOFF          | \
                                        USER_ALL_BADPASSWORDCOUNT    | \
                                        USER_ALL_LOGONCOUNT          | \
                                        USER_ALL_PASSWORDLASTSET     | \
                                        USER_ALL_SECURITYDESCRIPTOR  | \
                                        USER_ALL_PRIVATEDATA)

//
// Fields that can't be written.
//

#define USER_ALL_WRITE_CANT_MASK        (USER_ALL_USERID             | \
                                        USER_ALL_PASSWORDCANCHANGE   | \
                                        USER_ALL_PASSWORDMUSTCHANGE  | \
                                        USER_ALL_UNDEFINED_MASK)


typedef struct _USER_GENERAL_INFORMATION {
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG PrimaryGroupId;
    UNICODE_STRING AdminComment;
    UNICODE_STRING UserComment;
} USER_GENERAL_INFORMATION,  *PUSER_GENERAL_INFORMATION;

typedef struct _USER_PREFERENCES_INFORMATION {
    UNICODE_STRING UserComment;
    UNICODE_STRING Reserved1;
    USHORT CountryCode;
    USHORT CodePage;
} USER_PREFERENCES_INFORMATION,  *PUSER_PREFERENCES_INFORMATION;

typedef struct _USER_PARAMETERS_INFORMATION {
    UNICODE_STRING Parameters;
} USER_PARAMETERS_INFORMATION,  *PUSER_PARAMETERS_INFORMATION;

#include "pshpack4.h"
typedef struct _USER_LOGON_INFORMATION {
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING WorkStations;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    ULONG UserAccountControl;
} USER_LOGON_INFORMATION, *PUSER_LOGON_INFORMATION;
#include "poppack.h"

#include "pshpack4.h"
typedef struct _USER_ACCOUNT_INFORMATION {
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    ULONG UserAccountControl;
} USER_ACCOUNT_INFORMATION,  *PUSER_ACCOUNT_INFORMATION;
#include "poppack.h"

typedef struct _USER_ACCOUNT_NAME_INFORMATION {
    UNICODE_STRING UserName;
} USER_ACCOUNT_NAME_INFORMATION, *PUSER_ACCOUNT_NAME_INFORMATION;

typedef struct _USER_FULL_NAME_INFORMATION {
    UNICODE_STRING FullName;
} USER_FULL_NAME_INFORMATION, *PUSER_FULL_NAME_INFORMATION;

typedef struct _USER_NAME_INFORMATION {
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
} USER_NAME_INFORMATION, *PUSER_NAME_INFORMATION;

typedef struct _USER_PRIMARY_GROUP_INFORMATION {
    ULONG PrimaryGroupId;
} USER_PRIMARY_GROUP_INFORMATION, *PUSER_PRIMARY_GROUP_INFORMATION;

typedef struct _USER_HOME_INFORMATION {
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
} USER_HOME_INFORMATION, *PUSER_HOME_INFORMATION;

typedef struct _USER_SCRIPT_INFORMATION {
    UNICODE_STRING ScriptPath;
} USER_SCRIPT_INFORMATION, *PUSER_SCRIPT_INFORMATION;

typedef struct _USER_PROFILE_INFORMATION {
    UNICODE_STRING ProfilePath;
} USER_PROFILE_INFORMATION, *PUSER_PROFILE_INFORMATION;

typedef struct _USER_ADMIN_COMMENT_INFORMATION {
    UNICODE_STRING AdminComment;
} USER_ADMIN_COMMENT_INFORMATION, *PUSER_ADMIN_COMMENT_INFORMATION;

typedef struct _USER_WORKSTATIONS_INFORMATION {
    UNICODE_STRING WorkStations;
} USER_WORKSTATIONS_INFORMATION, *PUSER_WORKSTATIONS_INFORMATION;

typedef struct _USER_SET_PASSWORD_INFORMATION {
    UNICODE_STRING Password;
    BOOLEAN PasswordExpired;
} USER_SET_PASSWORD_INFORMATION, *PUSER_SET_PASSWORD_INFORMATION;

typedef struct _USER_CONTROL_INFORMATION {
    ULONG UserAccountControl;
} USER_CONTROL_INFORMATION, *PUSER_CONTROL_INFORMATION;

typedef struct _USER_EXPIRES_INFORMATION {
#if defined(MIDL_PASS)
    OLD_LARGE_INTEGER AccountExpires;
#else
    LARGE_INTEGER AccountExpires;
#endif
} USER_EXPIRES_INFORMATION, *PUSER_EXPIRES_INFORMATION;

typedef struct _USER_LOGON_HOURS_INFORMATION {
    LOGON_HOURS LogonHours;
} USER_LOGON_HOURS_INFORMATION, *PUSER_LOGON_HOURS_INFORMATION;

typedef SAM_BYTE_ARRAY_32K  SAM_USER_TILE, *PSAM_USER_TILE;

// 0xFF000FFF is reserved for internal callers and implementation

#define USER_EXTENDED_FIELD_USER_TILE                       (0x00001000L)
#define USER_EXTENDED_FIELD_PASSWORD_HINT                   (0x00002000L)
#define USER_EXTENDED_FIELD_DONT_SHOW_IN_LOGON_UI           (0x00004000L)
#define USER_EXTENDED_FIELD_SHELL_ADMIN_OBJECT_PROPERTIES   (0x00008000L)

typedef struct _USER_EXTENDED_INFORMATION {

    ULONG                               ExtendedWhichFields;
    SAM_USER_TILE                       UserTile;
    UNICODE_STRING                      PasswordHint;
    BOOLEAN                             DontShowInLogonUI;
    SAM_SHELL_OBJECT_PROPERTIES         ShellAdminObjectProperties;

} USER_EXTENDED_INFORMATION, *PUSER_EXTENDED_INFORMATION;

// For local callers only
typedef struct _USER_LOGON_UI_INFORMATION {

    BOOLEAN PasswordIsBlank;
    BOOLEAN AccountIsDisabled;

} USER_LOGON_UI_INFORMATION, *PUSER_LOGON_UI_INFORMATION;

///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Data type used by SamChangePasswordUser3 for better error             //
// reporting of password change change failures                          //
//                                                                       //
// The field definitions are as follows:                                 //
//                                                                       //
//        ExtendedFailureReason   -- Indicates the reason                //
//                                   why the new password was not        //
//                                   accepted                            //
//                                                                       //
//        FilterModuleName        -- If the password change was failed   //
//                                   by a password filter , the name of  //
//                                   of the filter DLL is returned in    //
//                                   here                                //
//                                                                       //
// The following error codes are defined                                 //
//                                                                       //
//   SAM_PWD_CHANGE_NO_ERROR                                             //
//           No error, cannot be returned alongwith a failure code for   //
//                                   password change                     //
//                                                                       //
//   SAM_PWD_CHANGE_PASSWORD_TOO_SHORT                                   //
//                                                                       //
//               Supplied password did not meet password length policy   //
//                                                                       //
//   SAM_PWD_CHANGE_PWD_IN_HISTORY                                       //
//                                                                       //
//                History restrictions were not met                      //
//                                                                       //
//   SAM_PWD_CHANGE_USERNAME_IN_PASSWORD                                 //
//                 Complexity check could not  be met because the user   //
//                 name was part of the password                         //
//                                                                       //
//   SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD                                 //
//                                                                       //
//                Complexity check could not be met because the user's   //
//                full name was part of the password                     //
//                                                                       //
//   SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT                         //
//                                                                       //
//                The  domain has the refuse password change setting     //
//                enabled. This disallows machine accounts from having   //
//                anything other than the default password               //
//                                                                       //
//   SAM_PWD_CHANGE_FAILED_BY_FILTER                                     //
//                                                                       //
//                The supplied new password failed by a password filter  //
//                the name of the filter DLL is indicated                //
//                                                                       //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

typedef struct _USER_PWD_CHANGE_FAILURE_INFORMATION {
    ULONG                       ExtendedFailureReason;
    UNICODE_STRING              FilterModuleName;
} USER_PWD_CHANGE_FAILURE_INFORMATION,*PUSER_PWD_CHANGE_FAILURE_INFORMATION;

//
// Currently defined values for ExtendedFailureReason are as follows
//


#define SAM_PWD_CHANGE_NO_ERROR                     0
#define SAM_PWD_CHANGE_PASSWORD_TOO_SHORT           1
#define SAM_PWD_CHANGE_PWD_IN_HISTORY               2
#define SAM_PWD_CHANGE_USERNAME_IN_PASSWORD         3
#define SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD         4
#define SAM_PWD_CHANGE_NOT_COMPLEX                  5
#define SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT 6
#define SAM_PWD_CHANGE_FAILED_BY_FILTER             7
#define SAM_PWD_CHANGE_PASSWORD_TOO_LONG            8
#define SAM_PWD_CHANGE_FAILURE_REASON_MAX           8


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Data types used by SAM and Netlogon for database replication            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


typedef enum _SECURITY_DB_DELTA_TYPE {
    SecurityDbNew = 1,
    SecurityDbRename,
    SecurityDbDelete,
    SecurityDbChangeMemberAdd,
    SecurityDbChangeMemberSet,
    SecurityDbChangeMemberDel,
    SecurityDbChange,
    SecurityDbChangePassword
} SECURITY_DB_DELTA_TYPE, *PSECURITY_DB_DELTA_TYPE;

typedef enum _SECURITY_DB_OBJECT_TYPE {
    SecurityDbObjectSamDomain = 1,
    SecurityDbObjectSamUser,
    SecurityDbObjectSamGroup,
    SecurityDbObjectSamAlias,
    SecurityDbObjectLsaPolicy,
    SecurityDbObjectLsaTDomain,
    SecurityDbObjectLsaAccount,
    SecurityDbObjectLsaSecret
} SECURITY_DB_OBJECT_TYPE, *PSECURITY_DB_OBJECT_TYPE;

//
// Account types
//
//  Both enumerated types and flag definitions are provided.
//  The flag definitions are used in places where more than
//  one type of account may be specified together.
//

typedef enum _SAM_ACCOUNT_TYPE {
    SamObjectUser = 1,
    SamObjectGroup ,
    SamObjectAlias
} SAM_ACCOUNT_TYPE, *PSAM_ACCOUNT_TYPE;


#define SAM_USER_ACCOUNT                (0x00000001)
#define SAM_GLOBAL_GROUP_ACCOUNT        (0x00000002)
#define SAM_LOCAL_GROUP_ACCOUNT         (0x00000004)



//
// Define the data type used to pass netlogon information on the account
// that was added or deleted from a group.
//

typedef struct _SAM_GROUP_MEMBER_ID {
    ULONG   MemberRid;
} SAM_GROUP_MEMBER_ID, *PSAM_GROUP_MEMBER_ID;


//
// Define the data type used to pass netlogon information on the account
// that was added or deleted from an alias.
//

typedef struct _SAM_ALIAS_MEMBER_ID {
    PSID    MemberSid;
} SAM_ALIAS_MEMBER_ID, *PSAM_ALIAS_MEMBER_ID;




//
// Define the data type used to pass netlogon information on a delta
//

typedef union _SAM_DELTA_DATA {

    //
    // Delta type ChangeMember{Add/Del/Set} and account type group
    //

    SAM_GROUP_MEMBER_ID GroupMemberId;

    //
    // Delta type ChangeMember{Add/Del/Set} and account type alias
    //

    SAM_ALIAS_MEMBER_ID AliasMemberId;

    //
    // Delta type AddOrChange and account type User
    //

    ULONG  AccountControl;

} SAM_DELTA_DATA, *PSAM_DELTA_DATA;


//
// Prototype for delta notification routine.
//

typedef NTSTATUS (*PSAM_DELTA_NOTIFICATION_ROUTINE) (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

#define SAM_DELTA_NOTIFY_ROUTINE "DeltaNotify"


//////////////////////////////////////////////////////////////////
//                                                              //
// Structure and ProtoType for RAS User Parameters              //
//                                                              //
//////////////////////////////////////////////////////////////////

// Flags used by SAM UserParms Migration
// indicate UserParmsConvert is called during upgrade.

#define SAM_USERPARMS_DURING_UPGRADE    0x00000001


typedef struct _SAM_USERPARMS_ATTRVALS {
    ULONG   length;     // length of the attribute.
    __field_bcount(length) PVOID   value;      // pointer to the value.
} SAM_USERPARMS_ATTRVALS, *PSAM_USERPARMS_ATTRVALS; // describes one value of the attribute.


typedef enum _SAM_USERPARMS_ATTRSYNTAX {
    Syntax_Attribute = 1,
    Syntax_EncryptedAttribute
} SAM_USERPARMS_ATTRSYNTAX;          // indicates whether attributes are encrypted or not.


typedef struct _SAM_USERPARMS_ATTR {
    UNICODE_STRING AttributeIdentifier;     // This will be the LDAP display name of the attribute.
                                            // SAM will perform the translation to attribute ID.
                                            // unless the specified syntax is type EncryptedAttribute,
                                            // in which case it is packaged as part of supplemental
                                            // credentials blob and the name identifes the package name.
                                            // Encrypted attribute will be supplied in the clear ie decrypted.
    SAM_USERPARMS_ATTRSYNTAX Syntax;
    ULONG CountOfValues;                    // The count of values in the attribute.
    SAM_USERPARMS_ATTRVALS * Values;        // pointer to an array of values representing the data
                                            // values of the attribute.
} SAM_USERPARMS_ATTR, *PSAM_USERPARMS_ATTR; // describes an attribute and the set of values associated with it.


typedef struct _SAM_USERPARMS_ATTRBLOCK {
    ULONG attCount;
    SAM_USERPARMS_ATTR * UserParmsAttr;
} SAM_USERPARMS_ATTRBLOCK, *PSAM_USERPARMS_ATTRBLOCK;  // describes an array of attributes


typedef NTSTATUS (*PSAM_USERPARMS_CONVERT_NOTIFICATION_ROUTINE) (
    IN ULONG    Flags,
    IN PSID     DomainSid,
    IN ULONG    ObjectRid,  // identifies the object
    IN ULONG    UserParmsLengthOrig,
    IN PVOID    UserParmsOrig,
    IN ULONG    UserParmsLengthNew,
    IN PVOID    UserParmsNew,
    OUT PSAM_USERPARMS_ATTRBLOCK * UserParmsAttrBlock
);

#define SAM_USERPARMS_CONVERT_NOTIFICATION_ROUTINE "UserParmsConvert"


typedef VOID (*PSAM_USERPARMS_ATTRBLOCK_FREE_ROUTINE) (
    IN PSAM_USERPARMS_ATTRBLOCK UserParmsAttrBlock
);

#define SAM_USERPARMS_ATTRBLOCK_FREE_ROUTINE    "UserParmsFree"


//////////////////////////////////////////////////////////////////
//                                                              //
// Return Values for Compatiblity Mode                          //
//                                                              //
//////////////////////////////////////////////////////////////////

// All SAM attributes are accessible
#define SAM_SID_COMPATIBILITY_ALL     0

// Rid field can be returned to caller as 0
// No writes to PrimaryGroupId allowed
#define SAM_SID_COMPATIBILITY_LAX     1

// NET API Information levels that ask for RID are to failed
// No writes to PrimaryGroupId allowed
#define SAM_SID_COMPATIBILITY_STRICT  2


//
//    *************************************
//
//    Internal Password Checking API structures
//
//    *************************************
//

//
//    What kind of password checking is to be performed?
//        SamValidateAuthentication : Check if the authentication can be done
//        SamValidatePasswordChange: Check if the password can be changed
//        SamValidatePasswordReset: Reset the password to the given value
//
typedef enum _PASSWORD_POLICY_VALIDATION_TYPE{
    SamValidateAuthentication = 1,
    SamValidatePasswordChange,
    SamValidatePasswordReset
} PASSWORD_POLICY_VALIDATION_TYPE;

//
//    Structure to keep the password hash
//
typedef struct _SAM_VALIDATE_PASSWORD_HASH{
    ULONG Length;
#ifdef MIDL_PASS
    [unique,size_is(Length)]
#endif
    PUCHAR Hash;
} SAM_VALIDATE_PASSWORD_HASH, *PSAM_VALIDATE_PASSWORD_HASH;


// To be used with PresentFields member of SAM_VALIDATE_PERSISTED_FIELDS
#define SAM_VALIDATE_PASSWORD_LAST_SET          0x00000001
#define SAM_VALIDATE_BAD_PASSWORD_TIME          0x00000002
#define SAM_VALIDATE_LOCKOUT_TIME               0x00000004
#define SAM_VALIDATE_BAD_PASSWORD_COUNT         0x00000008
#define SAM_VALIDATE_PASSWORD_HISTORY_LENGTH    0x00000010
#define SAM_VALIDATE_PASSWORD_HISTORY           0x00000020

//
//    Structure to keep information about the password and related things.
//        Present Fields: (used only in output args) which fields are changed.
//            See the constants above.
//        PasswordLastSet: When the password is last set.
//        BadPasswordTime: When the password was incorrect for the last time.
//        LockoutTime: When the account is locked out. If the account is not locked out
//            it is 0.
//        BadPasswordCount: How many times the password has given incorrectly in the
//            Observation Window.
//        PasswordHistoryLength: How many passwords are kept in the history
//        PasswordHistory: Password hashes that are in the history
//
typedef struct _SAM_VALIDATE_PERSISTED_FIELDS{
    ULONG PresentFields;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER BadPasswordTime;
    LARGE_INTEGER LockoutTime;
    ULONG BadPasswordCount;
    ULONG PasswordHistoryLength;
#ifdef MIDL_PASS
    [unique,size_is(PasswordHistoryLength)]
#endif
    PSAM_VALIDATE_PASSWORD_HASH PasswordHistory;
} SAM_VALIDATE_PERSISTED_FIELDS, *PSAM_VALIDATE_PERSISTED_FIELDS;

//
//    Validation Status of the password check:
//        Names are self-explaining so I think there is no need to explain them here.
//
typedef enum _SAM_VALIDATE_VALIDATION_STATUS{
    SamValidateSuccess = 0,
    SamValidatePasswordMustChange,
    SamValidateAccountLockedOut,
    SamValidatePasswordExpired,
    SamValidatePasswordIncorrect,
    SamValidatePasswordIsInHistory,
    SamValidatePasswordTooShort,
    SamValidatePasswordTooLong,
    SamValidatePasswordNotComplexEnough,
    SamValidatePasswordTooRecent,
    SamValidatePasswordFilterError
}SAM_VALIDATE_VALIDATION_STATUS, *PSAM_VALIDATE_VALIDATION_STATUS;

//
//    Output Arg
//        ChangedPersistedFields: Any changes to the password related info
//        ValidationStatus: Shows the result of the request
//
typedef struct _SAM_VALIDATE_STANDARD_OUTPUT_ARG{
    SAM_VALIDATE_PERSISTED_FIELDS ChangedPersistedFields;
    SAM_VALIDATE_VALIDATION_STATUS ValidationStatus;
} SAM_VALIDATE_STANDARD_OUTPUT_ARG, *PSAM_VALIDATE_STANDARD_OUTPUT_ARG;

//
//    If authentication type of password check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    PasswordMatched: Indicates the result of the application's authentication of the supplied password

typedef struct _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    BOOLEAN PasswordMatched; // indicates the result of the application's authentication of the supplied password
} SAM_VALIDATE_AUTHENTICATION_INPUT_ARG, *PSAM_VALIDATE_AUTHENTICATION_INPUT_ARG;

//
//    If password change type of check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    ClearPassword: The string which password is going to be
//    UserAccountName: Name of the user account
//    HashedPassword: Hash of the string that the password is going to be
//    PasswordMatch: denotes if the old password supplied by user matched or not
//
typedef struct  _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    UNICODE_STRING ClearPassword;
    UNICODE_STRING UserAccountName;
    SAM_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN PasswordMatch; // denotes if the old password supplied by user matched or not.
} SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG, *PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;

//
//    If password reset type of check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    ClearPassword: The string which password is going to be
//    UserAccountName: Name of the user account
//    HashedPassword: Hash of the string that the password is going to be
//    PasswordMustChangeAtNextLogon: Password must change for the user to be logged in
//    ClearLockout: If the account was locked out, this field can be used to clear lockout
//
typedef struct _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG{
    SAM_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    UNICODE_STRING ClearPassword;
    UNICODE_STRING UserAccountName;
    SAM_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN  PasswordMustChangeAtNextLogon; // looked at only for password reset
    BOOLEAN  ClearLockout; // can be used clear user account lockout --
}SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG, *PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG;


//
//    A union to encapsulate all kinds of inputs
//
typedef
#ifdef MIDL_PASS
    [switch_type(PASSWORD_POLICY_VALIDATION_TYPE)]
#endif
    union _SAM_VALIDATE_INPUT_ARG{
#ifdef MIDL_PASS
        [case(SamValidateAuthentication)]
#endif
        SAM_VALIDATE_AUTHENTICATION_INPUT_ARG ValidateAuthenticationInput;
#ifdef MIDL_PASS
        [case(SamValidatePasswordChange)]
#endif
        SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG ValidatePasswordChangeInput;
#ifdef MIDL_PASS
        [case(SamValidatePasswordReset)]
#endif
        SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG ValidatePasswordResetInput;
} SAM_VALIDATE_INPUT_ARG,  *PSAM_VALIDATE_INPUT_ARG;

//
//    A union to encapsulate all kinds of outputs
//        Actually, currently there is only one type of output,
//        but this can be used when there is a need for another
//        type of output.
//
typedef
#ifdef MIDL_PASS
    [switch_type(PASSWORD_POLICY_VALIDATION_TYPE)]
#endif
    union _SAM_VALIDATE_OUTPUT_ARG{
#ifdef MIDL_PASS
        [case(SamValidateAuthentication)]
#endif
        SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidateAuthenticationOutput;
#ifdef MIDL_PASS
        [case(SamValidatePasswordChange)]
#endif
        SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidatePasswordChangeOutput;
#ifdef MIDL_PASS
        [case(SamValidatePasswordReset)]
#endif
        SAM_VALIDATE_STANDARD_OUTPUT_ARG ValidatePasswordResetOutput;
} SAM_VALIDATE_OUTPUT_ARG,  *PSAM_VALIDATE_OUTPUT_ARG;

//
// Internal Password Checking API structures end here!
//

//
// Generic operation API structures start here
//

typedef enum _SAM_GENERIC_OPERATION_TYPE {

    SamObjectChangeNotificationOperation,

} SAM_GENERIC_OPERATION_TYPE, *PSAM_GENERIC_OPERATION_TYPE;

typedef struct _SAM_OPERATION_OBJCHG_INPUT {

    BOOLEAN                     Register;
    ULONG64                     EventHandle;
    SECURITY_DB_OBJECT_TYPE     ObjectType;
    ULONG                       ProcessID;

} SAM_OPERATION_OBJCHG_INPUT, *PSAM_OPERATION_OBJCHG_INPUT;

typedef struct _SAM_OPERATION_OBJCHG_OUTPUT {

    ULONG                       Reserved;

} SAM_OPERATION_OBJCHG_OUTPUT, *PSAM_OPERATION_OBJCHG_OUTPUT;

typedef SWITCH_TYPE( SAM_GENERIC_OPERATION_TYPE ) union _SAM_GENERIC_OPERATION_INPUT {

    CASE( SamObjectChangeNotificationOperation )    SAM_OPERATION_OBJCHG_INPUT ObjChangeIn;

} SAM_GENERIC_OPERATION_INPUT, *PSAM_GENERIC_OPERATION_INPUT;

typedef SWITCH_TYPE( SAM_GENERIC_OPERATION_TYPE ) union _SAM_GENERIC_OPERATION_OUTPUT {

    CASE( SamObjectChangeNotificationOperation )    SAM_OPERATION_OBJCHG_OUTPUT ObjChangeOut;

} SAM_GENERIC_OPERATION_OUTPUT, *PSAM_GENERIC_OPERATION_OUTPUT;

//
// Generic operation API structures end here
//


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   APIs Exported By SAM                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamFreeMemory(
    IN PVOID Buffer
    );


NTSTATUS
SamSetSecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
SamQuerySecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

NTSTATUS
SamCloseHandle(
    IN SAM_HANDLE SamHandle
    );

NTSTATUS
SamConnect(
    IN PUNICODE_STRING ServerName,
    OUT PSAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
SamShutdownSamServer(
    IN SAM_HANDLE ServerHandle
    );

NTSTATUS
SamLookupDomainInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN PUNICODE_STRING Name,
    OUT PSID * DomainId
    );

NTSTATUS
SamEnumerateDomainsInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );

NTSTATUS
SamOpenDomain(
    IN SAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PSID DomainId,
    OUT PSAM_HANDLE DomainHandle
    );

NTSTATUS
SamQueryInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
SamSetInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PVOID DomainInformation
    );

NTSTATUS
SamCreateGroupInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE GroupHandle,
    OUT PULONG RelativeId
    );


NTSTATUS
SamEnumerateGroupsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );

NTSTATUS
SamCreateUser2InDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG GrantedAccess,
    OUT PULONG RelativeId
    );

NTSTATUS
SamCreateUserInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG RelativeId
    );

NTSTATUS
SamEnumerateUsersInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN ULONG UserAccountControl,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );

NTSTATUS
SamCreateAliasInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE AliasHandle,
    OUT PULONG RelativeId
    );

NTSTATUS
SamEnumerateAliasesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );

NTSTATUS
SamGetAliasMembership(
    IN SAM_HANDLE DomainHandle,
    IN ULONG PassedCount,
    IN PSID *Sids,
    OUT PULONG MembershipCount,
    OUT PULONG *Aliases
    );

NTSTATUS
SamLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PULONG *RelativeIds,
    OUT PSID_NAME_USE *Use
    );

NTSTATUS
SamLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use
    );

NTSTATUS
SamOpenGroup(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG GroupId,
    OUT PSAM_HANDLE GroupHandle
    );

NTSTATUS
SamQueryInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
SamSetInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    IN PVOID Buffer
    );

NTSTATUS
SamAddMemberToGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    );

NTSTATUS
SamDeleteGroup(
    IN SAM_HANDLE GroupHandle
    );

NTSTATUS
SamRemoveMemberFromGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId
    );

NTSTATUS
SamGetMembersInGroup(
    IN SAM_HANDLE GroupHandle,
    OUT PULONG * MemberIds,
    OUT PULONG * Attributes,
    OUT PULONG MemberCount
    );

NTSTATUS
SamSetMemberAttributesOfGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    );

NTSTATUS
SamOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AliasId,
    OUT PSAM_HANDLE AliasHandle
    );

NTSTATUS
SamQueryInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
SamSetInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    IN PVOID Buffer
    );

NTSTATUS
SamDeleteAlias(
    IN SAM_HANDLE AliasHandle
    );

NTSTATUS
SamAddMemberToAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    );

NTSTATUS
SamAddMultipleMembersToAlias(
    IN SAM_HANDLE   AliasHandle,
    IN PSID         *MemberIds,
    IN ULONG        MemberCount
    );

NTSTATUS
SamRemoveMemberFromAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    );

NTSTATUS
SamRemoveMultipleMembersFromAlias(
    IN SAM_HANDLE   AliasHandle,
    IN PSID         *MemberIds,
    IN ULONG        MemberCount
    );

NTSTATUS
SamRemoveMemberFromForeignDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSID MemberId
    );

NTSTATUS
SamGetMembersInAlias(
    IN SAM_HANDLE AliasHandle,
    OUT PSID **MemberIds,
    OUT PULONG MemberCount
    );

NTSTATUS
SamOpenUser(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG UserId,
    OUT PSAM_HANDLE UserHandle
    );

NTSTATUS
SamDeleteUser(
    IN SAM_HANDLE UserHandle
    );

NTSTATUS
SamQueryInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PVOID * Buffer
    );

NTSTATUS
SamSetInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PVOID Buffer
    );

NTSTATUS
SamChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
    );

NTSTATUS
SamChangePasswordUser2(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
    );


NTSTATUS
SamChangePasswordUser3(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo
    );


NTSTATUS
SamGetGroupsForUser(
    IN SAM_HANDLE UserHandle,
    OUT PGROUP_MEMBERSHIP * Groups,
    OUT PULONG MembershipCount
    );

NTSTATUS
SamQueryDisplayInformation (
      IN    SAM_HANDLE DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      IN    ULONG      EntryCount,
      IN    ULONG      PreferredMaximumLength,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
      );

NTSTATUS
SamGetDisplayEnumerationIndex (
      IN    SAM_HANDLE        DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PUNICODE_STRING   Prefix,
      OUT   PULONG            Index
      );

NTSTATUS
SamRidToSid(
    IN  SAM_HANDLE ObjectHandle,
    IN  ULONG      Rid,
    OUT PSID*      Sid
    );

NTSTATUS
SamGetCompatibilityMode(
    IN  SAM_HANDLE ObjectHandle,
    OUT ULONG*     Mode
    );

NTSTATUS
SamValidatePassword(
    IN PUNICODE_STRING ServerName,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    IN PSAM_VALIDATE_INPUT_ARG InputArg,
    OUT PSAM_VALIDATE_OUTPUT_ARG *OutputArg
    );

NTSTATUS
SamQueryLocalizableAccountsInDomain(
    __in         SAM_HANDLE                              Domain,
    __in         ULONG                                   Flags,
    __in         ULONG                                   LanguageId,
    __in         DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION Class,
    __deref_out  PVOID                                  *Buffer
    );

NTSTATUS
SamRegisterObjectChangeNotification(
    __in    SECURITY_DB_OBJECT_TYPE     ObjectType,
    __in    HANDLE                      NotificationEventHandle
    );

NTSTATUS
SamUnregisterObjectChangeNotification(
    __in    SECURITY_DB_OBJECT_TYPE     ObjectType,
    __in    HANDLE                      NotificationEventHandle
    );

NTSTATUS
SamPerformGenericOperation(
    __in_opt    PWSTR                           ServerName,
    __in        SAM_GENERIC_OPERATION_TYPE      OperationType,
    __in        PSAM_GENERIC_OPERATION_INPUT    OperationIn,
    __out       PSAM_GENERIC_OPERATION_OUTPUT   *OperationOut
    );


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Interface definitions of services provided by a password filter DLL    //
//                                                                        //
////////////////////////////////////////////////////////////////////////////




//
// Routine names
//
// The routines provided by the DLL must be assigned the following names
// so that their addresses can be retrieved when the DLL is loaded.
//


//
// routine templates
//


//
// These guards are in place to allow ntsam.h and ntsecapi.h
// to be included in the same file.
//

// begin_ntsecapi

#ifndef _PASSWORD_NOTIFICATION_DEFINED
#define _PASSWORD_NOTIFICATION_DEFINED
typedef NTSTATUS (*PSAM_PASSWORD_NOTIFICATION_ROUTINE) (
    PUNICODE_STRING UserName,
    ULONG RelativeId,
    PUNICODE_STRING NewPassword
);

#define SAM_PASSWORD_CHANGE_NOTIFY_ROUTINE  "PasswordChangeNotify"

typedef BOOLEAN (*PSAM_INIT_NOTIFICATION_ROUTINE) (
);

#define SAM_INIT_NOTIFICATION_ROUTINE  "InitializeChangeNotify"

#define SAM_PASSWORD_FILTER_ROUTINE  "PasswordFilter"

typedef BOOLEAN (*PSAM_PASSWORD_FILTER_ROUTINE) (
    IN PUNICODE_STRING  AccountName,
    IN PUNICODE_STRING  FullName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN SetOperation
    );


#endif // _PASSWORD_NOTIFICATION_DEFINED

// end_ntsecapi

// begin_ntsecpkg

#ifndef _SAM_CREDENTIAL_UPDATE_DEFINED
#define _SAM_CREDENTIAL_UPDATE_DEFINED

typedef NTSTATUS (*PSAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE) (
    IN PUNICODE_STRING ClearPassword,
    IN PVOID OldCredentials,
    IN ULONG OldCredentialSize,
    IN ULONG UserAccountControl,
    IN PUNICODE_STRING UPN,  OPTIONAL
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING DnsDomainName,
    OUT PVOID * NewCredentials,
    OUT ULONG * NewCredentialSize
    );

#define SAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE "CredentialUpdateNotify"

typedef BOOLEAN (*PSAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE) (
    OUT PUNICODE_STRING CredentialName
    );

#define SAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE "CredentialUpdateRegister"

typedef VOID (*PSAM_CREDENTIAL_UPDATE_FREE_ROUTINE) (
    IN PVOID p
    );

#define SAM_CREDENTIAL_UPDATE_FREE_ROUTINE "CredentialUpdateFree"

typedef struct {
    PSTR   Original;
    PSTR   Mapped;
    BOOLEAN Continuable;  // only honored for some operations
} SAM_REGISTER_MAPPING_ELEMENT, *PSAM_REGISTER_MAPPING_ELEMENT;

typedef struct {
    ULONG                           Count;
    PSAM_REGISTER_MAPPING_ELEMENT   Elements;
} SAM_REGISTER_MAPPING_LIST, *PSAM_REGISTER_MAPPING_LIST;

typedef struct {
    ULONG                          Count;
    PSAM_REGISTER_MAPPING_LIST     Lists;
} SAM_REGISTER_MAPPING_TABLE, *PSAM_REGISTER_MAPPING_TABLE;

typedef NTSTATUS (*PSAM_CREDENTIAL_UPDATE_REGISTER_MAPPED_ENTRYPOINTS_ROUTINE) (
    __out SAM_REGISTER_MAPPING_TABLE *Table
    );

#define SAM_CREDENTIAL_UPDATE_REGISTER_MAPPED_ENTRYPOINTS_ROUTINE "RegisterMappedEntrypoints"

#endif // _SAM_CREDENTIAL_UPDATE_DEFINED

// end_ntsecpkg

#undef SIZE_IS
#undef SWITCH_IS
#undef SWITCH_TYPE
#undef CASE
#undef VAR_SIZE_ARRAY
#undef RANGE

#ifdef __cplusplus
}
#endif

#endif // _NTSAM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\oledberr.h ===
//-----------------------------------------------------------------------------
// File:			OledbErr.mc
//
// Copyright:		Copyright (c) Microsoft Corporation          
//
// Contents: 		
//
// Comments: 		
//
//
//-----------------------------------------------------------------------------
#ifndef _MSADERR_H_
#define _MSADERR_H_
#ifndef FACILITY_WINDOWS				  	
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_STORAGE                 0x3
#define FACILITY_ITF                     0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: DB_E_BOGUS
//
// MessageText:
//
// Dummy error - need this error so that mc puts the above defines
// inside the FACILITY_WINDOWS guard, instead of leaving it empty
//
#define DB_E_BOGUS                       ((HRESULT)0x80040EFFL)

#endif // FACILITY_WINDOWS

//
// Codes 0x0e00-0x0eff are reserved for the OLE DB group of
// interfaces.
//
// Free codes are:
//
//		Error:
//						
//
//		Success:
//			0x0eea
//			
//


//
// OLEDBVER
//	OLE DB version number (0x0270); this can be overridden with an older
// version number if necessary
//

// If OLEDBVER is not defined, assume version 2.7
#ifndef OLEDBVER
#define OLEDBVER 0x0270
#endif

//
// MessageId: DB_E_BADACCESSORHANDLE
//
// MessageText:
//
// Accessor is invalid.
//
#define DB_E_BADACCESSORHANDLE           ((HRESULT)0x80040E00L)

//
// MessageId: DB_E_ROWLIMITEXCEEDED
//
// MessageText:
//
// Row could not be inserted into the rowset without exceeding provider's maximum number of active rows.
//
#define DB_E_ROWLIMITEXCEEDED            ((HRESULT)0x80040E01L)

//
// MessageId: DB_E_READONLYACCESSOR
//
// MessageText:
//
// Accessor is read-only. Operation failed.
//
#define DB_E_READONLYACCESSOR            ((HRESULT)0x80040E02L)

//
// MessageId: DB_E_SCHEMAVIOLATION
//
// MessageText:
//
// Values violate the database schema.
//
#define DB_E_SCHEMAVIOLATION             ((HRESULT)0x80040E03L)

//
// MessageId: DB_E_BADROWHANDLE
//
// MessageText:
//
// Row handle is invalid.
//
#define DB_E_BADROWHANDLE                ((HRESULT)0x80040E04L)

//
// MessageId: DB_E_OBJECTOPEN
//
// MessageText:
//
// Object was open.
//
#define DB_E_OBJECTOPEN                  ((HRESULT)0x80040E05L)

//@@@+ V1.5
#if( OLEDBVER >= 0x0150 )
//
// MessageId: DB_E_BADCHAPTER
//
// MessageText:
//
// Chapter is invalid.
//
#define DB_E_BADCHAPTER                  ((HRESULT)0x80040E06L)

#endif // OLEDBVER >= 0x0150
//@@@- V1.5

//
// MessageId: DB_E_CANTCONVERTVALUE
//
// MessageText:
//
// Data or literal value could not be converted to the type of the column in the data source, and the provider was unable to determine which columns could not be converted.  Data overflow or sign mismatch was not the cause.
//
#define DB_E_CANTCONVERTVALUE            ((HRESULT)0x80040E07L)

//
// MessageId: DB_E_BADBINDINFO
//
// MessageText:
//
// Binding information is invalid.
//
#define DB_E_BADBINDINFO                 ((HRESULT)0x80040E08L)

//
// MessageId: DB_SEC_E_PERMISSIONDENIED
//
// MessageText:
//
// Permission denied.
//
#define DB_SEC_E_PERMISSIONDENIED        ((HRESULT)0x80040E09L)

//
// MessageId: DB_E_NOTAREFERENCECOLUMN
//
// MessageText:
//
// Column does not contain bookmarks or chapters.
//
#define DB_E_NOTAREFERENCECOLUMN         ((HRESULT)0x80040E0AL)

//@@@+ V2.5
#if( OLEDBVER >= 0x0250 )
//
// MessageId: DB_E_LIMITREJECTED
//
// MessageText:
//
// Cost limits were rejected.
//
#define DB_E_LIMITREJECTED               ((HRESULT)0x80040E0BL)

#endif // OLEDBVER >= 0x0250
//@@@- V2.5

//
// MessageId: DB_E_NOCOMMAND
//
// MessageText:
//
// Command text was not set for the command object.
//
#define DB_E_NOCOMMAND                   ((HRESULT)0x80040E0CL)

//@@@+ V2.5
#if( OLEDBVER >= 0x0250 )
//
// MessageId: DB_E_COSTLIMIT
//
// MessageText:
//
// Query plan within the cost limit cannot be found.
//
#define DB_E_COSTLIMIT                   ((HRESULT)0x80040E0DL)

#endif // OLEDBVER >= 0x0250
//@@@- V2.5

//
// MessageId: DB_E_BADBOOKMARK
//
// MessageText:
//
// Bookmark is invalid.
//
#define DB_E_BADBOOKMARK                 ((HRESULT)0x80040E0EL)

//
// MessageId: DB_E_BADLOCKMODE
//
// MessageText:
//
// Lock mode is invalid.
//
#define DB_E_BADLOCKMODE                 ((HRESULT)0x80040E0FL)

//
// MessageId: DB_E_PARAMNOTOPTIONAL
//
// MessageText:
//
// No value given for one or more required parameters.
//
#define DB_E_PARAMNOTOPTIONAL            ((HRESULT)0x80040E10L)

//
// MessageId: DB_E_BADCOLUMNID
//
// MessageText:
//
// Column ID is invalid.
//
#define DB_E_BADCOLUMNID                 ((HRESULT)0x80040E11L)

//
// MessageId: DB_E_BADRATIO
//
// MessageText:
//
// Numerator was greater than denominator. Values must express ratio between zero and 1.
//
#define DB_E_BADRATIO                    ((HRESULT)0x80040E12L)

//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )
//
// MessageId: DB_E_BADVALUES
//
// MessageText:
//
// Value is invalid.
//
#define DB_E_BADVALUES                   ((HRESULT)0x80040E13L)

#endif // OLEDBVER >= 0x0200
//@@@- V2.0

//
// MessageId: DB_E_ERRORSINCOMMAND
//
// MessageText:
//
// One or more errors occurred during processing of command.
//
#define DB_E_ERRORSINCOMMAND             ((HRESULT)0x80040E14L)

//
// MessageId: DB_E_CANTCANCEL
//
// MessageText:
//
// Command cannot be canceled.
//
#define DB_E_CANTCANCEL                  ((HRESULT)0x80040E15L)

//
// MessageId: DB_E_DIALECTNOTSUPPORTED
//
// MessageText:
//
// Command dialect is not supported by this provider.
//
#define DB_E_DIALECTNOTSUPPORTED         ((HRESULT)0x80040E16L)

//
// MessageId: DB_E_DUPLICATEDATASOURCE
//
// MessageText:
//
// Data source object could not be created because the named data source already exists.
//
#define DB_E_DUPLICATEDATASOURCE         ((HRESULT)0x80040E17L)

//
// MessageId: DB_E_CANNOTRESTART
//
// MessageText:
//
// Rowset position cannot be restarted.
//
#define DB_E_CANNOTRESTART               ((HRESULT)0x80040E18L)

//
// MessageId: DB_E_NOTFOUND
//
// MessageText:
//
// Object or data matching the name, range, or selection criteria was not found within the scope of this operation.
//
#define DB_E_NOTFOUND                    ((HRESULT)0x80040E19L)

//
// MessageId: DB_E_NEWLYINSERTED
//
// MessageText:
//
// Identity cannot be determined for newly inserted rows.
//
#define DB_E_NEWLYINSERTED               ((HRESULT)0x80040E1BL)

//@@@+ V2.5
#if( OLEDBVER >= 0x0250 )
//
// MessageId: DB_E_CANNOTFREE
//
// MessageText:
//
// Provider has ownership of this tree.
//
#define DB_E_CANNOTFREE                  ((HRESULT)0x80040E1AL)

//
// MessageId: DB_E_GOALREJECTED
//
// MessageText:
//
// Goal was rejected because no nonzero weights were specified for any goals supported. Current goal was not changed.
//
#define DB_E_GOALREJECTED                ((HRESULT)0x80040E1CL)

#endif // OLEDBVER >= 0x0250
//@@@- V2.5

//
// MessageId: DB_E_UNSUPPORTEDCONVERSION
//
// MessageText:
//
// Requested conversion is not supported.
//
#define DB_E_UNSUPPORTEDCONVERSION       ((HRESULT)0x80040E1DL)

//
// MessageId: DB_E_BADSTARTPOSITION
//
// MessageText:
//
// No rows were returned because the offset value moves the position before the beginning or after the end of the rowset.
//
#define DB_E_BADSTARTPOSITION            ((HRESULT)0x80040E1EL)

//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )
//
// MessageId: DB_E_NOQUERY
//
// MessageText:
//
// Information was requested for a query and the query was not set.
//
#define DB_E_NOQUERY                     ((HRESULT)0x80040E1FL)

#endif // OLEDBVER >= 0x0200
//@@@- V2.0

//
// MessageId: DB_E_NOTREENTRANT
//
// MessageText:
//
// Consumer's event handler called a non-reentrant method in the provider.
//
#define DB_E_NOTREENTRANT                ((HRESULT)0x80040E20L)

//
// MessageId: DB_E_ERRORSOCCURRED
//
// MessageText:
//
// Multiple-step OLE DB operation generated errors. Check each OLE DB status value, if available. No work was done.
//
#define DB_E_ERRORSOCCURRED              ((HRESULT)0x80040E21L)

//
// MessageId: DB_E_NOAGGREGATION
//
// MessageText:
//
// Non-NULL controlling IUnknown was specified, and either the requested interface was not 
// IUnknown, or the provider does not support COM aggregation.
//
#define DB_E_NOAGGREGATION               ((HRESULT)0x80040E22L)

//
// MessageId: DB_E_DELETEDROW
//
// MessageText:
//
// Row handle referred to a deleted row or a row marked for deletion.
//
#define DB_E_DELETEDROW                  ((HRESULT)0x80040E23L)

//
// MessageId: DB_E_CANTFETCHBACKWARDS
//
// MessageText:
//
// Rowset does not support fetching backward.
//
#define DB_E_CANTFETCHBACKWARDS          ((HRESULT)0x80040E24L)

//
// MessageId: DB_E_ROWSNOTRELEASED
//
// MessageText:
//
// Row handles must all be released before new ones can be obtained.
//
#define DB_E_ROWSNOTRELEASED             ((HRESULT)0x80040E25L)

//
// MessageId: DB_E_BADSTORAGEFLAG
//
// MessageText:
//
// One or more storage flags are not supported.
//
#define DB_E_BADSTORAGEFLAG              ((HRESULT)0x80040E26L)

//@@@+ V1.5
#if( OLEDBVER >= 0x0150 )
//
// MessageId: DB_E_BADCOMPAREOP
//
// MessageText:
//
// Comparison operator is invalid.
//
#define DB_E_BADCOMPAREOP                ((HRESULT)0x80040E27L)

#endif // OLEDBVER >= 0x0150
//@@@- V1.5

//
// MessageId: DB_E_BADSTATUSVALUE
//
// MessageText:
//
// Status flag was neither DBCOLUMNSTATUS_OK nor
// DBCOLUMNSTATUS_ISNULL.
//
#define DB_E_BADSTATUSVALUE              ((HRESULT)0x80040E28L)

//
// MessageId: DB_E_CANTSCROLLBACKWARDS
//
// MessageText:
//
// Rowset does not support scrolling backward.
//
#define DB_E_CANTSCROLLBACKWARDS         ((HRESULT)0x80040E29L)

//@@@+ V2.5
#if( OLEDBVER >= 0x0250 )
//
// MessageId: DB_E_BADREGIONHANDLE
//
// MessageText:
//
// Region handle is invalid.
//
#define DB_E_BADREGIONHANDLE             ((HRESULT)0x80040E2AL)

//
// MessageId: DB_E_NONCONTIGUOUSRANGE
//
// MessageText:
//
// Set of rows is not contiguous to, or does not overlap, the rows in the watch region.
//
#define DB_E_NONCONTIGUOUSRANGE          ((HRESULT)0x80040E2BL)

//
// MessageId: DB_E_INVALIDTRANSITION
//
// MessageText:
//
// Transition from ALL* to MOVE* or EXTEND* was specified.
//
#define DB_E_INVALIDTRANSITION           ((HRESULT)0x80040E2CL)

//
// MessageId: DB_E_NOTASUBREGION
//
// MessageText:
//
// Region is not a proper subregion of the region identified by the watch region handle.
//
#define DB_E_NOTASUBREGION               ((HRESULT)0x80040E2DL)

#endif // OLEDBVER >= 0x0250
//@@@- V2.5

//
// MessageId: DB_E_MULTIPLESTATEMENTS
//
// MessageText:
//
// Multiple-statement commands are not supported by this provider.
//
#define DB_E_MULTIPLESTATEMENTS          ((HRESULT)0x80040E2EL)

//
// MessageId: DB_E_INTEGRITYVIOLATION
//
// MessageText:
//
// Value violated the integrity constraints for a column or table.
//
#define DB_E_INTEGRITYVIOLATION          ((HRESULT)0x80040E2FL)

//
// MessageId: DB_E_BADTYPENAME
//
// MessageText:
//
// Type name is invalid.
//
#define DB_E_BADTYPENAME                 ((HRESULT)0x80040E30L)

//
// MessageId: DB_E_ABORTLIMITREACHED
//
// MessageText:
//
// Execution stopped because a resource limit was reached. No results were returned.
//
#define DB_E_ABORTLIMITREACHED           ((HRESULT)0x80040E31L)

//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )
//
// MessageId: DB_E_ROWSETINCOMMAND
//
// MessageText:
//
// Command object whose command tree contains a rowset or rowsets cannot be cloned.
//
#define DB_E_ROWSETINCOMMAND             ((HRESULT)0x80040E32L)

//
// MessageId: DB_E_CANTTRANSLATE
//
// MessageText:
//
// Current tree cannot be represented as text.
//
#define DB_E_CANTTRANSLATE               ((HRESULT)0x80040E33L)

#endif // OLEDBVER >= 0x0200
//@@@- V2.0

//
// MessageId: DB_E_DUPLICATEINDEXID
//
// MessageText:
//
// Index already exists.
//
#define DB_E_DUPLICATEINDEXID            ((HRESULT)0x80040E34L)

//
// MessageId: DB_E_NOINDEX
//
// MessageText:
//
// Index does not exist.
//
#define DB_E_NOINDEX                     ((HRESULT)0x80040E35L)

//
// MessageId: DB_E_INDEXINUSE
//
// MessageText:
//
// Index is in use.
//
#define DB_E_INDEXINUSE                  ((HRESULT)0x80040E36L)

//
// MessageId: DB_E_NOTABLE
//
// MessageText:
//
// Table does not exist.
//
#define DB_E_NOTABLE                     ((HRESULT)0x80040E37L)

//
// MessageId: DB_E_CONCURRENCYVIOLATION
//
// MessageText:
//
// Rowset used optimistic concurrency and the value of a column has changed since it was last read.
//
#define DB_E_CONCURRENCYVIOLATION        ((HRESULT)0x80040E38L)

//
// MessageId: DB_E_BADCOPY
//
// MessageText:
//
// Errors detected during the copy.
//
#define DB_E_BADCOPY                     ((HRESULT)0x80040E39L)

//
// MessageId: DB_E_BADPRECISION
//
// MessageText:
//
// Precision is invalid.
//
#define DB_E_BADPRECISION                ((HRESULT)0x80040E3AL)

//
// MessageId: DB_E_BADSCALE
//
// MessageText:
//
// Scale is invalid.
//
#define DB_E_BADSCALE                    ((HRESULT)0x80040E3BL)

//
// MessageId: DB_E_BADTABLEID
//
// MessageText:
//
// Table ID is invalid.
//
#define DB_E_BADTABLEID                  ((HRESULT)0x80040E3CL)

// DB_E_BADID is deprecated; use DB_E_BADTABLEID instead
#define DB_E_BADID DB_E_BADTABLEID

//
// MessageId: DB_E_BADTYPE
//
// MessageText:
//
// Type is invalid.
//
#define DB_E_BADTYPE                     ((HRESULT)0x80040E3DL)

//
// MessageId: DB_E_DUPLICATECOLUMNID
//
// MessageText:
//
// Column ID already exists or occurred more than once in the array of columns.
//
#define DB_E_DUPLICATECOLUMNID           ((HRESULT)0x80040E3EL)

//
// MessageId: DB_E_DUPLICATETABLEID
//
// MessageText:
//
// Table already exists.
//
#define DB_E_DUPLICATETABLEID            ((HRESULT)0x80040E3FL)

//
// MessageId: DB_E_TABLEINUSE
//
// MessageText:
//
// Table is in use.
//
#define DB_E_TABLEINUSE                  ((HRESULT)0x80040E40L)

//
// MessageId: DB_E_NOLOCALE
//
// MessageText:
//
// Locale ID is not supported.
//
#define DB_E_NOLOCALE                    ((HRESULT)0x80040E41L)

//
// MessageId: DB_E_BADRECORDNUM
//
// MessageText:
//
// Record number is invalid.
//
#define DB_E_BADRECORDNUM                ((HRESULT)0x80040E42L)

//
// MessageId: DB_E_BOOKMARKSKIPPED
//
// MessageText:
//
// Form of bookmark is valid, but no row was found to match it.
//
#define DB_E_BOOKMARKSKIPPED             ((HRESULT)0x80040E43L)

//
// MessageId: DB_E_BADPROPERTYVALUE
//
// MessageText:
//
// Property value is invalid.
//
#define DB_E_BADPROPERTYVALUE            ((HRESULT)0x80040E44L)

//
// MessageId: DB_E_INVALID
//
// MessageText:
//
// Rowset is not chaptered.
//
#define DB_E_INVALID                     ((HRESULT)0x80040E45L)

//
// MessageId: DB_E_BADACCESSORFLAGS
//
// MessageText:
//
// One or more accessor flags were invalid.
//
#define DB_E_BADACCESSORFLAGS            ((HRESULT)0x80040E46L)

//
// MessageId: DB_E_BADSTORAGEFLAGS
//
// MessageText:
//
// One or more storage flags are invalid.
//
#define DB_E_BADSTORAGEFLAGS             ((HRESULT)0x80040E47L)

//
// MessageId: DB_E_BYREFACCESSORNOTSUPPORTED
//
// MessageText:
//
// Reference accessors are not supported by this provider.
//
#define DB_E_BYREFACCESSORNOTSUPPORTED   ((HRESULT)0x80040E48L)

//
// MessageId: DB_E_NULLACCESSORNOTSUPPORTED
//
// MessageText:
//
// Null accessors are not supported by this provider.
//
#define DB_E_NULLACCESSORNOTSUPPORTED    ((HRESULT)0x80040E49L)

//
// MessageId: DB_E_NOTPREPARED
//
// MessageText:
//
// Command was not prepared.
//
#define DB_E_NOTPREPARED                 ((HRESULT)0x80040E4AL)

//
// MessageId: DB_E_BADACCESSORTYPE
//
// MessageText:
//
// Accessor is not a parameter accessor.
//
#define DB_E_BADACCESSORTYPE             ((HRESULT)0x80040E4BL)

//
// MessageId: DB_E_WRITEONLYACCESSOR
//
// MessageText:
//
// Accessor is write-only.
//
#define DB_E_WRITEONLYACCESSOR           ((HRESULT)0x80040E4CL)

//
// MessageId: DB_SEC_E_AUTH_FAILED
//
// MessageText:
//
// Authentication failed.
//
#define DB_SEC_E_AUTH_FAILED             ((HRESULT)0x80040E4DL)

//
// MessageId: DB_E_CANCELED
//
// MessageText:
//
// Operation was canceled.
//
#define DB_E_CANCELED                    ((HRESULT)0x80040E4EL)

//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )
//
// MessageId: DB_E_CHAPTERNOTRELEASED
//
// MessageText:
//
// Rowset is single-chaptered. The chapter was not released.
//
#define DB_E_CHAPTERNOTRELEASED          ((HRESULT)0x80040E4FL)

#endif // OLEDBVER >= 0x0200
//@@@- V2.0

//
// MessageId: DB_E_BADSOURCEHANDLE
//
// MessageText:
//
// Source handle is invalid.
//
#define DB_E_BADSOURCEHANDLE             ((HRESULT)0x80040E50L)

//
// MessageId: DB_E_PARAMUNAVAILABLE
//
// MessageText:
//
// Provider cannot derive parameter information and SetParameterInfo has not been called.
//
#define DB_E_PARAMUNAVAILABLE            ((HRESULT)0x80040E51L)

//
// MessageId: DB_E_ALREADYINITIALIZED
//
// MessageText:
//
// Data source object is already initialized.
//
#define DB_E_ALREADYINITIALIZED          ((HRESULT)0x80040E52L)

//
// MessageId: DB_E_NOTSUPPORTED
//
// MessageText:
//
// Method is not supported by this provider.
//
#define DB_E_NOTSUPPORTED                ((HRESULT)0x80040E53L)

//
// MessageId: DB_E_MAXPENDCHANGESEXCEEDED
//
// MessageText:
//
// Number of rows with pending changes exceeded the limit.
//
#define DB_E_MAXPENDCHANGESEXCEEDED      ((HRESULT)0x80040E54L)

//
// MessageId: DB_E_BADORDINAL
//
// MessageText:
//
// Column does not exist.
//
#define DB_E_BADORDINAL                  ((HRESULT)0x80040E55L)

//
// MessageId: DB_E_PENDINGCHANGES
//
// MessageText:
//
// Pending changes exist on a row with a reference count of zero.
//
#define DB_E_PENDINGCHANGES              ((HRESULT)0x80040E56L)

//
// MessageId: DB_E_DATAOVERFLOW
//
// MessageText:
//
// Literal value in the command exceeded the range of the type of the associated column.
//
#define DB_E_DATAOVERFLOW                ((HRESULT)0x80040E57L)

//
// MessageId: DB_E_BADHRESULT
//
// MessageText:
//
// HRESULT is invalid.
//
#define DB_E_BADHRESULT                  ((HRESULT)0x80040E58L)

//
// MessageId: DB_E_BADLOOKUPID
//
// MessageText:
//
// Lookup ID is invalid.
//
#define DB_E_BADLOOKUPID                 ((HRESULT)0x80040E59L)

//
// MessageId: DB_E_BADDYNAMICERRORID
//
// MessageText:
//
// DynamicError ID is invalid.
//
#define DB_E_BADDYNAMICERRORID           ((HRESULT)0x80040E5AL)

//
// MessageId: DB_E_PENDINGINSERT
//
// MessageText:
//
// Most recent data for a newly inserted row could not be retrieved because the insert is pending.
//
#define DB_E_PENDINGINSERT               ((HRESULT)0x80040E5BL)

//
// MessageId: DB_E_BADCONVERTFLAG
//
// MessageText:
//
// Conversion flag is invalid.
//
#define DB_E_BADCONVERTFLAG              ((HRESULT)0x80040E5CL)

//
// MessageId: DB_E_BADPARAMETERNAME
//
// MessageText:
//
// Parameter name is unrecognized.
//
#define DB_E_BADPARAMETERNAME            ((HRESULT)0x80040E5DL)

//
// MessageId: DB_E_MULTIPLESTORAGE
//
// MessageText:
//
// Multiple storage objects cannot be open simultaneously.
//
#define DB_E_MULTIPLESTORAGE             ((HRESULT)0x80040E5EL)

//
// MessageId: DB_E_CANTFILTER
//
// MessageText:
//
// Filter cannot be opened.
//
#define DB_E_CANTFILTER                  ((HRESULT)0x80040E5FL)

//
// MessageId: DB_E_CANTORDER
//
// MessageText:
//
// Order cannot be opened.
//
#define DB_E_CANTORDER                   ((HRESULT)0x80040E60L)

//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )
//
// MessageId: MD_E_BADTUPLE
//
// MessageText:
//
// Tuple is invalid.
//
#define MD_E_BADTUPLE                    ((HRESULT)0x80040E61L)

//
// MessageId: MD_E_BADCOORDINATE
//
// MessageText:
//
// Coordinate is invalid.
//
#define MD_E_BADCOORDINATE               ((HRESULT)0x80040E62L)

//
// MessageId: MD_E_INVALIDAXIS
//
// MessageText:
//
// Axis is invalid.
//
#define MD_E_INVALIDAXIS                 ((HRESULT)0x80040E63L)

//
// MessageId: MD_E_INVALIDCELLRANGE
//
// MessageText:
//
// One or more cell ordinals is invalid.
//
#define MD_E_INVALIDCELLRANGE            ((HRESULT)0x80040E64L)

//
// MessageId: DB_E_NOCOLUMN
//
// MessageText:
//
// Column ID is invalid.
//
#define DB_E_NOCOLUMN                    ((HRESULT)0x80040E65L)

//
// MessageId: DB_E_COMMANDNOTPERSISTED
//
// MessageText:
//
// Command does not have a DBID.
//
#define DB_E_COMMANDNOTPERSISTED         ((HRESULT)0x80040E67L)

//
// MessageId: DB_E_DUPLICATEID
//
// MessageText:
//
// DBID already exists.
//
#define DB_E_DUPLICATEID                 ((HRESULT)0x80040E68L)

//
// MessageId: DB_E_OBJECTCREATIONLIMITREACHED
//
// MessageText:
//
// Session cannot be created because maximum number of active sessions was already reached. Consumer must release one or more sessions before creating a new session object. 
//
#define DB_E_OBJECTCREATIONLIMITREACHED  ((HRESULT)0x80040E69L)

//
// MessageId: DB_E_BADINDEXID
//
// MessageText:
//
// Index ID is invalid.
//
#define DB_E_BADINDEXID                  ((HRESULT)0x80040E72L)

//
// MessageId: DB_E_BADINITSTRING
//
// MessageText:
//
// Format of the initialization string does not conform to the OLE DB specification.
//
#define DB_E_BADINITSTRING               ((HRESULT)0x80040E73L)

//
// MessageId: DB_E_NOPROVIDERSREGISTERED
//
// MessageText:
//
// No OLE DB providers of this source type are registered.
//
#define DB_E_NOPROVIDERSREGISTERED       ((HRESULT)0x80040E74L)

//
// MessageId: DB_E_MISMATCHEDPROVIDER
//
// MessageText:
//
// Initialization string specifies a provider that does not match the active provider.
//
#define DB_E_MISMATCHEDPROVIDER          ((HRESULT)0x80040E75L)

//
// MessageId: DB_E_BADCOMMANDID
//
// MessageText:
//
// DBID is invalid.
//
#define DB_E_BADCOMMANDID                ((HRESULT)0x80040E76L)

#endif // OLEDBVER >= 0x0200
//@@@- V2.0
//@@@+ V2.1
#if( OLEDBVER >= 0x0210 )
#define SEC_E_PERMISSIONDENIED DB_SEC_E_PERMISSIONDENIED
//
// MessageId: SEC_E_BADTRUSTEEID
//
// MessageText:
//
// Trustee is invalid.
//
#define SEC_E_BADTRUSTEEID               ((HRESULT)0x80040E6AL)

//
// MessageId: SEC_E_NOTRUSTEEID
//
// MessageText:
//
// Trustee was not recognized for this data source.
//
#define SEC_E_NOTRUSTEEID                ((HRESULT)0x80040E6BL)

//
// MessageId: SEC_E_NOMEMBERSHIPSUPPORT
//
// MessageText:
//
// Trustee does not support memberships or collections.
//
#define SEC_E_NOMEMBERSHIPSUPPORT        ((HRESULT)0x80040E6CL)

//
// MessageId: SEC_E_INVALIDOBJECT
//
// MessageText:
//
// Object is invalid or unknown to the provider.
//
#define SEC_E_INVALIDOBJECT              ((HRESULT)0x80040E6DL)

//
// MessageId: SEC_E_NOOWNER
//
// MessageText:
//
// Object does not have an owner.
//
#define SEC_E_NOOWNER                    ((HRESULT)0x80040E6EL)

//
// MessageId: SEC_E_INVALIDACCESSENTRYLIST
//
// MessageText:
//
// Access entry list is invalid.
//
#define SEC_E_INVALIDACCESSENTRYLIST     ((HRESULT)0x80040E6FL)

//
// MessageId: SEC_E_INVALIDOWNER
//
// MessageText:
//
// Trustee supplied as owner is invalid or unknown to the provider.
//
#define SEC_E_INVALIDOWNER               ((HRESULT)0x80040E70L)

//
// MessageId: SEC_E_INVALIDACCESSENTRY
//
// MessageText:
//
// Permission in the access entry list is invalid.
//
#define SEC_E_INVALIDACCESSENTRY         ((HRESULT)0x80040E71L)

//
// MessageId: DB_E_BADCONSTRAINTTYPE
//
// MessageText:
//
// ConstraintType is invalid or not supported by the provider.
//
#define DB_E_BADCONSTRAINTTYPE           ((HRESULT)0x80040E77L)

//
// MessageId: DB_E_BADCONSTRAINTFORM
//
// MessageText:
//
// ConstraintType is not DBCONSTRAINTTYPE_FOREIGNKEY and cForeignKeyColumns is not zero.
//
#define DB_E_BADCONSTRAINTFORM           ((HRESULT)0x80040E78L)

//
// MessageId: DB_E_BADDEFERRABILITY
//
// MessageText:
//
// Specified deferrability flag is invalid or not supported by the provider.
//
#define DB_E_BADDEFERRABILITY            ((HRESULT)0x80040E79L)

//
// MessageId: DB_E_BADMATCHTYPE
//
// MessageText:
//
// MatchType is invalid or the value is not supported by the provider.
//
#define DB_E_BADMATCHTYPE                ((HRESULT)0x80040E80L)

//
// MessageId: DB_E_BADUPDATEDELETERULE
//
// MessageText:
//
// Constraint update rule or delete rule is invalid.
//
#define DB_E_BADUPDATEDELETERULE         ((HRESULT)0x80040E8AL)

//
// MessageId: DB_E_BADCONSTRAINTID
//
// MessageText:
//
// Constraint ID is invalid.
//
#define DB_E_BADCONSTRAINTID             ((HRESULT)0x80040E8BL)

//
// MessageId: DB_E_BADCOMMANDFLAGS
//
// MessageText:
//
// Command persistence flag is invalid.
//
#define DB_E_BADCOMMANDFLAGS             ((HRESULT)0x80040E8CL)

//
// MessageId: DB_E_OBJECTMISMATCH
//
// MessageText:
//
// rguidColumnType points to a GUID that does not match the object type of this column, or this column was not set.
//
#define DB_E_OBJECTMISMATCH              ((HRESULT)0x80040E8DL)

//
// MessageId: DB_E_NOSOURCEOBJECT
//
// MessageText:
//
// Source row does not exist.
//
#define DB_E_NOSOURCEOBJECT              ((HRESULT)0x80040E91L)

//
// MessageId: DB_E_RESOURCELOCKED
//
// MessageText:
//
// OLE DB object represented by this URL is locked by one or more other processes.
//
#define DB_E_RESOURCELOCKED              ((HRESULT)0x80040E92L)

//
// MessageId: DB_E_NOTCOLLECTION
//
// MessageText:
//
// Client requested an object type that is valid only for a collection. 
//
#define DB_E_NOTCOLLECTION               ((HRESULT)0x80040E93L)

//
// MessageId: DB_E_READONLY
//
// MessageText:
//
// Caller requested write access to a read-only object.
//
#define DB_E_READONLY                    ((HRESULT)0x80040E94L)

//
// MessageId: DB_E_ASYNCNOTSUPPORTED
//
// MessageText:
//
// Asynchronous binding is not supported by this provider.
//
#define DB_E_ASYNCNOTSUPPORTED           ((HRESULT)0x80040E95L)

//
// MessageId: DB_E_CANNOTCONNECT
//
// MessageText:
//
// Connection to the server for this URL cannot be established.
//
#define DB_E_CANNOTCONNECT               ((HRESULT)0x80040E96L)

//
// MessageId: DB_E_TIMEOUT
//
// MessageText:
//
// Timeout occurred when attempting to bind to the object.
//
#define DB_E_TIMEOUT                     ((HRESULT)0x80040E97L)

//
// MessageId: DB_E_RESOURCEEXISTS
//
// MessageText:
//
// Object cannot be created at this URL because an object named by this URL already exists.
//
#define DB_E_RESOURCEEXISTS              ((HRESULT)0x80040E98L)

//
// MessageId: DB_E_RESOURCEOUTOFSCOPE
//
// MessageText:
//
// URL is outside of scope.
//
#define DB_E_RESOURCEOUTOFSCOPE          ((HRESULT)0x80040E8EL)

//
// MessageId: DB_E_DROPRESTRICTED
//
// MessageText:
//
// Column or constraint could not be dropped because it is referenced by a dependent view or constraint.
//
#define DB_E_DROPRESTRICTED              ((HRESULT)0x80040E90L)

//
// MessageId: DB_E_DUPLICATECONSTRAINTID
//
// MessageText:
//
// Constraint already exists.
//
#define DB_E_DUPLICATECONSTRAINTID       ((HRESULT)0x80040E99L)

//
// MessageId: DB_E_OUTOFSPACE
//
// MessageText:
//
// Object cannot be created at this URL because the server is out of physical storage.
//
#define DB_E_OUTOFSPACE                  ((HRESULT)0x80040E9AL)

#define SEC_E_PERMISSIONDENIED DB_SEC_E_PERMISSIONDENIED
#endif // OLEDBVER >= 0x0210
//@@@- V2.1
//@@@+ V2.5
#if( OLEDBVER >= 0x0250 )
//
// MessageId: DB_SEC_E_SAFEMODE_DENIED
//
// MessageText:
//
// Safety settings on this computer prohibit accessing a data source on another domain.
//
#define DB_SEC_E_SAFEMODE_DENIED         ((HRESULT)0x80040E9BL)

#endif // OLEDBVER >= 0x0250
//@@@- V2.5

//@@@+ V2.6
#if( OLEDBVER >= 0x0260 )
//
// MessageId: DB_E_NOSTATISTIC
//
// MessageText:
//
// The specified statistic does not exist in the current data source or did not apply to the specified table or it does not support a histogram. 
//
#define DB_E_NOSTATISTIC                 ((HRESULT)0x80040E9CL)

//
// MessageId: DB_E_ALTERRESTRICTED
//
// MessageText:
//
// Column or table could not be altered because it is referenced by a constraint.
//
#define DB_E_ALTERRESTRICTED             ((HRESULT)0x80040E9DL)

//
// MessageId: DB_E_RESOURCENOTSUPPORTED
//
// MessageText:
//
// Requested object type is not supported by the provider.
//
#define DB_E_RESOURCENOTSUPPORTED        ((HRESULT)0x80040E9EL)

//
// MessageId: DB_E_NOCONSTRAINT
//
// MessageText:
//
// Constraint does not exist.
//
#define DB_E_NOCONSTRAINT                ((HRESULT)0x80040E9FL)

//
// MessageId: DB_E_COLUMNUNAVAILABLE
//
// MessageText:
//
// Requested column is valid, but could not be retrieved. This could be due to a forward only cursor attempting to go backwards in a row.
//
#define DB_E_COLUMNUNAVAILABLE           ((HRESULT)0x80040EA0L)

#endif // OLEDBVER >= 0x0260
//@@@- V2.6
//
// MessageId: DB_S_ROWLIMITEXCEEDED
//
// MessageText:
//
// Fetching requested number of rows will exceed total number of active rows supported by the rowset.
//
#define DB_S_ROWLIMITEXCEEDED            ((HRESULT)0x00040EC0L)

//
// MessageId: DB_S_COLUMNTYPEMISMATCH
//
// MessageText:
//
// One or more column types are incompatible. Conversion errors will occur during copying.
//
#define DB_S_COLUMNTYPEMISMATCH          ((HRESULT)0x00040EC1L)

//
// MessageId: DB_S_TYPEINFOOVERRIDDEN
//
// MessageText:
//
// Parameter type information was overridden by caller.
//
#define DB_S_TYPEINFOOVERRIDDEN          ((HRESULT)0x00040EC2L)

//
// MessageId: DB_S_BOOKMARKSKIPPED
//
// MessageText:
//
// Bookmark was skipped for deleted or nonmember row.
//
#define DB_S_BOOKMARKSKIPPED             ((HRESULT)0x00040EC3L)

//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )
//
// MessageId: DB_S_NONEXTROWSET
//
// MessageText:
//
// No more rowsets.
//
#define DB_S_NONEXTROWSET                ((HRESULT)0x00040EC5L)

#endif // OLEDBVER >= 0x0200
//@@@- V2.0

//
// MessageId: DB_S_ENDOFROWSET
//
// MessageText:
//
// Start or end of rowset or chapter was reached.
//
#define DB_S_ENDOFROWSET                 ((HRESULT)0x00040EC6L)

//
// MessageId: DB_S_COMMANDREEXECUTED
//
// MessageText:
//
// Command was reexecuted.
//
#define DB_S_COMMANDREEXECUTED           ((HRESULT)0x00040EC7L)

//
// MessageId: DB_S_BUFFERFULL
//
// MessageText:
//
// Operation succeeded, but status array or string buffer could not be allocated. 
//
#define DB_S_BUFFERFULL                  ((HRESULT)0x00040EC8L)

//
// MessageId: DB_S_NORESULT
//
// MessageText:
//
// No more results.
//
#define DB_S_NORESULT                    ((HRESULT)0x00040EC9L)

//
// MessageId: DB_S_CANTRELEASE
//
// MessageText:
//
// Server cannot release or downgrade a lock until the end of the transaction.
//
#define DB_S_CANTRELEASE                 ((HRESULT)0x00040ECAL)

//@@@+ V2.5
#if( OLEDBVER >= 0x0250 )
//
// MessageId: DB_S_GOALCHANGED
//
// MessageText:
//
// Weight is not supported or exceeded the supported limit, and was set to 0 or the supported limit.
//
#define DB_S_GOALCHANGED                 ((HRESULT)0x00040ECBL)

#endif // OLEDBVER >= 0x0250
//@@@- V2.5

//@@@+ V1.5
#if( OLEDBVER >= 0x0150 )
//
// MessageId: DB_S_UNWANTEDOPERATION
//
// MessageText:
//
// Consumer does not want to receive further notification calls for this operation. 
//
#define DB_S_UNWANTEDOPERATION           ((HRESULT)0x00040ECCL)

#endif // OLEDBVER >= 0x0150
//@@@- V1.5

//
// MessageId: DB_S_DIALECTIGNORED
//
// MessageText:
//
// Input dialect was ignored and command was processed using default dialect.
//
#define DB_S_DIALECTIGNORED              ((HRESULT)0x00040ECDL)

//
// MessageId: DB_S_UNWANTEDPHASE
//
// MessageText:
//
// Consumer does not want to receive further notification calls for this phase.
//
#define DB_S_UNWANTEDPHASE               ((HRESULT)0x00040ECEL)

//
// MessageId: DB_S_UNWANTEDREASON
//
// MessageText:
//
// Consumer does not want to receive further notification calls for this reason.
//
#define DB_S_UNWANTEDREASON              ((HRESULT)0x00040ECFL)

//@@@+ V1.5
#if( OLEDBVER >= 0x0150 )
//
// MessageId: DB_S_ASYNCHRONOUS
//
// MessageText:
//
// Operation is being processed asynchronously.
//
#define DB_S_ASYNCHRONOUS                ((HRESULT)0x00040ED0L)

#endif // OLEDBVER >= 0x0150
//@@@- V1.5

//
// MessageId: DB_S_COLUMNSCHANGED
//
// MessageText:
//
// Command was executed to reposition to the start of the rowset. Either the order of the columns changed, or columns were added to or removed from the rowset.
//
#define DB_S_COLUMNSCHANGED              ((HRESULT)0x00040ED1L)

//
// MessageId: DB_S_ERRORSRETURNED
//
// MessageText:
//
// Method had some errors, which were returned in the error array.
//
#define DB_S_ERRORSRETURNED              ((HRESULT)0x00040ED2L)

//
// MessageId: DB_S_BADROWHANDLE
//
// MessageText:
//
// Row handle is invalid.
//
#define DB_S_BADROWHANDLE                ((HRESULT)0x00040ED3L)

//
// MessageId: DB_S_DELETEDROW
//
// MessageText:
//
// Row handle referred to a deleted row.
//
#define DB_S_DELETEDROW                  ((HRESULT)0x00040ED4L)

//@@@+ V2.5
#if( OLEDBVER >= 0x0250 )
//
// MessageId: DB_S_TOOMANYCHANGES
//
// MessageText:
//
// Provider cannot keep track of all the changes. Client must refetch the data associated with the watch region by using another method.
//
#define DB_S_TOOMANYCHANGES              ((HRESULT)0x00040ED5L)

#endif // OLEDBVER >= 0x0250
//@@@- V2.5

//
// MessageId: DB_S_STOPLIMITREACHED
//
// MessageText:
//
// Execution stopped because a resource limit was reached. Results obtained so far were returned, but execution cannot resume.
//
#define DB_S_STOPLIMITREACHED            ((HRESULT)0x00040ED6L)

//
// MessageId: DB_S_LOCKUPGRADED
//
// MessageText:
//
// Lock was upgraded from the value specified.
//
#define DB_S_LOCKUPGRADED                ((HRESULT)0x00040ED8L)

//
// MessageId: DB_S_PROPERTIESCHANGED
//
// MessageText:
//
// One or more properties were changed as allowed by provider.
//
#define DB_S_PROPERTIESCHANGED           ((HRESULT)0x00040ED9L)

//
// MessageId: DB_S_ERRORSOCCURRED
//
// MessageText:
//
// Multiple-step operation completed with one or more errors. Check each status value.
//
#define DB_S_ERRORSOCCURRED              ((HRESULT)0x00040EDAL)

//
// MessageId: DB_S_PARAMUNAVAILABLE
//
// MessageText:
//
// Parameter is invalid.
//
#define DB_S_PARAMUNAVAILABLE            ((HRESULT)0x00040EDBL)

//
// MessageId: DB_S_MULTIPLECHANGES
//
// MessageText:
//
// Updating a row caused more than one row to be updated in the data source.
//
#define DB_S_MULTIPLECHANGES             ((HRESULT)0x00040EDCL)

//@@@+ V2.1
#if( OLEDBVER >= 0x0210 )
//
// MessageId: DB_S_NOTSINGLETON
//
// MessageText:
//
// Row object was requested on a non-singleton result. First row was returned.
//
#define DB_S_NOTSINGLETON                ((HRESULT)0x00040ED7L)

//
// MessageId: DB_S_NOROWSPECIFICCOLUMNS
//
// MessageText:
//
// Row has no row-specific columns.
//
#define DB_S_NOROWSPECIFICCOLUMNS        ((HRESULT)0x00040EDDL)

#endif // OLEDBVER >= 0x0210
//@@@- V2.1
// To help DSL display more meaningful error message, we need to overwrite system error message
// in the following two cases.
#ifdef MESSAGESANDHEADERS
//(0x80030002L)STG_E_FILENOTFOUND
//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
// The file could not be found.
//
#define STG_E_FILENOTFOUND               ((HRESULT)0x80030002L)

//(0x80030003L)STG_E_PATHNOTFOUND
//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
// The path could not be found.
//
#define STG_E_PATHNOTFOUND               ((HRESULT)0x80030003L)

//(0x80030050L)STG_E_FILEALREADYEXISTS
//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
// The file already exists.
//
#define STG_E_FILEALREADYEXISTS          ((HRESULT)0x80030050L)

//(0x800300fbL)STG_E_INVALIDHEADER
//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
// The file is not a valid compound file.
//
#define STG_E_INVALIDHEADER              ((HRESULT)0x800300FBL)

//(0x800300fcL)STG_E_INVALIDNAME
//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
// The name is not valid.
//
#define STG_E_INVALIDNAME                ((HRESULT)0x800300FCL)

//(0x80030104L)STG_E_OLDFORMAT
//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
// The compound file was produced with an incompatible version of storage.
//
#define STG_E_OLDFORMAT                  ((HRESULT)0x80030104L)

//(0x80030105L)STG_E_OLDDLL
//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
// The compound file was produced with an incompatible version of storage.
//
#define STG_E_OLDDLL                     ((HRESULT)0x80030105L)

#endif //MESSAGESANDHEADERS
#endif // _OLEDBERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntrxdef.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    NtRxDef.h

Abstract:

    This module defines a whole host of macros that orient the code towards NT
    as opposed to Win9x.

Author:
--*/

#ifndef _RX_NTDEFS_DEFINED_
#define _RX_NTDEFS_DEFINED_

#define INLINE __inline

//
//  from winbase.h:
//

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif //  ifndef INVALID_HANDLE_VALUE

#define RxDeviceType(__xxx) ((DEVICE_TYPE)FILE_DEVICE_##__xxx)

//
//  this macro is used in various places to assist in defining sets of constants
//  that can be used to set/clear/test specific bits in a flags-type field
//

#define RX_DEFINE_FLAG(a,c,d)  a = ((1<<c)&d),

//
//  we need this constant various places
//

#define TICKS_PER_SECOND (10 * 1000 * 1000)
#define TICKS_PER_MILLESECOND (10 * 1000)


#ifndef WRAPPER_CALLS_ONLY
#define RxSprintf sprintf
#endif //  ifndef WRAPPER_CALLS_ONLY

//
//  the next set of macros defines how to get things out of the RxContext; however, RxContext is not
//  a macro parameter; rather, the appropriate pointers are just captured from whatever RxContext happens
//  to be around. Q: "why would you use RxCaptureFcb and then reference thru capFcb instead of just having
//  a macro like RxGetFcb() === RxContext->Fcb?" A: it is done this way to help with optimization. when you make
//  the RxGetFcb() call, the Fcb will have to be reloaded from the RxContext if you have called any procs; however,
//  it will not have to be reloaded with the capture technique.
//

#ifndef MINIRDR__NAME
#define RxCaptureFcb PFCB __C_Fcb = (PFCB)(RxContext->pFcb)
#define RxCaptureFobx PFOBX __C_Fobx = (PFOBX)(RxContext->pFobx)
#else
#define RxCaptureFcb PMRX_FCB __C_Fcb = (RxContext->pFcb)
#define RxCaptureFobx PMRX_FOBX __C_Fobx = (RxContext->pFobx)
#endif

#define RxCaptureRequestPacket PIRP __C_Irp = RxContext->CurrentIrp
#define RxCaptureParamBlock PIO_STACK_LOCATION __C_IrpSp = RxContext->CurrentIrpSp
#define RxCaptureFileObject PFILE_OBJECT __C_FileObject = __C_IrpSp-> FileObject

//
//  the "cap" prefix means "Captured from the RxContext....."; it's ok after you get used to it
//

#define capFcb __C_Fcb
#define capFobx __C_Fobx
#define capPARAMS __C_IrpSp
#define capReqPacket __C_Irp
#define capFileObject __C_FileObject

#define RxAllocatePool ExAllocatePool
#define RxAllocatePoolWithTag ExAllocatePoolWithTag
#define RxFreePool ExFreePool


extern 
NTSTATUS
RxDuplicateString(
    PUNICODE_STRING *Copy,
    PUNICODE_STRING Original,
    POOL_TYPE PoolType
    );

#define RxIsResourceOwnershipStateExclusive(__r) (FlagOn((__r)->Flag, ResourceOwnedExclusive))

#define RxProtectMdlFromFree( Mdl ) {NOTHING;}
#define RxUnprotectMdlFromFree( Mdl ) {NOTHING;}
#define RxMdlIsProtected( Mdl ) (FALSE)
#define RxTakeOwnershipOfMdl( Mdl ) {NOTHING;}
#define RxDisownMdl( Mdl ) {NOTHING;}
#define RxMdlIsOwned( Mdl ) (TRUE)

#define RxAllocateMdl( Buffer, BufferSize ) \
        IoAllocateMdl( Buffer, BufferSize, FALSE, FALSE, NULL )

#define RxMdlIsLocked( Mdl )         ((Mdl)->MdlFlags & MDL_PAGES_LOCKED)
#define RxMdlSourceIsNonPaged( Mdl ) ((Mdl)->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL)
#define RxMdlIsPartial( Mdl )        ((Mdl)->MdlFlags & MDL_PARTIAL)

#undef RxProbeAndLockPages
#define RxProbeAndLockPages( Mdl, Mode, Access, Status )          \
        Status = STATUS_SUCCESS;                                  \
        try {                                                     \
           MmProbeAndLockPages((Mdl), (Mode), (Access));          \
        } except (EXCEPTION_EXECUTE_HANDLER) {                    \
           Status = GetExceptionCode();                           \
        }

//
//  Macros for dealing with network header MDLs
//

//
//  This is the amount of space we preallocate in front of the smb header to hold
//  transport headers.  This number came from the server.  I suspect it is a worse case
//  value for all the transports that support MDL_NETWORK_HEADER
//

#define TRANSPORT_HEADER_SIZE 128 //  IPX_HEADER_SIZE+MAC_HEADER_SIZE

//
//  Mdls that are marked with the MDL_NETWORK_HEADER flag have extra space allocated before
//  the current start address that can be used for prepending lower-level headers.  The idea
//  is that when we want to prepend another header, we take the current mdl and adjust it to
//  include this extra header at the front of the message.  This is not strictly kosher and relies
//  on the behavior that the page the current header is on, and the page that the prepended header
//  is on, is the same page.  The way the macros work is that if they are not on the same page,
//  we don't set the NETWORK_HEADER flag, and the transport will use a second Mdl for the header.
//
//  Note that the other wierd thing about this is that we don't use the true buffer sizes.  The
//  buffer address is really offset TRANSPORT_HEADER_SIZE into the buffer.  The buffer size passed
//  in the buffer size without the TRANSPORT_HEADER_SIZE included.  Thus if the addition of the
//  TRANSPORT_HEADER_SIZE would cause the Mdl to span an additonal page, this optimization won't
//  work.
//

#define RxInitializeHeaderMdl( Mdl, Va, Len ) {             \
            MmInitializeMdl( Mdl, Va, Len );                \
            if (Mdl->ByteOffset >= TRANSPORT_HEADER_SIZE) { \
                Mdl->MdlFlags |= MDL_NETWORK_HEADER;        \
            }                                               \
        }

#define RxAllocateHeaderMdl( Buffer, BufferSize, Mdl ) {                 \
            Mdl = RxAllocateMdl( Buffer, BufferSize );                   \
            if ((Mdl) && (Mdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) {  \
                SetFlag( Mdl->MdlFlags, MDL_NETWORK_HEADER );            \
            }                                                            \
        }

#define RxMdlIsHeader( Mdl )    (FlagOn( Mdl )->MdlFlags, MDL_NETWORK_HEADER)

#define RxBuildPartialHeaderMdl( SourceMdl, TargetMdl, Va, Len ) {  \
    IoBuildPartialMdl( SourceMdl, TargetMdl, Va, Len );             \
    if (FlagOn(SourceMdl->MdlFlags, MDL_NETWORK_HEADER ) &&         \
        (TargetMdl->ByteOffset >= TRANSPORT_HEADER_SIZE)) {         \
            SetFlag( TargetMdl->MdlFlags, MDL_NETWORK_HEADER );     \
    }                                                               \
}

#define RxBuildHeaderMdlForNonPagedPool( Mdl) MmBuildMdlForNonPagedPool( Mdl )

#define RxProbeAndLockHeaderPages( Mdl, Mode, Access, Status ) \
         RxProbeAndLockPages( Mdl, Mode, Access, Status )

#define RxUnlockHeaderPages( Mdl ) MmUnlockPages( Mdl )


//
//  the next set of macros defines the prototype and the argument list for the toplevel (Common)
//  routines. these routines are just below the dispatch level and this is where the commonality
//  between win9x and NT begins. In addition, the IN PRX_CONTEXT RxContext and accompanying capture macros
//  could be platform specific as well. We must pass at least the RxContext; but on a RISC machine with
//  lots of registers we could pass a lot more. An adjustment would have to be made in the
//  RxFsdCommonDispatch in this case since the parameters are not yet captured at that point.
//

//
//  the reason why to say "RXSTATUS RxCommonRead (IN PRX_CONTEXT RxContext)" instead
//  of "RxCommon(Read)" is so that the standard tags programs will work. "RxCommon(Read):
//  doesn't look like a procedure definition
//

#define  RXCOMMON_SIGNATURE \
      PRX_CONTEXT RxContext

#define  RXCOMMON_ARGUMENTS \
      RxContext

#define RxGetRequestorProcess( RXCONTEXT ) IoGetRequestorProcess( RXCONTEXT->CurrentIrp )

//
//  RxGetRequestorProcess() returns what IoGetRequestorProcess() returns, which
//  is a pointer to a process structure.  Truncating this to 32 bits does
//  not yield a value that is unique to the process.
//
//  When a 32 bit value that is unique to the process is desired,
//  RxGetRequestorProcessId() must be used instead.
//

#define RxGetRequestorProcessId( RXCONTEXT ) IoGetRequestorProcessId( (RXCONTEXT)->CurrentIrp )

#define RxMarkContextPending( RXCONTEXT ) IoMarkIrpPending( (RXCONTEXT)->CurrentIrp )
                                               
#define RxSetCancelRoutine( Irp, CancelRoutine ) IoSetCancelRoutine( Irp, CancelRoutine );  

//
//  we do this as a macro because we may want to record that we did this adjustment so that
//  people who QFI for standardinfo will be forced to the net to get the right answer and that would
//  probably be better as a routine
//        

#define RxAdjustAllocationSizeforCC( FCB ) {\
        if ((FCB)->Header.FileSize.QuadPart > (FCB)->Header.AllocationSize.QuadPart) {        \
            PMRX_NET_ROOT NetRoot = (FCB)->pNetRoot;                                          \
            ULONGLONG ClusterSize = NetRoot->DiskParameters.ClusterSize;                      \
            ULONGLONG FileSize = (FCB)->Header.FileSize.QuadPart;                             \
            ASSERT(ClusterSize!=0);                                                           \
            (FCB)->Header.AllocationSize.QuadPart = (FileSize+ClusterSize)&~(ClusterSize-1);  \
        }                                                                                     \
        ASSERT ( (FCB)->Header.ValidDataLength.QuadPart <= (FCB)->Header.FileSize.QuadPart ); \
    }


#endif // _RX_NTDEFS_DEFINED_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    NtRxDef.h

Abstract:

    This module defines a whole host of macros that orient the code towards NT
    as opposed to Win9x.

Author:

    Joe Linn     [JoeLinn]   19-aug-1994

Revision History:
    Jim McNelis  [jimmcn]    14-mar-1995    added OAL defines.
    Sethu        [SethuR]    15-mar-1995    include OAL defines for RX_DATA_BUFFER (aka MDL )

--*/

#ifndef _RX_NTDEFS_DEFINED_
#define _RX_NTDEFS_DEFINED_

#define INLINE __inline

//
//  from winbase.h:
//

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif //  ifndef INVALID_HANDLE_VALUE

#define RxDeviceType(__xxx) ((DEVICE_TYPE)FILE_DEVICE_##__xxx)

//
//  this macro is used in various places to assist in defining sets of constants
//  that can be used to set/clear/test specific bits in a flags-type field
//

#define RX_DEFINE_FLAG(a,c,d)  a = ((1<<c)&d),

//
//  we need this constant various places
//

#define TICKS_PER_SECOND (10 * 1000 * 1000)
#define TICKS_PER_MILLESECOND (10 * 1000)


int
RxSprintf (
    char *, 
    const char *, 
    ...
    );

#ifndef WRAPPER_CALLS_ONLY
#define RxSprintf sprintf
#endif //  ifndef WRAPPER_CALLS_ONLY

//
//  the next set of macros defines how to get things out of the RxContext; however, RxContext is not
//  a macro parameter; rather, the appropriate pointers are just captured from whatever RxContext happens
//  to be around. Q: "why would you use RxCaptureFcb and then reference thru capFcb instead of just having
//  a macro like RxGetFcb() === RxContext->Fcb?" A: it is done this way to help with optimization. when you make
//  the RxGetFcb() call, the Fcb will have to be reloaded from the RxContext if you have called any procs; however,
//  it will not have to be reloaded with the capture technique.
//

#ifndef MINIRDR__NAME
#define RxCaptureFcb PFCB __C_Fcb = (PFCB)(RxContext->pFcb)
#define RxCaptureFobx PFOBX __C_Fobx = (PFOBX)(RxContext->pFobx)
#else
#define RxCaptureFcb PMRX_FCB __C_Fcb = (RxContext->pFcb)
#define RxCaptureFobx PMRX_FOBX __C_Fobx = (RxContext->pFobx)
#endif

#define RxCaptureRequestPacket PIRP __C_Irp = RxContext->CurrentIrp
#define RxCaptureParamBlock PIO_STACK_LOCATION __C_IrpSp = RxContext->CurrentIrpSp
#define RxCaptureFileObject PFILE_OBJECT __C_FileObject = __C_IrpSp-> FileObject

//
//  the "cap" prefix means "Captured from the RxContext....."; it's ok after you get used to it
//

#define capFcb __C_Fcb
#define capFobx __C_Fobx
#define capPARAMS __C_IrpSp
#define capReqPacket __C_Irp
#define capFileObject __C_FileObject


//
//  The following routines are used for pool allocation. On a checked build
//  additional information, we add in callsite information and go to a set of
//  routines that over perform various kinds of checking and guarding. On a free
//  build we forego this luxury and go straight for the allocation.
//

#ifdef RX_POOL_WRAPPER

//
//  These routines do various debug checks on the pool and the block
//  being freed.
//

extern VOID *_RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag, PSZ File, ULONG line );
extern VOID  _RxFreePool( PVOID PoolBlock, PSZ File, ULONG line );
extern BOOLEAN _RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxAllocatePoolWithTag( type, size, tag ) \
        _RxAllocatePoolWithTag( type, size, tag, __FILE__, __LINE__ )

#define RxFreePool( ptr ) \
        _RxFreePool( ptr, __FILE__, __LINE__ )

#define RxCheckMemoryBlock( ptr ) \
        _RxCheckMemoryBlock( ptr, __FILE__, __LINE__ )

#else  //  NOT RX_POOL_WRAPPER

//
// For retail builds, we want to go right to the regular (de)allocator
//

//  extern VOID *RxAllocatePool( ULONG PoolType, ULONG NumberOfBytes );
extern VOID *RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag );
extern VOID  RxFreePool( PVOID PoolBlock );
//  extern BOOLEAN RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxCheckMemoryBlock( ptr ) {NOTHING;}

#endif //  RX_POOL_WRAPPER

#define RxAllocatePool( type, size ) \
        RxAllocatePoolWithTag( type, size, '??xR' )

#if !DBG
#ifndef WRAPPER_CALLS_ONLY
#ifndef RX_POOL_WRAPPER
#define RxAllocatePoolWithTag ExAllocatePoolWithTag
#define RxFreePool ExFreePool
#endif //  RX_POOL_WRAPPER
#endif //  WRAPPER_CALLS_ONLY
#endif


extern 
NTSTATUS
RxDuplicateString(
    PUNICODE_STRING *Copy,
    PUNICODE_STRING Original,
    POOL_TYPE PoolType
    );

#define RxIsResourceOwnershipStateExclusive(__r) (FlagOn((__r)->Flag, ResourceOwnedExclusive))

#define RxProtectMdlFromFree( Mdl ) {NOTHING;}
#define RxUnprotectMdlFromFree( Mdl ) {NOTHING;}
#define RxMdlIsProtected( Mdl ) (FALSE)
#define RxTakeOwnershipOfMdl( Mdl ) {NOTHING;}
#define RxDisownMdl( Mdl ) {NOTHING;}
#define RxMdlIsOwned( Mdl ) (TRUE)

#define RxAllocateMdl( Buffer, BufferSize ) \
        IoAllocateMdl( Buffer, BufferSize, FALSE, FALSE, NULL )

#define RxMdlIsLocked( Mdl )         ((Mdl)->MdlFlags & MDL_PAGES_LOCKED)
#define RxMdlSourceIsNonPaged( Mdl ) ((Mdl)->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL)
#define RxMdlIsPartial( Mdl )        ((Mdl)->MdlFlags & MDL_PARTIAL)

#undef RxProbeAndLockPages
#define RxProbeAndLockPages( Mdl, Mode, Access, Status )          \
        Status = STATUS_SUCCESS;                                  \
        try {                                                     \
           MmProbeAndLockPages((Mdl), (Mode), (Access));          \
        } except (EXCEPTION_EXECUTE_HANDLER) {                    \
           Status = GetExceptionCode();                           \
        }

//
//  Macros for dealing with network header MDLs
//

//
//  This is the amount of space we preallocate in front of the smb header to hold
//  transport headers.  This number came from the server.  I suspect it is a worse case
//  value for all the transports that support MDL_NETWORK_HEADER
//

#define TRANSPORT_HEADER_SIZE 128 //  IPX_HEADER_SIZE+MAC_HEADER_SIZE

//
//  Mdls that are marked with the MDL_NETWORK_HEADER flag have extra space allocated before
//  the current start address that can be used for prepending lower-level headers.  The idea
//  is that when we want to prepend another header, we take the current mdl and adjust it to
//  include this extra header at the front of the message.  This is not strictly kosher and relies
//  on the behavior that the page the current header is on, and the page that the prepended header
//  is on, is the same page.  The way the macros work is that if they are not on the same page,
//  we don't set the NETWORK_HEADER flag, and the transport will use a second Mdl for the header.
//
//  Note that the other wierd thing about this is that we don't use the true buffer sizes.  The
//  buffer address is really offset TRANSPORT_HEADER_SIZE into the buffer.  The buffer size passed
//  in the buffer size without the TRANSPORT_HEADER_SIZE included.  Thus if the addition of the
//  TRANSPORT_HEADER_SIZE would cause the Mdl to span an additonal page, this optimization won't
//  work.
//

#define RxInitializeHeaderMdl( Mdl, Va, Len ) {             \
            MmInitializeMdl( Mdl, Va, Len );                \
            if (Mdl->ByteOffset >= TRANSPORT_HEADER_SIZE) { \
                Mdl->MdlFlags |= MDL_NETWORK_HEADER;        \
            }                                               \
        }

#define RxAllocateHeaderMdl( Buffer, BufferSize, Mdl ) {                 \
            Mdl = RxAllocateMdl( Buffer, BufferSize );                   \
            if ((Mdl) && (Mdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) {  \
                SetFlag( Mdl->MdlFlags, MDL_NETWORK_HEADER );            \
            }                                                            \
        }

#define RxMdlIsHeader( Mdl )    (FlagOn( Mdl )->MdlFlags, MDL_NETWORK_HEADER)

#define RxBuildPartialHeaderMdl( SourceMdl, TargetMdl, Va, Len ) {  \
    IoBuildPartialMdl( SourceMdl, TargetMdl, Va, Len );             \
    if (FlagOn(SourceMdl->MdlFlags, MDL_NETWORK_HEADER ) &&         \
        (TargetMdl->ByteOffset >= TRANSPORT_HEADER_SIZE)) {         \
            SetFlag( TargetMdl->MdlFlags, MDL_NETWORK_HEADER );     \
    }                                                               \
}

#define RxBuildHeaderMdlForNonPagedPool( Mdl) MmBuildMdlForNonPagedPool( Mdl )

#define RxProbeAndLockHeaderPages( Mdl, Mode, Access, Status ) \
         RxProbeAndLockPages( Mdl, Mode, Access, Status )

#define RxUnlockHeaderPages( Mdl ) MmUnlockPages( Mdl )


//
//  the next set of macros defines the prototype and the argument list for the toplevel (Common)
//  routines. these routines are just below the dispatch level and this is where the commonality
//  between win9x and NT begins. In addition, the IN PRX_CONTEXT RxContext and accompanying capture macros
//  could be platform specific as well. We must pass at least the RxContext; but on a RISC machine with
//  lots of registers we could pass a lot more. An adjustment would have to be made in the
//  RxFsdCommonDispatch in this case since the parameters are not yet captured at that point.
//

//
//  the reason why to say "RXSTATUS RxCommonRead (IN PRX_CONTEXT RxContext)" instead
//  of "RxCommon(Read)" is so that the standard tags programs will work. "RxCommon(Read):
//  doesn't look like a procedure definition
//

#define  RXCOMMON_SIGNATURE \
      PRX_CONTEXT RxContext

#define  RXCOMMON_ARGUMENTS \
      RxContext

#define RxGetRequestorProcess( RXCONTEXT ) IoGetRequestorProcess( RXCONTEXT->CurrentIrp )

//
//  RxGetRequestorProcess() returns what IoGetRequestorProcess() returns, which
//  is a pointer to a process structure.  Truncating this to 32 bits does
//  not yield a value that is unique to the process.
//
//  When a 32 bit value that is unique to the process is desired,
//  RxGetRequestorProcessId() must be used instead.
//

#define RxGetRequestorProcessId( RXCONTEXT ) IoGetRequestorProcessId( (RXCONTEXT)->CurrentIrp )

#define RxMarkContextPending( RXCONTEXT ) IoMarkIrpPending( (RXCONTEXT)->CurrentIrp )
                                               
#define RxSetCancelRoutine( Irp, CancelRoutine ) IoSetCancelRoutine( Irp, CancelRoutine );  

//
//  we do this as a macro because we may want to record that we did this adjustment so that
//  people who QFI for standardinfo will be forced to the net to get the right answer and that would
//  probably be better as a routine
//        

#define RxAdjustAllocationSizeforCC( FCB ) {\
        if ((FCB)->Header.FileSize.QuadPart > (FCB)->Header.AllocationSize.QuadPart) {        \
            PMRX_NET_ROOT NetRoot = (FCB)->pNetRoot;                                          \
            ULONGLONG ClusterSize = NetRoot->DiskParameters.ClusterSize;                      \
            ULONGLONG FileSize = (FCB)->Header.FileSize.QuadPart;                             \
            ASSERT(ClusterSize!=0);                                                           \
            (FCB)->Header.AllocationSize.QuadPart = (FileSize+ClusterSize)&~(ClusterSize-1);  \
        }                                                                                     \
        ASSERT ( (FCB)->Header.ValidDataLength.QuadPart <= (FCB)->Header.FileSize.QuadPart ); \
    }


#endif // _RX_NTDEFS_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    NtRxDef.h

Abstract:

    This module defines a whole host of macros that orient the code towards NT
    as opposed to Win9x.

Author:

    Joe Linn     [JoeLinn]   19-aug-1994

Revision History:
    Jim McNelis  [jimmcn]    14-mar-1995    added OAL defines.
    Sethu        [SethuR]    15-mar-1995    include OAL defines for RX_DATA_BUFFER (aka MDL )

--*/

#ifndef _RX_NTDEFS_DEFINED_
#define _RX_NTDEFS_DEFINED_

#define INLINE __inline

//from winbase.h:
#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif //ifndef INVALID_HANDLE_VALUE

#define RxDeviceType(__xxx) ((DEVICE_TYPE)FILE_DEVICE_##__xxx)

// this macro is used in various places to assist in defining sets of constants
// that can be used to set/clear/test specific bits in a flags-type field
#define RX_DEFINE_FLAG(a,c,d)  a = ((1<<c)&d),

//we need this constant various places
#define TICKS_PER_SECOND (10 * 1000 * 1000)
#define TICKS_PER_MILLESECOND (10 * 1000)


int
RxSprintf(char *, const char *, ...);
#ifndef WRAPPER_CALLS_ONLY
#define RxSprintf sprintf
#endif //ifndef WRAPPER_CALLS_ONLY

//  the next set of macros defines how to get things out of the RxContext; however, RxContext is not
//  a macro parameter; rather, the appropriate pointers are just captured from whatever RxContext happens
//  to be around. Q: "why would you use RxCaptureFcb and then reference thru capFcb instead of just having
//  a macro like RxGetFcb() === RxContext->Fcb?" A: it is done this way to help with optimization. when you make
//  the RxGetFcb() call, the Fcb will have to be reloaded from the RxContext if you have called any procs; however,
//  it will not have to be reloaded with the capture technique.

#ifndef MINIRDR__NAME
#define RxCaptureFcb PFCB __C_Fcb = (PFCB)(RxContext->pFcb)
#define RxCaptureFobx PFOBX __C_Fobx = (PFOBX)(RxContext->pFobx)
#else
#define RxCaptureFcb PMRX_FCB __C_Fcb = (RxContext->pFcb)
#define RxCaptureFobx PMRX_FOBX __C_Fobx = (RxContext->pFobx)
#endif

#define RxCaptureRequestPacket PIRP __C_Irp = RxContext->CurrentIrp
#define RxCaptureParamBlock PIO_STACK_LOCATION __C_IrpSp = RxContext->CurrentIrpSp
#define RxCaptureFileObject PFILE_OBJECT __C_FileObject = __C_IrpSp-> FileObject

//
// the "cap" prefix means "Captured from the RxContext....."; it's ok after you get used to it

#define capFcb __C_Fcb
#define capFobx __C_Fobx
#define capPARAMS __C_IrpSp
#define capReqPacket __C_Irp
#define capFileObject __C_FileObject

#define RXCOMPRESSIONAPI

RXCOMPRESSIONAPI
NTSTATUS
RxDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

RXCOMPRESSIONAPI
NTSTATUS
RxDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxCompressChunks (
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    );


// The following routines are used for pool allocation. On a checked build
// additional information, we add in callsite information and go to a set of
// routines that over perform various kinds of checking and guarding. On a free
// build we forego this luxury and go straight for the allocation.


#ifdef RX_POOL_WRAPPER

//
// These routines do various debug checks on the pool and the block
// being freed.
//
extern VOID *_RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag, PSZ File, ULONG line );
extern VOID  _RxFreePool( PVOID PoolBlock, PSZ File, ULONG line );
extern BOOLEAN _RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxAllocatePoolWithTag( type, size, tag ) \
        _RxAllocatePoolWithTag( type, size, tag, __FILE__, __LINE__ )

//#define RxAllocatePool( type, size ) \
//        _RxAllocatePoolWithTag( type, size, '??xR', __FILE__, __LINE__ )

#define RxFreePool( ptr ) \
        _RxFreePool( ptr, __FILE__, __LINE__ )

#define RxCheckMemoryBlock( ptr ) \
        _RxCheckMemoryBlock( ptr, __FILE__, __LINE__ )

#else  // NOT RX_POOL_WRAPPER

//
// For retail builds, we want to go right to the regular (de)allocator
//
//extern VOID *RxAllocatePool( ULONG PoolType, ULONG NumberOfBytes );
extern VOID *RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag );
extern VOID  RxFreePool( PVOID PoolBlock );
//extern BOOLEAN RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxCheckMemoryBlock( ptr ) {NOTHING;}

#endif // RX_POOL_WRAPPER

#define RxAllocatePool( type, size ) \
        RxAllocatePoolWithTag( type, size, '??xR' )

#if !DBG
#ifndef WRAPPER_CALLS_ONLY
#ifndef RX_POOL_WRAPPER
#define RxAllocatePoolWithTag ExAllocatePoolWithTag
#define RxFreePool ExFreePool
#endif //RX_POOL_WRAPPER
#endif //WRAPPER_CALLS_ONLY
#endif


extern NTSTATUS
RxDuplicateString(
         PUNICODE_STRING *pCopy,
         PUNICODE_STRING pOriginal,
         POOL_TYPE    PoolType);

#define RxIsResourceOwnershipStateExclusive(__r) (__r->Flag&ResourceOwnedExclusive)

#define RxProtectMdlFromFree(pMdl) {NOTHING;}
#define RxUnprotectMdlFromFree(pMdl) {NOTHING;}
#define RxMdlIsProtected(pMdl) (FALSE)
#define RxTakeOwnershipOfMdl(pMdl) {NOTHING;}
#define RxDisownMdl(pMdl) {NOTHING;}
#define RxMdlIsOwned(pMdl) (TRUE)

#define RxAllocateMdl(pBuffer,BufferSize) \
        IoAllocateMdl(pBuffer,BufferSize,FALSE,FALSE,NULL)

#define RxMdlIsLocked(pMdl)         ((pMdl)->MdlFlags & MDL_PAGES_LOCKED)
#define RxMdlSourceIsNonPaged(pMdl) ((pMdl)->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL)
#define RxMdlIsPartial(pMdl)        ((pMdl)->MdlFlags & MDL_PARTIAL)

#undef RxProbeAndLockPages
#define RxProbeAndLockPages(pMdl,Mode,Access,Status)              \
        Status = STATUS_SUCCESS;                                  \
        try {                                                     \
           MmProbeAndLockPages((pMdl), (Mode), (Access));         \
        } except (EXCEPTION_EXECUTE_HANDLER) {                    \
           Status = GetExceptionCode();                           \
        }

//
// Macros for dealing with network header MDLs
//

// This is the amount of space we preallocate in front of the smb header to hold
// transport headers.  This number came from the server.  I suspect it is a worse case
// value for all the transports that support MDL_NETWORK_HEADER

#define TRANSPORT_HEADER_SIZE 128 // IPX_HEADER_SIZE+MAC_HEADER_SIZE

// Mdls that are marked with the MDL_NETWORK_HEADER flag have extra space allocated before
// the current start address that can be used for prepending lower-level headers.  The idea
// is that when we want to prepend another header, we take the current mdl and adjust it to
// include this extra header at the front of the message.  This is not strictly kosher and relies
// on the behavior that the page the current header is on, and the page that the prepended header
// is on, is the same page.  The way the macros work is that if they are not on the same page,
// we don't set the NETWORK_HEADER flag, and the transport will use a second Mdl for the header.
//
// Note that the other wierd thing about this is that we don't use the true buffer sizes.  The
// buffer address is really offset TRANSPORT_HEADER_SIZE into the buffer.  The buffer size passed
// in the buffer size without the TRANSPORT_HEADER_SIZE included.  Thus if the addition of the
// TRANSPORT_HEADER_SIZE would cause the Mdl to span an additonal page, this optimization won't
// work.

#define RxInitializeHeaderMdl( pMdl, Va, Len ) { \
            MmInitializeMdl( pMdl, Va, Len ); \
            if (pMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) { \
                pMdl->MdlFlags |= MDL_NETWORK_HEADER; \
            } \
        }

#define RxAllocateHeaderMdl( pBuffer, BufferSize, pMdl ) { \
            pMdl = RxAllocateMdl( pBuffer, BufferSize ); \
            if ( (pMdl) && (pMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) { \
                pMdl->MdlFlags |= MDL_NETWORK_HEADER; \
            } \
        }

#define RxMdlIsHeader(pMdl)         ((pMdl)->MdlFlags & MDL_NETWORK_HEADER)

#define RxBuildPartialHeaderMdl( SourceMdl, TargetMdl, Va, Len ) { \
    IoBuildPartialMdl( SourceMdl, TargetMdl, Va, Len ); \
    if ( (SourceMdl->MdlFlags & MDL_NETWORK_HEADER) && \
         (TargetMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) { \
            TargetMdl->MdlFlags |= MDL_NETWORK_HEADER; \
    } \
}

#define RxBuildHeaderMdlForNonPagedPool( pMdl) MmBuildMdlForNonPagedPool( pMdl )

#define RxProbeAndLockHeaderPages( pMdl, Mode, Access, Status ) \
         RxProbeAndLockPages( pMdl, Mode, Access, Status )

#define RxUnlockHeaderPages( pMdl ) MmUnlockPages( pMdl )




//  the next set of macros defines the prototype and the argument list for the toplevel (Common)
//  routines. these routines are just below the dispatch level and this is where the commonality
//  between win9x and NT begins. In addition, the RXCOMMON_SIGNATURE and accompanying capture macros
//  could be platform specific as well. We must pass at least the RxContext; but on a RISC machine with
//  lots of registers we could pass a lot more. An adjustment would have to be made in the
//  RxFsdCommonDispatch in this case since the parameters are not yet captured at that point.

// the reason why do say "RXSTATUS RxCommonRead (RXCOMMON_SIGNATURE)" instead
// of "RxCommon(Read)" is so that the standard tags programs will work. "RxCommon(Read):
// doesn;t look like a procedure definition

#define  RXCOMMON_SIGNATURE \
      PRX_CONTEXT RxContext

#define  RXCOMMON_ARGUMENTS \
      RxContext

#define RxGetRequestorProcess(RXCONTEXT) IoGetRequestorProcess(RXCONTEXT->CurrentIrp)

//
//  RxGetRequestorProcess() returns what IoGetRequestorProcess() returns, which
//  is a pointer to a process structure.  Truncating this to 32 bits does
//  not yield a value that is unique to the process.
//
//  When a 32 bit value that is unique to the process is desired,
//  RxGetRequestorProcessId() must be used instead.
//

#define RxGetRequestorProcessId(RXCONTEXT) \
              IoGetRequestorProcessId((RXCONTEXT)->CurrentIrp)

#define RxMarkContextPending(RXCONTEXT) \
              IoMarkIrpPending((RXCONTEXT)->CurrentIrp)

#define RxSetCancelRoutine(pIrp, pCancelRoutine)      \
        {                                             \
           KIRQL CurrentIrql;                         \
           IoAcquireCancelSpinLock(&CurrentIrql);     \
           IoSetCancelRoutine(pIrp,pCancelRoutine);   \
           IoReleaseCancelSpinLock(CurrentIrql);      \
        }

//we do this as a macro because we may want to record that we did this adjustment so that
//people who QFI for standardinfo will be forced to the net to get the right answer and that would
//probably be better as a routine

#define RxAdjustAllocationSizeforCC(FCB) {\
        if ((FCB)->Header.FileSize.QuadPart > (FCB)->Header.AllocationSize.QuadPart) {       \
            PMRX_NET_ROOT NetRoot = (FCB)->pNetRoot;                              \
            ULONGLONG ClusterSize = NetRoot->DiskParameters.ClusterSize;                     \
            ULONGLONG FileSize = (FCB)->Header.FileSize.QuadPart;                            \
            ASSERT(ClusterSize!=0);                                                          \
            (FCB)->Header.AllocationSize.QuadPart = (FileSize+ClusterSize)&~(ClusterSize-1); \
        }                                                                                    \
        ASSERT ((FCB)->Header.ValidDataLength.QuadPart <= (FCB)->Header.FileSize.QuadPart);  \
    }


#endif // _RX_NTDEFS_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    NtRxDef.h

Abstract:

    This module defines a whole host of macros that orient the code towards NT
    as opposed to Win9x.

Author:

    Joe Linn     [JoeLinn]   19-aug-1994

Revision History:
    Jim McNelis  [jimmcn]    14-mar-1995    added OAL defines.
    Sethu        [SethuR]    15-mar-1995    include OAL defines for RX_DATA_BUFFER (aka MDL )

--*/

#ifndef _RX_NTDEFS_DEFINED_
#define _RX_NTDEFS_DEFINED_

#define INLINE __inline

//from winbase.h:
#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif //ifndef INVALID_HANDLE_VALUE

#define RxDeviceType(__xxx) ((DEVICE_TYPE)FILE_DEVICE_##__xxx)

// this macro is used in various places to assist in defining sets of constants
// that can be used to set/clear/test specific bits in a flags-type field
#define RX_DEFINE_FLAG(a,c,d)  a = ((1<<c)&d),

//we need this constant various places
#define TICKS_PER_SECOND (10 * 1000 * 1000)
#define TICKS_PER_MILLESECOND (10 * 1000)


int
RxSprintf(char *, const char *, ...);
#ifndef WRAPPER_CALLS_ONLY
#define RxSprintf sprintf
#endif //ifndef WRAPPER_CALLS_ONLY

//  the next set of macros defines how to get things out of the RxContext; however, RxContext is not
//  a macro parameter; rather, the appropriate pointers are just captured from whatever RxContext happens
//  to be around. Q: "why would you use RxCaptureFcb and then reference thru capFcb instead of just having
//  a macro like RxGetFcb() === RxContext->Fcb?" A: it is done this way to help with optimization. when you make
//  the RxGetFcb() call, the Fcb will have to be reloaded from the RxContext if you have called any procs; however,
//  it will not have to be reloaded with the capture technique.

#ifndef MINIRDR__NAME
#define RxCaptureFcb PFCB __C_Fcb = (PFCB)(RxContext->pFcb)
#define RxCaptureFobx PFOBX __C_Fobx = (PFOBX)(RxContext->pFobx)
#else
#define RxCaptureFcb PMRX_FCB __C_Fcb = (RxContext->pFcb)
#define RxCaptureFobx PMRX_FOBX __C_Fobx = (RxContext->pFobx)
#endif

#define RxCaptureRequestPacket PIRP __C_Irp = RxContext->CurrentIrp
#define RxCaptureParamBlock PIO_STACK_LOCATION __C_IrpSp = RxContext->CurrentIrpSp
#define RxCaptureFileObject PFILE_OBJECT __C_FileObject = __C_IrpSp-> FileObject

//
// the "cap" prefix means "Captured from the RxContext....."; it's ok after you get used to it

#define capFcb __C_Fcb
#define capFobx __C_Fobx
#define capPARAMS __C_IrpSp
#define capReqPacket __C_Irp
#define capFileObject __C_FileObject

#define RXCOMPRESSIONAPI

RXCOMPRESSIONAPI
NTSTATUS
RxDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

RXCOMPRESSIONAPI
NTSTATUS
RxDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxCompressChunks (
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    );


// The following routines are used for pool allocation. On a checked build
// additional information, we add in callsite information and go to a set of
// routines that over perform various kinds of checking and guarding. On a free
// build we forego this luxury and go straight for the allocation.


#ifdef RX_POOL_WRAPPER

//
// These routines do various debug checks on the pool and the block
// being freed.
//
extern VOID *_RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag, PSZ File, ULONG line );
extern VOID  _RxFreePool( PVOID PoolBlock, PSZ File, ULONG line );
extern BOOLEAN _RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxAllocatePoolWithTag( type, size, tag ) \
        _RxAllocatePoolWithTag( type, size, tag, __FILE__, __LINE__ )

//#define RxAllocatePool( type, size ) \
//        _RxAllocatePoolWithTag( type, size, '??xR', __FILE__, __LINE__ )

#define RxFreePool( ptr ) \
        _RxFreePool( ptr, __FILE__, __LINE__ )

#define RxCheckMemoryBlock( ptr ) \
        _RxCheckMemoryBlock( ptr, __FILE__, __LINE__ )

#else  // NOT RX_POOL_WRAPPER

//
// For retail builds, we want to go right to the regular (de)allocator
//
//extern VOID *RxAllocatePool( ULONG PoolType, ULONG NumberOfBytes );
extern VOID *RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag );
extern VOID  RxFreePool( PVOID PoolBlock );
//extern BOOLEAN RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxCheckMemoryBlock( ptr ) {NOTHING;}

#endif // RX_POOL_WRAPPER

#define RxAllocatePool( type, size ) \
        RxAllocatePoolWithTag( type, size, '??xR' )

#if !DBG
#ifndef WRAPPER_CALLS_ONLY
#ifndef RX_POOL_WRAPPER
#define RxAllocatePoolWithTag ExAllocatePoolWithTag
#define RxFreePool ExFreePool
#endif //RX_POOL_WRAPPER
#endif //WRAPPER_CALLS_ONLY
#endif


extern NTSTATUS
RxDuplicateString(
         PUNICODE_STRING *pCopy,
         PUNICODE_STRING pOriginal,
         POOL_TYPE    PoolType);

#define RxIsResourceOwnershipStateExclusive(__r) (__r->Flag&ResourceOwnedExclusive)

#define RxProtectMdlFromFree(pMdl) {NOTHING;}
#define RxUnprotectMdlFromFree(pMdl) {NOTHING;}
#define RxMdlIsProtected(pMdl) (FALSE)
#define RxTakeOwnershipOfMdl(pMdl) {NOTHING;}
#define RxDisownMdl(pMdl) {NOTHING;}
#define RxMdlIsOwned(pMdl) (TRUE)

#define RxAllocateMdl(pBuffer,BufferSize) \
        IoAllocateMdl(pBuffer,BufferSize,FALSE,FALSE,NULL)

#define RxMdlIsLocked(pMdl)         ((pMdl)->MdlFlags & MDL_PAGES_LOCKED)
#define RxMdlSourceIsNonPaged(pMdl) ((pMdl)->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL)
#define RxMdlIsPartial(pMdl)        ((pMdl)->MdlFlags & MDL_PARTIAL)

#undef RxProbeAndLockPages
#define RxProbeAndLockPages(pMdl,Mode,Access,Status)              \
        Status = STATUS_SUCCESS;                                  \
        try {                                                     \
           MmProbeAndLockPages((pMdl), (Mode), (Access));         \
        } except (EXCEPTION_EXECUTE_HANDLER) {                    \
           Status = GetExceptionCode();                           \
        }

//
// Macros for dealing with network header MDLs
//

// This is the amount of space we preallocate in front of the smb header to hold
// transport headers.  This number came from the server.  I suspect it is a worse case
// value for all the transports that support MDL_NETWORK_HEADER

#define TRANSPORT_HEADER_SIZE 64 // IPX_HEADER_SIZE+MAC_HEADER_SIZE

// Mdls that are marked with the MDL_NETWORK_HEADER flag have extra space allocated before
// the current start address that can be used for prepending lower-level headers.  The idea
// is that when we want to prepend another header, we take the current mdl and adjust it to
// include this extra header at the front of the message.  This is not strictly kosher and relies
// on the behavior that the page the current header is on, and the page that the prepended header
// is on, is the same page.  The way the macros work is that if they are not on the same page,
// we don't set the NETWORK_HEADER flag, and the transport will use a second Mdl for the header.
//
// Note that the other wierd thing about this is that we don't use the true buffer sizes.  The
// buffer address is really offset TRANSPORT_HEADER_SIZE into the buffer.  The buffer size passed
// in the buffer size without the TRANSPORT_HEADER_SIZE included.  Thus if the addition of the
// TRANSPORT_HEADER_SIZE would cause the Mdl to span an additonal page, this optimization won't
// work.

#define RxInitializeHeaderMdl( pMdl, Va, Len ) { \
            MmInitializeMdl( pMdl, Va, Len ); \
            if (pMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) { \
                pMdl->MdlFlags |= MDL_NETWORK_HEADER; \
            } \
        }

#define RxAllocateHeaderMdl( pBuffer, BufferSize, pMdl ) { \
            pMdl = RxAllocateMdl( pBuffer, BufferSize ); \
            if ( (pMdl) && (pMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) { \
                pMdl->MdlFlags |= MDL_NETWORK_HEADER; \
            } \
        }

#define RxMdlIsHeader(pMdl)         ((pMdl)->MdlFlags & MDL_NETWORK_HEADER)

#define RxBuildPartialHeaderMdl( SourceMdl, TargetMdl, Va, Len ) { \
    IoBuildPartialMdl( SourceMdl, TargetMdl, Va, Len ); \
    if ( (SourceMdl->MdlFlags & MDL_NETWORK_HEADER) && \
         (TargetMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) { \
            TargetMdl->MdlFlags |= MDL_NETWORK_HEADER; \
    } \
}

#define RxBuildHeaderMdlForNonPagedPool( pMdl) MmBuildMdlForNonPagedPool( pMdl )

#define RxProbeAndLockHeaderPages( pMdl, Mode, Access, Status ) \
         RxProbeAndLockPages( pMdl, Mode, Access, Status )

#define RxUnlockHeaderPages( pMdl ) MmUnlockPages( pMdl )




//  the next set of macros defines the prototype and the argument list for the toplevel (Common)
//  routines. these routines are just below the dispatch level and this is where the commonality
//  between win9x and NT begins. In addition, the RXCOMMON_SIGNATURE and accompanying capture macros
//  could be platform specific as well. We must pass at least the RxContext; but on a RISC machine with
//  lots of registers we could pass a lot more. An adjustment would have to be made in the
//  RxFsdCommonDispatch in this case since the parameters are not yet captured at that point.

// the reason why do say "RXSTATUS RxCommonRead (RXCOMMON_SIGNATURE)" instead
// of "RxCommon(Read)" is so that the standard tags programs will work. "RxCommon(Read):
// doesn;t look like a procedure definition

#define  RXCOMMON_SIGNATURE \
      PRX_CONTEXT RxContext

#define  RXCOMMON_ARGUMENTS \
      RxContext

#define RxGetRequestorProcess(RXCONTEXT) IoGetRequestorProcess(RXCONTEXT->CurrentIrp)

//
//  RxGetRequestorProcess() returns what IoGetRequestorProcess() returns, which
//  is a pointer to a process structure.  Truncating this to 32 bits does
//  not yield a value that is unique to the process.
//
//  When a 32 bit value that is unique to the process is desired,
//  RxGetRequestorProcessId() must be used instead.
//

#define RxGetRequestorProcessId(RXCONTEXT) \
              IoGetRequestorProcessId((RXCONTEXT)->CurrentIrp)

#define RxMarkContextPending(RXCONTEXT) \
              IoMarkIrpPending((RXCONTEXT)->CurrentIrp)

#define RxSetCancelRoutine(pIrp, pCancelRoutine)      \
        {                                             \
           KIRQL CurrentIrql;                         \
           IoAcquireCancelSpinLock(&CurrentIrql);     \
           IoSetCancelRoutine(pIrp,pCancelRoutine);   \
           IoReleaseCancelSpinLock(CurrentIrql);      \
        }

//we do this as a macro because we may want to record that we did this adjustment so that
//people who QFI for standardinfo will be forced to the net to get the right answer and that would
//probably be better as a routine

#define RxAdjustAllocationSizeforCC(FCB) {\
        if ((FCB)->Header.FileSize.QuadPart > (FCB)->Header.AllocationSize.QuadPart) {       \
            PMRX_NET_ROOT NetRoot = (FCB)->pNetRoot;                              \
            ULONGLONG ClusterSize = NetRoot->DiskParameters.ClusterSize;                     \
            ULONGLONG FileSize = (FCB)->Header.FileSize.QuadPart;                            \
            ASSERT(ClusterSize!=0);                                                          \
            (FCB)->Header.AllocationSize.QuadPart = (FileSize+ClusterSize)&~(ClusterSize-1); \
        }                                                                                    \
        ASSERT ((FCB)->Header.ValidDataLength.QuadPart <= (FCB)->Header.FileSize.QuadPart);  \
    }


#endif // _RX_NTDEFS_DEFINED_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ntstrsafe.h ===
/******************************************************************
*                                                                 *
*  ntstrsafe.h -- This module defines safer C library string      *
*                 routine replacements for drivers. These are     *
*                 meant to make C a bit more safe in reference    *
*                 to security and robustness. A similar file,     *
*                 strsafe.h, is available for applications.       *
*                                                                 *
*  Copyright (c) Microsoft Corp.  All rights reserved.            *
*                                                                 *
******************************************************************/
#ifndef _NTSTRSAFE_H_INCLUDED_
#define _NTSTRSAFE_H_INCLUDED_
#if (_MSC_VER > 1000)
#pragma once
#endif

#include <stdio.h>          // for _vsnprintf, _vsnwprintf, getc, getwc
#include <string.h>         // for memset
#include <stdarg.h>         // for va_start, etc.
#include <specstrings.h>    // for __in, etc.

#ifndef NTSTRSAFE_NO_UNICODE_STRING_FUNCTIONS
#include <ntdef.h>          // for UNICODE_STRING, etc.
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && (_MSC_VER >= 1300)
#define _W64 __w64
#else
#define _W64
#endif
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define ALIGNMENT_MACHINE
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#undef ALIGNMENT_MACHINE
#define UNALIGNED
#define UNALIGNED64
#endif

// typedefs
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif

#ifndef _NTSTATUS_DEFINED
#define _NTSTATUS_DEFINED
typedef __success(return >= 0) long NTSTATUS;
#endif

typedef unsigned long DWORD;


#ifndef SORTPP_PASS
// compiletime asserts (failure results in error C2118: negative subscript)
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#else
#define C_ASSERT(e)
#endif

#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif

// use the new secure crt functions if available
#ifndef NTSTRSAFE_USE_SECURE_CRT
#if defined(__GOT_SECURE_LIB__) && (__GOT_SECURE_LIB__ >= 200402L)
#define NTSTRSAFE_USE_SECURE_CRT 0
#else
#define NTSTRSAFE_USE_SECURE_CRT 0
#endif
#endif  // !NTSTRSAFE_USE_SECURE_CRT

#ifdef _M_CEE_PURE
#define NTSTRSAFEDDI      __inline NTSTATUS __clrcall
#else
#define NTSTRSAFEDDI      __inline NTSTATUS __stdcall
#endif

#if defined(NTSTRSAFE_LIB_IMPL) || defined(NTSTRSAFE_LIB)
#define NTSTRSAFEWORKERDDI    EXTERN_C NTSTATUS __stdcall 
#else
#define NTSTRSAFEWORKERDDI    static NTSTRSAFEDDI
#endif

// The following steps are *REQUIRED* if ntstrsafe.h is used for drivers on:
//     Windows 2000
//     Windows Millennium Edition
//     Windows 98 Second Edition
//     Windows 98
//
// 1. #define NTSTRSAFE_LIB before including the ntstrsafe.h header file.
// 2. Add ntstrsafe.lib to the TARGET_LIBS line in SOURCES
//
// Drivers running on XP and later can skip these steps to create a smaller
// driver by running the functions inline.
#if defined(NTSTRSAFE_LIB)
#pragma comment(lib, "ntstrsafe.lib")
#endif

// The user can request no "Cb" or no "Cch" fuctions, but not both
#if defined(NTSTRSAFE_NO_CB_FUNCTIONS) && defined(NTSTRSAFE_NO_CCH_FUNCTIONS)
#error cannot specify both NTSTRSAFE_NO_CB_FUNCTIONS and NTSTRSAFE_NO_CCH_FUNCTIONS !!
#endif

// The user may override NTSTRSAFE_MAX_CCH, but it must always be less than INT_MAX
#ifndef NTSTRSAFE_MAX_CCH
#define NTSTRSAFE_MAX_CCH     2147483647  // max buffer size, in characters, that we support (same as INT_MAX)
#endif
C_ASSERT(NTSTRSAFE_MAX_CCH <= 2147483647);
C_ASSERT(NTSTRSAFE_MAX_CCH > 1);

#define NTSTRSAFE_MAX_LENGTH  (NTSTRSAFE_MAX_CCH - 1)   // max buffer length, in characters, that we support

// The user may override NTSTRSAFE_UNICODE_STRING_MAX_CCH, but it must always be less than (USHORT_MAX / sizeof(wchar_t))
#ifndef NTSTRSAFE_UNICODE_STRING_MAX_CCH
#define NTSTRSAFE_UNICODE_STRING_MAX_CCH    (0xffff / sizeof(wchar_t))  // max buffer size, in characters, for a UNICODE_STRING
#endif
C_ASSERT(NTSTRSAFE_UNICODE_STRING_MAX_CCH <= (0xffff / sizeof(wchar_t)));
C_ASSERT(NTSTRSAFE_UNICODE_STRING_MAX_CCH > 1);


// Flags for controling the Ex functions
//
//      STRSAFE_FILL_BYTE(0xFF)                         0x000000FF  // bottom byte specifies fill pattern
#define STRSAFE_IGNORE_NULLS                            0x00000100  // treat null string pointers as TEXT("") -- don't fault on NULL buffers
#define STRSAFE_FILL_BEHIND_NULL                        0x00000200  // on success, fill in extra space behind the null terminator with fill pattern
#define STRSAFE_FILL_ON_FAILURE                         0x00000400  // on failure, overwrite pszDest with fill pattern and null terminate it
#define STRSAFE_NULL_ON_FAILURE                         0x00000800  // on failure, set *pszDest = TEXT('\0')
#define STRSAFE_NO_TRUNCATION                           0x00001000  // instead of returning a truncated result, copy/append nothing to pszDest and null terminate it

// Flags for controling UNICODE_STRING Ex functions
//
//      STRSAFE_FILL_BYTE(0xFF)                         0x000000FF  // bottom byte specifies fill pattern
//      STRSAFE_IGNORE_NULLS                            0x00000100  // don't fault on NULL UNICODE_STRING pointers, and treat null pszSrc as L""
#define STRSAFE_FILL_BEHIND                             0x00000200  // on success, fill in extra space at the end of the UNICODE_STRING Buffer with fill pattern
//      STRSAFE_FILL_ON_FAILURE                         0x00000400  // on failure, fill the UNICODE_STRING Buffer with fill pattern and set the Length to 0
#define STRSAFE_ZERO_LENGTH_ON_FAILURE                  0x00000800  // on failure, set the UNICODE_STRING Length to 0
//      STRSAFE_NO_TRUNCATION                           0x00001000  // instead of returning a truncated result, copy/append nothing to UNICODE_STRING Buffer


#define STRSAFE_VALID_FLAGS                     (0x000000FF | STRSAFE_IGNORE_NULLS | STRSAFE_FILL_BEHIND_NULL | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)
#define STRSAFE_UNICODE_STRING_VALID_FLAGS      (0x000000FF | STRSAFE_IGNORE_NULLS | STRSAFE_FILL_BEHIND | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE | STRSAFE_NO_TRUNCATION)

// helper macro to set the fill character and specify buffer filling
#define STRSAFE_FILL_BYTE(x)                    ((DWORD)((x & 0x000000FF) | STRSAFE_FILL_BEHIND_NULL))
#define STRSAFE_FAILURE_BYTE(x)                 ((DWORD)((x & 0x000000FF) | STRSAFE_FILL_ON_FAILURE))

#define STRSAFE_GET_FILL_PATTERN(dwFlags)       ((int)(dwFlags & 0x000000FF))


//
// These typedefs are used in places where the string is guaranteed to
// be null terminated.
//
typedef __nullterminated char* NTSTRSAFE_PSTR;
typedef __nullterminated const char* NTSTRSAFE_PCSTR;
typedef __nullterminated wchar_t* NTSTRSAFE_PWSTR;
typedef __nullterminated const wchar_t* NTSTRSAFE_PCWSTR;
typedef __nullterminated const wchar_t UNALIGNED* NTSTRSAFE_PCUWSTR;


// prototypes for the worker functions

NTSTRSAFEWORKERDDI
RtlStringLengthWorkerA(
    __in NTSTRSAFE_PCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);

NTSTRSAFEWORKERDDI
RtlStringLengthWorkerW(
    __in NTSTRSAFE_PCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);
    
#ifdef ALIGNMENT_MACHINE
NTSTRSAFEWORKERDDI
RtlUnalignedStringLengthWorkerW(
    __in NTSTRSAFE_PCUWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);
#endif  // ALIGNMENT_MACHINE

NTSTRSAFEWORKERDDI
RtlStringExValidateSrcA(
    __deref_inout_opt NTSTRSAFE_PCSTR* ppszSrc,
    __inout_opt size_t* pcchToRead,
    __in size_t cchMax,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlStringExValidateSrcW(
    __deref_inout_opt NTSTRSAFE_PCWSTR* ppszSrc,
    __inout_opt size_t* pcchToRead,
    __in size_t cchMax,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlStringValidateDestA(
    __in_ecount_opt(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax);

NTSTRSAFEWORKERDDI
RtlStringValidateDestW(
    __in_ecount_opt(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax);

NTSTRSAFEWORKERDDI
RtlStringExValidateDestA(
    __deref_inout_opt NTSTRSAFE_PSTR* ppszDest,
    __inout size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlStringExValidateDestW(
    __deref_inout_opt NTSTRSAFE_PWSTR* ppszDest,
    __inout size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlStringCopyWorkerA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cchToCopy);

NTSTRSAFEWORKERDDI
RtlStringCopyWorkerW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToCopy);

NTSTRSAFEWORKERDDI
RtlStringVPrintfWorkerA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    __in va_list argList);

NTSTRSAFEWORKERDDI
RtlStringVPrintfWorkerW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    __in va_list argList);

NTSTRSAFEWORKERDDI
RtlStringExHandleFillBehindNullA(
    __out_bcount(cbRemaining) NTSTRSAFE_PSTR pszDestEnd,
    __in size_t cbRemaining,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlStringExHandleFillBehindNullW(
    __out_bcount(cbRemaining) NTSTRSAFE_PWSTR pszDestEnd,
    __in size_t cbRemaining,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlStringExHandleOtherFlagsA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in size_t cchOriginalDestLength,
    __deref_out_ecount(*pcchRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlStringExHandleOtherFlagsW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in size_t cchOriginalDestLength,
    __deref_out_ecount(*pcchRemaining)NTSTRSAFE_PWSTR* ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags);

#ifndef NTSTRSAFE_NO_UNICODE_STRING_FUNCTIONS

NTSTRSAFEWORKERDDI
RtlUnicodeStringInitWorker(
    __out PUNICODE_STRING DestinationString,
    __in_opt NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchMax,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlUnicodeStringValidateWorker(
    __in_opt PCUNICODE_STRING SourceString,
    __in size_t cchMax,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlUnicodeStringValidateSrcWorker(
    __in PCUNICODE_STRING SourceString,
    __deref_out_ecount(*pcchSrcLength) wchar_t** ppszSrc,
    __out size_t* pcchSrcLength,
    __in size_t cchMax,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlUnicodeStringValidateDestWorker(
    __in PCUNICODE_STRING DestinationString,
    __deref_out_ecount(*pcchDest) wchar_t** ppszDest,
    __out size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlStringCopyWideCharArrayWorker(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in_ecount(cchSrcLength) const wchar_t* pszSrc,
    __in size_t cchSrcLength);

NTSTRSAFEWORKERDDI
RtlWideCharArrayCopyStringWorker(
    __out_ecount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __out size_t* pcchNewDestLength,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToCopy);

NTSTRSAFEWORKERDDI
RtlWideCharArrayCopyWorker(
    __out_ecount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __out size_t* pcchNewDestLength,
    __in_ecount(cchSrcLength) const wchar_t* pszSrc,
    __in size_t cchSrcLength);

NTSTRSAFEWORKERDDI
RtlWideCharArrayVPrintfWorker(
    __out_ecount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __out size_t* pcchNewDestLength,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    __in va_list argList);

NTSTRSAFEWORKERDDI
RtlUnicodeStringExHandleFill(
    __out_ecount(cchRemaining) wchar_t* pszDestEnd,
    __in size_t cchRemaining,
    __in DWORD dwFlags);

NTSTRSAFEWORKERDDI
RtlUnicodeStringExHandleOtherFlags(
    __out_bcount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __in size_t cchOriginalDestLength,
    __out size_t* pcchNewDestLength,
    __deref_out_ecount(*pcchRemaining) wchar_t** ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags);

#endif  // !NTSTRSAFE_NO_UNICODE_STRING_FUNCTIONS

#pragma warning(push)
#pragma warning(disable : 4996) // 'function': was declared deprecated
#pragma warning(disable : 4995) // name was marked as #pragma deprecated
#pragma warning(disable : 4793) // vararg causes native code generation


#ifndef NTSTRSAFE_LIB_IMPL

#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchCopy(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in  size_t  cchDest,
    __in  LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for strncpy.  That function will pad the
    destination string with extra null termination characters if the count is
    greater than the length of the source string, and it will fail to null
    terminate the destination string if the source string length is greater
    than or equal to the count. You can not blindly use this instead of strncpy:
    it is common for code to use it to "patch" strings and you would introduce
    errors if the code started null terminating in the middle of the string.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was copied without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of
    pszSrc will be copied to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = (_tcslen(src) + 1) to hold all of the
                       source including the null terminator

    pszSrc         -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See RtlStringCchCopyEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCchCopyA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCSTR pszSrc)
{
    NTSTATUS status;

    status = RtlStringValidateDestA(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringCopyWorkerA(pszDest,
                               cchDest,
                               NULL,
                               pszSrc,
                               NTSTRSAFE_MAX_LENGTH);
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchCopyW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCWSTR pszSrc)
{
    NTSTATUS status;
    
    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);

    if (NT_SUCCESS(status))
    {
        status = RtlStringCopyWorkerW(pszDest,
                               cchDest,
                               NULL,
                               pszSrc,
                               NTSTRSAFE_MAX_LENGTH);
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbCopy(
    __out_bcount(cbDest) LPTSTR pszDest,
    __in  size_t cbDest,
    __in  LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for strncpy.  That function will pad the
    destination string with extra null termination characters if the count is
    greater than the length of the source string, and it will fail to null
    terminate the destination string if the source string length is greater
    than or equal to the count. You can not blindly use this instead of strncpy:
    it is common for code to use it to "patch" strings and you would introduce
    errors if the code started null terminating in the middle of the string.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was copied without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be copied to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = ((_tcslen(src) + 1) * sizeof(TCHAR)) to
                       hold all of the source including the null terminator

    pszSrc         -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See RtlStringCbCopyEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCbCopyA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCSTR pszSrc)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringValidateDestA(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);

    if (NT_SUCCESS(status))
    {
        status = RtlStringCopyWorkerA(pszDest,
                               cchDest,
                               NULL,
                               pszSrc,
                               NTSTRSAFE_MAX_LENGTH);
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbCopyW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCWSTR pszSrc)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);

    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);

    if (NT_SUCCESS(status))
    {
        status = RtlStringCopyWorkerW(pszDest,
                               cchDest,
                               NULL,
                               pszSrc,
                               NTSTRSAFE_MAX_LENGTH);
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchCopyEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cchDest,
    __in  LPCTSTR pszSrc          OPTIONAL,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCchCopy, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = (_tcslen(pszSrc) + 1) to hold all of
                        the source including the null terminator

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchCopyExA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcA(&pszSrc, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerA(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       NTSTRSAFE_MAX_LENGTH);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;
                
                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchCopyExW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcW(&pszSrc, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerW(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       NTSTRSAFE_MAX_LENGTH);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbCopyEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cbDest,
    __in  LPCTSTR pszSrc          OPTIONAL,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCbCopy, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to
                        hold all of the source including the null terminator

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbCopyExA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcA(&pszSrc, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerA(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       NTSTRSAFE_MAX_LENGTH);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }

            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbCopyExW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcW(&pszSrc, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerW(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       NTSTRSAFE_MAX_LENGTH);
                
                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (NT_SUCCESS(status) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchCopyN(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in  size_t  cchDest,
    __in  LPCTSTR pszSrc,
    __in  size_t  cchToCopy
    );


Routine Description:

    This routine is a safer version of the C built-in function 'strncpy'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cchToCopy is greater than the length of pszSrc.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the entire string or the first cchToCopy characters were copied
    without truncation and the resultant destination string was null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be copied to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = (_tcslen(src) + 1) to hold all of the
                       source including the null terminator

    pszSrc         -   source string

    cchToCopy      -   maximum number of characters to copy from source string,
                       not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See RtlStringCchCopyNEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCchCopyNA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cchToCopy)
{
    NTSTATUS status;

    status = RtlStringValidateDestA(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        if (cchToCopy > NTSTRSAFE_MAX_LENGTH)
        {
            status = STATUS_INVALID_PARAMETER;
            
            *pszDest = '\0';
        }
        else
        {
            status = RtlStringCopyWorkerA(pszDest,
                                   cchDest,
                                   NULL,
                                   pszSrc,
                                   cchToCopy);
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchCopyNW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToCopy)
{
    NTSTATUS status;

    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        if (cchToCopy > NTSTRSAFE_MAX_LENGTH)
        {
            status = STATUS_INVALID_PARAMETER;
            
            *pszDest = L'\0';
        }
        else
        {
            status = RtlStringCopyWorkerW(pszDest,
                                   cchDest,
                                   NULL,
                                   pszSrc,
                                   cchToCopy);
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbCopyN(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in  size_t  cbDest,
    __in  LPCTSTR pszSrc,
    __in  size_t  cbToCopy
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cbToCopy is greater than the size of pszSrc.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the entire string or the first cbToCopy characters were
    copied without truncation and the resultant destination string was null
    terminated, otherwise it will return a failure code. In failure cases as
    much of pszSrc will be copied to pszDest as possible, and pszDest will be
    null terminated.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = ((_tcslen(src) + 1) * sizeof(TCHAR)) to
                       hold all of the source including the null terminator

    pszSrc         -   source string

    cbToCopy       -   maximum number of bytes to copy from source string,
                       not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See RtlStringCbCopyEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCbCopyNA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cbToCopy)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringValidateDestA(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        size_t cchToCopy = cbToCopy / sizeof(char);

        if (cchToCopy > NTSTRSAFE_MAX_LENGTH)
        {
            status = STATUS_INVALID_PARAMETER;
            
            *pszDest = '\0';
        }
        else
        {
            status = RtlStringCopyWorkerA(pszDest,
                                   cchDest,
                                   NULL,
                                   pszSrc,
                                   cchToCopy);
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbCopyNW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cbToCopy)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);

    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        size_t cchToCopy = cbToCopy / sizeof(wchar_t);

        if (cchToCopy > NTSTRSAFE_MAX_LENGTH)
        {
            status = STATUS_INVALID_PARAMETER;
            
            *pszDest = L'\0';
        }
        else
        {
            status = RtlStringCopyWorkerW(pszDest,
                                   cchDest,
                                   NULL,
                                   pszSrc,
                                   cchToCopy);
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchCopyNEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cchDest,
    __in  LPCTSTR pszSrc          OPTIONAL,
    __in  size_t  cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd OPTIONAL,
    __out_opt size_t* pcchRemaining OPTIONAL,
    __in  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCchCopyN, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination
    string including the null terminator. The flags parameter allows
    additional controls.

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cchToCopy is greater than the length of pszSrc.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = (_tcslen(pszSrc) + 1) to hold all of
                        the source including the null terminator

    pszSrc          -   source string

    cchToCopy       -   maximum number of characters to copy from the source
                        string

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified. If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL. An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchCopyNExA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;

    status = RtlStringExValidateDestA(&pszDest, 
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcA(&pszSrc, &cchToCopy, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerA(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       cchToCopy);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchCopyNExW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcW(&pszSrc, &cchToCopy, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerW(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       cchToCopy);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbCopyNEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cbDest,
    __in  LPCTSTR pszSrc          OPTIONAL,
    __in  size_t  cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCbCopyN, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cbToCopy is greater than the size of pszSrc.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to
                        hold all of the source including the null terminator

    pszSrc          -   source string

    cbToCopy        -   maximum number of bytes to copy from source string

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbCopyNExA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchToCopy = cbToCopy / sizeof(char);

        status = RtlStringExValidateSrcA(&pszSrc, &cchToCopy, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerA(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       cchToCopy);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbCopyNExW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchToCopy = cbToCopy / sizeof(wchar_t);

        status = RtlStringExValidateSrcW(&pszSrc, &cchToCopy, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerW(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       cchToCopy);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (NT_SUCCESS(status) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }

            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchCat(
    __inout_ecount(cchDest) LPTSTR  pszDest,
    __in     size_t  cchDest,
    __in     LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat'.
    The size of the destination buffer (in characters) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was concatenated without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be appended to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest     -  destination string which must be null terminated

    cchDest     -  size of destination buffer in characters.
                   length must be = (_tcslen(pszDest) + _tcslen(pszSrc) + 1)
                   to hold all of the combine string plus the null
                   terminator

    pszSrc      -  source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See RtlStringCchCatEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error occurs,
                       the destination buffer is modified to contain a truncated
                       version of the ideal result and is null terminated. This
                       is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchCatA(
    __inout_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCSTR pszSrc)
{
    NTSTATUS status;
    size_t cchDestLength;

    status = RtlStringValidateDestA(pszDest, cchDest, &cchDestLength, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringCopyWorkerA(pszDest + cchDestLength,
                               cchDest - cchDestLength,
                               NULL,
                               pszSrc,
                               NTSTRSAFE_MAX_CCH);
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchCatW(
    __inout_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCWSTR pszSrc)
{
    NTSTATUS status;
    size_t cchDestLength;

    status = RtlStringValidateDestW(pszDest, cchDest, &cchDestLength, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringCopyWorkerW(pszDest + cchDestLength,
                               cchDest - cchDestLength,
                               NULL,
                               pszSrc,
                               NTSTRSAFE_MAX_CCH);
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbCat(
    __inout_bcount(cbDest) LPTSTR  pszDest,
    __in     size_t  cbDest,
    __in     LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was concatenated without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be appended to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest     -  destination string which must be null terminated

    cbDest      -  size of destination buffer in bytes.
                   length must be = ((_tcslen(pszDest) + _tcslen(pszSrc) + 1) * sizeof(TCHAR)
                   to hold all of the combine string plus the null
                   terminator

    pszSrc      -  source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See RtlStringCbCatEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error occurs,
                       the destination buffer is modified to contain a truncated
                       version of the ideal result and is null terminated. This
                       is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbCatA(
    __inout_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCSTR pszSrc)
{
    NTSTATUS status;
    size_t cchDestLength;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringValidateDestA(pszDest, cchDest, &cchDestLength, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringCopyWorkerA(pszDest + cchDestLength,
                               cchDest - cchDestLength,
                               NULL,
                               pszSrc,
                               NTSTRSAFE_MAX_CCH);
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbCatW(
    __inout_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCWSTR pszSrc)
{
    NTSTATUS status;
    size_t cchDestLength;
    size_t cchDest = cbDest / sizeof(wchar_t);

    status = RtlStringValidateDestW(pszDest, cchDest, &cchDestLength, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringCopyWorkerW(pszDest + cchDestLength,
                               cchDest - cchDestLength,
                               NULL,
                               pszSrc,
                               NTSTRSAFE_MAX_CCH);
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchCatEx(
    __inout_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in     size_t  cchDest,
    __in     LPCTSTR pszSrc          OPTIONAL,
    __deref_opt_out_ecount(*pcchRemaining)    LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt    size_t* pcchRemaining   OPTIONAL,
    __in     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCchCat, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters
                        length must be (_tcslen(pszDest) + _tcslen(pszSrc) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcat

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchCatExA(
    __inout_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDestLength;

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        status = RtlStringExValidateSrcA(&pszSrc, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerA(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       NTSTRSAFE_MAX_LENGTH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;
            
                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);
            
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchCatExW(
    __inout_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDestLength;

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        status = RtlStringExValidateSrcW(&pszSrc, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerW(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       NTSTRSAFE_MAX_LENGTH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(wchar_t);
            
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbCatEx(
    __inout_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in     size_t  cbDest,
    __in     LPCTSTR pszSrc          OPTIONAL,
    __deref_opt_out_bcount(*pcbRemaining)    LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt    size_t* pcbRemaining    OPTIONAL,
    __in     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCbCat, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + _tcslen(pszSrc) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcat

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated
                       and the resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbCatExA(
    __inout_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);
    size_t cchDestLength;

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        status = RtlStringExValidateSrcA(&pszSrc, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerA(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       NTSTRSAFE_MAX_LENGTH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbCatExW(
    __inout_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);
    size_t cchDestLength;

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        status = RtlStringExValidateSrcW(&pszSrc, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerW(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       NTSTRSAFE_MAX_LENGTH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (NT_SUCCESS(status) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchCatN(
    __inout_ecount(cchDest) LPTSTR  pszDest,
    __in     size_t  cchDest,
    __in     LPCTSTR pszSrc,
    __in     size_t  cchToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat'.
    The size of the destination buffer (in characters) is a parameter as well as
    the maximum number of characters to append, excluding the null terminator.
    This function will not write past the end of the destination buffer and it will
    ALWAYS null terminate pszDest (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if all of pszSrc or the first cchToAppend characters were appended
    to the destination string and it was null terminated, otherwise it will
    return a failure code. In failure cases as much of pszSrc will be appended
    to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters.
                        length must be (_tcslen(pszDest) + min(cchToAppend, _tcslen(pszSrc)) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cchToAppend     -   maximum number of characters to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See RtlStringCchCatNEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if all of pszSrc or the first cchToAppend characters
                       were concatenated to pszDest and the resultant dest
                       string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchCatNA(
    __inout_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cchToAppend)
{
    NTSTATUS status;
    size_t cchDestLength;

    status = RtlStringValidateDestA(pszDest, cchDest, &cchDestLength, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        if (cchToAppend > NTSTRSAFE_MAX_LENGTH)
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            status = RtlStringCopyWorkerA(pszDest + cchDestLength,
                                   cchDest - cchDestLength,
                                   NULL,
                                   pszSrc,
                                   cchToAppend);
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchCatNW(
    __inout_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToAppend)
{
    NTSTATUS status;
    size_t cchDestLength;

    status = RtlStringValidateDestW(pszDest, cchDest, &cchDestLength, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        if (cchToAppend > NTSTRSAFE_MAX_LENGTH)
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            status = RtlStringCopyWorkerW(pszDest + cchDestLength,
                                   cchDest - cchDestLength,
                                   NULL,
                                   pszSrc,
                                   cchToAppend);
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbCatN(
    __inout_bcount(cbDest) LPTSTR  pszDest,
    __in     size_t  cbDest,
    __in     LPCTSTR pszSrc,
    __in     size_t  cbToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat'.
    The size of the destination buffer (in bytes) is a parameter as well as
    the maximum number of bytes to append, excluding the null terminator.
    This function will not write past the end of the destination buffer and it will
    ALWAYS null terminate pszDest (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if all of pszSrc or the first cbToAppend bytes were appended
    to the destination string and it was null terminated, otherwise it will
    return a failure code. In failure cases as much of pszSrc will be appended
    to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + min(cbToAppend / sizeof(TCHAR), _tcslen(pszSrc)) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cbToAppend      -   maximum number of bytes to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See RtlStringCbCatNEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if all of pszSrc or the first cbToAppend bytes were
                       concatenated to pszDest and the resultant dest string
                       was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbCatNA(
    __inout_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cbToAppend)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);
    size_t cchDestLength;

    status = RtlStringValidateDestA(pszDest, cchDest, &cchDestLength, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        size_t cchToAppend = cbToAppend / sizeof(char);
        
        if (cchToAppend > NTSTRSAFE_MAX_LENGTH)
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            status = RtlStringCopyWorkerA(pszDest + cchDestLength,
                                   cchDest - cchDestLength,
                                   NULL,
                                   pszSrc,
                                   cchToAppend);
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbCatNW(
    __inout_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cbToAppend)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);
    size_t cchDestLength;

    status = RtlStringValidateDestW(pszDest, cchDest, &cchDestLength, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        size_t cchToAppend = cbToAppend / sizeof(wchar_t);
        
        if (cchToAppend > NTSTRSAFE_MAX_LENGTH)
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            status = RtlStringCopyWorkerW(pszDest + cchDestLength,
                                   cchDest - cchDestLength,
                                   NULL,
                                   pszSrc,
                                   cchToAppend);
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchCatNEx(
    __inout_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in     size_t  cchDest,
    __in     LPCTSTR pszSrc          OPTIONAL,
    __in     size_t  cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining)    LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt    size_t* pcchRemaining   OPTIONAL,
    __in     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters.  In addition to functionality provided by
    RtlStringCchCatN, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters.
                        length must be (_tcslen(pszDest) + min(cchToAppend, _tcslen(pszSrc)) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cchToAppend     -   maximum number of characters to append

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if all of pszSrc or the first cchToAppend characters
                       were concatenated to pszDest and the resultant dest
                       string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchCatNExA(
    __inout_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDestLength;

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        status = RtlStringExValidateSrcA(&pszSrc, &cchToAppend, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerA(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       cchToAppend);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchCatNExW(
    __inout_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDestLength;

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        status = RtlStringExValidateSrcW(&pszSrc, &cchToAppend, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerW(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       cchToAppend);
                
                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbCatNEx(
    __inout_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in     size_t  cbDest,
    __in     LPCTSTR pszSrc          OPTIONAL,
    __in     size_t  cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining)    LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt    size_t* pcchRemaining   OPTIONAL,
    __in     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters.  In addition to functionality provided by
    RtlStringCbCatN, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + min(cbToAppend / sizeof(TCHAR), _tcslen(pszSrc)) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cbToAppend      -   maximum number of bytes to append

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if all of pszSrc or the first cbToAppend bytes were
                       concatenated to pszDest and the resultant dest string
                       was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbCatNExA(
    __inout_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);
    size_t cchDestLength;

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchToAppend = cbToAppend / sizeof(char);

        status = RtlStringExValidateSrcA(&pszSrc, &cchToAppend, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerA(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       cchToAppend);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbCatNExW(
    __inout_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);
    size_t cchDestLength;

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);

    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchToAppend = cbToAppend / sizeof(wchar_t);

        status = RtlStringExValidateSrcW(&pszSrc, &cchToAppend, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlStringCopyWorkerW(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       cchToAppend);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (NT_SUCCESS(status) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchVPrintf(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in  size_t  cchDest,
    __in __format_string  LPCTSTR pszFormat,
    __in  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cchDest     -  size of destination buffer in characters
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    argList     -  va_list from the variable arguments according to the
                   stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See RtlStringCchVPrintfEx if you
    require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchVPrintfA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status;

    status = RtlStringValidateDestA(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringVPrintfWorkerA(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchVPrintfW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status;

    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringVPrintfWorkerW(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbVPrintf(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in size_t  cbDest,
    __in __format_string LPCTSTR pszFormat,
    __in va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cbDest      -  size of destination buffer in bytes
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    argList     -  va_list from the variable arguments according to the
                   stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See RtlStringCbVPrintfEx if you
    require the handling of NULL values.


Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbVPrintfA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringValidateDestA(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringVPrintfWorkerA(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbVPrintfW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);
 
    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        status = RtlStringVPrintfWorkerW(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef _M_CEE_PURE

#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchPrintf(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in size_t  cchDest,
    __in __format_string  LPCTSTR pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cchDest     -  size of destination buffer in characters
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    ...         -  additional parameters to be formatted according to
                   the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See RtlStringCchPrintfEx if you
    require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchPrintfA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    ...)
{
    NTSTATUS status;

    status = RtlStringValidateDestA(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        va_list argList;

        va_start(argList, pszFormat);

        status = RtlStringVPrintfWorkerA(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);

        va_end(argList);
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchPrintfW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    ...)
{
    NTSTATUS status;

    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        va_list argList;

        va_start(argList, pszFormat);

        status = RtlStringVPrintfWorkerW(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);

        va_end(argList);
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbPrintf(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in size_t  cbDest,
    __in __format_string LPCTSTR pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cbDest      -  size of destination buffer in bytes
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    ...         -  additional parameters to be formatted according to
                   the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See RtlStringCbPrintfEx if you
    require the handling of NULL values.


Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbPrintfA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    ...)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringValidateDestA(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        va_list argList;

        va_start(argList, pszFormat);

        status = RtlStringVPrintfWorkerA(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);

        va_end(argList);
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbPrintfW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    ...)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);

    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);
    
    if (NT_SUCCESS(status))
    {
        va_list argList;

        va_start(argList, pszFormat);

        status = RtlStringVPrintfWorkerW(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);

        va_end(argList);
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchPrintfEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cchDest,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCchPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return
                        the number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

    pszFormat       -   format string which must be null terminated

    ...             -   additional parameters to be formatted according to
                        the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchPrintfExA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    ...)
{
    NTSTATUS status;

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcA(&pszFormat, NULL, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, pszFormat);

                status = RtlStringVPrintfWorkerA(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

             // safe to multiply cchDest * sizeof(char) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchPrintfExW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    ...)
{
    NTSTATUS status;

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcW(&pszFormat, NULL, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, pszFormat);

                status = RtlStringVPrintfWorkerW(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbPrintfEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cbDest,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCbPrintf, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

    pszFormat       -   format string which must be null terminated

    ...             -   additional parameters to be formatted according to
                        the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbPrintfExA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    ...)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcA(&pszFormat, NULL, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, pszFormat);

                status = RtlStringVPrintfWorkerA(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbPrintfExW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    ...)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcW(&pszFormat, NULL, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, pszFormat);

                status = RtlStringVPrintfWorkerW(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (NT_SUCCESS(status) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS

#endif  // !_M_CEE_PURE


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchVPrintfEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cchDest,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    __in va_list argList
    );


Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCchVPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return
                        the number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

    pszFormat       -   format string which must be null terminated

    argList         -   va_list from the variable arguments according to the
                        stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCchVPrintfExA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status;

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcA(&pszFormat, NULL, NTSTRSAFE_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                status = RtlStringVPrintfWorkerA(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchVPrintfExW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status;

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcW(&pszFormat, NULL, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                status = RtlStringVPrintfWorkerW(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbVPrintfEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cbDest,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    __in va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters.  In addition to functionality provided by
    RtlStringCbVPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return
                        a pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

    pszFormat       -   format string which must be null terminated

    argList         -   va_list from the variable arguments according to the
                        stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlStringCbVPrintfExA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(char);

    status = RtlStringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcA(&pszFormat, NULL, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                status = RtlStringVPrintfWorkerA(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbVPrintfExW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);

    status = RtlStringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               NTSTRSAFE_MAX_CCH,
                               dwFlags);
    
    if (NT_SUCCESS(status))
    {
        NTSTRSAFE_PWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        status = RtlStringExValidateSrcW(&pszFormat, NULL, NTSTRSAFE_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                status = RtlStringVPrintfWorkerW(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (NT_SUCCESS(status) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlStringCchLength(
    __in_opt LPCTSTR psz         OPTIONAL,
    __in size_t  cchMax,
    __out_opt size_t* pcchLength  OPTIONAL
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strlen'.
    It is used to make sure a string is not larger than a given length, and
    it optionally returns the current length in characters not including
    the null terminator.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string is non-null and the length including the null
    terminator is less than or equal to cchMax characters.

Arguments:

    psz         -   string to check the length of

    cchMax      -   maximum number of characters including the null terminator
                    that psz is allowed to contain

    pcch        -   if the function succeeds and pcch is non-null, the current length
                    in characters of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz)

Notes:
    psz can be null but the function will fail

    cchMax should be greater than zero or the function will fail

Return Value:

    STATUS_SUCCESS -   psz is non-null and the length including the null
                       terminator is less than or equal to cchMax characters

    failure        -   the operation did not succeed


    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCchLengthA(
    __in_opt NTSTRSAFE_PCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    NTSTATUS status;

    if ((psz == NULL) || (cchMax > NTSTRSAFE_MAX_CCH))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = RtlStringLengthWorkerA(psz, cchMax, pcchLength);
    }
    
    if (!NT_SUCCESS(status) && pcchLength)
    {
        *pcchLength = 0;
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCchLengthW(
    __in_opt NTSTRSAFE_PCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    NTSTATUS status;

    if ((psz == NULL) || (cchMax > NTSTRSAFE_MAX_CCH))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = RtlStringLengthWorkerW(psz, cchMax, pcchLength);
    }
    
    if (!NT_SUCCESS(status) && pcchLength)
    {
        *pcchLength = 0;
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlStringCbLength(
    __in_opt LPCTSTR psz,        OPTIONAL
    __in size_t  cbMax,
    __out_opt size_t* pcbLength   OPTIONAL
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strlen'.
    It is used to make sure a string is not larger than a given length, and
    it optionally returns the current length in bytes not including
    the null terminator.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string is non-null and the length including the null
    terminator is less than or equal to cbMax bytes.

Arguments:

    psz         -   string to check the length of

    cbMax       -   maximum number of bytes including the null terminator
                    that psz is allowed to contain

    pcb         -   if the function succeeds and pcb is non-null, the current length
                    in bytes of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz) * sizeof(TCHAR)

Notes:
    psz can be null but the function will fail

    cbMax should be greater than or equal to sizeof(TCHAR) or the function will fail

Return Value:

    STATUS_SUCCESS -   psz is non-null and the length including the null
                       terminator is less than or equal to cbMax bytes

    failure        -   the operation did not succeed


    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCbLengthA(
    __in_opt NTSTRSAFE_PCSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength)
{
    NTSTATUS status;
    size_t cchMax = cbMax / sizeof(char);
    size_t cchLength = 0;

    if ((psz == NULL) || (cchMax > NTSTRSAFE_MAX_CCH))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = RtlStringLengthWorkerA(psz, cchMax, &cchLength);
    }

    if (pcbLength)
    {
        if (NT_SUCCESS(status))
        {
             // safe to multiply cchLength * sizeof(char) since cchLength < NTSTRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbLength = cchLength * sizeof(char);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return status;
}

NTSTRSAFEDDI
RtlStringCbLengthW(
    __in_opt NTSTRSAFE_PCWSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength)
{
    NTSTATUS status;
    size_t cchMax = cbMax / sizeof(wchar_t);
    size_t cchLength = 0;

    if ((psz == NULL) || (cchMax > NTSTRSAFE_MAX_CCH))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = RtlStringLengthWorkerW(psz, cchMax, &cchLength);
    }

    if (pcbLength)
    {
        if (NT_SUCCESS(status))
        {
            // safe to multiply cchLength * sizeof(wchar_t) since cchLength < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbLength = cchLength * sizeof(wchar_t);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS

#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnalignedStringCchLength(
    __in_opt LPCUTSTR    psz         OPTIONAL,
    __in size_t      cchMax,
    __out_opt size_t*     pcchLength  OPTIONAL
    );

Routine Description:

    This routine is a version of RtlStringCchLength that accepts an unaligned string pointer.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string is non-null and the length including the null
    terminator is less than or equal to cchMax characters.

Arguments:

    psz         -   string to check the length of

    cchMax      -   maximum number of characters including the null terminator
                    that psz is allowed to contain

    pcch        -   if the function succeeds and pcch is non-null, the current length
                    in characters of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz)

Notes:
    psz can be null but the function will fail

    cchMax should be greater than zero or the function will fail

Return Value:

    STATUS_SUCCESS -   psz is non-null and the length including the null
                       terminator is less than or equal to cchMax characters

    failure        -   the operation did not succeed


    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

#ifdef ALIGNMENT_MACHINE
NTSTRSAFEDDI
RtlUnalignedStringCchLengthW(
    __in_opt NTSTRSAFE_PCUWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    NTSTATUS status;

    if ((psz == NULL) || (cchMax > NTSTRSAFE_MAX_CCH))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = RtlUnalignedStringLengthWorkerW(psz, cchMax, pcchLength);
    }
    
    if (!NT_SUCCESS(status) && pcchLength)
    {
        *pcchLength = 0;
    }

    return status;
}
#else
#define RtlUnalignedStringCchLengthW   RtlStringCchLengthW
#endif  // !ALIGNMENT_MACHINE
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS

#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnalignedStringCbLength(
    __in_opt LPCUTSTR    psz,        OPTIONAL
    __in size_t      cbMax,
    __out_opt size_t*     pcbLength   OPTIONAL
    );

Routine Description:

    This routine is a version of RtlStringCbLength that accepts an unaligned string pointer.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string is non-null and the length including the null
    terminator is less than or equal to cbMax bytes.

Arguments:

    psz         -   string to check the length of

    cbMax       -   maximum number of bytes including the null terminator
                    that psz is allowed to contain

    pcb         -   if the function succeeds and pcb is non-null, the current length
                    in bytes of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz) * sizeof(TCHAR)

Notes:
    psz can be null but the function will fail

    cbMax should be greater than or equal to sizeof(TCHAR) or the function will fail

Return Value:

    STATUS_SUCCESS -   psz is non-null and the length including the null
                       terminator is less than or equal to cbMax bytes

    failure        -   the operation did not succeed


    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

#ifdef ALIGNMENT_MACHINE
NTSTRSAFEDDI
RtlUnalignedStringCbLengthW(
    __in_opt NTSTRSAFE_PCUWSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength)
{
    NTSTATUS status;
    size_t cchMax = cbMax / sizeof(wchar_t);
    size_t cchLength = 0;

    if ((psz == NULL) || (cchMax > NTSTRSAFE_MAX_CCH))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = RtlUnalignedStringLengthWorkerW(psz, cchMax, &cchLength);
    }

    if (pcbLength)
    {
        if (NT_SUCCESS(status))
        {
            // safe to multiply cchLength * sizeof(wchar_t) since cchLength < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbLength = cchLength * sizeof(wchar_t);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return status;
}
#else
#define RtlUnalignedStringCbLengthW    RtlStringCbLengthW
#endif  // !ALIGNMENT_MACHINE
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS

#ifndef NTSTRSAFE_NO_UNICODE_STRING_FUNCTIONS

/*++

NTSTATUS
RtlUnicodeStringInit(
    __out PUNICODE_STRING DestinationString,
    __in_opt NTSTRSAFE_PCWSTR pszSrc              OPTIONAL
    );

Routine Description:

    The RtlUnicodeStringInit function initializes a counted unicode string from
    pszSrc.

    This function returns an NTSTATUS value.  It returns STATUS_SUCCESS if the 
    counted unicode string was sucessfully initialized from pszSrc. In failure
    cases the unicode string buffer will be set to NULL, and the Length and 
    MaximumLength members will be set to zero.

Arguments:

    DestinationString - pointer to the counted unicode string to be initialized

    pszSrc            - source string which must be null or null terminated
    
Notes:
    DestinationString should not be NULL. See RtlUnicodeStringInitEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   

    failure        -   the operation did not succeed

      STATUS_INVALID_PARAMETER
                   -   this return value is an indication that the source string
                       was too large and DestinationString could not be initialized

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringInit(
    __out PUNICODE_STRING DestinationString,
    __in_opt NTSTRSAFE_PCWSTR pszSrc)
{
    return RtlUnicodeStringInitWorker(DestinationString,
                                      pszSrc,
                                      NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                      0);
}


/*++

NTSTATUS
RtlUnicodeStringInitEx(
    __out PUNICODE_STRING DestinationString,
    __in_opt  NTSTRSAFE_PCWSTR pszSrc              OPTIONAL,
    __in DWORD           dwFlags
    );

Routine Description:

    In addition to functionality provided by RtlUnicodeStringInit, this routine
    includes the flags parameter allows additional controls.

    This function returns an NTSTATUS value.  It returns STATUS_SUCCESS if the 
    counted unicode string was sucessfully initialized from pszSrc. In failure
    cases the unicode string buffer will be set to NULL, and the Length and 
    MaximumLength members will be set to zero.

Arguments:

    DestinationString - pointer to the counted unicode string to be initialized

    pszSrc            - source string which must be null terminated

    dwFlags           - controls some details of the initialization:

        STRSAFE_IGNORE_NULLS
                    do not fault on a NULL DestinationString pointer

Return Value:

    STATUS_SUCCESS -   

    failure        -   the operation did not succeed

      STATUS_INVALID_PARAMETER

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringInitEx(
    __out PUNICODE_STRING DestinationString,
    __in_opt NTSTRSAFE_PCWSTR pszSrc,
    __in DWORD dwFlags)
{
    NTSTATUS status;

    if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = RtlUnicodeStringInitWorker(DestinationString,
                                            pszSrc,
                                            NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                            dwFlags);
    }
    
    if (!NT_SUCCESS(status) && DestinationString)
    {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringValidate(
    __in PCUNICODE_STRING    SourceString
    );

Routine Description:

    The RtlUnicodeStringValidate function checks the counted unicode string to make
    sure that is is valid.

    This function returns an NTSTATUS value.  It returns STATUS_SUCCESS if the 
    counted unicode string is valid.

Arguments:

    SourceString   - pointer to the counted unicode string to be checked
    
Notes:
    SourceString should not be NULL. See RtlUnicodeStringValidateEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   SourceString is a valid counted unicode string

    failure        -   the operation did not succeed

      STATUS_INVALID_PARAMETER
                   -   this return value is an indication that SourceString is not a valid
                       counted unicode string

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringValidate(
    __in PCUNICODE_STRING SourceString)
{
    return RtlUnicodeStringValidateWorker(SourceString, NTSTRSAFE_UNICODE_STRING_MAX_CCH, 0);
}


/*++

NTSTATUS
RtlUnicodeStringValidateEx(
    __in PCUNICODE_STRING    SourceString     OPTIONAL,
    __in DWORD               dwFlags
    );

Routine Description:

    In addition to functionality provided by RtlUnicodeStringValidate, this routine
    includes the flags parameter allows additional controls.

    This function returns an NTSTATUS value.  It returns STATUS_SUCCESS if the 
    counted unicode string is valid.

Arguments:

    SourceString   - pointer to the counted unicode string to be checked

    dwFlags        - controls some details of the validation:

        STRSAFE_IGNORE_NULLS
                    allows SourceString to be NULL (will return STATUS_SUCCESS for this case).

Return Value:

    STATUS_SUCCESS -   SourceString is a valid counted unicode string

    failure        -   the operation did not succeed

      STATUS_INVALID_PARAMETER
                   -   this return value is an indication that the source string
                       is not a valide counted unicode string given the flags passed.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringValidateEx(
    __in PCUNICODE_STRING SourceString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    
    if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = RtlUnicodeStringValidateWorker(SourceString, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);
    }

    return status;
}


/*++

NTSTATUS
RtlStringCchCopyUnicodeString(
    __out_ecount(cchDest) PWSTR               pszDest,
    __in size_t              cchDest,
    __in PCUNICODE_STRING    SourceString,
    );

Routine Description:

    This routine copies a PUNICODE_STRING to a PWSTR. This function will not
    write past the end of this buffer and it will ALWAYS null terminate the
    destination buffer (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer. It returns
    STATUS_SUCCESS if the string was copied without truncation, otherwise it
    will return a failure code. In failure cases as much of SourceString will be
    copied to pszDest as possible.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = ((DestinationString->Length / sizeof(wchar_t)) + 1)
                       to hold all of the source and null terminate the string.
                       
    SourceString   -   pointer to the counted unicode source string
                       
Notes:
    Behavior is undefined if source and destination strings overlap.

    SourceString and pszDest should not be NULL.  See RtlStringCchCopyUnicodeStringEx
    if you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCchCopyUnicodeString(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in PCUNICODE_STRING SourceString)
{
    NTSTATUS status;
    
    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        
        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            status = RtlStringCopyWideCharArrayWorker(pszDest,
                                                      cchDest,
                                                      NULL,
                                                      pszSrc,
                                                      cchSrcLength);
        }
        else
        {
            *pszDest = L'\0';
        }
    }
    
    return status;
}


/*++

NTSTATUS
RtlStringCbCopyUnicodeString(
    __out_bcount(cbDest) PWSTR               pszDest,
    __in size_t              cbDest,
    __in PCUNICODE_STRING    SourceString,
    );

Routine Description:

    This routine copies a PUNICODE_STRING to a PWSTR. This function will not
    write past the end of this buffer and it will ALWAYS null terminate the
    destination buffer (unless it is zero length).

    This function returns an NTSTATUS value, and not a pointer. It returns
    STATUS_SUCCESS if the string was copied without truncation, otherwise it
    will return a failure code. In failure cases as much of SourceString will be
    copied to pszDest as possible.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = (DestinationString->Length + sizeof(wchar_t))
                       to hold all of the source and null terminate the string.
                       
    SourceString   -   pointer to the counted unicode source string
                       
Notes:
    Behavior is undefined if source and destination strings overlap.

    SourceString and pszDest should not be NULL.  See RtlStringCbCopyUnicodeStringEx
    if you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCbCopyUnicodeString(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in PCUNICODE_STRING SourceString)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);
    
    status = RtlStringValidateDestW(pszDest, cchDest, NULL, NTSTRSAFE_MAX_CCH);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        
        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            status = RtlStringCopyWideCharArrayWorker(pszDest,
                                                      cchDest,
                                                      NULL,
                                                      pszSrc,
                                                      cchSrcLength);
        }
        else
        {
            *pszDest = L'\0';
        }
    }
    
    return status;
}


/*++

NTSTATUS
RtlStringCchCopyUnicodeStringEx(
    __out_ecount(cchDest) PWSTR               pszDest         OPTIONAL,
    __in size_t              cchDest,
    __in PCUNICODE_STRING    SourceString    OPTIONAL,
    __deref_opt_out_ecount(*pcchRemaining) PWSTR*              ppszDestEnd     OPTIONAL,
    __out_opt size_t*             pcchRemaining   OPTIONAL,
    __in DWORD               dwFlags
    );

Routine Description:

    This routine copies a PUNICODE_STRING to a PWSTR. In addition to
    functionality provided by RtlStringCchCopyUnicodeString, this routine also
    returns a pointer to the end of the destination string and the number of
    characters left in the destination string including the null terminator.
    The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = ((DestinationString->Length / sizeof(wchar_t)) + 1)
                        to hold all of the source and null terminate the string.
                       
    SourceString    -   pointer to the counted unicode source string
    
    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.
                       
Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and SourceString should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and SourceString
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCchCopyUnicodeStringEx(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __in PCUNICODE_STRING SourceString,
    __deref_opt_out_ecount(*pcchRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    
    status = RtlStringExValidateDestW(&pszDest,
                                      &cchDest,
                                      NULL,
                                      NTSTRSAFE_MAX_CCH,
                                      dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        
        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (cchSrcLength != 0)
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;
                
                status = RtlStringCopyWideCharArrayWorker(pszDest,
                                                          cchDest,
                                                          &cchCopied,
                                                          pszSrc,
                                                          cchSrcLength);
                                                            
                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;
                
                if (NT_SUCCESS(status)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }
        
        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);
            
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }   
    }
    
    return status;
}


/*++

NTSTATUS
RtlStringCbCopyUnicodeStringEx(
    __out_bcount(cbDest) PWSTR               pszDest         OPTIONAL,
    __in size_t              cbDest,
    __in PCUNICODE_STRING    SourceString    OPTIONAL,
    __deref_opt_out_bcount(*pcbRemaining) PWSTR*              ppszDestEnd     OPTIONAL,
    __out_opt size_t*             pcbRemaining    OPTIONAL,
    __in DWORD               dwFlags
    );

Routine Description:

    This routine copies a PUNICODE_STRING to a PWSTR. In addition to
    functionality provided by RtlStringCbCopyUnicodeString, this routine also
    returns a pointer to the end of the destination string and the number of
    characters left in the destination string including the null terminator.
    The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = ((DestinationString->Length / sizeof(wchar_t)) + 1)
                        to hold all of the source and null terminate the string.
                       
    SourceString    -   pointer to the counted unicode source string
    
    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.
                       
Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and SourceString should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and SourceString
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlStringCbCopyUnicodeStringEx(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in PCUNICODE_STRING SourceString,
    __deref_opt_out_bcount(*pcbRemaining) NTSTRSAFE_PWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    size_t cchDest = cbDest / sizeof(wchar_t);
    
    status = RtlStringExValidateDestW(&pszDest,
                                      &cchDest,
                                      NULL,
                                      NTSTRSAFE_MAX_CCH,
                                      dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        
        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (cchSrcLength != 0)
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;
                
                status = RtlStringCopyWideCharArrayWorker(pszDest,
                                                          cchDest,
                                                          &cchCopied,
                                                          pszSrc,
                                                          cchSrcLength);
                                                            
                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;
                
                if (NT_SUCCESS(status) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    RtlStringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }
        
        if (!NT_SUCCESS(status)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            RtlStringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }
    
    return status;
}


/*++

NTSTATUS
RtlUnicodeStringCopyString(
    __out PUNICODE_STRING DestinationString,
    __in  LPCTSTR         pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' for
    UNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was copied without truncation, otherwise it
    will return a failure code. In failure cases as much of pszSrc will be
    copied to DestinationString as possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL.  See RtlUnicodeStringCopyStringEx
    if you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringCopyString(
    __out PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        size_t cchNewDestLength = 0;
        
        status = RtlWideCharArrayCopyStringWorker(pszDest,
                                                  cchDest,
                                                  &cchNewDestLength,
                                                  pszSrc,
                                                  NTSTRSAFE_UNICODE_STRING_MAX_CCH);

        // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringCopy(
    __out PUNICODE_STRING    DestinationString,
    __in PCUNICODE_STRING    SourceString
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' for
    UNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was copied without truncation, otherwise it
    will return a failure code. In failure cases as much of SourceString
    will be copied to Dest as possible.

Arguments:

    DestinationString   - pointer to the counted unicode destination string

    SourceString        -  pointer to the counted unicode source string

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL.  See RtlUnicodeStringCopyEx
    if you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringCopy(
    __out PUNICODE_STRING DestinationString, 
    __in PCUNICODE_STRING SourceString)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        size_t cchNewDestLength = 0;
        
        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            status = RtlWideCharArrayCopyWorker(pszDest,
                                                cchDest,
                                                &cchNewDestLength,
                                                pszSrc,
                                                cchSrcLength);
        }

        // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringCopyStringEx(
    __out PUNICODE_STRING DestinationString   OPTIONAL,
    __in  LPCTSTR         pszSrc              OPTIONAL,
    __out_opt PUNICODE_STRING RemainingString     OPTIONAL,
    __in  DWORD           dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' for
    UNICODE_STRINGs with some additional parameters. In addition to the
    functionality provided by RtlUnicodeStringCopyString, this routine also
    returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string which must be null terminated

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszSrc like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored.

    Behavior is undefined if DestinationString and RemainingString are the same pointer.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCopyStringEx(
    __out PUNICODE_STRING DestinationString, 
    __in NTSTRSAFE_PCWSTR pszSrc,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchNewDestLength = 0;

        status = RtlStringExValidateSrcW(&pszSrc, NULL, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {        
                status = RtlWideCharArrayCopyStringWorker(pszDest,
                                                          cchDest,
                                                          &cchNewDestLength,
                                                          pszSrc,
                                                          NTSTRSAFE_UNICODE_STRING_MAX_CCH);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        
        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               0,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringCopyEx(
    __out PUNICODE_STRING     DestinationString   OPTIONAL,
    __in  PCUNICODE_STRING    SourceString        OPTIONAL,
    __out_opt PUNICODE_STRING     RemainingString     OPTIONAL,
    __in  DWORD               dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' for
    UNICODE_STRINGs with some additional parameters. In addition to the
    functionality provided by RtlUnicodeStringCopy, this routine
    also returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string
    
    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszSrc like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and SourceString
    may be NULL.  An error may still be returned even though NULLS are ignored.

    Behavior is undefined if DestinationString and RemainingString are the same pointer.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCopyEx(
    __out PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest; 
        size_t cchNewDestLength = 0;
        
        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (cchSrcLength != 0)
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                status = RtlWideCharArrayCopyWorker(pszDest,
                                                    cchDest,
                                                    &cchNewDestLength,
                                                    pszSrc,
                                                    cchSrcLength);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               0,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }

        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCchCopyStringN(
    __out PUNICODE_STRING DestinationString,
    __in LPCTSTR         pszSrc,
    __in size_t          cchToCopy
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' for
    PUNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the entire string or the first cchToCopy characters were
    copied without truncation, otherwise it will return a failure code. In
    failure cases as much of pszSrc will be copied to DestinationString as possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string

    cchToCopy           -   maximum number of characters to copy from source string,
                            not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL. See RtlUnicodeStringCchCopyStringNEx if
    you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringCchCopyStringN(
    __out PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToCopy)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    
    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        size_t cchNewDestLength = 0;

        if (cchToCopy > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            status = RtlWideCharArrayCopyStringWorker(pszDest,
                                                      cchDest,
                                                      &cchNewDestLength,
                                                      pszSrc,
                                                      cchToCopy);
        }

        // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCbCopyStringN(
    __out PUNICODE_STRING DestinationString,
    __in LPCTSTR         pszSrc,
    __in size_t          cbToCopy
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' for
    PUNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the entire string or the first cbToCopy bytes were
    copied without truncation, otherwise it will return a failure code. In
    failure cases as much of pszSrc will be copied to DestinationString as possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string

    cbToCopy            -   maximum number of bytes to copy from source string,
                            not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL.  See RtlUnicodeStringCopyCbStringEx if you require
    the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok
                       
    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringCbCopyStringN(
    __out PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cbToCopy)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    
    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        size_t cchNewDestLength = 0;
        size_t cchToCopy = cbToCopy / sizeof(wchar_t);

        if (cchToCopy > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            status = RtlWideCharArrayCopyStringWorker(pszDest,
                                                      cchDest,
                                                      &cchNewDestLength,
                                                      pszSrc,
                                                      cchToCopy);
        }

        // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCchCopyN(
    __out PUNICODE_STRING     DestinationString,
    __in  PCUNICODE_STRING    SourceString,
    __in  size_t              cchToCopy
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' for
    PUNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the entire string or the first cchToCopy characters were
    copied without truncation, otherwise it will return a failure code. In
    failure cases as much of SourceString will be copied to DestinationString as possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string
    
    cchToCopy           -   maximum number of characters to copy from source string,
                            not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL. See RtlUnicodeStringCchCopyNEx
    if you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringCchCopyN(
    __out PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in size_t cchToCopy)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    
    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        size_t cchNewDestLength = 0;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            if (cchToCopy > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                if (cchSrcLength < cchToCopy)
                {
                    cchToCopy = cchSrcLength;
                }

                status = RtlWideCharArrayCopyWorker(pszDest,
                                                    cchDest,
                                                    &cchNewDestLength,
                                                    pszSrc,
                                                    cchToCopy);
            }
        }

        // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCbCopyN(
    __out PUNICODE_STRING     DestinationString,
    __in  PCUNICODE_STRING    SourceString,
    __in  size_t              cbToCopy
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' for
    PUNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the entire string or the first cbToCopy bytes were
    copied without truncation, otherwise it will return a failure code. In
    failure cases as much of SourceString will be copied to DestinationString as possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string

    cbToCopy            -   maximum number of bytes to copy from source string,
                            not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL.  See RtlUnicodeStringCbCopyNEx
    if you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok
                       
    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/


NTSTRSAFEDDI
RtlUnicodeStringCbCopyN(
    __out PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in size_t cbToCopy)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    
    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        size_t cchNewDestLength = 0;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            size_t cchToCopy = cbToCopy / sizeof(wchar_t);

            if (cchToCopy > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                if (cchSrcLength < cchToCopy)
                {
                    cchToCopy = cchSrcLength;
                }

                status = RtlWideCharArrayCopyWorker(pszDest,
                                                    cchDest,
                                                    &cchNewDestLength,
                                                    pszSrc,
                                                    cchToCopy);
            }
        }

        // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCchCopyStringNEx(
    __out PUNICODE_STRING DestinationString   OPTIONAL,
    __in LPCTSTR         pszSrc              OPTIONAL,
    __in size_t          cchToCopy,
    __out_opt PUNICODE_STRING RemainingString     OPTIONAL,
    __in DWORD           dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters and for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringCchCopyStringN, this routine also
    returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string

    cchToCopy           -   maximum number of characters to copy from source string

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszSrc like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCchCopyStringNEx(
    __out PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToCopy,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchNewDestLength = 0;

        status = RtlStringExValidateSrcW(&pszSrc, &cchToCopy, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                status = RtlWideCharArrayCopyStringWorker(pszDest,
                                                          cchDest,
                                                          &cchNewDestLength,
                                                          pszSrc,
                                                          cchToCopy);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               0,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCbCopyStringNEx(
    __out PUNICODE_STRING DestinationString   OPTIONAL,
    __in LPCTSTR         pszSrc              OPTIONAL,
    __in size_t          cbToCopy,
    __out_opt PUNICODE_STRING RemainingString     OPTIONAL,
    __in DWORD           dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters and for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringCbCopyStringN, this routine also
    returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string

    cbToCopy            -   maximum number of bytes to copy from source string

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszSrc like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.


Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCbCopyStringNEx(
    __out PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cbToCopy,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchNewDestLength = 0;
        size_t cchToCopy = cbToCopy / sizeof(wchar_t);

        status = RtlStringExValidateSrcW(&pszSrc, &cchToCopy, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                status = RtlWideCharArrayCopyStringWorker(pszDest,
                                                          cchDest,
                                                          &cchNewDestLength,
                                                          pszSrc,
                                                          cchToCopy);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               0,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCchCopyNEx(
    __out PUNICODE_STRING     DestinationString   OPTIONAL,
    __in  PCUNICODE_STRING    SourceString        OPTIONAL,
    __in  size_t              cchToCopy,
    __out_opt PUNICODE_STRING RemainingString     OPTIONAL,
    __in  DWORD               dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters and for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringCchCopyN, this
    routine also returns a PUNICODE_STRING which points to the end of the
    destination string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string
    
    SourceString        -   pointer to the counted unicode source string

    cchToCopy           -   maximum number of characters to copy from source string

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL SourceString like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.
Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and SourceString
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied
    
    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCchCopyNEx(
    __out PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in size_t cchToCopy,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchNewDestLength = 0;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   dwFlags);

        if (NT_SUCCESS(status))
        {
            if (cchToCopy > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                if (cchSrcLength < cchToCopy)
                {
                    cchToCopy = cchSrcLength;
                }

                if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
                {
                    status = STATUS_INVALID_PARAMETER;
                }
                else if (cchDest == 0)
                {
                    // only fail if there was actually src data to copy
                    if (cchToCopy != 0)
                    {
                        if (pszDest == NULL)
                        {
                            status = STATUS_INVALID_PARAMETER;
                        }
                        else
                        {
                            status = STATUS_BUFFER_OVERFLOW;
                        }
                    }
                }
                else
                {
                    status = RtlWideCharArrayCopyWorker(pszDest,
                                                        cchDest,
                                                        &cchNewDestLength,
                                                        pszSrc,
                                                        cchToCopy);

                    pszDestEnd = pszDest + cchNewDestLength;
                    cchRemaining = cchDest - cchNewDestLength;
                    
                    if (NT_SUCCESS(status)              &&
                        (dwFlags & STRSAFE_FILL_BEHIND) &&
                        (cchRemaining != 0))
                    {
                        // handle the STRSAFE_FILL_BEHIND flag
                        RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                    }
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               0,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCbCopyNEx(
    __out PUNICODE_STRING     DestinationString   OPTIONAL,
    __in  PCUNICODE_STRING    SourceString        OPTIONAL,
    __in  size_t              cbToCopy,
    __out_opt PUNICODE_STRING RemainingString     OPTIONAL,
    __in  DWORD               dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters and for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringCbCopyN, this
    routine also returns a PUNICODE_STRING which points to the end of the
    destination string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string

    cbToCopy            -   maximum number of bytes to copy from source string

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL SourceString like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and SourceString
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all copied

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCbCopyNEx(
    __out PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in size_t cbToCopy,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchNewDestLength = 0;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   dwFlags);

        if (NT_SUCCESS(status))
        {
            size_t cchToCopy = cbToCopy / sizeof(wchar_t);

            if (cchToCopy > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                if (cchSrcLength < cchToCopy)
                {
                    cchToCopy = cchSrcLength;
                }

                if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
                {
                    status = STATUS_INVALID_PARAMETER;
                }
                else if (cchDest == 0)
                {
                    // only fail if there was actually src data to copy
                    if (cchToCopy != 0)
                    {
                        if (pszDest == NULL)
                        {
                            status = STATUS_INVALID_PARAMETER;
                        }
                        else
                        {
                            status = STATUS_BUFFER_OVERFLOW;
                        }
                    }
                }
                else
                {
                    status = RtlWideCharArrayCopyWorker(pszDest,
                                                        cchDest,
                                                        &cchNewDestLength,
                                                        pszSrc,
                                                        cchToCopy);

                    pszDestEnd = pszDest + cchNewDestLength;
                    cchRemaining = cchDest - cchNewDestLength;
                    
                    if (NT_SUCCESS(status)              &&
                        (dwFlags & STRSAFE_FILL_BEHIND) &&
                        (cchRemaining != 0))
                    {
                        // handle the STRSAFE_FILL_BEHIND flag
                        RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                    }
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               0,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


/*++

NTSTATUS
RtlUnicodeStringCatString(
    __inout  PUNICODE_STRING DestinationString,
    __in     LPCTSTR         pszSrc
    );

 Routine Description:

    This routine is a safer version of the C built-in function 'strcat' for
    UNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was concatenated without truncation, otherwise
    it will return a failure code. In failure cases as much of pszSrc will be
    appended to DestinationString as possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL.  See RtlUnicodeStringCatStringEx
    if you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this 
            status do have their data copied back to user mode
                   -   this return value is an indication that the
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringCatString(
    __inout PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        size_t cchCopied = 0;

        status = RtlWideCharArrayCopyStringWorker(pszDest + cchDestLength,
                                                  cchDest - cchDestLength,
                                                  &cchCopied,
                                                  pszSrc,
                                                  NTSTRSAFE_UNICODE_STRING_MAX_CCH);

        // safe to multiply (cchDestLength + cchCopied) * sizeof(wchar_t) since (cchDestLength + cchCopied) < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)((cchDestLength + cchCopied) * sizeof(wchar_t));
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringCat(
    __inout  PUNICODE_STRING     DestinationString,
    __in     PCUNICODE_STRING    SourceString
    );
    
 Routine Description:

    This routine is a safer version of the C built-in function 'strcat' for
    UNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer.  It returns
    STATUS_SUCCESS if the string was concatenated without truncation, otherwise
    it will return a failure code. In failure cases as much of SourceString will be
    appended to DestinationString as possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL.  See RtlUnicodeStringCatEx
    if you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this 
            status do have their data copied back to user mode
                   -   this return value is an indication that the
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function.

--*/

NTSTRSAFEDDI
RtlUnicodeStringCat(
    __inout PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        
        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            size_t cchCopied = 0;

            status = RtlWideCharArrayCopyWorker(pszDest + cchDestLength,
                                                cchDest - cchDestLength,
                                                &cchCopied,
                                                pszSrc,
                                                cchSrcLength);

            // safe to multiply (cchDestLength + cchCopied) * sizeof(wchar_t) since (cchDestLength + cchCopied) < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)((cchDestLength + cchCopied) * sizeof(wchar_t));
        }
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringCatStringEx(
    __inout PUNICODE_STRING DestinationString   OPTTONAL,
    __in      LPCTSTR         pszSrc              OPTIONAL,
    __out_opt PUNICODE_STRING RemainingString     OPTIONAL,
    __in      DWORD           dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' for
    PUNICODE_STRINGs with some additional parameters.  In addition to the
    functionality provided by RtlUnicodeStringCatString, this routine
    also returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string which must be null terminated

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:
    
        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszSrc like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap or if
    DestinationString and RemainingString are the same pointer.

    DestinationString and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the 
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCatStringEx(
    __inout PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchNewDestLength = cchDestLength;

        status = RtlStringExValidateSrcW(&pszSrc, NULL, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining == 0)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;
                
                status = RtlWideCharArrayCopyStringWorker(pszDestEnd,
                                                          cchRemaining,
                                                          &cchCopied,
                                                          pszSrc,
                                                          NTSTRSAFE_UNICODE_STRING_MAX_CCH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;
                
                cchNewDestLength = cchDestLength + cchCopied;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               cchDestLength,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringCatEx(
    __inout   PUNICODE_STRING     DestinationString   OPTIONAL,
    __in      PCUNICODE_STRING    SourceString        OPTIONAL,
    __out_opt PUNICODE_STRING     RemainingString     OPTIONAL,
    __in      DWORD               dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' for
    PUNICODE_STRINGs with some additional parameters. In addition to the
    functionality provided by RtlUnicodeStringCat, this routine
    also returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszSrc like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap or if
    DestinationString and RemainingString are the same pointer.

    DestinationString and SourceString should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and SourceString
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was source data and it was all concatenated

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the 
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.
                       
    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCatEx(
    __inout PUNICODE_STRING DestinationString, 
    __in PCUNICODE_STRING SourceString,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        wchar_t* pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchNewDestLength = cchDestLength;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining == 0)
            {
                // only fail if there was actually src data to append
                if (cchSrcLength != 0)
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;
                
                status = RtlWideCharArrayCopyWorker(pszDestEnd,
                                                    cchRemaining,
                                                    &cchCopied,
                                                    pszSrc,
                                                    cchSrcLength);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;
                
                cchNewDestLength = cchDestLength + cchCopied;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               cchDestLength,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCchCatStringN(
    __inout  PUNICODE_STRING DestinationString,
    __in     LPCTSTR         pszSrc,
    __in     size_t          cchToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat' for
    PUNICODE_STRINGs.
    
    This function returns an NTSTATUS value, and not a pointer. It returns
    STATUS_SUCCESS if all of pszSrc or the first cchToAppend characters were
    appended to the destination string, otherwise it will return a failure
    code. In failure cases as much of pszSrc will be appended to DestinationString as
    possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string

    cchToAppend         -   maximum number of characters to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL. See RtlUnicodeStringCchCatStringNEx if
    you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if all of pszSrc or the first cchToAppend characters were
                       concatenated to DestinationString

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok
                       
    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCchCatStringN(
    __inout PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToAppend)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        if (cchToAppend > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            size_t cchCopied = 0;

            status = RtlWideCharArrayCopyStringWorker(pszDest + cchDestLength,
                                                      cchDest - cchDestLength,
                                                      &cchCopied,
                                                      pszSrc,
                                                      cchToAppend);

            // safe to multiply (cchDestLength + cchCopied) * sizeof(wchar_t) since (cchDestLength + cchCopied) < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)((cchDestLength + cchCopied) * sizeof(wchar_t));
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCbCatStringN(
    __inout   PUNICODE_STRING DestinationString,
    __in      LPCTSTR         pszSrc,
    __in      size_t          cbToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat' for
    PUNICODE_STRINGs.
    
    This function returns an NTSTATUS value, and not a pointer. It returns
    STATUS_SUCCESS if all of pszSrc or the first cbToAppend bytes were
    appended to the destination string, otherwise it will return a failure
    code. In failure cases as much of pszSrc will be appended to DestinationString as
    possible.
    
Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string

    cbToAppend          -   maximum number of bytes to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL. See RtlUnicodeStringCbCatStringNEx if
    you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if all of pszSrc or the first cbToAppend bytes were
                       concatenated to pszDest
                       
    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCbCatStringN(
    __inout PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cbToAppend)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        size_t cchToAppend = cbToAppend / sizeof(wchar_t);

        if (cchToAppend > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            size_t cchCopied = 0;

            status = RtlWideCharArrayCopyStringWorker(pszDest + cchDestLength,
                                                      cchDest - cchDestLength,
                                                      &cchCopied,
                                                      pszSrc,
                                                      cchToAppend);

            // safe to multiply (cchDestLength + cchCopied) * sizeof(wchar_t) since (cchDestLength + cchCopied) < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)((cchDestLength + cchCopied) * sizeof(wchar_t));
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCchCatN(
    __inout  PUNICODE_STRING     DestinationString,
    __in     PCUNICODE_STRING    SourceString,
    __in     size_t              cchToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat' for
    PUNICODE_STRINGs.
    
    This function returns an NTSTATUS value, and not a pointer. It returns
    STATUS_SUCCESS if all of SourceString or the first cchToAppend characters were
    appended to the destination string, otherwise it will return a failure
    code. In failure cases as much of SourceString will be appended to DestinationString as
    possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string

    cchToAppend         -   maximum number of characters to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL. See RtlUnicodeStringCchCatNEx if
    you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if all of SourceString or the first cchToAppend characters were
                       concatenated to DestinationString

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCchCatN(
    __inout PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in size_t cchToAppend)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            if (cchToAppend > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                size_t cchCopied = 0;

                if (cchSrcLength < cchToAppend)
                {
                    cchToAppend = cchSrcLength;
                }

                status = RtlWideCharArrayCopyWorker(pszDest + cchDestLength,
                                                    cchDest - cchDestLength,
                                                    &cchCopied,
                                                    pszSrc,
                                                    cchToAppend);

                // safe to multiply (cchDestLength + cchCopied) * sizeof(wchar_t) since (cchDestLength + cchCopied) < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                DestinationString->Length = (USHORT)((cchDestLength + cchCopied) * sizeof(wchar_t));
            }
        }
    }

    return status;
}
#endif // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCbCatN(
    __inout PUNICODE_STRING     DestinationString,
    __in    PCUNICODE_STRING    SourceString,
    __in    size_t              cbToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat' for
    PUNICODE_STRINGs.
    
    This function returns an NTSTATUS value, and not a pointer. It returns
    STATUS_SUCCESS if all of SourceString or the first cbToAppend bytes were
    appended to the destination string, otherwise it will return a failure
    code. In failure cases as much of SourceString will be appended to DestinationString as
    possible.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string

    cbToAppend          -   maximum number of bytes to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL. See RtlUnicodeStringCbCatNEx if
    you require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if all of SourceString or the first cbToAppend bytes were
                       concatenated to pszDest

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok
                       
    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCbCatN(
    __inout PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in size_t cbToAppend)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   0);

        if (NT_SUCCESS(status))
        {
            size_t cchToAppend = cbToAppend / sizeof(wchar_t);

            if (cchToAppend > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                size_t cchCopied = 0;

                if (cchSrcLength < cchToAppend)
                {
                    cchToAppend = cchSrcLength;
                }

                status = RtlWideCharArrayCopyWorker(pszDest + cchDestLength,
                                                    cchDest - cchDestLength,
                                                    &cchCopied,
                                                    pszSrc,
                                                    cchToAppend);

                // safe to multiply (cchDestLength + cchCopied) * sizeof(wchar_t) since (cchDestLength + cchCopied) < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                DestinationString->Length = (USHORT)((cchDestLength + cchCopied) * sizeof(wchar_t));
            }
        }
    }

    return status;
}
#endif // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCchCatStringNEx(
    __inout PUNICODE_STRING DestinationString   OPTIONAL,
    __in    LPCTSTR         pszSrc              OPTIONAL,
    __in    size_t          cchToAppend,
    __out_opt PUNICODE_STRING RemainingString     OPTIONAL,
    __in    DWORD           dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters and for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringCchCatStringN, this routine
    also returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string

    cchToAppend         -   maximum number of characters to append

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszSrc like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

        STRSAFE_NO_TRUNCATION
                    if th