uArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellDispatch2_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define IShellDispatch2_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define IShellDispatch2_NameSpace(This,vDir,ppsdf)	\
    (This)->lpVtbl -> NameSpace(This,vDir,ppsdf)

#define IShellDispatch2_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)

#define IShellDispatch2_Windows(This,ppid)	\
    (This)->lpVtbl -> Windows(This,ppid)

#define IShellDispatch2_Open(This,vDir)	\
    (This)->lpVtbl -> Open(This,vDir)

#define IShellDispatch2_Explore(This,vDir)	\
    (This)->lpVtbl -> Explore(This,vDir)

#define IShellDispatch2_MinimizeAll(This)	\
    (This)->lpVtbl -> MinimizeAll(This)

#define IShellDispatch2_UndoMinimizeALL(This)	\
    (This)->lpVtbl -> UndoMinimizeALL(This)

#define IShellDispatch2_FileRun(This)	\
    (This)->lpVtbl -> FileRun(This)

#define IShellDispatch2_CascadeWindows(This)	\
    (This)->lpVtbl -> CascadeWindows(This)

#define IShellDispatch2_TileVertically(This)	\
    (This)->lpVtbl -> TileVertically(This)

#define IShellDispatch2_TileHorizontally(This)	\
    (This)->lpVtbl -> TileHorizontally(This)

#define IShellDispatch2_ShutdownWindows(This)	\
    (This)->lpVtbl -> ShutdownWindows(This)

#define IShellDispatch2_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IShellDispatch2_EjectPC(This)	\
    (This)->lpVtbl -> EjectPC(This)

#define IShellDispatch2_SetTime(This)	\
    (This)->lpVtbl -> SetTime(This)

#define IShellDispatch2_TrayProperties(This)	\
    (This)->lpVtbl -> TrayProperties(This)

#define IShellDispatch2_Help(This)	\
    (This)->lpVtbl -> Help(This)

#define IShellDispatch2_FindFiles(This)	\
    (This)->lpVtbl -> FindFiles(This)

#define IShellDispatch2_FindComputer(This)	\
    (This)->lpVtbl -> FindComputer(This)

#define IShellDispatch2_RefreshMenu(This)	\
    (This)->lpVtbl -> RefreshMenu(This)

#define IShellDispatch2_ControlPanelItem(This,szDir)	\
    (This)->lpVtbl -> ControlPanelItem(This,szDir)


#define IShellDispatch2_IsRestricted(This,Group,Restriction,plRestrictValue)	\
    (This)->lpVtbl -> IsRestricted(This,Group,Restriction,plRestrictValue)

#define IShellDispatch2_ShellExecute(This,File,vArgs,vDir,vOperation,vShow)	\
    (This)->lpVtbl -> ShellExecute(This,File,vArgs,vDir,vOperation,vShow)

#define IShellDispatch2_FindPrinter(This,name,location,model)	\
    (This)->lpVtbl -> FindPrinter(This,name,location,model)

#define IShellDispatch2_GetSystemInformation(This,name,pv)	\
    (This)->lpVtbl -> GetSystemInformation(This,name,pv)

#define IShellDispatch2_ServiceStart(This,ServiceName,Persistent,pSuccess)	\
    (This)->lpVtbl -> ServiceStart(This,ServiceName,Persistent,pSuccess)

#define IShellDispatch2_ServiceStop(This,ServiceName,Persistent,pSuccess)	\
    (This)->lpVtbl -> ServiceStop(This,ServiceName,Persistent,pSuccess)

#define IShellDispatch2_IsServiceRunning(This,ServiceName,pRunning)	\
    (This)->lpVtbl -> IsServiceRunning(This,ServiceName,pRunning)

#define IShellDispatch2_CanStartStopService(This,ServiceName,pCanStartStop)	\
    (This)->lpVtbl -> CanStartStopService(This,ServiceName,pCanStartStop)

#define IShellDispatch2_ShowBrowserBar(This,bstrClsid,bShow,pSuccess)	\
    (This)->lpVtbl -> ShowBrowserBar(This,bstrClsid,bShow,pSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_IsRestricted_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR Group,
    /* [in] */ BSTR Restriction,
    /* [retval][out] */ long __RPC_FAR *plRestrictValue);


void __RPC_STUB IShellDispatch2_IsRestricted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_ShellExecute_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR File,
    /* [optional][in] */ VARIANT vArgs,
    /* [optional][in] */ VARIANT vDir,
    /* [optional][in] */ VARIANT vOperation,
    /* [optional][in] */ VARIANT vShow);


void __RPC_STUB IShellDispatch2_ShellExecute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_FindPrinter_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [optional][in] */ BSTR name,
    /* [optional][in] */ BSTR location,
    /* [optional][in] */ BSTR model);


void __RPC_STUB IShellDispatch2_FindPrinter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_GetSystemInformation_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *pv);


void __RPC_STUB IShellDispatch2_GetSystemInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_ServiceStart_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR ServiceName,
    /* [in] */ VARIANT Persistent,
    /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);


void __RPC_STUB IShellDispatch2_ServiceStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_ServiceStop_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR ServiceName,
    /* [in] */ VARIANT Persistent,
    /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);


void __RPC_STUB IShellDispatch2_ServiceStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_IsServiceRunning_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR ServiceName,
    /* [retval][out] */ VARIANT __RPC_FAR *pRunning);


void __RPC_STUB IShellDispatch2_IsServiceRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_CanStartStopService_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR ServiceName,
    /* [retval][out] */ VARIANT __RPC_FAR *pCanStartStop);


void __RPC_STUB IShellDispatch2_CanStartStopService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_ShowBrowserBar_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR bstrClsid,
    /* [in] */ VARIANT bShow,
    /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);


void __RPC_STUB IShellDispatch2_ShowBrowserBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellDispatch2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Shell;

#ifdef __cplusplus

class DECLSPEC_UUID("13709620-C279-11CE-A49E-444553540000")
Shell;
#endif

EXTERN_C const CLSID CLSID_ShellDispatchInproc;

#ifdef __cplusplus

class DECLSPEC_UUID("0A89A860-D7B1-11CE-8350-444553540000")
ShellDispatchInproc;
#endif

EXTERN_C const CLSID CLSID_WebViewFolderContents;

#ifdef __cplusplus

class DECLSPEC_UUID("1820FED0-473E-11D0-A96C-00C04FD705A2")
WebViewFolderContents;
#endif

#ifndef __DSearchCommandEvents_DISPINTERFACE_DEFINED__
#define __DSearchCommandEvents_DISPINTERFACE_DEFINED__

/* dispinterface DSearchCommandEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_DSearchCommandEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("60890160-69f0-11d1-b758-00a0c90564fe")
    DSearchCommandEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DSearchCommandEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DSearchCommandEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DSearchCommandEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DSearchCommandEventsVtbl;

    interface DSearchCommandEvents
    {
        CONST_VTBL struct DSearchCommandEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DSearchCommandEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DSearchCommandEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DSearchCommandEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DSearchCommandEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DSearchCommandEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DSearchCommandEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DSearchCommandEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DSearchCommandEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SearchCommand;

#ifdef __cplusplus

class DECLSPEC_UUID("B005E690-678D-11d1-B758-00A0C90564FE")
SearchCommand;
#endif

#ifndef __IFileSearchBand_INTERFACE_DEFINED__
#define __IFileSearchBand_INTERFACE_DEFINED__

/* interface IFileSearchBand */
/* [object][unique][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IFileSearchBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2D91EEA1-9932-11d2-BE86-00A0C9A83DA1")
    IFileSearchBand : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSearchParameters( 
            /* [in] */ BSTR __RPC_FAR *pbstrSearchID,
            /* [in] */ VARIANT_BOOL bNavToResults,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarScope,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarQueryFile) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SearchID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchID) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarScope) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_QueryFile( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSearchBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFileSearchBand __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFileSearchBand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFileSearchBand __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFocus )( 
            IFileSearchBand __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSearchParameters )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *pbstrSearchID,
            /* [in] */ VARIANT_BOOL bNavToResults,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarScope,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarQueryFile);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchID )( 
            IFileSearchBand __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchID);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Scope )( 
            IFileSearchBand __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarScope);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryFile )( 
            IFileSearchBand __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarFile);
        
        END_INTERFACE
    } IFileSearchBandVtbl;

    interface IFileSearchBand
    {
        CONST_VTBL struct IFileSearchBandVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSearchBand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFileSearchBand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFileSearchBand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFileSearchBand_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFileSearchBand_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFileSearchBand_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFileSearchBand_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFileSearchBand_SetFocus(This)	\
    (This)->lpVtbl -> SetFocus(This)

#define IFileSearchBand_SetSearchParameters(This,pbstrSearchID,bNavToResults,pvarScope,pvarQueryFile)	\
    (This)->lpVtbl -> SetSearchParameters(This,pbstrSearchID,bNavToResults,pvarScope,pvarQueryFile)

#define IFileSearchBand_get_SearchID(This,pbstrSearchID)	\
    (This)->lpVtbl -> get_SearchID(This,pbstrSearchID)

#define IFileSearchBand_get_Scope(This,pvarScope)	\
    (This)->lpVtbl -> get_Scope(This,pvarScope)

#define IFileSearchBand_get_QueryFile(This,pvarFile)	\
    (This)->lpVtbl -> get_QueryFile(This,pvarFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_SetFocus_Proxy( 
    IFileSearchBand __RPC_FAR * This);


void __RPC_STUB IFileSearchBand_SetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_SetSearchParameters_Proxy( 
    IFileSearchBand __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *pbstrSearchID,
    /* [in] */ VARIANT_BOOL bNavToResults,
    /* [optional][in] */ VARIANT __RPC_FAR *pvarScope,
    /* [optional][in] */ VARIANT __RPC_FAR *pvarQueryFile);


void __RPC_STUB IFileSearchBand_SetSearchParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_get_SearchID_Proxy( 
    IFileSearchBand __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchID);


void __RPC_STUB IFileSearchBand_get_SearchID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_get_Scope_Proxy( 
    IFileSearchBand __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarScope);


void __RPC_STUB IFileSearchBand_get_Scope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_get_QueryFile_Proxy( 
    IFileSearchBand __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarFile);


void __RPC_STUB IFileSearchBand_get_QueryFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFileSearchBand_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_FileSearchBand;

#ifdef __cplusplus

class DECLSPEC_UUID("C4EE31F3-4768-11D2-BE5C-00A0C9A83DA1")
FileSearchBand;
#endif
#endif /* __Shell32_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shldispp_0261 */
/* [local] */ 


//-------------------------------------------------------------------------
//
// IAutoComplete interface
//
//
// [Member functions]
//
// IAutoComplete::Init(hwndEdit, punkACL, pwszRegKeyPath, pwszQuickComplete)
//   This function initializes an AutoComplete object, telling it
//   what control to subclass, and what list of strings to process.
//
// IAutoComplete::Enable(fEnable)
//   This function enables or disables the AutoComplete functionality.
//
//-------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_shldispp_0261_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0261_v0_0_s_ifspec;

#ifndef __IAutoComplete_INTERFACE_DEFINED__
#define __IAutoComplete_INTERFACE_DEFINED__

/* interface IAutoComplete */
/* [unique][uuid][object][local][helpstring] */ 

typedef /* [unique] */ IAutoComplete __RPC_FAR *LPAUTOCOMPLETE;


EXTERN_C const IID IID_IAutoComplete;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00bb2762-6a77-11d0-a535-00c04fd7d062")
    IAutoComplete : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ HWND hwndEdit,
            /* [unique][in] */ IUnknown __RPC_FAR *punkACL,
            /* [unique][in] */ LPCOLESTR pwszRegKeyPath,
            /* [in] */ LPCOLESTR pwszQuickComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoCompleteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAutoComplete __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAutoComplete __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAutoComplete __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IAutoComplete __RPC_FAR * This,
            /* [in] */ HWND hwndEdit,
            /* [unique][in] */ IUnknown __RPC_FAR *punkACL,
            /* [unique][in] */ LPCOLESTR pwszRegKeyPath,
            /* [in] */ LPCOLESTR pwszQuickComplete);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enable )( 
            IAutoComplete __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IAutoCompleteVtbl;

    interface IAutoComplete
    {
        CONST_VTBL struct IAutoCompleteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoComplete_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAutoComplete_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAutoComplete_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAutoComplete_Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)	\
    (This)->lpVtbl -> Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)

#define IAutoComplete_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAutoComplete_Init_Proxy( 
    IAutoComplete __RPC_FAR * This,
    /* [in] */ HWND hwndEdit,
    /* [unique][in] */ IUnknown __RPC_FAR *punkACL,
    /* [unique][in] */ LPCOLESTR pwszRegKeyPath,
    /* [in] */ LPCOLESTR pwszQuickComplete);


void __RPC_STUB IAutoComplete_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoComplete_Enable_Proxy( 
    IAutoComplete __RPC_FAR * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IAutoComplete_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAutoComplete_INTERFACE_DEFINED__ */


#ifndef __IAutoComplete2_INTERFACE_DEFINED__
#define __IAutoComplete2_INTERFACE_DEFINED__

/* interface IAutoComplete2 */
/* [unique][uuid][object][local][helpstring] */ 

typedef /* [unique] */ IAutoComplete2 __RPC_FAR *LPAUTOCOMPLETE2;

typedef 
enum _tagAUTOCOMPLETEOPTIONS
    {	ACO_NONE	= 0,
	ACO_AUTOSUGGEST	= 0x1,
	ACO_AUTOAPPEND	= 0x2,
	ACO_SEARCH	= 0x4,
	ACO_FILTERPREFIXES	= 0x8,
	ACO_USETAB	= 0x10,
	ACO_UPDOWNKEYDROPSLIST	= 0x20,
	ACO_RTLREADING	= 0x40
    }	AUTOCOMPLETEOPTIONS;


EXTERN_C const IID IID_IAutoComplete2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAC04BC0-3791-11d2-BB95-0060977B464C")
    IAutoComplete2 : public IAutoComplete
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ DWORD dwFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out] */ DWORD __RPC_FAR *pdwFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoComplete2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAutoComplete2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAutoComplete2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [in] */ HWND hwndEdit,
            /* [unique][in] */ IUnknown __RPC_FAR *punkACL,
            /* [unique][in] */ LPCOLESTR pwszRegKeyPath,
            /* [in] */ LPCOLESTR pwszQuickComplete);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enable )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOptions )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptions )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlag);
        
        END_INTERFACE
    } IAutoComplete2Vtbl;

    interface IAutoComplete2
    {
        CONST_VTBL struct IAutoComplete2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoComplete2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAutoComplete2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAutoComplete2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAutoComplete2_Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)	\
    (This)->lpVtbl -> Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)

#define IAutoComplete2_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)


#define IAutoComplete2_SetOptions(This,dwFlag)	\
    (This)->lpVtbl -> SetOptions(This,dwFlag)

#define IAutoComplete2_GetOptions(This,pdwFlag)	\
    (This)->lpVtbl -> GetOptions(This,pdwFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAutoComplete2_SetOptions_Proxy( 
    IAutoComplete2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlag);


void __RPC_STUB IAutoComplete2_SetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoComplete2_GetOptions_Proxy( 
    IAutoComplete2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlag);


void __RPC_STUB IAutoComplete2_GetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAutoComplete2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shldispp_0263 */
/* [local] */ 

// INTERFACE: IAsyncOperation
//
// This interface was implemented to turn some previously synchronous
// interfaces into async.  The following example is for
// doing the IDataObject::Drop() operation asynchronously.
//
// Sometimes the rendering of the IDataObject data (IDataObject::GetData() or
// STGMEDIUM.pStream->Read()) can be time intensive.  The IDropTarget
// may want to do this on another thread.
//
// Implimentation Check list:
// DoDragDrop Caller:
//    If this code can support asynch operations, then it needs to
//    QueryInterface() the IDataObject for IAsyncOperation.
//    IAsyncOperation::SetAsyncMode(VARIANT_TRUE).
//    After calling DoDragDrop(), call InOperation().  If any call fails
//    or InOperation() return FALSE, use the pdwEffect returned by DoDragDrop()
//    and the operation completed synchrously.
//
// OleSetClipboard Caller:
//    If this code can support asynch operations, then it needs to
//    QueryInterface() the IDataObject for IAsyncOperation.  Then call
//    IAsyncOperation::SetAsyncMode(VARIANT_TRUE).
//    If any of that fails, the final dwEffect should be passed to the IDataObject via
//    CFSTR_PERFORMEDDROPEFFECT.
//
// IDataObect Object:
//    IAsyncOperation::GetAsyncMode() should return whatever was last passed in
//          fDoOpAsync to ::SetAsyncMode() or VARIANT_FALSE if ::SetAsyncMode()
//          was never called.
//    IAsyncOperation::SetAsyncMode() should AddRef and store paocb.
//    IAsyncOperation::StartOperation() should store the fact that this was called and
//          cause InOperation() to return VARIANT_TRUE.  pbcReserved is not used and needs
//          to be NULL.
//    IAsyncOperation::InOperation() should return VARIANT_TRUE only if ::StartOperation()
//          was called.
//    IAsyncOperation::EndOperation() needs to call paocbpaocb->EndOperation() with the same
//          parameters.  Then release paocb.
//    IDataObject::SetData(CFSTR_PERFORMEDDROPEFFECT) When this happens, call
//          EndOperation(<into VAR>S_OK, NULL, <into VAR>dwEffect) and pass the dwEffect from the hglobal.
//
// IDropTarget Object:
//    IDropTarget::Drop() If asynch operations aren't supported, nothing is required.
//          The asynch operation can only happen if GetAsyncMode() returns VARIANT_TRUE.
//          Before starting the asynch operation, StartOperation(NULL) needs to be called before
//          returning from IDropTarget::Drop().



extern RPC_IF_HANDLE __MIDL_itf_shldispp_0263_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0263_v0_0_s_ifspec;

#ifndef __IAsyncOperation_INTERFACE_DEFINED__
#define __IAsyncOperation_INTERFACE_DEFINED__

/* interface IAsyncOperation */
/* [object][uuid][helpstring] */ 

typedef /* [unique] */ IAsyncOperation __RPC_FAR *LPASYNCOPERATION;


EXTERN_C const IID IID_IAsyncOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D8B0590-F691-11d2-8EA9-006097DF5BD4")
    IAsyncOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAsyncMode( 
            /* [in] */ BOOL fDoOpAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMode( 
            /* [out] */ BOOL __RPC_FAR *pfIsOpAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartOperation( 
            /* [optional][unique][in] */ IBindCtx __RPC_FAR *pbcReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InOperation( 
            /* [out] */ BOOL __RPC_FAR *pfInAsyncOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOperation( 
            /* [in] */ HRESULT hResult,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbcReserved,
            /* [in] */ DWORD dwEffects) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAsyncOperation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAsyncOperation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAsyncOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAsyncMode )( 
            IAsyncOperation __RPC_FAR * This,
            /* [in] */ BOOL fDoOpAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAsyncMode )( 
            IAsyncOperation __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsOpAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOperation )( 
            IAsyncOperation __RPC_FAR * This,
            /* [optional][unique][in] */ IBindCtx __RPC_FAR *pbcReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InOperation )( 
            IAsyncOperation __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfInAsyncOp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOperation )( 
            IAsyncOperation __RPC_FAR * This,
            /* [in] */ HRESULT hResult,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbcReserved,
            /* [in] */ DWORD dwEffects);
        
        END_INTERFACE
    } IAsyncOperationVtbl;

    interface IAsyncOperation
    {
        CONST_VTBL struct IAsyncOperationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncOperation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAsyncOperation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAsyncOperation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAsyncOperation_SetAsyncMode(This,fDoOpAsync)	\
    (This)->lpVtbl -> SetAsyncMode(This,fDoOpAsync)

#define IAsyncOperation_GetAsyncMode(This,pfIsOpAsync)	\
    (This)->lpVtbl -> GetAsyncMode(This,pfIsOpAsync)

#define IAsyncOperation_StartOperation(This,pbcReserved)	\
    (This)->lpVtbl -> StartOperation(This,pbcReserved)

#define IAsyncOperation_InOperation(This,pfInAsyncOp)	\
    (This)->lpVtbl -> InOperation(This,pfInAsyncOp)

#define IAsyncOperation_EndOperation(This,hResult,pbcReserved,dwEffects)	\
    (This)->lpVtbl -> EndOperation(This,hResult,pbcReserved,dwEffects)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAsyncOperation_SetAsyncMode_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [in] */ BOOL fDoOpAsync);


void __RPC_STUB IAsyncOperation_SetAsyncMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncOperation_GetAsyncMode_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsOpAsync);


void __RPC_STUB IAsyncOperation_GetAsyncMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncOperation_StartOperation_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [optional][unique][in] */ IBindCtx __RPC_FAR *pbcReserved);


void __RPC_STUB IAsyncOperation_StartOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncOperation_InOperation_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfInAsyncOp);


void __RPC_STUB IAsyncOperation_InOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncOperation_EndOperation_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [in] */ HRESULT hResult,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbcReserved,
    /* [in] */ DWORD dwEffects);


void __RPC_STUB IAsyncOperation_EndOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAsyncOperation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shldispp_0264 */
/* [local] */ 

#endif // _SHLDISP_PUB_H_
#ifndef _SHLDISP_PRIV_H_
#define _SHLDISP_PRIV_H_
// INTERFACE: IBrowserFrameOptions
//
// This interface was implemented so a browser or host can ask a ShellView/ShelNameSpace what
// kind of 'Behavior' is appropriate for that view.  These are normally PM type decisions to
// refine the user experience.
// 
// For example, should the IE globe be added to the toolbar
// when the view is a HTTP web page? (Yes)  When the view is a FTP Folders?  When the view
// is the file system? (No) When the view is Web Folders? (Maybe, did you as a PM?)
// It's very important for the view to ask the NSE if it does or doesn't want the behavior instead of
// trying to sniff the pidl and guess.  An example of this kind of bad coding style is all the
// code that calls IsURLChild().  Currently we have a lot of hacky code that says turn such-and-such
// behavior on for HTTP and FTP URLs but not Web Folders and not ABOUT URLs, so it's very important to
// use this interface to do the work for you.  This will also allow Web Folders to fix a lot of bugs because
// the code hasn't yet been 'tweaked' to give the behavior Web Folders wants.
//
//    IBrowserFrameOptions::GetBrowserOptions()
//       dwMask is the logical OR of bits to look for.  pdwOptions is not optional and
//       it's return value will always equal or will be a subset of dwMask.
//       If the function succeeds, the return value must be S_OK and pdwOptions needs to be filled in.
//       If the function fails, pdwOptions needs to be filled in with BFO_NONE.
//
// NOTE: The definition of the bit needs to be OFF for the most common NSE.  This way shell name space
//       extensions that don't implement this interface or haven't been updated to handle this bit will
//       default to behavior that is the most common.  An example of this is the BFO_NO_FOLDER_OPTIONS
//       where this bit off will give the 'Folder Options', which is the most common case.  This is especially
//       true since this interface is internal only.



extern RPC_IF_HANDLE __MIDL_itf_shldispp_0264_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0264_v0_0_s_ifspec;

#ifndef __IBrowserFrameOptions_INTERFACE_DEFINED__
#define __IBrowserFrameOptions_INTERFACE_DEFINED__

/* interface IBrowserFrameOptions */
/* [object][uuid][helpstring] */ 

typedef /* [unique] */ IBrowserFrameOptions __RPC_FAR *LPBROWSERFRAMEOPTIONS;


enum __MIDL_IBrowserFrameOptions_0001
    {	BFO_NONE	= 0,
	BFO_BROWSER_PERSIST_SETTINGS	= 0x1,
	BFO_RENAME_FOLDER_OPTIONS_TOINTERNET	= 0x2,
	BFO_BOTH_OPTIONS	= 0x4,
	BIF_PREFER_INTERNET_SHORTCUT	= 0x8,
	BFO_BROWSE_NO_IN_NEW_PROCESS	= 0x10,
	BFO_ENABLE_HYPERLINK_TRACKING	= 0x20,
	BFO_USE_IE_OFFLINE_SUPPORT	= 0x40,
	BFO_SUBSTITUE_INTERNET_START_PAGE	= 0x80,
	BFO_USE_IE_LOGOBANDING	= 0x100,
	BFO_ADD_IE_TOCAPTIONBAR	= 0x200,
	BFO_USE_DIALUP_REF	= 0x400,
	BFO_USE_IE_TOOLBAR	= 0x800,
	BFO_NO_PARENT_FOLDER_SUPPORT	= 0x1000,
	BFO_NO_REOPEN_NEXT_RESTART	= 0x2000,
	BFO_GO_HOME_PAGE	= 0x4000,
	BFO_PREFER_IEPROCESS	= 0x8000,
	BFO_QUERY_ALL	= 0xffffffff
    };
typedef DWORD BROWSERFRAMEOPTIONS;


EXTERN_C const IID IID_IBrowserFrameOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10DF43C8-1DBE-11d3-8B34-006097DF5BD4")
    IBrowserFrameOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [in] */ BROWSERFRAMEOPTIONS dwMask,
            /* [out] */ BROWSERFRAMEOPTIONS __RPC_FAR *pdwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBrowserFrameOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBrowserFrameOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBrowserFrameOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBrowserFrameOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameOptions )( 
            IBrowserFrameOptions __RPC_FAR * This,
            /* [in] */ BROWSERFRAMEOPTIONS dwMask,
            /* [out] */ BROWSERFRAMEOPTIONS __RPC_FAR *pdwOptions);
        
        END_INTERFACE
    } IBrowserFrameOptionsVtbl;

    interface IBrowserFrameOptions
    {
        CONST_VTBL struct IBrowserFrameOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBrowserFrameOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBrowserFrameOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBrowserFrameOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBrowserFrameOptions_GetFrameOptions(This,dwMask,pdwOptions)	\
    (This)->lpVtbl -> GetFrameOptions(This,dwMask,pdwOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBrowserFrameOptions_GetFrameOptions_Proxy( 
    IBrowserFrameOptions __RPC_FAR * This,
    /* [in] */ BROWSERFRAMEOPTIONS dwMask,
    /* [out] */ BROWSERFRAMEOPTIONS __RPC_FAR *pdwOptions);


void __RPC_STUB IBrowserFrameOptions_GetFrameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBrowserFrameOptions_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shldispp_0265 */
/* [local] */ 

#endif // _SHLDISP_PRIV_H_


extern RPC_IF_HANDLE __MIDL_itf_shldispp_0265_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0265_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\sdkp\inc\shlobj.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation 1991-1998
//
// File: shlobj.h
//
//===========================================================================

#ifndef _SHLOBJ_H_
#define _SHLOBJ_H_

#ifndef _WINRESRC_
#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif
#endif

#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if defined(_SHELL32_)
#define WINSHELLAPI
#else
#define WINSHELLAPI       DECLSPEC_IMPORT
#endif
#endif // WINSHELLAPI

#ifndef SHSTDAPI
#if defined(_SHELL32_)
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#else
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDAPI

#ifndef SHDOCAPI
#if defined(_SHDOCVW_)
#define SHDOCAPI          STDAPI
#define SHDOCAPI_(type)   STDAPI_(type)
#else
#define SHDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHDOCAPI

// shell32 APIs that are also exported from shdocvw
#ifndef SHSTDDOCAPI
#if defined(_SHDOCVW_) || defined(_SHELL32_)
#define SHSTDDOCAPI          STDAPI
#define SHSTDDOCAPI_(type)   STDAPI_(type)
#else
#define SHSTDDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDDOCAPI

#ifndef BROWSEUIAPI
#if defined(_BROWSEUI_)
#define BROWSEUIAPI           STDAPI
#define BROWSEUIAPI_(type)    STDAPI_(type)
#else
#define BROWSEUIAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define BROWSEUIAPI_(type)    EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif // defined(_BROWSEUI_)
#endif // BROWSEUIAPI

// shell32 APIs that are also exported from shfolder
#ifndef SHFOLDERAPI
#if defined(_SHFOLDER_) || defined(_SHELL32_)
#define SHFOLDERAPI           STDAPI
#else
#define SHFOLDERAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#endif
#endif



#include <ole2.h>
#ifndef _PRSHT_H_
#include <prsht.h>
#endif
#ifndef _INC_COMMCTRL
#include <commctrl.h>   // for LPTBBUTTON
#endif

#ifndef INITGUID
#include <shlguid.h>
#endif /* !INITGUID */


#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#include <shtypes.h>


#include <shobjidl.h>


//===========================================================================
//
// Task allocator API
//
//  All the shell extensions MUST use the task allocator (see OLE 2.0
// programming guild for its definition) when they allocate or free
// memory objects (mostly ITEMIDLIST) that are returned across any
// shell interfaces. There are two ways to access the task allocator
// from a shell extension depending on whether or not it is linked with
// OLE32.DLL or not (purely for efficiency).
//
// (1) A shell extension which calls any OLE API (i.e., linked with
//  OLE32.DLL) should call OLE's task allocator (by retrieving
//  the task allocator by calling CoGetMalloc API).
//
// (2) A shell extension which does not call any OLE API (i.e., not linked
//  with OLE32.DLL) should call the shell task allocator API (defined
//  below), so that the shell can quickly loads it when OLE32.DLL is not
//  loaded by any application at that point.
//
// Notes:
//  In next version of Windowso release, SHGetMalloc will be replaced by
// the following macro.
//
// #define SHGetMalloc(ppmem)   CoGetMalloc(MEMCTX_TASK, ppmem)
//
//===========================================================================

SHSTDAPI SHGetMalloc(LPMALLOC * ppMalloc);


//===========================================================================
//
// IContextMenu interface
//
// [OverView]
//
//  The shell uses the IContextMenu interface in following three cases.
//
// case-1: The shell is loading context menu extensions.
//
//   When the user clicks the right mouse button on an item within the shell's
//  name space (i.g., file, directory, server, work-group, etc.), it creates
//  the default context menu for its type, then loads context menu extensions
//  that are registered for that type (and its base type) so that they can
//  add extra menu items. Those context menu extensions are registered at
//  HKCR\{ProgID}\shellex\ContextMenuHandlers.
//
// case-2: The shell is retrieving a context menu of sub-folders in extended
//   name-space.
//
//   When the explorer's name space is extended by name space extensions,
//  the shell calls their IShellFolder::GetUIObjectOf to get the IContextMenu
//  objects when it creates context menus for folders under those extended
//  name spaces.
//
// case-3: The shell is loading non-default drag and drop handler for directories.
//
//   When the user performed a non-default drag and drop onto one of file
//  system folders (i.e., directories), it loads shell extensions that are
//  registered at HKCR\{ProgID}\DragDropHandlers.
//
//
// [Member functions]
//
//
// IContextMenu::QueryContextMenu
//
//   This member function may insert one or more menuitems to the specified
//  menu (hmenu) at the specified location (indexMenu which is never be -1).
//  The IDs of those menuitem must be in the specified range (idCmdFirst and
//  idCmdLast). It returns the maximum menuitem ID offset (ushort) in the
//  'code' field (low word) of the scode.
//
//   The uFlags specify the context. It may have one or more of following
//  flags.
//
//  CMF_DEFAULTONLY: This flag is passed if the user is invoking the default
//   action (typically by double-clicking, case 1 and 2 only). Context menu
//   extensions (case 1) should not add any menu items, and returns NOERROR.
//
//  CMF_VERBSONLY: The explorer passes this flag if it is constructing
//   a context menu for a short-cut object (case 1 and case 2 only). If this
//   flag is passed, it should not add any menu-items that is not appropriate
//   from a short-cut.
//    A good example is the "Delete" menuitem, which confuses the user
//   because it is not clear whether it deletes the link source item or the
//   link itself.
//
//  CMF_EXPLORER: The explorer passes this flag if it has the left-side pane
//   (case 1 and 2 only). Context menu extensions should ignore this flag.
//
//   High word (16-bit) are reserved for context specific communications
//  and the rest of flags (13-bit) are reserved by the system.
//
//
// IContextMenu::InvokeCommand
//
//   This member is called when the user has selected one of menuitems that
//  are inserted by previous QueryContextMenu member. In this case, the
//  LOWORD(lpici->lpVerb) contains the menuitem ID offset (menuitem ID -
//  idCmdFirst).
//
//   This member function may also be called programmatically. In such a case,
//  lpici->lpVerb specifies the canonical name of the command to be invoked,
//  which is typically retrieved by GetCommandString member previously.
//
//  Parameters in lpci:
//    cbSize -- Specifies the size of this structure (sizeof(*lpci))
//    hwnd   -- Specifies the owner window for any message/dialog box.
//    fMask  -- Specifies whether or not dwHotkey/hIcon paramter is valid.
//    lpVerb -- Specifies the command to be invoked.
//    lpParameters -- Parameters (optional)
//    lpDirectory  -- Working directory (optional)
//    nShow -- Specifies the flag to be passed to ShowWindow (SW_*).
//    dwHotKey -- Hot key to be assigned to the app after invoked (optional).
//    hIcon -- Specifies the icon (optional).
//    hMonitor -- Specifies the default monitor (optional).
//
//
// IContextMenu::GetCommandString
//
//   This member function is called by the explorer either to get the
//  canonical (language independent) command name (uFlags == GCS_VERB) or
//  the help text ((uFlags & GCS_HELPTEXT) != 0) for the specified command.
//  The retrieved canonical string may be passed to its InvokeCommand
//  member function to invoke a command programmatically. The explorer
//  displays the help texts in its status bar; therefore, the length of
//  the help text should be reasonably short (<40 characters).
//
//  Parameters:
//   idCmd -- Specifies menuitem ID offset (from idCmdFirst)
//   uFlags -- Either GCS_VERB or GCS_HELPTEXT
//   pwReserved -- Reserved (must pass NULL when calling, must ignore when called)
//   pszName -- Specifies the string buffer.
//   cchMax -- Specifies the size of the string buffer.
//
//===========================================================================

// QueryContextMenu uFlags
#define CMF_NORMAL              0x00000000
#define CMF_DEFAULTONLY         0x00000001
#define CMF_VERBSONLY           0x00000002
#define CMF_EXPLORE             0x00000004
#define CMF_NOVERBS             0x00000008
#define CMF_CANRENAME           0x00000010
#define CMF_NODEFAULT           0x00000020
#define CMF_INCLUDESTATIC       0x00000040
#define CMF_FINDHACK            0x00000080
#define CMF_EXTENDEDVERBS       0x00000100      // rarely used verbs
#define CMF_RESERVED            0xffff0000      // View specific


// GetCommandString uFlags
#define GCS_VERBA        0x00000000     // canonical verb
#define GCS_HELPTEXTA    0x00000001     // help text (for status bar)
#define GCS_VALIDATEA    0x00000002     // validate command exists
#define GCS_VERBW        0x00000004     // canonical verb (unicode)
#define GCS_HELPTEXTW    0x00000005     // help text (unicode version)
#define GCS_VALIDATEW    0x00000006     // validate command exists (unicode)
#define GCS_UNICODE      0x00000004     // for bit testing - Unicode string

#ifdef UNICODE
#define GCS_VERB        GCS_VERBW
#define GCS_HELPTEXT    GCS_HELPTEXTW
#define GCS_VALIDATE    GCS_VALIDATEW
#else
#define GCS_VERB        GCS_VERBA
#define GCS_HELPTEXT    GCS_HELPTEXTA
#define GCS_VALIDATE    GCS_VALIDATEA
#endif

#define CMDSTR_NEWFOLDERA   "NewFolder"
#define CMDSTR_VIEWLISTA    "ViewList"
#define CMDSTR_VIEWDETAILSA "ViewDetails"
#define CMDSTR_NEWFOLDERW   L"NewFolder"
#define CMDSTR_VIEWLISTW    L"ViewList"
#define CMDSTR_VIEWDETAILSW L"ViewDetails"

#ifdef UNICODE
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERW
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTW
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSW
#else
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERA
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTA
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSA
#endif

#define CMIC_MASK_HOTKEY        SEE_MASK_HOTKEY
#define CMIC_MASK_ICON          SEE_MASK_ICON
#define CMIC_MASK_FLAG_NO_UI    SEE_MASK_FLAG_NO_UI
#define CMIC_MASK_UNICODE       SEE_MASK_UNICODE
#define CMIC_MASK_NO_CONSOLE    SEE_MASK_NO_CONSOLE
#define CMIC_MASK_HASLINKNAME   SEE_MASK_HASLINKNAME
#define CMIC_MASK_FLAG_SEP_VDM  SEE_MASK_FLAG_SEPVDM
#define CMIC_MASK_HASTITLE      SEE_MASK_HASTITLE
#define CMIC_MASK_ASYNCOK       SEE_MASK_ASYNCOK
#if (_WIN32_IE >= 0x0501)
#define CMIC_MASK_SHIFT_DOWN    0x10000000
#define CMIC_MASK_CONTROL_DOWN  0x20000000
#endif // (_WIN32_IE >= 0x501)


#if (_WIN32_IE >= 0x0400)
#define CMIC_MASK_PTINVOKE      0x20000000
#endif


#include <pshpack8.h>  

//NOTE: When SEE_MASK_HMONITOR is set, hIcon is treated as hMonitor
typedef struct _CMINVOKECOMMANDINFO {
    DWORD cbSize;        // sizeof(CMINVOKECOMMANDINFO)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    LPCSTR lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters; // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;  // might be NULL (indicating no specific directory)
    int nShow;           // one of SW_ values for ShowWindow() API

    DWORD dwHotKey;
    HANDLE hIcon;
} CMINVOKECOMMANDINFO,  *LPCMINVOKECOMMANDINFO;

typedef struct _CMInvokeCommandInfoEx {
    DWORD cbSize;        // must be sizeof(CMINVOKECOMMANDINFOEX)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    LPCSTR lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters; // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;  // might be NULL (indicating no specific directory)
    int nShow;           // one of SW_ values for ShowWindow() API

    DWORD dwHotKey;

    HANDLE hIcon;
    LPCSTR lpTitle;      // For CreateProcess-StartupInfo.lpTitle
    LPCWSTR lpVerbW;        // Unicode verb (for those who can use it)
    LPCWSTR lpParametersW;  // Unicode parameters (for those who can use it)
    LPCWSTR lpDirectoryW;   // Unicode directory (for those who can use it)
    LPCWSTR lpTitleW;       // Unicode title (for those who can use it)
#if (_WIN32_IE >= 0x0400)
    POINT   ptInvoke;       // Point where it's invoked
#endif
} CMINVOKECOMMANDINFOEX,  *LPCMINVOKECOMMANDINFOEX;

#include <poppack.h>        /* Return to byte packing */

#undef  INTERFACE
#define INTERFACE   IContextMenu

DECLARE_INTERFACE_(IContextMenu, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;
};

typedef IContextMenu *  LPCONTEXTMENU;

//
// IContextMenu2 (IContextMenu with one new member)
//
// IContextMenu2::HandleMenuMsg
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu2 interface and receives one of following messages while
// it is calling TrackPopupMenu (in the window proc of hwnd):
//      WM_INITPOPUP, WM_DRAWITEM and WM_MEASUREITEM
//  The callee may handle these messages to draw owner draw menuitems.
//

#undef  INTERFACE
#define INTERFACE   IContextMenu2

DECLARE_INTERFACE_(IContextMenu2, IContextMenu)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IContextMenu methods ***

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;

    // *** IContextMenu2 methods ***

    STDMETHOD(HandleMenuMsg)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam) PURE;
};

typedef IContextMenu2 * LPCONTEXTMENU2;

//
// IContextMenu3 (IContextMenu with one new member)
//
// IContextMenu3::HandleMenuMsg2
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu3 interface and receives a menu message while
// it is calling TrackPopupMenu (in the window proc of hwnd):
//

#undef  INTERFACE
#define INTERFACE   IContextMenu3

DECLARE_INTERFACE_(IContextMenu3, IContextMenu2)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IContextMenu methods ***

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;

    // *** IContextMenu2 methods ***

    STDMETHOD(HandleMenuMsg)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam) PURE;

    // *** IContextMenu3 methods ***

    STDMETHOD(HandleMenuMsg2)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             LRESULT* plResult) PURE;
};

typedef IContextMenu3 * LPCONTEXTMENU3;


#if (_WIN32_IE >= 0x0500)
#undef  INTERFACE
#define INTERFACE   IPersistFolder3

#define CSIDL_FLAG_PFTI_TRACKTARGET CSIDL_FLAG_DONT_VERIFY

// DESCRIPTION: PERSIST_FOLDER_TARGET_INFO
//    This stucture is used for Folder Shortcuts which allow the shell to
// have a file system folder act like another area in the name space.
// One of pidlTargetFolder, szTargetParsingName, or csidl needs to
// specify the destination name space.
//
// pidlTargetFolder: This is a full pidl to the target folder.  Can be NULL in the IPersistFolder3::InitializeEx()
//                   call but not in the GetFolderTargetInfo() return structure.
// szTargetParsingName: Empty string if not specified. Ortherwise, it is the parsible name
//                       to the target.  This name can be parsed by IShellFolder::
//                       ParseDisplayName() from the desktop.
// szNetworkProvider: Can be an empty string.  If not empty, it specifies the type of network
//                    provider that will be used when binding to the target.  This is used
//                    for performance optimizations for the WNet APIs.
// dwAttributes: -1 if not known.  These are the SFGAO_ flags for IShellFolder::GetAttributesOf()
// csidl: This is -1 if it's not used.  This can be used instead of pidlTargetFolder or
//        szTargetParsingName to indicate the TargetFolder.  See the list of CSIDL_ folders
//        below.  CSIDL_FLAG_PFTI_TRACKTARGET means that the IShellFolder's target folder
//        should change if the user changes the target of the underlying CSIDL value.
//        You can also pass CSIDL_FLAG_CREATE to indicate that the target folder
//        should be created if it does not exist.  No other CSIDL_FLAG_* values are supported.

#include <pshpack8.h>  

typedef struct
{
    LPITEMIDLIST  pidlTargetFolder;               // pidl for the folder we want to intiailize
    WCHAR         szTargetParsingName[MAX_PATH];  // optional parsing name for the target
    WCHAR         szNetworkProvider[MAX_PATH];    // optional network provider
    DWORD         dwAttributes;                   // optional FILE_ATTRIBUTES_ flags (-1 if not used)
    int           csidl;                          // optional folder index (SHGetFolderPath()) -1 if not used
} PERSIST_FOLDER_TARGET_INFO;

#include <poppack.h>        /* Return to byte packing */


// DESCRIPTION: IPersistFolder3
//    This interface is implemented by an IShellFolder object that wants non-default
// handling of Folder Shortcuts.  In general, shell name space extensions should use
// pidlRoot (the alias pidl) as their location in the name space and pass it to public
// APIs, such as ShellExecute().  The one exception is that pidlTarget should be used
// when sending ChangeNotifies or registering to listen for change notifies
// (see SFVM_GETNOTIFY).
//
// InitializeEx: This method initializes an IShellFolder and specifies where
//               it is rooted in the name space.
//      pbc: May be NULL.
//      pidlRoot: This is the same parameter as IPersistFolder::Initialize(). Caller allocates
//                and frees this parameter.
//      ppfti: May be NULL, in which case this is the same as a call to IPersistFolder::Initialize().
//             Otherwise this is a Folder Shortcut and this structure specifies the target
//             folder and it's attributes.
// GetFolderTargetInfo: This is used by the caller to find information about
//             the folder shortcut.  This structure may not be initialized by the caller,
//             so the callee needs to initialize every member.  The callee allocates
//             pidlTargetFolder and the caller will free it.  Filling in pidlTargetFolder is
//             ALWAYS required.
DECLARE_INTERFACE_(IPersistFolder3, IPersistFolder2)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistFolder methods ***
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidl) PURE;

    // *** IPersistFolder2 methods ***
    STDMETHOD(GetCurFolder)(THIS_ LPITEMIDLIST *ppidl) PURE;

    // *** IPersistFolder3 methods ***
    STDMETHOD(InitializeEx)(THIS_ IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfti) PURE;
    STDMETHOD(GetFolderTargetInfo)(THIS_ PERSIST_FOLDER_TARGET_INFO *ppfti) PURE;
};


#endif

//

//===========================================================================
//
// IExtractIcon interface
//
//  This interface is used in two different places in the shell.
//
// Case-1: Icons of sub-folders for the scope-pane of the explorer.
//
//  It is used by the explorer to get the "icon location" of
// sub-folders from each shell folders. When the user expands a folder
// in the scope pane of the explorer, the explorer does following:
//  (1) binds to the folder (gets IShellFolder),
//  (2) enumerates its sub-folders by calling its EnumObjects member,
//  (3) calls its GetUIObjectOf member to get IExtractIcon interface
//     for each sub-folders.
//  In this case, the explorer uses only IExtractIcon::GetIconLocation
// member to get the location of the appropriate icon. An icon location
// always consists of a file name (typically DLL or EXE) and either an icon
// resource or an icon index.
//
//
// Case-2: Extracting an icon image from a file
//
//  It is used by the shell when it extracts an icon image
// from a file. When the shell is extracting an icon from a file,
// it does following:
//  (1) creates the icon extraction handler object (by getting its CLSID
//     under the {ProgID}\shell\ExtractIconHanler key and calling
//     CoCreateInstance requesting for IExtractIcon interface).
//  (2) Calls IExtractIcon::GetIconLocation.
//  (3) Then, calls IExtractIcon::ExtractIcon with the location/index pair.
//  (4) If (3) returns NOERROR, it uses the returned icon.
//  (5) Otherwise, it recursively calls this logic with new location
//     assuming that the location string contains a fully qualified path name.
//
//  From extension programmer's point of view, there are only two cases
// where they provide implementations of IExtractIcon:
//  Case-1) providing explorer extensions (i.e., IShellFolder).
//  Case-2) providing per-instance icons for some types of files.
//
// Because Case-1 is described above, we'll explain only Case-2 here.
//
// When the shell is about display an icon for a file, it does following:
//  (1) Finds its ProgID and ClassID.
//  (2) If the file has a ClassID, it gets the icon location string from the
//    "DefaultIcon" key under it. The string indicates either per-class
//    icon (e.g., "FOOBAR.DLL,2") or per-instance icon (e.g., "%1,1").
//  (3) If a per-instance icon is specified, the shell creates an icon
//    extraction handler object for it, and extracts the icon from it
//    (which is described above).
//
//  It is important to note that the shell calls IExtractIcon::GetIconLocation
// first, then calls IExtractIcon::Extract. Most application programs
// that support per-instance icons will probably store an icon location
// (DLL/EXE name and index/id) rather than an icon image in each file.
// In those cases, a programmer needs to implement only the GetIconLocation
// member and it Extract member simply returns S_FALSE. They need to
// implement Extract member only if they decided to store the icon images
// within files themselved or some other database (which is very rare).
//
//
//
// [Member functions]
//
//
// IExtractIcon::GetIconLocation
//
//  This function returns an icon location.
//
//  Parameters:
//   uFlags     [in]  -- Specifies if it is opened or not (GIL_OPENICON or 0)
//   szIconFile [out] -- Specifies the string buffer buffer for a location name.
//   cchMax     [in]  -- Specifies the size of szIconFile (almost always MAX_PATH)
//   piIndex    [out] -- Sepcifies the address of UINT for the index.
//   pwFlags    [out] -- Returns GIL_* flags
//  Returns:
//   NOERROR, if it returns a valid location; S_FALSE, if the shell use a
//   default icon.
//
//  Notes: The location may or may not be a path to a file. The caller can
//   not assume anything unless the subsequent Extract member call returns
//   S_FALSE.
//
//   if the returned location is not a path to a file, GIL_NOTFILENAME should
//   be set in the returned flags.
//
// IExtractIcon::Extract
//
//  This function extracts an icon image from a specified file.
//
//  Parameters:
//   pszFile [in] -- Specifies the icon location (typically a path to a file).
//   nIconIndex [in] -- Specifies the icon index.
//   phiconLarge [out] -- Specifies the HICON variable for large icon.
//   phiconSmall [out] -- Specifies the HICON variable for small icon.
//   nIconSize [in] -- Specifies the size icon required (size of large icon)
//                     LOWORD is the requested large icon size
//                     HIWORD is the requested small icon size
//  Returns:
//   NOERROR, if it extracted the from the file.
//   S_FALSE, if the caller should extract from the file specified in the
//           location.
//
//===========================================================================

// GetIconLocation() input flags

#define GIL_OPENICON     0x0001      // allows containers to specify an "open" look
#define GIL_FORSHELL     0x0002      // icon is to be displayed in a ShellFolder
#define GIL_ASYNC        0x0020      // this is an async extract, return E_PENDING
#define GIL_DEFAULTICON  0x0040      // get the default icon location if the final one takes too long to get

// GetIconLocation() return flags

#define GIL_SIMULATEDOC  0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE  0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS     0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME  0x0008      // location is not a filename, must call ::ExtractIcon
#define GIL_DONTCACHE    0x0010      // this icon should not be cached

#undef  INTERFACE
#define INTERFACE   IExtractIconA

DECLARE_INTERFACE_(IExtractIconA, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPSTR  szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconA * LPEXTRACTICONA;

#undef  INTERFACE
#define INTERFACE   IExtractIconW

DECLARE_INTERFACE_(IExtractIconW, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPWSTR szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCWSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconW * LPEXTRACTICONW;

#ifdef UNICODE
#define IExtractIcon        IExtractIconW
#define IExtractIconVtbl    IExtractIconWVtbl
#define LPEXTRACTICON       LPEXTRACTICONW
#else
#define IExtractIcon        IExtractIconA
#define IExtractIconVtbl    IExtractIconAVtbl
#define LPEXTRACTICON       LPEXTRACTICONA
#endif

//===========================================================================
//
// IShellIcon Interface
//
// used to get a icon index for a IShellFolder object.
//
// this interface can be implemented by a IShellFolder, as a quick way to
// return the icon for a object in the folder.
//
// a instance of this interface is only created once for the folder, unlike
// IExtractIcon witch is created once for each object.
//
// if a ShellFolder does not implement this interface, the standard
// GetUIObject(....IExtractIcon) method will be used to get a icon
// for all objects.
//
// the following standard imagelist indexs can be returned:
//
//      0   document (blank page) (not associated)
//      1   document (with stuff on the page)
//      2   application (exe, com, bat)
//      3   folder (plain)
//      4   folder (open)
//
// IShellIcon:GetIconOf(pidl, flags, lpIconIndex)
//
//      pidl            object to get icon for.
//      flags           GIL_* input flags (GIL_OPEN, ...)
//      lpIconIndex     place to return icon index.
//
//  returns:
//      NOERROR, if lpIconIndex contains the correct system imagelist index.
//      S_FALSE, if unable to get icon for this object, go through
//               GetUIObject, IExtractIcon, methods.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIcon

DECLARE_INTERFACE_(IShellIcon, IUnknown)      // shi
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIcon methods ***
    STDMETHOD(GetIconOf)(THIS_ LPCITEMIDLIST pidl, UINT flags,
                    LPINT lpIconIndex) PURE;
};

typedef IShellIcon *LPSHELLICON;

//===========================================================================
//
// IShellIconOverlayIdentifier
//
// Used to identify a file as a member of the group of files that have this specific
// icon overlay
//
// Users can create new IconOverlayIdentifiers and place them in the following registry
// location together with the Icon overlay image and their priority.
// HKEY_LOCAL_MACHINE "Software\\Microsoft\\Windows\\CurrentVersion\\ShellIconOverlayIdentifiers"
//
// The shell will enumerate through all IconOverlayIdentifiers at start, and prioritize
// them according to internal rules, in case the internal rules don't apply, we use their
// input priority
//
// IShellIconOverlayIdentifier:IsMemberOf(LPCWSTR pwszPath, DWORD dwAttrib)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//
//  returns:
//      S_OK,    if the file is a member
//      S_FALSE, if the file is not a member
//      E_FAIL,  if the operation failed due to bad WIN32_FIND_DATA
//
// IShellIconOverlayIdentifier::GetOverlayInfo(LPWSTR pwszIconFile, int * pIndex, DWORD * dwFlags) PURE;
//      pszIconFile    the path of the icon file
//      pIndex         Depend on the flags, this could contain the IconIndex 
//      dwFlags        defined below
//
// IShellIconOverlayIdentifier::GetPriority(int * pIPriority) PURE;
//      pIPriority     the priority of this Overlay Identifier
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayIdentifier

DECLARE_INTERFACE_(IShellIconOverlayIdentifier, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayIdentifier methods ***
    STDMETHOD (IsMemberOf)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib) PURE;
    STDMETHOD (GetOverlayInfo)(THIS_ LPWSTR pwszIconFile, int cchMax, int * pIndex, DWORD * pdwFlags) PURE;
    STDMETHOD (GetPriority)(THIS_ int * pIPriority) PURE;
};

#define ISIOI_ICONFILE            0x00000001          // path is returned through pwszIconFile
#define ISIOI_ICONINDEX           0x00000002          // icon index in pwszIconFile is returned through pIndex


//===========================================================================
//
// IShellIconOverlay
//
// Used to return the icon overlay index or its icon index for an IShellFolder object,
// this is always implemented with IShellFolder
//
// IShellIconOverlay:GetOverlayIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pidl            object to identify icon overlay for.
//      pdwIndex        the Overlay Index in the system image list
//
// IShellIconOverlay:GetOverlayIconIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pdwIconIndex    the Overlay Icon index in the system image list
// This method is only used for those who are interested in seeing the real bits
// of the Overlay Icon
//
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if pidl is bad
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlay

DECLARE_INTERFACE_(IShellIconOverlay, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlay methods ***
    STDMETHOD(GetOverlayIndex)(THIS_ LPCITEMIDLIST pidl, int * pIndex) PURE;
    STDMETHOD(GetOverlayIconIndex)(THIS_ LPCITEMIDLIST pidl, int * pIconIndex) PURE;
};

#define OI_ASYNC 0xFFFFEEEE

//-------------------------------------------------------------------------
//
// SHGetIconOverlayIndex
//
// This function takes the path and icon/res id to the icon and convert it into 
// an overlay index in the system image list. 
// Note: there are totally only 15 slots for system image overlays, some of which 
// was reserved by the system, or taken by the overlayidentifiers, so it's possible
// that this function would fail and return -1;  
//
// To get the default overlays in the system, such as the share hand, link shortcut
// and slow files, pass NULL as the file name, then the IDO_SHGIOI_* flags as the icon index
//-------------------------------------------------------------------------

#define IDO_SHGIOI_SHARE  0x0FFFFFFF
#define IDO_SHGIOI_LINK   0x0FFFFFFE
#define IDO_SHGIOI_SLOWFILE 0x0FFFFFFFD
SHSTDAPI_(int) SHGetIconOverlayIndexA(LPCSTR pszIconPath, int iIconIndex);
SHSTDAPI_(int) SHGetIconOverlayIndexW(LPCWSTR pszIconPath, int iIconIndex);
#ifdef UNICODE
#define SHGetIconOverlayIndex  SHGetIconOverlayIndexW
#else
#define SHGetIconOverlayIndex  SHGetIconOverlayIndexA
#endif // !UNICODE


#if (_WIN32_IE >= 0x0400)

// IShellLinkDataList::GetFlags()/SetFlags()
typedef enum {
   SLDF_HAS_ID_LIST         = 0x00000001,   // Shell link saved with ID list
   SLDF_HAS_LINK_INFO       = 0x00000002,   // Shell link saved with LinkInfo
   SLDF_HAS_NAME            = 0x00000004,
   SLDF_HAS_RELPATH         = 0x00000008,
   SLDF_HAS_WORKINGDIR      = 0x00000010,
   SLDF_HAS_ARGS            = 0x00000020,
   SLDF_HAS_ICONLOCATION    = 0x00000040,
   SLDF_UNICODE             = 0x00000080,   // the strings are unicode
   SLDF_FORCE_NO_LINKINFO   = 0x00000100,   // don't create a LINKINFO (make a dumb link)
   SLDF_HAS_EXP_SZ          = 0x00000200,   // the link contains expandable env strings
   SLDF_RUN_IN_SEPARATE     = 0x00000400,   // Run the 16-bit target exe in a separate VDM/WOW
   SLDF_HAS_LOGO3ID         = 0x00000800,   // this link is a special Logo3/MSICD link
   SLDF_HAS_DARWINID        = 0x00001000,   // this link is a special Darwin link
   SLDF_RUNAS_USER          = 0x00002000,   // Run this link as a different user       
   SLDF_HAS_EXP_ICON_SZ     = 0x00004000,   // contains expandable env string for icon path
   SLDF_NO_PIDL_ALIAS       = 0x00008000,   // don't ever resolve to a logical location
   SLDF_FORCE_UNCNAME       = 0x00010000,   // make GetPath() prefer the UNC name to the local name
} SHELL_LINK_DATA_FLAGS;

typedef struct tagDATABLOCKHEADER
{
    DWORD   cbSize;             // Size of this extra data block
    DWORD   dwSignature;        // signature of this extra data block
} DATABLOCK_HEADER, *LPDATABLOCK_HEADER, *LPDBLIST;

typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    WORD     wFillAttribute;         // fill attribute for console
    WORD     wPopupFillAttribute;    // fill attribute for console popups
    COORD    dwScreenBufferSize;     // screen buffer size for console
    COORD    dwWindowSize;           // window size for console
    COORD    dwWindowOrigin;         // window origin for console
    DWORD    nFont;
    DWORD    nInputBufferSize;
    COORD    dwFontSize;
    UINT     uFontFamily;
    UINT     uFontWeight;
    WCHAR    FaceName[LF_FACESIZE];
    UINT     uCursorSize;
    BOOL     bFullScreen;
    BOOL     bQuickEdit;
    BOOL     bInsertMode;
    BOOL     bAutoPosition;
    UINT     uHistoryBufferSize;
    UINT     uNumberOfHistoryBuffers;
    BOOL     bHistoryNoDup;
    COLORREF ColorTable[ 16 ];
} NT_CONSOLE_PROPS, *LPNT_CONSOLE_PROPS;
#define NT_CONSOLE_PROPS_SIG 0xA0000002

// This is a FE Console property
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    UINT     uCodePage;
} NT_FE_CONSOLE_PROPS, *LPNT_FE_CONSOLE_PROPS;
#define NT_FE_CONSOLE_PROPS_SIG 0xA0000004

#if (_WIN32_IE >= 0x0500)
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    CHAR        szDarwinID[MAX_PATH];  // ANSI darwin ID associated with link
    WCHAR       szwDarwinID[MAX_PATH]; // UNICODE darwin ID associated with link
} EXP_DARWIN_LINK, *LPEXP_DARWIN_LINK;
#define EXP_DARWIN_ID_SIG       0xA0000006
#define EXP_LOGO3_ID_SIG        0xA0000007
#endif

#define EXP_SPECIAL_FOLDER_SIG         0xA0000005   // LPEXP_SPECIAL_FOLDER


typedef struct 
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    DWORD       idSpecialFolder;    // special folder id this link points into
    DWORD       cbOffset;           // ofset into pidl from SLDF_HAS_ID_LIST for child
} EXP_SPECIAL_FOLDER, *LPEXP_SPECIAL_FOLDER;



typedef struct 
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    CHAR        szTarget[ MAX_PATH ];   // ANSI target name w/EXP_SZ in it
    WCHAR       swzTarget[ MAX_PATH ];  // UNICODE target name w/EXP_SZ in it
} EXP_SZ_LINK, *LPEXP_SZ_LINK;
#define EXP_SZ_LINK_SIG                0xA0000001   // LPEXP_SZ_LINK (target)
#define EXP_SZ_ICON_SIG                0xA0000007   // LPEXP_SZ_LINK (icon)

#undef  INTERFACE
#define INTERFACE IShellLinkDataList

DECLARE_INTERFACE_(IShellLinkDataList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellLinkDataList methods ***
    STDMETHOD(AddDataBlock)(THIS_ void * pDataBlock) PURE;
    STDMETHOD(CopyDataBlock)(THIS_ DWORD dwSig, void **ppDataBlock) PURE;
    STDMETHOD(RemoveDataBlock)(THIS_ DWORD dwSig) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;
    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags) PURE;
};

#endif // (_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
#undef  INTERFACE
#define INTERFACE IResolveShellLink

DECLARE_INTERFACE_(IResolveShellLink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IResolveShellLink methods ***
    STDMETHOD(ResolveShellLink)(THIS_ IUnknown* punk, HWND hwnd, DWORD fFlags) PURE;
};
#endif // (_WIN32_IE >= 0x0500)


#ifdef _INC_SHELLAPI    /* for LPSHELLEXECUTEINFO */
//===========================================================================
//
// IShellExecuteHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookA

DECLARE_INTERFACE_(IShellExecuteHookA, IUnknown) // shexhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookA methods ***
    STDMETHOD(Execute)(THIS_ LPSHELLEXECUTEINFOA pei) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookW

DECLARE_INTERFACE_(IShellExecuteHookW, IUnknown) // shexhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookW methods ***
    STDMETHOD(Execute)(THIS_ LPSHELLEXECUTEINFOW pei) PURE;
};

#ifdef UNICODE
#define IShellExecuteHook       IShellExecuteHookW
#define IShellExecuteHookVtbl   IShellExecuteHookWVtbl
#else
#define IShellExecuteHook       IShellExecuteHookA
#define IShellExecuteHookVtbl   IShellExecuteHookAVtbl
#endif
#endif

//===========================================================================
//
// IURLSearchHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IURLSearchHook

DECLARE_INTERFACE_(IURLSearchHook, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IURLSearchHook methods ***
    STDMETHOD(Translate)(THIS_ LPWSTR lpwszSearchURL, DWORD cchBufferSize) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchContext

DECLARE_INTERFACE_(ISearchContext, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ISearchContext methods ***
    STDMETHOD(GetSearchUrl)(THIS_ BSTR * pbstrSearchUrl) PURE;
    STDMETHOD(GetSearchText)(THIS_ BSTR * pbstrSearchText) PURE;
    STDMETHOD(GetSearchStyle)(THIS_ DWORD * pdwSearchStyle) PURE;
};

#undef  INTERFACE
#define INTERFACE   IURLSearchHook2

DECLARE_INTERFACE_(IURLSearchHook2, IURLSearchHook)
{
    // *** IURLSearchHook2 methods ***
    STDMETHOD(TranslateWithSearchContext)(THIS_ LPWSTR lpwszSearchURL, DWORD cchBufferSize, ISearchContext * pSearchContext) PURE;
};

//===========================================================================
//
// INewShortcutHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   INewShortcutHookA

DECLARE_INTERFACE_(INewShortcutHookA, IUnknown) // nshhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ LPSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ LPSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ LPSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ LPSTR pszExtension, int cchExtension) PURE;
};

#undef  INTERFACE
#define INTERFACE   INewShortcutHookW

DECLARE_INTERFACE_(INewShortcutHookW, IUnknown) // nshhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCWSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ LPWSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCWSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ LPWSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ LPWSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ LPWSTR pszExtension, int cchExtension) PURE;
};

#ifdef UNICODE
#define INewShortcutHook        INewShortcutHookW
#define INewShortcutHookVtbl    INewShortcutHookWVtbl
#else
#define INewShortcutHook        INewShortcutHookA
#define INewShortcutHookVtbl    INewShortcutHookAVtbl
#endif

//===========================================================================
//
// ICopyHook Interface
//
//  The copy hook is called whenever file system directories are
//  copy/moved/deleted/renamed via the shell.  It is also called by the shell
//  on changes of status of printers.
//
//  Clients register their id under STRREG_SHEX_COPYHOOK for file system hooks
//  and STRREG_SHEx_PRNCOPYHOOK for printer hooks.
//  the CopyCallback is called prior to the action, so the hook has the chance
//  to allow, deny or cancel the operation by returning the falues:
//     IDYES  -  means allow the operation
//     IDNO   -  means disallow the operation on this file, but continue with
//              any other operations (eg. batch copy)
//     IDCANCEL - means disallow the current operation and cancel any pending
//              operations
//
//   arguments to the CopyCallback
//      hwnd - window to use for any UI
//      wFunc - what operation is being done
//      wFlags - and flags (FOF_*) set in the initial call to the file operation
//      pszSrcFile - name of the source file
//      dwSrcAttribs - file attributes of the source file
//      pszDestFile - name of the destiation file (for move and renames)
//      dwDestAttribs - file attributes of the destination file
//
//
//===========================================================================

#ifndef FO_MOVE //these need to be kept in sync with the ones in shellapi.h

// file operations

#define FO_MOVE           0x0001
#define FO_COPY           0x0002
#define FO_DELETE         0x0003
#define FO_RENAME         0x0004

#define FOF_MULTIDESTFILES         0x0001
#define FOF_CONFIRMMOUSE           0x0002
#define FOF_SILENT                 0x0004  // don't create progress/report
#define FOF_RENAMEONCOLLISION      0x0008
#define FOF_NOCONFIRMATION         0x0010  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE      0x0020  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings
#define FOF_ALLOWUNDO              0x0040
#define FOF_FILESONLY              0x0080  // on *.*, do only files
#define FOF_SIMPLEPROGRESS         0x0100  // means don't show names of files
#define FOF_NOCONFIRMMKDIR         0x0200  // don't confirm making any needed dirs
#define FOF_NOERRORUI              0x0400  // don't put up error UI
#define FOF_NOCOPYSECURITYATTRIBS  0x0800  // dont copy NT file Security Attributes
#define FOF_NORECURSION            0x1000  // don't recurse into directories.
#if (_WIN32_IE >= 0x500)
#define FOF_NO_CONNECTED_ELEMENTS  0x2000  // don't operate on connected file elements.
#define FOF_WANTNUKEWARNING        0x4000  // during delete operation, warn if nuking instead of recycling (partially overrides FOF_NOCONFIRMATION)
#endif // _WIN32_IE >= 0x500

typedef WORD FILEOP_FLAGS;

// printer operations

#define PO_DELETE       0x0013  // printer is being deleted
#define PO_RENAME       0x0014  // printer is being renamed
#define PO_PORTCHANGE   0x0020  // port this printer connected to is being changed
                                // if this id is set, the strings received by
                                // the copyhook are a doubly-null terminated
                                // list of strings.  The first is the printer
                                // name and the second is the printer port.
#define PO_REN_PORT     0x0034  // PO_RENAME and PO_PORTCHANGE at same time.

// no POF_ flags currently defined

typedef UINT PRINTEROP_FLAGS;

#endif // FO_MOVE

#undef  INTERFACE
#define INTERFACE   ICopyHookA

DECLARE_INTERFACE_(ICopyHookA, IUnknown)        // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookA *    LPCOPYHOOKA;

#undef  INTERFACE
#define INTERFACE   ICopyHookW

DECLARE_INTERFACE_(ICopyHookW, IUnknown)        // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCWSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCWSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookW *    LPCOPYHOOKW;

#ifdef UNICODE
#define ICopyHook       ICopyHookW
#define ICopyHookVtbl   ICopyHookWVtbl
#define LPCOPYHOOK      LPCOPYHOOKW
#else
#define ICopyHook       ICopyHookA
#define ICopyHookVtbl   ICopyHookAVtbl
#define LPCOPYHOOK      LPCOPYHOOKA
#endif

//===========================================================================
//
// IFileViewerSite Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IFileViewerSite

DECLARE_INTERFACE_(IFileViewerSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewerSite methods ***
    STDMETHOD(SetPinnedWindow) (THIS_ HWND hwnd) PURE;
    STDMETHOD(GetPinnedWindow) (THIS_ HWND *phwnd) PURE;
};

typedef IFileViewerSite * LPFILEVIEWERSITE;


//===========================================================================
//
// IFileViewer Interface
//
// Implemented in a FileViewer component object.  Used to tell a
// FileViewer to PrintTo or to view, the latter happening though
// ShowInitialize and Show.  The filename is always given to the
// viewer through IPersistFile.
//
//===========================================================================

#include <pshpack8.h>  

typedef struct
{
    // Stuff passed into viewer (in)
    DWORD cbSize;           // Size of structure for future expansion...
    HWND hwndOwner;         // who is the owner window.
    int iShow;              // The show command

    // Passed in and updated  (in/Out)
    DWORD dwFlags;          // flags
    RECT rect;              // Where to create the window may have defaults
    IUnknown *punkRel;      // Relese this interface when window is visible

    // Stuff that might be returned from viewer (out)
    OLECHAR strNewFile[MAX_PATH];   // New File to view.

} FVSHOWINFO, *LPFVSHOWINFO;

#include <poppack.h>        /* Return to byte packing */

    // Define File View Show Info Flags.
#define FVSIF_RECT      0x00000001      // The rect variable has valid data.
#define FVSIF_PINNED    0x00000002      // We should Initialize pinned

#define FVSIF_NEWFAILED 0x08000000      // The new file passed back failed
                                        // to be viewed.

#define FVSIF_NEWFILE   0x80000000      // A new file to view has been returned
#define FVSIF_CANVIEWIT 0x40000000      // The viewer can view it.

#undef  INTERFACE
#define INTERFACE   IFileViewerA

DECLARE_INTERFACE(IFileViewerA)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ LPSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerA * LPFILEVIEWERA;

#undef  INTERFACE
#define INTERFACE   IFileViewerW

DECLARE_INTERFACE(IFileViewerW)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ LPWSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerW * LPFILEVIEWERW;

#ifdef UNICODE
#define IFileViewer IFileViewerW
#define LPFILEVIEWER LPFILEVIEWERW
#else
#define IFileViewer IFileViewerA
#define LPFILEVIEWER LPFILEVIEWERA
#endif



//==========================================================================
//
// IShellBrowser/IShellView/IShellFolder interface
//
//  These three interfaces are used when the shell communicates with
// name space extensions. The shell (explorer) provides IShellBrowser
// interface, and extensions implements IShellFolder and IShellView
// interfaces.
//
//==========================================================================


//--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------

#define FCIDM_SHVIEWFIRST           0x0000
#define FCIDM_SHVIEWLAST            0x7fff
#define FCIDM_BROWSERFIRST          0xa000
#define FCIDM_BROWSERLAST           0xbf00
#define FCIDM_GLOBALFIRST           0x8000
#define FCIDM_GLOBALLAST            0x9fff

//
// Global submenu IDs and separator IDs
//
#define FCIDM_MENU_FILE             (FCIDM_GLOBALFIRST+0x0000)
#define FCIDM_MENU_EDIT             (FCIDM_GLOBALFIRST+0x0040)
#define FCIDM_MENU_VIEW             (FCIDM_GLOBALFIRST+0x0080)
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)
#define FCIDM_MENU_TOOLS            (FCIDM_GLOBALFIRST+0x00c0) // for Win9x compat
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1) // for Win9x compat
#define FCIDM_MENU_HELP             (FCIDM_GLOBALFIRST+0x0100)
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)
#define FCIDM_MENU_EXPLORE          (FCIDM_GLOBALFIRST+0x0150)
#define FCIDM_MENU_FAVORITES        (FCIDM_GLOBALFIRST+0x0170)

//--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------

#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)

#if (_WIN32_IE >= 0x0400)
//--------------------------------------------------------------------------
//
// The resource id of the offline cursor
// This cursor is avaialble in shdocvw.dll
#define IDC_OFFLINE_HAND        103
//
//--------------------------------------------------------------------------
#endif


//-------------------------------------------------------------------------
// ICommDlgBrowser interface
//
//  ICommDlgBrowser interface is the interface that is provided by the new
// common dialog window to hook and modify the behavior of IShellView.  When
// a default view is created, it queries its parent IShellBrowser for the
// ICommDlgBrowser interface.  If supported, it calls out to that interface
// in several cases that need to behave differently in a dialog.
//
// Member functions:
//
//  ICommDlgBrowser::OnDefaultCommand()
//    Called when the user double-clicks in the view or presses Enter.  The
//   browser should return S_OK if it processed the action itself, S_FALSE
//   to let the view perform the default action.
//
//  ICommDlgBrowser::OnStateChange(ULONG uChange)
//    Called when some states in the view change.  'uChange' is one of the
//   CDBOSC_* values.  This call is made after the state (selection, focus,
//   etc) has changed.  There is no return value.
//
//  ICommDlgBrowser::IncludeObject(LPCITEMIDLIST pidl)
//    Called when the view is enumerating objects.  'pidl' is a relative
//   IDLIST.  The browser should return S_OK to include the object in the
//   view, S_FALSE to hide it
//
//-------------------------------------------------------------------------

#define CDBOSC_SETFOCUS     0x00000000
#define CDBOSC_KILLFOCUS    0x00000001
#define CDBOSC_SELCHANGE    0x00000002
#define CDBOSC_RENAME       0x00000003

#undef  INTERFACE
#define INTERFACE   ICommDlgBrowser

DECLARE_INTERFACE_(ICommDlgBrowser, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICommDlgBrowser methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView * ppshv) PURE;
    STDMETHOD(OnStateChange) (THIS_ struct IShellView * ppshv,
                ULONG uChange) PURE;
    STDMETHOD(IncludeObject) (THIS_ struct IShellView * ppshv,
                LPCITEMIDLIST pidl) PURE;
};

typedef ICommDlgBrowser * LPCOMMDLGBROWSER;

//-------------------------------------------------------------------------
// ICommDlgBrowser2 interface
//
// Member functions:
//
//  ICommDlgBrowser2::Notify(IShellView *pshv, DWORD dwNotfyType)
//   Called when the view is wants to notify common dialog when an event
//  occurrs.
//
//  CDB2N_CONTEXTMENU_START indicates the context menu has started.
//  CDB2N_CONTEXTMENU_DONE  indicates the context menu has completed.
//
//  ICommDlgBrowser2::GetDefaultMenuText(IShellView *pshv,
//                                      WCHAR *pszText, INT cchMax)
//   Called when the view wants to get the default context menu text.
//  pszText points to buffer and cchMax specifies the size of the
//  buffer in characters.  The browser on return has filled the buffer
//  with the default context menu text.  The Shell will call this method
//  with at least a buffer size of MAX_PATH.  The browser should return
//  S_OK if it returned a new default menu text, S_FALSE to let the view
//  to use the normal default menu text.
//
//  ICommDlgBrowser2::GetViewFlags(DWORD *pdwFlags)
//     Called when the view wants to determine  if special customization needs to
//    be done for the common dialog browser. For example View calls this function to 
//    determin if all files(hidden and system)needs to be shown. If the GetViewFlags returns a DWORD with 
//    CDB2GVF_SHOWALLFILES  flag set then it will show all the files.
//-------------------------------------------------------------------------

#define CDB2N_CONTEXTMENU_DONE  0x00000001
#define CDB2N_CONTEXTMENU_START 0x00000002

//GetViewFlags
#define CDB2GVF_SHOWALLFILES        0x00000001

#undef  INTERFACE
#define INTERFACE   ICommDlgBrowser2

DECLARE_INTERFACE_(ICommDlgBrowser2, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICommDlgBrowser methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView * ppshv) PURE;
    STDMETHOD(OnStateChange) (THIS_ struct IShellView * ppshv,
                ULONG uChange) PURE;
    STDMETHOD(IncludeObject) (THIS_ struct IShellView * ppshv,
                LPCITEMIDLIST pidl) PURE;

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(Notify) (THIS_ struct IShellView * ppshv,
                DWORD dwNotifyType) PURE;
    STDMETHOD(GetDefaultMenuText) (THIS_ struct IShellView * ppshv,
                WCHAR *pszText, INT cchMax) PURE;
    STDMETHOD(GetViewFlags)(THIS_ DWORD *pdwFlags) PURE;

};

typedef ICommDlgBrowser2 * LPCOMMDLGBROWSER2;



//
// function assumes the size of the buffer (MAX_PATH). The pidl
// should point to a file system object.

SHSTDAPI_(BOOL) SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath);
SHSTDAPI_(BOOL) SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);
#ifdef UNICODE
#define SHGetPathFromIDList  SHGetPathFromIDListW
#else
#define SHGetPathFromIDList  SHGetPathFromIDListA
#endif // !UNICODE

SHSTDAPI_(int) SHCreateDirectoryExA(HWND hwnd, LPCSTR pszPath, SECURITY_ATTRIBUTES *psa);
SHSTDAPI_(int) SHCreateDirectoryExW(HWND hwnd, LPCWSTR pszPath, SECURITY_ATTRIBUTES *psa);
#ifdef UNICODE
#define SHCreateDirectoryEx  SHCreateDirectoryExW
#else
#define SHCreateDirectoryEx  SHCreateDirectoryExA
#endif // !UNICODE

SHSTDAPI SHOpenFolderAndSelectItems(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl, DWORD dwFlags);
SHSTDAPI SHCreateShellItem(LPCITEMIDLIST pidlParent, IShellFolder *psfParent, LPCITEMIDLIST pidl, IShellItem **ppsi);

//-------------------------------------------------------------------------
//
// SHGetSpecialFolderLocation
//
//  Caller should use SHGetMalloc to obtain an allocator that can free the pidl
//
//
//-------------------------------------------------------------------------
//
// registry entries for special paths are kept in :
#define REGSTR_PATH_SPECIAL_FOLDERS    REGSTR_PATH_EXPLORER TEXT("\\Shell Folders")


#define CSIDL_DESKTOP                   0x0000        // <desktop>
#define CSIDL_INTERNET                  0x0001        // Internet Explorer (icon on desktop)
#define CSIDL_PROGRAMS                  0x0002        // Start Menu\Programs
#define CSIDL_CONTROLS                  0x0003        // My Computer\Control Panel
#define CSIDL_PRINTERS                  0x0004        // My Computer\Printers
#define CSIDL_PERSONAL                  0x0005        // My Documents
#define CSIDL_FAVORITES                 0x0006        // <user name>\Favorites
#define CSIDL_STARTUP                   0x0007        // Start Menu\Programs\Startup
#define CSIDL_RECENT                    0x0008        // <user name>\Recent
#define CSIDL_SENDTO                    0x0009        // <user name>\SendTo
#define CSIDL_BITBUCKET                 0x000a        // <desktop>\Recycle Bin
#define CSIDL_STARTMENU                 0x000b        // <user name>\Start Menu
#define CSIDL_MYDOCUMENTS               0x000c        // logical "My Documents" desktop icon
#define CSIDL_MYMUSIC                   0x000d        // "My Music" folder
#define CSIDL_MYVIDEO                   0x000e        // "My Videos" folder
#define CSIDL_DESKTOPDIRECTORY          0x0010        // <user name>\Desktop
#define CSIDL_DRIVES                    0x0011        // My Computer
#define CSIDL_NETWORK                   0x0012        // Network Neighborhood
#define CSIDL_NETHOOD                   0x0013        // <user name>\nethood
#define CSIDL_FONTS                     0x0014        // windows\fonts
#define CSIDL_TEMPLATES                 0x0015
#define CSIDL_COMMON_STARTMENU          0x0016        // All Users\Start Menu
#define CSIDL_COMMON_PROGRAMS           0X0017        // All Users\Programs
#define CSIDL_COMMON_STARTUP            0x0018        // All Users\Startup
#define CSIDL_COMMON_DESKTOPDIRECTORY   0x0019        // All Users\Desktop
#define CSIDL_APPDATA                   0x001a        // <user name>\Application Data
#define CSIDL_PRINTHOOD                 0x001b        // <user name>\PrintHood
#define CSIDL_LOCAL_APPDATA             0x001c        // <user name>\Local Settings\Applicaiton Data (non roaming)
#define CSIDL_ALTSTARTUP                0x001d        // non localized startup
#define CSIDL_COMMON_ALTSTARTUP         0x001e        // non localized common startup
#define CSIDL_COMMON_FAVORITES          0x001f
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023        // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024        // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025        // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026        // C:\Program Files
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#define CSIDL_PROFILE                   0x0028        // USERPROFILE
#define CSIDL_SYSTEMX86                 0x0029        // x86 system directory on RISC
#define CSIDL_PROGRAM_FILESX86          0x002a        // x86 C:\Program Files on RISC
#define CSIDL_PROGRAM_FILES_COMMON      0x002b        // C:\Program Files\Common 
#define CSIDL_PROGRAM_FILES_COMMONX86   0x002c        // x86 Program Files\Common on RISC
#define CSIDL_COMMON_TEMPLATES          0x002d        // All Users\Templates
#define CSIDL_COMMON_DOCUMENTS          0x002e        // All Users\Documents
#define CSIDL_COMMON_ADMINTOOLS         0x002f        // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030        // <user name>\Start Menu\Programs\Administrative Tools
#define CSIDL_CONNECTIONS               0x0031        // Network and Dial-up Connections
#define CSIDL_COMMON_MUSIC              0x0035        // All Users\My Music
#define CSIDL_COMMON_PICTURES           0x0036        // All Users\My Pictures
#define CSIDL_COMMON_VIDEO              0x0037        // All Users\My Video

#define CSIDL_FLAG_CREATE               0x8000        // combine with CSIDL_ value to force folder creation in SHGetFolderPath()
#define CSIDL_FLAG_DONT_VERIFY          0x4000        // combine with CSIDL_ value to return an unverified folder path
#define CSIDL_FLAG_NO_ALIAS             0x1000        // combine with CSIDL_ value to insure non-alias versions of the pidl
#define CSIDL_FLAG_MASK                 0xFF00        // mask for all possible flag values


SHSTDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);

#if (_WIN32_IE >= 0x0400)

SHSTDAPI_(BOOL) SHGetSpecialFolderPathA(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate);
SHSTDAPI_(BOOL) SHGetSpecialFolderPathW(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);
#ifdef UNICODE
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathW
#else
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathA
#endif // !UNICODE

#if (_WIN32_IE >= 0x0500)

typedef enum {
    SHGFP_TYPE_CURRENT  = 0,   // current value for user, verify it exists
    SHGFP_TYPE_DEFAULT  = 1,   // default value, may not exist
} SHGFP_TYPE;

SHFOLDERAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
SHFOLDERAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
#ifdef UNICODE
#define SHGetFolderPath  SHGetFolderPathW
#else
#define SHGetFolderPath  SHGetFolderPathA
#endif // !UNICODE
SHSTDAPI SHGetFolderLocation(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPITEMIDLIST *ppidl);


#endif      // _WIN32_IE >= 0x0500

#endif      // _WIN32_IE >= 0x0400



//-------------------------------------------------------------------------
//
// SHBrowseForFolder API
//
// 
//-------------------------------------------------------------------------

typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

#include <pshpack8.h>  

typedef struct _browseinfoA {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPSTR        pszDisplayName;        // Return display name of item selected.
    LPCSTR       lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOA, *PBROWSEINFOA, *LPBROWSEINFOA;

typedef struct _browseinfoW {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPWSTR       pszDisplayName;        // Return display name of item selected.
    LPCWSTR      lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOW, *PBROWSEINFOW, *LPBROWSEINFOW;

#include <poppack.h>        /* Return to byte packing */

#ifdef UNICODE
#define BROWSEINFO      BROWSEINFOW
#define PBROWSEINFO     PBROWSEINFOW
#define LPBROWSEINFO    LPBROWSEINFOW
#else
#define BROWSEINFO      BROWSEINFOA
#define PBROWSEINFO     PBROWSEINFOA
#define LPBROWSEINFO    LPBROWSEINFOA
#endif

// Browsing for directory.
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004   // Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if
                                        // this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the
                                        // rest of the text.  This is not used with BIF_USENEWUI and BROWSEINFO.lpszTitle gets
                                        // all three lines of text.
#define BIF_RETURNFSANCESTORS  0x0008
#define BIF_EDITBOX            0x0010   // Add an editbox to the dialog
#define BIF_VALIDATE           0x0020   // insist on valid result (or CANCEL)

#define BIF_NEWDIALOGSTYLE     0x0040   // Use the new dialog layout with the ability to resize
                                        // Caller needs to call OleInitialize() before using this API

#define BIF_USENEWUI           (BIF_NEWDIALOGSTYLE | BIF_EDITBOX)

#define BIF_BROWSEINCLUDEURLS  0x0080   // Allow URLs to be displayed or entered. (Requires BIF_USENEWUI)
#define BIF_UAHINT             0x0100   // Add a UA hint to the dialog, in place of the edit box. May not be combined with BIF_EDITBOX

#define BIF_BROWSEFORCOMPUTER  0x1000  // Browsing for Computers.
#define BIF_BROWSEFORPRINTER   0x2000  // Browsing for Printers
#define BIF_BROWSEINCLUDEFILES 0x4000  // Browsing for Everything
#define BIF_SHAREABLE          0x8000  // sharable resources displayed (remote shares, requires BIF_USENEWUI)

// message from browser
#define BFFM_INITIALIZED        1
#define BFFM_SELCHANGED         2
#define BFFM_VALIDATEFAILEDA    3   // lParam:szPath ret:1(cont),0(EndDialog)
#define BFFM_VALIDATEFAILEDW    4   // lParam:wzPath ret:1(cont),0(EndDialog)
#define BFFM_IUNKNOWN           5   // provides IUnknown to client. lParam: IUnknown*

// messages to browser
#define BFFM_SETSTATUSTEXTA     (WM_USER + 100)
#define BFFM_ENABLEOK           (WM_USER + 101)
#define BFFM_SETSELECTIONA      (WM_USER + 102)
#define BFFM_SETSELECTIONW      (WM_USER + 103)
#define BFFM_SETSTATUSTEXTW     (WM_USER + 104)
#define BFFM_SETOKTEXT          (WM_USER + 105) // Unicode only
#define BFFM_SETEXPANDED        (WM_USER + 106) // Unicode only

SHSTDAPI_(LPITEMIDLIST) SHBrowseForFolderA(LPBROWSEINFOA lpbi);
SHSTDAPI_(LPITEMIDLIST) SHBrowseForFolderW(LPBROWSEINFOW lpbi);

#ifdef UNICODE
#define SHBrowseForFolder   SHBrowseForFolderW
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTW
#define BFFM_SETSELECTION   BFFM_SETSELECTIONW

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDW
#else
#define SHBrowseForFolder   SHBrowseForFolderA
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTA
#define BFFM_SETSELECTION   BFFM_SETSELECTIONA

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDA
#endif

//-------------------------------------------------------------------------
//
// SHLoadInProc
//
//   When this function is called, the shell calls CoCreateInstance
//  (or equivalent) with CLSCTX_INPROC_SERVER and the specified CLSID
//  from within the shell's process and release it immediately.
//
//-------------------------------------------------------------------------

SHSTDAPI SHLoadInProc(REFCLSID rclsid);


#if _WIN32_IE >= 0x0560

//-------------------------------------------------------------------------
//
// SHEnableServiceObject
//
//   Like SHLoadInProc, but gives control over the object's lifetime
//  via fEnable parameter.  TRUE tells the shell to create the object
//  and hold onto it, FALSE tells the shell to look for the previously
//  created instance of the object and release it.
//
//-------------------------------------------------------------------------

SHSTDAPI SHEnableServiceObject(REFCLSID rclsid, BOOL fEnable);

#endif


//
//  Helper function which returns a IShellFolder interface to the desktop
// folder. This is equivalent to call CoCreateInstance with CLSID_ShellDesktop.
//
//  CoCreateInstance(CLSID_Desktop, NULL,
//                   CLSCTX_INPROC, IID_IShellFolder, &pshf);
//
SHSTDAPI SHGetDesktopFolder(IShellFolder **ppshf);


// IShellFolder IBindCtx* parameters. the IUnknown for these are
// accessed through IBindCtx::RegisterObjectParam/GetObjectParam
// use this to provide the data needed create IDLists through 
// IShellFolder::ParseDisplayName(). this data applies to the last element
// of the name that is parsed (c:\foo\bar.txt, data applies to bar.txt)
// this makes creating these IDLists much faster that suppling the name only

#define STR_FILE_SYS_BIND_DATA      L"File System Bind Data"

#undef  INTERFACE
#define INTERFACE   IFileSystemBindData

DECLARE_INTERFACE_(IFileSystemBindData, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileSystemBindData methods ***
    STDMETHOD(SetFindData)(THIS_ const WIN32_FIND_DATAW *pfd) PURE;
    STDMETHOD(GetFindData)(THIS_ WIN32_FIND_DATAW *pfd) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellDetails

DECLARE_INTERFACE_(IShellDetails, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellDetails methods ***
    STDMETHOD(GetDetailsOf)(THIS_ LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails) PURE;
    STDMETHOD(ColumnClick)(THIS_ UINT iColumn) PURE;
};



//-------------------------------------------------------------------------
//
// ITaskbarList interface
//
//
// [Member functions]
//
// ITaskbarList::HrInit()
//   This function must be called first to validate use of other members.
//
// ITaskbarList::AddTab(hwnd)
//   This function adds a tab for hwnd to the taskbar.
//
// ITaskbarList::DeleteTab(hwnd)
//   This function deletes a tab for hwnd from the taskbar.
//
// ITaskbarList::ActivateTab(hwnd)
//   This function activates the tab associated with hwnd on the taskbar.
//
// ITaskbarList::SetActivateAlt(hwnd)
//   This function marks hwnd in the taskbar as the active tab
//
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE ITaskbarList

DECLARE_INTERFACE_(ITaskbarList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ITaskbarList specific methods ***
    STDMETHOD(HrInit) (THIS) PURE;
    STDMETHOD(AddTab) (THIS_ HWND hwnd) PURE;
    STDMETHOD(DeleteTab) (THIS_ HWND hwnd) PURE;
    STDMETHOD(ActivateTab) (THIS_ HWND hwnd) PURE;
    STDMETHOD(SetActiveAlt) (THIS_ HWND hwnd) PURE;
};

//-------------------------------------------------------------------------
//
// IObjMgr interface
//
//
// [Member functions]
//
// IObjMgr::Append(punk)
//   This function adds an object to the end of a list of objects.
//
// IObjMgr::Remove(punk)
//   This function removes an object from a list of objects.
//
// This is implemented by CLSID_ACLMulti so each AutoComplete List
// (CLSID_ACLHistory, CLSID_ACListISF, CLSID_ACLMRU) can be added.
// CLSID_ACLMulti's IEnumString will then be the union of the results
// from the COM Objects added.
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IObjMgr

DECLARE_INTERFACE_(IObjMgr, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IObjMgr specific methods ***
    STDMETHOD(Append) (THIS_ IUnknown *punk) PURE;
    STDMETHOD(Remove) (THIS_ IUnknown *punk) PURE;
};


//-------------------------------------------------------------------------
//
// ICurrentWorkingDirectory interface
//
//
// [Member functions]
//
// ICurrentWorkingDirectory::GetDirectory(LPWSTR pwzPath, DWORD cchSize)
//   This function gets the Current Working Directory from a COM object that
//   stores such state.
//
// ICurrentWorkingDirectory::SetDirectory(LPCWSTR pwzPath)
//   This function sets the Current Working Directory of a COM object that
//   stores such state.
//
// This function can be used generically.  One COM object that implements it
// is CLSID_ACListISF so that the AutoComplete engine can complete relative
// paths.  SetDirectory() will set the "Current Working Directory" and
// AutoComplete with then complete both absolute and relative paths.
// For Example, if ::SetDirectory(L"C:\Program Files") is called, then
// the user can AutoComplete "..\winnt".  In order to set the current
// working directory for non-file system paths, "ftp://ftp.microsoft.com/" or
// "Control Panel" for example, use IPersistFolder.
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE ICurrentWorkingDirectory

DECLARE_INTERFACE_(ICurrentWorkingDirectory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ICurrentWorkingDirectory specific methods ***
    STDMETHOD(GetDirectory) (THIS_ LPWSTR pwzPath, DWORD cchSize) PURE;
    STDMETHOD(SetDirectory) (THIS_ LPCWSTR pwzPath) PURE;
};


//-------------------------------------------------------------------------
//
// IACList interface
//
//
// [Member functions]
//
// IObjMgr::Expand(LPCOLESTR)
//   This function tells an autocomplete list to expand a specific string.
//
// If the user enters a multi-level path, AutoComplete (CLSID_AutoComplete)
// will use this interface to tell the "AutoComplete Lists" where to expand
// the results.
//
// For Example, if the user enters "C:\Program Files\Micros", AutoComplete
// first completely enumerate the "AutoComplete Lists" via IEnumString.  Then it
// will call the "AutoComplete Lists" with IACList::Expand(L"C:\Program Files").
// It will then enumerate the IEnumString interface again to get results in
// that directory.
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IACList

DECLARE_INTERFACE_(IACList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IACList specific methods ***
    STDMETHOD(Expand) (THIS_ LPCOLESTR pszExpand) PURE;
};

//-------------------------------------------------------------------------
//
// IACList2 interface
//
// [Description]
//              This interface exists to allow the caller to set filter criteria
// for an AutoComplete List.  AutoComplete Lists generates the list of
// possible AutoComplete completions.  CLSID_ACListISF is one AutoComplete
// List COM object that implements this interface.
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IACList2

typedef enum _tagAUTOCOMPLETELISTOPTIONS 
{
    ACLO_NONE            = 0,    // don't enumerate anything
    ACLO_CURRENTDIR      = 1,    // enumerate current directory
    ACLO_MYCOMPUTER      = 2,    // enumerate MyComputer
    ACLO_DESKTOP         = 4,    // enumerate Desktop Folder
    ACLO_FAVORITES       = 8,    // enumerate Favorites Folder
    ACLO_FILESYSONLY     = 16,   // enumerate only the file system
} AUTOCOMPLETELISTOPTIONS;

DECLARE_INTERFACE_(IACList2, IACList)
{
    // *** IACList2 specific methods ***
    STDMETHOD(SetOptions)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(GetOptions)(THIS_ DWORD* pdwFlag) PURE;
};


/*-------------------------------------------------------------------------*\
    INTERFACE: IProgressDialog

    DESCRIPTION:
        CLSID_ProgressDialog/IProgressDialog exist to allow a caller to create
    a progress dialog, set it's title, animation, text lines, progress, and
    it will do all the work of updating on a background thread, being modless,
    handling the user cancelling the operation, and estimating the time remaining
    until the operation completes.

    USAGE:
        This is how the dialog is used during operations that require progress
    and the ability to cancel:
    {
        DWORD dwComplete, dwTotal;
        IProgressDialog * ppd;
        CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (void **)&ppd);
        ppd->SetTitle(L"My Slow Operation");                                // Set the title of the dialog.
        ppd->SetAnimation(hInstApp, IDA_OPERATION_ANIMATION);               // Set the animation to play.
        ppd->StartProgressDialog(hwndParent, punk, PROGDLG_AUTOTIME, NULL); // Display and enable automatic estimated time remaining.
        ppd->SetCancelMsg(L"Please wait while the current operation is cleaned up", NULL);   // Will only be displayed if Cancel button is pressed.

        dwComplete = 0;
        dwTotal = CalcTotalUnitsToDo();

        // Reset because CalcTotalUnitsToDo() took a long time and the estimated time
        // is based on the time between ::StartProgressDialog() and the first
        // ::SetProgress() call.
        ppd->Timer(PDTIMER_RESET, NULL);

        for (nIndex = 0; nIndex < nTotal; nIndex++)
        {
            if (TRUE == ppd->HasUserCancelled())
                break;

            ppd->SetLine(2, L"I'm processing item n", FALSE, NULL);
            dwComplete += DoSlowOperation();

            ppd->SetProgress(dwCompleted, dwTotal);
        }

        ppd->StopProgressDialog();
        ppd->Release();
    }
\*-------------------------------------------------------------------------*/

// Flags for IProgressDialog::StartProgressDialog() (dwFlags)
#define PROGDLG_NORMAL          0x00000000      // default normal progress dlg behavior
#define PROGDLG_MODAL           0x00000001      // the dialog is modal to its hwndParent (default is modeless)
#define PROGDLG_AUTOTIME        0x00000002      // automatically updates the "Line3" text with the "time remaining" (you cant call SetLine3 if you passs this!)
#define PROGDLG_NOTIME          0x00000004      // we dont show the "time remaining" if this is set. We need this if dwTotal < dwCompleted for sparse files
#define PROGDLG_NOMINIMIZE      0x00000008      // Do not have a minimize button in the caption bar.
#define PROGDLG_NOPROGRESSBAR   0x00000010      // Don't display the progress bar

// Time Actions (dwTimerAction)
#define PDTIMER_RESET       0x00000001       // Reset the timer so the progress will be calculated from now until the first ::SetProgress() is called so
                                             // those this time will correspond to the values passed to ::SetProgress().  Only do this before ::SetProgress() is called.


#undef  INTERFACE
#define INTERFACE   IProgressDialog

DECLARE_INTERFACE_(IProgressDialog, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IProgressDialog specific methods
    STDMETHOD(StartProgressDialog)(THIS_ HWND hwndParent, IUnknown * punkEnableModless, DWORD dwFlags, LPCVOID pvResevered) PURE;
    STDMETHOD(StopProgressDialog)(THIS) PURE;
    STDMETHOD(SetTitle)(THIS_ LPCWSTR pwzTitle) PURE;
    STDMETHOD(SetAnimation)(THIS_ HINSTANCE hInstAnimation, UINT idAnimation) PURE;
    STDMETHOD_(BOOL,HasUserCancelled) (THIS) PURE;
    STDMETHOD(SetProgress)(THIS_ DWORD dwCompleted, DWORD dwTotal) PURE;
    STDMETHOD(SetProgress64)(THIS_ ULONGLONG ullCompleted, ULONGLONG ullTotal) PURE;
    STDMETHOD(SetLine)(THIS_ DWORD dwLineNum, LPCWSTR pwzString, BOOL fCompactPath, LPCVOID pvResevered) PURE;
    STDMETHOD(SetCancelMsg)(THIS_ LPCWSTR pwzCancelMsg, LPCVOID pvResevered) PURE;
    STDMETHOD(Timer)(THIS_ DWORD dwTimerAction, LPCVOID pvResevered) PURE;
};


//==========================================================================
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================

//-------------------------------------------------------------------------
//
// IInputObjectSite interface
//
//   A site implements this interface so the object can communicate
// focus change to it.
//
// [Member functions]
//
// IInputObjectSite::OnFocusChangeIS(punkObj, fSetFocus)
//   Object (punkObj) is getting or losing the focus.
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IInputObjectSite

DECLARE_INTERFACE_(IInputObjectSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInputObjectSite specific methods ***
    STDMETHOD(OnFocusChangeIS)(THIS_ IUnknown* punkObj, BOOL fSetFocus) PURE;
};


//-------------------------------------------------------------------------
//
// IInputObject interface
//
//   An object implements this interface so the site can communicate
// activation and accelerator events to it.
//
// [Member functions]
//
// IInputObject::UIActivateIO(fActivate, lpMsg)
//   Activates or deactivates the object.  lpMsg may be NULL.  Returns
//   S_OK if the activation succeeded.
//
// IInputObject::HasFocusIO()
//   Returns S_OK if the object has the focus, S_FALSE if not.
//
// IInputObject::TranslateAcceleratorIO(lpMsg)
//   Allow the object to process the message.  Returns S_OK if the
//   message was processed (eaten).
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IInputObject

DECLARE_INTERFACE_(IInputObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInputObject specific methods ***
    STDMETHOD(UIActivateIO)(THIS_ BOOL fActivate, LPMSG lpMsg) PURE;
    STDMETHOD(HasFocusIO)(THIS) PURE;
    STDMETHOD(TranslateAcceleratorIO)(THIS_ LPMSG lpMsg) PURE;
};


//==========================================================================
// IDockingWindowSite/IDockingWindow/IDockingWindowFrame interfaces
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================


//-------------------------------------------------------------------------
//
// IDockingWindowSite interface
//
//   A site implements this interface so the object can negotiate for
// and inquire about real estate on the site.
//
// [Member functions]
//
// IDockingWindowSite::GetBorderDW(punkObj, prcBorder)
//   Site returns the bounding rectangle of the given source object
//   (punkObj).
//
// IDockingWindowSite::RequestBorderSpaceDW(punkObj, pbw)
//   Object requests that the site makes room for it, as specified in
//   *pbw.
//
// IDockingWindowSite::SetBorderSpaceDW(punkObj, pbw)
//   Object requests that the site set the border spacing to the size
//   specified in *pbw.
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IDockingWindowSite

DECLARE_INTERFACE_(IDockingWindowSite, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowSite methods ***
    STDMETHOD(GetBorderDW) (THIS_ IUnknown* punkObj, LPRECT prcBorder) PURE;
    STDMETHOD(RequestBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(SetBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
};



//-------------------------------------------------------------------------
//
// IDockingWindowFrame interface
//
//
// [Member functions]
//
// IDockingWindowFrame::AddToolbar(punkSrc, pwszItem, dwReserved)
//
// IDockingWindowFrame::RemoveToolbar(punkSrc, dwRemoveFlags)
//
// IDockingWindowFrame::FindToolbar(pwszItem, riid, ppv)
//
//-------------------------------------------------------------------------


// flags for RemoveToolbar
#define DWFRF_NORMAL            0x0000
#define DWFRF_DELETECONFIGDATA  0x0001


// flags for AddToolbar
#define DWFAF_HIDDEN  0x0001   // add hidden

#undef  INTERFACE
#define INTERFACE   IDockingWindowFrame

DECLARE_INTERFACE_(IDockingWindowFrame, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowFrame methods ***
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwAddFlags) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc, DWORD dwRemoveFlags) PURE;
    STDMETHOD(FindToolbar) (THIS_ LPCWSTR pwszItem, REFIID riid, void **ppv) PURE;
};



#if (_WIN32_IE >= 0x0400)

//-------------------------------------------------------------------------
//
// IRunnableTask interface
//
//   This is a free threaded interface used for putting items on a background
// scheduler for execution within the view.  It allows a scheduler to start and
// stop tasks on as many worker threads as it deems necessary.
//
// Run(), Kill() and Suspend() may be called from different threads.
//
// [Member functions]
//
// IRunnableTask::Run(void)
//   Initiate the task to run.  This should return E_PENDING if the task
//   has been suspended.
//
// IRunnableTask::Kill(void)
//
// IRunnableTask::Suspend(void)
//
// IRunnableTask::Resume(void)
//
// IRunnableTask::IsRunning(void)
//
//-------------------------------------------------------------------------

// Convenient state values
#define IRTIR_TASK_NOT_RUNNING  0
#define IRTIR_TASK_RUNNING      1
#define IRTIR_TASK_SUSPENDED    2
#define IRTIR_TASK_PENDING      3
#define IRTIR_TASK_FINISHED     4

#undef  INTERFACE
#define INTERFACE   IRunnableTask

DECLARE_INTERFACE_( IRunnableTask, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IRunnableTask methods ***
    STDMETHOD (Run)(THIS) PURE;
    STDMETHOD (Kill)(THIS_ BOOL fWait ) PURE;
    STDMETHOD (Suspend)(THIS) PURE;
    STDMETHOD (Resume)(THIS) PURE;
    STDMETHOD_(ULONG, IsRunning)(THIS) PURE;
};

typedef IRunnableTask * LPRUNNABLETASK;
#endif


#if (_WIN32_IE >= 0x0400)

// --- IExtractImage
// this interface is provided for objects to provide a thumbnail image.
// IExtractImage::GetLocation()
//      Gets a path description of the image that is to be extracted. This is used to
//      identify the image in the view so that multiple instances of the same image can reuse the
//      original image. If *pdwFlags == IEIFLAG_ASYNC and the result is E_PENDING, then *pdwPriority
//      is used to return the priority of the item, this is usually a measure of how long it will take
//      to perform the extraction. *pdwFlags can return IEIFLAG_CACHE if the view should cache a copy
//      of the image for future reference and faster access. This flag is use dto tell the difference
//      between file formats that cache a thumbnail image  such as Flashpix or Office documents, and those
//      that don't cache one.
// IExtractImage::Extract()
//      Extract the thumbnail of the specified size. If GetLocation() returned the values indicating
//      it is free-threaded and can be placed on a background thread. If the object
//      supports IRunnableTask as well, then long extractions can be started and paused as appropriate.
//      At this point it is asssumed the object is free-threaded.
//      If dwRecClrDepth contains a recommended Colour depth
//      If *phBmpthumbnail is non NULL, then it contains the destination bitmap that should be used.

#define IEI_PRIORITY_MAX        ITSAT_MAX_PRIORITY
#define IEI_PRIORITY_MIN        ITSAT_MIN_PRIORITY
#define IEIT_PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY

#define IEIFLAG_ASYNC       0x0001      // ask the extractor if it supports ASYNC extract (free threaded)
#define IEIFLAG_CACHE       0x0002      // returned from the extractor if it does NOT cache the thumbnail
#define IEIFLAG_ASPECT      0x0004      // passed to the extractor to beg it to render to the aspect ratio of the supplied rect
#define IEIFLAG_OFFLINE     0x0008      // if the extractor shouldn't hit the net to get any content neede for the rendering
#define IEIFLAG_GLEAM       0x0010      // does the image have a gleam ? this will be returned if it does
#define IEIFLAG_SCREEN      0x0020      // render as if for the screen  (this is exlusive with IEIFLAG_ASPECT )
#define IEIFLAG_ORIGSIZE    0x0040      // render to the approx size passed, but crop if neccessary
#define IEIFLAG_NOSTAMP     0x0080      // returned from the extractor if it does NOT want an icon stamp on the thumbnail
#define IEIFLAG_NOBORDER    0x0100      // returned from the extractor if it does NOT want an a border around the thumbnail

#undef  INTERFACE
#define INTERFACE   IExtractImage

DECLARE_INTERFACE_ ( IExtractImage, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IExtractImage methods ***
    STDMETHOD (GetLocation) ( THIS_ LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags ) PURE;

    STDMETHOD (Extract)( THIS_ HBITMAP * phBmpThumbnail) PURE;
};
typedef IExtractImage * LPEXTRACTIMAGE;


/* ***************** IExtractImage2
 * GetDateStamp : returns the date stamp associated with the image. If this image is already cached,
 *                then it is easy to find out if the image is out of date.
 */

#undef  INTERFACE
#define INTERFACE   IExtractImage

DECLARE_INTERFACE_ ( IExtractImage2, IExtractImage )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IExtractImage methods ***
    STDMETHOD (GetLocation) ( THIS_ LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags ) PURE;

    STDMETHOD (Extract)( THIS_ HBITMAP * phBmpThumbnail) PURE;

    // *** IExtractImage2 methods ***
    STDMETHOD (GetDateStamp)( THIS_ FILETIME * pDateStamp ) PURE;
};
typedef IExtractImage2 * LPEXTRACTIMAGE2;

/* ***************** IThumbnailCapture
 * CaptureThumbnail : takes an IHTMLDocument2 and returns a thumbnail of specified
 *                    size as an hbitmap
 */

#undef  INTERFACE
#define INTERFACE   IThumbnailCapture

DECLARE_INTERFACE_ ( IThumbnailCapture, IUnknown )
{
    // *** IThumbnailCapture methods ***
    STDMETHOD (CaptureThumbnail)    ( THIS_ const SIZE * pMaxSize,
                                      IUnknown * pHTMLDoc2,
                                      HBITMAP * phbmThumbnail ) PURE;
};
typedef IThumbnailCapture * LPTHUMBNAILCAPTURE;

#endif


#if (_WIN32_IE >= 0x400)
//
// We need to make sure that WININET.H is included before this interface is
// used because the COMPONENT structure uses INTERNET_MAX_URL_LENGTH
//
#ifdef _WININET_
//
//  Flags and structures used by IActiveDesktop
//

typedef struct _tagWALLPAPEROPT
{
    DWORD   dwSize;     // size of this Structure.
    DWORD   dwStyle;    // WPSTYLE_* mentioned above
}
WALLPAPEROPT;

typedef WALLPAPEROPT  *LPWALLPAPEROPT;
typedef const WALLPAPEROPT *LPCWALLPAPEROPT;

typedef struct _tagCOMPONENTSOPT
{
    DWORD   dwSize;             //Size of this structure
    BOOL    fEnableComponents;  //Enable components?
    BOOL    fActiveDesktop;     // Active desktop enabled ?
}
COMPONENTSOPT;

typedef COMPONENTSOPT   *LPCOMPONENTSOPT;
typedef const COMPONENTSOPT   *LPCCOMPONENTSOPT;

typedef struct _tagCOMPPOS
{
    DWORD   dwSize;             //Size of this structure
    int     iLeft;              //Left of top-left corner in screen co-ordinates.
    int     iTop;               //Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    int     izIndex;            // Indicates the Z-order of the component.
    BOOL    fCanResize;         // Is the component resizeable?
    BOOL    fCanResizeX;        // Resizeable in X-direction?
    BOOL    fCanResizeY;        // Resizeable in Y-direction?
    int     iPreferredLeftPercent;    //Left of top-left corner as percent of screen width
    int     iPreferredTopPercent;     //Top of top-left corner as percent of screen height
}
COMPPOS;

typedef COMPPOS *LPCOMPPOS;
typedef const COMPPOS *LPCCOMPPOS;

typedef struct  _tagCOMPSTATEINFO
{
    DWORD   dwSize;             // Size of this structure.
    int     iLeft;              // Left of the top-left corner in screen co-ordinates.
    int     iTop;               // Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    DWORD   dwItemState;        // State of the component (full-screen mode or split-screen or normal state.
}
COMPSTATEINFO;

typedef COMPSTATEINFO   *LPCOMPSTATEINFO;
typedef const COMPSTATEINFO *LPCCOMPSTATEINFO;



#define COMPONENT_TOP (0x3fffffff)  // izOrder value meaning component is at the top


// iCompType values
#define COMP_TYPE_HTMLDOC       0
#define COMP_TYPE_PICTURE       1
#define COMP_TYPE_WEBSITE       2
#define COMP_TYPE_CONTROL       3
#define COMP_TYPE_CFHTML        4
#define COMP_TYPE_MAX           4

// The following is the COMPONENT structure used in IE4.01, IE4.0 and Memphis. It is kept here for compatibility
// reasons.
typedef struct _tagIE4COMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL
}
IE4COMPONENT;

typedef IE4COMPONENT *LPIE4COMPONENT;
typedef const IE4COMPONENT *LPCIE4COMPONENT;

//
// The following is the new NT5 component structure. Note that the initial portion of this component exactly
// matches the IE4COMPONENT structure. All new fields are added at the bottom and the dwSize field is used to
// distinguish between IE4COMPONENT and the new COMPONENT structures.
//
typedef struct _tagCOMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL

    //New fields are added below. Everything above here must exactly match the IE4COMPONENT Structure.
    DWORD           dwCurItemState; // Current state of the Component.
    COMPSTATEINFO   csiOriginal;    // Original state of the component when it was first added.
    COMPSTATEINFO   csiRestored;    // Restored state of the component.
}
COMPONENT;

typedef COMPONENT *LPCOMPONENT;
typedef const COMPONENT *LPCCOMPONENT;


// Defines for dwCurItemState
#define IS_NORMAL               0x00000001
#define IS_FULLSCREEN           0x00000002
#define IS_SPLIT                0x00000004
#define IS_VALIDSIZESTATEBITS   (IS_NORMAL | IS_SPLIT | IS_FULLSCREEN)  // The set of IS_* state bits which define the "size" of the component - these bits are mutually exclusive.
#define IS_VALIDSTATEBITS       (IS_NORMAL | IS_SPLIT | IS_FULLSCREEN | 0x80000000 | 0x40000000)  // All of the currently defined IS_* bits.

////////////////////////////////////////////
// Flags for IActiveDesktop::ApplyChanges()
#define AD_APPLY_SAVE             0x00000001
#define AD_APPLY_HTMLGEN          0x00000002
#define AD_APPLY_REFRESH          0x00000004
#define AD_APPLY_ALL              (AD_APPLY_SAVE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH)
#define AD_APPLY_FORCE            0x00000008
#define AD_APPLY_BUFFERED_REFRESH 0x00000010
#define AD_APPLY_DYNAMICREFRESH   0x00000020

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaperOptions()
//           IActiveDesktop::SetWallpaperOptions()
#define WPSTYLE_CENTER      0
#define WPSTYLE_TILE        1
#define WPSTYLE_STRETCH     2
#define WPSTYLE_MAX         3


////////////////////////////////////////////
// Flags for IActiveDesktop::ModifyComponent()

#define COMP_ELEM_TYPE          0x00000001
#define COMP_ELEM_CHECKED       0x00000002
#define COMP_ELEM_DIRTY         0x00000004
#define COMP_ELEM_NOSCROLL      0x00000008
#define COMP_ELEM_POS_LEFT      0x00000010
#define COMP_ELEM_POS_TOP       0x00000020
#define COMP_ELEM_SIZE_WIDTH    0x00000040
#define COMP_ELEM_SIZE_HEIGHT   0x00000080
#define COMP_ELEM_POS_ZINDEX    0x00000100
#define COMP_ELEM_SOURCE        0x00000200
#define COMP_ELEM_FRIENDLYNAME  0x00000400
#define COMP_ELEM_SUBSCRIBEDURL 0x00000800
#define COMP_ELEM_ORIGINAL_CSI  0x00001000
#define COMP_ELEM_RESTORED_CSI  0x00002000
#define COMP_ELEM_CURITEMSTATE  0x00004000

#define COMP_ELEM_ALL   (COMP_ELEM_TYPE | COMP_ELEM_CHECKED | COMP_ELEM_DIRTY |                     \
                         COMP_ELEM_NOSCROLL | COMP_ELEM_POS_LEFT | COMP_ELEM_SIZE_WIDTH  |          \
                         COMP_ELEM_SIZE_HEIGHT | COMP_ELEM_POS_ZINDEX | COMP_ELEM_SOURCE |          \
                         COMP_ELEM_FRIENDLYNAME | COMP_ELEM_POS_TOP | COMP_ELEM_SUBSCRIBEDURL |     \
                         COMP_ELEM_ORIGINAL_CSI | COMP_ELEM_RESTORED_CSI | COMP_ELEM_CURITEMSTATE)


////////////////////////////////////////////
// Flags for IActiveDesktop::AddDesktopItemWithUI()
typedef enum tagDTI_ADTIWUI
{
    DTI_ADDUI_DEFAULT               = 0x00000000,
    DTI_ADDUI_DISPSUBWIZARD         = 0x00000001,
    DTI_ADDUI_POSITIONITEM          = 0x00000002,
};


////////////////////////////////////////////
// Flags for IActiveDesktop::AddUrl()
#define ADDURL_SILENT           0X0001


////////////////////////////////////////////
// Default positions for ADI
#define COMPONENT_DEFAULT_LEFT    (0xFFFF)
#define COMPONENT_DEFAULT_TOP     (0xFFFF)




//
//  Interface for manipulating the Active Desktop.
//

#undef INTERFACE
#define INTERFACE IActiveDesktop

DECLARE_INTERFACE_( IActiveDesktop, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktop methods
    STDMETHOD (ApplyChanges)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (GetWallpaper)(THIS_ LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwReserved) PURE;
    STDMETHOD (SetWallpaper)(THIS_ LPCWSTR pwszWallpaper, DWORD dwReserved) PURE;
    STDMETHOD (GetWallpaperOptions)(THIS_ LPWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (SetWallpaperOptions)(THIS_ LPCWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (GetPattern)(THIS_ LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved) PURE;
    STDMETHOD (SetPattern)(THIS_ LPCWSTR pwszPattern, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemOptions)(THIS_ LPCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (SetDesktopItemOptions)(THIS_ LPCCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItem)(THIS_ LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItemWithUI)(THIS_ HWND hwnd, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (ModifyDesktopItem)(THIS_ LPCCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (RemoveDesktopItem)(THIS_ LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemCount)(THIS_ LPINT lpiCount, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItem)(THIS_ int nComponent, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemByID)(THIS_ ULONG_PTR dwID, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GenerateDesktopItemHtml)(THIS_ LPCWSTR pwszFileName, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddUrl)(THIS_ HWND hwnd, LPCWSTR pszSource, LPCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (GetDesktopItemBySource)(THIS_ LPCWSTR pwszSource, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
};

typedef IActiveDesktop * LPACTIVEDESKTOP;


#endif // _WININET_

#if (_WIN32_IE >= 0x0500)

#define MAX_COLUMN_NAME_LEN 80
#define MAX_COLUMN_DESC_LEN 128

#include <pshpack1.h>

typedef struct {
    SHCOLUMNID  scid;                           // OUT the unique identifier of this column
    VARTYPE     vt;                             // OUT the native type of the data returned
    DWORD       fmt;                            // OUT this listview format (LVCFMT_LEFT, usually)
    UINT        cChars;                         // OUT the default width of the column, in characters
    DWORD       csFlags;                        // OUT SHCOLSTATE flags
    WCHAR wszTitle[MAX_COLUMN_NAME_LEN];        // OUT the title of the column
    WCHAR wszDescription[MAX_COLUMN_DESC_LEN];  // OUT full description of this column
} SHCOLUMNINFO, *LPSHCOLUMNINFO;
typedef const SHCOLUMNINFO* LPCSHCOLUMNINFO;

#include <poppack.h>        /* Return to default */

#include <pshpack8.h>  

typedef struct {
    ULONG   dwFlags;              // initialization flags
    ULONG   dwReserved;           // reserved for future use.
    WCHAR   wszFolder[MAX_PATH];  // fully qualified folder path (or empty if multiple folders)
} SHCOLUMNINIT, *LPSHCOLUMNINIT;
typedef const SHCOLUMNINIT* LPCSHCOLUMNINIT;

#define SHCDF_UPDATEITEM        0x00000001      // this flag is a hint that the file has changed since the last call to GetItemData

typedef struct {
    ULONG   dwFlags;             // combination of SHCDF_ flags.
    DWORD   dwFileAttributes;    // file attributes.
    ULONG   dwReserved;          // reserved for future use.
    WCHAR*  pwszExt;             // address of file name extension
    WCHAR   wszFile[MAX_PATH];   // Absolute path of file.
} SHCOLUMNDATA, *LPSHCOLUMNDATA;
typedef const SHCOLUMNDATA* LPCSHCOLUMNDATA;

#include <poppack.h>        /* Return to byte packing */

#undef INTERFACE
#define INTERFACE IColumnProvider

// Note: these objects must be threadsafe!  GetItemData _will_ be called
// simultaneously from multiple threads.
DECLARE_INTERFACE_(IColumnProvider, IUnknown)
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IColumnProvider methods
    STDMETHOD (Initialize)(THIS_ LPCSHCOLUMNINIT psci) PURE;
    STDMETHOD (GetColumnInfo)(THIS_ DWORD dwIndex, SHCOLUMNINFO *psci) PURE;
    STDMETHOD (GetItemData)(THIS_ LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData) PURE;
};


///////////////////////////////////////////////////////
//
// Drag and Drop helper
//
// Purpose: To expose the Shell drag images
//
// This interface is implemented in the shell by CLSID_DragDropHelper.
// 
// To use:
//   If you are the source of a drag (i.e. in response to LV_DRAGBEGIN or 
//    equivelent begin drag message) call 
//    IDragSourceHelper::InitializeFromWindow
//              (<hwnd of window supporting DI_GETDRAGIMAGE>, 
//               <pointer to POINT indicating offset to the mouse from 
//                  the upper left corner of the image>, 
//               <pointer to data object>)
//
//      NOTE: The Data object must support IDataObject::SetData with multiple 
//            data types and GetData must implement data type cloning 
//            (Including HGLOBAL), not just aliasing.
//
//   If you wish to have an image while over your application add the 
//    IDragImages::Dr* calls to your IDropTarget implementation. For Example:
//
//    STDMETHODIMP CUserDropTarget::DragEnter(IDataObject* pDataObject, 
//                                            DWORD grfKeyState,
//                                            POINTL pt, DWORD* pdwEffect)
//    {
//          // Process your DragEnter
//          // Call IDragImages::DragEnter last. 
//          _pDropTargetHelper->DragEnter(_hwndDragOver, pDataObject, 
//                                        (POINT*)&pt, *pdwEffect);
//          return hres;
//    }
//
//
//   If you wish to be able to source a drag image from a custom control, 
//     implement a handler for the RegisterWindowMessage(DI_GETDRAGIMAGE).
//     The LPARAM is a pointer to an SHDRAGIMAGE structure.
//     
//      sizeDragImage  -   Calculate the length and width required to render 
//                          the images.
//      ptOffset       -   Calculate the offset from the upper left corner to 
//                          the mouse cursor within the image
//      hbmpDragImage  -   CreateBitmap( sizeDragImage.cx, sizeDragImage.cy, 
//                           GetDeviceCaps(hdcScreen, PLANES), 
//                           GetDeviceCaps(hdcScreen, BITSPIXEL),
//                           NULL);
//
//   Drag Images will only be displayed on Windows NT 5.0 or later.
//
//
//   Note about IDropTargetHelper::Show - This method is provided for 
//     showing/hiding the Drag image in low color depth video modes. When 
//     painting to a window that is currently being dragged over (i.e. For
//     indicating a selection) you need to hide the drag image by calling this
//     method passing FALSE. After the window is done painting, Show the image 
//     again by passing TRUE.

#include <pshpack8.h>  

typedef struct
{
    SIZE        sizeDragImage;      // OUT - The length and Width of the 
                                    //        rendered image
    POINT       ptOffset;           // OUT - The Offset from the mouse cursor to 
                                    //        the upper left corner of the image
    HBITMAP     hbmpDragImage;      // OUT - The Bitmap containing the rendered
                                    //        drag images
    COLORREF    crColorKey;         // OUT - The COLORREF that has been blitted 
                                    //        to the background of the images
} SHDRAGIMAGE, *LPSHDRAGIMAGE;

#include <poppack.h>        /* Return to byte packing */

// This is sent to a window to get the rendered images to a bitmap
// Call RegisterWindowMessage to get the ID
#define DI_GETDRAGIMAGE     TEXT("ShellGetDragImage")

#undef INTERFACE
#define INTERFACE IDropTargetHelper

DECLARE_INTERFACE_( IDropTargetHelper, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IDropTargetHelper
    STDMETHOD (DragEnter)(THIS_ HWND hwndTarget, IDataObject* pDataObject, 
                          POINT* ppt, DWORD dwEffect) PURE;
    STDMETHOD (DragLeave)(THIS) PURE;
    STDMETHOD (DragOver)(THIS_ POINT* ppt, DWORD dwEffect) PURE;
    STDMETHOD (Drop)(THIS_ IDataObject* pDataObject, POINT* ppt, 
                     DWORD dwEffect) PURE;
    STDMETHOD (Show)(THIS_ BOOL fShow) PURE;
    
};

#undef INTERFACE
#define INTERFACE IDragSourceHelper

DECLARE_INTERFACE_( IDragSourceHelper, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IDragSourceHelper
    STDMETHOD (InitializeFromBitmap)(THIS_ LPSHDRAGIMAGE pshdi, 
                                     IDataObject* pDataObject) PURE;
    STDMETHOD (InitializeFromWindow)(THIS_ HWND hwnd, POINT* ppt, 
                                     IDataObject* pDataObject) PURE;
};
#endif // _WIN32_IE >= 0x0500
#endif // _WIN32_IE

//==========================================================================
// Clipboard format which may be supported by IDataObject from system
// defined shell folders (such as directories, network, ...).
//==========================================================================

#define CFSTR_SHELLIDLIST                   TEXT("Shell IDList Array")      // CF_IDLIST
#define CFSTR_SHELLIDLISTOFFSET             TEXT("Shell Object Offsets")    // CF_OBJECTPOSITIONS
#define CFSTR_NETRESOURCES                  TEXT("Net Resource")            // CF_NETRESOURCE
#define CFSTR_FILEDESCRIPTORA               TEXT("FileGroupDescriptor")     // CF_FILEGROUPDESCRIPTORA
#define CFSTR_FILEDESCRIPTORW               TEXT("FileGroupDescriptorW")    // CF_FILEGROUPDESCRIPTORW
#define CFSTR_FILECONTENTS                  TEXT("FileContents")            // CF_FILECONTENTS
#define CFSTR_FILENAMEA                     TEXT("FileName")                // CF_FILENAMEA
#define CFSTR_FILENAMEW                     TEXT("FileNameW")               // CF_FILENAMEW
#define CFSTR_PRINTERGROUP                  TEXT("PrinterFriendlyName")     // CF_PRINTERS
#define CFSTR_FILENAMEMAPA                  TEXT("FileNameMap")             // CF_FILENAMEMAPA
#define CFSTR_FILENAMEMAPW                  TEXT("FileNameMapW")            // CF_FILENAMEMAPW
#define CFSTR_SHELLURL                      TEXT("UniformResourceLocator")
#define CFSTR_INETURLA                      CFSTR_SHELLURL
#define CFSTR_INETURLW                      TEXT("UniformResourceLocatorW")
#define CFSTR_PREFERREDDROPEFFECT           TEXT("Preferred DropEffect")
#define CFSTR_PERFORMEDDROPEFFECT           TEXT("Performed DropEffect")
#define CFSTR_PASTESUCCEEDED                TEXT("Paste Succeeded")
#define CFSTR_INDRAGLOOP                    TEXT("InShellDragLoop")
#define CFSTR_DRAGCONTEXT                   TEXT("DragContext")
#define CFSTR_MOUNTEDVOLUME                 TEXT("MountedVolume")
#define CFSTR_PERSISTEDDATAOBJECT           TEXT("PersistedDataObject")
#define CFSTR_TARGETCLSID                           TEXT("TargetCLSID")                         // HGLOBAL with a CLSID of the drop target
#define CFSTR_LOGICALPERFORMEDDROPEFFECT    TEXT("Logical Performed DropEffect")

#ifdef UNICODE
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORW
#define CFSTR_FILENAME          CFSTR_FILENAMEW
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPW
#define CFSTR_INETURL           CFSTR_INETURLW
#else
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORA
#define CFSTR_FILENAME          CFSTR_FILENAMEA
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPA
#define CFSTR_INETURL           CFSTR_INETURLA
#endif

#define DVASPECT_SHORTNAME      2 // use for CF_HDROP to get short name version of file paths
#define DVASPECT_COPY           3 // use to indicate format is a "Copy" of the data (FILECONTENTS, FILEDESCRIPTOR, etc)
#define DVASPECT_LINK           4 // use to indicate format is a "Shortcut" to the data (FILECONTENTS, FILEDESCRIPTOR, etc)

//
// format of CF_NETRESOURCE
//
typedef struct _NRESARRAY {     // anr
    UINT cItems;
    NETRESOURCE nr[1];
} NRESARRAY, * LPNRESARRAY;

//
// format of CF_IDLIST
//
typedef struct _IDA {
    UINT cidl;          // number of relative IDList
    UINT aoffset[1];    // [0]: folder IDList, [1]-[cidl]: item IDList
} CIDA, * LPIDA;

//
// FILEDESCRIPTOR.dwFlags field indicate which fields are to be used
//
typedef enum {
    FD_CLSID            = 0x0001,
    FD_SIZEPOINT        = 0x0002,
    FD_ATTRIBUTES       = 0x0004,
    FD_CREATETIME       = 0x0008,
    FD_ACCESSTIME       = 0x0010,
    FD_WRITESTIME       = 0x0020,
    FD_FILESIZE         = 0x0040,
    FD_PROGRESSUI       = 0x4000,       // Show Progress UI w/Drag and Drop
    FD_LINKUI           = 0x8000,       // 'link' UI is prefered
} FD_FLAGS;

typedef struct _FILEDESCRIPTORA { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    CHAR   cFileName[ MAX_PATH ];
} FILEDESCRIPTORA, *LPFILEDESCRIPTORA;

typedef struct _FILEDESCRIPTORW { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    WCHAR  cFileName[ MAX_PATH ];
} FILEDESCRIPTORW, *LPFILEDESCRIPTORW;

#ifdef UNICODE
#define FILEDESCRIPTOR      FILEDESCRIPTORW
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORW
#else
#define FILEDESCRIPTOR      FILEDESCRIPTORA
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORA
#endif

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct _FILEGROUPDESCRIPTORA { // fgd
     UINT cItems;
     FILEDESCRIPTORA fgd[1];
} FILEGROUPDESCRIPTORA, * LPFILEGROUPDESCRIPTORA;

typedef struct _FILEGROUPDESCRIPTORW { // fgd
     UINT cItems;
     FILEDESCRIPTORW fgd[1];
} FILEGROUPDESCRIPTORW, * LPFILEGROUPDESCRIPTORW;

#ifdef UNICODE
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORW
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORW
#else
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORA
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORA
#endif

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
typedef struct _DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
                                       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, *LPDROPFILES;


//====== File System Notification APIs ===============================
//

//
//  File System Notification flags
//

#define SHCNE_RENAMEITEM          0x00000001L
#define SHCNE_CREATE              0x00000002L
#define SHCNE_DELETE              0x00000004L
#define SHCNE_MKDIR               0x00000008L
#define SHCNE_RMDIR               0x00000010L
#define SHCNE_MEDIAINSERTED       0x00000020L
#define SHCNE_MEDIAREMOVED        0x00000040L
#define SHCNE_DRIVEREMOVED        0x00000080L
#define SHCNE_DRIVEADD            0x00000100L
#define SHCNE_NETSHARE            0x00000200L
#define SHCNE_NETUNSHARE          0x00000400L
#define SHCNE_ATTRIBUTES          0x00000800L
#define SHCNE_UPDATEDIR           0x00001000L
#define SHCNE_UPDATEITEM          0x00002000L
#define SHCNE_SERVERDISCONNECT    0x00004000L
#define SHCNE_UPDATEIMAGE         0x00008000L
#define SHCNE_DRIVEADDGUI         0x00010000L
#define SHCNE_RENAMEFOLDER        0x00020000L
#define SHCNE_FREESPACE           0x00040000L

#if (_WIN32_IE >= 0x0400)
// SHCNE_EXTENDED_EVENT: the extended event is identified in dwItem1,
// packed in LPITEMIDLIST format (same as SHCNF_DWORD packing).
// Additional information can be passed in the dwItem2 parameter
// of SHChangeNotify (called "pidl2" below), which if present, must also
// be in LPITEMIDLIST format.
//
// Unlike the standard events, the extended events are ORDINALs, so we
// don't run out of bits.  Extended events follow the SHCNEE_* naming 
// convention.
//
// The dwItem2 parameter varies according to the extended event.

#define SHCNE_EXTENDED_EVENT      0x04000000L
#endif      // _WIN32_IE >= 0x0400

#define SHCNE_ASSOCCHANGED        0x08000000L

#define SHCNE_DISKEVENTS          0x0002381FL
#define SHCNE_GLOBALEVENTS        0x0C0581E0L // Events that dont match pidls first
#define SHCNE_ALLEVENTS           0x7FFFFFFFL
#define SHCNE_INTERRUPT           0x80000000L // The presence of this flag indicates
                                            // that the event was generated by an
                                            // interrupt.  It is stripped out before
                                            // the clients of SHCNNotify_ see it.

#if (_WIN32_IE >= 0x0400)
// SHCNE_EXTENDED_EVENT extended events.  These events are ordinals.
// This is not a bitfield.

#define SHCNEE_ORDERCHANGED         2L  // pidl2 is the changed folder
#define SHCNEE_MSI_CHANGE           4L  // pidl2 is a SHChangeProductKeyAsIDList
#define SHCNEE_MSI_UNINSTALL        5L  // pidl2 is a SHChangeProductKeyAsIDList
#endif


// Flags
// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
#define SHCNF_IDLIST      0x0000        // LPITEMIDLIST
#define SHCNF_PATHA       0x0001        // path name
#define SHCNF_PRINTERA    0x0002        // printer friendly name
#define SHCNF_DWORD       0x0003        // DWORD
#define SHCNF_PATHW       0x0005        // path name
#define SHCNF_PRINTERW    0x0006        // printer friendly name
#define SHCNF_TYPE        0x00FF
#define SHCNF_FLUSH       0x1000
#define SHCNF_FLUSHNOWAIT 0x2000

#ifdef UNICODE
#define SHCNF_PATH      SHCNF_PATHW
#define SHCNF_PRINTER   SHCNF_PRINTERW
#else
#define SHCNF_PATH      SHCNF_PATHA
#define SHCNF_PRINTER   SHCNF_PRINTERA
#endif


//
//  APIs
//
SHSTDAPI_(void) SHChangeNotify(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);

//
// IShellChangeNotify
//
#undef  INTERFACE
#define INTERFACE  IShellChangeNotify

DECLARE_INTERFACE_(IShellChangeNotify, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellChangeNotify methods ***
    STDMETHOD(OnChange) (THIS_ LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
} ;

//
// IQueryInfo
//
//-------------------------------------------------------------------------
//
// IQueryInfo interface
//
// [Methods]
//              ::GetInfoTip()
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE  IQueryInfo

DECLARE_INTERFACE_(IQueryInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IQueryInfo methods ***
    STDMETHOD(GetInfoTip)(THIS_ DWORD dwFlags, WCHAR **ppwszTip) PURE;
    STDMETHOD(GetInfoFlags)(THIS_ DWORD *pdwFlags) PURE;
} ;

#define QITIPF_DEFAULT          0x00000000
#define QITIPF_USENAME          0x00000001
#define QITIPF_LINKNOTARGET     0x00000002
#define QITIPF_LINKUSETARGET    0x00000004
#define QITIPF_USESLOWTIP       0x00000008  // Flag says it's OK to take a long time generating tip

#define QIF_CACHED           0x00000001
#define QIF_DONTEXPANDFOLDER 0x00000002


//
// SHAddToRecentDocs
//
#define SHARD_PIDL      0x00000001L
#define SHARD_PATHA     0x00000002L
#define SHARD_PATHW     0x00000003L

#ifdef UNICODE
#define SHARD_PATH  SHARD_PATHW
#else
#define SHARD_PATH  SHARD_PATHA
#endif

SHSTDAPI_(void) SHAddToRecentDocs(UINT uFlags, LPCVOID pv);


#if (_WIN32_IE >= 0x0400)

                                                                        
typedef struct _SHChangeProductKeyAsIDList {
    USHORT cb;
    WCHAR wszProductKey[39];
    USHORT cbZero;
} SHChangeProductKeyAsIDList, *LPSHChangeProductKeyAsIDList;


SHSTDAPI_(void) SHUpdateImageA(LPCSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex);
SHSTDAPI_(void) SHUpdateImageW(LPCWSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex);
#ifdef UNICODE
#define SHUpdateImage  SHUpdateImageW
#else
#define SHUpdateImage  SHUpdateImageA
#endif // !UNICODE
#endif /* _WIN32_IE */


SHSTDAPI SHGetInstanceExplorer(IUnknown **ppunk);

//
// SHGetDataFromIDListA/W
//
// SHGetDataFromIDList nFormat values TCHAR
#define SHGDFIL_FINDDATA        1
#define SHGDFIL_NETRESOURCE     2
#define SHGDFIL_DESCRIPTIONID   3

#define SHDID_ROOT_REGITEM          1
#define SHDID_FS_FILE               2
#define SHDID_FS_DIRECTORY          3
#define SHDID_FS_OTHER              4
#define SHDID_COMPUTER_DRIVE35      5
#define SHDID_COMPUTER_DRIVE525     6
#define SHDID_COMPUTER_REMOVABLE    7
#define SHDID_COMPUTER_FIXED        8
#define SHDID_COMPUTER_NETDRIVE     9
#define SHDID_COMPUTER_CDROM        10
#define SHDID_COMPUTER_RAMDISK      11
#define SHDID_COMPUTER_OTHER        12
#define SHDID_NET_DOMAIN            13
#define SHDID_NET_SERVER            14
#define SHDID_NET_SHARE             15
#define SHDID_NET_RESTOFNET         16
#define SHDID_NET_OTHER             17
#define SHDID_COMPUTER_IMAGING      18
#define SHDID_COMPUTER_AUDIO        19
#define SHDID_COMPUTER_SHAREDDOCS   20

#include <pshpack8.h>  

typedef struct _SHDESCRIPTIONID {
    DWORD   dwDescriptionId;
    CLSID   clsid;
} SHDESCRIPTIONID, *LPSHDESCRIPTIONID;

#include <poppack.h>        /* Return to byte packing */

// these delegate to IShellFolder2::GetItemData()

SHSTDAPI SHGetDataFromIDListA(IShellFolder *psf, LPCITEMIDLIST pidl, int nFormat, void *pv, int cb);
SHSTDAPI SHGetDataFromIDListW(IShellFolder *psf, LPCITEMIDLIST pidl, int nFormat, void *pv, int cb);
#ifdef UNICODE
#define SHGetDataFromIDList  SHGetDataFromIDListW
#else
#define SHGetDataFromIDList  SHGetDataFromIDListA
#endif // !UNICODE


//===========================================================================


//
// PROPIDs for Internet Shortcuts (FMTID_Intshcut) to be used with
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_IS_URL          [VT_LPWSTR]   URL
//      PID_IS_NAME         [VT_LPWSTR]   Name of the internet shortcut
//      PID_IS_WORKINGDIR   [VT_LPWSTR]   Working directory for the shortcut
//      PID_IS_HOTKEY       [VT_UI2]      Hotkey for the shortcut
//      PID_IS_SHOWCMD      [VT_I4]       Show command for shortcut
//      PID_IS_ICONINDEX    [VT_I4]       Index into file that has icon
//      PID_IS_ICONFILE     [VT_LPWSTR]   File that has the icon
//      PID_IS_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_IS_AUTHOR       [VT_LPWSTR]   Author
//      PID_IS_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_IS_COMMENT      [VT_LPWSTR]   User annotated comment
//

#define PID_IS_URL           2
#define PID_IS_NAME          4
#define PID_IS_WORKINGDIR    5
#define PID_IS_HOTKEY        6
#define PID_IS_SHOWCMD       7
#define PID_IS_ICONINDEX     8
#define PID_IS_ICONFILE      9
#define PID_IS_WHATSNEW      10
#define PID_IS_AUTHOR        11
#define PID_IS_DESCRIPTION   12
#define PID_IS_COMMENT       13

//
// PROPIDs for Internet Sites (FMTID_InternetSite) to be used with
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_INTSITE_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_INTSITE_AUTHOR       [VT_LPWSTR]   Author
//      PID_INTSITE_LASTVISIT    [VT_FILETIME] Time site was last visited
//      PID_INTSITE_LASTMOD      [VT_FILETIME] Time site was last modified
//      PID_INTSITE_VISITCOUNT   [VT_UI4]      Number of times user has visited
//      PID_INTSITE_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_INTSITE_COMMENT      [VT_LPWSTR]   User annotated comment
//      PID_INTSITE_RECURSE      [VT_UI4]      Levels to recurse (0-3)
//      PID_INTSITE_WATCH        [VT_UI4]      PIDISM_ flags
//      PID_INTSITE_SUBSCRIPTION [VT_UI8]      Subscription cookie
//      PID_INTSITE_URL          [VT_LPWSTR]   URL
//      PID_INTSITE_TITLE        [VT_LPWSTR]   Title
//      PID_INTSITE_CODEPAGE     [VT_UI4]      Codepage of the document
//      PID_INTSITE_TRACKING     [VT_UI4]      Tracking
//      PID_INTSITE_ICONINDEX    [VT_I4]       Retrieve the index to the icon
//      PID_INTSITE_ICONFILE     [VT_LPWSTR]   Retrieve the file containing the icon index.


#define PID_INTSITE_WHATSNEW      2
#define PID_INTSITE_AUTHOR        3
#define PID_INTSITE_LASTVISIT     4
#define PID_INTSITE_LASTMOD       5
#define PID_INTSITE_VISITCOUNT    6
#define PID_INTSITE_DESCRIPTION   7
#define PID_INTSITE_COMMENT       8
#define PID_INTSITE_FLAGS         9
#define PID_INTSITE_CONTENTLEN    10
#define PID_INTSITE_CONTENTCODE   11
#define PID_INTSITE_RECURSE       12
#define PID_INTSITE_WATCH         13
#define PID_INTSITE_SUBSCRIPTION  14
#define PID_INTSITE_URL           15
#define PID_INTSITE_TITLE         16
#define PID_INTSITE_CODEPAGE      18
#define PID_INTSITE_TRACKING      19
#define PID_INTSITE_ICONINDEX     20
#define PID_INTSITE_ICONFILE      21


// Flags for PID_IS_FLAGS
#define PIDISF_RECENTLYCHANGED  0x00000001
#define PIDISF_CACHEDSTICKY     0x00000002
#define PIDISF_CACHEIMAGES      0x00000010
#define PIDISF_FOLLOWALLLINKS   0x00000020

// Values for PID_INTSITE_WATCH
#define PIDISM_GLOBAL           0       // Monitor based on global setting
#define PIDISM_WATCH            1       // User says watch
#define PIDISM_DONTWATCH        2       // User says don't watch


////////////////////////////////////////////////////////////////////
//
// The shell keeps track of some per-user state to handle display
// options that is of major interest to ISVs.
// The key one requested right now is "DoubleClickInWebView".
//
//  SysFiles are these windows special files:
//      "dll sys vxd 386 drv"
//
//  hidden files are files with the FILE_ATTRIBUTE_HIDDEN attribute
//
//  system files are files with the FILE_ATTRIBUTE_SYSTEM attribute
//
//      fShowAllObjects fShowSysFiles   Result
//      --------------- -------------   ------
//      0               0               hide hidden + SysFiles + system files
//      0               1               hide hidden files.
//      1               0               show all files.
//      1               1               show all files.
//
typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    UINT fRestFlags : 3;
} SHELLFLAGSTATE, * LPSHELLFLAGSTATE;

#define SSF_SHOWALLOBJECTS          0x00000001
#define SSF_SHOWEXTENSIONS          0x00000002
#define SSF_SHOWCOMPCOLOR           0x00000008
#define SSF_SHOWSYSFILES            0x00000020
#define SSF_DOUBLECLICKINWEBVIEW    0x00000080
#define SSF_SHOWATTRIBCOL           0x00000100
#define SSF_DESKTOPHTML             0x00000200
#define SSF_WIN95CLASSIC            0x00000400
#define SSF_DONTPRETTYPATH          0x00000800
#define SSF_SHOWINFOTIP             0x00002000
#define SSF_MAPNETDRVBUTTON         0x00001000
#define SSF_NOCONFIRMRECYCLE        0x00008000
#define SSF_HIDEICONS               0x00004000

// SHGetSettings(LPSHELLFLAGSTATE lpss, DWORD dwMask)
//
// Specify the bits you are interested in in dwMask and they will be
// filled out in the lpss structure.
//
// When these settings change, a WM_SETTINGCHANGE message is sent
// with the string lParam value of "ShellState".
//
SHSTDAPI_(void) SHGetSettings(LPSHELLFLAGSTATE lpsfs, DWORD dwMask);

// SHBindToParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
STDAPI SHBindToParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);



// SHPathPrepareForWrite(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszPath, DWORD dwFlags)
//
// DESCRIPTION:
//     This API will prepare the path for the caller.  This includes:
// 1. Prompting for the ejectable media to be re-inserted. (Floppy, CD-ROM, ZIP drive, etc.)
// 2. Prompting for the media to be formatted. (Floppy, hard drive, etc.)
// 3. Remount mapped drives if the connection was lost. (\\unc\share mapped to N: becomes disconnected)
// 4. If the path doesn't exist, create it.  (SHPPFW_DIRCREATE and SHPPFW_ASKDIRCREATE)
// 5. Display an error if the media is read only. (SHPPFW_NOWRITECHECK not set)
//                           
// PARAMETERS:
//      hwnd: Parernt window for UI.  NULL means don't display UI. OPTIONAL
//      punkEnableModless: Parent that will be set to modal during UI using IOleInPlaceActiveObject::EnableModeless(). OPTIONAL
//      pszPath: Path to verify is valid for writting.  This can be a UNC or file drive path.  The path
//               should only contain directories.  Pass SHPPFW_IGNOREFILENAME if the last path segment
//               is always filename to ignore.
//      dwFlags: SHPPFW_* Flags to modify behavior
//
//-------------------------------------------------------------------------
#define SHPPFW_NONE             0x00000000
#define SHPPFW_DEFAULT          SHPPFW_DIRCREATE        // May change
#define SHPPFW_DIRCREATE        0x00000001              // Create the directory if it doesn't exist without asking the user.
#define SHPPFW_ASKDIRCREATE     0x00000002              // Create the directory if it doesn't exist after asking the user.
#define SHPPFW_IGNOREFILENAME   0x00000004              // Ignore the last item in pszPath because it's a file.  Example: pszPath="C:\DirA\DirB", only use "C:\DirA".
#define SHPPFW_NOWRITECHECK     0x00000008              // Caller only needs to read from the drive, so don't check if it's READ ONLY.
#define SHPPFW_MEDIACHECKONLY   0x00000010              // do the retrys on the media (or net path), return errors if the file can't be found

STDAPI SHPathPrepareForWriteA(HWND hwnd, IUnknown *punkEnableModless, LPCSTR pszPath, DWORD dwFlags);
STDAPI SHPathPrepareForWriteW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pszPath, DWORD dwFlags);
#ifdef UNICODE
#define SHPathPrepareForWrite  SHPathPrepareForWriteW
#else
#define SHPathPrepareForWrite  SHPathPrepareForWriteA
#endif // !UNICODE



#ifdef __urlmon_h__
//    NOTE: urlmon.h must be included before shlobj.h to access this function.
//
//    SoftwareUpdateMessageBox
//
//    Provides a standard message box for the alerting the user that a software
//    update is available or installed. No UI will be displayed if there is no
//    update available or if the available update version is less than or equal
//    to the Advertised update version.
//
//    hWnd                - [in] Handle of owner window
//    szDistUnit          - [in] Unique identifier string for a code distribution unit. For
//                               ActiveX controls and Active Setup installed components, this
//                               is typically a GUID string.
//    dwFlags             - [in] Must be 0.
//    psdi                - [in,out] Pointer to SOFTDISTINFO ( see URLMon.h ). May be NULL.
//                                cbSize should be initialized
//                                by the caller to sizeof(SOFTDISTINFO), dwReserved should be set to 0.
//
//    RETURNS:
//
//    IDNO     - The user chose cancel. If *pbRemind is FALSE, the caller should save the
//               update version from the SOFTDISTINFO and pass it in as the Advertised
//               version in future calls.
//
//    IDYES    - The user has selected Update Now/About Update. The caller should navigate to
//               the SOFTDISTINFO's pszHREF to initiate the install or learn about it.
//               The caller should save the update version from the SOFTDISTINFO and pass
//               it in as the Advertised version in future calls.
//
//    IDIGNORE - There is no pending software update. Note: There is
//               no Ignore button in the standard UI. This occurs if the available
//               version is less than the installed version or is not present or if the
//               Advertised version is greater than or equal to the update version.
//
//    IDABORT  - An error occured. Call GetSoftwareUpdateInfo() for a more specific HRESULT.
//               Note: There is no Abort button in the standard UI.


SHDOCAPI_(DWORD) SoftwareUpdateMessageBox( HWND hWnd,
                                           LPCWSTR szDistUnit,
                                           DWORD dwFlags,
                                           LPSOFTDISTINFO psdi );
#endif // if __urlmon_h__



#ifdef __cplusplus
}

#endif  /* __cplusplus */

#include <poppack.h>

#endif // _SHLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\sdkp\inc\shlobjp.h ===
#ifndef _SHLOBJP_H_
#define _SHLOBJP_H_
#define NO_MONIKER
#include <docobj.h>
#include <shldisp.h>
#ifndef RC_INVOKED
#include <pshpack1.h>   /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */
// HMONITOR is already declared in NT 5's windef.h.
#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
DECLARE_HANDLE(HMONITOR);
#define HMONITOR_DECLARED
#endif
SHSTDAPI_(void *) SHAlloc(SIZE_T cb);
SHSTDAPI_(void *) SHRealloc(void * pv, SIZE_T cbNew);
SHSTDAPI_(SIZE_T)  SHGetSize(void * pv);
SHSTDAPI_(void)   SHFree(void * pv);
#define CMICEXSIZE_NT4          (SIZEOF(CMINVOKECOMMANDINFOEX) - SIZEOF(POINT))
#define CMIC_MASK_NO_HOOKS      SEE_MASK_NO_HOOKS
#define CMIC_MASK_DATAOBJECT    0x40000000   // lpPara is IDataObject*
#define CMIC_MASK_MODAL         0x80000000

#define CMIC_VALID_SEE_FLAGS    SEE_VALID_CMIC_FLAGS
//----------------------------------------------------------------------------
// Internal helper macro
//----------------------------------------------------------------------------

#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))
#define IToClassN(class, itf, pitf)  IToClass(class, itf, pitf)

//
// Helper macro definitions
//
#define S_BOOL(f)   MAKE_SCODE(SEVERITY_SUCCESS, 0, f)

#ifdef DEBUG
#define ReleaseAndAssert(punk) Assert(punk->lpVtbl->Release(punk)==0)
#else
#define ReleaseAndAssert(punk) (punk->lpVtbl->Release(punk))
#endif
// Property sheet ID for Explorer->View->Options File Types property sheet
// replacement.

#define EXPPS_FILETYPES 1
//  this interface is just the IID.  return back
//  a pointer to the IDropTarget interface if the
//  object calls DAD_DragLeave/DAD_SetDragImage
//  in its IDropTarget::Drop().
//
#define IDropTargetWithDADSupport IDropTarget
//===========================================================================
//
// IShellIconOverlayManager
//
// Used to return the icon overlay information including OverlayIndex, Image Index or Priority for an IShellFolder
// object, this is only inherited by CFSFolder_IconOverlayManager, it enumerates through all IconOverlayID's and
// keep their information in an array.
//
// IShellIconOverlayManager:GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//      pIndex          pointer to the Icon Index in the system image list
//      pOverlayIndex   pointer to the OverlayIndex in the system image list
//      pPriority       pointer to the Priority of this overlay
// IShellIconOverlayManager:GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags, int iReservedID)
//      iReservedID     reserved icon overlay id
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if lpfd is bad
// IShellIconOverlayManager:RefreshOverlayImages(DWORD dwFlags)
//      This will refresh the overlay cache, depends on the dwFlags passed in
//      It will reload the icons into the imagelist, when passed SIOM_ICONINDEX
// IShellIconOverlayManager::LoadNonloadedOverlayIdentifiers()
//      This method loads any registered overlay identifiers (handlers) that
//      are not currently loaded.
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayManager

DECLARE_INTERFACE_(IShellIconOverlayManager, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayManager methods ***
    STDMETHOD(GetFileOverlayInfo)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags) PURE;
    STDMETHOD(GetReservedOverlayInfo)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags, int iReservedID) PURE;
    STDMETHOD(RefreshOverlayImages)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(LoadNonloadedOverlayIdentifiers)(THIS) PURE;
    STDMETHOD(SetIndependentOverlay)(int iImage, int * piIndex) PURE;
};
#define SIOM_OVERLAYINDEX         1
#define SIOM_ICONINDEX            2
// #define SIOM_PRIORITY          3
#define SIOM_RESERVED_SHARED      0
#define SIOM_RESERVED_LINK        1
#define SIOM_RESERVED_SLOWFILE    2
//===========================================================================
//
// IBrowserBand
//
// IBrowserBand::GetObjectBB(REFIID riid, void **ppv)
//  Obtain a service from the web browser.
//
// IBrowserBand::SetBrowserBandInfo(DWORD dwMask, PBROWSERBANDINFO pbbi)
//  Set browser band properties based on members of browserbandinfo struct
//  specified by dwMask.  These properties include title, deskband mode, and
//  current size.
//
//===========================================================================

typedef struct {
    UINT    cbSize;
    DWORD   dwModeFlags;
    BSTR    bstrTitle;
    SIZE    sizeMin;
    SIZE    sizeMax;
    SIZE    sizeCur;
} BROWSERBANDINFO, *PBROWSERBANDINFO;

#define BBIM_MODEFLAGS  0x00000001
#define BBIM_TITLE      0x00000002
#define BBIM_SIZEMIN    0x00000004
#define BBIM_SIZEMAX    0x00000008
#define BBIM_SIZECUR    0x00000010

#undef  INTERFACE
#define INTERFACE  IBrowserBand
DECLARE_INTERFACE_(IBrowserBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBrowserBand methods ***
    STDMETHOD(GetObjectBB)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD(SetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) PURE;
    STDMETHOD(GetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) PURE;
};


typedef struct _TreeWalkerStats {
    int nFiles;               // number of files we have seen
    int nFolders;             // number of folders we have seen (does not include the root)
    int nDepth;               // the current depth
    DWORD dwClusterSize;      // cluster size of the disk we are currently on
    ULONGLONG  ulTotalSize;   // total size of all files we have seen
    ULONGLONG  ulActualSize;  // total size on disk of all files, taking into account compression, sparse files, and cluster slop
} TREEWALKERSTATS,  *LPTREEWALKERSTATS;

//===========================================================================
//
// IShellTreeWalkerCallBack Interface
// The callback interface for IShellTreeWalker
//
// All callbacks receives fully-qualified paths to the item found, being
// entered, being left, etc.
//
// Return values for all methods:
// S_OK    -- Normal, continue processing files, skip the problem file in error case
// S_FALSE -- Conitnue but quit the current directory
// E_NOTIMPL -- same as S_OK
// E_* -- Stop right away.
//
//===========================================================================
#undef  INTERFACE
#define INTERFACE   IShellTreeWalkerCallBack

DECLARE_INTERFACE_(IShellTreeWalkerCallBack, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellTreeWalkerCallBack methods ***
    STDMETHOD(FoundFile)(THIS_ LPCWSTR pwszPath, LPTREEWALKERSTATS ptws, WIN32_FIND_DATAW * pwfd) PURE;
    STDMETHOD(EnterFolder)(THIS_ LPCWSTR pwszPath, LPTREEWALKERSTATS ptws, WIN32_FIND_DATAW * pwfd) PURE;
    STDMETHOD(LeaveFolder)(THIS_ LPCWSTR pwszPath, LPTREEWALKERSTATS ptws) PURE;
    STDMETHOD(HandleError)(THIS_ LPCWSTR pwszPath, LPTREEWALKERSTATS ptws, HRESULT hrError) PURE;
};

typedef IShellTreeWalkerCallBack * LPSHELLTREEWALKERCALLBACK;

#define WT_FOLDERFIRST          0x00000001 // default to files first
#define WT_MAXDEPTH             0x00000002 // specify the maximum depth we go into
#define WT_FOLDERONLY           0x00000004 // only walks directories: default is to only return files
#define WT_NOTIFYFOLDERENTER    0x00000008 // notifies whenever entering a folder :default is to notify on every file
#define WT_NOTIFYFOLDERLEAVE    0x00000010 // notifies whenever leaving a folder
#define WT_GOINTOREPARSEPOINT   0x00000020 // default is to stop at any reparse points
#define WT_EXCLUDEWALKROOT      0x00000040 // default is to EnterFolder the starting point

#define WT_ALL                  0x0000007F

//===========================================================================
//
// IShellTreeWalker Interface
// The common File System tree traversal interface in shell.
//
// IShellTreeWalker::WalkTree(DWORD dwFlags, LPCWSTR pwszWalkRoot, LPCWSTR pwszWalkSpec, int iMaxPath, IShellTreeWalkerCallBack * pstwcb)
// Parameters:
// dwFlags      -- search flags: details above
// pwszWalkRoot -- the root directory to start from
// pwszWalkSpec -- the spec used to match files
// iMaxDepth    -- maximum depth to go into
// pstwcb       -- pointer to the callback interface
//
// Return Value:
// S_OK -- succeeded
// E_*  -- failed
//===========================================================================
#undef  INTERFACE
#define INTERFACE   IShellTreeWalker

DECLARE_INTERFACE_(IShellTreeWalker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellTreeWalker methods ***
    STDMETHOD(WalkTree)(THIS_ DWORD dwFlags, LPCWSTR pwszWalkRoot, LPCWSTR pwszWalkSpec, int iMaxPath, IShellTreeWalkerCallBack * pstwcb) PURE;
};

typedef IShellTreeWalker * LPSHELLTREEWALKER;

// NT4 Console Server included shell32\shlink.h to get structure
// definitions and mimicked shell32\shlink.c to understand the
// stream format so our stream format is fixed forever. This is
// not bad since it was designed with extension in mind. We need
// to publish (as privately as possible) the file format and
// structures needed to read the file format.
//
// The stream format is a SHELL_LINK_DATA followed by
//   if SLDF_HAS_ID_LIST an ILSaveToStream followed by
//   if SLDF_HAS_LINK_INFO a LINKINFO followed by
//   if SLDF_HAS_NAME a STREAMSTRING followed by
//   if SLDF_RELPATH a STREAMSTRING followed by
//   if SLDF_WORKINGDIR a STREAMSTRING followed by
//   if SLDF_HAS_ARGS a STREAMSTRING followed by
//   if SLDF_HAS_ICON_LOCATION a STREAMSTRING followed by
//   SHWriteDataBlockList list of signature blocks
//
// Where a STREAMSTRING is a USHORT count of characters
// followed by that many (SLDF_UNICODE ? WIDE : ANSI) characters.
//
typedef struct {        // sld
    DWORD       cbSize;                 // signature for this data structure
    CLSID       clsid;                  // our GUID
    DWORD       dwFlags;                // SHELL_LINK_DATA_FLAGS enumeration

    DWORD       dwFileAttributes;
    FILETIME    ftCreationTime;
    FILETIME    ftLastAccessTime;
    FILETIME    ftLastWriteTime;
    DWORD       nFileSizeLow;

    int         iIcon;
    int         iShowCmd;
    WORD        wHotkey;
    WORD        wUnused;
    DWORD       dwRes1;
    DWORD       dwRes2;
} SHELL_LINK_DATA, *LPSHELL_LINK_DATA;
typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
} EXP_HEADER, *LPEXP_HEADER;
typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    BYTE        abTracker[ 1 ];     //
} EXP_TRACKER, *LPEXP_TRACKER;
#define EXP_TRACKER_SIG                0xA0000003   // LPEXP_TRACKER
// NT40 Console Control Panel Applet does a CoCreateInstance(CLSID_CShellLink),
// used the CShellLink definition to get the 'this' pointer, and passed that
// along to some private exports in shell32. This completely prevents us
// from moving the CShellLink implementation to another DLL. (If we do, or an
// ISV takes our stream format and implements a better link by pointing the
// classid to their implementation, the NT40 Console CPA will fault.)
//
// To fix this problem in future revs, CShellLink will support IShellLinkDataList
//   AddDataBlock    adds the data block
//   FindDataBloc    returns a LocalAlloc()d COPY of a data block with the
//                   signature dwSig (NOTE: this is different than SHFindDataBlock)
//   RemoveDataBlock removes a data block with signature dwSig
// Plan is for NT50's Console CPA to use this interface instead.
//

//
// IURLSearchHook Interface is called whenever the browser navigates to a
// non-standard URL. It can be used to redirect the user's request to a
// search engine or a specific web site.
//
// A non-standard URL does not have a protocol prefix (e.g.,
// "www.microsoft.com") and the protocol cannot be easily guessed by
// the browser (e.g., "home.microsoft.com").
//
// The parameters of Translate(..)
//    lpwszSearchURL -- (IN/OUT) Wide char buffer that contains the request
//                      "URL" user typed in as input and the tranlated URL
//                      as output.
//    cchBufferSize  -- (IN) size of lpwszSearchURL
//
// Return Values:
// S_OK         Search handled completely, pszResult has the full URL to
//              browse to.  Stop running any further IURLSearchHooks and
//              pass this URL back to the browser for browsing.
//
// S_FALSE      Query has been preprocessed, pszResult has the result of
//              the preprocess, further search still needed. Go on
//              executing the rest of the IURLSearchHooks.  The
//              preprocessing steps can be:
//
//                      1. replaced certain characters
//                      2. added more hints
//
// E_ABORT      Search handled completely, stop running any further
//              IURLSearchHooks, but NO BROWSING NEEDED as a result,
//              pszResult is a copy of pcszQuery.
//
//              ;BUGBUG: This is not fully implemented, yet, making IURLQualify return this
//              involves too much change.
//
// BUGBUG:: E_ABORT is currently treated as E_FAIL. It requires too much change.
//
// E_FAIL       This Hook was unsuccessful. Search not handled at all,
//              pcszQueryURL has the query string. Please go on running
//              other IURLSearchHooks.
//
// BUGBUG:  There is a potential danger in this Interface, that is people can write
//          very bad SearchHooks, but we (Microsoft) take the blame.

// History:
//  --/--/94 KurtE Created
//
// History:
//  3/4/94 kraigb Created
//

//  CGID_DefView Command Target IDs. used to persist global DefView state

enum
{
    DVID_SETASDEFAULT,          // Set the DefView state of this folder as default for all of the same class
    DVID_RESETDEFAULT           // Reset the DefView state to the default (delete subkeys)
};

// CGID_ShellDocView Command Target IDs. for shell doc view wedge
enum {
    SHDVID_FINALTITLEAVAIL,     // DEAD: variantIn bstr - sent after final OLECMDID_SETTITLE is sent
    SHDVID_MIMECSETMENUOPEN,    // mimecharset menu open commands
    SHDVID_PRINTFRAME,          // print HTML frame
    SHDVID_PUTOFFLINE,          // DEAD: The Offline property has been changed
    SHDVID_PUTSILENT,           // DEAD: The frame's Silent property has been changed
    SHDVID_GOBACK,              // Navigate Back
    SHDVID_GOFORWARD,           // Navigate Forward
    SHDVID_CANGOBACK,           // Is Back Navigation Possible?
    SHDVID_CANGOFORWARD,        // Is Forward Navigation Possible?
    SHDVID_CANACTIVATENOW,      // (down) (PICS) OK to navigate to this view now?
    SHDVID_ACTIVATEMENOW,       // (up) (PICS) Rating checks out, navigate now
    SHDVID_CANSUPPORTPICS,      // (down) variantIn I4: IOleCommandTarget to reply to
    SHDVID_PICSLABELFOUND,      // (up) variantIn bstr: PICS label
    SHDVID_NOMOREPICSLABELS,    // (up) End of document, no more PICS labels coming
    SHDVID_CANDEACTIVATENOW,    // (QS down) (in script/etc) OK to deactivate view now?
    SHDVID_DEACTIVATEMENOW,     // (EXEC up) (in script/etc) out of script, deactivate view now
    SHDVID_NODEACTIVATENOW,     // (EXEC up) (in script/etc) entering script, disable deactivate
    SHDVID_AMBIENTPROPCHANGE,   // variantIn I4: dispid of ambient property that changed
    SHDVID_GETSYSIMAGEINDEX,    // variantOut: image index for current page
    SHDVID_GETPENDINGOBJECT,    // variantOut: IUnknown of pending shellview/docobject
    SHDVID_GETPENDINGURL,       // variantOut: BSTR of URL for pending docobject
    SHDVID_SETPENDINGURL,       // variantIn: BSTR of URL passed to pending docobject
    SHDVID_ISDRAGSOURCE,        // (down) varioutOut I4: non-zero if it's initiated drag&drop
    SHDVID_DOCFAMILYCHARSET,    // variantOut: I4: windows (family) codepage
    SHDVID_DOCCHARSET,          // variantOut: I4: actual (mlang) codepage
    SHDVID_RAISE,               // vaIn:I4:DTRF_*, vaOut:NULL unless DTRF_QUERY
    SHDVID_GETTRANSITION,       // (down) vaIn: I4: TransitionEvent; vaOut BSTR (CLSID), I4 (dwSpeed)
    SHDVID_GETMIMECSETMENU,     // get menu handle for mimecharset
    SHDVID_DOCWRITEABORT,       // Abort binding but activate pending docobject
    SHDVID_SETPRINTSTATUS,      // VariantIn: BOOL, TRUE - Started printing, FALSE - Finished printing
    SHDVID_NAVIGATIONSTATUS,    // QS for tooltip text and Exec when user clicks
    SHDVID_PROGRESSSTATUS,      // QS for tooltip text and Exec when user clicks
    SHDVID_ONLINESTATUS,        // QS for tooltip text and Exec when user clicks
    SHDVID_SSLSTATUS,           // QS for tooltip text and Exec when user clicks
    SHDVID_PRINTSTATUS,         // QS for tooltip text and Exec when user clicks
    SHDVID_ZONESTATUS,          // QS for tooltip text and Exec when user clicks
    SHDVID_ONCODEPAGECHANGE,    // variantIn I4: new specified codepage
    SHDVID_SETSECURELOCK,       // set the secure icon
    SHDVID_SHOWBROWSERBAR,      // show browser bar of clsid guid
    SHDVID_NAVIGATEBB,          // navigate to pidl in browserbar.
    SHDVID_UPDATEOFFLINEDESKTOP,// put the desktop in ON-LINE mode, update and put it back in Offline mode
    SHDVID_PICSBLOCKINGUI,      // (up) In I4: pointer to "ratings nugget" for block API
    SHDVID_ONCOLORSCHANGE,      // (up) sent by mshtml to indicate color set change
    SHDVID_CANDOCOLORSCHANGE,   // (down) used to query if document supports the above
    SHDVID_QUERYMERGEDHELPMENU, // was the help menu micro-merged?
    SHDVID_QUERYOBJECTSHELPMENU,// return the object's help menu
    SHDVID_HELP,                // do help
    SHDVID_UEMLOG,              // set UEM logging vaIn:I4:UEMIND_*, vaOut:NULL
    SHDVID_GETBROWSERBAR,       // get IDeskBand for browser bar of clsid guid
    SHDVID_GETFONTMENU,
    SHDVID_FONTMENUOPEN,
    SHDVID_CLSIDTOIDM,          // get the idm for the given clsid
    SHDVID_GETDOCDIRMENU,       // get menu handle for document direction
    SHDVID_ADDMENUEXTENSIONS,   // Context Menu Extensions
    SHDVID_CLSIDTOMONIKER,      // CLSID to property page resource mapping
    SHDVID_RESETSTATUSBAR,      // set the status bar back to "normal" icon w/out text
    SHDVID_ISBROWSERBARVISIBLE, // is browser bar of clsid guid visible?
    SHDVID_GETOPTIONSHWND,      // gets hwnd for internet options prop sheet (NULL if not open)
    SHDVID_DELEGATEWINDOWOM,    // set policy for whether window OM methods should be delegated.
    SHDVID_PAGEFROMPOSTDATA,    // determines if page was generated by post data
    SHDVID_DISPLAYSCRIPTERRORS, // tells the top docobject host to display his script err dialog
};

// CGID_SearchBand Command Target IDs.
enum {
    SBID_SEARCH_NEW,            // (re)load the context-appropriate url
    SBID_SEARCH_NEXT,           // cycle between multiple providers
    SBID_SEARCH_CUSTOMIZE,      // navigate to customization url
    SBID_SEARCH_HELP,           // what it says
    SBID_GETPIDL,               // get the search pane's pidl
};

//
//  this enum is used by SHDVID_SETSECURELOCK and SBCMDID_SETSECURELOCKICON
//  when adding new values, make sure to add to both SET and SUGGEST, and
//  the code depends on a direct correlation between the level of security
//  and the value of the enum.  so keep new values in the correct order
//
enum {
    SECURELOCK_NOCHANGE        = -1,
    SECURELOCK_SET_UNSECURE    = 0,
    SECURELOCK_SET_MIXED,
    SECURELOCK_SET_SECUREUNKNOWNBIT,
    SECURELOCK_SET_SECURE40BIT,
    SECURELOCK_SET_SECURE56BIT,
    SECURELOCK_SET_FORTEZZA,
    SECURELOCK_SET_SECURE128BIT,
    SECURELOCK_FIRSTSUGGEST,
    SECURELOCK_SUGGEST_UNSECURE = SECURELOCK_FIRSTSUGGEST,
    SECURELOCK_SUGGEST_MIXED,
    SECURELOCK_SUGGEST_SECUREUNKNOWNBIT,
    SECURELOCK_SUGGEST_SECURE40BIT,
    SECURELOCK_SUGGEST_SECURE56BIT,
    SECURELOCK_SUGGEST_FORTEZZA,
    SECURELOCK_SUGGEST_SECURE128BIT,
};

#define FCIDM_DRIVELIST    (FCIDM_BROWSERFIRST + 2) //
#define FCIDM_TREE         (FCIDM_BROWSERFIRST + 3) //
#define FCIDM_TABS         (FCIDM_BROWSERFIRST + 4) //
#define FCIDM_REBAR        (FCIDM_BROWSERFIRST + 5) //
typedef FOLDERSETTINGS *PFOLDERSETTINGS;
#define FCW_VIEW        0x0004
#define FCW_BROWSER     0x0005
#define FCW_MENUBAR     0x0007
#define FCW_ADDRESSBAR  0x0009
#define FCW_TOOLBAND    0x000a
#define FCW_LINKSBAR    0x000b
// CGID_Explorer Command Target IDs
enum {
    SBCMDID_ENABLESHOWTREE          = 0,
    SBCMDID_SHOWCONTROL             = 1,        // variant vt_i4 = loword = FCW_* hiword = SBSC_*
    SBCMDID_CANCELNAVIGATION        = 2,        // cancel last navigation
    SBCMDID_MAYSAVECHANGES          = 3,        // about to close and may save changes
    SBCMDID_SETHLINKFRAME           = 4,        // variant vt_i4 = phlinkframe
    SBCMDID_ENABLESTOP              = 5,        // variant vt_bool = fEnable
    SBCMDID_OPTIONS                 = 6,        // the view.options page
    SBCMDID_EXPLORER                = 7,        // are you explorer.exe?
    SBCMDID_ADDTOFAVORITES          = 8,
    SBCMDID_ACTIVEOBJECTMENUS       = 9,
    SBCMDID_MAYSAVEVIEWSTATE        = 10,       // Should we save view stream
    SBCMDID_DOFAVORITESMENU         = 11,       // popup the favorites menu
    SBCMDID_DOMAILMENU              = 12,       // popup the mail menu
    SBCMDID_GETADDRESSBARTEXT       = 13,       // get user-typed text
    SBCMDID_ASYNCNAVIGATION         = 14,       // do an async navigation
    SBCMDID_SEARCHBAROBSOLETE       = 15,       // OBSOLETE beta-1 SEARCHBAR
    SBCMDID_FLUSHOBJECTCACHE        = 16,       // flush object cache
    SBCMDID_CREATESHORTCUT          = 17,       // create a shortcut
    SBCMDID_SETMERGEDWEBMENU        = 18,       // set pre-merged menu for HTML
    SBCMDID_REMOVELOCKICON          = 19,       // Remove lock icon
    SBCMDID_SELECTHISTPIDL          = 20,       // QS:EXEC select history pidl on navigate
    SBCMDID_WRITEHIST               = 21,       // QS only:write history sf on navigate
    SBCMDID_GETHISTPIDL             = 22,       // EXEC gets most recent history pidl
    SBCMDID_REGISTERNSCBAND         = 23,       // EXEC registers NscBand when visible
    SBCMDID_COCREATEDOCUMENT        = 24,       // Create an instance of MSHTML
    SBCMDID_SETSECURELOCKICON       = 25,       // sets the SSL lock icon for the current page
    SBCMDID_INITFILECTXMENU         = 26,       // EXEC,QS: file context menu for band item
    SBCMDID_UNREGISTERNSCBAND       = 27,       // EXEC unregisters NscBand when invisible
    SBCMDID_SEARCHBAR               = 28,       // show/hide/toggle BrowserBar search
    SBCMDID_HISTORYBAR              = 29,       // show/hide/toggle BrowserBar history
    SBCMDID_FAVORITESBAR            = 30,       // show/hide/toggle BrowserBar favorites
#ifdef ENABLE_CHANNELS
    SBCMDID_CHANNELSBAR             = 31,       // show/hide/toggle BrowserBar channels
#endif
    SBCMDID_SENDPAGE                = 32,       // sends the current page via email
    SBCMDID_SENDSHORTCUT            = 33,       // sends a shortcut to current page via email
    SBCMDID_TOOLBAREMPTY            = 34,       // toolbar has nothing visible
    SBCMDID_EXPLORERBAR             = 35,       // show/hide/toggle BrowserBar all folders
    SBCMDID_GETUSERADDRESSBARTEXT   = 36,       // get the exact text the user-entered
    SBCMDID_HISTSFOLDER             = 37,       // EXEC varOut returns cached history IShellFolder
    SBCMDID_UPDATETRAVELLOG         = 38,       // updates the travellog with the current info
    SBCMDID_MIXEDZONE               = 39,       // The current view has mixed zones
    SBCMDID_REPLACELOCATION         = 40,       // replace the current URL with this one.
    SBCMDID_GETPANE                 = 41,       // Browser asks the view for pane ordinal
    SBCMDID_FILERENAME              = 42,       // Browser forwards file->rename to explorer bar
    SBCMDID_FILEDELETE              = 43,       // Browser forwards file->delete to explorer bar
    SBCMDID_FILEPROPERTIES          = 44,       // Browser forwards file->properties to explorer bar
    SBCMDID_IESHORTCUT              = 45,       // Navigates the browser to an .url file
    SBCMDID_GETSHORTCUTPATH         = 46,       // Asks for the path to the shortcut - if it exists
    SBCMDID_DISCUSSIONBAND          = 47,       // show/hide/toggle the Office discussion band
    SBCMDID_SETADDRESSBARFOCUS      = 48,       // Set focus on address bar on WM_ACTIVATE (UNIX)
    SBCMDID_HASADDRESSBARFOCUS      = 49,       // Checks whether address bar has focus (UNIX)
    SBCMDID_MSGBAND                 = 50,       // MsgBand Message (UNIX)
    SBCMDID_ISIEMODEBROWSER         = 51,       // returns S_OK if browser is in IE mode
    SBCMDID_GETTEMPLATEMENU         = 52,       // get handle to template menu
    SBCMDID_GETCURRENTMENU          = 53,       // get handle to current menu
    SBCMDID_ERRORPAGE               = 54,       // informs addressbar mru that this is an error page
    SBCMDID_AUTOSEARCHING           = 55,       // informs addressbar mru that we are trying a new url
    SBCMDID_STARTEDFORINTERNET      = 56,       // return S_OK if window started as IE window, S_FALSE otherwise
    SBCMDID_ISBROWSERACTIVE         = 57,       // return S_OK if the browser is active, S_FALSE otherwise
    SBCMDID_SUGGESTSAVEWINPOS       = 58,       // return S_OK if browser decides to save window position, S_FALSE otherwise
    SBCMDID_CACHEINETZONEICON       = 59,       // Cache/refresh internet zone icons painted by status bar
    SBCMDID_ONVIEWMOVETOTOP         = 60,       // Notification that the view window has moved to HWND_TOP
};

#define ZONE_UNKNOWN    -1
#define ZONE_MIXED      -2
#define IS_SPECIAL_ZONE(a) (((a) == ZONE_UNKNOWN) || ((a) == ZONE_MIXED))

// SBCMDID_GETPANE
#define PANE_NONE        -1
#define PANE_ZONE        1
#define PANE_OFFLINE     2
#define PANE_PRINTER     3
#define PANE_SSL         4
#define PANE_NAVIGATION  5
#define PANE_PROGRESS    6



#if (_WIN32_IE >= 0x0400)
// CGID_AddresseditBox Command Target IDs
enum {
    AECMDID_SAVE                    = 0,        // Ask AddressEditBox to save
};
#endif

// The pvid parameter of the GetView() method of IShellView2 is normally only an OUT parameter.
// But, for SV2GV_ISEXTENDEDVIEW, it is an IN parameter.
#define SV2GV_ISEXTENDEDVIEW    ((UINT)-3)
#define STRRET_OLESTR   0x0000          // same as STRRET_WSTR
#define STRRET_OFFPTR(pidl,lpstrret) ((LPSTR)((LPBYTE)(pidl)+(lpstrret)->NAMELESS_MEMBER(uOffset)))
SHSTDAPI_(int) SHCreateDirectory(HWND hwnd, LPCTSTR pszPath);	//
#define REGSTR_PATH_INTERNET_EXPLORER   TEXT("\\SOFTWARE\\Microsoft\\Internet Explorer")
#define REGSTR_PATH_IE_MAIN             REGSTR_PATH_INTERNET_EXPLORER TEXT("\\Main")
#define REGSTR_VALUE_USER_AGENT         TEXT("UserAgent")
#define REGSTR_DEFAULT_USER_AGENT       TEXT("Mozilla/2.0 (compatible; MSIE 3.0A; Windows 95)")
                                    //  0x000c
                                    //  0x000d
                                    //  0x000e
                                    //  0x000f
#define CSIDL_FLAG_DONT_UNEXPAND        0x2000        // combine with CSIDL_ value to avoid unexpanding environment variables
SHSTDAPI_(void) SHFlushSFCache(void);
SHSTDAPI_(LPITEMIDLIST) SHCloneSpecialIDList(HWND hwnd, int csidl, BOOL fCreate);
SHFOLDERAPI SHSetFolderPathA(int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszPath);
SHFOLDERAPI SHSetFolderPathW(int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszPath);
#ifdef UNICODE
#define SHSetFolderPath  SHSetFolderPathW
#else
#define SHSetFolderPath  SHSetFolderPathA
#endif // !UNICODE
#if (_WIN32_IE >= 0x0500)

#define FCS_READ                    0x00000001
#define FCS_FORCEWRITE              0x00000002
#define FCS_WRITE                   (FCS_READ | FCS_FORCEWRITE)

#define FCS_FLAG_DRAGDROP           2

// Mask which values have been retreived or being set.
#define FCSM_VIEWID                 0x00000001
#define FCSM_WEBVIEWTEMPLATE        0x00000002
#define FCSM_INFOTIP                0x00000004
#define FCSM_CLSID                  0x00000008
#define FCSM_ICONFILE               0x00000010
#define FCSM_LOGO                   0x00000020
#define FCSM_FLAGS                  0x00000040

// Used by SHGetSetFolderCustomSettingsA
typedef struct
{
    DWORD           dwSize;
    DWORD           dwMask;             // IN/OUT   Which Attributes to Get/Set
    SHELLVIEWID*    pvid;               // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // The folder's WebView template path
    LPSTR           pszWebViewTemplate;  // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchWebViewTemplate;  // IN - Specifies the size of the buffer pointed to by pszWebViewTemplate
                                        // Ignored if dwReadWrite is FCS_READ
    LPSTR           pszWebViewTemplateVersion;  // currently IN only
    // Infotip for the folder
    LPSTR           pszInfoTip;         // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchInfoTip;         // IN - Specifies the size of the buffer pointed to by pszInfoTip
                                        // Ignored if dwReadWrite is FCS_READ
    // CLSID that points to more info in the registry
    CLSID*          pclsid;             // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // Other flags for the folder. Takes FCS_FLAG_* values
    DWORD           dwFlags;            // OUT - if dwReadWrite is FCS_READ, IN - otherwise

    LPSTR           pszIconFile;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchIconFile;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                        // Ignored if dwReadWrite is FCS_READ

    int             iIconIndex;         // OUT - if dwReadWrite is FCS_READ, IN - otherwise

    LPSTR           pszLogo;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchLogo;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                        // Ignored if dwReadWrite is FCS_READ


} SHFOLDERCUSTOMSETTINGSA, *LPSHFOLDERCUSTOMSETTINGSA;
// Gets/Sets the Folder Custom Settings for pszPath based on dwReadWrite. dwReadWrite can be FCS_READ/FCS_WRITE/FCS_FORCEWRITE
HRESULT SHGetSetFolderCustomSettingsA(LPSHFOLDERCUSTOMSETTINGSA pfcs, LPCSTR pszPath, DWORD dwReadWrite);

// Used by SHGetSetFolderCustomSettingsW
typedef struct
{
    DWORD           dwSize;
    DWORD           dwMask;              // IN/OUT  Which Attributes to Get/Set
    SHELLVIEWID*    pvid;                // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // The folder's WebView template path
    LPWSTR          pszWebViewTemplate;   // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchWebViewTemplate;   // IN - Specifies the size of the buffer pointed to by pszWebViewTemplate
                                         // Ignored if dwReadWrite is FCS_READ
    LPWSTR           pszWebViewTemplateVersion;  // currently IN only
    // Infotip for the folder
    LPWSTR          pszInfoTip;          // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchInfoTip;          // IN - Specifies the size of the buffer pointed to by pszInfoTip
                                         // Ignored if dwReadWrite is FCS_READ
    // CLSID that points to more info in the registry
    CLSID*          pclsid;              // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // Other flags for the folder. Takes FCS_FLAG_* values
    DWORD           dwFlags;             // OUT - if dwReadWrite is FCS_READ, IN - otherwise


    LPWSTR           pszIconFile;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD            cchIconFile;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                         // Ignored if dwReadWrite is FCS_READ

    int              iIconIndex;         // OUT - if dwReadWrite is FCS_READ, IN - otherwise

    LPWSTR           pszLogo;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD            cchLogo;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                         // Ignored if dwReadWrite is FCS_READ
} SHFOLDERCUSTOMSETTINGSW, *LPSHFOLDERCUSTOMSETTINGSW;
// Gets/Sets the Folder Custom Settings for pszPath based on dwReadWrite. dwReadWrite can be FCS_READ/FCS_WRITE/FCS_FORCEWRITE
HRESULT SHGetSetFolderCustomSettingsW(LPSHFOLDERCUSTOMSETTINGSW pfcs, LPCWSTR pszPath, DWORD dwReadWrite);

#ifdef UNICODE
#define SHFOLDERCUSTOMSETTINGS          SHFOLDERCUSTOMSETTINGSW
#define SHGetSetFolderCustomSettings    SHGetSetFolderCustomSettingsW
#define LPSHFOLDERCUSTOMSETTINGS        LPSHFOLDERCUSTOMSETTINGSW
#else
#define SHFOLDERCUSTOMSETTINGS          SHFOLDERCUSTOMSETTINGSA
#define SHGetSetFolderCustomSettings    SHGetSetFolderCustomSettingsA
#define LPSHFOLDERCUSTOMSETTINGS        LPSHFOLDERCUSTOMSETTINGSA
#endif

#endif  // _WIN32_IE >= 0x0500
    // pszTitle can be a resource, but the hinst is assumed to be shell32.dll
    // lpszTitle can be a resource, but the hinst is assumed to be shell32.dll

//-------------------------------------------------------------------------
//
// Shell Service Object
//
//-------------------------------------------------------------------------
// Cmds for CGID_ShellServiceObject
enum {
    SSOCMDID_LOAD        = 0,
    SSOCMDID_UNLOAD      = 1,
    SSOCMDID_OPEN        = 2,
    SSOCMDID_CLOSE       = 3,
    SSOCMDID_STARTMENU   = 4,
    SSOCMDID_SAVETODOCUMENT=5,
};
#define CMDID_SAVEASTHICKET  SSOCMDID_SAVETODOCUMENT

//-------------------------------------------------------------------------
//
// Internet Shortcut Object
//
//-------------------------------------------------------------------------
// Cmds for CGID_ShortCut
enum {
    ISHCUTCMDID_DOWNLOADICON  = 0,
    ISHCUTCMDID_INTSHORTCUTCREATE = 1,
};
#define CMDID_INTSHORTCUTCREATE ISHCUTCMDID_INTSHORTCUTCREATE



//-------------------------------------------------------------------------
// STR_DISPLAY_UI_DURING_BINDING - IBindCtx Key
//-------------------------------------------------------------------------
// If displaying UI during binding is allowed, this parameter
// will be in the IBindCtx so the object binding can get the
// IUnknown* of the site in order to:
// 1. Use the site's hwnd as the parent hwnd of any UI dialogs.
//    This is done via. IOleWindow::GetWindow() or IInternetSecurityMgrSite::GetWindow()
// 2. While the dialog is being displayed, make the site modal
//    This is done via:
//       IOleInPlaceActiveObject::EnableModeless()
//       IOleInPlaceUIWindow::EnableModelessSB()
//       IInternetSecurityMgrSite::EnableModeless()

#define STR_DISPLAY_UI_DURING_BINDING      L"UI During Binding"


//  This member function should always create a new
//
//  SHCIDS_ALLFIELDS is a mask for lParam indicating that the shell folder
//  should first compare on the lParam column, and if that proves equal,
//  then perform a full comparison on all fields.  This flag is supported
//  if the IShellFolder supports IShellFolder2.
//
//  If you add more flags in the future, you need to enhance the return
//  value from SFVM_SUPPORTSIDENTITY.
//
// IShellFolderFilterSite

#undef  INTERFACE
#define INTERFACE       IShellFolderFilterSite

DECLARE_INTERFACE_(IShellFolderFilterSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderFilterSite methods ***
    STDMETHOD(SetFilter)(THIS_ IUnknown* punk) PURE;
};

// IIDListFilter

#undef  INTERFACE
#define INTERFACE       IShellFolderFilter

DECLARE_INTERFACE_(IShellFolderFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderFilter methods ***
    STDMETHOD(ShouldShow)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem) PURE;
    STDMETHOD(GetEnumFlags)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags) PURE;
};

//
// The IShellDetails interface was private in win95 and didnt have a _WIN32_IE guard,
// so it is now in shlobj.h, along with the definition of SHELLDETAILS
//


//-------------------------------------------------------------------------
//
// DELEGATEITEMID structure
//
//
// A Delegate Item ID is a standard SHITEMID with some additional
// fields defined.
//
//-------------------------------------------------------------------------

typedef struct tagDELEGATEITEMID {
    WORD cbSize;                // Size of entire item ID
    WORD wOuter;                // Private data owned by the outer folder
    WORD cbInner;               // Size of delegate's data
    BYTE rgb[1];                // Inner folder's data,
                                //   followed by outer folder's data.
} DELEGATEITEMID;

typedef const UNALIGNED DELEGATEITEMID *PCDELEGATEITEMID;
typedef UNALIGNED DELEGATEITEMID *PDELEGATEITEMID;


//-------------------------------------------------------------------------
//
// IDelegateFolder interface
//
//
// [Member functions]
//
// IDelegateFolder::SetItemAlloc(pm)
//   This function gives the object an IMalloc interface that it
//   should use to alloc and free item IDs.  These IDs are in the
//   form of DELEGATEITEMIDs.
//
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDelegateFolder

DECLARE_INTERFACE_(IDelegateFolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDelegateFolder methods ***
    STDMETHOD(SetItemAlloc)(THIS_ IMalloc *pmalloc) PURE;
};

#undef  INTERFACE
#define INTERFACE   IMountedVolume

DECLARE_INTERFACE_(IMountedVolume, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMountedVolume methods ***
    STDMETHOD(Initialize)(THIS_ LPCWSTR pcszHostFolderPath) PURE;
};
//-------------------------------------------------------------------------
// This is the interface for a browser to "subclass" the main File Cabinet
// window.  Note that only the hwnd, message, wParam, and lParam fields of
// the msg structure are used.  The browser window will get a WM_NOTIFY
// message with NULL ID, FCN_MESSAGE as the code, and a far pointer to
// FCMSG_NOTIFY as the lParam.
//
//-------------------------------------------------------------------------
typedef struct tagFCMSG_NOTIFY
{
    NMHDR   hdr;
    MSG     msg;
    LRESULT lResult;
} FCMSG_NOTIFY;

#define FCN_MESSAGE (100)


//---------------------------------------------------------------------------
// messages that can be send to the cabinet by other apps
//
// REVIEW: Do we really need to publish any of those?
//---------------------------------------------------------------------------

#define NF_INHERITVIEW 0x0000
#define NF_LOCALVIEW   0x0001

// Change the path of an existing folder.
// wParam:
//      0:              LPARAM is a pidl, handle the message immediately.
//      CSP_REPOST:     LPARAM is a pidl, copy the pidl and handle the
//                      message later.
//      CSP_NOEXECUTE:  if this path is not a folder, fail, don't shell exec
//
//
// lParam: LPITEMIDLIST of path.
//
//
#define CSP_REPOST                  0x0001
#define CSP_INITIATEDBYHLINKFRAME   0x0002
#define CSP_NOEXECUTE               0x0004
#define CSP_NONAVIGATE              0x0008
#define CWM_SETPATH                 (WM_USER + 2)

// lpsv points to the Shell View extension that requested idle processing
// uID is an app define identifier for the processor
// returns: TRUE if there is more idle processing necessary, FALSE if all done
// Note that the idle processor should do one "atomic" operation and return
// as soon as possible.
typedef BOOL (CALLBACK *FCIDLEPROC)(void *lpsv, UINT uID);

// Inform the File Cabinet that you want idle messages.
// This should ONLY be used by File Cabinet extensions.
// wParam: app define UINT (passed to FCIDLEPROC).
// lParam: pointer to an FCIDLEPROC.
// return: TRUE if successful; FALSE otherwise
//
#define CWM_WANTIDLE                (WM_USER + 3)

// get or set the FOLDERSETTINGS for a view
// wParam: BOOL TRUE -> set to view info buffer, FALSE -> get view info buffer
// lParam: LPFOLDERSETTINGS buffer to get or set view info
//
#define CWM_GETSETCURRENTINFO       (WM_USER + 4)
#define FileCabinet_GetSetCurrentInfo(_hwnd, _bSet, _lpfs) \
             SendMessage(_hwnd, CWM_GETSETCURRENTINFO, (WPARAM)(_bSet), (LPARAM)(LPFOLDERSETTINGS)_lpfs)

// selects the specified item in the current view
// wParam: SVSI_* flags
// lParam: LPCITEMIDLIST of the item ID, NULL -> all items
//
#define CWM_SELECTITEM              (WM_USER + 5)
#define FileCabinet_SelectItem(_hwnd, _sel, _item) \
            SendMessage(_hwnd, CWM_SELECTITEM, _sel, (LPARAM)(LPCITEMIDLIST)(_item))

// selects the specified path in the current view
// wParam: SVSI_* flags
// lParam: LPCSTR of the display name
//
#define CWM_SELECTPATH              (WM_USER + 6)
#define FileCabinet_SelectPath(_hwnd, _sel, _path)  \
            SendMessage(_hwnd, CWM_SELECTPATH, _sel, (LPARAM)(LPCSTR)(_path))

// Get the IShellBrowser object associated with an hwndMain
#define CWM_GETISHELLBROWSER        (WM_USER + 7)
#define FileCabinet_GetIShellBrowser(_hwnd)     \
            (IShellBrowser*)SendMessage(_hwnd, CWM_GETISHELLBROWSER, 0, 0L)

//
//  two pidls can have the same path, so we need a compare pidl message
#define CWM_COMPAREPIDL                (WM_USER + 9)
//
//  sent when the global state changes
#define CWM_GLOBALSTATECHANGE           (WM_USER + 10)
#define CWMF_GLOBALSTATE                0x0000
#define CWMF_SECURITY                   0x0001

//  sent to the desktop from a second instance
#define CWM_COMMANDLINE                 (WM_USER + 11)
// global clone your current pidl
#define CWM_CLONEPIDL                   (WM_USER + 12)
// See if the root of the instance is as specified
#define CWM_COMPAREROOT                 (WM_USER + 13)
// Tell desktop our root
#define CWM_SPECIFYCOMPARE              (WM_USER + 14)
// See if the root of the instance matches a hwnd
#define CWM_PERFORMCOMPARE              (WM_USER + 15)
// Forward SHChangeNotify events
#define CWM_FSNOTIFY                    (WM_USER + 16)
// Forward SHChangeRegistration events
#define CWM_CHANGEREGISTRATION          (WM_USER + 17)
// For AddToRecentDocs processing by desktop
#define CWM_ADDTORECENT                 (WM_USER + 18)
// For SHWaitForFile processing by desktopop
#define CWM_WAITOP                      (WM_USER + 19)

// Notify for changes to the fav's folder.
#define CWM_FAV_CHANGE                  (WM_USER + 20)
#define CWM_SHOWDRAGIMAGE               (WM_USER + 21)
#define CWM_SHOWFOLDEROPT               (WM_USER + 22)

#define CWM_FSNOTIFYSUSPENDRESUME       (WM_USER + 23)

#define CWM_RESERVEDFORCOMDLG_FIRST     (WM_USER + 100)
#define CWM_RESERVEDFORCOMDLG_LAST      (WM_USER + 199)
#define CWM_RESERVEDFORWEBBROWSER_FIRST (WM_USER + 200)
#define CWM_RESERVEDFORWEBBROWSER_LAST  (WM_USER + 299)
//   ;BUGBUG (scotth): fill this in
#define STFRF_NORMAL            DWFRF_NORMAL
#define STFRF_DELETECONFIGDATA  DWFRF_DELETECONFIGDATA
//
//   formerly IDockingWindow::SetToolbarSite
//   ;BUGBUG (scotth): what's the difference b/t punkToolbarSite
//                    and the punkSite provided by the
//                    SetToolbarSite method?

#undef  INTERFACE
#define INTERFACE   IMultiMonitorDockingSite

DECLARE_INTERFACE_(IMultiMonitorDockingSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMultiMonitorDockingSite methods ***
    STDMETHOD(GetMonitor) (THIS_ IUnknown* punkSrc, HMONITOR * phMon) PURE;
    STDMETHOD(RequestMonitor) (THIS_ IUnknown* punkSrc, HMONITOR * phMon) PURE;
    STDMETHOD(SetMonitor) (THIS_ IUnknown* punkSrc, HMONITOR hMonNew, HMONITOR *phMonOld) PURE;
};
#define DBIMF_FIXED             0x0001  //
#define DBIMF_FIXEDBMP          0x0004   // a fixed background bitmap (if supported)   //
#define DBIMF_UNDELETEABLE      0x0010   //
#define DBIMF_USECHEVRON        0x0080  //
#define DBIMF_BREAK             0x0100  //
// flags for DBID_PUSHCHEVRON
#define DBPC_SELECTFIRST    (DWORD)-1
#define DBPC_SELECTLAST     (DWORD)-2

#ifdef ISHELLTOOLBAND_COMPAT
#undef  INTERFACE
#define INTERFACE   IShellToolband

DECLARE_INTERFACE_(IShellToolband, IDockingWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindow methods ***
    STDMETHOD(ShowDW)         (THIS_ BOOL fShow) PURE;
    STDMETHOD(CloseDW)        (THIS_ DWORD dwReserved) PURE;
    STDMETHOD(ResizeBorderDW) (THIS_ LPCRECT   prcBorder,
                                     IUnknown* punkToolbarSite,
                                     BOOL      fReserved) PURE;
    // *** IShellToolband methods ***
    STDMETHOD(GetBandInfo)    (THIS_ DWORD fViewMode, LPPOINT pptSize,
                              LPWSTR pszTitle, int cchTitle, DWORD *dwSizeMode) PURE;
};

// IShellToolband Enum
typedef enum {
        STBE_MINSIZE = 0,
        STBE_MAXSIZE,
        STBE_INTEGRAL,
        STBE_ACTUAL,

        STBE_MAX   // how many are there?
} STBENUM;

// command target ids
enum {
        STBID_BANDINFOCHANGED,
};

#define STBBIF_VIEWMODE_NORMAL   0x0000
#define STBBIF_VIEWMODE_VERTICAL 0x0001
#define STBBIF_VIEWMODE_FLOATING 0x0002

#define STBBIF_SIZEMODE_NORMAL  0x0
#define STBBIF_SIZEMODE_FIXED   0x1
#define STBBIF_SIZEMODE_TITLE   0x2
#define STBBIF_SIZEMODE_FIXEDBMP 0x4   // a fixed background bitmap (if supported)
#define STBBIF_SIZEMODE_VARIABLEHEIGHT 0x8

#define STBBIF_DRAGMODE_UNDELETEABLE 0x10
#endif
#if (_WIN32_IE >= 0x0400)

#define TASKOWNERID     GUID
#define REFTASKOWNERID  REFGUID


// ---ITaskScheduler
// An interface for interacting with and controlling a task scheduler. This
// interface does not need to be free-threaded unless the items in the queue
// interact with the scheduler as well as the main execution thread on which the
// task scheduler was created.

// ITaskScheduler::AddTask()
//      Adds Tasks to the scheduler's background queue. The TASKOWNERID allow particular types
//      of tasks to be grouped so that they can be counted or removed. The lParam allows the task
//      to be associated with a particular item (for example an item in a listview).
// ITaskScheduler::RemoveTasks()
//      Removes tasks from the scheduler's queue. These can be sepcified in terms of their TASKOWNERID
//      or their LPARAM, or both, or neither (TOID_NULL && ITSAT_DEFAULT_LPARAM results in all tasks being
//      removed). If a task that matches is currently running and ITaskScheduler::Status() has been
//      passeed ITSSFLAG_KILL_ON_DESTROY then the scheduler will attempt to kill the current task. The
//      fWaitIfRunning parameter is then passed to IRunnableTask::Kill().
// ITaskScheduler::CountTasks()
//      Counts the tasks in the queue depending upon the TASKOWNERID and the LPARAM passed. (TOID_NULL and
//      ITSAT_DEFAULT_LPARAM will count all tasks in the queue)
// ITaskScheduler::Status()
//      This sets the ReleaseStatus for the current task and the background thread timeout. When
//      ITaskScheduler::RemoveTasks() is called and there is a task currently running that matches
//      ITSSFLAG_COMPLETE_ON_DESTROY will cause TRUE to be passed to the task's IRunnableTask::Kill().
//      The dwThreadTimeout parameter if not set to the default will cause the background thread to
//      die if no new tasks have been added to the queue in the timeout period. The Thread will be
//      recreated when the next new task is added.

////////////////////////
// Status() flags,
// wait for the current task to complete before deleting the scheduler
#define ITSSFLAG_COMPLETE_ON_DESTROY        0x0000

// kill the current task (if there is one) when the task scheduler is deleted
#define ITSSFLAG_KILL_ON_DESTROY            0x0001

#define ITSSFLAG_SUPPORTS_TERMINATE         0x0002

#define ITSSFLAG_FLAGS_MASK                 0x0003

// set the timeout for killing the thread when the object is terminated.
// this timeout can be used to stop the object from blocking the system
// indefinitely.
#define ITSSFLAG_THREAD_TERMINATE_TIMEOUT   0x0010

// set the timeout for threads that are idle in the thread pool
#define ITSSFLAG_THREAD_POOL_TIMEOUT        0x0020

// The default timeout passed to release Status to determine how long the thread
// can be asleep before the thread is expired
#define ITSS_THREAD_DESTROY_DEFAULT_TIMEOUT     (60*1000)

// default, we won't kill it...
#define ITSS_THREAD_TERMINATE_TIMEOUT           (INFINITE)

// there is no change to the thread timeout
#define ITSS_THREAD_TIMEOUT_NO_CHANGE           (INFINITE - 1)

// the LPARAM allows task to be associated with items thus all tasks owned by a
// particular item can be accessed by passing a non default value for this parameter
#define ITSAT_DEFAULT_LPARAM        0xffffffff

// Task priorities
// ---------------
// This depends on the cooperation of tasks currently under execution. New tasks will
// be inserted in the queue in priority order. If a task of a low priority is currently
// under execution when a higher priority task is added, the scheduler will attempt
// to suspend the task currently under execution. It will be resumed when the other tasks
// have been completed.
#define ITSAT_DEFAULT_PRIORITY      0x10000000
#define ITSAT_MAX_PRIORITY          0x7fffffff
#define ITSAT_MIN_PRIORITY          0x00000000

#define TOID_NULL   CLSID_NULL

#undef INTERFACE
#define INTERFACE IShellTaskScheduler

DECLARE_INTERFACE_( IShellTaskScheduler, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IShellTaskScheduler methods ***
    STDMETHOD (AddTask)(THIS_ IRunnableTask * pTask,
               REFTASKOWNERID rtoid,
               DWORD_PTR lParam,
               DWORD dwPriority ) PURE;

    STDMETHOD (RemoveTasks)(THIS_ REFTASKOWNERID rtoid,
               DWORD_PTR lParam,
               BOOL fWaitIfRunning ) PURE;

    STDMETHOD_(UINT, CountTasks)(THIS_ REFTASKOWNERID rtoid) PURE;

    STDMETHOD (Status)(THIS_ DWORD dwReleaseStatus, DWORD dwThreadTimeout ) PURE;
};

typedef IShellTaskScheduler * LPSHELLTASKSCHEDULER;


// --- IExtractImage
//-------------------------------------------------------------------------
//
// IThumbnail interface
//
//
// [Member functions]
//
// IThumbnail::Init(HWND hwnd, UINT uMsg)
//   Must initialize interface before use.  The hwnd given will receive the
//   uMsg message when the bitmap is computed (cf. GetBitmap()).
//
// IThumbnail::GetBitmap(LPCWSTR pwszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
//   Call this function to actually compute and return the bitmap.  pszFile is
//   the file UNC whose bitmap is to be computed.  lWidth and lHeight are the
//   width and height respectively of the rectangle containing the thumbnail,
//   i.e. the size of the resultant bitmap.  When the bitmap is computed, the
//   uMsg is sent to the hwnd (cf. Init()) where LPARAM is the HBITMAP, and
//   WPARAM is dwItem (so it's an ID to identify the bitmap).
//   NOTE: Call GetBitmap(NULL,...) to cancel any pending requests.
//
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IThumbnail

DECLARE_INTERFACE_(IThumbnail, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IThumbnail specific methods ***
    STDMETHOD(Init) (THIS_ HWND hwnd, UINT uMsg) PURE;
    STDMETHOD(GetBitmap) (THIS_ LPCWSTR wszFile, DWORD dwItem, LONG lWidth, LONG lHeight) PURE;
};

#endif
#if (_WIN32_IE >= 0x0400)

// Interface used to scale and sharpen images...
// right now, always pass the palette from SHCreateShellPalette on a 256 colour machine...
#undef  INTERFACE
#define INTERFACE   IScaleAndSharpenImage2

DECLARE_INTERFACE_ (IScaleAndSharpenImage2, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IScaleAndSharpenImage methods ***
    STDMETHOD( ScaleSharpen2 ) ( THIS_ BITMAPINFO * pbi,
                                void * pBits,
                                HBITMAP * phBmpThumbnail,
                                const SIZE * prgSize,
                                DWORD dwRecClrDepth,
                                HPALETTE hpal,
                                UINT uiSharpPct,
                                BOOL fOrigSize) PURE;
};

// IImageCache
// Interface for controlling and accessing an imagecache of bitmaps for icons..

// flags for the dwMask member of IMAGECACHEINFO
#define ICIFLAG_LARGE       0x0001
#define ICIFLAG_SMALL       0x0002
#define ICIFLAG_BITMAP      0x0004
#define ICIFLAG_ICON        0x0008
#define ICIFLAG_INDEX       0x0010
#define ICIFLAG_NAME        0x0020
#define ICIFLAG_FLAGS       0x0040
#define ICIFLAG_NOUSAGE     0x0080
#define ICIFLAG_DATESTAMP   0x0100
#define ICIFLAG_MIRROR      0x2000

typedef struct _tagImageCacheInfo
{
    DWORD        cbSize;
    DWORD        dwMask;
    union
    {
        HBITMAP  hBitmapLarge;
        HICON    hIconLarge;
    };
    HBITMAP      hMaskLarge;
    union
    {
        HBITMAP  hBitmapSmall;
        HICON    hIconSmall;
    };
    HBITMAP      hMaskSmall;
    LPCWSTR      pszName;
    int          iIndex;
    DWORD        dwFlags;
#if (_WIN32_IE >= 0x0500)
    FILETIME     ftDateStamp;
#endif
} IMAGECACHEINFO;

typedef IMAGECACHEINFO * LPIMAGECACHEINFO;
typedef const IMAGECACHEINFO * LPCIMAGECACHEINFO;

#define ICIIFLAG_LARGE          0x0001
#define ICIIFLAG_SMALL          0x0002

typedef struct _tagImageCacheInitInfo
{
    DWORD cbSize;
    DWORD dwMask;
    HIMAGELIST himlLarge;
    HIMAGELIST himlSmall;
    SIZEL rgSizeLarge;
    SIZEL rgSizeSmall;
    DWORD dwFlags;
    int   iStart;
    int   iGrow;
}IMAGECACHEINITINFO;

typedef IMAGECACHEINITINFO * LPIMAGECACHEINITINFO;

#undef  INTERFACE
#define INTERFACE   IImageCache

DECLARE_INTERFACE_ ( IImageCache, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IImageCache methods ***
    STDMETHOD ( AddImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FindImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FreeImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( Flush )( THIS_ BOOL fRelease ) PURE;
    STDMETHOD ( ChangeImageInfo ) ( THIS_ UINT IImageIndex, LPCIMAGECACHEINFO pInfo ) PURE;
    STDMETHOD ( GetCacheSize ) ( THIS_ UINT * puSize ) PURE;
    STDMETHOD ( GetUsage ) ( THIS_ UINT uIndex, UINT * puUsage ) PURE;

    STDMETHOD( GetImageList ) ( THIS_ LPIMAGECACHEINITINFO pInfo ) PURE;
};
typedef IImageCache * LPIMAGECACHE;

#if (_WIN32_IE >= 0x0500)

// IImageCache 2

#undef  INTERFACE
#define INTERFACE  IImageCache2

DECLARE_INTERFACE_ ( IImageCache2, IImageCache )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IImageCache methods ***
    STDMETHOD ( AddImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FindImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FreeImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( Flush )( THIS_ BOOL fRelease ) PURE;
    STDMETHOD ( ChangeImageInfo ) ( THIS_ UINT IImageIndex, LPCIMAGECACHEINFO pInfo ) PURE;
    STDMETHOD ( GetCacheSize ) ( THIS_ UINT * puSize ) PURE;
    STDMETHOD ( GetUsage ) ( THIS_ UINT uIndex, UINT * puUsage ) PURE;

    STDMETHOD( GetImageList ) ( THIS_ LPIMAGECACHEINITINFO pInfo ) PURE;

    // IImageCache2 methods
    STDMETHOD ( DeleteImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( GetImageInfo ) (THIS_ UINT iImageIndex, LPIMAGECACHEINFO pInfo ) PURE;
};

#endif

#if ( _WIN32_IE >= 0x0500 )
///////////////////////////////////////////////////////////////////////
// interface for
typedef struct _EnumImageStoreDATAtag
{
    WCHAR     szPath[MAX_PATH];
    FILETIME  ftTimeStamp;
} ENUMSHELLIMAGESTOREDATA, * PENUMSHELLIMAGESTOREDATA;

#undef  INTERFACE
#define INTERFACE   IEnumShellImageStore

DECLARE_INTERFACE_( IEnumShellImageStore, IUnknown )
{
    STDMETHOD ( QueryInterface ) ( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    STDMETHOD ( Reset ) ( THIS ) PURE;
    STDMETHOD ( Next ) ( THIS_ ULONG celt, PENUMSHELLIMAGESTOREDATA * prgElt, ULONG * pceltFetched ) PURE;
    STDMETHOD ( Skip ) ( THIS_ ULONG celt ) PURE;
    STDMETHOD ( Clone ) ( THIS_ IEnumShellImageStore ** ppEnum ) PURE;
};

typedef IEnumShellImageStore * LPENUMSHELLIMAGESTORE;


// flags used to determine the capabilities of the storage for the images
#define SHIMSTCAPFLAG_LOCKABLE    0x0001       // does the store require/support locking
#define SHIMSTCAPFLAG_PURGEABLE   0x0002       // does the store require dead items purging externally ?

#undef  INTERFACE
#define INTERFACE   IShellImageStore

// this interface is used to manipulate the Image cache. It can potentially be used
// in a free threaded manner in conjunction with the Lock parameter to Open and close
DECLARE_INTERFACE_( IShellImageStore, IUnknown )
{
    STDMETHOD ( QueryInterface )( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    // if the lock parameter is used, then all other calls into
    // open and/or create will block until the lock is released.
    STDMETHOD ( Open ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;
    STDMETHOD ( Create ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;

    // if the lock is passed to either of these two methods, it releases the lock
    // once the operation is complete.
    STDMETHOD ( ReleaseLock ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Close ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Commit ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( IsLocked ) ( THIS ) PURE;

    STDMETHOD ( GetMode ) ( THIS_ DWORD * pdwMode ) PURE;
    STDMETHOD ( GetCapabilities ) ( THIS_ DWORD * pdwCapMask ) PURE;

    STDMETHOD ( AddEntry ) ( THIS_ LPCWSTR pszName, const FILETIME * pftTimeStamp, DWORD dwMode, HBITMAP hImage ) PURE;
    STDMETHOD ( GetEntry ) ( THIS_ LPCWSTR pszName, DWORD dwMode, HBITMAP * phImage ) PURE;
    STDMETHOD ( DeleteEntry ) ( THIS_ LPCWSTR pszName ) PURE;
    STDMETHOD ( IsEntryInStore ) ( THIS_ LPCWSTR pszName, FILETIME * pftTimeStamp ) PURE;

    STDMETHOD ( Enum ) ( THIS_ LPENUMSHELLIMAGESTORE * ppEnum ) PURE;
};

typedef IShellImageStore * LPSHELLIMAGESTORE;
#endif
//
// Interface for interacting with the IE splash screen
//

#undef  INTERFACE
#define INTERFACE   ISplashScreen

DECLARE_INTERFACE_( ISplashScreen, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** ISplashScreen methods ***
    STDMETHOD ( Show ) ( THIS_ HINSTANCE hinst, UINT idResHi, UINT idResLow, HWND * phwnd ) PURE;
    STDMETHOD ( Dismiss ) (THIS) PURE;
};

typedef ISplashScreen * LPSPLASHSCREEN;

//
// Interface for Multiple Monitor Configurations
//

#define MD_PRIMARY  0x00000001
#define MD_ATTACHED 0x00000002
typedef struct _MonitorData
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwStatus;
    RECT rcPos;
} MonitorData, * LPMONITORDATA;
#undef  INTERFACE
#define INTERFACE   IMultiMonConfig

DECLARE_INTERFACE_( IMultiMonConfig, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IMultiMonConfig methods ***
    STDMETHOD ( Initialize ) ( THIS_ HWND hwndHost, WNDPROC WndProc, DWORD dwReserved) PURE;
    STDMETHOD ( GetNumberOfMonitors ) (THIS_ int * pCMon, DWORD dwReserved) PURE;
    STDMETHOD ( GetMonitorData) (THIS_ int iMonitor, MonitorData * pmd, DWORD dwReserved) PURE;
    STDMETHOD ( Paint) (THIS_ int iMonitor, DWORD dwReserved) PURE;
};

typedef IMultiMonConfig * LPMULTIMONCONFIG;

#endif // _WIN32_IE > 0x0400

////  IRestrict
// For the pdwRestrictionResult out parameter in IRestrict::IsRestricted() for
// all pguidIDs.
typedef enum
{
    RR_ALLOW  = 1,
    RR_DISALLOW,
    RR_NOCHANGE,
} RESTRICTION_RESULT;

// IRestrict::IsRestricted() dwRestrictAction parameter values for
// the RID_RDeskBars pguidID.
typedef enum
{
    RA_DRAG  = 1,
    RA_DROP,
    RA_ADD,
    RA_CLOSE,
    RA_MOVE,
} RESTRICT_ACTIONS;

#undef INTERFACE
#define INTERFACE IRestrict

DECLARE_INTERFACE_(IRestrict, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRestrict Methods ***
    STDMETHOD(IsRestricted) (THIS_ const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, OUT DWORD * pdwRestrictionResult) PURE;
};


////  IAddressBand
#define OLECMD_REFRESH_TOPMOST     0x00000000
#define OLECMD_REFRESH_ENTIRELIST  0x00000001

#undef INTERFACE
#define INTERFACE IAddressBand

DECLARE_INTERFACE_(IAddressBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAddressBand Methods ***
    STDMETHOD(FileSysChange) (THIS_ DWORD dwEvent, LPCITEMIDLIST * ppidl1) PURE;
    STDMETHOD(Refresh) (THIS_ VARIANT * pvarType) PURE;
};

#undef INTERFACE
#define INTERFACE IAddressEditBox

// Init Flags
#define AEB_INIT_DEFAULT     0x00000000
#define AEB_INIT_NOSHELL     0x00000001
#define AEB_INIT_NOWEB       0x00000002
#define AEB_INIT_NOFILE      0x00000004
#define AEB_INIT_AUTOEXEC    0x00000008     // Set if you want the item Navigated/ShellExeced when ENTER occurs.
#define AEB_INIT_SUBCLASS    0x00000010     // If set parent needs to pass HWND events thru IWinEventHandler::OnWinEvent()

// Parse Flags for IAddressEditBox::ParseNow()
#define SHURL_FLAGS_NONE        0x00000000
#define SHURL_FLAGS_NOUI        0x00000001      // Don't display any UI.
#define SHURL_FLAGS_NOSNS       0x00000002      // Ignore SHELL URLs. (FILE and Internet URLs still work)
#define SHURL_FLAGS_NOWEB       0x00000004      // Ignore WEB URLs. (Don't successfully parse if not found in shell name space)
#define SHURL_FLAGS_NOPATHSEARCH 0x00000008     // don't search on dos paths or app path
#define SHURL_FLAGS_AUTOCORRECT 0x00000010      // Try to autocorrect WEB URLs

// Exec Flags for IAddressEditBox::Execute()
#define SHURL_EXECFLAGS_NONE        0x00000000
#define SHURL_EXECFLAGS_SEPVDM      0x00000001      // If ShellExec(), set SEE_MASK_FLAG_SEPVDM fMask.
#define SHURL_EXECFLAGS_DONTFORCEIE 0x00000002      // If some browser other than IE is associated with HTML files, allow them to launch.


DECLARE_INTERFACE_(IAddressEditBox, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAddressEditBox Methods ***
    STDMETHOD(Init) (THIS_ HWND hwnd, HWND hwndEditBox, DWORD dwFlags, IUnknown * punkParent) PURE;
    STDMETHOD(SetCurrentDir) (THIS_ LPCOLESTR pwzDir) PURE;
    STDMETHOD(ParseNow) (THIS_ DWORD dwParseFlags) PURE;
    STDMETHOD(Execute) (THIS_ DWORD dwExecFlags) PURE;
    STDMETHOD(Save) (THIS_ DWORD dwReserved) PURE;
};


#if (_WIN32_IE >= 0x0400)

////  IShellFolderBand

// Field mask
#define ISFB_MASK_STATE          0x00000001 // TRUE if dwStateMask and dwState is valid
#define ISFB_MASK_BKCOLOR        0x00000002 // TRUE if crBkgnd field is valid
#define ISFB_MASK_VIEWMODE       0x00000004 // TRUE if wViewMode field is valid
#define ISFB_MASK_SHELLFOLDER    0x00000008
#define ISFB_MASK_IDLIST         0x00000010
#define ISFB_MASK_COLORS         0x00000020 // TRUE if crXXXX fields are valid (except bkgnd)
#define ISFB_MASK_ALL            0x0000003F         //
#define ISFB_MASK_INVALID        (~(ISFB_MASK_ALL)) //

#define ISFB_STATE_DEFAULT       0x00000000
#define ISFB_STATE_DEBOSSED      0x00000001
#define ISFB_STATE_ALLOWRENAME   0x00000002
#define ISFB_STATE_NOSHOWTEXT    0x00000004 // TRUE if _fNoShowText
//#define ISFB_STATE_NOTITLE       0x00000008 // obsolete! (use cbs::SetBandState)
#define ISFB_STATE_CHANNELBAR    0x00000010 // TRUE if we want NavigateTarget support
#define ISFB_STATE_QLINKSMODE    0x00000020 // TRUE if we want to turn off drag & drop onto content items
#define ISFB_STATE_FULLOPEN      0x00000040 // TRUE if band should maximize when opened
#define ISFB_STATE_NONAMESORT    0x00000080 // TRUE if band should _not_ sort icons by name
#define ISFB_STATE_BTNMINSIZE    0x00000100 // TRUE if band should report min thickness of button
#define ISFB_STATE_ALL           0x000001FF //

#define ISFBVIEWMODE_SMALLICONS   0x0001
#define ISFBVIEWMODE_LARGEICONS   0x0002
#define ISFBVIEWMODE_LOGOS        0x0003

typedef struct {
    DWORD       dwMask;       // [in] ISFB_MASK mask of valid fields from crBkgnd on
    DWORD       dwStateMask;  // [in] ISFB_STATE mask of dwState bits being set/queried
    DWORD       dwState;      // [in/out] ISFB_STATE bits
    COLORREF    crBkgnd;      // [in/out]
    COLORREF    crBtnLt;      // [in/out]
    COLORREF    crBtnDk;      // [in/out]
    WORD        wViewMode;    // [in/out]
    WORD        wAlign;       // not used (yet)
    IShellFolder * psf;       // [out]
    LPITEMIDLIST   pidl;      // [out]
} BANDINFOSFB, *PBANDINFOSFB;

#undef INTERFACE
#define INTERFACE IShellFolderBand

DECLARE_INTERFACE_(IShellFolderBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderBand Methods ***
    STDMETHOD(InitializeSFB)(THIS_ IShellFolder *psf, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(SetBandInfoSFB)(THIS_ PBANDINFOSFB pbi) PURE;
    STDMETHOD(GetBandInfoSFB)(THIS_ PBANDINFOSFB pbi) PURE;
};

// Command Target IDs
enum {
    SFBID_PIDLCHANGED,
};

//-------------------------------------------------------------------------
//
// IWinEventHandler interface
//
//   An object that wants to send messages to another object (typically
// a sub-object) QI's for the sub-object's IWinEventHandler interface.
// Once the object determines the hwnd is owned by the sub-object (via
// IsWindowOwner), the object calls OnWinEvent for send the message.
//
//
// [Member functions]
//
// IWinEventHandler::IsWindowOwner(hwnd)
//   Returns S_OK if the hwnd is owned by the object, S_FALSE if not.
//
// IWinEventHandler::OnWinEvent(hwnd, dwMsg, wParam, lParam, plRet)
//   Sends a message to the object.  The Win32 return value (i.e., the
//   value returned by DefWindowProc) is returned in *plRet.  Return
//   S_OK if the message is handled, otherwise S_FALSE.
//
//-------------------------------------------------------------------------


#undef INTERFACE
#define INTERFACE IWinEventHandler

DECLARE_INTERFACE_(IWinEventHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWinEventHandler Methods ***
    STDMETHOD(OnWinEvent) (THIS_ HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres) PURE;
    STDMETHOD(IsWindowOwner) (THIS_ HWND hwnd) PURE;
};


////  IDeskBarClient

#undef  INTERFACE
#define INTERFACE   IDeskBarClient

DECLARE_INTERFACE_(IDeskBarClient, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetDeskBarSite)   (THIS_ IUnknown* punkSite) PURE;
    STDMETHOD(SetModeDBC)          (THIS_ DWORD dwMode) PURE;
    STDMETHOD(UIActivateDBC)    (THIS_ DWORD dwState) PURE;
    STDMETHOD(GetSize)    (THIS_ DWORD dwWhich, LPRECT prc) PURE;
};

#define DBC_GS_IDEAL    0  // get the ideal size

#define DBC_HIDE        0 // Band is hidden (being destroyed)
#define DBC_SHOW        1 // Band is visible
#define DBC_SHOWOBSCURE 2 // Band is completely obscured


enum {
    DBCID_EMPTY = 0,        // bandsite is empty
    DBCID_ONDRAG = 1,       // (down)DragMoveEnter/Leave vaIn:I4:eDrag
    DBCID_CLSIDOFBAR = 2,   // clsid of bar inside
    DBCID_RESIZE = 3,		// resize from keyboard
};

///// IDeskBar

#undef  INTERFACE
#define INTERFACE   IDeskBar

DECLARE_INTERFACE_(IDeskBar, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetClient)          (THIS_ IUnknown* punkClient) PURE;
    STDMETHOD(GetClient)          (THIS_ IUnknown** ppunkClient) PURE;
    STDMETHOD(OnPosRectChangeDB)(THIS_ LPRECT prc) PURE;
};


//-------------------------------------------------------------------------
//
// IBandSite interface
//
//   This interface provides methods to get or set bandsite information.
//
// [Member functions]
//
// IBandSite::AddBand(punk)
//   Add a band to the bandsite.  Returns the band ID in ShortFromResult(hres).
//
// IBandSite::EnumBands(uBand, *pdwBandID)
//   Enumerate the bands. If uBand is -1, pdwBandID is ignored and this
//   method returns the count of bands in the bandsite.  Call this method
//   with uBand starting at 0 to begin enumerating.  Returns S_OK and the
//   band ID in *pdwBandID of the next band.
//
// IBandSite::QueryBand(dwBandID, ppstb, pdwState, pszName, cchName)
//   Get info about a band.
//
// IBandSite::SetBandState(dwBandID, dwState)
//   Set the band's state.
//   ;BUGBUG (scotth): no one implements this right now!
//
// IBandSite::RemoveBand(dwBandID)
//   Remove the band.
//
// IBandSite::GetBandObject(dwBandID, riid, ppv)
//   Get an object that support riid for the band.
//
// IBandSite::GetBandSiteInfo(pbsinfo)
//   Get info about the bandsite.
//
// IBandSite::SetBandSiteInfo(pbsinfo)
//   Set info about the bandsite.
//
//-------------------------------------------------------------------------

// Field mask
#define BSIM_STATE          0x00000001
#define BSIM_STYLE          0x00000002

// State flags
#define BSSF_VISIBLE        0x00000001
#define BSSF_NOTITLE        0x00000002
#define BSSF_UNDELETEABLE   0x00001000  // OBSOLETE

// Style flags
#define BSIS_AUTOGRIPPER    0x00000000
#define BSIS_NOGRIPPER      0x00000001
#define BSIS_ALWAYSGRIPPER  0x00000002
#define BSIS_LEFTALIGN      0x00000004
#define BSIS_SINGLECLICK    0x00000008
#define BSIS_NOCONTEXTMENU  0x00000010
#define BSIS_NODROPTARGET   0x00000020

typedef struct {
    DWORD       dwMask;         // BSIM_* flags
    DWORD       dwState;        // BSSF_* flags
    DWORD       dwStyle;        // BSIS_* flags
} BANDSITEINFO;

// Passed to parent and child context menus in
// lpParameters field of CMINVOKECOMMANDINFO
typedef struct {
    DWORD       dwID;
    IUnknown *  punkSite;
} BANDSITEINVOKEPARAM;

#undef  INTERFACE
#define INTERFACE   IBandSite

DECLARE_INTERFACE_(IBandSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBandSite methods ***
    STDMETHOD(AddBand)          (THIS_ IUnknown* punk) PURE;
    STDMETHOD(EnumBands)        (THIS_ UINT uBand, DWORD* pdwBandID) PURE;
    STDMETHOD(QueryBand)        (THIS_ DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName) PURE;
    STDMETHOD(SetBandState)     (THIS_ DWORD dwBandID, DWORD dwMask, DWORD dwState) PURE;
    STDMETHOD(RemoveBand)       (THIS_ DWORD dwBandID) PURE;
    STDMETHOD(GetBandObject)    (THIS_ DWORD dwBandID, REFIID riid, void **ppv) PURE;
    STDMETHOD(SetBandSiteInfo)  (THIS_ const BANDSITEINFO * pbsinfo) PURE;
    STDMETHOD(GetBandSiteInfo)  (THIS_ BANDSITEINFO * pbsinfo) PURE;
};

// BSID_BANDREMOVED means removed *or* hidden
enum {
    BSID_BANDADDED,
    BSID_BANDREMOVED,
};
#endif // _WIN32_IE > 0x0400


//==========================================================================
// IExplorerToolbar interfaces
//
//  This is an interface to the shell toolbar which allows shell views
// to add buttons and process.
// See http://ohserv/users/satona/toolbar_extension.htm for spec.
//
//==========================================================================

// Bitmap types
#define BITMAP_NORMAL         0x1
#define BITMAP_HOT            0x2
#define BITMAP_DISABLED       0x3

// Band Visibility Flags
#define VBF_TOOLS               0x00000001
#define VBF_ADDRESS             0x00000002
#define VBF_LINKS               0x00000004
#define VBF_BRAND               0x00000008
#define VBF_MENU                0x00000010

#define VBF_ONELINETEXT         0x00000020
#define VBF_TWOLINESTEXT        0x00000040
#define VBF_NOCUSTOMIZE         0x00000080

#define VBF_EXTERNALBANDS       0xFFFF0000

#define VBF_VALID               (VBF_TOOLS | VBF_ADDRESS | VBF_LINKS | VBF_BRAND | VBF_MENU | VBF_EXTERNALBANDS)

#undef  INTERFACE
#define INTERFACE   IExplorerToolbar

typedef enum {
    ETCMDID_GETBUTTONS          = 0x0001,
    ETCMDID_NEWCOMMANDTARGET    = 0x0002,   // sent to the previous command target when a new one is coming in
#if (_WIN32_IE >= 0x500)
    ETCMDID_RELOADBUTTONS       = 0x0003,   // command target needs to call AddButtons again
#endif
} ENUM_ETCMDID;

DECLARE_INTERFACE_(IExplorerToolbar, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExplorerToolbar methods ***
    STDMETHOD(SetCommandTarget) (THIS_ IUnknown* punkCmdTarget, const GUID* pguidCmdGrp, DWORD dwFlags) PURE;
    STDMETHOD(AddStdBrowserButtons) (THIS) PURE;

    // Wrap of the TB_* messages the messages that are implmented
    // are just the ones to add delete and modify the buttons, and not
    // the ones to manipulate the toolbar.
    STDMETHOD(AddButtons)       (THIS_ const GUID * pguidButtonGroup, UINT nButtons, const TBBUTTON * lpButtons) PURE;
    STDMETHOD(AddString)        (THIS_ const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LRESULT * pOffset) PURE;
    STDMETHOD(GetButton)        (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton) PURE;
    STDMETHOD(GetState)         (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, UINT * pfState) PURE;
    STDMETHOD(SetState)         (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, UINT fState) PURE;
    STDMETHOD(AddBitmap)        (THIS_ const GUID * pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP * ptb,
                                                        LRESULT * pOffset, COLORREF rgbMask) PURE;
    STDMETHOD(GetBitmapSize)    (THIS_ UINT * uiID) PURE;
    STDMETHOD(SendToolbarMsg)   (THIS_ const GUID * pguidButtonGroup, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRes) PURE;

    STDMETHOD(SetImageList) (THIS_ const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled) PURE;
    STDMETHOD(ModifyButton)     (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton) PURE;
};

//==========================================================================
// DefView supports a private service id for extended views.
// DefView's IOleCommandTarget supports the below command group and ids too.
//==========================================================================
// SID_DefView and CGID_DefView are defined in shlguid.w
//
#define DVCMDID_GETTHISDIRPATH 1 // pvaOut = path to this directory (if in filesystem)
#define DVCMDID_GETTHISDIRNAME 2 // pvaOut = friendly name of this directory
#define DVCMDID_GETTEMPLATEDIRNAME 3 // pvaOut = webview template (.htt) dir
#define IS_ADJUSTLISTVIEW       0x80000000
#define IS_INTERNALDUMMYBIT     0x40000000
#define IS_VALIDINTERNALBITS    (IS_ADJUSTLISTVIEW | IS_INTERNALDUMMYBIT)

// Flags for SetSafeMode
#define SSM_CLEAR   0x0000
#define SSM_SET     0x0001
#define SSM_REFRESH 0x0002
#define SSM_UPDATE  0x0004

// Flags for Set/GetScheme
#define SCHEME_DISPLAY          0x0001
#define SCHEME_EDIT             0x0002
#define SCHEME_LOCAL            0x0004
#define SCHEME_GLOBAL           0x0008
#define SCHEME_REFRESH          0x0010
#define SCHEME_UPDATE           0x0020
#define SCHEME_DONOTUSE 0x0040 // used to be SCHEME_ENUMERATE; no longer supported
#define SCHEME_CREATE           0x0080

#undef INTERFACE
#define INTERFACE IActiveDesktopP

DECLARE_INTERFACE_( IActiveDesktopP, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktopP methods
    STDMETHOD (SetSafeMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (EnsureUpdateHTML)(THIS) PURE;
    STDMETHOD (SetScheme)(THIS_ LPCWSTR pwszSchemeName, DWORD dwFlags) PURE;
    STDMETHOD (GetScheme)(THIS_ LPWSTR pwszSchemeName, DWORD *lpdwcchBuffer, DWORD dwFlags) PURE;
    //
};

typedef IActiveDesktopP * LPACTIVEDESKTOPP;

//Flags for GetObjectFlags
#define GADOF_DIRTY    0x00000001

#undef INTERFACE
#define INTERFACE IADesktopP2

DECLARE_INTERFACE_( IADesktopP2, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IADesktopP2 methods
    STDMETHOD (ReReadWallpaper)(THIS) PURE;
    STDMETHOD (GetADObjectFlags)(THIS_ DWORD *lpdwFlags, DWORD dwMask) PURE;
    STDMETHOD (UpdateAllDesktopSubscriptions)(THIS) PURE;
    STDMETHOD (MakeDynamicChanges)(THIS_ IOleObject *pOleObj) PURE;
};

typedef IADesktopP2 * LPADESKTOPP2;

#define CFSTR_SHELLIDLISTP      TEXT("Shell IDLData Private")
#define CFSTR_SHELLCOPYDATA     TEXT("Shell Copy Data")
//
// Win 3.1 style HDROP
//
//  Notes: Our API works only if pFiles == sizeof(DROPFILES16)
//
typedef struct _DROPFILES16 {
    WORD pFiles;                // offset to double null list of files
    POINTS pt;                  // drop point (client coords)
    WORD fNC;                   // is it on non client area
                                // and pt is in screen coords
} DROPFILES16, * LPDROPFILES16;

//
// format of CF_SHELLCOPYDATA
//

typedef struct _SHELLCOPYDATA {
    DWORD dwEffect;                 // Intended effect
} SHELLCOPYDATA;
//------ See shelldll\fsnotify.c for function descriptions. ----------

//
//  Definition of the function type to be called by the notification
//  service when a file the client has registered to monitor changes.
//

typedef struct _SHChangeNotifyEntry
{
    LPCITEMIDLIST pidl;
    BOOL   fRecursive;
} SHChangeNotifyEntry;
#define SHCNRF_InterruptLevel      0x0001
#define SHCNRF_ShellLevel          0x0002

// If the caller passes SHCNRF_RecursiveInterrupt (meaning that they want interrupt events on the whole
// subtree), then they must also pass SHCNRF_InterruptLevel flag (duh), and they must be a recursive (eg
// fRecursive == TRUE) type notification.
#define SHCNRF_RecursiveInterrupt  0x1000
#define SHCNRF_ResumeThread        0x2000
#define SHCNRF_CreateSuspended     0x4000
#define SHCNRF_NewDelivery         0x8000

// !! WARNING !!
// If you change/add any new SHCNE_ events, you will need
// to possibly modify the SHCNE_XXXXEVENTS masks that are
// defined below as well.
// NOTE: SHCNE_GLOBALEVENTS are typically used to pass
// non-pidl information (packed into pidl format). We cannot
// extend SHCNE_GLOBALEVENTS and expect clients of the new
// events to work on a down-level shell32. In fact, they
// may very well fault during psfDesktop->CompareIDs.
// So be careful when adding to this bitfield!
//
// Win95 and NT4 and IE4 shipped with 0x0C0581E0L.
// We use this event mask to tell if we need to possibly throw out a SHCNE_UPDATEDIR that was
// generated by the filesystem because we have a more specific event already in our queue.
// NOTE: only non-interrupt events could cause us to throw out a interrupt generated UPDATEDIR event.
#define SHCNE_UPDATEDIR_OVERRIDE_EVENTS 0x00023818L
// This event was defined early on in IE4 for the Theme Switcher to
// notify the shell that a system-wide update needed to happen.
// This has been removed but I don't want to re-use the id just yet...

// BUGBUG (scotth) 6/11/98: can we remove this yet??

//#define SHCNEE_THEMECHANGED       1L  // The theme changed
#define SHCNEE_WININETCHANGED       3L  // dwItem2 contains CACHE_NOTIFY_* bits
#define SHCNEE_PROMOTEDITEM         6L  // pidl2 is the pidl of the Promoted item
#define SHCNEE_DEMOTEDITEM          7L  // pidl2 is the pidl of the demoted item
#define SHCNEE_ALIASINUSE           8L  // some alias style folder is now being used
// Update types for the UpdateEntryList api
#define SHCNNU_SET        1   // Set the notify list to passed in list
#define SHCNNU_ADD        2   // Add the items to the current list
#define SHCNNU_REMOVE     3   // Remove the items from the current list
#define SHCNF_PRINTJOBA   0x0004        // dwItem1: printer name
                                        // dwItem2: SHCNF_PRINTJOB_DATA
#define SHCNF_PRINTJOBW   0x0007        // dwItem1: printer name
                                        // dwItem2: SHCNF_PRINTJOB_DATA
#define SHCNF_INSTRUMENT  0x0080        // dwItem1: LPSHCNF_INSTRUMENT
#define SHCNF_NONOTIFYINTERNALS     0x4000 // means don't do shell notify internals.  see comments in code
#define SHCNF_ONLYNOTIFYINTERNALS   0x8000 // only notify internal clients
#ifdef UNICODE
#define SHCNF_PRINTJOB  SHCNF_PRINTJOBW
#else
#define SHCNF_PRINTJOB  SHCNF_PRINTJOBA
#endif

typedef struct tagSHCNF_PRINTJOB_DATA {
    DWORD JobId;
    DWORD Status;
    DWORD TotalPages;
    DWORD Size;
    DWORD PagesPrinted;
} SHCNF_PRINTJOB_DATA, *LPSHCNF_PRINTJOB_DATA;

//
// This is all the INSTRUMENTation stuff...
// make this look like an ITEMIDLIST (uOffset points to 0 uTerm)
#include <pshpack1.h>
typedef struct tagSHCNF_INSTRUMENT {
    USHORT uOffset;
    USHORT uAlign;
    DWORD dwEventType;
    DWORD dwEventStructure;
    SYSTEMTIME st;
    union tagEvents {
        struct tagSTRING {
            TCHAR sz[32];
        } string;
        struct tagHOTKEY {
            WPARAM wParam;
        } hotkey;
        struct tagWNDPROC {
            HWND hwnd;
            UINT uMsg;
            WPARAM wParam;
            LPARAM lParam;
        } wndproc;
        struct tagCOMMAND {
            HWND hwnd;
            UINT idCmd;
        } command;
        struct tagDROP {
            HWND hwnd;
            UINT idCmd;
//          TCHAR sz[32]; // convert pDataObject into something we can log
        } drop;
    } e;
    USHORT uTerm;
} SHCNF_INSTRUMENT_INFO, * LPSHCNF_INSTRUMENT_INFO;
#include <poppack.h>

#define SHCNFI_EVENT_STATECHANGE          0   // dwEventType
#define SHCNFI_EVENT_STRING               1   // e.string
#define SHCNFI_EVENT_HOTKEY               2   // e.hotkey
#define SHCNFI_EVENT_WNDPROC              3   // e.wndproc
#define SHCNFI_EVENT_WNDPROC_HOOK         4   // e.wndproc
#define SHCNFI_EVENT_ONCOMMAND            5   // e.command
#define SHCNFI_EVENT_INVOKECOMMAND        6   // e.command
#define SHCNFI_EVENT_TRACKPOPUPMENU       7   // e.command
#define SHCNFI_EVENT_DROP                 8   // e.drop
#define SHCNFI_EVENT_MAX                  9

#define SHCNFI_STRING_SHOWEXTVIEW         0

#define SHCNFI_STATE_KEYBOARDACTIVE         0   // _KEYBOARDACTIVE or _MOUSEACTIVE
#define SHCNFI_STATE_MOUSEACTIVE            1   // _KEYBOARDACTIVE or _MOUSEACTIVE
#define SHCNFI_STATE_ACCEL_TRAY             2   // _ACCEL_TRAY or _ACCEL_DESKTOP
#define SHCNFI_STATE_ACCEL_DESKTOP          3   // _ACCEL_TRAY or _ACCEL_DESKTOP
#define SHCNFI_STATE_START_DOWN             4   // _START_DOWN or _START_UP
#define SHCNFI_STATE_START_UP               5   // _START_DOWN or _START_UP
#define SHCNFI_STATE_TRAY_CONTEXT           6
#define SHCNFI_STATE_TRAY_CONTEXT_CLOCK     7
#define SHCNFI_STATE_TRAY_CONTEXT_START     8
#define SHCNFI_STATE_DEFVIEWX_ALT_DBLCLK    9
#define SHCNFI_STATE_DEFVIEWX_SHIFT_DBLCLK 10
#define SHCNFI_STATE_DEFVIEWX_DBLCLK       11

#define SHCNFI_GLOBALHOTKEY               0

#define SHCNFI_CABINET_WNDPROC            0
#define SHCNFI_DESKTOP_WNDPROC            1
#define SHCNFI_PROXYDESKTOP_WNDPROC       2
#define SHCNFI_TRAY_WNDPROC               3
#define SHCNFI_DRIVES_WNDPROC             4
#define SHCNFI_ONETREE_WNDPROC            5
#define SHCNFI_MAIN_WNDPROC               6
#define SHCNFI_FOLDEROPTIONS_DLGPROC      7
#define SHCNFI_VIEWOPTIONS_DLGPROC        8
#define SHCNFI_FT_DLGPROC                 9
#define SHCNFI_FTEdit_DLGPROC            10
#define SHCNFI_FTCmd_DLGPROC             11
#define SHCNFI_TASKMAN_DLGPROC           12
#define SHCNFI_TRAYVIEWOPTIONS_DLGPROC   13
#define SHCNFI_INITSTARTMENU_DLGPROC     14
#define SHCNFI_PRINTERQUEUE_DLGPROC      15

#define SHCNFI_CABINET_ONCOMMAND          0
#define SHCNFI_TRAYCOMMAND                1

#define SHCNFI_BITBUCKET_DFM_INVOKE       0
#define SHCNFI_BITBUCKET_FNV_INVOKE       1
#define SHCNFI_BITBUCKET_INVOKE           2
#define SHCNFI_BITBUCKETBG_DFM_INVOKE     3
#define SHCNFI_CONTROLS_DFM_INVOKE        4
#define SHCNFI_CONTROLS_FNV_INVOKE        5
#define SHCNFI_CONTROLSBG_DFM_INVOKE      6
#define SHCNFI_DEFFOLDER_DFM_INVOKE       7
#define SHCNFI_DEFFOLDER_INVOKE           8
#define SHCNFI_FINDEXT_INVOKE             9
#define SHCNFI_DEFFOLDER_FNV_INVOKE      10
#define SHCNFI_DRIVESBG_DFM_INVOKE       11
#define SHCNFI_DRIVES_FNV_INVOKE         12
#define SHCNFI_DRIVES_DFM_INVOKE         13
#define SHCNFI_FOLDERBG_DFM_INVOKE       14
#define SHCNFI_FOLDER_FNV_INVOKE         15
#define SHCNFI_FOLDER_DFM_INVOKE         16
#define SHCNFI_NETWORKBG_DFM_INVOKE      17
#define SHCNFI_NETWORK_FNV_INVOKE        18
#define SHCNFI_NETWORK_DFM_INVOKE        19
#define SHCNFI_NETWORKPRINTER_DFM_INVOKE 20
#define SHCNFI_DESKTOPBG_DFM_INVOKE      21
#define SHCNFI_DESKTOP_DFM_INVOKE        22
#define SHCNFI_DESKTOP_FNV_INVOKE        23
#define SHCNFI_PRINTERS_DFM_INVOKE       24
#define SHCNFI_PRINTERSBG_DFM_INVOKE     25
#define SHCNFI_PRINTERS_FNV_INVOKE       26
#define SHCNFI_DEFVIEWX_INVOKE           27

#define SHCNFI_FOLDER_DROP                0
#define SHCNFI_PRINTQUEUE_DROP            1
#define SHCNFI_DEFVIEWX_TPM               2
#define SHCNFI_DROP_EXE_TPM               3
#define SHCNFI_IDLDT_TPM                  4

#define SHCNFI_DROP_BITBUCKET             0
#define SHCNFI_DROP_PRINTFOLDER           1
#define SHCNFI_DROP_PRINTER               2
#define SHCNFI_DROP_RUN                   3
#define SHCNFI_DROP_SHELLLINK             4
#define SHCNFI_DROP_DRIVES                5
#define SHCNFI_DROP_FS                    6
#define SHCNFI_DROP_EXE                   7
#define SHCNFI_DROP_NETROOT               8
#define SHCNFI_DROP_PRINTQUEUE            9
#define SHCNFI_DROP_BRIEFCASE            10

#ifdef WANT_SHELL_INSTRUMENTATION
#define INSTRUMENT_STATECHANGE(t)                               \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_STATECHANGE;                \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_STRING(t,p)                                  \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_STRING;                     \
    lstrcpyn(s.e.string.sz,(p),ARRAYSIZE(s.e.string.sz));       \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_HOTKEY(t,w)                                  \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_HOTKEY;                     \
    s.e.hotkey.wParam=(w);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_WNDPROC(t,h,u,w,l)                           \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_WNDPROC;                    \
    s.e.wndproc.hwnd=(h);                                       \
    s.e.wndproc.uMsg=(u);                                       \
    s.e.wndproc.wParam=(w);                                     \
    s.e.wndproc.lParam=(l);                                     \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_WNDPROC_HOOK(h,u,w,l)                        \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=0;                                            \
    s.dwEventStructure=SHCNFI_EVENT_WNDPROC_HOOK;               \
    s.e.wndproc.hwnd=(h);                                       \
    s.e.wndproc.uMsg=(u);                                       \
    s.e.wndproc.wParam=(w);                                     \
    s.e.wndproc.lParam=(l);                                     \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_ONCOMMAND(t,h,u)                             \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_ONCOMMAND;                  \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_INVOKECOMMAND(t,h,u)                         \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_INVOKECOMMAND;              \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_TRACKPOPUPMENU(t,h,u)                        \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_TRACKPOPUPMENU;             \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_DROP(t,h,u,p)                                \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_DROP;                       \
    s.e.drop.hwnd=(h);                                          \
    s.e.drop.idCmd=(u);                                         \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#else
#define INSTRUMENT_STATECHANGE(t)
#define INSTRUMENT_STRING(t,p)
#define INSTRUMENT_HOTKEY(t,w)
#define INSTRUMENT_WNDPROC(t,h,u,w,l)
#define INSTRUMENT_WNDPROC_HOOK(h,u,w,l)
#define INSTRUMENT_ONCOMMAND(t,h,u)
#define INSTRUMENT_INVOKECOMMAND(t,h,u)
#define INSTRUMENT_TRACKPOPUPMENU(t,h,u)
#define INSTRUMENT_DROP(t,h,u,p)
#endif //WANT_SHELL_INSTRUMENTATION
//
//
// IQueryCodePage
//
#undef  INTERFACE
#define INTERFACE  IQueryCodePage

DECLARE_INTERFACE_(IQueryCodePage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IQueryCodePage methods ***
    STDMETHOD(GetCodePage)(THIS_ UINT * puiCodePage) PURE;
    STDMETHOD(SetCodePage)(THIS_ UINT uiCodePage) PURE;
} ;
SHSTDAPI_(void) ReceiveAddToRecentDocs(HANDLE hARD, DWORD dwProcId);

SHSTDAPI_(void) SHWaitOp_Operate(HANDLE hWaitOp, DWORD dwProcId);

/// THESE ARE INTERNAL ....

#define SHCR_CMD_REGISTER   1
#define SHCR_CMD_DEREGISTER 2

typedef struct _SHChangeRegistration {
    UINT    uCmd;
    ULONG   ulID;
    DWORD   hwnd;
    UINT    uMsg;
    DWORD   fSources;
    LONG    lEvents;
    BOOL    fRecursive;
    UINT    uidlRegister;
} SHChangeRegistration, *LPSHChangeRegistration;

typedef struct _SHChangeNotification {
    DWORD   dwSize;
    LONG    lEvent;
    UINT    uFlags;
    UINT    cRef;
    DWORD   dwEventTime;
    UINT    uidlMain;
    UINT    uidlExtra;
} SHChangeNotification, *LPSHChangeNotification;

typedef struct _SHChangeNotificationLock {
    LPITEMIDLIST            pidlMain;
    LPITEMIDLIST            pidlExtra;
    LPSHChangeNotification  pshcn;
#ifdef DEBUG
    DWORD                   dwSignature;
#endif
} SHChangeNotificationLock, * LPSHChangeNotificationLock;

typedef struct _SHChangeDWORDAsIDList {
    USHORT   cb;
    DWORD    dwItem1;
    DWORD    dwItem2;
    USHORT   cbZero;
} SHChangeDWORDAsIDList, *LPSHChangeDWORDAsIDList;



#if (_WIN32_IE >= 0x0400)

// Use this instead of SHChangeDWORDAsIDList for SHCNEE_ORDERCHANGED
// SHCNEE_PROMOTEDITEM and SHCNEE_DEMOTEDITEM
//
// When filling in the pSender, cast LPVOID directly to INT64.
// Do not cast through DWORD_PTR because that will not sign extend
// properly on Win32.

typedef struct _SHChangeMenuAsIDList {
    USHORT  cb;
    DWORD   dwItem1;        // SHCNEE_EXTENDED_EVENT requires this
    // pSender must appear immediately after dwItem1 for IE5.0 compat
    INT64 pSender;          // address of sender (64-bit for Win64)
    DWORD   dwProcessID;    // pid of sender
    USHORT  cbZero;
} SHChangeMenuAsIDList, * LPSHChangeMenuAsIDList;

typedef struct _SHChangeUpdateImageIDList {
    USHORT cb;
    int iIconIndex;
    int iCurIndex;
    UINT uFlags;
    DWORD dwProcessID;
    WCHAR szName[MAX_PATH];
    USHORT cbZero;
} SHChangeUpdateImageIDList, * LPSHChangeUpdateImageIDList;

SHSTDAPI_(int)  SHHandleUpdateImage( LPCITEMIDLIST pidlExtra );			
#endif /* _WIN32_IE */
#define SHChangeNotifyHandleEvents() SHChangeNotify(0, SHCNF_FLUSH, NULL, NULL)
SHSTDAPI_(ULONG) SHChangeNotifyRegister(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, SHChangeNotifyEntry *pshcne);
#define SHChangeNotifyRegisterORD 2
SHSTDAPI_(BOOL) SHChangeNotifyDeregister(unsigned long ulID);
#define SHChangeNotifyDeregisterORD 4

SHSTDAPI_(BOOL) SHChangeNotifyUpdateEntryList(unsigned long ulID, int iUpdateType, int cEntries, SHChangeNotifyEntry *pshcne);

SHSTDAPI_(void)   SHChangeNotifyReceive(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
SHSTDAPI_(HANDLE) SHChangeNotification_Create(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidlMain, LPCITEMIDLIST pidlExtra, DWORD dwProcessId, DWORD dwEventTime);
SHSTDAPI_(ULONG)  SHChangeNotification_Release(HANDLE hChangeNotification, DWORD dwProcessId);
SHSTDAPI_(LPSHChangeNotificationLock) SHChangeNotification_Lock(HANDLE hChangeNotification, DWORD dwProcessId, LPITEMIDLIST **pppidl, LONG *plEvent);
SHSTDAPI_(BOOL) SHChangeNotification_Unlock(LPSHChangeNotificationLock pshcnl);
SHSTDAPI_(BOOL) SHChangeRegistrationReceive(HANDLE hChangeNotification, DWORD dwProcId);
SHSTDAPI_(void) SHChangeNotifyDeregisterWindow(HWND hwnd);
SHSTDAPI_(LRESULT) SHChangeNotifySuspendResumeReceive(WPARAM wParam, LPARAM lParam);
SHSTDAPI_(BOOL) SHChangeNotifySuspendResume(BOOL bSuspend, LPITEMIDLIST pidlSuspend, BOOL bRescursive, DWORD dwReserved);

#if (_WIN32_IE >= 0x0400)
// The pidls that are given to the view via the ChangeNotifyEvents are simple Pidls,
// SHGetRealIDL() will convert them to true PIDLs.
SHSTDAPI SHGetRealIDL(IShellFolder *psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST * ppidlReal);
#endif // _WIN32_IE >= 0x0400
#ifndef NOOCHOST // {

//
// ====== OCHOST CONTROL ==========================================
//
// The following are all definations of structures, windows messages needed for OCHOST,
// the window control you can use to host an OC.
// To use OCHOST, you must specify the window class as OCHOST_CLASS or "OCHOST"
// -- To Create and initialize OCHOST:
// 1. CreateWindow with window title = the string version of class id or the OC
// 2. CreateWindow with a pointer to the OCHINITSTRUCT structure as the last parameter
//    you must allocate and initialize the OCHINITSTRUCT structure
// 3. CreateWindow with no title and the last param == NULL, then use the OCM_INITIALIZE message
//    or the OCHost_InitOC macro to initialize it.
// 4. Use OCM_QUERYINTERFACE to QI an interface pointer from the OC.
// 5. Simply destroy the window when you exit.

// SHDRC -- Shell Doc Register Classes

typedef struct _SHDRC {
    DWORD cbSize;   // size of this structure in bytes
    DWORD dwFlags;  // SHDRCF_ flags
} SHDRC;

#define SHDRCF_OCHOST   0x0001 // Register the OCHOST_CLASS window
#define SHDRCF_ALL      0x0001 //

SHDOCAPI_(BOOL)     DllRegisterWindowClasses(const SHDRC * pshdrc);
BROWSEUIAPI_(BOOL)  InitOCHostClass(const SHDRC *pshdrc);

#define OCHOST_CLASSA   "OCHost"
#define OCHOST_CLASSW   L"OCHost"

#ifdef UNICODE
#define OCHOST_CLASS    OCHOST_CLASSW
#else
#define OCHOST_CLASS    OCHOST_CLASSA
#endif

// ------------------- Window messages for OC Host --------------------

// IUnknown::QueryInterface the hosted OC
typedef struct _QIMSG {
    const IID * qiid;
    void **ppvObject;
} QIMSG, *LPQIMSG;

// ................. Query Interface Message ..........
#define OCM_QUERYINTERFACE      (WM_USER+0)

#ifdef __cplusplus
inline HRESULT OCHost_QueryInterface(HWND hwndOCH, REFIID riid, void **ppv) \
{ QIMSG qimsg = {&riid, ppv}; \
  return (HRESULT)SNDMSG((hwndOCH), OCM_QUERYINTERFACE, (WPARAM)sizeof(qimsg), (LPARAM)&qimsg); \
}
#else
#define OCHost_QueryInterface(hwndOCH, riid, ppv) \
{ QIMSG qimsg = {&riid, ppv}; \
  SNDMSG((hwndOCH), OCM_QUERYINTERFACE, (WPARAM)sizeof(qimsg), (LPARAM)&qimsg); \
}
#endif


// ------------------- OC Initialization Structure ---------------------
// This is intended to be passed in as the lParam of the OCM_INITOC message
typedef struct _OCHINITSTRUCT {
    UINT cbSize;                    // size of this structure
    CLSID clsidOC;                  // class ID of the OC
    IUnknown * punkOwner;           // owner of OCHOST
} OCHINITSTRUCT, *LPOCHINITSTRUCT;
//--------------------------------------------------------------------

// ................ Initialize and activate the OC ...............
#define OCM_INITIALIZE      (WM_USER+1)
#define OCM_INITOC          OCM_INITIALIZE
#define OCHost_InitOC(hwndOCH, lpOCS) \
  (HRESULT)SNDMSG((hwndOCH), OCM_INITOC, 0, (LPARAM)lpOCS)


// ............... give ochost a parent IUnknown .......
#define OCM_SETOWNER            (WM_USER+2)
#define OCHost_SetOwner(hwndOC, punk) \
  (HRESULT)SNDMSG((hwndOC), OCM_SETOWNER, 0, (LPARAM)(IUnknown*)(punk))

// ............... DoVerb the OC .......
// n.b. iVerb is technically a long, WPARAM might truncate it
#define OCM_DOVERB              (WM_USER+3)
#define OCHost_DoVerb(hwndOC, iVerb, lpMsg) \
  (HRESULT)SNDMSG((hwndOC), OCM_DOVERB, (WPARAM)iVerb, (LPARAM)lpMsg)

//.................Enable/Disable OC event notifications
#define OCM_ENABLEEVENTS       (WM_USER+4)
//  WPARAM: TRUE to enable event notifications, FALSE to disable.
//  returns: TRUE if successful, otherwise FALSE.
//  Event notification is in the form of a WM_NOTIFY with
//  code OCN_OCEVENT and an NMOCEVENT block.

#define OCHost_EnableEvents(hwndOC, bEnable) \
    (BOOL)SNDMSG((hwndOC), OCM_ENABLEEVENTS, (WPARAM)bEnable, 0L)

// ------------------ Window Notify messages from OC Host --------------

#define OCN_FIRST               0x1300
#define OCN_COCREATEINSTANCE    (OCN_FIRST + 1)

typedef struct _OCNCOCREATEMSG {
    NMHDR nmhdr;
    CLSID clsidOC;
    IUnknown ** ppunk;
} OCNCOCREATEMSG, *LPOCNCOCREATEMSG;

// NOTE: return values are defined as the following
// If the handler of OCN_COCREATEINSTANCE Notify message returns OCNCOCREATE_ALREADYCREATED,
// on return the (*ppvObj) is assumed to have the value of the OC's IUnkown pointer
#define OCNCOCREATE_CONTINUE       0
#define OCNCOCREATE_HANDLED       -1


#define OCN_PERSISTINIT         (OCN_FIRST + 2)
// NOTE: return values are defined as the following
// If the handler of OCN_PERSISTINIT Notify message returns OCNPERSIST_ABORT,
// the OCHOST will abort IPersist's initialization.
#define OCNPERSISTINIT_CONTINUE    0
#define OCNPERSISTINIT_HANDLED    -1

// The return value on the following notify messages are ignored.
#define OCN_ACTIVATE            (OCN_FIRST + 3)
#define OCN_DEACTIVATE          (OCN_FIRST + 4)
#define OCN_EXIT                (OCN_FIRST + 5)
#define OCN_ONPOSRECTCHANGE     (OCN_FIRST + 6)

typedef struct _OCNONPOSRECTCHANGEMSG {
    NMHDR nmhdr;
    LPCRECT prcPosRect;
} OCNONPOSRECTCHANGEMSG, *LPOCNONPOSRECTCHANGEMSG;

#define OCN_ONUIACTIVATE        (OCN_FIRST + 7)
typedef struct _OCNONUIACTIVATEMSG {
    NMHDR nmhdr;
    IUnknown *punk;
} OCNONUIACTIVATEMSG, *LPOCNONUIACTIVATEMSG;

#define OCNONUIACTIVATE_HANDLED       -1

#define OCN_ONSETSTATUSTEXT     (OCN_FIRST + 8)
typedef struct _OCNONSETSTATUSTEXT {
    NMHDR nmhdr;
    LPCOLESTR pwszStatusText;
} OCNONSETSTATUSTEXTMSG, *LPOCNONSETSTATUSTEXTMSG;


#define OCN_OCEVENT    (OCN_FIRST + 9)
//  OC event notification block.
//  Recipient should return nonzero if any outbound parameters were modified
//  and should be returned to the ActiveX control object; otherwse zero.
typedef struct tagNMOCEVENT
{
    IN NMHDR           hdr ;
    IN DISPID          dispID ;
    IN IID             iid ;
    IN LCID            lcid ;
    IN WORD            wFlags ;
    IN OUT DISPPARAMS  *pDispParams ;
    OUT VARIANT        *pVarResult ;
    OUT EXCEPINFO      *pExepInfo ;
    OUT UINT           *puArgErr ;
} NMOCEVENT, *PNMOCEVENT, *LPNMOCEVENT ;


#endif // NOOCHOST // }

//
// Access to shdocvw's active session count
//
enum SessionOp {
    SESSION_QUERY = 0,
    SESSION_INCREMENT,
    SESSION_DECREMENT,
	SESSION_INCREMENT_NODEFAULTBROWSERCHECK
};

long SetQueryNetSessionCount(enum SessionOp Op);
void IEWriteErrorLog(const EXCEPTION_RECORD* pexr);

//
// Internal APIs Follow.  NOT FOR PUBLIC CONSUMPTION.
//

// Errors shared in the shell

#define E_FILE_NOT_FOUND        MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND        MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)


// Useful macros

#define ResultFromShort(i)      MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(i))
#define ShortFromResult(r)      (short)HRESULT_CODE(r)


#if (defined(UNICODE) && !defined(_X86_)) // all non-x86 systems require alignment
#ifndef ALIGNMENT_SCENARIO
#define ALIGNMENT_SCENARIO
#endif
#endif

#ifndef LPNTSTR_DEFINED
#define LPNTSTR_DEFINED
typedef UNALIGNED const WCHAR * LPNCWSTR;
typedef UNALIGNED WCHAR *       LPNWSTR;
#ifdef UNICODE
#define LPNCTSTR        LPNCWSTR
#define LPNTSTR         LPNWSTR
#else
#define LPNCTSTR        LPCSTR
#define LPNTSTR         LPSTR
#endif
#endif // LPNTSTR_DEFINED

#define RFN_FIRST       (0U-510U) // run file dialog notify
#define RFN_LAST        (0U-519U)


//=======================================================================
// String constants for
//  1. Registration database keywords       (prefix STRREG_)
//  2. Exported functions from handler dlls (prefix STREXP_)
//  3. .INI file keywords                   (prefix STRINI_)
//  4. Others                               (prefix STR_)
//=======================================================================
#define STRREG_SHELLUI          TEXT("ShellUIHandler")
#define STRREG_SHELL            TEXT("Shell")
#define STRREG_DEFICON          TEXT("DefaultIcon")
#define STRREG_SHEX             TEXT("shellex")
#define STRREG_SHEX_PROPSHEET   STRREG_SHEX TEXT("\\PropertySheetHandlers")
#define STRREG_SHEX_DDHANDLER   STRREG_SHEX TEXT("\\DragDropHandlers")
#define STRREG_SHEX_MENUHANDLER STRREG_SHEX TEXT("\\ContextMenuHandlers")
#define STRREG_SHEX_COPYHOOK    TEXT("Directory\\") STRREG_SHEX TEXT("\\CopyHookHandlers")
#define STRREG_SHEX_PRNCOPYHOOK TEXT("Printers\\") STRREG_SHEX TEXT("\\CopyHookHandlers")
#define STRREG_STARTMENU TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Start Menu")
#define STRREG_FAVORITES TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Favorites")
#define STRREG_DISCARDABLE      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Discardable")
#define STRREG_POSTSETUP        TEXT("\\PostSetup")

#define STREXP_CANUNLOAD        "DllCanUnloadNow"       // From OLE 2.0

#define STRINI_CLASSINFO        TEXT(".ShellClassInfo")       // secton name
#define STRINI_SHELLUI          TEXT("ShellUIHandler")
#define STRINI_OPENDIRICON      TEXT("OpenDirIcon")
#define STRINI_DIRICON          TEXT("DirIcon")

#define STR_DESKTOPINI          TEXT("desktop.ini")
#define STR_DESKTOPINIA         "desktop.ini"

#define DRIVEID(path)   ((*path - 'A') & 31)

#define PATH_CCH_EXT    64
// PathResolve flags
#define PRF_VERIFYEXISTS            0x0001
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)
#define PRF_FIRSTDIRDEF             0x0004
#define PRF_DONTFINDLNK             0x0008      // if PRF_TRYPROGRAMEXTENSIONS is specified

#ifndef NOUSER

typedef struct {
    NMHDR  hdr;
    CHAR   szCmd[MAX_PATH*2];
    DWORD  dwHotKey;
    HMONITOR hMonitor;
} NMVIEWFOLDERA, *LPNMVIEWFOLDERA;
typedef struct {
    NMHDR  hdr;
    WCHAR  szCmd[MAX_PATH*2];
    DWORD  dwHotKey;
    HMONITOR hMonitor;
} NMVIEWFOLDERW, *LPNMVIEWFOLDERW;
#ifdef UNICODE
typedef NMVIEWFOLDERW NMVIEWFOLDER;
typedef LPNMVIEWFOLDERW LPNMVIEWFOLDER;
#else
typedef NMVIEWFOLDERA NMVIEWFOLDER;
typedef LPNMVIEWFOLDERA LPNMVIEWFOLDER;
#endif // UNICODE

#endif

//
//  DDE related APIs
//
STDAPI_(void) ShellDDEInit(BOOL fInit);
STDAPI_(BOOL) DDEHandleViewFolderNotify(IShellBrowser* psb, HWND hwnd, LPNMVIEWFOLDER lpnm);
STDAPI_(LPNMVIEWFOLDER) DDECreatePostNotify(LPNMVIEWFOLDER lpnm);

SHSTDAPI_(int) RestartDialog(HWND hwnd, LPCTSTR lpPrompt, DWORD dwReturn);

SHSTDAPI SHCoCreateInstance(LPCTSTR pszCLSID, const CLSID * lpclsid, IUnknown *pUnkOuter, REFIID riid, void **ppv);

SHSTDAPI CIDLData_CreateFromIDArray(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject ** ppdtobj);


// Common strings
#define STR_DESKTOPCLASS        "Progman"

//
// Storage name of a scrap/bookmark item
//
#define WSTR_SCRAPITEM L"\003ITEM000"


// For CallCPLEntry16
//
DECLARE_HANDLE(FARPROC16);
STDAPI_(LRESULT) CallCPLEntry16(HINSTANCE hinst, FARPROC16 lpfnEntry, HWND hwndCPL, UINT msg, LPARAM lParam1, LPARAM lParam2);

#ifdef RFN_FIRST
#define RFN_EXECUTE             (RFN_FIRST - 0)
typedef struct {
    NMHDR hdr;
    LPCSTR   lpszCmd;
    LPCSTR   lpszWorkingDir;
    int nShowCmd;
} NMRUNFILEA, *LPNMRUNFILEA;
typedef struct {
    NMHDR hdr;
    LPCWSTR  lpszCmd;
    LPCWSTR  lpszWorkingDir;
    int nShowCmd;
} NMRUNFILEW, *LPNMRUNFILEW;
#ifdef UNICODE
typedef NMRUNFILEW NMRUNFILE;
typedef LPNMRUNFILEW LPNMRUNFILE;
#else
typedef NMRUNFILEA NMRUNFILE;
typedef LPNMRUNFILEA LPNMRUNFILE;
#endif // UNICODE

#endif


SHSTDAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], IEnumFORMATETC **ppenumFormatEtc);


// Shell create link API
#define SHCL_USETEMPLATE        0x0001
#define SHCL_USEDESKTOP         0x0002
#define SHCL_CONFIRM            0x0004
#define SHCL_MAKEFOLDERSHORTCUT 0x0008

SHSTDAPI SHCreateLinks(HWND hwnd, LPCTSTR pszDir, IDataObject *pDataObj, UINT fFlags, LPITEMIDLIST* ppidl);

SHSTDAPI SHRegisterDragDrop(HWND hwnd, IDropTarget *pdtgt);
SHSTDAPI SHRevokeDragDrop(HWND hwnd);
SHSTDAPI SHDoDragDrop(HWND hwnd, IDataObject *pdata, IDropSource *pdsrc, DWORD dwEffect, DWORD *pdwEffect);

//===========================================================================
// office 9 pluggable UI
//===========================================================================

#define PUI_OFFICE_COMMAND     (WM_USER + 0x901)
#define PLUGUI_CMD_SHUTDOWN    0 // wParam value
#define PLUGUI_CMD_QUERY       1 // wParam value
#define OFFICE_VERSION_9       9 // standardized value to return for Office 9 apps

typedef struct _PLUGUI_INFO
{
    unsigned uMajorVersion : 8; // Used to indicate App's major version number
    unsigned uOleServer : 1;    // BOOL, TRUE if this is an OLE process
    unsigned uUnused : 23;      // not used
} PLUGUI_INFO;

typedef union _PLUGUI_QUERY
{
    UINT uQueryVal;
    PLUGUI_INFO PlugUIInfo;
} PLUGUI_QUERY;

//===========================================================================
// Image dragging API (definitely private)
//===========================================================================

// stuff for doing auto scrolling
#define NUM_POINTS      3
typedef struct {        // asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

//Contains the drag context header.
typedef struct {
    BOOL  fImage;
    BOOL  fLayered;
    POINT ptOffset;
} DragContextHeader;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0

SHSTDAPI_(BOOL) DAD_SetDragImage(HIMAGELIST him, POINT * pptOffset);
SHSTDAPI_(BOOL) DAD_DragEnter(HWND hwndTarget);
SHSTDAPI_(BOOL) DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
SHSTDAPI_(BOOL) DAD_DragEnterEx2(HWND hwndTarget, const POINT ptStart, IDataObject *pdtObject);
SHSTDAPI_(BOOL) DAD_ShowDragImage(BOOL fShow);
SHSTDAPI_(BOOL) DAD_DragMove(POINT pt);
SHSTDAPI_(BOOL) DAD_DragLeave(void);
SHSTDAPI_(BOOL) DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
SHSTDAPI_(BOOL) DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset);
SHSTDAPI_(void) DAD_InvalidateCursors(void);



//----------------------------------------------------------------------------
// CABINETSTATE holds the global configuration for the Explorer and its cohorts.
//
// Originally the cLength was an 'int', it is now two words, allowing us to
// specify a version number.
//----------------------------------------------------------------------------

typedef struct {
    WORD cLength;
    WORD nVersion;

    BOOL fFullPathTitle            : 1;
    BOOL fSaveLocalView            : 1;
    BOOL fNotShell                 : 1;
    BOOL fSimpleDefault            : 1;
    BOOL fDontShowDescBar          : 1;
    BOOL fNewWindowMode            : 1;
    BOOL fShowCompColor            : 1;  // NT: Show compressed volumes in a different colour
    BOOL fDontPrettyNames          : 1;  // NT: Do 8.3 name conversion, or not!
    BOOL fAdminsCreateCommonGroups : 1;  // NT: Administrators create comon groups
    UINT fUnusedFlags : 7;

    UINT fMenuEnumFilter;

} CABINETSTATE, * LPCABINETSTATE;

#define CABINETSTATE_VERSION 2

// APIs for reading and writing the cabinet state.
SHSTDAPI_(BOOL) ReadCabinetState( LPCABINETSTATE lpState, int iSize );
SHSTDAPI_(BOOL) WriteCabinetState( LPCABINETSTATE lpState );


// RUN FILE RETURN values from notify message
#define RFR_NOTHANDLED 0
#define RFR_SUCCESS 1
#define RFR_FAILURE 2

#define PathGetExtensionORD     158

SHSTDAPI_(LPTSTR) PathGetExtension(LPCTSTR pszPath, LPTSTR pszExtension, int cchExt);
SHSTDAPI_(BOOL) PathMakeUniqueName(LPTSTR pszUniqueName, UINT cchMax, LPCTSTR pszTemplate, LPCTSTR pszLongPlate, LPCTSTR pszDir);
SHSTDAPI_(BOOL) PathGetShortName(LPCTSTR pszLongName, LPTSTR pszShortName, UINT cbShortName);
SHSTDAPI_(BOOL) PathGetLongName(LPCTSTR pszShortName, LPTSTR pszLongName, UINT cbLongName);
SHSTDAPI_(BOOL) PathDirectoryExists(LPCTSTR pszDir);
SHSTDAPI_(void) PathQualify(LPTSTR psz);
SHSTDAPI_(LPTSTR) PathGetNextComponent(LPCTSTR pszPath, LPTSTR pszComponent);
SHSTDAPI_(BOOL) PathIsExe(LPCTSTR pszPath);

SHSTDAPI_(BOOL) PathIsSlowA(LPCSTR pszFile, DWORD dwAttr);
SHSTDAPI_(BOOL) PathIsSlowW(LPCWSTR pszFile, DWORD dwAttr);
#ifdef UNICODE
#define PathIsSlow  PathIsSlowW
#else
#define PathIsSlow  PathIsSlowA
#endif // !UNICODE
SHSTDAPI_(BOOL) PathIsTemporaryA(LPCSTR pszPath);
SHSTDAPI_(BOOL) PathIsTemporaryW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsTemporary  PathIsTemporaryW
#else
#define PathIsTemporary  PathIsTemporaryA
#endif // !UNICODE

//
//  Return codes from PathCleanupSpec.  Negative return values are
//  unrecoverable errors
//
#define PCS_FATAL           0x80000000
#define PCS_REPLACEDCHAR    0x00000001
#define PCS_REMOVEDCHAR     0x00000002
#define PCS_TRUNCATED       0x00000004
#define PCS_PATHTOOLONG     0x00000008  // Always combined with FATAL

SHSTDAPI_(int) PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec);
SHSTDAPI_(int) PathCleanupSpecEx(LPCTSTR pszDir, LPTSTR pszSpec);
SHSTDAPI_(int) PathResolve(LPTSTR pszPath, LPCTSTR dirs[], UINT fFlags);
SHSTDAPI_(BOOL) ParseField(LPCTSTR szData, int n, LPTSTR szBuf, int iBufLen);

// Needed for RunFileDlg
#define RFD_NOBROWSE            0x00000001
#define RFD_NODEFFILE           0x00000002
#define RFD_USEFULLPATHDIR      0x00000004
#define RFD_NOSHOWOPEN          0x00000008
#define RFD_WOW_APP             0x00000010
#define RFD_NOSEPMEMORY_BOX     0x00000020


SHSTDAPI_(int) RunFileDlg(HWND hwnd, HICON hIcon, LPCTSTR pszWorkingDir, LPCTSTR pszTitle,
                          LPCTSTR pszPrompt, DWORD dwFlags);

SHSTDAPI_(BOOL) GetFileNameFromBrowse(HWND hwnd, LPTSTR pszFilePath, UINT cbFilePath,
                                      LPCTSTR pszWorkingDir, LPCTSTR pszDefExt, LPCTSTR pszFilters, LPCTSTR pszTitle);

SHSTDAPI_(int) DriveType(int iDrive);
SHSTDAPI_(int) RealDriveTypeFlags(int iDrive, BOOL fOKToHitNet);
SHSTDAPI_(int) RealDriveType(int iDrive, BOOL fOKToHitNet);
SHSTDAPI_(void) InvalidateDriveType(int iDrive);
SHSTDAPI_(int) IsNetDrive(int iDrive);

//
// Constants used for dwNumFmtFlags argument in Int64ToString and LargeIntegerToString.
//
#define NUMFMT_IDIGITS    0x00000001
#define NUMFMT_ILZERO     0x00000002
#define NUMFMT_SGROUPING  0x00000004
#define NUMFMT_SDECIMAL   0x00000008
#define NUMFMT_STHOUSAND  0x00000010
#define NUMFMT_INEGNUMBER 0x00000020
#define NUMFMT_ALL        0xFFFFFFFF

SHSTDAPI_(int) LargeIntegerToString(LARGE_INTEGER *pN, LPTSTR szOutStr, UINT nSize, BOOL bFormat, NUMBERFMT *pFmt, DWORD dwNumFmtFlags);
SHSTDAPI_(int) Int64ToString(_int64 n, LPTSTR szOutStr, UINT nSize, BOOL bFormat, NUMBERFMT *pFmt, DWORD dwNumFmtFlags);

//-------- drive type identification --------------
// iDrive      drive index (0=A, 1=B, ...)
//
#define DRIVE_CDROM     5           // extended DriveType() types
#define DRIVE_RAMDRIVE  6
#define DRIVE_TYPE      0x000F      // type masek
#define DRIVE_SLOW      0x0010      // drive is on a slow link
#define DRIVE_LFN       0x0020      // drive supports LFNs
#define DRIVE_AUTORUN   0x0040      // drive has AutoRun.inf in root.
#define DRIVE_AUDIOCD   0x0080      // drive is a AudioCD
#define DRIVE_AUTOOPEN  0x0100      // should *always* auto open on insert
#define DRIVE_NETUNAVAIL 0x0200     // Network drive that is not available
#define DRIVE_SHELLOPEN  0x0400     // should auto open on insert, if shell has focus
#define DRIVE_SECURITY   0x0800     // Supports ACLs
#define DRIVE_COMPRESSED 0x1000     // Root of volume is compressed
#define DRIVE_ISCOMPRESSIBLE 0x2000 // Drive supports compression (not nescesarrily compressed)
#define DRIVE_DVD       0x4000      // drive is a DVD

#define DriveTypeFlags(iDrive)      DriveType('A' + (iDrive))
#define DriveIsSlow(iDrive)         (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_SLOW)
#define DriveIsLFN(iDrive)          (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_LFN)
#define DriveIsAutoRun(iDrive)      (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUTORUN)
#define DriveIsAutoOpen(iDrive)     (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUTOOPEN)
#define DriveIsShellOpen(iDrive)    (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_SHELLOPEN)
#define DriveIsAudioCD(iDrive)      (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUDIOCD)
#define DriveIsNetUnAvail(iDrive)   (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_NETUNAVAIL)
#define DriveIsSecure(iDrive)       (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_SECURITY)
#define DriveIsCompressed(iDrive)   (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_COMPRESSED)
#define DriveIsCompressible(iDrive) (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_ISCOMPRESSIBLE)
#define DriveIsDVD(iDrive)          (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_DVD)

#define IsCDRomDrive(iDrive)        (RealDriveType(iDrive, FALSE) == DRIVE_CDROM)
#define IsRamDrive(iDrive)          (RealDriveType(iDrive, FALSE) == DRIVE_RAMDRIVE)
#define IsRemovableDrive(iDrive)    (RealDriveType(iDrive, FALSE) == DRIVE_REMOVABLE)
#define IsRemoteDrive(iDrive)       (RealDriveType(iDrive, FALSE) == DRIVE_REMOTE)


//
// For SHCreateDefClassObject
//
typedef HRESULT (CALLBACK *LPFNCREATEINSTANCE)(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);

SHSTDAPI SHCreateDefClassObject(REFIID riid, void **ppv, LPFNCREATEINSTANCE lpfn, UINT *pcRefDll, REFIID riidInstance);


// Flags for Shell_MergeMenus
#define MM_ADDSEPARATOR         0x00000001L
#define MM_SUBMENUSHAVEIDS      0x00000002L
#define MM_DONTREMOVESEPS       0x00000004L

SHSTDAPI_(UINT) Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);


typedef HANDLE HNRES;           // for SHGetNetResource

SHSTDAPI_(UINT) SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnres, UINT cbMax);


/*
 * The SHObjectProperties API provides an easy way to invoke
 *   the Properties context menu command on shell objects.
 *
 *   PARAMETERS
 *
 *     hwnd    The window handle of the window which will own the dialog
 *     dwType       A SHOP_ value as defined below
 *     lpObject     Name of the object, see SHOP_ values below
 *     lpPage       The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 */
SHSTDAPI_(BOOL) SHObjectProperties(HWND hwnd, DWORD dwType, LPCTSTR lpObject, LPCTSTR lpPage);

#define SHOP_PRINTERNAME 0x00000001  // lpObject points to a printer friendly name
#define SHOP_FILEPATH    0x00000002  // lpObject points to a fully qualified path+file name
#define SHOP_VOLUMEGUID  0x00000004  // lpObject points to a Volume GUID
#define SHOP_TYPEMASK	 0x00000007
#define SHOP_MODAL       0x80000000


/*
 * The SHFormatDrive API provides access to the Shell
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that the Shell does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *               NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *               this dialog to come up as a "top level application" window.
 *               This parameter should always be non-null, this dialog is
 *               only designed to be the child of another window, not a
 *               stand-alone application.
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *               NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *                     default format specified by the DMaint_FormatDrive
 *                     engine". If you want to FORCE a particular format
 *                     ID "up front" you will have to call
 *                     DMaint_GetFormatOptions yourself before calling
 *                     this to obtain the valid list of phys format IDs
 *                     (contents of the PhysFmtIDList array in the
 *                     FMTINFOSTRUCT).
 *     options = There is currently only two option bits defined
 *
 *                SHFMT_OPT_FULL
 *                SHFMT_OPT_SYSONLY
 *
 *               The normal defualt in the Shell format dialog is
 *               "Quick Format", setting this option bit indicates that
 *               the caller wants to start with FULL format selected
 *               (this is useful for folks detecting "unformatted" disks
 *               and wanting to bring up the format dialog).
 *
 *               The SHFMT_OPT_SYSONLY initializes the dialog to
 *               default to just sys the disk.
 *
 *               All other bits are reserved for future expansion and
 *               must be 0.
 *
 *               Please note that this is a bit field and not a value
 *               and treat it accordingly.
 *
 *   RETURN
 *      The return is either one of the SHFMT_* values, or if the
 *      returned DWORD value is not == to one of these values, then
 *      the return is the physical format ID of the last succesful
 *      format. The LOWORD of this value can be passed on subsequent
 *      calls as the fmtID parameter to "format the same type you did
 *      last time".
 *
 */
SHSTDAPI_(DWORD) SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);

SHSTDAPI_(DWORD) SHChkDskDrive(HWND hwnd, UINT drive);

//
// Special value of fmtID which means "use the default format"
//
#define SHFMT_ID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define SHFMT_OPT_FULL     0x0001
#define SHFMT_OPT_SYSONLY  0x0002

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define SHFMT_ERROR     0xFFFFFFFFL     // Error on last format, drive may be formatable
#define SHFMT_CANCEL    0xFFFFFFFEL     // Last format was canceled
#define SHFMT_NOFORMAT  0xFFFFFFFDL     // Drive is not formatable

//====== SEMI-PRIVATE API ===============================
#ifndef HPSXA_DEFINED
#define HPSXA_DEFINED
DECLARE_HANDLE( HPSXA );
#endif
WINSHELLAPI HPSXA SHCreatePropSheetExtArray( HKEY hKey, LPCTSTR pszSubKey, UINT max_iface );
WINSHELLAPI void SHDestroyPropSheetExtArray( HPSXA hpsxa );
WINSHELLAPI UINT SHAddFromPropSheetExtArray( HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT SHReplaceFromPropSheetExtArray( HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );
WINSHELLAPI HPSXA SHCreatePropSheetExtArrayEx( HKEY hKey, LPCTSTR pszSubKey, UINT max_iface, IDataObject * pdo );

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHGetNetResourceORD                      69
#define SHObjectPropertiesORD                   178
#define SHAddFromPropSheetExtArrayORD           167
#define SHCreatePropSheetExtArrayORD            168
#define SHDestroyPropSheetExtArrayORD           169
#define SHReplaceFromPropSheetExtArrayORD       170
#define SHCreateDefClassObjectORD                70

#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)

#define SHEXP_SHADDFROMPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHAddFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEPROPSHEETEXTARRAY         MAKEINTRESOURCE(SHCreatePropSheetExtArrayORD)
#define SHEXP_SHDESTROYPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHDestroyPropSheetExtArrayORD)
#define SHEXP_SHREPLACEFROMPROPSHEETEXTARRAY    MAKEINTRESOURCE(SHReplaceFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)


// This avoids duplicate definition problems in the net\config project
// which defines *some* of its own PIDL utility functions, but depends on
// us for others (ILClone())
SHSTDAPI_(LPITEMIDLIST) ILClone(LPCITEMIDLIST pidl);

#ifndef AVOID_NET_CONFIG_DUPLICATES
//===========================================================================
// ITEMIDLIST
//===========================================================================

// flags for ILGetDisplayNameEx
#define ILGDN_FULLNAME  0
#define ILGDN_ITEMONLY  1
#define ILGDN_INFOLDER  2

SHSTDAPI_(LPITEMIDLIST) ILGetNext(LPCITEMIDLIST pidl);
SHSTDAPI_(UINT)         ILGetSize(LPCITEMIDLIST pidl);
SHSTDAPI_(LPITEMIDLIST) ILFindLastID(LPCITEMIDLIST pidl);
SHSTDAPI_(BOOL)         ILRemoveLastID(LPITEMIDLIST pidl);

#define ILIsEmpty(pidl)     ((pidl) == NULL || (pidl)->mkid.cb==0)

SHSTDAPI_(LPITEMIDLIST) ILCreate(void);
SHSTDAPI_(LPITEMIDLIST) ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend);
SHSTDAPI_(void)         ILFree(LPITEMIDLIST pidl);
SHSTDAPI_(void)         ILGlobalFree(LPITEMIDLIST pidl);
SHSTDAPI_(BOOL)         ILGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName);
SHSTDAPI_(BOOL)         ILGetDisplayNameEx(IShellFolder *psfRoot, LPCITEMIDLIST pidl, LPTSTR pszName, int fType);
SHSTDAPI_(BOOL)         ILGetPseudoNameA(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlBase, LPSTR pszName, int fType);
SHSTDAPI_(BOOL)         ILGetPseudoNameW(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlBase, LPWSTR pszName, int fType);
#ifdef UNICODE
#define ILGetPseudoName  ILGetPseudoNameW
#else
#define ILGetPseudoName  ILGetPseudoNameA
#endif // !UNICODE

SHSTDAPI_(LPITEMIDLIST) ILCloneFirst(LPCITEMIDLIST pidl);
SHSTDAPI_(LPITEMIDLIST) ILGlobalClone(LPCITEMIDLIST pidl);
SHSTDAPI_(BOOL)         ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
SHSTDAPI_(BOOL)         ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
SHSTDAPI_(LPITEMIDLIST) ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);
SHSTDAPI_(LPITEMIDLIST) ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
SHSTDAPI                ILLoadFromStream(IStream *pstm, LPITEMIDLIST *pidl);
SHSTDAPI                ILSaveToStream(IStream *pstm, LPCITEMIDLIST pidl);
SHSTDAPI                ILLoadFromFile(HFILE hfile, LPITEMIDLIST *pidl);
SHSTDAPI                ILSaveToFile(HFILE hfile, LPCITEMIDLIST pidl);
SHSTDAPI_(LPITEMIDLIST) _ILCreate(UINT cbSize);

#if (_WIN32_IE >= 0x0400)
SHSTDAPI_(LPITEMIDLIST) ILCreateFromPathA(LPCSTR pszPath);
SHSTDAPI_(LPITEMIDLIST) ILCreateFromPathW(LPCWSTR pszPath);
#ifdef UNICODE
#define ILCreateFromPath  ILCreateFromPathW
#else
#define ILCreateFromPath  ILCreateFromPathA
#endif // !UNICODE
#endif
SHSTDAPI SHILCreateFromPath(LPCTSTR szPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);

// helper macros
#define ILCreateFromID(pmkid)   ILAppendID(NULL, pmkid, TRUE)

#endif // AVOID_NET_CONFIG_DUPLICATES

//
#undef  INTERFACE
#define INTERFACE   IDefViewFrame
DECLARE_INTERFACE_(IDefViewFrame, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewFrame methods ***
    STDMETHOD(GetWindowLV) (THIS_ HWND * phwnd) PURE;
    STDMETHOD(ReleaseWindowLV) (THIS) PURE;
    STDMETHOD(GetShellFolder)(THIS_ IShellFolder **ppsf) PURE;

    // Warning!  Do not change or add any methods to this interface
    // because IE4 shell32.dll uses it, so changing the interface
    // breaks IE4 interop.

};

// Warning!  IE4's shell32.dll does not support IDefViewFrame2, so make
//           sure you can survive its absence.

#undef  INTERFACE
#define INTERFACE   IDefViewFrame2
DECLARE_INTERFACE_(IDefViewFrame2, IDefViewFrame)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewFrame methods ***
    STDMETHOD(GetWindowLV) (THIS_ HWND * phwnd) PURE;
    STDMETHOD(ReleaseWindowLV) (THIS) PURE;
    STDMETHOD(GetShellFolder)(THIS_ IShellFolder **ppsf) PURE;

    // *** IDefViewFrame2 methods ***
    STDMETHOD(GetWindowLV2) (THIS_ HWND * phwnd, IUnknown * punk) PURE;
    STDMETHOD(AutoAutoArrange)(THIS_ DWORD dwReserved) PURE;
};

#undef  INTERFACE
#define INTERFACE   IWebViewOCWinMan
DECLARE_INTERFACE_(IWebViewOCWinMan, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWebViewOCWinMan methods ***
    STDMETHOD(SwapWindow) (THIS_ HWND hwndLV, IWebViewOCWinMan **pocWinMan) PURE;
};

//===========================================================================
// Shell restrictions. (Parameter for SHRestricted)
typedef enum
{
    // Classic Win95 policy bits.  Do NOT add any more bits in
    // this range.  See the ranges below to add new policies.
    //          |                        |
    //          v                        v
    REST_NONE                       = 0x00000000,
    REST_NORUN                      = 0x00000001,
    REST_NOCLOSE                    = 0x00000002,
    REST_NOSAVESET                  = 0x00000004,
    REST_NOFILEMENU                 = 0x00000008,
    REST_NOSETFOLDERS               = 0x00000010,
    REST_NOSETTASKBAR               = 0x00000020,
    REST_NODESKTOP                  = 0x00000040,
    REST_NOFIND                     = 0x00000080,
    REST_NODRIVES                   = 0x00000100,
    REST_NODRIVEAUTORUN             = 0x00000200,
    REST_NODRIVETYPEAUTORUN         = 0x00000400,
    REST_NONETHOOD                  = 0x00000800,
    REST_STARTBANNER                = 0x00001000,
    REST_RESTRICTRUN                = 0x00002000,
    REST_NOPRINTERTABS              = 0x00004000,
    REST_NOPRINTERDELETE            = 0x00008000,
    REST_NOPRINTERADD               = 0x00010000,
    REST_NOSTARTMENUSUBFOLDERS      = 0x00020000,
    REST_MYDOCSONNET                = 0x00040000,
    REST_NOEXITTODOS                = 0x00080000,
    REST_ENFORCESHELLEXTSECURITY    = 0x00100000,
    REST_LINKRESOLVEIGNORELINKINFO  = 0x00200000,
    REST_NOCOMMONGROUPS             = 0x00400000,
    REST_SEPARATEDESKTOPPROCESS     = 0x00800000,
    REST_NOWEB                      = 0x01000000,
    REST_NOTRAYCONTEXTMENU          = 0x02000000,
    REST_NOVIEWCONTEXTMENU          = 0x04000000,
    REST_NONETCONNECTDISCONNECT     = 0x08000000,
    REST_STARTMENULOGOFF            = 0x10000000,
    REST_NOSETTINGSASSIST           = 0x20000000,

    // Values starting at 4000001 are treated as raw INTs.  New
    // *shell-specific* policies (NOT browser policies) should
    // be added in this range.  Use SHRestricted() with these bits.
    //          |                        |
    //          v                        v

    REST_NOINTERNETICON             = 0x40000001,
    REST_NORECENTDOCSHISTORY        = 0x40000002,
    REST_NORECENTDOCSMENU           = 0x40000003,
    REST_NOACTIVEDESKTOP            = 0x40000004,
    REST_NOACTIVEDESKTOPCHANGES     = 0x40000005,
    REST_NOFAVORITESMENU            = 0x40000006,
    REST_CLEARRECENTDOCSONEXIT      = 0x40000007,
    REST_CLASSICSHELL               = 0x40000008,
    REST_NOCUSTOMIZEWEBVIEW         = 0x40000009,
    REST_NOHTMLWALLPAPER            = 0x40000010,
    REST_NOCHANGINGWALLPAPER        = 0x40000011,
    REST_NODESKCOMP                 = 0x40000012,
    REST_NOADDDESKCOMP              = 0x40000013,
    REST_NODELDESKCOMP              = 0x40000014,
    REST_NOCLOSEDESKCOMP            = 0x40000015,
    REST_NOCLOSE_DRAGDROPBAND       = 0x40000016,   // Disable Close and Drag & Drop on ALL Bands
    REST_NOMOVINGBAND               = 0x40000017,   // Disable Moving ALL Bands
    REST_NOEDITDESKCOMP             = 0x40000018,
    REST_NORESOLVESEARCH            = 0x40000019,
    REST_NORESOLVETRACK             = 0x4000001A,
    REST_FORCECOPYACLWITHFILE       = 0X4000001B,
    REST_NOLOGO3CHANNELNOTIFY       = 0x4000001C,
    REST_NOFORGETSOFTWAREUPDATE     = 0x4000001D,
    REST_NOSETACTIVEDESKTOP         = 0x4000001E,   // No Active desktop on Settings Menu
    REST_NOUPDATEWINDOWS            = 0x4000001F,   // No Windows Update on Settings Menu
    REST_NOCHANGESTARMENU           = 0x40000020,   // No Context menu or Drag and Drop on Start menu
    REST_NOFOLDEROPTIONS            = 0x40000021,   // No Folder Options on Settings Menu
    REST_HASFINDCOMPUTERS           = 0x40000022,   // Show Start/Search/Computers
    REST_INTELLIMENUS               = 0x40000023,
    REST_RUNDLGMEMCHECKBOX          = 0x40000024,
    REST_ARP_ShowPostSetup          = 0x40000025,   // ARP: Show Post-Setup page
    REST_NOCSC                      = 0x40000026,   // Disable the ClientSide caching on SM
    REST_NOCONTROLPANEL             = 0x40000027,   // Remove the Control Panel only from SM|Settings
    REST_ENUMWORKGROUP              = 0x40000028,   // Enumerate workgroup in root of nethood
    REST_ARP_NOARP                  = 0x40000029,   // ARP: Don't Allow ARP to come up at all
    REST_ARP_NOREMOVEPAGE           = 0x4000002A,   // ARP: Don't allow Remove page
    REST_ARP_NOADDPAGE              = 0x4000002B,   // ARP: Don't allow Add page
    REST_ARP_NOWINSETUPPAGE         = 0x4000002C,   // ARP: Don't allow opt components page
    REST_GREYMSIADS                 = 0x4000002D,    // SM: Allow the greying of Darwin Ads in SM
    REST_NOCHANGEMAPPEDDRIVELABEL   = 0x4000002E,   // Don't enable the UI which allows users to rename mapped drive labels
    REST_NOCHANGEMAPPEDDRIVECOMMENT = 0x4000002F,   // Don't enable the UI which allows users to change mapped drive comments
    REST_MaxRecentDocs              = 0x40000030,
    REST_NONETWORKCONNECTIONS       = 0x40000031,   // No Start Menu | Settings |Network Connections
    REST_FORCESTARTMENULOGOFF       = 0x40000032,   // Force logoff on the Start Menu
    REST_NOWEBVIEW                  = 0x40000033,   // Disable Web View
    REST_NOCUSTOMIZETHISFOLDER      = 0x40000034,   // Disable Customize This Folder
    REST_NOENCRYPTION               = 0x40000035,   // Don't allow file encryption
    REST_ALLOWFRENCRYPTION          = 0x40000036,   // Allow encryption in France (Do not publish)
    REST_DONTSHOWSUPERHIDDEN        = 0x40000037,   // don't show super hidden files
    REST_NOSHELLSEARCHBUTTON        = 0x40000038,
    REST_NOHARDWARETAB              = 0x40000039,   // No Hardware tab on Drives or in control panel
    REST_NORUNASINSTALLPROMPT       = 0x4000003A,   // Don't bring up "Run As" prompt for install programs
    REST_PROMPTRUNASINSTALLNETPATH  = 0x4000003B,   // Force the  "Run As" prompt for install programs on unc/network shares
    REST_NOMANAGEMYCOMPUTERVERB     = 0x4000003C,   // No Manage verb on My Computer
    REST_NORECENTDOCSNETHOOD        = 0x4000003D,   // dont add the recent docs shares to nethood
    REST_DISALLOWRUN                = 0x4000003E,   // don't allow certain apps to be run
    REST_NOWELCOMESCREEN            = 0x4000003F,   // don't allow the welcome screen to be displayed.
    REST_RESTRICTCPL                = 0x40000040,   // only allow certain cpls to be run
    REST_DISALLOWCPL                = 0x40000041,   // don't allow certain cpls to be run
    REST_NOSMBALLOONTIP             = 0x40000042,   // No Start Menu Balloon Tip
    REST_NOSMHELP                   = 0x40000043,   // No Help on the Start Menu
    REST_NOWINKEYS                  = 0x40000044,   // No Windows-X Hot keys
    REST_NOENCRYPTONMOVE            = 0x40000045,   // Don't automatically try to encrypt files that are moved to encryped directories
    REST_NOLOCALMACHINERUN          = 0x40000046,   // ignore HKLM\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOCURRENTUSERRUN           = 0x40000047,   // ignore HKCU\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOLOCALMACHINERUNONCE      = 0x40000048,   // ignore HKLM\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_NOCURRENTUSERRUNONCE       = 0x40000049,   // ignore HKCU\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_FORCEACTIVEDESKTOPON       = 0x4000004A,   // Force ActiveDesktop to be turned ON all the time.
    REST_NOCOMPUTERSNEARME          = 0x4000004B,   // removes the "Computers near me" link
    REST_NOVIEWONDRIVE              = 0x4000004C,   // disallows CreateViewObject() on specified drives (CFSFolder only)

// BUGBUG: Space is taken by Millennium changes
    REST_NOSMMYDOCS                 = 0x4000004F,   // Don't show the My Documents item on the Start Menu.
#ifdef WINNT // hydra specific ids
    REST_NODISCONNECT               = 0x41000001,   // No Disconnect option in Start menu
    REST_NOSECURITY                 = 0x41000002,   // No Security option in start menu
    REST_NOFILEASSOCIATE            = 0x41000003,   // Do not allow user to change file association
#endif
} RESTRICTIONS;


// Browser restrictions (parameter for SHRestricted2)
//
// The browser restrictions are divided into two ranges, "explorer restrictions" and
// "infodelivery restrictions".  Explorer restrictions are kept under "Software\\Microsoft\\
// Windows\\CurrentVersion\\Policies\\Explorer," while infodelivery restrictions are kept
// under "Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions."
//
// **NOTE**: SHRestricted2 assumes each range is continuous.
typedef enum {
    // explorer restrictions
    REST_BROWSER_NONE               = 0x00000000,   // REST_EXPLORER_FIRST
    REST_NOTOOLBARCUSTOMIZE         = 0x00000001,
    REST_NOBANDCUSTOMIZE            = 0x00000002,
    REST_SMALLICONS                 = 0x00000003,
    REST_LOCKICONSIZE               = 0x00000004,
    REST_SPECIFYDEFAULTBUTTONS      = 0x00000005,
    REST_BTN_BACK                   = 0x00000006,
    REST_BTN_FORWARD                = 0x00000007,
    REST_BTN_STOPDOWNLOAD           = 0x00000008,
    REST_BTN_REFRESH                = 0x00000009,
    REST_BTN_HOME                   = 0x0000000A,
    REST_BTN_SEARCH                 = 0x0000000B,
    REST_BTN_HISTORY                = 0x0000000C,
    REST_BTN_FAVORITES              = 0x0000000D,
    REST_BTN_ALLFOLDERS             = 0x0000000E,
    REST_BTN_THEATER                = 0x0000000F,
    REST_BTN_TOOLS                  = 0x00000010,
    REST_BTN_MAIL                   = 0x00000011,
    REST_BTN_FONTS                  = 0x00000012,
    REST_BTN_PRINT                  = 0x00000013,
    REST_BTN_EDIT                   = 0x00000014,
    REST_BTN_DISCUSSIONS            = 0x00000015,
    REST_BTN_CUT                    = 0x00000016,
    REST_BTN_COPY                   = 0x00000017,
    REST_BTN_PASTE                  = 0x00000018,
    REST_BTN_ENCODING               = 0x00000019,
    REST_NoUserAssist               = 0x0000001A,
    REST_NoWindowsUpdate            = 0x0000001B,
    REST_NoExpandedNewMenu          = 0x0000001C,
    REST_NOFILEURL                  = 0x0000001D,   // REST_EXPLORER_LAST

    // infodelivery restrictions
    REST_NoChannelUI                = 0x50000001,   // REST_INFO_FIRST
    REST_NoAddingChannels           = 0x50000002,
    REST_NoEditingChannels          = 0x50000003,
    REST_NoRemovingChannels         = 0x50000004,
    REST_NoAddingSubscriptions      = 0x50000005,
    REST_NoEditingSubscriptions     = 0x50000006,
    REST_NoRemovingSubscriptions    = 0x50000007,
    REST_NoChannelLogging           = 0x50000008,
    REST_NoManualUpdates            = 0x50000009,
    REST_NoScheduledUpdates         = 0x5000000A,
    REST_NoUnattendedDialing        = 0x5000000B,
    REST_NoChannelContent           = 0x5000000C,
    REST_NoSubscriptionContent      = 0x5000000D,
    REST_NoEditingScheduleGroups    = 0x5000000E,
    REST_MaxChannelSize             = 0x5000000F,
    REST_MaxSubscriptionSize        = 0x50000010,
    REST_MaxChannelCount            = 0x50000011,
    REST_MaxSubscriptionCount       = 0x50000012,
    REST_MinUpdateInterval          = 0x50000013,
    REST_UpdateExcludeBegin         = 0x50000014,
    REST_UpdateExcludeEnd           = 0x50000015,
    REST_UpdateInNewProcess         = 0x50000016,
    REST_MaxWebcrawlLevels          = 0x50000017,
    REST_MaxChannelLevels           = 0x50000018,
    REST_NoSubscriptionPasswords    = 0x50000019,
    REST_NoBrowserSaveWebComplete   = 0x5000001A,
    REST_NoSearchCustomization      = 0x5000001B,
    REST_NoSplash                   = 0x5000001C,  // REST_INFO_LAST

    // restrictions ported from SP2
    REST_NoFileOpen                 = 0x60000001,  // REST_BROWSER_FIRST
    REST_NoFileNew                  = 0x60000002,
    REST_NoBrowserSaveAs            = 0x60000003,
    REST_NoBrowserOptions           = 0x60000004,
    REST_NoFavorites                = 0x60000005,
    REST_NoSelectDownloadDir        = 0x60000006,
    REST_NoBrowserContextMenu       = 0x60000007,
    REST_NoBrowserClose             = 0x60000008,
    REST_NoOpeninNewWnd             = 0x60000009,
    REST_NoTheaterMode              = 0x6000000A,
    REST_NoFindFiles                = 0x6000000B,
    REST_NoViewSource               = 0x6000000C,
    REST_GoMenu                     = 0x6000000D,
    REST_NoToolbarOptions           = 0x6000000E,

    REST_NoHelpItem_TipOfTheDay     = 0x6000000F,
    REST_NoHelpItem_NetscapeHelp    = 0x60000010,
    REST_NoHelpItem_Tutorial        = 0x60000011,
    REST_NoHelpItem_SendFeedback    = 0x60000012,
    REST_AlwaysPromptWhenDownload   = 0x60000013,

    REST_NoNavButtons               = 0x60000014,
    REST_NoHelpMenu                 = 0x60000015,
    REST_NoBrowserBars              = 0x60000016,
    REST_NoToolBar                  = 0x60000017,
    REST_NoAddressBar               = 0x60000018,
    REST_NoLinksBar                 = 0x60000019,  // REST_BROWSER_LAST

} BROWSER_RESTRICTIONS;

#define REST_EXPLORER_FIRST     REST_BROWSER_NONE
#define REST_EXPLORER_LAST      REST_NOFILEURL

#define REST_INFO_FIRST         REST_NoChannelUI
#define REST_INFO_LAST          REST_NoSplash

#define REST_BROWSER_FIRST      REST_NoFileOpen
#define REST_BROWSER_LAST       REST_NoLinksBar

// codes for REST_BTN policies
#define RESTOPT_BTN_STATE_DEFAULT       0   // must be zero, else break browseui\itbar.cpp assumption
#define RESTOPT_BTN_STATE_VISIBLE       1
#define RESTOPT_BTN_STATE_HIDDEN        2

// REST_INTELLIMENUS
#define RESTOPT_INTELLIMENUS_USER       0
#define RESTOPT_INTELLIMENUS_DISABLED   1       // Match Restriction assumption: 1 == Off
#define RESTOPT_INTELLIMENUS_ENABLED    2


// FTP Exports
STDAPI IsIEDefautlFTPClient(void);
STDAPI MakeIEDefautlFTPClient(void);
STDAPI RestoreFTPClient(void);


SHSTDAPI_(void) SHSettingsChanged(WPARAM wParam, LPARAM lParam);
SHSTDAPI_(BOOL) SHIsBadInterfacePtr(LPCVOID pv, UINT cbVtbl);
SHSTDAPI_(IStream *) OpenRegStream(HKEY hkey, LPCTSTR pszSubkey, LPCTSTR pszValue, DWORD grfMode);
SHSTDAPI_(void) SHHandleDiskFull(HWND hwnd, int idDrive);

SHSTDAPI_(BOOL) SHFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);
SHSTDAPI_(BOOL) SHFindComputer(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);

SHSTDAPI_(void) PathGetShortPath(LPTSTR pszLongPath);
SHSTDAPI_(BOOL) PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName, LPCTSTR pszPath, LPCTSTR pszShort, LPCTSTR pszFileSpec);

SHSTDAPI_(BOOL) Win32CreateDirectory(LPCTSTR pszPath, SECURITY_ATTRIBUTES *psa);
SHSTDAPI_(BOOL) Win32RemoveDirectory(LPCTSTR pszPath);
SHSTDAPI_(BOOL) Win32DeleteFile(LPCTSTR pszPath);

SHSTDAPI_(void) SHUpdateRecycleBinIcon();

//
// Path processing function
//

#define PPCF_ADDQUOTES               0x00000001        // return a quoted name if required
#define PPCF_ADDARGUMENTS            0x00000003        // appends arguments (and wraps in quotes if required)
#define PPCF_NODIRECTORIES           0x00000010        // don't match to directories
#define PPCF_NORELATIVEOBJECTQUALIFY 0x00000020        // don't return fully qualified relative objects
#define PPCF_FORCEQUALIFY            0x00000040        // qualify even non-relative names
#define PPCF_LONGESTPOSSIBLE         0x00000080        // always find the longest possible name

SHSTDAPI_(LONG) PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iMax, DWORD dwFlags);
SHSTDAPI_(LPITEMIDLIST) SHLogILFromFSIL(LPCITEMIDLIST pidlFS);
SHSTDAPI_(BOOL) StrRetToStrN(LPTSTR szOut, UINT uszOut, STRRET *pStrRet, LPCITEMIDLIST pidl);
SHSTDAPI_(DWORD) SHWaitForFileToOpen(LPCITEMIDLIST pidl, UINT uOptions, DWORD dwtimeout);
SHSTDAPI_(void) SetAppStartingCursor(HWND hwnd, BOOL fSet);
SHSTDAPI_(DWORD) SHRestricted(RESTRICTIONS rest);
SHSTDAPI_(void *) SHGetHandlerEntry(LPCTSTR szHandler, LPCSTR szProcName, HINSTANCE *lpModule);


SHSTDAPI_(BOOL) SignalFileOpen(LPCITEMIDLIST pidl);
SHSTDAPI_(LPITEMIDLIST) SHSimpleIDListFromPath(LPCTSTR pszPath);

SHSTDAPI SHCreatePropertyBag(REFIID riid, void **ppv);

SHSTDAPI_(DWORD) SHNetConnectionDialog(HWND hwnd, LPTSTR pszRemoteName, DWORD dwType);
SHSTDAPI SHLoadOLE(LPARAM lParam);
SHSTDAPI_(void) Desktop_UpdateBriefcaseOnEvent(HWND hwnd, UINT uEvent);


SHSTDAPI SHStartNetConnectionDialogA(HWND hwnd, LPCSTR pszRemoteName, DWORD dwType);
SHSTDAPI SHStartNetConnectionDialogW(HWND hwnd, LPCWSTR pszRemoteName, DWORD dwType);
#ifdef UNICODE
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogW
#else
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogA
#endif // !UNICODE
SHSTDAPI SHDefExtractIconA(LPCSTR pszIconFile, int iIndex, UINT uFlags,
                           HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
SHSTDAPI SHDefExtractIconW(LPCWSTR pszIconFile, int iIndex, UINT uFlags,
                           HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
#ifdef UNICODE
#define SHDefExtractIcon  SHDefExtractIconW
#else
#define SHDefExtractIcon  SHDefExtractIconA
#endif // !UNICODE
SHSTDAPI_(int) SHLookupIconIndexA(LPCSTR pszFile, int iIconIndex, UINT uFlags);
SHSTDAPI_(int) SHLookupIconIndexW(LPCWSTR pszFile, int iIconIndex, UINT uFlags);
#ifdef UNICODE
#define SHLookupIconIndex  SHLookupIconIndexW
#else
#define SHLookupIconIndex  SHLookupIconIndexA
#endif // !UNICODE
SHSTDAPI_(UINT) SHExtractIconsA(LPCSTR pszFileName, int nIconIndex, int cxIcon, int cyIcon,
                                HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);
SHSTDAPI_(UINT) SHExtractIconsW(LPCWSTR pszFileName, int nIconIndex, int cxIcon, int cyIcon,
                                HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);
#ifdef UNICODE
#define SHExtractIcons  SHExtractIconsW
#else
#define SHExtractIcons  SHExtractIconsA
#endif // !UNICODE
SHSTDAPI SHGetAssociations(LPCITEMIDLIST pidl, void **ppvQueryAssociations);

#define SHLookupIconIndexAORD   7
#define SHLookupIconIndexWORD   8
#ifdef UNICODE
#define SHLookupIconIndexORD    SHLookupIconIndexWORD
#else
#define SHDefExtractIcon    SHDefExtractIconA
#endif


// BUGBUG (scotth): temporary.  move to shdocvw.
// OpenAsInfo flags
#define OAIF_ALLOW_REGISTRATION     0x00000001      // enable the "always use this file" checkbox (NOTE if you dont pass this, it will be disabled)
#define OAIF_REGISTER_EXT           0x00000002      // do the registration after the user hits "ok"
#define OAIF_EXEC                   0x00000004      // execute file after registering
#define OAIF_FORCE_REGISTRATION     0x00000008      // force the "always use this file" checkbox to be checked (normally, you wont use the OAIF_ALLOW_REGISTRATION wen you pass this)
#define OAIF_ALL                    (OAIF_ALLOW_REGISTRATION | OAIF_REGISTER_EXT | OAIF_EXEC | OAIF_FORCE_REGISTRATION)  //

typedef struct _openasinfo
{
    LPCTSTR pcszFile;           // [in] file name
    LPCTSTR pcszClass;          // [in] file class description.  NULL means
                                //      use pcszFile's extension
    DWORD dwInFlags;            // [in] input flags from OAIF_*

    TCHAR szApp[MAX_PATH];      // [out] application selected
} OPENASINFO, * POPENASINFO;

SHSTDAPI OpenAsDialog(HWND hwnd, POPENASINFO poainfo);

//
// Interface pointer validation
//
#define IsBadInterfacePtr(pitf, ITF)  SHIsBadInterfacePtr(pitf, sizeof(ITF##Vtbl))

//===========================================================================
// Another block of private API
//===========================================================================

// indexes into the shell image lists (Shell_GetImageList) for default images
// If you add to this list, you also need to update II_LASTSYSICON!

#define II_DOCNOASSOC         0  // document (blank page) (not associated)
#define II_DOCUMENT           1  // document (with stuff on the page)
#define II_APPLICATION        2  // application (exe, com, bat)
#define II_FOLDER             3  // folder (plain)
#define II_FOLDEROPEN         4  // folder (open)
#define II_DRIVE525           5
#define II_DRIVE35            6
#define II_DRIVEREMOVE        7
#define II_DRIVEFIXED         8
#define II_DRIVENET           9
#define II_DRIVENETDISABLED  10
#define II_DRIVECD           11
#define II_DRIVERAM          12
#define II_WORLD             13
#define II_NETWORK           14
#define II_SERVER            15
#define II_PRINTER           16
#define II_MYNETWORK         17
#define II_GROUP             18
// Startmenu images.
#define II_STPROGS           19
#define II_STDOCS            20
#define II_STSETNGS          21
#define II_STFIND            22
#define II_STHELP            23
#define II_STRUN             24
#define II_STSUSPEND         25
#define II_STEJECT           26
#define II_STSHUTD           27

#define II_SHARE             28
#define II_LINK              29
#define II_SLOWFILE          30
#define II_RECYCLER          31
#define II_RECYCLERFULL      32
#define II_RNA               33
#define II_DESKTOP           34

// More startmenu image.
#define II_STCPANEL          35
#define II_STSPROGS          36
#define II_STPRNTRS          37
#define II_STFONTS           38
#define II_STTASKBR          39

#define II_CDAUDIO           40
#define II_TREE              41
#define II_STCPROGS          42
#define II_STFAVORITES       43
#define II_STLOGOFF          44
#define II_STFLDRPROP        45
#define II_WINUPDATE         46

#define II_MU_STSECURITY     47
#define II_MU_STDISCONN      48

#ifdef WINNT // hydra specific id
#define II_LASTSYSICON       II_MU_STDISCONN
#else
// Last system image list icon index - used by icon cache manager
#define II_LASTSYSICON       II_WINUPDATE
#endif

// Overlay indexes
#define II_OVERLAYFIRST      II_SHARE
#define II_OVERLAYLAST       II_SLOWFILE

#define II_NDSCONTAINER      72
#define II_SERVERSHARE       73

SHSTDAPI_(BOOL) FileIconInit( BOOL fRestoreCache );

SHSTDAPI_(BOOL) Shell_GetImageLists(HIMAGELIST *phiml, HIMAGELIST *phimlSmall);
SHSTDAPI_(void) Shell_SysColorChange(void);
SHSTDAPI_(int)  Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);


// A usefull function in Defview for mapping idlist into index into system
// image list.  Optionally it can also look up the index of the selected
// icon.
SHSTDAPI_(int) SHMapPIDLToSystemImageListIndex(IShellFolder *pshf, LPCITEMIDLIST pidl, int *piIndexSel);
//
// OLE string
//
SHSTDAPI_(int) OleStrToStrN(LPTSTR, int, LPCOLESTR, int);
SHSTDAPI_(int) StrToOleStrN(LPOLESTR, int, LPCTSTR, int);
SHSTDAPI_(int) OleStrToStr(LPTSTR, LPCOLESTR);
SHSTDAPI_(int) StrToOleStr(LPOLESTR, LPCTSTR);


// Tray CopyData Messages
#define TCDM_APPBAR     0x00000000
#define TCDM_NOTIFY     0x00000001
#define TCDM_LOADINPROC 0x00000002

//
//  new navigation stack interfaces

#undef  INTERFACE
#define INTERFACE   ITravelEntry

DECLARE_INTERFACE_(ITravelEntry, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ITravelEntry specific methods
    STDMETHOD(Invoke)(THIS_ IUnknown *punk) PURE;
    STDMETHOD(Update)(THIS_ IUnknown *punk, BOOL fIsLocalAnchor) PURE;
    STDMETHOD(GetPidl)(THIS_ LPITEMIDLIST *ppidl) PURE;
};

#undef  INTERFACE
#define INTERFACE   ITravelLog

#define TLOG_BACK   -1
#define TLOG_FORE   1

#define TLMENUF_INCLUDECURRENT                  0x00000001
#define TLMENUF_CHECKCURRENT                    (TLMENUF_INCLUDECURRENT | 0x00000002)
#define TLMENUF_BACK                            0x00000010  // Default
#define TLMENUF_FORE                            0x00000020
#define TLMENUF_BACKANDFORTH                    (TLMENUF_BACK | TLMENUF_FORE | TLMENUF_INCLUDECURRENT)

DECLARE_INTERFACE_(ITravelLog, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ITravelLog specific methods
    STDMETHOD(AddEntry)(THIS_ IUnknown *punk, BOOL fIsLocalAnchor) PURE;
    STDMETHOD(UpdateEntry)(THIS_ IUnknown *punk, BOOL fIsLocalAnchor) PURE;
    STDMETHOD(UpdateExternal)(THIS_ IUnknown *punk, IUnknown *punkHLBrowseContext) PURE;
    STDMETHOD(Travel)(THIS_ IUnknown *punk, int iOffset) PURE;
    STDMETHOD(GetTravelEntry)(THIS_ IUnknown *punk, int iOffset, ITravelEntry **ppte) PURE;
    STDMETHOD(FindTravelEntry)(THIS_ IUnknown *punk, LPCITEMIDLIST pidl, ITravelEntry **ppte) PURE;
    STDMETHOD(GetToolTipText)(THIS_ IUnknown *punk, int iOffset, int idsTemplate, LPWSTR pwzText, DWORD cchText) PURE;
    STDMETHOD(InsertMenuEntries)(THIS_ IUnknown *punk, HMENU hmenu, int nPos, int idFirst, int idLast, DWORD dwFlags) PURE;
    STDMETHOD(Clone)(THIS_ ITravelLog **pptl) PURE;
    STDMETHOD_(DWORD, CountEntries)(THIS_ IUnknown *punk) PURE;
    STDMETHOD(Revert)(void) PURE;
};


//
// Private QueryContextMenuFlag passed from Bands
//
#define CMF_BANDCMD      0x00020000     // Install Band Context menu commands

//
// Functions to help the cabinets sync to each other
//  uOptions parameter to SHWaitForFileOpen
//
#define WFFO_WAITTIME 10000L

#define WFFO_ADD        0x0001
#define WFFO_REMOVE     0x0002
#define WFFO_WAIT       0x0004
#define WFFO_SIGNAL     0x0008



//
// NOTES: IShellService is used when we share a service component
//  (which implements a certain interface) among multiple clients
//  (such as IE 3.0 and Explorer). The client always CoCreateInstance
//  it and call SetOwner(this). When the client is going away
//  (typically when the window is closed), it calls SetOwner(NULL)
//  to let the service object releases the reference to the owner
//  object.
//
#undef  INTERFACE
#define INTERFACE   IShellService

DECLARE_INTERFACE_(IShellService, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellService specific methods ***
    STDMETHOD(SetOwner)(THIS_ struct IUnknown* punkOwner) PURE;
};


//
// NOTES: IHistSFPrivate is used when manipulating a history IShellFolder object
//      It includes methods for pointing the shell folder at the correct virtual
//      directory.  QIing for IHistSFPrivate also guarantees the pidl format can
//      safely be delved into to access the INTERNET_CACHE_ENTRY_INFO structure
//
#undef  INTERFACE
#define INTERFACE   IHistSFPrivate

DECLARE_INTERFACE_(IHistSFPrivate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IHistPrivate specific methods ***
    STDMETHOD(SetCachePrefix)(THIS_ LPCWSTR pszCachePrefix) PURE;
    STDMETHOD(SetDomain)(THIS_ LPCWSTR pszDomain) PURE;
    STDMETHOD(WriteHistory)(THIS_ LPCWSTR pszPrefixedUrl, FILETIME ftExpires, FILETIME ftModified, LPITEMIDLIST * ppidlSelect) PURE;
    STDMETHOD(ClearHistory) (THIS) PURE;
};

//
// NOTES:  IShellFolderViewType lets a shell folder support different "views" on
//      its contents (meaning different hierarchical layouts of its data) with
//      the default "view" being the one the shell folder displays normally.
//      This enumerator returns pidls that are special hidden folders at the
//      top level of the shell folder (which are not otherwise enumerated).
#undef  INTERFACE
#define INTERFACE   IShellFolderViewType
DECLARE_INTERFACE_(IShellFolderViewType, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderViewType Methods ***

    // NOTE: "Views" are seen by the user as hidden folders off the
    //       root (represented by pidls).  Whenever appropriate, the
    //       default view (coming off the root folder) is represented
    //       as the NULL *or* empty pidl.

    // EnumViews:
    //   Return an enumerator which will give out one pidl for every extended view.
    STDMETHOD(EnumViews)(THIS_ ULONG grfFlags, IEnumIDList **ppenum) PURE;

    // GetDefaultViewName:
    //   Return the name of the default view.  The names of the other views
    //   can be retrieved by calling GetDisplayNameOf.
    STDMETHOD(GetDefaultViewName)(THIS_ DWORD  uFlags, LPWSTR *ppwszName)      PURE;
    STDMETHOD(GetViewTypeProperties)(THIS_ LPCITEMIDLIST pidl, DWORD *pdwFlags)  PURE;

    // TranslateViewPidl:
    //   Attempt to take a pidl represented in one heirarchical representation of
    //   the shell folder, and find it in a different representation.
    //   pidl should be relative to the root folder.
    //   Remember to ILFree ppidlOut
    STDMETHOD(TranslateViewPidl)(THIS_ LPCITEMIDLIST pidl, LPCITEMIDLIST pidlView, LPITEMIDLIST *ppidlOut) PURE;
};

#define SFVTFLAG_NOTIFY_CREATE  0x00000001
#define SFVTFLAG_NOTIFY_RESORT  0x00000002

//
// NOTES: IShellFolderSearchableCallback allows the searcher to provide
//          callback routines that moniter the search process
//
#undef  INTERFACE
#define INTERFACE IShellFolderSearchableCallback
DECLARE_INTERFACE_(IShellFolderSearchableCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderSearchableCallback Methods ***

    // NOTE: Caller may pass NULL for pVar or pdwFlags as a legal value
    STDMETHOD(RunBegin)(DWORD dwReserved) PURE;
    STDMETHOD(RunEnd)(DWORD dwReserved) PURE;
};

//
// NOTES: IShellFolderSearchable allows a shell extension to provide a searchable
//        namespace.
#undef  INTERFACE
#define INTERFACE IShellFolderSearchable
DECLARE_INTERFACE_(IShellFolderSearchable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderSearchable methods ***

    // FindString -
    //  The returned shell folder's enumerator will have any
    //   search hits for the given search string.
    //  As no flags are currently defined, we suggest you pass
    //    NULL as lpdword
    //  punkOnAsyncSearch will be QI'd for IShellFolderSearchableCallback
    STDMETHOD(FindString)(THIS_ LPCWSTR pwszTarget, DWORD *pdwFlags,
                          IUnknown *punkOnAsyncSearch, LPITEMIDLIST *ppidlOut)   PURE;
    // CancelAsyncSearch -
    //   Begins the process of cancelling  any pending
    //    asynchronous search from this pidl.
    //    When the search is actually cancelled, RunEnd will be called
    //   Returns: S_OK => cancelling, S_FALSE => not running
    STDMETHOD(CancelAsyncSearch) (THIS_ LPCITEMIDLIST pidlSearch, DWORD *pdwFlags) PURE;

    // InvalidateSearch -
    //   Makes this pidl no longer a valid portion of the shell folder
    //    also does some cleanup of any databases used in the search and
    //    will cause the eventual release of the IRunHook callback
    //   May cause async search to be cancelled
    STDMETHOD(InvalidateSearch)  (THIS_ LPCITEMIDLIST pidlSearch, DWORD *pdwFlags) PURE;
};

//
// NOTES: IBandSiteHelper is used to let explorer's BandSite implementation,
//  which aggregates shdocvw's BandSite, provide callback hooks for shdocvw
//  to call.
//
#undef  INTERFACE
#define INTERFACE   IBandSiteHelper

DECLARE_INTERFACE_(IBandSiteHelper, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBandSiteHelper specific methods ***
    STDMETHOD(LoadFromStreamBS)(THIS_ struct IStream* pstm, REFIID riid, void **ppv) PURE;
    STDMETHOD(SaveToStreamBS)(THIS_ struct IUnknown* punk, struct IStream* pstm) PURE;
};

// This private interface is added such that some of the support features that is in
// SHDocvw's Internet explorer frame automation code, that is not part of publicly
// defined interfaces can be used in the Explorer code...
//
// Note: FindCIE4ConnectionPoint was a hack for IE4.  New code should use
//       shlwapi helper functions like IConnectionPoint_Invoke instead.
//

#ifdef __cplusplus
class CIE4ConnectionPoint;
#else
typedef struct CIE4ConnectionPoint CIE4ConnectionPoint;
#endif

#undef  INTERFACE
#define INTERFACE   IExpDispSupport

DECLARE_INTERFACE_(IExpDispSupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExpDispSupport specific methods ***
    STDMETHOD(FindCIE4ConnectionPoint)(THIS_ REFIID riid, CIE4ConnectionPoint **ppccp) PURE;
    STDMETHOD(OnTranslateAccelerator)(MSG  *pMsg, DWORD grfModifiers) PURE;
    STDMETHOD(OnInvoke)(THIS_ DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                        VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) PURE;
};

//
// This interface is related to the above. It contains functions
// that would only be implemented on the WebBrowserOC version if IExpDispSupport.
//
#undef  INTERFACE
#define INTERFACE   IExpDispSupportOC
DECLARE_INTERFACE_(IExpDispSupportOC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExpDispSupportOC specific methods ***
    STDMETHOD(OnOnControlInfoChanged)() PURE;
    STDMETHOD(GetDoVerbMSG)(MSG *pMsg) PURE;
};



//===========================================================================
// IConnectionPointCB interface
#undef  INTERFACE
#define INTERFACE  IConnectionPointCB
DECLARE_INTERFACE_(IConnectionPointCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IConnectionPointCB Methods ***
    STDMETHOD(OnAdvise) (REFIID iid, DWORD cSinks, ULONG_PTR dwCookie) PURE;
    STDMETHOD(OnUnadvise) (REFIID iid, DWORD cSinks, ULONG_PTR dwCookie) PURE;

};

//===========================================================================
// IDelegateDropTargetCB interface
//
// This interface is used by CDelegateDropTarget implementation in shdocvw
// to generate an IDropTarget implementation that delegates to different
// IDropTarget implementations depending on the point currently over. The
// implementor of IDelegateDropTargetCB can handle feedback, scrolling,
// hit testing, and returning interfaces for ids returned from hit testing.
//
// GetWindows returns the hwnd to lock and the hwnd to scroll (not necesarily
//            the same window, as you often want to lock the parent of the window
//            you want to scroll)
//
// HitTest    should return an id of the object over as well as
//            uptate UI (highlights, etc). if ppt is NULL
//            that means remove any UI as the drag is terminating.
//            this should be able to handle hittesting on points not
//            even inside hwndScroll.
//
// GetObject  returns an interface for an id returned from HitTest
//
// OnDrop     gives the CB a chance to take action on the drop.
//            returning S_FALSE from this function prevents
//            CDelegateDropTarget from calling pdt->Drop(...).
//
#undef  INTERFACE
#define INTERFACE  IDelegateDropTargetCB
DECLARE_INTERFACE_(IDelegateDropTargetCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDelegateDropTargetCB Methods ***
    STDMETHOD(GetWindows) (THIS_ HWND * phwndLock, HWND * phwndScroll) PURE;
    STDMETHOD(HitTest) (THIS_ LPPOINT ppt, DWORD * pdwId) PURE;
    STDMETHOD(GetObject) (THIS_ DWORD dwId, REFIID riid, void **ppv) PURE;
    STDMETHOD(OnDrop) (THIS_ IDropTarget *pdt, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) PURE;

};


#ifdef __COMMCTRL_DA_DEFINED__ // we need HDPAs for this interface
//
// IOrderList - for ordering info in favorites/channels
//
// Typical usage is: GetOrderList, AllocOrderItem, insert into correct
// position, SetOrderList, and then FreeOrderList.
//
typedef struct
{
    LPITEMIDLIST    pidl;       // IDlist for this item
    int             nOrder;     // Ordinal indicating user preference
    DWORD           lParam;     // store custom order info.
} ORDERITEM, * PORDERITEM;

// Values for SortOrderList
#define OI_SORTBYNAME       0
#define OI_SORTBYORDINAL    1
#define OI_MERGEBYNAME      2

#undef  INTERFACE
#define INTERFACE  IOrderList
DECLARE_INTERFACE_(IOrderList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOrderList Methods ***
    STDMETHOD(GetOrderList)(THIS_ HDPA * phdpa) PURE;
    STDMETHOD(SetOrderList)(THIS_ HDPA hdpa, IShellFolder *psf) PURE;
    STDMETHOD(FreeOrderList)(THIS_ HDPA hdpa) PURE;
    STDMETHOD(SortOrderList)(THIS_ HDPA hdpa, DWORD dw) PURE;
    STDMETHOD(AllocOrderItem)(THIS_ PORDERITEM * ppoi, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(FreeOrderItem)(THIS_ PORDERITEM poi) PURE;
};

#undef  INTERFACE
#define INTERFACE  IOrderList2
DECLARE_INTERFACE_(IOrderList2, IOrderList)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOrderList Methods ***
    STDMETHOD(GetOrderList)(THIS_ HDPA * phdpa) PURE;           // BUGBUG (lamadio): This assumes Favorites Menu
    STDMETHOD(SetOrderList)(THIS_ HDPA hdpa, IShellFolder *psf) PURE; // BUGBUG (lamadio): This assumes Favorites Menu
    STDMETHOD(FreeOrderList)(THIS_ HDPA hdpa) PURE;
    STDMETHOD(SortOrderList)(THIS_ HDPA hdpa, DWORD dw) PURE;
    STDMETHOD(AllocOrderItem)(THIS_ PORDERITEM * ppoi, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(FreeOrderItem)(THIS_ PORDERITEM poi) PURE;

    // *** IOrderList2
    STDMETHOD(LoadFromStream)(THIS_ IStream* pstm, HDPA* phdpa, IShellFolder* psf) PURE;
    STDMETHOD(SaveToStream)(THIS_ IStream* pstm, HDPA hdpa) PURE;
};

#endif


//===========================================================================
// IShellHTMLWindowSupport private COmWindow interface. This should never be exposed.
#undef  INTERFACE
#define INTERFACE  IShellHTMLWindowSupport
DECLARE_INTERFACE_(IShellHTMLWindowSupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(ViewReleased)() PURE;
    STDMETHOD(ViewActivated)() PURE;
    STDMETHOD(ReadyStateChangedTo)( long, IShellView* ) PURE;
    STDMETHOD(CanNavigate)() PURE;

};



//===========================================================================
// IBandProxy private COmWindow interface. This should never be exposed.
#undef INTERFACE
#define INTERFACE IBandProxy
DECLARE_INTERFACE_(IBandProxy, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBandProxy Methods ***
    STDMETHOD(SetSite) (THIS_ IUnknown* punkSite) PURE;
    STDMETHOD(CreateNewWindow) (THIS_ IUnknown** ppunk) PURE;
    STDMETHOD(GetBrowserWindow) (THIS_ IUnknown** ppunk) PURE;
    STDMETHOD(IsConnected) (THIS) PURE;
    STDMETHOD(NavigateToPIDL) (THIS_ LPCITEMIDLIST pidl) PURE;
    STDMETHOD(NavigateToURL) (THIS_ LPCWSTR wzUrl, VARIANT * Flags) PURE;
};



//===========================================================================
//
// Make it sure that we include ole2x.h and shlobj.h
//
#if defined(__IOleInPlaceSite_FWD_DEFINED__) && defined(FCIDM_SHVIEWFIRST)

#ifdef HLINK_H

#ifndef RC_INVOKED
#include <pshpack8.h>
#endif /* !RC_INVOKED */

typedef struct {
    HWND _hwnd;
    ITravelLog  *_ptl;
    IHlinkFrame *_phlf;
    IWebBrowser2    *_pautoWB2; // use this to reference _pauto's IWebBrowser2 functions
    IExpDispSupport *_pautoEDS; // use this to reference _pauto's IExpDispSupport functions
    IShellService   *_pautoSS;  // use this to reference _pauto's IShellService functions
    int _eSecureLockIcon;
    DWORD _fCreatingViewWindow :1;
    UINT _uActivateState;   // this is the state we should use when we go active..
                            // this is here so that derived classes can set us for UI or non-UI active

    // The following pidl is used in CBaseBrowser2::GetViewStateStream because
    // at that time, neither _pidlCur nor _pidlPending are initialized.
    LPCITEMIDLIST  _pidlNewShellView;

    IOleCommandTarget* _pctView;

    LPITEMIDLIST _pidlCur;
    IShellView *_psv;
    IShellFolder *_psf; // IShellFolder for _psv (used in CVOCBrowser)
    HWND        _hwndView;
    LPWSTR      _pszTitleCur;

    LPITEMIDLIST _pidlPending;
    IShellView *_psvPending;
    IShellFolder *_psfPending;
    HWND        _hwndViewPending;
    LPWSTR      _pszTitlePending;

    BOOL _fIsViewMSHTML;

} BASEBROWSERDATA, *LPBASEBROWSERDATA;
typedef const BASEBROWSERDATA *LPCBASEBROWSERDATA;

#ifndef RC_INVOKED
#include <poppack.h>
#endif /* !RC_INVOKED */

#else
// so (unref'ed) ifaces will compile (?)
typedef LPVOID BASEBROWSERDATA;
typedef LPCVOID *LPBASEBROWSERDATA;     // BUGBUG LPVOID?
typedef LPCVOID *LPCBASEBROWSERDATA;

#endif // hlink_h

typedef struct _travellog * PTRAVELLOG;

typedef enum
{
    BNS_NORMAL = 0,     // Normal state that we are in
    BNS_BEGIN_NAVIGATE, // A Begin navigate event has happened.
    BNS_NAVIGATE       // A Navigate event has happened...
} BNSTATE;             // The navigate state...


#undef  INTERFACE
#define INTERFACE   IBrowserService

DECLARE_INTERFACE_(IBrowserService, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBrowserService specific methods ***
    STDMETHOD(GetParentSite)(THIS_ struct IOleInPlaceSite** ppipsite) PURE;
    STDMETHOD(SetTitle)(THIS_ IShellView* psv, LPCWSTR pszName) PURE;
    STDMETHOD(GetTitle)(THIS_ IShellView* psv, LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(GetOleObject)(THIS_ struct IOleObject** ppobjv) PURE;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // BUGBUG:: Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    STDMETHOD(GetTravelLog)(THIS_ ITravelLog** pptl) PURE;

    STDMETHOD(ShowControlWindow)(THIS_ UINT id, BOOL fShow) PURE;
    STDMETHOD(IsControlWindowShown)(THIS_ UINT id, BOOL *pfShown) PURE;
    STDMETHOD(IEGetDisplayName)(THIS_ LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) PURE;
    STDMETHOD(IEParseDisplayName)(THIS_ UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) PURE;
    STDMETHOD(DisplayParseError)(THIS_ HRESULT hres, LPCWSTR pwszPath) PURE;
    STDMETHOD(NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF) PURE;

    STDMETHOD (SetNavigateState)(THIS_ BNSTATE bnstate) PURE;
    STDMETHOD (GetNavigateState) (THIS_ BNSTATE *pbnstate) PURE;

    STDMETHOD (NotifyRedirect) (THIS_ struct IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) PURE;
    STDMETHOD (UpdateWindowList) (THIS) PURE;

    STDMETHOD (UpdateBackForwardState) (THIS) PURE;

    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags, DWORD dwFlagMask) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;

    // Tells if it can navigate now or not.
    STDMETHOD (CanNavigateNow) (THIS) PURE;

    STDMETHOD (GetPidl) (THIS_ LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (SetReferrer) (THIS_ LPITEMIDLIST pidl) PURE;
    STDMETHOD_(DWORD, GetBrowserIndex)(THIS) PURE;
    STDMETHOD (GetBrowserByIndex)(THIS_ DWORD dwID, IUnknown **ppunk) PURE;
    STDMETHOD (GetHistoryObject)(THIS_ IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) PURE;
    STDMETHOD (SetHistoryObject)(THIS_ IOleObject *pole, BOOL fIsLocalAnchor) PURE;

    STDMETHOD (CacheOLEServer)(THIS_ IOleObject *pole) PURE;

    STDMETHOD (GetSetCodePage)(THIS_ VARIANT* pvarIn, VARIANT* pvarOut) PURE;
    STDMETHOD (OnHttpEquiv)(THIS_ IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) PURE;

    STDMETHOD (GetPalette)( THIS_ HPALETTE * hpal ) PURE;

    STDMETHOD (RegisterWindow)(THIS_ BOOL fUnregister, int swc) PURE;

    // Warning!  Do not add any new methods to this interface
    // because IE4 shell32.dll uses it, so changing the interface
    // breaks IE4 interop.
};

#define BSF_REGISTERASDROPTARGET 0x00000001
#define BSF_THEATERMODE          0x00000002
#define BSF_NOLOCALFILEWARNING   0x00000010
#define BSF_UISETBYAUTOMATION    0x00000100
#define BSF_RESIZABLE            0x00000200

#ifndef RC_INVOKED
#include <pshpack8.h>
#endif /* !RC_INVOKED */

typedef struct SToolbarItem {
    IDockingWindow * ptbar;
    BORDERWIDTHS    rcBorderTool;
    LPWSTR          pwszItem;
    BOOL            fShow;
    HMONITOR        hMon;
} TOOLBARITEM, *LPTOOLBARITEM;
#define ITB_VIEW        ((UINT)-1)      // view

#ifndef RC_INVOKED
#include <poppack.h>   /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

struct tagFolderSetData;

// TEMPORARY.  this is so that we don't have to keep writing dummy subs in basesb as we're
// building basesb2
DECLARE_INTERFACE_(IBrowserService2, IBrowserService)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBrowserService specific methods ***
    // TODO: break into 3 sections (outer, inner, and both/inherit)
    STDMETHOD(GetParentSite)(THIS_ struct IOleInPlaceSite** ppipsite) PURE;
    STDMETHOD(SetTitle)(THIS_ IShellView* psv, LPCWSTR pszName) PURE;
    STDMETHOD(GetTitle)(THIS_ IShellView* psv, LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(GetOleObject)(THIS_ struct IOleObject** ppobjv) PURE;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // BUGBUG:: Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    STDMETHOD(GetTravelLog)(THIS_ ITravelLog** pptl) PURE;

    STDMETHOD(ShowControlWindow)(THIS_ UINT id, BOOL fShow) PURE;
    STDMETHOD(IsControlWindowShown)(THIS_ UINT id, BOOL *pfShown) PURE;
    STDMETHOD(IEGetDisplayName)(THIS_ LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) PURE;
    STDMETHOD(IEParseDisplayName)(THIS_ UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) PURE;
    STDMETHOD(DisplayParseError)(THIS_ HRESULT hres, LPCWSTR pwszPath) PURE;
    STDMETHOD(NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF) PURE;

    STDMETHOD (SetNavigateState)(THIS_ BNSTATE bnstate) PURE;
    STDMETHOD (GetNavigateState) (THIS_ BNSTATE *pbnstate) PURE;

    STDMETHOD (NotifyRedirect) (THIS_ struct IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) PURE;
    STDMETHOD (UpdateWindowList) (THIS) PURE;

    STDMETHOD (UpdateBackForwardState) (THIS) PURE;

    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags, DWORD dwFlagMask) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;

    // Tells if it can navigate now or not.
    STDMETHOD (CanNavigateNow) (THIS) PURE;

    STDMETHOD (GetPidl) (THIS_ LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (SetReferrer) (THIS_ LPITEMIDLIST pidl) PURE;
    STDMETHOD_(DWORD, GetBrowserIndex)(THIS) PURE;
    STDMETHOD (GetBrowserByIndex)(THIS_ DWORD dwID, IUnknown **ppunk) PURE;
    STDMETHOD (GetHistoryObject)(THIS_ IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) PURE;
    STDMETHOD (SetHistoryObject)(THIS_ IOleObject *pole, BOOL fIsLocalAnchor) PURE;

    STDMETHOD (CacheOLEServer)(THIS_ IOleObject *pole) PURE;

    STDMETHOD (GetSetCodePage)(THIS_ VARIANT* pvarIn, VARIANT* pvarOut) PURE;
    STDMETHOD (OnHttpEquiv)(THIS_ IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) PURE;

    STDMETHOD (GetPalette)( THIS_ HPALETTE * hpal ) PURE;

    STDMETHOD (RegisterWindow)(THIS_ BOOL fUnregister, int swc) PURE;

    // Stuff added for shbrowse->shbrows2 split
    // These remove "friend" functions and classes
    //
    STDMETHOD_(LRESULT, WndProcBS)(THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    STDMETHOD (SetAsDefFolderSettings)(THIS) PURE;
    STDMETHOD (GetViewRect)(THIS_ RECT * prc) PURE;

    STDMETHOD (OnSize)(THIS_ WPARAM wParam) PURE;
    STDMETHOD (OnCreate)(THIS_ LPCREATESTRUCT pcs) PURE;
    STDMETHOD_(LRESULT, OnCommand)(THIS_ WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD (OnDestroy)(THIS ) PURE;
    STDMETHOD_(LRESULT, OnNotify)(THIS_ NMHDR * pnm) PURE;
    STDMETHOD (OnSetFocus)(THIS ) PURE;
    STDMETHOD (OnFrameWindowActivateBS)(THIS_ BOOL fActive) PURE;

    STDMETHOD (ReleaseShellView)(THIS ) PURE;
    STDMETHOD (ActivatePendingView)(THIS ) PURE;
    STDMETHOD (CreateViewWindow)(THIS_ IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd) PURE;
    STDMETHOD (CreateBrowserPropSheetExt)(THIS_ REFIID riid, void **ppv) PURE;

    // these could be base browser only interfaces
    // they are not overridden by anyone, and perhaps only there for the aggregators to get info from the
    // aggregatee. NOTE: where basesb calls these,
    // it does NOT go through _pbsOuter
    STDMETHOD (GetViewWindow)(THIS_ HWND * phwndView) PURE;
    STDMETHOD (GetBaseBrowserData)(THIS_ LPCBASEBROWSERDATA * pbbd) PURE;
    STDMETHOD_(LPBASEBROWSERDATA, PutBaseBrowserData)(THIS) PURE;
    STDMETHOD (InitializeTravelLog)(THIS_ ITravelLog* ptl, DWORD dw) PURE;
    STDMETHOD (SetTopBrowser)(THIS) PURE;
    STDMETHOD (Offline)(THIS_ int iCmd) PURE;
    STDMETHOD (AllowViewResize)(THIS_ BOOL f) PURE;
    STDMETHOD (SetActivateState)(THIS_ UINT u) PURE;
    STDMETHOD (UpdateSecureLockIcon)(THIS_ int eSecureLock) PURE;
    STDMETHOD (InitializeDownloadManager)(THIS) PURE;
    STDMETHOD (InitializeTransitionSite)(THIS) PURE;
    STDMETHOD (_Initialize)(THIS_ HWND hwnd, IUnknown *pauto) PURE;


    // BEGIN REVIEW:  review names and need of each.
    //
    // this first set could be basebrowser only members.  no one overrides
    // NOTE: where basesb calls these, it does NOT go throug _pbsOuter
    STDMETHOD (_CancelPendingNavigationAsync)(THIS) PURE;
    STDMETHOD (_CancelPendingView)(THIS) PURE;
    STDMETHOD (_MaySaveChanges)(THIS) PURE;
    STDMETHOD (_PauseOrResumeView)(THIS_ BOOL fPaused) PURE;
    STDMETHOD (_DisableModeless)(THIS) PURE;

    // rethink these... are all of these necessary?
    STDMETHOD (_NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags)PURE;
    STDMETHOD (_TryShell2Rename)(THIS_ IShellView* psv, LPCITEMIDLIST pidlNew)PURE;
    STDMETHOD (_SwitchActivationNow)(THIS )PURE;

    // this set is overridden and called thru _pbsOuter (and SUPER:_pbsInner)
    STDMETHOD (_ExecChildren)(IUnknown *punkBar, BOOL fBroadcast,
                              const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                              VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)PURE;
    STDMETHOD (_SendChildren)(HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    //END REVIEW:

    // querying from the outer.
    STDMETHOD (GetFolderSetData)(THIS_ struct tagFolderSetData* pfsd) PURE;

    // Toolbar stuff is here temporarily. Eventually it will move out
    // of basesb into commonsb, so I'm keeping the underscore "_"
    // Except those noted below, none of these are overridden by
    // outer guys, so no calls are made through _pbsOuter
    STDMETHOD (_OnFocusChange)(UINT itb) PURE;
    STDMETHOD (v_ShowHideChildWindows)(BOOL fChildOnly) PURE; // NOTE: overridden and called thru _pbsOuter
    STDMETHOD_(UINT,_get_itbLastFocus)() PURE;
    STDMETHOD (_put_itbLastFocus)(UINT itbLastFocus) PURE;
    STDMETHOD (_UIActivateView)(UINT uState) PURE;

    // Check the following functions
    STDMETHOD (_GetViewBorderRect)(RECT* prc) PURE;
    STDMETHOD (_UpdateViewRectSize)() PURE;
    STDMETHOD (_ResizeNextBorder)(UINT itb) PURE;
    STDMETHOD (_ResizeView)() PURE;

    STDMETHOD (_GetEffectiveClientArea)(LPRECT lprectBorder, HMONITOR hmon) PURE;

    // Desktop needs to override this from commonsb
    STDMETHOD_(IStream*,v_GetViewStream)(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName) PURE;

    // Desktop needs access to these commonsb functions, they are not overridden:
    STDMETHOD_(LRESULT,ForwardViewMsg)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD (SetAcceleratorMenu)(THIS_ HACCEL hacc) PURE;
    STDMETHOD_(int,_GetToolbarCount)(THIS) PURE;
    STDMETHOD_(LPTOOLBARITEM,_GetToolbarItem)(THIS_ int itb) PURE;
    STDMETHOD (_SaveToolbars)(IStream* pstm) PURE;
    STDMETHOD (_LoadToolbars)(IStream* pstm) PURE;
    STDMETHOD (_CloseAndReleaseToolbars)(BOOL fClose) PURE;
    STDMETHOD (v_MayGetNextToolbarFocus)(LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd) PURE;
    STDMETHOD (_ResizeNextBorderHelper)(UINT itb, BOOL bUseHmonitor) PURE;
    STDMETHOD_(UINT,_FindTBar)(IUnknown* punkSrc) PURE;
    STDMETHOD (_SetFocus)(LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg) PURE;
    STDMETHOD (v_MayTranslateAccelerator)(MSG* pmsg) PURE;
    STDMETHOD (_GetBorderDWHelper)(IUnknown* punkSrc, LPRECT lprectBorder, BOOL bUseHmonitor) PURE;

    // Shell browser needs to override this from basesb.

    STDMETHOD (v_CheckZoneCrossing)(LPCITEMIDLIST pidl) PURE;
};

// these MUST be listed in  the same order a c_szPropNames in deskbar.cpp
typedef enum {
    PROPDATA_SIDE = 0,
    PROPDATA_MODE,
    PROPDATA_LEFT,
    PROPDATA_TOP,
    PROPDATA_RIGHT,
    PROPDATA_BOTTOM,
    PROPDATA_DELETEABLE,
    PROPDATA_X,
    PROPDATA_Y,
    PROPDATA_CX,
    PROPDATA_CY,

    PROPDATA_COUNT
} ENUMPROPDATA ;

// PROPDATA_MODE values:
//  (aka. WBM_* -- webbar modes (_eMode))
#define WBM_BOTTOMMOST  ((UINT) 0x0)      // bottommost
#define WBM_TOPMOST     ((UINT) 0x1)      // topmost
#define WBM_FLOATING    ((UINT) 0x2)      // floating
#define WBM_NIL         ((UINT) 0x7)      // nil

#undef  INTERFACE
#define INTERFACE  IDockingBarPropertyBagInit
DECLARE_INTERFACE_(IDockingBarPropertyBagInit, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDockingBarPropertyBag ***
    STDMETHOD(SetDataDWORD)(THIS_ ENUMPROPDATA e, DWORD dwData) PURE;
} ;

#if (_WIN32_IE) >= 0x0400
//===========================================================================
// IAddressList private COmWindow interface. This should never be exposed.
#undef INTERFACE
#define INTERFACE IAddressList
DECLARE_INTERFACE_(IAddressList, IWinEventHandler)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWinEventHandler Methods ***
    STDMETHOD(OnWinEvent) (THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres) PURE;
    STDMETHOD(IsWindowOwner) (THIS_ HWND hwnd) PURE;

    // *** IAddressList Methods ***
    STDMETHOD(Connect) (THIS_ BOOL fConnect, HWND hwnd, IBrowserService* pbs, IBandProxy* pbp, IAutoComplete * pac) PURE;
    STDMETHOD(NavigationComplete) (THIS_ void *pvCShellUrl) PURE;
    STDMETHOD(Refresh) (THIS_ DWORD dwType) PURE;
    STDMETHOD(Load) (THIS) PURE;
    STDMETHOD(Save) (THIS) PURE;
    STDMETHOD(SetToListIndex) (THIS_ int nIndex, void *pvShelLUrl) PURE;
    STDMETHOD(FileSysChangeAL) (THIS_ DWORD dw, LPCITEMIDLIST *ppidl) PURE;
};
#endif


//
// IDocViewSite
//
#undef  INTERFACE
#define INTERFACE  IDocViewSite
DECLARE_INTERFACE_(IDocViewSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocViewSite methods ***
    STDMETHOD(OnSetTitle) (THIS_ VARIANTARG *pvTitle) PURE;

} ;

#endif

//===========================================================================
// INSCTree: This is a private interface
// CreateTree() dwStyles - these are normal window styles.
// Initialize() grfFlags - these are SHCONTF_* flags defined in <shlobj.h>.
//              dwFlags - these are NSCTree Behavior flags defined below
//                   NSS_DROPTARGET - Enable drag and drop
//                   NSS_BROWSERSELECT - With this on, a selection is different than the standard
//                      tree view selection in that a box is drawn around the sub heirarchy selected
//                      and the buttons are turned off.
// SetNscMode() nMode - these are modes that inherit general behavior.  Defined below

// NSCTree Behavior flags: (INSCTree::Initialize(..., dwFlags))
#define NSS_DROPTARGET          0x0001      // register as a drop target
#define NSS_BROWSERSELECT       0x0002      // Use the browser style selection (see above)
#define NSS_NOHISTSELECT        0x0004      // Do not select the history entry on navigations.

// NSCTree Modes: (INSCTree::SetNscMode(nMode))
typedef enum
{
    MODE_NORMAL           = 0x0000,             // Act like a normal tree view
    MODE_CONTROL          = 0x0001,             // Have behaviors specific the being hosted in a control
    MODE_HISTORY          = 0x0002,             // Have behaviors specific to the History pane.
    MODE_FAVORITES        = 0x0004,             // Have behaviors specific to the Favorites pane.
} nscTreeMode;


#undef INTERFACE
#define INTERFACE INSCTree
DECLARE_INTERFACE_(INSCTree, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** INSCTree Methods ***
    STDMETHOD(CreateTree) (THIS_ HWND hwndParent, DWORD dwStyles, HWND *phwnd) PURE;
    STDMETHOD(Initialize) (THIS_ LPCITEMIDLIST pidlRoot, DWORD grfFlags, DWORD dwFlags) PURE;
    STDMETHOD(ShowWindow) (THIS_ BOOL fShow) PURE;
    STDMETHOD(Refresh) (THIS) PURE;
    STDMETHOD(GetSelectedItem) (THIS_ LPITEMIDLIST * ppidl, int nItem) PURE;
    STDMETHOD(SetSelectedItem) (THIS_ LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert, int nItem) PURE;
    STDMETHOD(GetNscMode) (THIS_ UINT * pnMode) PURE;
    STDMETHOD(SetNscMode) (THIS_ UINT nMode) PURE;
    STDMETHOD(GetSelectedItemName) (THIS_ LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(BindToSelectedItemParent) (THIS_ REFIID riid, void **ppv, LPITEMIDLIST *ppidl) PURE;
    STDMETHOD_(BOOL, InLabelEdit) (THIS) PURE;
};


//===========================================================================
// IDwnCodePage: This is a private interface to pass codepage info.
#undef INTERFACE
#define INTERFACE IDwnCodePage

DECLARE_INTERFACE_(IDwnCodePage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDwnCodePage Methods ***
    STDMETHOD_(UINT,GetCodePage) (THIS) PURE;
    STDMETHOD(SetCodePage) (THIS_ UINT uiCP) PURE;
};

//===========================================================================
// Helper functions for pidl allocation using the task allocator.
//
SHSTDAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
SHSTDAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut);
#define SHILFree(pidl)  SHFree(pidl)

SHSTDAPI SHDllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);

//===========================================================================

//----------------------------------------------------------------------------
#define IsLFNDriveORD           119
SHSTDAPI_(int) SHOutOfMemoryMessageBox(HWND hwndOwner, LPTSTR pszTitle, UINT fuStyle);
SHSTDAPI_(BOOL) SHWinHelp(HWND hwndMain, LPCTSTR pszHelp, UINT usCommand, ULONG_PTR ulData);

SHSTDAPI_(BOOL) RLBuildListOfPaths(void);

#ifdef WINNT
SHSTDAPI_(BOOL) RegenerateUserEnvironment(void **pPrevEnv, BOOL bSetCurrentEnv);
#endif

#define SHValidateUNCORD        173

#define VALIDATEUNC_NOUI        0x0002          // don't bring up stinking UI!
#define VALIDATEUNC_CONNECT     0x0001          // connect a drive letter
#define VALIDATEUNC_PRINT       0x0004          // validate as print share instead of disk share
#define VALIDATEUNC_VALID       0x0007          // valid flags


SHSTDAPI_(BOOL) SHValidateUNC(HWND hwndOwner, LPTSTR pszFile, UINT fConnect);

//----------------------------------------------------------------------------
#define OleStrToStrNORD                         78
#define SHCloneSpecialIDListORD                 89
#define SHDllGetClassObjectORD                 128
#define SHLogILFromFSILORD                      95
#define SHMapPIDLToSystemImageListIndexORD      77
#define SHShellFolderView_MessageORD            73
#define Shell_GetImageListsORD                  71
#define SHGetSpecialFolderPathORD              175
#define StrToOleStrNORD                         79

#define ILCloneORD                              18
#define ILCloneFirstORD                         19
#define ILCombineORD                            25
#define ILCreateFromPathORD                     157
#define ILFindChildORD                          24
#define ILFreeORD                               155
#define ILGetNextORD                            153
#define ILGetSizeORD                            152
#define ILIsEqualORD                            21
#define ILRemoveLastIDORD                       17
#define PathAddBackslashORD                     32
#define PathCombineORD                          37
#define PathIsExeORD                            43
#define PathMatchSpecORD                        46
#define SHGetSetSettingsORD                     68
#define SHILCreateFromPathORD                   28

#define SHFreeORD                               195

#define CheckWinIniForAssocsORD                 711

SHSTDAPI_(HANDLE) PifMgr_OpenProperties(LPCTSTR pszApp, LPCTSTR pszPIF, UINT hInf, UINT flOpt);
SHSTDAPI_(int)    PifMgr_GetProperties(HANDLE hProps, LPCSTR pszGroup, void *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(int)    PifMgr_SetProperties(HANDLE hProps, LPCSTR pszGroup, const VOID *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(HANDLE) PifMgr_CloseProperties(HANDLE hProps, UINT flOpt);

SHSTDAPI_(void) SHSetInstanceExplorer(IUnknown *punk);

#ifndef WINNT
// Always usr TerminateThreadEx.
BOOL APIENTRY TerminateThreadEx(HANDLE hThread, DWORD dwExitCode, BOOL bCleanupFlag);
#define TerminateThread(hThread, dwExitCode) TerminateThreadEx(hThread, dwExitCode, TRUE)
#endif

SHSTDAPI_(BOOL) IsUserAnAdmin(void);

// Sortof Gross but if we pass this flag in with STGM_CREATE we will fail if file already exists
// with ERROR_ALREADY_EXISTS
#define CSOF_FAILIFTHERE         0x80000000L


//===========================================================================
// Structure for covert communication
// between shdocvw's CShellBrowser::Exec()
// and shell32's DefView WM_COMMAND handler
struct _DFVCMDDATA
{
    HWND        hwnd;               // Browser hwnd
    VARIANTARG  *pva;               // Args passed to Exec()
    DWORD       nCmdIDTranslated;   // Replacement OLECMDID_* value
};
typedef struct _DFVCMDDATA DFVCMDDATA;
typedef struct _DFVCMDDATA *LPDFVCMDDATA;
typedef const struct _DFVCMDDATA *LPCDFVCMDDATA;


SHSTDAPI_(DWORD) SHGetProcessDword(DWORD idProcess, LONG iIndex);
SHSTDAPI_(BOOL)  SHSetShellWindowEx(HWND hwnd, HWND hwndChild);

#define CCH_MENUMAX     80          // DOC: max size of a menu string


// WinEventHandler message ranges
#define MBHM_FIRST          (0x00000001)    // MenuBandHandler
#define MBHM_LAST           (0x000000ff)

#define MSFM_FIRST          (0x00000100)    // MenuShellFolder
#define MSFM_LAST           (0x000001ff)

#define FSFM_FIRST          (0x00000200)    // FileShellFolder
#define FSFM_LAST           (0x000002ff)



//-------------------------------------------------------------------------
//
// SID_SMenuBandHandler
//
//  The menuband calls QueryService(SID_SMenuBandHandler, IID_IWinEventHandler)
//  on its shellfolder.  If the shellfolder supports this service, the
//  menuband will call the event handler on certain menu events.  These
//  events and messages are as follows:
//
//    MBHM_INITMENUPOPUP    sent when a drop-down menu or submenu is
//                          about to become active.
//
//
//   File-system ShellFolder events:
//
//    FSFM_COMMAND          sent when a file-system item is executed
//
//-------------------------------------------------------------------------

typedef struct tagMBINITMENUPOPUP
{
    DWORD           dwMask;     // MBIMP_*
    IShellFolder *  psf;
    LPCITEMIDLIST   pidl;
    HMENU           hmenu;
    int             iPos;
} MBINITMENUPOPUP;

#define MBIMP_HMENU     0x00000001      // hmenu and iPos are set


// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ---
#define MBHM_INITMENUPOPUP  (MBHM_FIRST+0)  //  0           MBINITMENUPOPUP *


// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ------
#define FSFM_COMMAND        (FSFM_FIRST+0)  //  cmd ID      pidl


//-------------------------------------------------------------------------
//
// IAugmentedShellFolder interface
//
//   This provides methods to add multiple Shell Folder objects to a
//  single augmented object (CLSID_AugmentedShellFolder), which will
//  enumerate them as if they were in a single namespace.
//
//
// [Member functions]
//
// IAugmentedShellFolder::AddNameSpace(rguidObject, psf, pidl)
//   Add the object represented by the IShellFolder interface to
//   the augmented list.  The rguidObject is used to identify the
//   given object.  It may be NULL.  The optional pidl refers to
//   the location of the psf.
//
// IAugmentedShellFolder::GetNameSpaceID(pidl, rguidOut)
//   This method returns the rguidObject associated with the given
//   pidl.  This is how a caller can identify which namespace the
//   pidl resides, given the list of IShellFolder objects that were
//   added to this augmented object.
//
// IAugmentedShellFolder::QueryNameSpace(dwNameSpaceID, pguidOut, ppsf)
//   Returns the shellfolder and guid associated with the given ID.
//
// IAugmentedShellFolder::EnumNameSpace(uNameSpace, pdwNameSpaceID)
//   Enumerates the namespace shellfolders.  If uNameSpace is -1,
//   pdwNameSpaceID is ignored and this method returns the count of
//   shellfolders in the augmented namespace.  Call this method with
//   uNameSpace starting at 0 to begin enumerating.  Returns S_OK and
//   and namespace ID in *pdwNameSpaceID.
//
//-------------------------------------------------------------------------

//  IAugmentedShellFolder::AddNameSpace flags
enum
{
    ASFF_DEFAULT                   = 0x00000000, // There are no applicable Flags
    ASFF_SORTDOWN                  = 0x00000001, // Sort the items in this ISF to the bottom.
    ASFF_MERGE                     = 0x00000002, // Merge the 2 namespaces
    // the following should all be collapsed to one ASFF_DEFNAMESPACE
    ASFF_DEFNAMESPACE_BINDSTG      = 0x00000100, // The namespace is the default handler for BindToStorage() for merged child items.
    ASFF_DEFNAMESPACE_COMPARE      = 0x00000200, // The namespace is the default handler for CompareIDs() for merged child items.
    ASFF_DEFNAMESPACE_VIEWOBJ      = 0x00000400, // The namespace is the default handler for CreateViewObject() for merged child items.
    ASFF_DEFNAMESPACE_ATTRIB       = 0x00001800, // The namespace is the default handler for GetAttributesOf() for merged child items.
    ASFF_DEFNAMESPACE_DISPLAYNAME  = 0x00001000, // The namespace is the default handler for GetDisplayNameOf(), SetNameOf() and ParseDisplayName() for merged child items.
    ASFF_DEFNAMESPACE_UIOBJ        = 0x00002000, // The namespace is the default handler for GetUIObjectOf() for merged child items.
    ASFF_DEFNAMESPACE_ITEMDATA     = 0x00004000, // The namespace is the default handler for GetItemData() for merged child items.
    ASFF_DEFNAMESPACE_ALL          = 0x0000FF00  // The namespace is the primary handler for all IShellFolder operations on merged child items.
};

#undef  INTERFACE
#define INTERFACE   IAugmentedShellFolder

DECLARE_INTERFACE_(IAugmentedShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner,LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IAugmentedShellFolder methods ***
    STDMETHOD(AddNameSpace)     (THIS_ const GUID * pguidObject, IShellFolder * psf,
                                 LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(GetNameSpaceID)   (THIS_ LPCITEMIDLIST pidl, GUID * pguidOut) PURE;
    STDMETHOD(QueryNameSpace)   (THIS_ DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf) PURE;
    STDMETHOD(EnumNameSpace)    (THIS_ DWORD uNameSpace, DWORD * pdwID) PURE;
};

#undef  INTERFACE
#define INTERFACE   IAugmentedShellFolder2

DECLARE_INTERFACE_(IAugmentedShellFolder2, IAugmentedShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IAugmentedShellFolder methods ***
    STDMETHOD(AddNameSpace)     (THIS_ const GUID * pguidObject, IShellFolder * psf,
                                 LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(GetNameSpaceID)   (THIS_ LPCITEMIDLIST pidl, GUID * pguidOut) PURE;
    STDMETHOD(QueryNameSpace)   (THIS_ DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf) PURE;
    STDMETHOD(EnumNameSpace)    (THIS_ DWORD uNameSpace, DWORD * pdwID) PURE;

    // *** IAugmentedShellFolder2 methods ***
    //where are these used?
    //STDMETHOD(GetNameSpaceCount)  (THIS_ OUT LONG * pcNamespaces) PURE ;
    //STDMETHOD(GetIDListWrapCount) (THIS_ LPCITEMIDLIST pidlWrap, OUT LONG * pcPidls) PURE ;
    STDMETHOD(UnWrapIDList)       (THIS_ LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder ** apsf, LPITEMIDLIST * apidlFolder, LPITEMIDLIST * apidlItems, LONG * pcFetched ) PURE ;
};


//-------------------------------------------------------------------------
//
// IProxyShellFolder interface
//
//   This provides methods to set a proxy object which can respond
//  to GetUIObjectOf instead of or in addition to the hosted object
//  the supports IShellFolder.  All other methods are forwarded onto
//  the hosted object.  The CLSID_HostProxyShellFolder object implements
//  this interface.
//
//   The Win95 shell does not support aggregation, so this object
//  must be extra careful that it follows the rules of COM.
//
//   This interface is implemented by an object that wishes to provide
//  more support for GetUIObjectOf on behalf of another object that
//  implements an original IShellFolder.
//
// [Member functions]
//
// IProxyShellFolder::InitHostProxy(psf, pidl, punk, dwFlags)
//   Set the object that implements IProxyShellFolder.  Depending
//   on dwFlags, this object will be called instead of or in addition
//   to the host's method.
//
//      SPF_PRIORITY            - call the proxy's method instead of
//                              the host's method.
//      SPF_SECONDARY           - call the proxy's method only if the
//                              host's method doesn't support it.
//      SPF_INHERIT             - create a new object of this class and
//                              hand it back for BindToObject.
//      SPF_FOLDERPRECEDENCE    - have the proxy give folders priority
//                              over files in a call to CompareIDs.
//      SPF_HAVECALLBACK        - have the proxy call the owner's
//                              IOleCommandTarget on each enumerated
//                              object, for filtering.
//
//   Also sets as the host the given object which fully implements
//   IShellFolder.  pidl refers to the shell folder.
//
// IProxyShellFolder::CloneProxyPSF(riid, ppv)
//   Tells the object to clone itself.  The host proxy will call this
//   whenever IShellFolder::BindToObject is called.
//
// IProxyShellFolder::GetUIObjectOfPSF(hwndOwner, cidl, apidl, riid, prgfInOut, ppv)
//   Called by CLSID_HostProxyShellFolder to allow the proxy object
//   an opportunity to respond.
//
// IProxyShellFolder::CreateViewObjectPSF(hwndOwner, riid, ppv)
//   Called by CLSID_HostProxyShellFolder to allow the proxy object
//   an opportunity to respond.
//
//-------------------------------------------------------------------------

// SetProxyObject flags
#define SPF_PRIORITY            0x00000001       // This is mutually exclusive w/ SPF_SECONDARY
#define SPF_SECONDARY           0x00000002
#define SPF_INHERIT             0x00000004
#define SPF_FOLDERPRECEDENCE    0x00000008
#define SPF_HAVECALLBACK        0x00000010

//For filtering of Pidls
#define PHID_FilterOutPidl  0


#undef  INTERFACE
#define INTERFACE   IProxyShellFolder

DECLARE_INTERFACE_(IProxyShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IProxyShellFolder methods ***
    STDMETHOD(InitHostProxy)     (THIS_ IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(CloneProxyPSF)     (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD(GetUIObjectOfPSF) (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(CreateViewObjectPSF) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;

};


//-------------------------------------------------------------------------
//
// BUGBUG (scotth): I don't think we're using this anymore.
//
// ISetWinHandler interface
//
// [Member functions]
//
// ISetWinHandler::SetWindow(hwndOwner)
//   Specifies the window owner.  This may be NULL.
//
// ISetWinHandler::SetWinHandler(punk)
//   Gives a pointer to an object which supports IWinEventHandler.  The
//   hwnd will be the window handle set by the SetWindow method.  The
//   handler should return S_OK if the message is handled, otherwise S_FALSE.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   ISetWinHandler

DECLARE_INTERFACE_(ISetWinHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** ISetWinHandler methods ***
    STDMETHOD(SetWindow)        (THIS_ HWND hwndOwner) PURE;
    STDMETHOD(SetWinHandler)    (THIS_ IUnknown * punk) PURE;
};


//-------------------------------------------------------------------------
//
// IMenuShellFolder interface
//
//   This wraps a static HMENU with an IShellFolder interface.
//
//
// [Member functions]
//
// IMenuShellFolder::SetMenu(hmenu)
//   Specifies the hmenu to wrap.  This may be NULL.
//
//   BUGBUG (scotth): does this copy or not?
//
// IMenuShellFolder::GetMenu(phmenu)
//   Returns the current menu in *phmenu.  Returns S_FALSE if no menu is
//   set (*phmenu will be NULL).
//
// IMenuShellFolder::SetWindow(hwndOwner)
//   Specifies the window owner.  This may be NULL.
//
//-------------------------------------------------------------------------

// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ---
#define MSFM_COMMAND        (MSFM_FIRST+0)  //  cmd ID      0
#define MSFM_ISDROPTARGET   (MSFM_FIRST+1)  //  id          0           1 if yes


#undef  INTERFACE
#define INTERFACE   IMenuShellFolder

DECLARE_INTERFACE_(IMenuShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IMenuShellFolder methods ***
    STDMETHOD(SetMenu)          (THIS_ HMENU hmenu) PURE;
    STDMETHOD(GetMenu)          (THIS_ HMENU * phmenu) PURE;
    STDMETHOD(SetWindow)        (THIS_ HWND hwndOwner) PURE;
    STDMETHOD(GetWindow)        (THIS_ HWND *phwndOwner) PURE;
    STDMETHOD(GetIDPosition)    (THIS_ LPCITEMIDLIST pidl, int * pnPos) PURE;
};


//-------------------------------------------------------------------------
//
// ITranslateShellChangeNotify interface
//
//   This interface allows an object to translate the pidls that are
// passed to it.
//
// Note:  IE4 had an interface of the same name but with a different IID,
//        so there is no conflict.
//
// [Member functions]
//
// ITranslateShellChangeNotify::TranslateIDs(&lEvent, pidl1, pidl2, ppidlOut1, ppidlOut2)
//   Return converted pidls given the event. it also can change the event if appropriate
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   ITranslateShellChangeNotify

DECLARE_INTERFACE_(ITranslateShellChangeNotify, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** ITranslateShellChangeNotify methods ***
    STDMETHOD(TranslateIDs) (THIS_ LONG *plEvent , LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                   LONG *plEvent2, LPITEMIDLIST * ppidlOut1Event2, LPITEMIDLIST * ppidlOut2Event2) PURE;
    STDMETHOD(IsChildID)(THIS_ LPCITEMIDLIST pidlKid, BOOL fImmediate) PURE;
    STDMETHOD(IsEqualID)(THIS_ LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(Register)(THIS_ HWND hwnd, UINT uMsg, long lEvents) PURE;
    STDMETHOD(Unregister)(THIS) PURE;
};

////////////////////////////////////////////////////
//
// IRegTreeOptions
//
typedef enum tagBUTTON_STATES
{
    IDCHECKED,
    IDUNCHECKED,
    IDRADIOON,
    IDRADIOOFF,
    IDUNKNOWN
} BUTTON_STATES;

//
// Avoid conflicts in the windows\shell project
//
#ifndef NO_SHELL_TREE_TYPE
typedef enum tagTREE_TYPE
{
    TREE_CHECKBOX,
    TREE_RADIO,
    TREE_GROUP,
    TREE_UNKNOWN
} TREE_TYPE;
#endif // NO_SHELL_TREE_TYPE

typedef enum tagWALK_TREE_CMD
{
    WALK_TREE_SAVE,
    WALK_TREE_DELETE,
    WALK_TREE_RESTORE,
    WALK_TREE_REFRESH
} WALK_TREE_CMD;


enum REG_CMD
{
    REG_SET,
    REG_GET,
    REG_GETDEFAULT
};

#undef  INTERFACE
#define INTERFACE   IRegTreeOptions

DECLARE_INTERFACE_(IRegTreeOptions, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRegTreeOptions specific methods ***
    STDMETHOD(InitTree)(THIS_ HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey, LPCSTR pszParam) PURE;
    STDMETHOD(WalkTree)(THIS_ WALK_TREE_CMD cmd ) PURE;
    STDMETHOD(ToggleItem)(THIS_ HTREEITEM hti ) PURE;
    STDMETHOD(ShowHelp)(THIS_ HTREEITEM hti , DWORD dwFlags ) PURE;
};



//
// Interface: IShellHotKey
//

#undef  INTERFACE
#define INTERFACE   IShellHotKey

DECLARE_INTERFACE_(IShellHotKey, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellHotKey methods ***
    STDMETHOD(RegisterHotKey)(THIS_ IShellFolder * psf, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl) PURE;
};


//
// Interface: ITrayPriv
//
// Purpose: Talks to the new Start Menu code in Shdocvw from explorer.exe
//
// For flags on ShowFolder see inc\IETHREAD.H
//

#undef  INTERFACE
#define INTERFACE   ITrayPriv

DECLARE_INTERFACE_(ITrayPriv, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** ITrayPriv methods ***
    STDMETHOD(ExecItem)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(GetFindCM)(THIS_ HMENU hmenu, UINT idFirst, UINT idLast, IContextMenu** ppcmFind) PURE;
    STDMETHOD(GetStaticStartMenu)(THIS_ HMENU* phmenu) PURE;
};


#undef  INTERFACE
#define INTERFACE   IInitializeObject

DECLARE_INTERFACE_(IInitializeObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInitializeObject methods
    STDMETHOD(Initialize)(THIS) PURE;
};

enum
{
    BMICON_LARGE = 0,
    BMICON_SMALL
};

#undef  INTERFACE
#define INTERFACE   IBanneredBar

DECLARE_INTERFACE_(IBanneredBar, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBanneredBar methods ***
    STDMETHOD(SetIconSize)(THIS_ DWORD iIcon) PURE;
    STDMETHOD(GetIconSize)(THIS_ DWORD* piIcon) PURE;
    STDMETHOD(SetBitmap)(THIS_ HBITMAP hBitmap) PURE;
    STDMETHOD(GetBitmap)(THIS_ HBITMAP* phBitmap) PURE;

};

//
// Interface: IFolderShortcutConvert
//
// Purpose: Converts between FolderShortcuts and links
//

#undef  INTERFACE
#define INTERFACE   IFolderShortcutConvert

DECLARE_INTERFACE_(IFolderShortcutConvert, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //*** IFolderShortcutConvert methods ***
    STDMETHOD(ConvertToLink)(THIS_ LPCOLESTR pszFSPath, DWORD fFlags) PURE;
    STDMETHOD(ConvertToFolderShortcut)(THIS_ LPCOLESTR pszLinkPath, DWORD fFlags) PURE;
};

//
// Interface: IShellFolderTask
//
// Purpose: Initializes a task that does something by enumerating a shellfolder
//

#undef  INTERFACE
#define INTERFACE   IShellFolderTask

DECLARE_INTERFACE_(IShellFolderTask, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IShellFolderTask methods ***
    STDMETHOD(InitTaskSFT)(THIS_ IShellFolder *psfParent, LPITEMIDLIST pidlFull,
                           LONG nMaxRecursionLevel, DWORD dwFlags, DWORD dwTaskPriority) PURE;
};

// Flags for InitTaskSFT
#define ITSFT_RECURSE   0x00000001      // recurse into subfolders


//
// Interface: IStartMenuTask
//
// Purpose: Initializes a task that does something for the start menu
//

#undef  INTERFACE
#define INTERFACE   IStartMenuTask

DECLARE_INTERFACE_(IStartMenuTask, IShellFolderTask)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IShellFolderTask methods ***
    STDMETHOD(InitTaskSFT)(THIS_ IShellFolder *psfParent, LPITEMIDLIST pidlFull,
                           LONG nMaxRecursionLevel, DWORD dwFlags, DWORD dwTaskPriority) PURE;

    // *** IStartMenuTask methods ***
    STDMETHOD(InitTaskSMT)(THIS_ IShellHotKey * photkey, int iThreadPriority) PURE;
};

//
// Interface: IContextMenuCB
//
// Purpose: A call defview context menu callback object
//

#undef  INTERFACE
#define INTERFACE   IContextMenuCB

DECLARE_INTERFACE_(IContextMenuCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IContextMenuCB methods ***
    STDMETHOD(CallBack) (THIS_  IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg,
                                WPARAM wParam, LPARAM lParam) PURE;
};

// let the context menu handler call up to it's site to let the site implement certain functions
// BUGBUG: may need to add QueryRename(), QueryCut(), etc.

DECLARE_INTERFACE_(IContextMenuSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IContextMenuSite methods ***
    STDMETHOD(DoRename)() PURE;
    STDMETHOD(DoCut)() PURE;
};

#define SID_SContextMenuSite IID_IContextMenuSite

//
// Possible underline settings for shell icons.
//
enum
{
    ICON_YES,
    ICON_NO,
    ICON_HOVER,
    ICON_IE         // Use IE hyperlink settings
};

//-----------------------------------------------
// IOleCommand Target Command IDs

// CGID_BandHandler
    //  Get the order stream from parent.
#define BHCMDID_GetOrderStream      0x00000001

// CGID_Persist
    // Set the storage key.
#define MCBID_SetKey                0x00000001

// CGID_MenuBandItem
#define MBICMDID_IsVisible          0x00000001

// CGID_MenuBand
#define MBANDCID_REFRESH            0x10000000


//
// Interface: IShellMallocSpy
//
// Purpose: Facilitate IMallocSpy in the shell
//

#undef  INTERFACE
#define INTERFACE  IShellMallocSpy
DECLARE_INTERFACE_(IShellMallocSpy, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMallocSpy methods ***
    STDMETHOD(RegisterSpy) (THIS) PURE;
    STDMETHOD(RevokeSpy) (THIS) PURE;
    STDMETHOD(SetTracking) (THIS_ BOOL bTrack) PURE;
    STDMETHOD(AddToList) (THIS_ void *pv, SIZE_T cb) PURE;
    STDMETHOD(RemoveFromList) (THIS_ void *pv) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchProvider

DECLARE_INTERFACE_(ISearchProvider, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchObject methods ***
    STDMETHOD(GetSearchGUID)(THIS_ LPGUID lpGuid) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchItems

DECLARE_INTERFACE_(ISearchItems, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchItems methods ***
    //used by CSearchBand
    STDMETHOD(GetDefaultSearchUrl) (THIS_ LPWSTR pwzUrl, UINT cch) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchBandTBHelper

DECLARE_INTERFACE_(ISearchBandTBHelper, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchBandTBHelper methods ***
    // implemented by CSearchBand
    STDMETHOD(AddNextMenuItem) (THIS_ LPCWSTR pwszText, int idItem) PURE;
    STDMETHOD(SetOCCallback) (THIS_ IOleCommandTarget *pOleCmdTarget) PURE;
    STDMETHOD(ResetNextMenu) (THIS) PURE;
};

#undef  INTERFACE
#define INTERFACE   IEnumUrlSearch

typedef struct
{
    GUID  guid;
    WCHAR wszName[80];
    WCHAR wszUrl[2048];
}URLSEARCH, *LPURLSEARCH;

DECLARE_INTERFACE_(IEnumUrlSearch, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUrlSearch methods ***
    STDMETHOD(Next)(THIS_ ULONG celt, LPURLSEARCH rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone)(THIS_ IEnumUrlSearch **ppenum) PURE;
};

#undef  INTERFACE
#define INTERFACE   IFolderSearches

DECLARE_INTERFACE_(IFolderSearches, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFolderSearches methods ***
    STDMETHOD(EnumSearches) (THIS_ IEnumUrlSearch **ppenum) PURE;
    STDMETHOD(DefaultSearch) (THIS_ GUID *pguid) PURE;
};
#undef  INTERFACE
#define INTERFACE   IUserAssist

typedef struct
{
    DWORD   cbSize;     // SIZEOF
    DWORD   dwMask;     // INOUT requested/given (UEIM_*)
    int     cHit;       // profile count
    DWORD   dwAttrs;    // attributes (UEIA_*)
    FILETIME ftExecute; // Last execute filetime
} UEMINFO, *LPUEMINFO;

#define UEIM_HIT        0x01
#define UEIM_FILETIME   0x02

DECLARE_INTERFACE_(IUserAssist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IUserAssist methods ***
    STDMETHOD(FireEvent)(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(QueryEvent)(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui) PURE;
    STDMETHOD(SetEvent)(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui) PURE;
};



// This exists for the Internet Control Panel to be able to toggle who is the
// currently installed handler for FTP for the browser.
DECLARE_INTERFACE_(IFtpInstaller, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IFtpInstaller methods ***
    STDMETHOD(IsIEDefautlFTPClient)(THIS) PURE;
    STDMETHOD(RestoreFTPClient)(THIS) PURE;
    STDMETHOD(MakeIEDefautlFTPClient)(THIS) PURE;
};


//
// Private QueryContextMenuFlag passed from DefView
//
#define CMF_DVFILE       0x00010000     // "File" pulldown

SHSTDAPI_(LRESULT) SHShellFolderView_Message(HWND hwndMain, UINT uMsg, LPARAM lParam);


//
// Callback interface for the IShellFolderView
//
#undef  INTERFACE
#define INTERFACE   IShellFolderViewCB

DECLARE_INTERFACE_(IShellFolderViewCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderViewCB methods ***
    STDMETHOD(MessageSFVCB)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
};

// StringFromGUID and its constants
BOOL _StringFromGUID(GUID const* pid, LPTSTR pszString, UINT cb, UINT idString);

// Note:  The following are used by _StringFromGUID and/or are indexes into the
// c_szExtViewUIRegKeys string array in sfvext.cpp.
#define ID_EXTVIEWSTRFIRST          0
#define ID_EXTVIEWNAME              0 // name of view in menu
#define ID_EXTVIEWHELPTEXT          1 // help text for this view
#define ID_EXTVIEWTTTEXT            2 // tooltip text for this view
#define ID_EXTVIEWICONAREAIMAGE     3 // url of background bitmap for WebViewFolderContents OC
#define ID_EXTVIEWSTRLAST           3

#define ID_EXTVIEWCOLORSFIRST       4
#define ID_EXTVIEWTEXTBACKGROUND    4 // background text color for WebViewFolderContents OC
#define ID_EXTVIEWTEXT              5 // foreground text color for WebViewFolderContents OC
#define ID_EXTVIEWCOLORSLAST        5

#define ID_EXTVIEWMAX               5
#define ID_EXTVIEWSTRCOUNT  (ID_EXTVIEWSTRLAST - ID_EXTVIEWSTRFIRST + 1)
#define ID_EXTVIEWCOLORCOUNT    (ID_EXTVIEWCOLORSLAST - ID_EXTVIEWCOLORSFIRST + 1)
#define ID_EXTVIEWUICOUNT           (ID_EXTVIEWMAX + 1)

#define CLR_MYINVALID 0x8fffffff       // I need to use a special value since CLR_INVALID == CLR_NONE!!!!
#define ISVALIDCOLOR(a) ((a) != CLR_MYINVALID)

// The following are used as indexes into the crCustomColors array, and must be in the same
// order as their ID_EXTVIEW* counterparts above.  They are also used in an analogous array in CDefView.
#define CRID_CUSTOMTEXTBACKGROUND   ID_EXTVIEWTEXTBACKGROUND - ID_EXTVIEWCOLORSFIRST
#define CRID_CUSTOMTEXT             ID_EXTVIEWTEXT - ID_EXTVIEWCOLORSFIRST
#define CRID_COLORCOUNT             ID_EXTVIEWCOLORSLAST - ID_EXTVIEWCOLORSFIRST + 1

typedef struct _CUSTOMVIEWSDATA
{
    DWORD      cchSizeOfBlock;  // size of lpDataBlock in WCHARs
    LPWSTR     lpDataBlock;     // Pointer to the Strings data block, allocated by the task allocator (SHAlloc)

    // The following are offsets (in WCHARs) to be added to lpDataBlock.
    // If the offset is -1 => That data is not present for this view.
    int        acchOffExtViewUIstr[ID_EXTVIEWSTRCOUNT];
    COLORREF   crCustomColors[CRID_COLORCOUNT];

    // Once IE4 ships, we can extend this structure by adding new SFVF_ flags
    // in the main structure that say "customviewsdata contains xxx info".

} CUSTOMVIEWSDATA;

//
// Interface for enumerating "external" views for the ShellFolderView
//
typedef struct _SFVVIEWSDATA
{
    // idView specifies the view. Unless specified in pCustomData, look up
    // HKLM\CLSID\Software\Microsoft\Windows\CurrentVersion\ExtShellFolderViews\idView
    // to find the menu name, help text, tt text.
    //
    // the shell's IShellFolderView implementations get these as
    // subkeys of the shellex\ExtShellFolderViews key under the folder's
    // clsid type (or progid type, depending on the IShellFolderView impl).
    //
    // In desktop.ini, these are keys read from the [ExtShellFolderViews]
    // section, in the form of "{idView}" or "{idView}={idExtShellView}"
    //
    GUID idView;    // This is the GUID that specifies the View.

    // idExtShellView specifies the IDefViewExtInit IShellView extension
    // to use for this view.
    //
    // the shell's IShellFolderView implementations get this from
    // the "ISV" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [ExtShellFolderViews]
    // section, in the form of "{idView}={idExtShellView}"
    //
    GUID idExtShellView; // [optional] This is the GUID for the extended IShellView

    // dwFlags - see the SFVF_ flags below.
    //
    // the shell's IShellFolderView implementations get this from
    // the "Attributes" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "Attributes=" line.
    //
    DWORD dwFlags;

    // lParam is passed to IShellView view extensions
    //
    // the shell's IShellFolderView implementations get this from
    // the "lparam" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "LParam=" line.
    //
    DWORD lParam;

    // wszMoniker is used to either bind to a docobject extended view,
    // or as the data for an idExtShellView view.
    //
    // the shell's IShellFolderView implementations get this from
    // the "PersistMoniker" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "PersistMoniker=" line.
    //
    WCHAR wszMoniker[MAX_PATH];

    // pCustomData overrides/provides menu and other ui options
    // for this view. If a WebViewFolderContents OC appears in the
    // docobject extended view, it pays attention to color and
    // background bitmaps.
    //
    // the shell's IShellFolderView implementations do not fill out this structure.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "IconArea_Image", "IconArea_TextBackground", and "IconArea_Text".
    //
    CUSTOMVIEWSDATA *pCustomData; //This is valid only if SFVF_CUSTOMIZEDVIEW is set.

} SFVVIEWSDATA;

//
// SFVF_CUSTOMIZEDVIEW - This flag is set only for those views whose
// data are picked up from the Desktop.ini.
//
#define SFVF_CUSTOMIZEDVIEW  0x80000000

//
// SFVF_TREATASNORMAL - This flag is set for those views that wish to
// be treated as normal views, this means they will show up in the file-open/SaveAs
// Dialogs.
//
#define SFVF_TREATASNORMAL   0x40000000

//
// SFVF_NOWEBVIEWFOLDERCONTENTS - This is used to detect those views that
// never host the WebViewFolderContents OC and so cannot toggle on and off,
// ie, they are exclusive views such as Thumbnail View.
//
#define SFVF_NOWEBVIEWFOLDERCONTENTS   0x20000000


#undef  INTERFACE
#define INTERFACE   IEnumSFVViews

DECLARE_INTERFACE_(IEnumSFVViews, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumSFVViews methods ***
    STDMETHOD(Next)  (THIS_ ULONG celt,
                      SFVVIEWSDATA **ppData,
                      ULONG *pceltFetched) PURE;
    STDMETHOD(Skip)  (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSFVViews **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IPersistString

DECLARE_INTERFACE_(IPersistString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistString methods ***
    STDMETHOD(Initialize) (THIS_ LPCWSTR pwszInit) PURE;
};

#pragma warning (disable: 4200)
#pragma warning (disable: 4510)
#pragma warning (disable: 4512)
#pragma warning (disable: 4610)
// From sdkinc\platform.h
// We can't simply include that file because it breaks other projects
// that include platform.h.
#undef UNSIZED_ARRAY
#undef EMPTY_SIZE
#   ifdef UNIX
        // Unix specific compiler problems
#       define UNSIZED_ARRAY 1
#   else
#       define UNSIZED_ARRAY
#   endif // UNIX
#define EMPTY_SIZE UNSIZED_ARRAY
#define QCMINFO_PLACE_BEFORE    0
#define QCMINFO_PLACE_AFTER     1
typedef struct _QCMINFO_IDMAP_PLACEMENT
{
    UINT id;
    UINT fFlags;
} QCMINFO_IDMAP_PLACEMENT;

typedef struct _QCMINFO_IDMAP
{
    UINT    nMaxIds;
    const QCMINFO_IDMAP_PLACEMENT   pIdList[EMPTY_SIZE];
} QCMINFO_IDMAP;

typedef struct _QCMINFO
{
    HMENU       hmenu;          // in
    UINT        indexMenu;      // in
    UINT        idCmdFirst;     // in/out
    UINT        idCmdLast;      // in
    const QCMINFO_IDMAP*  pIdMap;      //out
} QCMINFO;
typedef QCMINFO * LPQCMINFO;

// TBINFO flags
#define TBIF_APPEND     0
#define TBIF_PREPEND    1
#define TBIF_REPLACE    2
#define TBIF_DEFAULT      0x00000000
#define TBIF_INTERNETBAR  0x00010000
#define TBIF_STANDARDTOOLBAR   0x00020000
#define TBIF_NOTOOLBAR  0x00030000

typedef struct _TBINFO
{
    UINT        cbuttons;       // out
    UINT        uFlags;         // out (one of TBIF_ flags)
} TBINFO;


typedef struct _SFVM_SELCHANGE_DATA
{
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
} SFVM_SELCHANGE_DATA;


typedef struct _COPYHOOKINFO
{
    HWND hwnd;
    DWORD wFunc;
    DWORD wFlags;
    LPCTSTR pszSrcFile;
    DWORD dwSrcAttribs;
    LPCTSTR pszDestFile;
    DWORD dwDestAttribs;
} COPYHOOKINFO;

typedef struct _DETAILSINFO
{
    LPCITEMIDLIST pidl;
    int fmt;
    int cxChar;
    STRRET str;
    int iImage;
} DETAILSINFO;

typedef struct _SFVM_PROPPAGE_DATA
{
    DWORD                dwReserved;
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM               lParam;
} SFVM_PROPPAGE_DATA;

typedef struct _SFVM_HELPTOPIC_DATA
{
    WCHAR wszHelpFile[MAX_PATH];
    WCHAR wszHelpTopic[MAX_PATH];
} SFVM_HELPTOPIC_DATA;


// SFVM_GETNOTIFY: The shell will use the pidl returned from this message to synch
//                 change notifies.  Folders in Folder Shortcuts should return pidlTarget
//                 because that is where the change notifies are sent.
//
//                                uMsg    wParam             lParam
#define SFVM_MERGEMENU            1    // 0                  LPQCMINFO
#define SFVM_INVOKECOMMAND        2    // idCmd              0
#define SFVM_GETHELPTEXT          3    // idCmd,cchMax       pszText - Ansi/unicode (yup, old Tchar version)
#define SFVM_GETTOOLTIPTEXT       4    // idCmd,cchMax       pszText - Ansi/unicode (yup, old tchar version)
#define SFVM_GETBUTTONINFO        5    // 0                  LPTBINFO
#define SFVM_GETBUTTONS           6    // idCmdFirst,cbtnMax LPTBBUTTON
#define SFVM_INITMENUPOPUP        7    // idCmdFirst,nIndex  hmenu
#define SFVM_SELCHANGE            8    // idCmdFirst,nItem   SFVM_SELCHANGE_DATA*
#define SFVM_DRAWITEM             9    // idCmdFirst         DRAWITEMSTRUCT*
#define SFVM_MEASUREITEM         10    // idCmdFirst         MEASUREITEMSTRUCT*
#define SFVM_EXITMENULOOP        11    // -                  -
#define SFVM_PRERELEASE          12    // -                  -
#define SFVM_GETCCHMAX           13    // LPCITEMIDLIST      pcchMax
#define SFVM_FSNOTIFY            14    // LPCITEMIDLIST*     lEvent
#define SFVM_WINDOWCREATED       15    // hwnd               -
#define SFVM_WINDOWDESTROY       16    // hwnd               -
#define SFVM_REFRESH             17    // BOOL fPreOrPost    -                          NB: this may be called multiple times in a row
#define SFVM_SETFOCUS            18    // -                  -
#define SFVM_QUERYCOPYHOOK       20    // -                  -
#define SFVM_NOTIFYCOPYHOOK      21    // -                  COPYHOOKINFO*
#define SFVM_GETDETAILSOF        23    // iColumn            DETAILSINFO*
#define SFVM_COLUMNCLICK         24    // iColumn            -
#define SFVM_QUERYFSNOTIFY       25    // -                  SHChangeNotifyEntry *
#define SFVM_DEFITEMCOUNT        26    // -                  UINT*
#define SFVM_DEFVIEWMODE         27    // -                  FOLDERVIEWMODE*
#define SFVM_UNMERGEMENU         28    // -                  hmenu
#define SFVM_INSERTITEM          29    // pidl               -
#define SFVM_DELETEITEM          30    // pidl               -
#define SFVM_UPDATESTATUSBAR     31    // fInitialize        -
#define SFVM_BACKGROUNDENUM      32    // -                  -
#define SFVM_GETWORKINGDIR       33    // uMax               pszDir
#define SFVM_GETCOLSAVESTREAM    34    // flags              IStream **
#define SFVM_SELECTALL           35    // -                  -
#define SFVM_DIDDRAGDROP         36    // dwEffect           IDataObject *
#define SFVM_SUPPORTSIDENTITY    37    // -                  -
#define SFVM_FOLDERISPARENT      38    // -                  pidlChild
#define SFVM_SETISFV             39    // -                  IShellFolderView*
#define SFVM_GETVIEWS            40    // SHELLVIEWID*       IEnumSFVViews **
#define SFVM_THISIDLIST          41    // -                  LPITMIDLIST*
#define SFVM_GETITEMIDLIST       42    // iItem              LPITMIDLIST*
#define SFVM_SETITEMIDLIST       43    // iItem              LPITEMIDLIST
#define SFVM_INDEXOFITEMIDLIST   44    // *iItem             LPITEMIDLIST
#define SFVM_ODFINDITEM          45    // *iItem             NM_FINDITEM*
#define SFVM_HWNDMAIN            46    //                    hwndMain
#define SFVM_ADDPROPERTYPAGES    47    // -                  SFVM_PROPPAGE_DATA *
#define SFVM_BACKGROUNDENUMDONE  48    // -                  -
#define SFVM_GETNOTIFY           49    // LPITEMIDLIST*      LONG*
#define SFVM_ARRANGE             50    // -                  lParamSort
#define SFVM_QUERYSTANDARDVIEWS  51    // -                  BOOL *
#define SFVM_QUERYREUSEEXTVIEW   52    // -                  BOOL *
#define SFVM_GETSORTDEFAULTS     53    // iDirection         iParamSort
#define SFVM_GETEMPTYTEXT        54    // cchMax             pszText
#define SFVM_GETITEMICONINDEX    55    // iItem              int *piIcon
#define SFVM_DONTCUSTOMIZE       56    // -                  BOOL *pbDontCustomize
#define SFVM_SIZE                57    // resizing flag      cx, cy
#define SFVM_GETZONE             58    // -                  DWORD*
#define SFVM_GETPANE             59    // Pane ID            DWORD*
#define SFVM_ISOWNERDATA         60    // ISOWNERDATA        BOOL *
#define SFVM_GETODRANGEOBJECT    61    // iWhich             ILVRange **
#define SFVM_ODCACHEHINT         62    // -                  NMLVCACHEHINT *
#define SFVM_GETHELPTOPIC        63    // 0                  SFVM_HELPTOPIC_DATA *
#define SFVM_OVERRIDEITEMCOUNT   64    // -                  UINT*
#define SFVM_GETHELPTEXTW        65    // idCmd,cchMax       pszText - unicode
#define SFVM_GETTOOLTIPTEXTW     66    // idCmd,cchMax       pszText - unicode
#define SFVM_GETIPERSISTHISTORY  67    //                    IPersistHistory **
#define SFVM_GETANIMATION        68    // HINSTANCE *        WCHAR *
#define SFVM_GETHELPTEXTA        69    // idCmd,cchMax       pszText - ansi
#define SFVM_GETTOOLTIPTEXTA     70    // idCmd,cchMax       pszText - ansi

// The below two messages are only used in ownder data case, i.e. when SFVM_ISOWNERDATA returns TRUE
#define SFVM_GETICONOVERLAY      71    // iItem              int iOverlayIndex
#define SFVM_SETICONOVERLAY      72    // iItem              int * piOverlayIndex

#define SFVM_ALTERDROPEFFECT     73    // DWORD*             IDataObject*

// All of these macros are compatible with HANDLE_MSG in WINDOWSX.H

#define HANDLE_SFVM_MERGEMENU(pv, wP, lP, fn) \
    ((fn)((pv), (QCMINFO*)(lP)))

#define HANDLE_SFVM_INVOKECOMMAND(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP)))

#define HANDLE_SFVM_GETHELPTEXT(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETTOOLTIPTEXT(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETBUTTONINFO(pv, wP, lP, fn) \
    ((fn)((pv), (TBINFO*)(lP)))

#define HANDLE_SFVM_GETBUTTONS(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (TBBUTTON*)(lP)))

#define HANDLE_SFVM_INITMENUPOPUP(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (HMENU)(lP)))

#define HANDLE_SFVM_SELCHANGE(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (SFVM_SELCHANGE_DATA*)(lP)))

#define HANDLE_SFVM_DRAWITEM(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (DRAWITEMSTRUCT*)(lP)))

#define HANDLE_SFVM_MEASUREITEM(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (MEASUREITEMSTRUCT*)(lP)))

#define HANDLE_SFVM_EXITMENULOOP(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_PRERELEASE(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_GETCCHMAX(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(wP), (UINT*)(lP)))

#define HANDLE_SFVM_FSNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST*)(wP), (lP)))

#define HANDLE_SFVM_WINDOWCREATED(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(wP)))

#define HANDLE_SFVM_WINDOWDESTROY(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(wP)))

#define HANDLE_SFVM_REFRESH(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL) wP))

#define HANDLE_SFVM_SETFOCUS(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_QUERYCOPYHOOK(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_NOTIFYCOPYHOOK(pv, wP, lP, fn) \
    ((fn)((pv), (COPYHOOKINFO*)(lP)))

#define HANDLE_SFVM_GETDETAILSOF(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (DETAILSINFO*)(lP)))

#define HANDLE_SFVM_COLUMNCLICK(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP)))

#define HANDLE_SFVM_QUERYFSNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (SHChangeNotifyEntry*)(lP)))

#define HANDLE_SFVM_DEFITEMCOUNT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT*)(lP)))

#define HANDLE_SFVM_OVERRIDEITEMCOUNT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT*)(lP)))

#define HANDLE_SFVM_DEFVIEWMODE(pv, wP, lP, fn) \
    ((fn)((pv), (FOLDERVIEWMODE*)(lP)))

#define HANDLE_SFVM_UNMERGEMENU(pv, wP, lP, fn) \
    ((fn)((pv), (HMENU)(lP)))

#define HANDLE_SFVM_INSERTITEM(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(lP)))

#define HANDLE_SFVM_DELETEITEM(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(lP)))

#define HANDLE_SFVM_UPDATESTATUSBAR(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL)(wP)))

#define HANDLE_SFVM_BACKGROUNDENUM(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_GETWORKINGDIR(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETCOLSAVESTREAM(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (IStream**)(lP)))

#define HANDLE_SFVM_SELECTALL(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_DIDDRAGDROP(pv, wP, lP, fn) \
    ((fn)((pv), (DWORD)(wP), (IDataObject*)(lP)))

#define HANDLE_SFVM_HWNDMAIN(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(lP)))

#define HANDLE_SFVM_GETNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST*)(wP), (LONG*)(lP)))

#define HANDLE_SFVM_SETISFV(pv, wP, lP, fn) \
    ((fn)((pv), (IShellFolderView*)(lP)))

#define HANDLE_SFVM_GETVIEWS(pv, wP, lP, fn) \
    ((fn)((pv), (SHELLVIEWID*)(wP), (IEnumSFVViews**)(lP)))

#define HANDLE_SFVM_THISIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST*)(lP)))

#define HANDLE_SFVM_GETITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (LPITEMIDLIST*)(lP)))

#define HANDLE_SFVM_SETITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_INDEXOFITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (int*)(wP), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_ODFINDITEM(pv, wP, lP, fn) \
    ((fn)((pv), (int*)(wP), (NM_FINDITEM*)(lP)))

#define HANDLE_SFVM_ADDPROPERTYPAGES(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_PROPPAGE_DATA *)(lP)))

#define HANDLE_SFVM_FOLDERISPARENT(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_ARRANGE(pv, wP, lP, fn) \
    ((fn)((pv), (LPARAM)(lP)))

#define HANDLE_SFVM_QUERYSTANDARDVIEWS(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_QUERYREUSEEXTVIEW(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_GETEMPTYTEXT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETITEMICONINDEX(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int*)(lP)))

#define HANDLE_SFVM_SIZE(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(lP), HIWORD(lP)))

#define HANDLE_SFVM_GETZONE(pv, wP, lP, fn) \
    ((fn)((pv), (DWORD *)(lP)))

#define HANDLE_SFVM_GETPANE(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (DWORD *)(lP)))

#define HANDLE_SFVM_ISOWNERDATA(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_GETODRANGEOBJECT(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (ILVRange **)(lP)))

#define HANDLE_SFVM_ODCACHEHINT(pv, wP, lP, fn) \
    ((fn)((pv), (NMLVCACHEHINT*)(lP)))

#define HANDLE_SFVM_GETHELPTOPIC(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_HELPTOPIC_DATA *)(lP)))

#define HANDLE_SFVM_GETIPERSISTHISTORY(pv, wP, lP, fn) \
    ((fn)((pv), (IPersistHistory **)(lP)))

#define HANDLE_SFVM_SETICONOVERLAY(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int)(lP)))

#define HANDLE_SFVM_GETICONOVERLAY(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int *)(lP)))

#define HANDLE_SFVM_ALTERDROPEFFECT(pv, wP, lP, fn) \
	((fn)((pv), (DWORD *)(wP), (IDataObject *)(lP)))

//
// Return values for SFVM_GETICONOVERLAY:
// If the icon overlay is not set and you want the shell to set it for you.
// return SFVOVERLAY_UNSET. This will cause the shell to retrieve the overlay and
// send SFVM_SETICONOVERLAY.
// If there is no overlay for this item at all, the correct return value is
// SFVOVERLAY_DEFAULT
// If you return SFVOVERLAY_UNSET every time for SFVM_GETICONOVERLAY, the
// shell will keep setting it indefinitely, so there is a danger of infinite loop
//
#define SFV_ICONOVERLAY_DEFAULT    0
#define SFV_ICONOVERLAY_UNSET      0xFFFFFFFF

//
// What you can return from SFVM_UPDATESTATUSBAR:
//
//  E_NOTIMPL - Message not handled; DefView should manage status bar
//
// Otherwise, update the status bar yourself and return a bitmask of the
// following codes indicating what you want DefView to do for you.
//
#define SFVUSB_HANDLED      0x0000  // Client handled completely - DefView does nothing
#define SFVUSB_INITED       0x0001  // Client initialized parts  - DefView will set text
#define SFVUSB_ALL          0x0001

// IShellFolderView interface for getting the SFV to do things
//

typedef struct _ITEMSPACING
{
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING;


// Define OPtions for SetObjectCount
#define SFVSOC_INVALIDATE_ALL   0x00000001  // Assumed to reset only what is neccessary...
#define SFVSOC_NOSCROLL         LVSICF_NOSCROLL

// defines for IShellFolderView::SelectItems()
#define SFVS_SELECT_NONE        0x0 // unselect all
#define SFVS_SELECT_ALLITEMS    0x1 // select all
#define SFVS_SELECT_INVERT      0x2 // Inver the selection

// defines for IShellFolderView::QuerySupport()
// allows a view to be queried to see if it supports various operations (useful for
// enabling menu items)
#define SFVQS_AUTO_ARRANGE      0x0001
#define SFVQS_ARRANGE_GRID      0x0002
#define SFVQS_SELECT_ALL        0x0004
#define SFVQS_SELECT_NONE       0x0008
#define SFVQS_SELECT_INVERT     0x0010

#undef  INTERFACE
#define INTERFACE   IShellFolderView

DECLARE_INTERFACE_(IShellFolderView, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderView methods ***
    STDMETHOD(Rearrange) (THIS_ LPARAM lParamSort) PURE;
    STDMETHOD(GetArrangeParam) (THIS_ LPARAM *plParamSort) PURE;
    STDMETHOD(ArrangeGrid) (THIS) PURE;
    STDMETHOD(AutoArrange) (THIS) PURE;
    STDMETHOD(GetAutoArrange) (THIS) PURE;
    STDMETHOD(AddObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(GetObject) (THIS_ LPITEMIDLIST *ppidl, UINT uItem) PURE;
    STDMETHOD(RemoveObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(GetObjectCount) (THIS_ UINT *puCount) PURE;
    STDMETHOD(SetObjectCount) (THIS_ UINT uCount, UINT dwFlags) PURE;
    STDMETHOD(UpdateObject) (THIS_ LPITEMIDLIST pidlOld, LPITEMIDLIST pidlNew, UINT *puItem) PURE;
    STDMETHOD(RefreshObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(SetRedraw) (THIS_ BOOL bRedraw) PURE;
    STDMETHOD(GetSelectedCount) (THIS_ UINT *puSelected) PURE;
    STDMETHOD(GetSelectedObjects) (THIS_ LPCITEMIDLIST **pppidl, UINT *puItems) PURE;
    STDMETHOD(IsDropOnSource) (THIS_ IDropTarget *pDropTarget) PURE;
    STDMETHOD(GetDragPoint) (THIS_ POINT *ppt) PURE;
    STDMETHOD(GetDropPoint) (THIS_ POINT *ppt) PURE;
    STDMETHOD(MoveIcons) (THIS_ IDataObject *pDataObject) PURE;
    STDMETHOD(SetItemPos) (THIS_ LPCITEMIDLIST pidl, POINT *ppt) PURE;
    STDMETHOD(IsBkDropTarget) (THIS_ IDropTarget *pDropTarget) PURE;
    STDMETHOD(SetClipboard) (THIS_ BOOL bMove) PURE;
    STDMETHOD(SetPoints) (THIS_ IDataObject *pDataObject) PURE;
    STDMETHOD(GetItemSpacing) (THIS_ ITEMSPACING *pSpacing) PURE;
    STDMETHOD(SetCallback) (THIS_ IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB) PURE;
    STDMETHOD(Select) ( THIS_  UINT dwFlags ) PURE;
    STDMETHOD(QuerySupport) (THIS_ UINT * pdwSupport ) PURE;
    STDMETHOD(SetAutomationObject)(THIS_ IDispatch* pdisp) PURE;
} ;

// CDTURNER start
////////////////////////////////////////////////////////////////////////////////////
DECLARE_INTERFACE_( IDefViewExtInit, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewExtInit methods ***
    STDMETHOD(SetOwnerDetails)(THIS_ IShellFolder * pSF, DWORD lParam ) PURE;
};

////////////////////////////////////////////////////////////////////////////////////
DECLARE_INTERFACE_( IDefViewExtInit2, IDefViewExtInit )
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewExtInit methods ***
    STDMETHOD(SetOwnerDetails)(THIS_ IShellFolder * pSF, DWORD lParam ) PURE;

    // *** IDefViewExtInit2 methods ***
    STDMETHOD( SetViewWindowStyle )( THIS_ DWORD dwBits, DWORD dwVal) PURE;
    STDMETHOD( SetViewWindowBkImage )( THIS_ LPCWSTR pszImage) PURE;
    STDMETHOD( SetViewWindowColors )( THIS_ COLORREF clrText, COLORREF clrTextBk, COLORREF clrWindow) PURE;

    STDMETHOD( IsModal )( THIS ) PURE;

    STDMETHOD( AutoAutoArrange )( THIS_ DWORD dwReserved ) PURE;
    STDMETHOD(SetStatusText)( THIS_ LPCWSTR pwszStatusText) PURE;
};
// CDTURNER end

// SHCreateShellFolderView struct
#include <pshpack8.h>
typedef struct _SFV_CREATE
{
    UINT            cbSize;
    IShellFolder*   pshf;
    IShellView*     psvOuter;
    IShellFolderViewCB* psfvcb; // No callback if NULL
} SFV_CREATE;
#include <poppack.h>

SHSTDAPI SHCreateShellFolderView(const SFV_CREATE* pcsfv, IShellView **ppsv);
#define SHCreateShellFolderViewORD      256

SHSTDAPI_(IShellFolderViewCB*) SHGetShellFolderViewCB(HWND hwndMain);
#define SHGetShellFolderViewCBORD   257


//===========================================================================
// Defview APIs to make name space author lives somewhat easier

typedef HRESULT (CALLBACK * LPFNDFMCALLBACK)(IShellFolder *psf, HWND hwnd,
                                             IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

SHSTDAPI CDefFolderMenu_Create2(LPCITEMIDLIST pidlFolder, HWND hwnd,
                                UINT cidl, LPCITEMIDLIST *apidl,
                                IShellFolder *psf, LPFNDFMCALLBACK lpfn,
                                UINT nKeys, const HKEY *ahkeyClsKeys,
                                IContextMenu **ppcm);

SHSTDAPI_(BOOL) SHOpenPropSheetA(LPCSTR pszCaption, HKEY ahkeys[], UINT cikeys,
                                 const CLSID * pclsidDefault, IDataObject *pdtobj,
                                 IShellBrowser *psb, LPCSTR pStartPage);
SHSTDAPI_(BOOL) SHOpenPropSheetW(LPCWSTR pszCaption, HKEY ahkeys[], UINT cikeys,
                                 const CLSID * pclsidDefault, IDataObject *pdtobj,
                                 IShellBrowser *psb, LPCWSTR pStartPage);
#ifdef UNICODE
#define SHOpenPropSheet  SHOpenPropSheetW
#else
#define SHOpenPropSheet  SHOpenPropSheetA
#endif // !UNICODE


// structure for lParam of DFM_INFOKECOMMANDEX
typedef struct
{
    DWORD  cbSize;

    DWORD  fMask;   // CMIC_MASK_ values for the invoke
    LPARAM lParam;  // same as lParam of DFM_INFOKECOMMAND
    UINT idCmdFirst;
    UINT idDefMax;
    LPCMINVOKECOMMANDINFO pici; // the whole thing so you can re-invoke on a child
} DFMICS, *PDFMICS;

//                                  uMsg       wParam       lParam
#define DFM_MERGECONTEXTMENU         1      // uFlags       LPQCMINFO
#define DFM_INVOKECOMMAND            2      // idCmd        pszArgs
#define DFM_ADDREF                   3      // 0            0
#define DFM_RELEASE                  4      // 0            0
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText -Ansi
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO
#define DFM_GETHELPTEXTW             11     // idCmd,cchMax pszText -Unicode
#define DFM_INVOKECOMMANDEX          12     // idCmd        PDFMICS
#define DFM_MAPCOMMANDNAME           13     // idCmd *      pszCommandName
#define DFM_GETDEFSTATICID           14     // idCmd *      0
#define DFM_GETVERBW                 15     // idCmd,cchMax pszText -Unicode
#define DFM_GETVERBA                 16     // idCmd,cchMax pszText -Ansi


// Commands from DFM_INVOKECOMMAND when strings are passed in
#define DFM_CMD_DELETE          ((WPARAM)-1)
#define DFM_CMD_MOVE            ((WPARAM)-2)
#define DFM_CMD_COPY            ((WPARAM)-3)
#define DFM_CMD_LINK            ((WPARAM)-4)
#define DFM_CMD_PROPERTIES      ((WPARAM)-5)
#define DFM_CMD_NEWFOLDER       ((WPARAM)-6)
#define DFM_CMD_PASTE           ((WPARAM)-7)
#define DFM_CMD_VIEWLIST        ((WPARAM)-8)
#define DFM_CMD_VIEWDETAILS     ((WPARAM)-9)
#define DFM_CMD_PASTELINK       ((WPARAM)-10)
#define DFM_CMD_PASTESPECIAL    ((WPARAM)-11)
#define DFM_CMD_MODALPROP       ((WPARAM)-12)
#define DFM_CMD_RENAME          ((WPARAM)-13)

STDAPI CDefFolderMenu_Create(LPCITEMIDLIST pidlFolder,
                             HWND hwndOwner,
                             UINT cidl, LPCITEMIDLIST * apidl,
                             IShellFolder *psf,
                             LPFNDFMCALLBACK lpfn,
                             HKEY hkeyProgID, HKEY hkeyBaseProgID,
                             IContextMenu ** ppcm);



STDAPI_(void) CDefFolderMenu_MergeMenu(HINSTANCE hinst, UINT idMainMerge, UINT idPopupMerge,
        LPQCMINFO pqcm);
STDAPI_(void) Def_InitFileCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
        BOOL bContext);
STDAPI_(void) Def_InitEditCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
        IDropTarget *pdtgt, UINT fContext);

// indeces in bitmap strip
#define VIEW_MOVETO     24
#define VIEW_COPYTO     25
#define VIEW_OPTIONS    26

//===========================================================================
// Default IShellView for IShellFolder
//===========================================================================

// Menu ID's
#define SFVIDM_FIRST            (FCIDM_SHVIEWLAST-0x0fff)
#define SFVIDM_LAST             (FCIDM_SHVIEWLAST)

// Hardcoded message values => This range can be used for messages that we
// pass from shdoc401 to shell32
#define SFVIDM_HARDCODED_FIRST  (SFVIDM_LAST-0x0010)
#define SFVIDM_HARDCODED_LAST   (SFVIDM_LAST)

#define SFVIDM_MISC_SETWEBVIEW  (SFVIDM_HARDCODED_FIRST)

// Popup menu ID's used in merging menus
#define SFVIDM_MENU_ARRANGE     (SFVIDM_FIRST + 0x0001)
#define SFVIDM_MENU_VIEW        (SFVIDM_FIRST + 0x0002)
#define SFVIDM_MENU_SELECT      (SFVIDM_FIRST + 0x0003)

#define SHARED_FILE_FIRST               0x0010
#define SHARED_FILE_LINK                (SHARED_FILE_FIRST + 0x0000)
#define SHARED_FILE_DELETE              (SHARED_FILE_FIRST + 0x0001)
#define SHARED_FILE_RENAME              (SHARED_FILE_FIRST + 0x0002)
#define SHARED_FILE_PROPERTIES          (SHARED_FILE_FIRST + 0x0003)

#define SHARED_EDIT_FIRST               0x0018
#define SHARED_EDIT_CUT                 (SHARED_EDIT_FIRST + 0x0000)
#define SHARED_EDIT_COPY                (SHARED_EDIT_FIRST + 0x0001)
#define SHARED_EDIT_PASTE               (SHARED_EDIT_FIRST + 0x0002)
#define SHARED_EDIT_UNDO                (SHARED_EDIT_FIRST + 0x0003)
#define SHARED_EDIT_PASTELINK           (SHARED_EDIT_FIRST + 0x0004)
#define SHARED_EDIT_PASTESPECIAL        (SHARED_EDIT_FIRST + 0x0005)
#define SHARED_EDIT_COPYTO              (SHARED_EDIT_FIRST + 0x0006)
#define SHARED_EDIT_MOVETO              (SHARED_EDIT_FIRST + 0x0007)

#define SFVIDM_FILE_FIRST               (SFVIDM_FIRST + SHARED_FILE_FIRST)
#define SFVIDM_FILE_LINK                (SFVIDM_FIRST + SHARED_FILE_LINK)
#define SFVIDM_FILE_DELETE              (SFVIDM_FIRST + SHARED_FILE_DELETE)
#define SFVIDM_FILE_RENAME              (SFVIDM_FIRST + SHARED_FILE_RENAME)
#define SFVIDM_FILE_PROPERTIES          (SFVIDM_FIRST + SHARED_FILE_PROPERTIES)

#define SFVIDM_EDIT_FIRST               (SFVIDM_FIRST + SHARED_EDIT_FIRST)
#define SFVIDM_EDIT_CUT                 (SFVIDM_FIRST + SHARED_EDIT_CUT)
#define SFVIDM_EDIT_COPY                (SFVIDM_FIRST + SHARED_EDIT_COPY)
#define SFVIDM_EDIT_PASTE               (SFVIDM_FIRST + SHARED_EDIT_PASTE)
#define SFVIDM_EDIT_UNDO                (SFVIDM_FIRST + SHARED_EDIT_UNDO)
#define SFVIDM_EDIT_PASTELINK           (SFVIDM_FIRST + SHARED_EDIT_PASTELINK)
#define SFVIDM_EDIT_PASTESPECIAL        (SFVIDM_FIRST + SHARED_EDIT_PASTESPECIAL)
#define SFVIDM_EDIT_COPYTO              (SFVIDM_FIRST + SHARED_EDIT_COPYTO)
#define SFVIDM_EDIT_MOVETO              (SFVIDM_FIRST + SHARED_EDIT_MOVETO)

#define SFVIDM_SELECT_FIRST             (SFVIDM_FIRST + 0x0020)
#define SFVIDM_SELECT_ALL               (SFVIDM_SELECT_FIRST + 0x0001)
#define SFVIDM_SELECT_INVERT            (SFVIDM_SELECT_FIRST + 0x0002)
#define SFVIDM_DESELECT_ALL             (SFVIDM_SELECT_FIRST + 0x0003)

#define SFVIDM_VIEW_FIRST               (SFVIDM_FIRST + 0x0028)
#define SFVIDM_VIEW_ICON                (SFVIDM_VIEW_FIRST + 0x0001)
#define SFVIDM_VIEW_SMALLICON           (SFVIDM_VIEW_FIRST + 0x0002)
#define SFVIDM_VIEW_LIST                (SFVIDM_VIEW_FIRST + 0x0003)
#define SFVIDM_VIEW_DETAILS             (SFVIDM_VIEW_FIRST + 0x0004)
#define SFVIDM_VIEW_FIRSTVIEW           (SFVIDM_VIEW_ICON)
#define SFVIDM_VIEW_LASTVIEW            (SFVIDM_VIEW_DETAILS)
#define SFVIDM_VIEW_OPTIONS             (SFVIDM_VIEW_FIRST + 0x0005)
#define SFVIDM_VIEW_VIEWMENU            (SFVIDM_VIEW_FIRST + 0x0006)
#define SFVIDM_VIEW_CUSTOMWIZARD        (SFVIDM_VIEW_FIRST + 0x0007)
#define SFVIDM_VIEW_COLSETTINGS         (SFVIDM_VIEW_FIRST + 0x0008)

#define SFVIDM_VIEW_EXTFIRST            (SFVIDM_VIEW_FIRST + 0x0009)
#define SFVIDM_VIEW_EXTLAST             (SFVIDM_VIEW_EXTFIRST + 0x0017)
#define SFVIDM_VIEW_SVEXTFIRST          (SFVIDM_VIEW_EXTFIRST)
#define SFVIDM_VIEW_SVEXTLAST           (SFVIDM_VIEW_EXTFIRST + 0x000F)
#define SFVIDM_VIEW_EXTENDEDFIRST       (SFVIDM_VIEW_EXTFIRST + 0x0010)
#define SFVIDM_VIEW_EXTENDEDLAST        (SFVIDM_VIEW_EXTLAST)

#define SFVIDM_ARRANGE_FIRST            (SFVIDM_FIRST + 0x0050)
#define SFVIDM_ARRANGE_AUTO             (SFVIDM_ARRANGE_FIRST + 0x0001)
#define SFVIDM_ARRANGE_GRID             (SFVIDM_ARRANGE_FIRST + 0x0002)
#define SFVIDM_ARRANGE_DISPLAYICONS     (SFVIDM_ARRANGE_FIRST + 0x0003)

#define SFVIDM_TOOL_FIRST               (SFVIDM_FIRST + 0x0060)
#define SFVIDM_TOOL_CONNECT             (SFVIDM_TOOL_FIRST + 0x0001)
#define SFVIDM_TOOL_DISCONNECT          (SFVIDM_TOOL_FIRST + 0x0002)
#define SFVIDM_TOOL_OPTIONS             (SFVIDM_TOOL_FIRST + 0x0003)

#define SFVIDM_HELP_FIRST               (SFVIDM_FIRST + 0x0070)
#define SFVIDM_HELP_TOPIC               (SFVIDM_HELP_FIRST + 0x0001)

#define SFVIDM_MISC_FIRST               (SFVIDM_FIRST + 0x0100)
#define SFVIDM_MISC_REFRESH             (SFVIDM_MISC_FIRST + 0x0003)

// Range for the client's additional menus
#define SFVIDM_CLIENT_FIRST             (SFVIDM_FIRST + 0x0200)
#define SFVIDM_CLIENT_LAST              (SFVIDM_FIRST + 0x02ff)

#define SFVIDM_DESKTOP_FIRST            (SFVIDM_FIRST + 0x0400)
#define SFVIDM_DESKTOPHTML_CUSTOMIZE    (SFVIDM_DESKTOP_FIRST + 0x0000)
#define SFVIDM_DESKTOPHTML_NEWITEM      (SFVIDM_DESKTOP_FIRST + 0x0001)
#define SFVIDM_DESKTOPHTML_WEBCONTENT   (SFVIDM_DESKTOP_FIRST + 0x0002)
#define SFVIDM_DESKTOPHTML_ICONS        (SFVIDM_DESKTOP_FIRST + 0x0003)
#define SFVIDM_DESKTOPHTML_LOCK         (SFVIDM_DESKTOP_FIRST + 0x0004)
#define SFVIDM_DESKTOPHTML_SYNCHRONIZE  (SFVIDM_DESKTOP_FIRST + 0x0005)
#define SFVIDM_DESKTOPHTML_ADDSEPARATOR (SFVIDM_DESKTOP_FIRST + 0x0010)
// The values after ADDSEPARATOR are reserved for each item dynamically added to the menu
#define SFVIDM_DESKTOP_LAST             (SFVIDM_FIRST + 0x04ff)

#define SFVIDM_COLUMN_FIRST             (SFVIDM_FIRST + 0x0500)
#define SFVIDM_COLUMN_LAST              (SFVIDM_FIRST + 0x05ff)


// Range for context menu id's
#define SFVIDM_CONTEXT_FIRST            (SFVIDM_FIRST + 0x0800)
#define SFVIDM_CONTEXT_LAST             (SFVIDM_FIRST + 0x0900)
#define SFVIDM_BACK_CONTEXT_FIRST       (SFVIDM_FIRST + 0x0901)
#define SFVIDM_BACK_CONTEXT_LAST        (SFVIDM_FIRST + 0x09ff)



typedef TBINFO * LPTBINFO;

typedef COPYHOOKINFO *LPCOPYHOOKINFO;

typedef DETAILSINFO *PDETAILSINFO;

//                              uMsg                     wParam         lParam
#define DVM_MERGEMENU           SFVM_MERGEMENU        // uFlags             LPQCMINFO
#define DVM_INVOKECOMMAND       SFVM_INVOKECOMMAND    // idCmd              0
#define DVM_GETHELPTEXT         SFVM_GETHELPTEXT      // idCmd,cchMax       pszText - Ansi
#define DVM_GETTOOLTIPTEXT      SFVM_GETTOOLTIPTEXT   // idCmd,cchMax       pszText
#define DVM_GETBUTTONINFO       SFVM_GETBUTTONINFO    // 0                  LPTBINFO
#define DVM_GETBUTTONS          SFVM_GETBUTTONS       // idCmdFirst,cbtnMax LPTBBUTTON
#define DVM_INITMENUPOPUP       SFVM_INITMENUPOPUP    // idCmdFirst,nIndex  hmenu
#define DVM_SELCHANGE           SFVM_SELCHANGE        // idCmdFirst,nItem   PDVSELCHANGEINFO
#define DVM_DRAWITEM            SFVM_DRAWITEM         // idCmdFirst         pdis
#define DVM_MEASUREITEM         SFVM_MEASUREITEM      // idCmdFirst         pmis
#define DVM_EXITMENULOOP        SFVM_EXITMENULOOP     // -                  -
#define DVM_RELEASE             SFVM_PRERELEASE       // -                  lSelChangeInfo (ShellFolder private)
#define DVM_GETCCHMAX           SFVM_GETCCHMAX        // pidlItem           pcchMax
#define DVM_FSNOTIFY            SFVM_FSNOTIFY         // LPITEMIDLIST*      lEvent
#define DVM_WINDOWCREATED       SFVM_WINDOWCREATED    // hwnd               PDVSELCHANGEINFO
#define DVM_WINDOWDESTROY       SFVM_WINDOWDESTROY    // hwnd               PDVSELCHANGEINFO
#define DVM_REFRESH             SFVM_REFRESH          // -                  lSelChangeInfo
#define DVM_SETFOCUS            SFVM_SETFOCUS         // -                  lSelChangeInfo
#define DVM_KILLFOCUS           19                    // unused
#define DVM_QUERYCOPYHOOK       SFVM_QUERYCOPYHOOK    // -                  -
#define DVM_NOTIFYCOPYHOOK      SFVM_NOTIFYCOPYHOOK   // -                  LPCOPYHOOKINFO
#define DVM_NOTIFY              SFVM_NOTIFY           // idFrom             LPNOTIFY
#define DVM_GETDETAILSOF        SFVM_GETDETAILSOF     // iColumn            PDETAILSINFO
#define DVM_COLUMNCLICK         SFVM_COLUMNCLICK      // iColumn            -
#define DVM_QUERYFSNOTIFY       SFVM_QUERYFSNOTIFY    // -                  FSNotifyEntry *
#define DVM_DEFITEMCOUNT        SFVM_DEFITEMCOUNT     // -                  PINT
#define DVM_DEFVIEWMODE         SFVM_DEFVIEWMODE      // -                  PFOLDERVIEWMODE
#define DVM_UNMERGEMENU         SFVM_UNMERGEMENU      // uFlags
#define DVM_INSERTITEM          SFVM_INSERTITEM       // pidl               PDVSELCHANGEINFO
#define DVM_DELETEITEM          SFVM_DELETEITEM       // pidl               PDVSELCHANGEINFO
#define DVM_UPDATESTATUSBAR     SFVM_UPDATESTATUSBAR  // -                  lSelChangeInfo
#define DVM_BACKGROUNDENUM      SFVM_BACKGROUNDENUM   //
#define DVM_GETWORKINGDIR       SFVM_GETWORKINGDIR    //
#define DVM_GETCOLSAVESTREAM    SFVM_GETCOLSAVESTREAM // flags              IStream **
#define DVM_SELECTALL           SFVM_SELECTALL        //                    lSelChangeInfo
#define DVM_DIDDRAGDROP         SFVM_DIDDRAGDROP      // dwEffect           IDataObject *
#define DVM_SUPPORTSIDENTIFY    SFVM_SUPPORTSIDENTITY // -                  -
#define DVM_FOLDERISPARENT      SFVM_FOLDERISPARENT   // -                  pidlChild

// max length for guid strings
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

typedef struct _DVSELCHANGEINFO {
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
    LPARAM* plParam;
} DVSELCHANGEINFO, *PDVSELCHANGEINFO;

typedef HRESULT (CALLBACK * LPFNVIEWCALLBACK)(IShellView *psvOuter,
                                                IShellFolder *psf,
                                                HWND hwndMain,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

// SHCreateShellFolderViewEx struct
typedef struct _CSFV
{
    UINT            cbSize;
    IShellFolder *  pshf;
    IShellView *    psvOuter;
    LPCITEMIDLIST   pidl;
    LONG            lEvents;
    LPFNVIEWCALLBACK pfnCallback;       // No callback if NULL
    FOLDERVIEWMODE  fvm;
} CSFV, * LPCSFV;

// Tell the FolderView to rearrange.  The lParam will be passed to
// IShellFolder::CompareIDs
#define SFVM_REARRANGE          0x00000001
#define ShellFolderView_ReArrange(_hwnd, _lparam) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_REARRANGE, _lparam)

// Get the last sorting parameter given to FolderView
#define SFVM_GETARRANGEPARAM    0x00000002
#define ShellFolderView_GetArrangeParam(_hwnd) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETARRANGEPARAM, 0L)

// Add an OBJECT into the view (May need to add insert also)
#define SFVM_ADDOBJECT         0x00000003
#define ShellFolderView_AddObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_ADDOBJECT, (LPARAM)_pidl)

// Gets the count of objects in the view
#define SFVM_GETOBJECTCOUNT         0x00000004
#define ShellFolderView_GetObjectCount(_hwnd) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECTCOUNT, (LPARAM)0)

// Returns a pointer to the Idlist associated with the specified index
// Returns NULL if at end of list.
#define SFVM_GETOBJECT         0x00000005
#define ShellFolderView_GetObject(_hwnd, _iObject) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECT, _iObject)

// Remove an OBJECT into the view (This works by pidl, may need index also);
#define SFVM_REMOVEOBJECT         0x00000006
#define ShellFolderView_RemoveObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REMOVEOBJECT, (LPARAM)_pidl)

// updates an object by passing in pointer to two PIDLS, the first
// is the old pidl, the second one is the one with update information.
//
// _ppidl[1] must be a *copy* of a pidl, as control over the lifetime
// of the pidl belongs to the view after successful completion of
// this call.  (Unsuccessful completion (a -1 return) implies failure
// and the caller must free the memory.)  Win95 waits a while before
// freeing the pidl, IE4 frees the pidl immediately.
// IShellFolderView::UpdateObject does not suffer from this problem.
//
#define SFVM_UPDATEOBJECT         0x00000007
#define ShellFolderView_UpdateObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_UPDATEOBJECT, (LPARAM)_ppidl)

// Sets the redraw mode for the window that is displaying the information
#define SFVM_SETREDRAW           0x00000008
#define ShellFolderView_SetRedraw(_hwnd, fRedraw) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_SETREDRAW, (LPARAM)fRedraw)

// Returns an array of the selected IDS to the caller.
//     lparam is a pointer to receive the idlists into
//     return value is the count of items in the array.
#define SFVM_GETSELECTEDOBJECTS 0x00000009
#define ShellFolderView_GetSelectedObjects(_hwnd, ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDOBJECTS, (LPARAM)ppidl)

// Checks if the current drop is on the view window
//     lparam is unused
//     return value is TRUE if the current drop is upon the background of the
//         view window, FALSE otherwise
#define SFVM_ISDROPONSOURCE     0x0000000a
#define ShellFolderView_IsDropOnSource(_hwnd, _pdtgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISDROPONSOURCE, (LPARAM)_pdtgt)

// Moves the selected icons in the listview
//     lparam is a pointer to a drop target
//     return value is unused
#define SFVM_MOVEICONS          0x0000000b
#define ShellFolderView_MoveIcons(_hwnd, _pdt) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_MOVEICONS, (LPARAM)(LPDROPTARGET)_pdt)

// Gets the start point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDRAGPOINT       0x0000000c
#define ShellFolderView_GetDragPoint(_hwnd, _ppt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETDRAGPOINT, (LPARAM)(LPPOINT)_ppt)

// Gets the end point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDROPPOINT       0x0000000d
#define ShellFolderView_GetDropPoint(_hwnd, _ppt) \
        SHShellFolderView_Message(_hwnd, SFVM_GETDROPPOINT, (LPARAM)(LPPOINT)_ppt)

#define ShellFolderView_GetAnchorPoint(_hwnd, _fStart, _ppt) \
        (BOOL)((_fStart) ? ShellFolderView_GetDragPoint(_hwnd, _ppt) : ShellFolderView_GetDropPoint(_hwnd, _ppt))

typedef struct _SFV_SETITEMPOS
{
        LPCITEMIDLIST pidl;
        POINT pt;
} SFV_SETITEMPOS, *LPSFV_SETITEMPOS;

// Sets the position of an item in the viewer
//     lparam is a pointer to a SVF_SETITEMPOS
//     return value is unused
#define SFVM_SETITEMPOS         0x0000000e
#define ShellFolderView_SetItemPos(_hwnd, _pidl, _x, _y) \
{       SFV_SETITEMPOS _sip = {_pidl, {_x, _y}}; \
        SHShellFolderView_Message(_hwnd, SFVM_SETITEMPOS, (LPARAM)(LPSFV_SETITEMPOS)&_sip);}

// Determines if a given drop target interface is the one being used for
// the background of the ShellFolderView (as opposed to an object in the
// view)
//     lparam is a pointer to a drop target interface
//     return value is TRUE if it is the background drop target, FALSE otherwise
#define SFVM_ISBKDROPTARGET     0x0000000f
#define ShellFolderView_IsBkDropTarget(_hwnd, _pdptgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISBKDROPTARGET, (LPARAM)(LPDROPTARGET)_pdptgt)

//  Notifies a ShellView when one of its objects get put on the clipboard
//  as a result of a menu command.
//
//  called by defcm.c when it does a copy/cut
//
//     lparam is the dwEffect (DROPEFFECT_MOVE, DROPEFFECT_COPY)
//     return value is void.
#define SFVM_SETCLIPBOARD       0x00000010
#define ShellFolderView_SetClipboard(_hwnd, _dwEffect) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETCLIPBOARD, (LPARAM)(DWORD)(_dwEffect))


// sets auto arrange
#define SFVM_AUTOARRANGE        0x00000011
#define ShellFolderView_AutoArrange(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_AUTOARRANGE, 0)

// sets snap to grid
#define SFVM_ARRANGEGRID        0x00000012
#define ShellFolderView_ArrangeGrid(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_ARRANGEGRID, 0)

#define SFVM_GETAUTOARRANGE     0x00000013
#define ShellFolderView_GetAutoArrange(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETAUTOARRANGE, 0)

#define SFVM_GETSELECTEDCOUNT     0x00000014
#define ShellFolderView_GetSelectedCount(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDCOUNT, 0)

typedef ITEMSPACING *LPITEMSPACING;

#define SFVM_GETITEMSPACING     0x00000015
#define ShellFolderView_GetItemSpacing(_hwnd, lpis) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETITEMSPACING, (LPARAM)lpis)

// Causes an object to be repainted
#define SFVM_REFRESHOBJECT      0x00000016
#define ShellFolderView_RefreshObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REFRESHOBJECT, (LPARAM)_ppidl)

// Causes the the whole view to be refreshed
#define ShellFolderView_RefreshAll(_hwnd) \
        (LPARAM)PostMessage(_hwnd, WM_KEYDOWN, (WPARAM)VK_F5, (LPARAM)0);

#define SFVM_SETPOINTS           0x00000017
#define ShellFolderView_SetPoints(_hwnd, _pdtobj) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETPOINTS, (LPARAM)_pdtobj)

// SVM_SELECTANDPOSITIONITEM lParam
typedef struct
{
        LPCITEMIDLIST pidl;     // relative pidl to the view
        UINT  uSelectFlags;     // select flags
        BOOL fMove; // if true, we should also move it to point pt
        POINT pt;
} SFM_SAP;

// shell view messages
#define SVM_SELECTITEM                  (WM_USER + 1)
#define SVM_MOVESELECTEDITEMS           (WM_USER + 2)
#define SVM_GETANCHORPOINT              (WM_USER + 3)
#define SVM_GETITEMPOSITION             (WM_USER + 4)
#define SVM_SELECTANDPOSITIONITEM       (WM_USER + 5)

//===========================================================================
// CDefShellFolder members (for easy subclassing)
//===========================================================================

// Default implementation (no dependencies to the instance data)
STDMETHODIMP CDefShellFolder_QueryInterface(IShellFolder *psf, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_BindToStorage(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_BindToObject(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_GetAttributesOf(IShellFolder *psf, UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfOut);
STDMETHODIMP CDefShellFolder_SetNameOf(IShellFolder *psf, HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD dwReserved, LPITEMIDLIST * ppidlOut);

// File Search APIS
SHSTDAPI_(IContextMenu *) SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, UINT idCmdFirst, UINT idCmdLast);

SHSTDAPI_(void) Control_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);
SHSTDAPI_(void) Control_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow);
SHSTDAPI_(void) Control_RunDLLAsUserW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow);


// to add 16 bit pages to 32bit things.  hGlobal can be NULL
SHSTDAPI_(UINT) SHAddPages16(HGLOBAL hGlobal, LPCTSTR pszDllEntry, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

SHSTDAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, IShellView ** ppsv);


// Access to MSHMTL's ditherer

/* Definition of interface: IIntDitherer */
#undef INTERFACE
#define INTERFACE IIntDitherer

DECLARE_INTERFACE_(IIntDitherer, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    // *** IIntDitherer methods ***
    STDMETHOD(DitherTo8bpp)(THIS_ BYTE * pDestBits, LONG nDestPitch,
                    BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc,
                    RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                    BYTE * pbDestInvMap,
                    LONG x, LONG y, LONG cx, LONG cy,
                    LONG lDestTrans, LONG lSrcTrans) PURE;
};

#ifdef COBJMACROS


#define IntDitherer_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IntDitherer_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IntDitherer_Release(This)   \
    (This)->lpVtbl -> Release(This)

#define IntDitherer_DitherTo8bpp(This, pDestBits, nDestPitch, \
                    pSrcBits, nSrcPitch, bfidSrc, \
                    prgbDestColors, prgbSrcColors, \
                    pbDestInvMap, x, y, cx, cy, \
                    lDestTrans, lSrcTrans)  \
    (This)->lpVtbl -> DitherTo8bpp(This, pDestBits, nDestPitch, pSrcBits, nSrcPitch, bfidSrc, \
                    prgbDestColors, prgbSrcColors, pbDestInvMap, x, y, cx, cy, lDestTrans, lSrcTrans)

#endif

//      PID_IS_SCHEME       [VT_UI4]      Scheme value
#define PID_IS_FIRST         2
#define PID_IS_SCHEME        3
#define PID_IS_IDLIST        14
#define PID_IS_LAST          14
//      PID_INTSITE_FLAGS        [VT_UI4]      PIDISF_ flags
//      PID_INTSITE_CONTENTLEN   [VT_UI4]      Content length
//      PID_INTSITE_CONTENTCODE  [VT_UI8]      Content code
//      PID_INTSITE_FRAGMENT     [VT_NULL]     Fragments
#define PID_INTSITE_FIRST         2
#define PID_INTSITE_FRAGMENT      17
#define PID_INTSITE_LAST          21
  //Is URL entered in IE history bucket?
#define PIDISF_HISTORY          0x10000000
// Athena needs this to determine whether to double click or not.
//
// NOTE: if user uninstalls IE4, the Win95 code will
// realize that the size has changed (even though it's not
// in this struct, it is saved) and drop back to default state.
//
// Since we're exporting this so ISVs can get access to our flags,
// let's avoid the need for a thunk and export the beginning section
// of this structure ONLY. Here are the A and W versions for internal use:
//
typedef struct {
    // These were in Win95 //
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;

    // The below were added for IE4 //
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1; // No longer used, dead bit
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;

    // These were in Win95 Gold
    LPSTR pszHiddenFileExts;
    UINT cbHiddenFileExts;

    // These must have been an OSR release, as they aren't on \\guilo\slmadd\src\dev\inc16\shsemip.h
    LPARAM lParamSort;
    int    iSortDirection;

    // This was added for IE4
    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;
    // If you need a new flag, steal a bit from from fSpareFlags.
    UINT fSpareFlags : 15;

    //
    // If you add any fields to this structure, you
    // must also add upgrade code to shell32\util.cpp.
    //
} SHELLSTATEA, * LPSHELLSTATEA;

typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;

    LPWSTR pszHiddenFileExts;
    UINT   cbHiddenFileExts;

    LPARAM lParamSort;
    int    iSortDirection;
    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;
    // If you need a new flag, steal a bit from from fSpareFlags.
    UINT fSpareFlags : 15;

    //
    // If you add any fields to this structure, you
    // must also add upgrade code to shell32\util.cpp.
    //
} SHELLSTATEW, * LPSHELLSTATEW;

#define SHELLSTATEVERSION_IE4 9
#define SHELLSTATEVERSION 10 // rev if defaults change but size doesn't //

#ifdef UNICODE
#define SHELLSTATE   SHELLSTATEW
#define LPSHELLSTATE LPSHELLSTATEW
#else
#define SHELLSTATE   SHELLSTATEA
#define LPSHELLSTATE LPSHELLSTATEA
#endif

#define SHELLSTATE_SIZE_WIN95 FIELD_OFFSET(SHELLSTATE,lParamSort)
#define SHELLSTATE_SIZE_NT4   FIELD_OFFSET(SHELLSTATE,version)
#define SHELLSTATE_SIZE_IE4   FIELD_OFFSET(SHELLSTATE,uNotUsed)
#define SHELLSTATE_SIZE_WIN2K sizeof(SHELLSTATE)

SHSTDAPI_(void) SHGetSetSettings(LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet);

// And here's the beginning portion for public use:
#define SSF_HIDDENFILEEXTS          0x00000004  //
#define SSF_SORTCOLUMNS             0x00000010  //
#define SSF_FILTER                  0x00010000  //
#define SSF_WEBVIEW                 0x00020000  //
#define SSF_SHOWSUPERHIDDEN         0x00040000  //
#define SSF_SEPPROCESS              0x00080000  //

//--------------------------------------------------------------------------
//
// Interface used for exposing the INI file methods on a shortcut file
//
//
//--------------------------------------------------------------------------
#undef  INTERFACE
#define INTERFACE  INamedPropertyBag
DECLARE_INTERFACE_(INamedPropertyBag, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;
    // *** INamedPropertyBag methods ***
    STDMETHOD(ReadPropertyNPB) (THIS_  /* [in] */ LPCOLESTR pszBagname,
                            /* [in] */ LPCOLESTR pszPropName,
                            /* [out][in] */ PROPVARIANT *pVar) PURE;

    STDMETHOD(WritePropertyNPB)(THIS_ /* [in] */ LPCOLESTR pszBagname,
                           /* [in] */ LPCOLESTR pszPropName,
                           /* [in] */ PROPVARIANT  *pVar) PURE;

    STDMETHOD(RemovePropertyNPB)(THIS_ /* [in] */ LPCOLESTR pszBagname,
                          /* [in] */ LPCOLESTR pszPropName) PURE;
};
//-------------------------------------------------------------------------
//
// IShellMenuCallback interface
//
//
// [Member functions]
//
//  TBD
//
//-------------------------------------------------------------------------

#ifndef RC_INVOKED
#include <pshpack8.h>   /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

typedef struct _tagSMDATA
{
    DWORD   dwMask;             // SMDM_* values
    DWORD   dwFlags;            // Not used
    HMENU   hmenu;              // Static HMENU portion.
    HWND    hwnd;               // HWND owning the HMENU
    UINT    uId;                // Id of the item in the menu (-1 for menu itself)
    UINT    uIdParent;          // Id of the item spawning this menu
    UINT    uIdAncestor;        // Id of the very top item in the chain of ShellFolders
    IUnknown*    punk;          // IUnkown of the menuband
    LPITEMIDLIST   pidlFolder;  // pidl of the ShellFolder portion
    LPITEMIDLIST   pidlItem;    // pidl of the item in the ShellFolder portion
    IShellFolder*   psf;        // IShellFolder for the shell folder portion

    void*   pvUserData;         // User defined Data associated with a pane.

} SMDATA, *LPSMDATA;

#ifndef RC_INVOKED
#include <poppack.h>   /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

// Mask
#define SMDM_SHELLFOLDER               0x00000001  // This is for an item in the band
#define SMDM_HMENU                     0x00000002  // This is for the Band itself

// Flags (bitmask)
typedef struct
{
    DWORD   dwMask;     // SMIM_*
    DWORD   dwType;     // SMIT_*
    DWORD   dwFlags;    // SMIF_*
    int     iIcon;
} SMINFO, * PSMINFO;

typedef struct
{
    LONG            lEvent;     // Change notify Event
    LPCITEMIDLIST   pidl1;      // Pidl 1 Passed in from the Change notify
    LPCITEMIDLIST   pidl2;      // Pidl 2 Passed in from the Change notify
} SMCSHCHANGENOTIFYSTRUCT, *PSMCSHCHANGENOTIFYSTRUCT;

// Mask flags
enum
{
    SMIM_TYPE           = 0x00000001,
    SMIM_FLAGS          = 0x00000002,
    SMIM_ICON           = 0x00000004
};

// Types for mbiinfo.dwType
enum
{
    SMIT_SEPARATOR      = 0x00000001,
    SMIT_STRING         = 0x00000002
};

// Flags for mbiinfo.dwFlags
enum
{
    SMIF_ICON           = 0x00000001,       // Show an icon
    SMIF_ACCELERATOR    = 0x00000002,       // Underline the character marked w/ '&'
    SMIF_DROPTARGET     = 0x00000004,       // Item is a drop target
    SMIF_SUBMENU        = 0x00000008,       // Item has a submenu
    SMIF_VOLATILE       = 0x00000010,       // Obsolete.
    SMIF_CHECKED        = 0x00000020,       // Item has a Checkmark
    SMIF_DROPCASCADE    = 0x00000040,       // Item can cascade out during drag/drop
    SMIF_HIDDEN         = 0x00000080,       // Don't display item
    SMIF_DISABLED       = 0x00000100,       // Should be unselectable. Grey.
    SMIF_TRACKPOPUP     = 0x00000200,       // Should be unselectable. Grey.
    SMIF_DEMOTED        = 0x00000400,       // Display item in "Demoted" state.
    SMIF_ALTSTATE       = 0x00000800,       // Displayed in "Altered State"
};

// Messages
//
//  SMC_INITMENU        Sent when a menu is shown.
//
//
//  SMC_GETOBJECT
//    wParam = riid
//    lParam = ppv
//      Sent to get an object that supports riid.
//
#define SMC_INITMENU            0x00000001  // The callback is called to init a menuband
#define SMC_CREATE              0x00000002
#define SMC_EXITMENU            0x00000003  // The callback is called when menu is collapsing
#define SMC_EXEC                0x00000004  // The callback is called to execute an item
#define SMC_GETINFO             0x00000005  // The callback is called to return DWORD values
#define SMC_GETSFINFO           0x00000006  // The callback is called to return DWORD values
#define SMC_GETOBJECT           0x00000007  // The callback is called to get some object
#define SMC_GETSFOBJECT         0x00000008  // The callback is called to get some object
#define SMC_SFEXEC              0x00000009  // The callback is called to execute an shell folder item
#define SMC_SFSELECTITEM        0x0000000A  // The callback is called when an item is selected
#define SMC_SELECTITEM          0x0000000B  // The callback is called when an item is selected
#define SMC_GETSFINFOTIP        0x0000000C  // The callback is called to get some object
#define SMC_GETINFOTIP          0x0000000D  // The callback is called to get some object
#define SMC_INSERTINDEX         0x0000000E  // New item insert index
#define SMC_POPUP               0x0000000F  // InitMenu/InitMenuPopup (sort of)
#define SMC_REFRESH             0x00000010  // Menus have completely refreshed. Reset your state.
#define SMC_DEMOTE              0x00000011  // Demote an item
#define SMC_PROMOTE             0x00000012  // Promote an item
#define SMC_BEGINENUM           0x00000013  // tell callback that we are beginning to ENUM the indicated parent
#define SMC_ENDENUM             0x00000014  // tell callback that we are ending the ENUM of the indicated paren
#define SMC_MAPACCELERATOR      0x00000015  // Called when processing an accelerator.
#define SMC_DEFAULTICON         0x00000016  // Returns Default icon location in wParam, index in lParam
#define SMC_NEWITEM             0x00000017  // Notifies item is not in the order stream.
#define SMC_GETMINPROMOTED      0x00000018  // Returns the minimum number of promoted items
#define SMC_CHEVRONEXPAND       0x00000019  // Notifies of a expansion via the chevron
#define SMC_DISPLAYCHEVRONTIP   0x0000002A  // S_OK display, S_FALSE not.
#define SMC_DESTROY             0x0000002B  // Called when a pane is being destroyed.
#define SMC_SETOBJECT           0x0000002C  // Called to save the passed object
#define SMC_SETSFOBJECT         0x0000002D  // Called to save the passed object
#define SMC_SHCHANGENOTIFY      0x0000002E	// Called when a Change notify is received. lParam points to SMCSHCHANGENOTIFYSTRUCT
#define SMC_CHEVRONGETTIP       0x0000002F  // Called to get the chevron tip text. wParam = Tip title, Lparam = TipText Both MAX_PATH
#define SMC_SFDDRESTRICTED      0x00000030  // Called requesting if it's ok to drop. wParam = IDropTarget.
#define SMC_FILTERPIDL          0x10000000  // The callback is called to see if an item is visible
#define SMC_CALLBACKMASK        0xF0000000  // Mask of comutationally intense messages


#undef  INTERFACE
#define INTERFACE   IShellMenuCallback

DECLARE_INTERFACE_(IShellMenuCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMenuCallback methods ***
    STDMETHOD(CallbackSM)         (THIS_ LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
};

//-------------------------------------------------------------------------
//
// IMenuBand interface
//
//   This interface provides methods the menuband (CLSID_MenuBand)
//  to receive pertinent messages.
//
// [Member functions]
//
// IMenuBand::IsMenuMessage(pmsg)
//   A message pump calls this function to see if any messages need
//   to be redirected to this object.  If this returns S_OK, the
//   message loop should not call TranslateMessage or DispatchMessage.
//   If this returns E_FAIL, the menu has exited menu mode and is ready
//   to be destroyed.
//
// IMenuBand::TranslateMenuMessage(pmsg, plRet)
//   Offers the object an opportunity to translate messages.  The
//   parent window proc must call this method for every message (not
//   the message pump).  The message, wParam, and lParam should be
//   delivered to this method in *pmsg.  This method may change the
//   values of pmsg->wParam or pmsg->lParam, in which case these changes
//   should be forwarded on.
//
//   This method is required because some modal message pumps (like the one
//   in TrackPopupMenu) do not give an opportunity to call a custom
//   TranslateAccelerator method like IInputObject::TranslateAcceleratorIO.
//
//   TranslateMenuMessage returns S_OK if the message was handled and
//   should be eaten.  *plRet is not touched if this returns S_FALSE.
//
//
//-------------------------------------------------------------------------

// CmdIDs for the IOleCommandTarget Group: CGID_MenuBandHandler (defined in shguidp.h)
#define MBHANDCID_PIDLSELECT    0           // A PIDL from a menuband was selected

#undef  INTERFACE
#define INTERFACE   IMenuBand

DECLARE_INTERFACE_(IMenuBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IMenuBand methods ***
    STDMETHOD(IsMenuMessage)    (THIS_ MSG * pmsg) PURE;
    STDMETHOD(TranslateMenuMessage) (THIS_ MSG * pmsg, LRESULT * plRet) PURE;
};



//-------------------------------------------------------------------------
//
// IShellMenu interface
//
//-------------------------------------------------------------------------

#define SMINIT_DEFAULT              0x00000000  // No Options
#define SMINIT_RESTRICT_CONTEXTMENU 0x00000001  // Don't allow Context Menus
#define SMINIT_RESTRICT_DRAGDROP    0x00000002  // Don't allow Drag and Drop
#define SMINIT_TOPLEVEL             0x00000004  // This is the top band.
#define SMINIT_DEFAULTTOTRACKPOPUP  0x00000008  // When no callback is specified,
                                                // default all HMENU items to Trackpopup
#define SMINIT_CACHED               0x00000010
#define SMINIT_USEMESSAGEFILTER     0x00000020
#define SMINIT_LEGACYMENU           0x00000040  // Old Menu behaviour.

// Internal Menuband setting
#define SMINIT_NOSETSITE            0x00010000  // Internal setting

// These are mutually Exclusive
#define SMINIT_VERTICAL             0x10000000  // This is a vertical menu
#define SMINIT_HORIZONTAL           0x20000000  // This is a horizontal menu    (does not inherit)
#define SMINIT_MULTICOLUMN          0x40000000  // this is a multi column menu

#define ANCESTORDEFAULT      (UINT)-1

#define SMSET_TOP                   0x10000000    // Bias this namespace to the top of the menu
#define SMSET_BOTTOM                0x20000000    // Bias this namespace to the bottom of the menu
#define SMSET_DONTOWN               0x00000001    // The Menuband doesn't own the non-ref counted object
                                                  // and should not destroy it.
#define SMSET_MERGE                 0x00000002
#define SMSET_NOEMPTY               0x00000004   // Dont show (Empty) on shell folder
#define SMSET_USEBKICONEXTRACTION   0x00000008   // Use the background icon extractor
#define SMSET_HASEXPANDABLEFOLDERS  0x00000010   // Need to call SHIsExpandableFolder
#define SMSET_DONTREGISTERCHANGENOTIFY 0x00000020 // ShellFolder is a discontiguous child of a parent shell folder
#define SMSET_COLLAPSEONEMPTY       0x00000040   // When Empty, causes a menus to collapse

#define SMINV_REFRESH        0x00000001
#define SMINV_ICON           0x00000002
#define SMINV_POSITION       0x00000004
#define SMINV_ID             0x00000008
#define SMINV_NEXTSHOW       0x00000010       // Does Invalidates on next show.
#define SMINV_PROMOTE        0x00000020       // Does Invalidates on next show.
#define SMINV_DEMOTE         0x00000040       // Does Invalidates on next show.
#define SMINV_FORCE          0x00000080
#define SMINV_NOCALLBACK     0x00000100       // Invalidates, but does not call the callback.

#undef  INTERFACE
#define INTERFACE   IShellMenu

DECLARE_INTERFACE_(IShellMenu, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMenu methods ***
    STDMETHOD(Initialize)(THIS_ IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags) PURE;
    STDMETHOD(GetMenuInfo)(THIS_ IShellMenuCallback** ppsmc, UINT* puId, UINT* puIdAncestor, DWORD* pdwFlags) PURE;
    STDMETHOD(SetShellFolder)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hKey, DWORD dwFlags) PURE;
    STDMETHOD(GetShellFolder)(THIS_ DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppv) PURE;
    STDMETHOD(SetMenu)(THIS_ HMENU hmenu, HWND hwnd, DWORD dwFlags) PURE;
    STDMETHOD(GetMenu)(THIS_ HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags) PURE;
    STDMETHOD(InvalidateItem)(THIS_ LPSMDATA psmd, DWORD dwFlags) PURE;
    STDMETHOD(GetState)(THIS_ LPSMDATA psmd) PURE;
    STDMETHOD(SetMenuToolbar)(THIS_ IUnknown* punk, DWORD dwFlags) PURE;
};



#undef  INTERFACE
#define INTERFACE   ITrackShellMenu

DECLARE_INTERFACE_(ITrackShellMenu, IShellMenu)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMenu methods ***
    STDMETHOD(Initialize)(THIS_ IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags) PURE;
    STDMETHOD(GetMenuInfo)(THIS_ IShellMenuCallback** ppsmc, UINT* puId, UINT* puIdAncestor, DWORD* pdwFlags) PURE;
    STDMETHOD(SetShellFolder)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hKey, DWORD dwFlags) PURE;
    STDMETHOD(GetShellFolder)(THIS_ DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppv) PURE;
    STDMETHOD(SetMenu)(THIS_ HMENU hmenu, HWND hwnd, DWORD dwFlags) PURE;
    STDMETHOD(GetMenu)(THIS_ HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags) PURE;
    STDMETHOD(InvalidateItem)(THIS_ LPSMDATA psmd, DWORD dwFlags) PURE;
    STDMETHOD(GetState)(THIS_ LPSMDATA psmd) PURE;
    STDMETHOD(SetMenuToolbar)(THIS_ IUnknown* punk, DWORD dwFlags) PURE;

    // *** ITrackShellMenu methods ***
    STDMETHOD(SetObscured)(THIS_ HWND hwndTB, IUnknown* punkBand, DWORD dwSMSetFlags) PURE;
    STDMETHOD(Popup)(THIS_ HWND hwnd, POINTL *ppt, RECTL *prcExclude, DWORD dwFlags) PURE;
};

//-------------------------------------------------------------------------
//
// IMenuPopup interface
//
//   This interface provides methods to navigate thru a menu.
//
// [Member functions]
//
// IMenuPopup::Popup(ppt, prcExclude, dwFlags)
//   Invoke the menu, located at the point *ppt (in screen coordinates).
//   The optional prcExclude points to the rectangle to exclude when
//   positioning the menu, otherwise it should be NULL.  dwFlags may be:
//
//      MDBPU_SETFOCUS: the menu can take the focus.
//
//   Returns S_OK if the object implements the popup menu as a modeless
//   menu.  Otherwise it returns S_FALSE, and the menu is finished.
//
// IMenuPopup::OnSelect(dwSelectType)
//   This method handles selection notifications.
//
// IMenuPopup::SetSubMenu(pmp, fSet)
//   Sets the given menu bar interface to be the submenu of this
//   object's interface.  Set fSet == FALSE to remove the submenu.
//
//-------------------------------------------------------------------------

// Type values for IMenuPopup::OnSelect
enum
{
    MPOS_EXECUTE = 0,           // Execute the selected menu item
    MPOS_FULLCANCEL,            // Cancel the entire menu
    MPOS_CANCELLEVEL,           // Cancel the current cascaded menu
    MPOS_SELECTLEFT,            // select one to the left of the cur selection
    MPOS_SELECTRIGHT,           // select one to the right of the cur selection
    MPOS_CHILDTRACKING          // the child got a tracking select (mouse moved over)
};

// Flags for IMenuPopup::Popup
enum
{
    MPPF_SETFOCUS       = 0x00000001,    // Menu can take the focus
    MPPF_INITIALSELECT  = 0x00000002,    // Select the first item
    MPPF_NOANIMATE      = 0x00000004,    // Do not animate this show
    MPPF_KEYBOARD       = 0x00000010,    // The menu is activated by keyboard
    MPPF_REPOSITION     = 0x00000020,    // Resposition the displayed bar.
    MPPF_FORCEZORDER    = 0x00000040,    // internal: Tells menubar to ignore Submenu positions
    MPPF_FINALSELECT    = 0x00000080,    // Select the last item
    MPPF_TOP            = 0x20000000,    // Popup menu up from point
    MPPF_LEFT           = 0x40000000,    // Popup menu left from point
    MPPF_RIGHT          = 0x60000000,    // Popup menu right from point
    MPPF_BOTTOM         = 0x80000000,    // Popup menu below point
    MPPF_POS_MASK       = 0xE0000000     // Menu Position Mask
};

#if (_WIN32_IE) >= 0x0400
#undef  INTERFACE
#define INTERFACE   IMenuPopup

DECLARE_INTERFACE_(IMenuPopup, IDeskBar)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow)        (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetClient)        (THIS_ IUnknown* punkClient) PURE;
    STDMETHOD(GetClient)        (THIS_ IUnknown** ppunkClient) PURE;
    STDMETHOD(OnPosRectChangeDB)(THIS_ LPRECT prc) PURE;

    // *** IMenuPopup methods ***
    STDMETHOD(Popup)            (THIS_ POINTL *ppt, RECTL *prcExclude, DWORD dwFlags) PURE;
    STDMETHOD(OnSelect)         (THIS_ DWORD dwSelectType) PURE;
    STDMETHOD(SetSubMenu)       (THIS_ IMenuPopup* pmp, BOOL fSet) PURE;
};
#endif


//
// Net Access Wizard - called from NetID and WinLogon.
//

#define NAW_NETID              0x00          // called from netid tab
#define NAW_PSWORKGROUP        0x01          // post setup (joined workgroup)
#define NAW_PSDOMAINJOINED     0x02          // post setup (joined domain)
#define NAW_PSDOMAINJOINFAILED 0x03          // post setup (domain joined failed)

STDAPI NetAccessWizard(HWND hwnd, UINT uType, BOOL *pfReboot);
typedef HRESULT (CALLBACK *LPNETACCESSWIZARD)(HWND hwnd, UINT uType, BOOL *pfReboot);

STDAPI ClearAutoLogon(VOID);

//
// Net Places API's called from mpr.
//

typedef enum
{
    NETPLACES_WIZARD_MAPDRIVE = 0,
    NETPLACES_WIZARD_ADDPLACE,
} NETPLACESWIZARDTYPE;

STDAPI_(DWORD)
NetPlacesWizardDoModal(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct,
    NETPLACESWIZARDTYPE npwt,
    BOOL                fIsRoPath
    );

// Definition for the exported function types (for GetProcAddress)
typedef DWORD (STDAPICALLTYPE*NetPlacesWizardDoModal_t)(LPCONNECTDLGSTRUCTW lpConnDlgStruct, NETPLACESWIZARDTYPE npwt, BOOL fIsROPath);

//
// moved here from nettarg.h (shell\inc)
//

// nCmdID
#define CFCID_SETENUMTYPE       0

//nCmdExecOpt
#define CFCOPT_ENUMINCOMING     1
#define CFCOPT_ENUMOUTGOING     2
#define CFCOPT_ENUMALL          3


/****************************************************
 Items to display in the shutdown dialog (dwItems)
 -------------------------------------------------

  These flags can be |'d when passed in. A single
  value will be returned, with NONE indicating an
  error or the user clicked cancel.
  -dsheldon
****************************************************/
#define SHTDN_NONE                      0x000000000
#define SHTDN_LOGOFF                    0x000000001
#define SHTDN_SHUTDOWN                  0x000000002
#define SHTDN_RESTART                   0x000000004
#define SHTDN_RESTART_DOS               0x000000008
#define SHTDN_SLEEP                     0x000000010
#define SHTDN_SLEEP2                    0x000000020
#define SHTDN_HIBERNATE                 0x000000040
#define SHTDN_DISCONNECT                0x000000080

// Shutdown dialog function exported from MSGINA.dll

STDAPI_(DWORD) ShellShutdownDialog(HWND hwndParent, LPCTSTR szUsername, DWORD dwExcludeItems);
typedef DWORD (STDAPICALLTYPE*PFNSHELLSHUTDOWNDIALOG)(HWND hwndParent, LPCTSTR szUsername, DWORD dwExcludeItems);


// Define a clipboard format for a data object to pass a user's SID
// A data object supporting this format is passed to IShellExtInit::Initialize
// before calling IShellPropSheetExt::AddPages.
#define CFSTR_USERPROPPAGESSID TEXT("UserPropertyPagesSid")


// Registry paths where extra IShellPropSheetExt handlers can be put so that
// extended pages are added to the CPL or User Properties
#define REGSTR_USERSANDPASSWORDS_CPL \
/* HKLM\\ */ TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Users and Passwords")
// CLSIDs go in HKLM\Software\Microsoft\Windows\CurrentVersion\Control Panel\Users and Passwords\shellex\PropertySheetHandlers

#define REGSTR_USERPROPERTIES_SHEET \
/* HKLM\\ */ TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Users and Passwords\\User Properties")
// CLSIDs go in HKLM\Software\Microsoft\Windows\CurrentVersion\Control Panel\Users and Passwords\User Properties\shellex\PropertySheetHandlers

//  SHStgOpenStorage()
//  Wrap of StgOpenStorage for binding to file-based storage.
//
//  pszPath,     // storage path
//  grfMode,     // STGM_ flags.  Note: if requesting a stream or property set, use STGM_DIRECT|STGM_SHARE_EXCLUSIVE.
//  grfAttr,     // reserved for future use.
//  grfFileAttr, // win32 file attributes, if available; otherwise zero.
//  riid,        // interface requested
//  ppvObj       // receives address of storage object
//
STDAPI SHStgOpenStorageA(IN LPCSTR pszPath, IN OPTIONAL DWORD grfMode, IN OPTIONAL DWORD grfAttr, IN OPTIONAL DWORD grfFileAttr, REFIID riid, OUT void ** ppvObj);
//  riid,        // interface requested
//  ppvObj       // receives address of storage object
//
STDAPI SHStgOpenStorageW(IN LPCWSTR pszPath, IN OPTIONAL DWORD grfMode, IN OPTIONAL DWORD grfAttr, IN OPTIONAL DWORD grfFileAttr, REFIID riid, OUT void ** ppvObj);
#ifdef UNICODE
#define SHStgOpenStorage  SHStgOpenStorageW
#else
#define SHStgOpenStorage  SHStgOpenStorageA
#endif // !UNICODE


//  SHPropStgCreate()
//  Wrap of IPropertySetStorage::Open/Create
//
//  This function ensures proper handling of code page retrieval/assignment
//  for the requested property set operation.
//
//  psstg,          //  Address of IPropertySetStorage vtable
//  fmtid,          //  property set ID
//  pclsid,         //  class ID associated with the set. This can be NULL
//  grfFlags,       //  PROPSETFLAG_xxx.  All sets containing ansi bytes should be created with
                    //  PROPSETFLAG_ANSI, otherwise PROPSETFLAG_DEFAULT.
//  grfMode,        //  STGM_ flags.  Must contain STGM_DIRECT|STGM_EXCLUSIVE.
//  dwDisposition,  //  OPEN_EXISTING. OPEN_ALWAYS, CREATE_NEW, or CREATE_ALWAYS
//  IPropertyStorage** ppstg,  // Address to receive requested vtable
//  puCodePage      //  Optional address to receive the code page ID for the set.
//
STDAPI SHPropStgCreate( IPropertySetStorage* psstg, REFFMTID fmtid, CLSID* pclsid, DWORD grfFlags, DWORD grfMode, DWORD dwDisposition, OUT IPropertyStorage** ppstg, OUT OPTIONAL UINT* puCodePage );


//  SHPropStgReadMultiple()
//  IPropertyStorage::ReadMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, //Code page value retrieved from SHCreatePropertySet
//  cpspec,    //Count of properties being read
//  rgpspec,   //Array of the properties to be read
//  rgvar      //Array of PROPVARIANTs containing the property values on return
//
STDAPI SHPropStgReadMultiple( IPropertyStorage* pps, UINT uCodePage, ULONG cpspec, PROPSPEC const rgpspec[], PROPVARIANT rgvar[] );


//  SHPropStgWriteMultiple()
//  IPropertyStorage::WriteMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,        // address of IPropertyStorage vtable.
//  puCodePage, // (in, out) address of code page value retrieved from SHCreatePropertySet.
//  cpspec,     // The number of properties being set
//  rgpspec,    // Property specifiers
//  rgvar,      // Array of PROPVARIANT values
//  propidNameFirst // Minimum value for property identifiers. This value should be >= PID_FIRST_USABLE
//
STDAPI SHPropStgWriteMultiple( IPropertyStorage* pps, UINT* puCodePage, ULONG cpspec, PROPSPEC const rgpspec[], PROPVARIANT rgvar[], PROPID propidNameFirst );

//  SHIsLegacyAnsiProperty()
//
//  Determine whether the property is a legacy ANSI property, and if so,
//  compute a conversion type for the property.
//
//  fmtid,     // property set identifier
//  propid,    // property identifier
//  pvt,       // optional:  if non-null, contains on input the VARTYPE for the property; on output,
               //            the converted type.  (e.g., VT_LPSTR <--> VT_LPWSTR).

STDAPI_(BOOL) SHIsLegacyAnsiProperty( REFFMTID fmtid, PROPID propid, IN OUT OPTIONAL VARTYPE* pvt );



//-------------------------------------------------------------------------//
//  linkwnd.h - declaration of LinkWindow control
//
//  LinkWindow supports HTML-like embedded links in the caption text.
//  (e.g. "<a>Click Here</a> to see something cool"
//
//  An unlimited number of embedded links are supported.   When the user clicks
//  on a link, an WM_NOTIFY - LWN_CLICK notification message is sent to the
//  parent window.   The message data includes the zero-based index
//  (left to right orientation) of the link that was clicked.
//
//  (BUGBUG: need to add link-identifier support to accommodate right-to-left
//  captions, <a id:Foo>Click Here</a> ).
//
//  scotthan: author/owner
//  dsheldon: moved this to shlobjp.h. Eventually destined for comctl32.

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;

#define INVALID_LINK_INDEX  (-1)
#define MAX_LINKID_TEXT     48
#define LINKWINDOW_CLASS    TEXT("Link Window")

#define LWIF_ITEMINDEX  0x00000001
#define LWIF_STATE      0x00000002
#define LWIF_ITEMID     0x00000004
#define LWIF_URL        0x00000008

#define LWIS_FOCUSED    0x0001
#define LWIS_ENABLED    0x0002
#define LWIS_VISITED    0x0004

//  BUGBUG: we've got to change the following definition to
//  wininet.h::INTERNET_MAX_URL_LENGTH.
//  Currently, this breaks various dependents.
#define LW_MAX_URL_LENGTH   (2048 + 32 + sizeof("://"))

//  LWITEM
typedef struct tagLWITEMA {
    UINT        mask ;
    int         iLink ;
    UINT        state ;
    UINT        stateMask ;
    CHAR        szID[MAX_LINKID_TEXT] ;
    CHAR        szUrl[LW_MAX_URL_LENGTH] ;   //bugbug: INTERNET_MAX_URL_LENGTH
} LWITEMA, FAR* LPLWITEMA ;

typedef struct tagLWITEMW {
    UINT        mask ;
    int         iLink ;
    UINT        state ;
    UINT        stateMask ;
    WCHAR       szID[MAX_LINKID_TEXT] ;
    WCHAR       szUrl[LW_MAX_URL_LENGTH] ;  //bugbug: INTERNET_MAX_URL_LENGTH
} LWITEMW, FAR* LPLWITEMW ;

//  LWHITTESTINFO
typedef struct tagLWHITTESTINFOA {
    POINT       pt ;
    LWITEMA     item ;
} LWHITTESTINFOA, FAR* LPLWHITTESTINFOA ;

//  LWHITTESTINFO
typedef struct tagLWHITTESTINFOW {
    POINT       pt ;
    LWITEMW     item ;
} LWHITTESTINFOW, FAR* LPLWHITTESTINFOW ;

//  NMLINKWND
typedef struct tagNMLINKWNDA {
    NMHDR       hdr;
    LWITEMA     item ;
} NMLINKWNDA, FAR *LPNMLINKWNDA;

typedef struct tagNMLINKWNDW {
    NMHDR       hdr;
    LWITEMW     item ;
} NMLINKWNDW, FAR *LPNMLINKWNDW;

#ifdef UNICODE
#define LWITEM          LWITEMW
#define LPLWITEM        LPLWITEMW
#define LWHITTESTINFO   LWHITTESTINFOW
#define LPLWHITTESTINFO LPLWHITTESTINFOW
#define NMLINKWND       NMLINKWNDW
#define LPNMLINKWND     LPNMLINKWNDW
#else //UNICODE
#define LWITEM          LWITEMA
#define LPLWITEM        LPLWITEMA
#define LWHITTESTINFO   LWHITTESTINFOA
#define LPLWHITTESTINFO LPLWHITTESTINFOA
#define NMLINKWND       NMLINKWNDA
#define LPNMLINKWND     LPNMLINKWNDA
#endif //UNICODE

//  LinkWindow notifications
//  NM_CLICK   // wParam: n/a, lParam: LPLWITEM, ret: ignored.

//  LinkWindow messages
#define LWM_HITTEST         (WM_USER+0x300)  // wParam: n/a, lparam: LPLWHITTESTINFO, ret: BOOL
#define LWM_GETIDEALHEIGHT  (WM_USER+0x301)  // wParam: n/a, lparam: n/a, ret: cy
#define LWM_SETITEM        (WM_USER+0x302)  // wParam: n/a, lparam: LWITEM*, ret: BOOL
#define LWM_GETITEM        (WM_USER+0x303)  // wParam: n/a, lparam: LWITEM*, ret: BOOL
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  grpbtn.h - declaration of GroupButton control
//
//  GroupButton is a variation of a group box control but supports a link-like
//  caption bar, and optionally, can be buddied to a containee window for
//  auto-positioning behavior.
//
//  scotthan: author/owner
//            (Eventually destined for comctl32.)

#define GROUPBUTTON_CLASS  TEXT("GroupButton")

EXTERN_C ATOM WINAPI GroupButton_RegisterClass() ;
EXTERN_C BOOL WINAPI GroupButton_UnregisterClass() ;

typedef struct tagGBPLACEMENT
{
    LONG x ;            // in: top left; -1 to ignore
    LONG y ;            // in: top right; -1 to ignore
    LONG cx ;           // in: width to assign; -1 to ignore.
                        //     If cx != -1, cxContain and cxMax are ignored.
    LONG cy ;           // in: height to assign; -1 to ignore.
                        //     If cy != -1, cyContain and cyMax are ignored.
    LONG cxBuddy ;      // in: width of buddy area; -1 to ignore
    LONG cyBuddy ;      // in: height of buddy area; -1 to ignore
    LONG cxBuddyMargin ;// in: width of buddy margin; -1 to ignore
    LONG cyBuddyMargin ;// in: height of buddy margin; -1 to ignore
    RECT rcBuddy ;      // out: new buddy rect in parent coords.
    RECT rcWindow ;     // out: new window rect in parent coords.
    HDWP hdwp ;         // optional in: Non-NULL => DeferWindowPos,
                        //              NULL => SetWindowPos
} GBPLACEMENT, *PGBPLACEMENT, *LPGBPLACEMENT ;

//  Buddy flags
#define GBBF_HRESIZE   0x00000001
#define GBBF_VRESIZE   0x00000002
#define GBBF_HSCROLL   0x00000004
#define GBBF_VSCROLL   0x00000008
#define GBBF_HSLAVE    0x00000010
#define GBBF_VSLAVE    0x00000020

//  Group button messages
#define GBM_FIRST        (WM_USER+0x400) // arbitrary
#define GBM_SETPLACEMENT (GBM_FIRST+0)   // WPARAM: n/a, LPARAM: PGBPLACEMENT, return: BOOL
#define GBM_SETBUDDY     (GBM_FIRST+1)   // WPARAM: HWND hwndBuddy, LPARAM: dwBuddyFlags, return: BOOL
#define GBM_GETBUDDY     (GBM_FIRST+2)   // WPARAM: n/a, LPARAM: n/a, return: HWND
#define GBM_SETDROPSTATE (GBM_FIRST+3)   // WPARAM: BOOL fDropped, LPARAM: n/a, return: BOOL
#define GBM_GETDROPSTATE (GBM_FIRST+4)   // WPARAM: n/a, LPARAM: n/a, return: BOOL fDropped
#define GBM_LAST         GBM_GETDROPSTATE

typedef struct tagGBNQUERYBUDDYSIZE
{
    NMHDR   hdr;
    LONG    cx ;
    LONG    cy ;
} GBNQUERYBUDDYSIZE, *LPGBNQUERYBUDDYSIZE, *PGBNQUERYBUDDYSIZE ;

//  Group button notifications
#define GBN_FIRST               2000U
#define GBN_LAST                2020U
#define GBN_QUERYBUDDYHEIGHT    (GBN_FIRST+0)   // LPARAM: LPGBNQUERYBUDDYSIZE
#define GBN_QUERYBUDDYWIDTH     (GBN_FIRST+1)   // LPARAM: LPGBNQUERYBUDDYSIZE.

//-------------------------------------------------------------------------//
#ifdef __cplusplus
}

#endif  /* __cplusplus */

#ifndef RC_INVOKED
#include <poppack.h>
#endif  /* !RC_INVOKED */
#endif // _SHLOBJP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=console
UMENTRY=main

INCLUDES=..\xbfile

LINKLIBS=$(LINKLIBS) \
    $(SDK_LIB_PATH)\xboxdbg.lib \
    ..\xbfile\obj\*\xbfile.lib \
    $(WSDK_LIB_PATH)\kernel32.lib \
    $(WSDK_LIB_PATH)\advapi32.lib \
    $(WSDK_LIB_PATH)\user32.lib

USE_MSVCRT=1

MSC_WARNING_FLAGS=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\sdkp\inc\shtypes.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for shtypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __shtypes_h__
#define __shtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_shtypes_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//--------------------------------------------------------------------------
//===========================================================================
//
// Object identifiers in the explorer's name space (ItemID and IDList)
//
//  All the items that the user can browse with the explorer (such as files,
// directories, servers, work-groups, etc.) has an identifier which is unique
// among items within the parent folder. Those identifiers are called item
// IDs (SHITEMID). Since all its parent folders have their own item IDs,
// any items can be uniquely identified by a list of item IDs, which is called
// an ID list (ITEMIDLIST).
//
//  ID lists are almost always allocated by the task allocator (see some
// description below as well as OLE 2.0 SDK) and may be passed across
// some of shell interfaces (such as IShellFolder). Each item ID in an ID list
// is only meaningful to its parent folder (which has generated it), and all
// the clients must treat it as an opaque binary data except the first two
// bytes, which indicates the size of the item ID.
//
//  When a shell extension -- which implements the IShellFolder interace --
// generates an item ID, it may put any information in it, not only the data
// with that it needs to identifies the item, but also some additional
// information, which would help implementing some other functions efficiently.
// For example, the shell's IShellFolder implementation of file system items
// stores the primary (long) name of a file or a directory as the item
// identifier, but it also stores its alternative (short) name, size and date
// etc.
//
//  When an ID list is passed to one of shell APIs (such as SHGetPathFromIDList),
// it is always an absolute path -- relative from the root of the name space,
// which is the desktop folder. When an ID list is passed to one of IShellFolder
// member function, it is always a relative path from the folder (unless it
// is explicitly specified).
//
//===========================================================================
//
// SHITEMID -- Item ID  (mkid)
//     USHORT      cb;             // Size of the ID (including cb itself)
//     BYTE        abID[];         // The item ID (variable length)
//
#include <pshpack1.h>
typedef struct _SHITEMID
    {
    USHORT cb;
    BYTE abID[ 1 ];
    } 	SHITEMID;

#include <poppack.h>
#if defined(_M_IX86)
#define __unaligned
#endif // __unaligned
typedef SHITEMID __unaligned *LPSHITEMID;

typedef const SHITEMID __unaligned *LPCSHITEMID;

//
// ITEMIDLIST -- List if item IDs (combined with 0-terminator)
//
#include <pshpack1.h>
typedef struct _ITEMIDLIST
    {
    SHITEMID mkid;
    } 	ITEMIDLIST;

#include <poppack.h>
typedef /* [unique] */ BYTE_BLOB *wirePIDL;

typedef /* [wire_marshal] */ ITEMIDLIST __unaligned *LPITEMIDLIST;

typedef /* [wire_marshal] */ const ITEMIDLIST __unaligned *LPCITEMIDLIST;

typedef struct _WINBASE_DEFINED_STRUCT
    {
    int dummy;
    } 	WINBASE_DEFINED_STRUCT;

#ifdef WINBASE_DEFINED_MIDL
typedef WINBASE_DEFINED_STRUCT WIN32_FIND_DATAA;

typedef WINBASE_DEFINED_STRUCT WIN32_FIND_DATAW;

#endif // WINBASE_DEFINED_MIDL
//-------------------------------------------------------------------------
//
// struct STRRET
//
// structure for returning strings from IShellFolder member functions
//
//-------------------------------------------------------------------------
//
//  uType indicate which union member to use 
//    STRRET_WSTR    Use STRRET.pOleStr     must be freed by caller of GetDisplayNameOf
//    STRRET_OFFSET  Use STRRET.uOffset     Offset into SHITEMID for ANSI string 
//    STRRET_CSTR    Use STRRET.cStr        ANSI Buffer
//
typedef /* [v1_enum] */ 
enum tagSTRRET_TYPE
    {	STRRET_WSTR	= 0,
	STRRET_OFFSET	= 0x1,
	STRRET_CSTR	= 0x2
    } 	STRRET_TYPE;

#include <pshpack1.h>
typedef struct _STRRET
    {
    UINT uType;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()][string] */ LPWSTR pOleStr;
        /* [case()] */ UINT uOffset;
        /* [case()] */ char cStr[ 260 ];
        } 	DUMMYUNIONNAME;
    } 	STRRET;

#include <poppack.h>
typedef STRRET *LPSTRRET;

//-------------------------------------------------------------------------
//
// struct SHELLDETAILS
//
// structure for returning strings from IShellDetails
//
//-------------------------------------------------------------------------
//
//  fmt;            // LVCFMT_* value (header only)
//  cxChar;         // Number of 'average' characters (header only)
//  str;            // String information
//
#include <pshpack1.h>
typedef struct _SHELLDETAILS
    {
    int fmt;
    int cxChar;
    STRRET str;
    } 	SHELLDETAILS;

typedef struct _SHELLDETAILS *LPSHELLDETAILS;

#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_shtypes_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shtypes_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\sdkp\inc\shobjidl.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for shobjidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shobjidl_h__
#define __shobjidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPersistFolder_FWD_DEFINED__
#define __IPersistFolder_FWD_DEFINED__
typedef interface IPersistFolder IPersistFolder;
#endif 	/* __IPersistFolder_FWD_DEFINED__ */


#ifndef __IPersistFolder2_FWD_DEFINED__
#define __IPersistFolder2_FWD_DEFINED__
typedef interface IPersistFolder2 IPersistFolder2;
#endif 	/* __IPersistFolder2_FWD_DEFINED__ */


#ifndef __IPersistIDList_FWD_DEFINED__
#define __IPersistIDList_FWD_DEFINED__
typedef interface IPersistIDList IPersistIDList;
#endif 	/* __IPersistIDList_FWD_DEFINED__ */


#ifndef __IEnumIDList_FWD_DEFINED__
#define __IEnumIDList_FWD_DEFINED__
typedef interface IEnumIDList IEnumIDList;
#endif 	/* __IEnumIDList_FWD_DEFINED__ */


#ifndef __IShellFolder_FWD_DEFINED__
#define __IShellFolder_FWD_DEFINED__
typedef interface IShellFolder IShellFolder;
#endif 	/* __IShellFolder_FWD_DEFINED__ */


#ifndef __IEnumExtraSearch_FWD_DEFINED__
#define __IEnumExtraSearch_FWD_DEFINED__
typedef interface IEnumExtraSearch IEnumExtraSearch;
#endif 	/* __IEnumExtraSearch_FWD_DEFINED__ */


#ifndef __IShellFolder2_FWD_DEFINED__
#define __IShellFolder2_FWD_DEFINED__
typedef interface IShellFolder2 IShellFolder2;
#endif 	/* __IShellFolder2_FWD_DEFINED__ */


#ifndef __IShellView_FWD_DEFINED__
#define __IShellView_FWD_DEFINED__
typedef interface IShellView IShellView;
#endif 	/* __IShellView_FWD_DEFINED__ */


#ifndef __IShellView2_FWD_DEFINED__
#define __IShellView2_FWD_DEFINED__
typedef interface IShellView2 IShellView2;
#endif 	/* __IShellView2_FWD_DEFINED__ */


#ifndef __IFolderView_FWD_DEFINED__
#define __IFolderView_FWD_DEFINED__
typedef interface IFolderView IFolderView;
#endif 	/* __IFolderView_FWD_DEFINED__ */


#ifndef __IShellBrowser_FWD_DEFINED__
#define __IShellBrowser_FWD_DEFINED__
typedef interface IShellBrowser IShellBrowser;
#endif 	/* __IShellBrowser_FWD_DEFINED__ */


#ifndef __IShellNetCrawler_FWD_DEFINED__
#define __IShellNetCrawler_FWD_DEFINED__
typedef interface IShellNetCrawler IShellNetCrawler;
#endif 	/* __IShellNetCrawler_FWD_DEFINED__ */


#ifndef __IProfferService_FWD_DEFINED__
#define __IProfferService_FWD_DEFINED__
typedef interface IProfferService IProfferService;
#endif 	/* __IProfferService_FWD_DEFINED__ */


#ifndef __ICompositeFolder_FWD_DEFINED__
#define __ICompositeFolder_FWD_DEFINED__
typedef interface ICompositeFolder ICompositeFolder;
#endif 	/* __ICompositeFolder_FWD_DEFINED__ */


#ifndef __IParentAndItem_FWD_DEFINED__
#define __IParentAndItem_FWD_DEFINED__
typedef interface IParentAndItem IParentAndItem;
#endif 	/* __IParentAndItem_FWD_DEFINED__ */


#ifndef __IPropertyUI_FWD_DEFINED__
#define __IPropertyUI_FWD_DEFINED__
typedef interface IPropertyUI IPropertyUI;
#endif 	/* __IPropertyUI_FWD_DEFINED__ */


#ifndef __ICategoryProvider_FWD_DEFINED__
#define __ICategoryProvider_FWD_DEFINED__
typedef interface ICategoryProvider ICategoryProvider;
#endif 	/* __ICategoryProvider_FWD_DEFINED__ */


#ifndef __ICategorizer_FWD_DEFINED__
#define __ICategorizer_FWD_DEFINED__
typedef interface ICategorizer ICategorizer;
#endif 	/* __ICategorizer_FWD_DEFINED__ */


#ifndef __IShellItem_FWD_DEFINED__
#define __IShellItem_FWD_DEFINED__
typedef interface IShellItem IShellItem;
#endif 	/* __IShellItem_FWD_DEFINED__ */


#ifndef __IEnumShellItems_FWD_DEFINED__
#define __IEnumShellItems_FWD_DEFINED__
typedef interface IEnumShellItems IEnumShellItems;
#endif 	/* __IEnumShellItems_FWD_DEFINED__ */


#ifndef __IItemHandler_FWD_DEFINED__
#define __IItemHandler_FWD_DEFINED__
typedef interface IItemHandler IItemHandler;
#endif 	/* __IItemHandler_FWD_DEFINED__ */


#ifndef __ILocalCopy_FWD_DEFINED__
#define __ILocalCopy_FWD_DEFINED__
typedef interface ILocalCopy ILocalCopy;
#endif 	/* __ILocalCopy_FWD_DEFINED__ */


#ifndef __IShellLinkA_FWD_DEFINED__
#define __IShellLinkA_FWD_DEFINED__
typedef interface IShellLinkA IShellLinkA;
#endif 	/* __IShellLinkA_FWD_DEFINED__ */


#ifndef __IShellLinkW_FWD_DEFINED__
#define __IShellLinkW_FWD_DEFINED__
typedef interface IShellLinkW IShellLinkW;
#endif 	/* __IShellLinkW_FWD_DEFINED__ */


#ifndef __IActionProgressDialog_FWD_DEFINED__
#define __IActionProgressDialog_FWD_DEFINED__
typedef interface IActionProgressDialog IActionProgressDialog;
#endif 	/* __IActionProgressDialog_FWD_DEFINED__ */


#ifndef __IHWEventHandler_FWD_DEFINED__
#define __IHWEventHandler_FWD_DEFINED__
typedef interface IHWEventHandler IHWEventHandler;
#endif 	/* __IHWEventHandler_FWD_DEFINED__ */


#ifndef __IActionProgress_FWD_DEFINED__
#define __IActionProgress_FWD_DEFINED__
typedef interface IActionProgress IActionProgress;
#endif 	/* __IActionProgress_FWD_DEFINED__ */


#ifndef __IShellExtInit_FWD_DEFINED__
#define __IShellExtInit_FWD_DEFINED__
typedef interface IShellExtInit IShellExtInit;
#endif 	/* __IShellExtInit_FWD_DEFINED__ */


#ifndef __IShellPropSheetExt_FWD_DEFINED__
#define __IShellPropSheetExt_FWD_DEFINED__
typedef interface IShellPropSheetExt IShellPropSheetExt;
#endif 	/* __IShellPropSheetExt_FWD_DEFINED__ */


#ifndef __IRemoteComputer_FWD_DEFINED__
#define __IRemoteComputer_FWD_DEFINED__
typedef interface IRemoteComputer IRemoteComputer;
#endif 	/* __IRemoteComputer_FWD_DEFINED__ */


#ifndef __IDavStorage_FWD_DEFINED__
#define __IDavStorage_FWD_DEFINED__
typedef interface IDavStorage IDavStorage;
#endif 	/* __IDavStorage_FWD_DEFINED__ */


#ifndef __IDynamicStorage_FWD_DEFINED__
#define __IDynamicStorage_FWD_DEFINED__
typedef interface IDynamicStorage IDynamicStorage;
#endif 	/* __IDynamicStorage_FWD_DEFINED__ */


#ifndef __IQueryContinue_FWD_DEFINED__
#define __IQueryContinue_FWD_DEFINED__
typedef interface IQueryContinue IQueryContinue;
#endif 	/* __IQueryContinue_FWD_DEFINED__ */


#ifndef __IUserNotification_FWD_DEFINED__
#define __IUserNotification_FWD_DEFINED__
typedef interface IUserNotification IUserNotification;
#endif 	/* __IUserNotification_FWD_DEFINED__ */


#ifndef __IDockingWindow_FWD_DEFINED__
#define __IDockingWindow_FWD_DEFINED__
typedef interface IDockingWindow IDockingWindow;
#endif 	/* __IDockingWindow_FWD_DEFINED__ */


#ifndef __IDeskBand_FWD_DEFINED__
#define __IDeskBand_FWD_DEFINED__
typedef interface IDeskBand IDeskBand;
#endif 	/* __IDeskBand_FWD_DEFINED__ */


#ifndef __DriveSizeCategorizer_FWD_DEFINED__
#define __DriveSizeCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DriveSizeCategorizer DriveSizeCategorizer;
#else
typedef struct DriveSizeCategorizer DriveSizeCategorizer;
#endif /* __cplusplus */

#endif 	/* __DriveSizeCategorizer_FWD_DEFINED__ */


#ifndef __DriveTypeCategorizer_FWD_DEFINED__
#define __DriveTypeCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DriveTypeCategorizer DriveTypeCategorizer;
#else
typedef struct DriveTypeCategorizer DriveTypeCategorizer;
#endif /* __cplusplus */

#endif 	/* __DriveTypeCategorizer_FWD_DEFINED__ */


#ifndef __FreeSpaceCategorizer_FWD_DEFINED__
#define __FreeSpaceCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class FreeSpaceCategorizer FreeSpaceCategorizer;
#else
typedef struct FreeSpaceCategorizer FreeSpaceCategorizer;
#endif /* __cplusplus */

#endif 	/* __FreeSpaceCategorizer_FWD_DEFINED__ */


#ifndef __TimeCategorizer_FWD_DEFINED__
#define __TimeCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class TimeCategorizer TimeCategorizer;
#else
typedef struct TimeCategorizer TimeCategorizer;
#endif /* __cplusplus */

#endif 	/* __TimeCategorizer_FWD_DEFINED__ */


#ifndef __SizeCategorizer_FWD_DEFINED__
#define __SizeCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SizeCategorizer SizeCategorizer;
#else
typedef struct SizeCategorizer SizeCategorizer;
#endif /* __cplusplus */

#endif 	/* __SizeCategorizer_FWD_DEFINED__ */


#ifndef __AlphabeticalCategorizer_FWD_DEFINED__
#define __AlphabeticalCategorizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class AlphabeticalCategorizer AlphabeticalCategorizer;
#else
typedef struct AlphabeticalCategorizer AlphabeticalCategorizer;
#endif /* __cplusplus */

#endif 	/* __AlphabeticalCategorizer_FWD_DEFINED__ */


#ifndef __CompositeFolder_FWD_DEFINED__
#define __CompositeFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompositeFolder CompositeFolder;
#else
typedef struct CompositeFolder CompositeFolder;
#endif /* __cplusplus */

#endif 	/* __CompositeFolder_FWD_DEFINED__ */


#ifndef __LocalCopyHelper_FWD_DEFINED__
#define __LocalCopyHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class LocalCopyHelper LocalCopyHelper;
#else
typedef struct LocalCopyHelper LocalCopyHelper;
#endif /* __cplusplus */

#endif 	/* __LocalCopyHelper_FWD_DEFINED__ */


#ifndef __ShellItem_FWD_DEFINED__
#define __ShellItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellItem ShellItem;
#else
typedef struct ShellItem ShellItem;
#endif /* __cplusplus */

#endif 	/* __ShellItem_FWD_DEFINED__ */


#ifndef __ImageProperties_FWD_DEFINED__
#define __ImageProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImageProperties ImageProperties;
#else
typedef struct ImageProperties ImageProperties;
#endif /* __cplusplus */

#endif 	/* __ImageProperties_FWD_DEFINED__ */


#ifndef __PropertiesUI_FWD_DEFINED__
#define __PropertiesUI_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertiesUI PropertiesUI;
#else
typedef struct PropertiesUI PropertiesUI;
#endif /* __cplusplus */

#endif 	/* __PropertiesUI_FWD_DEFINED__ */


#ifndef __UserNotification_FWD_DEFINED__
#define __UserNotification_FWD_DEFINED__

#ifdef __cplusplus
typedef class UserNotification UserNotification;
#else
typedef struct UserNotification UserNotification;
#endif /* __cplusplus */

#endif 	/* __UserNotification_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "shtypes.h"
#include "servprov.h"
#include "comcat.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_shobjidl_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//--------------------------------------------------------------------------

#ifndef _WINRESRC_
#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif
#endif
//===========================================================================
//
// IPersistFolder Interface
//
//  The IPersistFolder interface is used by the file system implementation of
// IShellFolder::BindToObject when it is initializing a shell folder object.
//
//
// [Member functions]
//
// IPersistFolder::Initialize
//
//  This member function is called when the explorer is initializing a
// shell folder object.
//
//  Parameters:
//   pidl -- Specifies the absolute location of the folder.
//
//===========================================================================


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0000_v0_0_s_ifspec;

#ifndef __IPersistFolder_INTERFACE_DEFINED__
#define __IPersistFolder_INTERFACE_DEFINED__

/* interface IPersistFolder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214EA-0000-0000-C000-000000000046")
    IPersistFolder : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCITEMIDLIST pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistFolder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistFolder * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPersistFolder * This,
            /* [in] */ LPCITEMIDLIST pidl);
        
        END_INTERFACE
    } IPersistFolderVtbl;

    interface IPersistFolder
    {
        CONST_VTBL struct IPersistFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistFolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistFolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistFolder_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistFolder_Initialize(This,pidl)	\
    (This)->lpVtbl -> Initialize(This,pidl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistFolder_Initialize_Proxy( 
    IPersistFolder * This,
    /* [in] */ LPCITEMIDLIST pidl);


void __RPC_STUB IPersistFolder_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0143 */
/* [local] */ 

typedef IPersistFolder *LPPERSISTFOLDER;

#if (_WIN32_IE >= 0x0400)


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0143_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0143_v0_0_s_ifspec;

#ifndef __IPersistFolder2_INTERFACE_DEFINED__
#define __IPersistFolder2_INTERFACE_DEFINED__

/* interface IPersistFolder2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistFolder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1AC3D9F0-175C-11d1-95BE-00609797EA4F")
    IPersistFolder2 : public IPersistFolder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurFolder( 
            /* [out] */ LPITEMIDLIST *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFolder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistFolder2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistFolder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistFolder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistFolder2 * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPersistFolder2 * This,
            /* [in] */ LPCITEMIDLIST pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFolder )( 
            IPersistFolder2 * This,
            /* [out] */ LPITEMIDLIST *ppidl);
        
        END_INTERFACE
    } IPersistFolder2Vtbl;

    interface IPersistFolder2
    {
        CONST_VTBL struct IPersistFolder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFolder2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistFolder2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistFolder2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistFolder2_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistFolder2_Initialize(This,pidl)	\
    (This)->lpVtbl -> Initialize(This,pidl)


#define IPersistFolder2_GetCurFolder(This,ppidl)	\
    (This)->lpVtbl -> GetCurFolder(This,ppidl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistFolder2_GetCurFolder_Proxy( 
    IPersistFolder2 * This,
    /* [out] */ LPITEMIDLIST *ppidl);


void __RPC_STUB IPersistFolder2_GetCurFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistFolder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0144 */
/* [local] */ 

typedef IPersistFolder2 *LPPERSISTFOLDER2;

#endif


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0144_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0144_v0_0_s_ifspec;

#ifndef __IPersistIDList_INTERFACE_DEFINED__
#define __IPersistIDList_INTERFACE_DEFINED__

/* interface IPersistIDList */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1079acfc-29bd-11d3-8e0d-00c04f6837d5")
    IPersistIDList : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadIDList( 
            /* [in] */ LPCITEMIDLIST pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveIDList( 
            /* [out] */ LPITEMIDLIST *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistIDList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistIDList * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *LoadIDList )( 
            IPersistIDList * This,
            /* [in] */ LPCITEMIDLIST pidl);
        
        HRESULT ( STDMETHODCALLTYPE *SaveIDList )( 
            IPersistIDList * This,
            /* [out] */ LPITEMIDLIST *ppidl);
        
        END_INTERFACE
    } IPersistIDListVtbl;

    interface IPersistIDList
    {
        CONST_VTBL struct IPersistIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistIDList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistIDList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistIDList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistIDList_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistIDList_LoadIDList(This,pidl)	\
    (This)->lpVtbl -> LoadIDList(This,pidl)

#define IPersistIDList_SaveIDList(This,ppidl)	\
    (This)->lpVtbl -> SaveIDList(This,ppidl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistIDList_LoadIDList_Proxy( 
    IPersistIDList * This,
    /* [in] */ LPCITEMIDLIST pidl);


void __RPC_STUB IPersistIDList_LoadIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistIDList_SaveIDList_Proxy( 
    IPersistIDList * This,
    /* [out] */ LPITEMIDLIST *ppidl);


void __RPC_STUB IPersistIDList_SaveIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0145 */
/* [local] */ 

//-------------------------------------------------------------------------
//
// IEnumIDList interface
//
//  IShellFolder::EnumObjects member returns an IEnumIDList object.
//
//-------------------------------------------------------------------------



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0145_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0145_v0_0_s_ifspec;

#ifndef __IEnumIDList_INTERFACE_DEFINED__
#define __IEnumIDList_INTERFACE_DEFINED__

/* interface IEnumIDList */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEnumIDList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214F2-0000-0000-C000-000000000046")
    IEnumIDList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPITEMIDLIST *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumIDList **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumIDListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumIDList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumIDList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumIDList * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPITEMIDLIST *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumIDList * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumIDList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumIDList * This,
            /* [out] */ IEnumIDList **ppenum);
        
        END_INTERFACE
    } IEnumIDListVtbl;

    interface IEnumIDList
    {
        CONST_VTBL struct IEnumIDListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumIDList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumIDList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumIDList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumIDList_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumIDList_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumIDList_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumIDList_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumIDList_Next_Proxy( 
    IEnumIDList * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPITEMIDLIST *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumIDList_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDList_Skip_Proxy( 
    IEnumIDList * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumIDList_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDList_Reset_Proxy( 
    IEnumIDList * This);


void __RPC_STUB IEnumIDList_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDList_Clone_Proxy( 
    IEnumIDList * This,
    /* [out] */ IEnumIDList **ppenum);


void __RPC_STUB IEnumIDList_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumIDList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0146 */
/* [local] */ 

typedef IEnumIDList *LPENUMIDLIST;

//-------------------------------------------------------------------------
//
// IShellFolder interface
//
//
// [Member functions]
//
// IShellFolder::BindToObject(pidl, pbc, riid, ppv)
//   This function returns an instance of a sub-folder which is specified
//  by the IDList (pidl).
//
// IShellFolder::BindToStorage(pidl, pbc, riid, ppv)
//   This function returns a storage instance of a sub-folder which is
//  specified by the IDList (pidl). The shell never calls this member
//  function in the first release of Win95.
//
// IShellFolder::CompareIDs(lParam, pidl1, pidl2)
//   This function compares two IDLists and returns the result. The shell
//  explorer always passes 0 as lParam, which indicates 'sort by name'.
//  It should return 0 (as CODE of the scode), if two id indicates the
//  same object; negative value if pidl1 should be placed before pidl2;
//  positive value if pidl2 should be placed before pidl1.
//
// IShellFolder::CreateViewObject(hwndOwner, riid, ppv)
//   This function creates a view object of the folder itself. The view
//  object is a difference instance from the shell folder object.
//   'hwndOwner' can be used  as the owner window of its dialog box or
//  menu during the lifetime of the view object.
//  This member function should always create a new
//  instance which has only one reference count. The explorer may create
//  more than one instances of view object from one shell folder object
//  and treat them as separate instances.
//
// IShellFolder::GetAttributesOf(cidl, apidl, prgfInOut)
//   This function returns the attributes of specified objects in that
//  folder. 'cidl' and 'apidl' specifies objects. 'apidl' contains only
//  simple IDLists. The explorer initializes *prgfInOut with a set of
//  flags to be evaluated. The shell folder may optimize the operation
//  by not returning unspecified flags.
//
// IShellFolder::GetUIObjectOf(hwndOwner, cidl, apidl, riid, prgfInOut, ppv)
//   This function creates a UI object to be used for specified objects.
//  The shell explorer passes either IID_IDataObject (for transfer operation)
//  or IID_IContextMenu (for context menu operation) as riid.
//
// IShellFolder::GetDisplayNameOf
//   This function returns the display name of the specified object.
//  If the ID contains the display name (in the locale character set),
//  it returns the offset to the name. Otherwise, it returns a pointer
//  to the display name string (UNICODE), which is allocated by the
//  task allocator, or fills in a buffer.
//
// IShellFolder::SetNameOf
//   This function sets the display name of the specified object.
//  If it changes the ID as well, it returns the new ID which is
//  alocated by the task allocator.
//
//-------------------------------------------------------------------------
// IShellFolder::GetDisplayNameOf/SetNameOf uFlags
typedef enum tagSHGDN
{
    SHGDN_NORMAL             = 0x0000,  // default (display purpose)
    SHGDN_INFOLDER           = 0x0001,  // displayed under a folder (relative)
    SHGDN_FOREDITING         = 0x1000,  // for in-place editing
    SHGDN_FORADDRESSBAR      = 0x4000,  // UI friendly parsing name (remove ugly stuff)
    SHGDN_FORPARSING         = 0x8000,  // parsing name for ParseDisplayName()
} SHGNO;
typedef DWORD SHGDNF;

// IShellFolder::EnumObjects grfFlags bits
typedef enum tagSHCONTF
{
    SHCONTF_FOLDERS             = 0x0020,   // only want folders enumerated (SHGAO_FOLDER)
    SHCONTF_NONFOLDERS          = 0x0040,   // include non folders
    SHCONTF_INCLUDEHIDDEN       = 0x0080,   // show items normally hidden
    SHCONTF_INIT_ON_FIRST_NEXT  = 0x0100,   // allow EnumObject() to return before validating enum
    SHCONTF_NETPRINTERSRCH      = 0x0200,   // hint that client is looking for printers
    SHCONTF_SHAREABLE           = 0x0400,   // hint that client is looking sharable resources (remote shares)
};
typedef DWORD SHCONTF;

// IShellFolder::CompareIDs lParam flags
//
//  SHCIDS_ALLFIELDS is a mask for lParam indicating that the shell folder
//  should first compare on the lParam column, and if that proves equal,
//  then perform a full comparison on all fields.  This flag is supported
//  if the IShellFolder supports IShellFolder2.
//
//
#define SHCIDS_ALLFIELDS        0x80000000L
#define SHCIDS_COLUMNMASK       0x0000FFFFL
// IShellFolder::GetAttributesOf flags
// DESCRIPTION:
// SFGAO_CANLINK: If this bit is set on an item in the shell folder, a
//            'Create Shortcut' menu item will be added to the File
//            menu and context menus for the item.  If the user selects
//            that command, your IContextMenu::InvokeCommand() will be called
//            with 'link'.
//                 That flag will also be used to determine if 'Create Shortcut'
//            should be added when the item in your folder is dragged to another
//            folder.
#define SFGAO_CANCOPY           DROPEFFECT_COPY // Objects can be copied    (0x1)
#define SFGAO_CANMOVE           DROPEFFECT_MOVE // Objects can be moved     (0x2)
#define SFGAO_CANLINK           DROPEFFECT_LINK // Objects can be linked    (0x4)
#define SFGAO_CANRENAME         0x00000010L     // Objects can be renamed
#define SFGAO_CANDELETE         0x00000020L     // Objects can be deleted
#define SFGAO_HASPROPSHEET      0x00000040L     // Objects have property sheets
#define SFGAO_DROPTARGET        0x00000100L     // Objects are drop target
#define SFGAO_CAPABILITYMASK    0x00000177L
#define SFGAO_ISSLOW            0x00004000L     // 'slow' object
#define SFGAO_GHOSTED           0x00008000L     // ghosted icon
#define SFGAO_LINK              0x00010000L     // Shortcut (link)
#define SFGAO_SHARE             0x00020000L     // shared
#define SFGAO_READONLY          0x00040000L     // read-only
#define SFGAO_HIDDEN            0x00080000L     // hidden object
#define SFGAO_DISPLAYATTRMASK   0x000FC000L
#define SFGAO_FILESYSANCESTOR   0x10000000L     // It contains file system folder
#define SFGAO_STORAGEANCESTOR   0x10000000L     // contains children with accessible storage (supersets FILESYSANCESTOR)
#define SFGAO_FOLDER            0x20000000L     // It's a folder.
#define SFGAO_FILESYSTEM        0x40000000L     // is a file system thing (file/folder/root)
#define SFGAO_HASSUBFOLDER      0x80000000L     // Expandable in the map pane
#define SFGAO_CONTENTSMASK      0x80000000L
#define SFGAO_VALIDATE          0x01000000L     // invalidate cached information
#define SFGAO_REMOVABLE         0x02000000L     // is this removeable media?
#define SFGAO_COMPRESSED        0x04000000L     // Object is compressed (use alt color)
#define SFGAO_BROWSABLE         0x08000000L     // is in-place browsable
#define SFGAO_NONENUMERATED     0x00100000L     // is a non-enumerated object
#define SFGAO_NEWCONTENT        0x00200000L     // should show bold in explorer tree
#define SFGAO_CANMONIKER        0x00400000L     // can create monikers for its objects
#define SFGAO_HASSTORAGE        0x00400000L     // item has accessible storage (replaces CANMONIKER)
typedef ULONG SFGAOF;

// IShellFolder IBindCtx* parameters. the IUnknown for these are
// accessed through IBindCtx::RegisterObjectParam/GetObjectParam

// this object will support IPersist to query a CLSID that should be skipped
// in the binding process. this is to avoid loops or to allow delegation to
// base name space functionality. see SHSkipJunction()

#define STR_SKIP_BINDING_CLSID      L"Skip Binding CLSID"



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0146_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0146_v0_0_s_ifspec;

#ifndef __IShellFolder_INTERFACE_DEFINED__
#define __IShellFolder_INTERFACE_DEFINED__

/* interface IShellFolder */
/* [unique][local][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E6-0000-0000-C000-000000000046")
    IShellFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseDisplayName( 
            /* [in] */ HWND hwnd,
            /* [in] */ LPBC pbc,
            /* [string][in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG *pchEaten,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [out][in] */ ULONG *pdwAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumObjects( 
            /* [in] */ HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ IEnumIDList **ppenumIDList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ LPBC pbc,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToStorage( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ LPBC pbc,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareIDs( 
            /* [in] */ LPARAM lParam,
            /* [in] */ LPCITEMIDLIST pidl1,
            /* [in] */ LPCITEMIDLIST pidl2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewObject( 
            /* [in] */ HWND hwndOwner,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributesOf( 
            /* [in] */ UINT cidl,
            /* [size_is][in] */ LPCITEMIDLIST *apidl,
            /* [out][in] */ SFGAOF *rgfInOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUIObjectOf( 
            /* [in] */ HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ LPCITEMIDLIST *apidl,
            /* [in] */ REFIID riid,
            UINT *rgfReserved,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayNameOf( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ LPSTRRET lpName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNameOf( 
            /* [in] */ HWND hwnd,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [string][in] */ LPCOLESTR pszName,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ LPITEMIDLIST *ppidlOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellFolder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseDisplayName )( 
            IShellFolder * This,
            /* [in] */ HWND hwnd,
            /* [in] */ LPBC pbc,
            /* [string][in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG *pchEaten,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [out][in] */ ULONG *pdwAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            IShellFolder * This,
            /* [in] */ HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ IEnumIDList **ppenumIDList);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IShellFolder * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ LPBC pbc,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *BindToStorage )( 
            IShellFolder * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ LPBC pbc,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CompareIDs )( 
            IShellFolder * This,
            /* [in] */ LPARAM lParam,
            /* [in] */ LPCITEMIDLIST pidl1,
            /* [in] */ LPCITEMIDLIST pidl2);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewObject )( 
            IShellFolder * This,
            /* [in] */ HWND hwndOwner,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributesOf )( 
            IShellFolder * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ LPCITEMIDLIST *apidl,
            /* [out][in] */ SFGAOF *rgfInOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIObjectOf )( 
            IShellFolder * This,
            /* [in] */ HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ LPCITEMIDLIST *apidl,
            /* [in] */ REFIID riid,
            UINT *rgfReserved,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayNameOf )( 
            IShellFolder * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ LPSTRRET lpName);
        
        HRESULT ( STDMETHODCALLTYPE *SetNameOf )( 
            IShellFolder * This,
            /* [in] */ HWND hwnd,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [string][in] */ LPCOLESTR pszName,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ LPITEMIDLIST *ppidlOut);
        
        END_INTERFACE
    } IShellFolderVtbl;

    interface IShellFolder
    {
        CONST_VTBL struct IShellFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellFolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellFolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellFolder_ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes)	\
    (This)->lpVtbl -> ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes)

#define IShellFolder_EnumObjects(This,hwnd,grfFlags,ppenumIDList)	\
    (This)->lpVtbl -> EnumObjects(This,hwnd,grfFlags,ppenumIDList)

#define IShellFolder_BindToObject(This,pidl,pbc,riid,ppv)	\
    (This)->lpVtbl -> BindToObject(This,pidl,pbc,riid,ppv)

#define IShellFolder_BindToStorage(This,pidl,pbc,riid,ppv)	\
    (This)->lpVtbl -> BindToStorage(This,pidl,pbc,riid,ppv)

#define IShellFolder_CompareIDs(This,lParam,pidl1,pidl2)	\
    (This)->lpVtbl -> CompareIDs(This,lParam,pidl1,pidl2)

#define IShellFolder_CreateViewObject(This,hwndOwner,riid,ppv)	\
    (This)->lpVtbl -> CreateViewObject(This,hwndOwner,riid,ppv)

#define IShellFolder_GetAttributesOf(This,cidl,apidl,rgfInOut)	\
    (This)->lpVtbl -> GetAttributesOf(This,cidl,apidl,rgfInOut)

#define IShellFolder_GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv)	\
    (This)->lpVtbl -> GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv)

#define IShellFolder_GetDisplayNameOf(This,pidl,uFlags,lpName)	\
    (This)->lpVtbl -> GetDisplayNameOf(This,pidl,uFlags,lpName)

#define IShellFolder_SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut)	\
    (This)->lpVtbl -> SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellFolder_ParseDisplayName_Proxy( 
    IShellFolder * This,
    /* [in] */ HWND hwnd,
    /* [in] */ LPBC pbc,
    /* [string][in] */ LPOLESTR pszDisplayName,
    /* [out] */ ULONG *pchEaten,
    /* [out] */ LPITEMIDLIST *ppidl,
    /* [out][in] */ ULONG *pdwAttributes);


void __RPC_STUB IShellFolder_ParseDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_EnumObjects_Proxy( 
    IShellFolder * This,
    /* [in] */ HWND hwnd,
    /* [in] */ SHCONTF grfFlags,
    /* [out] */ IEnumIDList **ppenumIDList);


void __RPC_STUB IShellFolder_EnumObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_BindToObject_Proxy( 
    IShellFolder * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ LPBC pbc,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IShellFolder_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_BindToStorage_Proxy( 
    IShellFolder * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ LPBC pbc,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IShellFolder_BindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_CompareIDs_Proxy( 
    IShellFolder * This,
    /* [in] */ LPARAM lParam,
    /* [in] */ LPCITEMIDLIST pidl1,
    /* [in] */ LPCITEMIDLIST pidl2);


void __RPC_STUB IShellFolder_CompareIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_CreateViewObject_Proxy( 
    IShellFolder * This,
    /* [in] */ HWND hwndOwner,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IShellFolder_CreateViewObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_GetAttributesOf_Proxy( 
    IShellFolder * This,
    /* [in] */ UINT cidl,
    /* [size_is][in] */ LPCITEMIDLIST *apidl,
    /* [out][in] */ SFGAOF *rgfInOut);


void __RPC_STUB IShellFolder_GetAttributesOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_GetUIObjectOf_Proxy( 
    IShellFolder * This,
    /* [in] */ HWND hwndOwner,
    /* [in] */ UINT cidl,
    /* [size_is][in] */ LPCITEMIDLIST *apidl,
    /* [in] */ REFIID riid,
    UINT *rgfReserved,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IShellFolder_GetUIObjectOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_GetDisplayNameOf_Proxy( 
    IShellFolder * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ SHGDNF uFlags,
    /* [out] */ LPSTRRET lpName);


void __RPC_STUB IShellFolder_GetDisplayNameOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder_SetNameOf_Proxy( 
    IShellFolder * This,
    /* [in] */ HWND hwnd,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [string][in] */ LPCOLESTR pszName,
    /* [in] */ SHGDNF uFlags,
    /* [out] */ LPITEMIDLIST *ppidlOut);


void __RPC_STUB IShellFolder_SetNameOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0147 */
/* [local] */ 

typedef IShellFolder *LPSHELLFOLDER;

#if (_WIN32_IE >= 0x0500)
//-------------------------------------------------------------------------
//
// IEnumExtraSearch interface
//
//  IShellFolder2::EnumSearches member returns an IEnumExtraSearch object.
//
//-------------------------------------------------------------------------
typedef struct tagEXTRASEARCH
    {
    GUID guidSearch;
    WCHAR wszFriendlyName[ 80 ];
    WCHAR wszUrl[ 2084 ];
    } 	EXTRASEARCH;

typedef struct tagEXTRASEARCH *LPEXTRASEARCH;

typedef struct IEnumExtraSearch *LPENUMEXTRASEARCH;




extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0147_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0147_v0_0_s_ifspec;

#ifndef __IEnumExtraSearch_INTERFACE_DEFINED__
#define __IEnumExtraSearch_INTERFACE_DEFINED__

/* interface IEnumExtraSearch */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEnumExtraSearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E700BE1-9DB6-11d1-A1CE-00C04FD75D13")
    IEnumExtraSearch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ EXTRASEARCH *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumExtraSearch **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumExtraSearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumExtraSearch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumExtraSearch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumExtraSearch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumExtraSearch * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ EXTRASEARCH *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumExtraSearch * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumExtraSearch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumExtraSearch * This,
            /* [out] */ IEnumExtraSearch **ppenum);
        
        END_INTERFACE
    } IEnumExtraSearchVtbl;

    interface IEnumExtraSearch
    {
        CONST_VTBL struct IEnumExtraSearchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumExtraSearch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumExtraSearch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumExtraSearch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumExtraSearch_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumExtraSearch_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumExtraSearch_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumExtraSearch_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumExtraSearch_Next_Proxy( 
    IEnumExtraSearch * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ EXTRASEARCH *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumExtraSearch_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumExtraSearch_Skip_Proxy( 
    IEnumExtraSearch * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumExtraSearch_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumExtraSearch_Reset_Proxy( 
    IEnumExtraSearch * This);


void __RPC_STUB IEnumExtraSearch_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumExtraSearch_Clone_Proxy( 
    IEnumExtraSearch * This,
    /* [out] */ IEnumExtraSearch **ppenum);


void __RPC_STUB IEnumExtraSearch_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumExtraSearch_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0148 */
/* [local] */ 

//--------------------------------------------------------------------------
// IShellFolder2
//
// [member functions]
//
// IShellFolder2::GetDefaultSearchGUID(LPGUID pGuid)
//   Returns the guid of the search that is to be invoked when user clicks 
//   on the search toolbar button
//
// IShellFolder2::EnumSearches(IEnumExtraSearch **ppenum)
//   gives an enumerator of the searches to be added to the search menu
//--------------------------------------------------------------------------
//
// IShellFolder2::GetDefaultColumnState values
typedef /* [public][v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0148_0001
    {	SHCOLSTATE_TYPE_STR	= 0x1,
	SHCOLSTATE_TYPE_INT	= 0x2,
	SHCOLSTATE_TYPE_DATE	= 0x3,
	SHCOLSTATE_TYPEMASK	= 0xf,
	SHCOLSTATE_ONBYDEFAULT	= 0x10,
	SHCOLSTATE_SLOW	= 0x20,
	SHCOLSTATE_EXTENDED	= 0x40,
	SHCOLSTATE_SECONDARYUI	= 0x80,
	SHCOLSTATE_HIDDEN	= 0x100
    } 	SHCOLSTATE;

typedef DWORD SHCOLSTATEF;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_shobjidl_0148_0002
    {
    GUID fmtid;
    DWORD pid;
    } 	SHCOLUMNID;

typedef struct __MIDL___MIDL_itf_shobjidl_0148_0002 *LPSHCOLUMNID;

typedef const SHCOLUMNID *LPCSHCOLUMNID;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0148_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0148_v0_0_s_ifspec;

#ifndef __IShellFolder2_INTERFACE_DEFINED__
#define __IShellFolder2_INTERFACE_DEFINED__

/* interface IShellFolder2 */
/* [unique][local][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellFolder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93F2F68C-1D1B-11d3-A30E-00C04F79ABD1")
    IShellFolder2 : public IShellFolder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSearchGUID( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSearches( 
            /* [out] */ IEnumExtraSearch **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumn( 
            DWORD dwRes,
            /* [out] */ ULONG *pSort,
            /* [out] */ ULONG *pDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumnState( 
            /* [in] */ UINT iColumn,
            /* [out] */ SHCOLSTATEF *pcsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDetailsEx( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ const SHCOLUMNID *pscid,
            /* [out] */ VARIANT *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDetailsOf( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ UINT iColumn,
            /* [out] */ SHELLDETAILS *psd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapColumnToSCID( 
            /* [in] */ UINT iColumn,
            /* [in] */ SHCOLUMNID *pscid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellFolder2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellFolder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellFolder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseDisplayName )( 
            IShellFolder2 * This,
            /* [in] */ HWND hwnd,
            /* [in] */ LPBC pbc,
            /* [string][in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG *pchEaten,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [out][in] */ ULONG *pdwAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            IShellFolder2 * This,
            /* [in] */ HWND hwnd,
            /* [in] */ SHCONTF grfFlags,
            /* [out] */ IEnumIDList **ppenumIDList);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IShellFolder2 * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ LPBC pbc,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *BindToStorage )( 
            IShellFolder2 * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ LPBC pbc,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CompareIDs )( 
            IShellFolder2 * This,
            /* [in] */ LPARAM lParam,
            /* [in] */ LPCITEMIDLIST pidl1,
            /* [in] */ LPCITEMIDLIST pidl2);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewObject )( 
            IShellFolder2 * This,
            /* [in] */ HWND hwndOwner,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributesOf )( 
            IShellFolder2 * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ LPCITEMIDLIST *apidl,
            /* [out][in] */ SFGAOF *rgfInOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIObjectOf )( 
            IShellFolder2 * This,
            /* [in] */ HWND hwndOwner,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ LPCITEMIDLIST *apidl,
            /* [in] */ REFIID riid,
            UINT *rgfReserved,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayNameOf )( 
            IShellFolder2 * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ LPSTRRET lpName);
        
        HRESULT ( STDMETHODCALLTYPE *SetNameOf )( 
            IShellFolder2 * This,
            /* [in] */ HWND hwnd,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [string][in] */ LPCOLESTR pszName,
            /* [in] */ SHGDNF uFlags,
            /* [out] */ LPITEMIDLIST *ppidlOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSearchGUID )( 
            IShellFolder2 * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSearches )( 
            IShellFolder2 * This,
            /* [out] */ IEnumExtraSearch **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumn )( 
            IShellFolder2 * This,
            DWORD dwRes,
            /* [out] */ ULONG *pSort,
            /* [out] */ ULONG *pDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnState )( 
            IShellFolder2 * This,
            /* [in] */ UINT iColumn,
            /* [out] */ SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailsEx )( 
            IShellFolder2 * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ const SHCOLUMNID *pscid,
            /* [out] */ VARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailsOf )( 
            IShellFolder2 * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ UINT iColumn,
            /* [out] */ SHELLDETAILS *psd);
        
        HRESULT ( STDMETHODCALLTYPE *MapColumnToSCID )( 
            IShellFolder2 * This,
            /* [in] */ UINT iColumn,
            /* [in] */ SHCOLUMNID *pscid);
        
        END_INTERFACE
    } IShellFolder2Vtbl;

    interface IShellFolder2
    {
        CONST_VTBL struct IShellFolder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolder2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellFolder2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellFolder2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellFolder2_ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes)	\
    (This)->lpVtbl -> ParseDisplayName(This,hwnd,pbc,pszDisplayName,pchEaten,ppidl,pdwAttributes)

#define IShellFolder2_EnumObjects(This,hwnd,grfFlags,ppenumIDList)	\
    (This)->lpVtbl -> EnumObjects(This,hwnd,grfFlags,ppenumIDList)

#define IShellFolder2_BindToObject(This,pidl,pbc,riid,ppv)	\
    (This)->lpVtbl -> BindToObject(This,pidl,pbc,riid,ppv)

#define IShellFolder2_BindToStorage(This,pidl,pbc,riid,ppv)	\
    (This)->lpVtbl -> BindToStorage(This,pidl,pbc,riid,ppv)

#define IShellFolder2_CompareIDs(This,lParam,pidl1,pidl2)	\
    (This)->lpVtbl -> CompareIDs(This,lParam,pidl1,pidl2)

#define IShellFolder2_CreateViewObject(This,hwndOwner,riid,ppv)	\
    (This)->lpVtbl -> CreateViewObject(This,hwndOwner,riid,ppv)

#define IShellFolder2_GetAttributesOf(This,cidl,apidl,rgfInOut)	\
    (This)->lpVtbl -> GetAttributesOf(This,cidl,apidl,rgfInOut)

#define IShellFolder2_GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv)	\
    (This)->lpVtbl -> GetUIObjectOf(This,hwndOwner,cidl,apidl,riid,rgfReserved,ppv)

#define IShellFolder2_GetDisplayNameOf(This,pidl,uFlags,lpName)	\
    (This)->lpVtbl -> GetDisplayNameOf(This,pidl,uFlags,lpName)

#define IShellFolder2_SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut)	\
    (This)->lpVtbl -> SetNameOf(This,hwnd,pidl,pszName,uFlags,ppidlOut)


#define IShellFolder2_GetDefaultSearchGUID(This,pguid)	\
    (This)->lpVtbl -> GetDefaultSearchGUID(This,pguid)

#define IShellFolder2_EnumSearches(This,ppenum)	\
    (This)->lpVtbl -> EnumSearches(This,ppenum)

#define IShellFolder2_GetDefaultColumn(This,dwRes,pSort,pDisplay)	\
    (This)->lpVtbl -> GetDefaultColumn(This,dwRes,pSort,pDisplay)

#define IShellFolder2_GetDefaultColumnState(This,iColumn,pcsFlags)	\
    (This)->lpVtbl -> GetDefaultColumnState(This,iColumn,pcsFlags)

#define IShellFolder2_GetDetailsEx(This,pidl,pscid,pv)	\
    (This)->lpVtbl -> GetDetailsEx(This,pidl,pscid,pv)

#define IShellFolder2_GetDetailsOf(This,pidl,iColumn,psd)	\
    (This)->lpVtbl -> GetDetailsOf(This,pidl,iColumn,psd)

#define IShellFolder2_MapColumnToSCID(This,iColumn,pscid)	\
    (This)->lpVtbl -> MapColumnToSCID(This,iColumn,pscid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellFolder2_GetDefaultSearchGUID_Proxy( 
    IShellFolder2 * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB IShellFolder2_GetDefaultSearchGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder2_EnumSearches_Proxy( 
    IShellFolder2 * This,
    /* [out] */ IEnumExtraSearch **ppenum);


void __RPC_STUB IShellFolder2_EnumSearches_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder2_GetDefaultColumn_Proxy( 
    IShellFolder2 * This,
    DWORD dwRes,
    /* [out] */ ULONG *pSort,
    /* [out] */ ULONG *pDisplay);


void __RPC_STUB IShellFolder2_GetDefaultColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder2_GetDefaultColumnState_Proxy( 
    IShellFolder2 * This,
    /* [in] */ UINT iColumn,
    /* [out] */ SHCOLSTATEF *pcsFlags);


void __RPC_STUB IShellFolder2_GetDefaultColumnState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder2_GetDetailsEx_Proxy( 
    IShellFolder2 * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ const SHCOLUMNID *pscid,
    /* [out] */ VARIANT *pv);


void __RPC_STUB IShellFolder2_GetDetailsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder2_GetDetailsOf_Proxy( 
    IShellFolder2 * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ UINT iColumn,
    /* [out] */ SHELLDETAILS *psd);


void __RPC_STUB IShellFolder2_GetDetailsOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolder2_MapColumnToSCID_Proxy( 
    IShellFolder2 * This,
    /* [in] */ UINT iColumn,
    /* [in] */ SHCOLUMNID *pscid);


void __RPC_STUB IShellFolder2_MapColumnToSCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellFolder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0149 */
/* [local] */ 

#endif // _WIN32_IE >= 0x0500)
//--------------------------------------------------------------------------
//
// FOLDERSETTINGS
//
//  FOLDERSETTINGS is a data structure that explorer passes from one folder
// view to another, when the user is browsing. It calls ISV::GetCurrentInfo
// member to get the current settings and pass it to ISV::CreateViewWindow
// to allow the next folder view 'inherit' it. These settings assumes a
// particular UI (which the shell's folder view has), and shell extensions
// may or may not use those settings.
//
//--------------------------------------------------------------------------
typedef char *LPVIEWSETTINGS;

// NB Bitfields.
// FWF_DESKTOP implies FWF_TRANSPARENT/NOCLIENTEDGE/NOSCROLL
typedef /* [public][v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0149_0001
    {	FWF_AUTOARRANGE	= 0x1,
	FWF_ABBREVIATEDNAMES	= 0x2,
	FWF_SNAPTOGRID	= 0x4,
	FWF_OWNERDATA	= 0x8,
	FWF_BESTFITWINDOW	= 0x10,
	FWF_DESKTOP	= 0x20,
	FWF_SINGLESEL	= 0x40,
	FWF_NOSUBFOLDERS	= 0x80,
	FWF_TRANSPARENT	= 0x100,
	FWF_NOCLIENTEDGE	= 0x200,
	FWF_NOSCROLL	= 0x400,
	FWF_ALIGNLEFT	= 0x800,
	FWF_NOICONS	= 0x1000,
	FWF_SHOWSELALWAYS	= 0x2000,
	FWF_NOVISIBLE	= 0x4000,
	FWF_SINGLECLICKACTIVATE	= 0x8000,
	FWF_NOWEBVIEW	= 0x10000,
	FWF_HIDEFILENAMES	= 0x20000
    } 	FOLDERFLAGS;

typedef /* [public][v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0149_0002
    {	FVM_FIRST	= 1,
	FVM_ICON	= 1,
	FVM_SMALLICON	= 2,
	FVM_LIST	= 3,
	FVM_DETAILS	= 4,
	FVM_THUMBNAIL	= 5,
	FVM_TILE	= 6,
	FVM_THUMBSTRIP	= 7,
	FVM_LAST	= 7
    } 	FOLDERVIEWMODE;

typedef /* [public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_shobjidl_0149_0003
    {
    UINT ViewMode;
    UINT fFlags;
    } 	FOLDERSETTINGS;

typedef FOLDERSETTINGS *LPFOLDERSETTINGS;

typedef const FOLDERSETTINGS *LPCFOLDERSETTINGS;

typedef FOLDERSETTINGS *PFOLDERSETTINGS;

#define SVSI_DESELECT   0x0000
#define SVSI_SELECT     0x0001
#define SVSI_EDIT       0x0003  // includes select
#define SVSI_DESELECTOTHERS 0x0004
#define SVSI_ENSUREVISIBLE  0x0008
#define SVSI_FOCUSED        0x0010
#define SVSI_TRANSLATEPT    0x0020
#define SVSI_SELECTIONMARK  0x0040
#define SVGIO_BACKGROUND    0x00000000
#define SVGIO_SELECTION     0x00000001
#define SVGIO_ALLVIEW       0x00000002
typedef /* [public][v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0149_0004
    {	SVUIA_DEACTIVATE	= 0,
	SVUIA_ACTIVATE_NOFOCUS	= 1,
	SVUIA_ACTIVATE_FOCUS	= 2,
	SVUIA_INPLACEACTIVATE	= 3
    } 	SVUIA_STATUS;

#ifdef _FIX_ENABLEMODELESS_CONFLICT
#define    EnableModeless EnableModelessSV
#endif
#ifdef _NEVER_
typedef LPARAM LPFNSVADDPROPSHEETPAGE;

#else //!_NEVER_
#include <prsht.h>
typedef LPFNADDPROPSHEETPAGE LPFNSVADDPROPSHEETPAGE;
#endif //_NEVER_



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0149_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0149_v0_0_s_ifspec;

#ifndef __IShellView_INTERFACE_DEFINED__
#define __IShellView_INTERFACE_DEFINED__

/* interface IShellView */
/* [unique][object][uuid][helpstring] */ 

typedef IShellView *LPSHELLVIEW;


EXTERN_C const IID IID_IShellView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E3-0000-0000-C000-000000000046")
    IShellView : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ LPMSG lpmsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UIActivate( 
            /* [in] */ UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewWindow( 
            /* [in] */ IShellView *psvPrevious,
            /* [in] */ LPCFOLDERSETTINGS lpfs,
            /* [in] */ IShellBrowser *psb,
            /* [out] */ RECT *prcView,
            /* [out] */ HWND *phWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyViewWindow( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentInfo( 
            /* [out] */ LPFOLDERSETTINGS lpfs) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddPropertySheetPages( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfn,
            /* [in] */ LPARAM lparam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveViewState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [in] */ LPCITEMIDLIST pidlItem,
            /* [in] */ UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemObject( 
            /* [in] */ UINT uItem,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellView * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IShellView * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IShellView * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IShellView * This,
            /* [in] */ LPMSG lpmsg);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IShellView * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            IShellView * This,
            /* [in] */ UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow )( 
            IShellView * This,
            /* [in] */ IShellView *psvPrevious,
            /* [in] */ LPCFOLDERSETTINGS lpfs,
            /* [in] */ IShellBrowser *psb,
            /* [out] */ RECT *prcView,
            /* [out] */ HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyViewWindow )( 
            IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentInfo )( 
            IShellView * This,
            /* [out] */ LPFOLDERSETTINGS lpfs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPages )( 
            IShellView * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfn,
            /* [in] */ LPARAM lparam);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            IShellView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IShellView * This,
            /* [in] */ LPCITEMIDLIST pidlItem,
            /* [in] */ UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemObject )( 
            IShellView * This,
            /* [in] */ UINT uItem,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        END_INTERFACE
    } IShellViewVtbl;

    interface IShellView
    {
        CONST_VTBL struct IShellViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellView_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IShellView_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IShellView_TranslateAccelerator(This,lpmsg)	\
    (This)->lpVtbl -> TranslateAccelerator(This,lpmsg)

#define IShellView_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#define IShellView_UIActivate(This,uState)	\
    (This)->lpVtbl -> UIActivate(This,uState)

#define IShellView_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IShellView_CreateViewWindow(This,psvPrevious,lpfs,psb,prcView,phWnd)	\
    (This)->lpVtbl -> CreateViewWindow(This,psvPrevious,lpfs,psb,prcView,phWnd)

#define IShellView_DestroyViewWindow(This)	\
    (This)->lpVtbl -> DestroyViewWindow(This)

#define IShellView_GetCurrentInfo(This,lpfs)	\
    (This)->lpVtbl -> GetCurrentInfo(This,lpfs)

#define IShellView_AddPropertySheetPages(This,dwReserved,pfn,lparam)	\
    (This)->lpVtbl -> AddPropertySheetPages(This,dwReserved,pfn,lparam)

#define IShellView_SaveViewState(This)	\
    (This)->lpVtbl -> SaveViewState(This)

#define IShellView_SelectItem(This,pidlItem,uFlags)	\
    (This)->lpVtbl -> SelectItem(This,pidlItem,uFlags)

#define IShellView_GetItemObject(This,uItem,riid,ppv)	\
    (This)->lpVtbl -> GetItemObject(This,uItem,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellView_TranslateAccelerator_Proxy( 
    IShellView * This,
    /* [in] */ LPMSG lpmsg);


void __RPC_STUB IShellView_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_EnableModeless_Proxy( 
    IShellView * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IShellView_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_UIActivate_Proxy( 
    IShellView * This,
    /* [in] */ UINT uState);


void __RPC_STUB IShellView_UIActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_Refresh_Proxy( 
    IShellView * This);


void __RPC_STUB IShellView_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_CreateViewWindow_Proxy( 
    IShellView * This,
    /* [in] */ IShellView *psvPrevious,
    /* [in] */ LPCFOLDERSETTINGS lpfs,
    /* [in] */ IShellBrowser *psb,
    /* [out] */ RECT *prcView,
    /* [out] */ HWND *phWnd);


void __RPC_STUB IShellView_CreateViewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_DestroyViewWindow_Proxy( 
    IShellView * This);


void __RPC_STUB IShellView_DestroyViewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_GetCurrentInfo_Proxy( 
    IShellView * This,
    /* [out] */ LPFOLDERSETTINGS lpfs);


void __RPC_STUB IShellView_GetCurrentInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IShellView_AddPropertySheetPages_Proxy( 
    IShellView * This,
    /* [in] */ DWORD dwReserved,
    /* [in] */ LPFNSVADDPROPSHEETPAGE pfn,
    /* [in] */ LPARAM lparam);


void __RPC_STUB IShellView_AddPropertySheetPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_SaveViewState_Proxy( 
    IShellView * This);


void __RPC_STUB IShellView_SaveViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_SelectItem_Proxy( 
    IShellView * This,
    /* [in] */ LPCITEMIDLIST pidlItem,
    /* [in] */ UINT uFlags);


void __RPC_STUB IShellView_SelectItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView_GetItemObject_Proxy( 
    IShellView * This,
    /* [in] */ UINT uItem,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IShellView_GetItemObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellView_INTERFACE_DEFINED__ */


#ifndef __IShellView2_INTERFACE_DEFINED__
#define __IShellView2_INTERFACE_DEFINED__

/* interface IShellView2 */
/* [unique][object][uuid][helpstring] */ 

typedef GUID SHELLVIEWID;

#define SV2GV_CURRENTVIEW ((UINT)-1)
#define SV2GV_DEFAULTVIEW ((UINT)-2)
#include <pshpack8.h>
typedef struct _SV2CVW2_PARAMS
    {
    DWORD cbSize;
    IShellView *psvPrev;
    LPCFOLDERSETTINGS pfs;
    IShellBrowser *psbOwner;
    RECT *prcView;
    const SHELLVIEWID *pvid;
    HWND hwndView;
    } 	SV2CVW2_PARAMS;

typedef struct _SV2CVW2_PARAMS *LPSV2CVW2_PARAMS;

#include <poppack.h>

EXTERN_C const IID IID_IShellView2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88E39E80-3578-11CF-AE69-08002B2E1262")
    IShellView2 : public IShellView
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetView( 
            /* [out][in] */ SHELLVIEWID *pvid,
            /* [in] */ ULONG uView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateViewWindow2( 
            /* [in] */ LPSV2CVW2_PARAMS lpParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleRename( 
            /* [in] */ LPCITEMIDLIST pidlNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndPositionItem( 
            /* [in] */ LPCITEMIDLIST pidlItem,
            /* [in] */ UINT uFlags,
            /* [in] */ POINT *ppt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellView2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellView2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellView2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellView2 * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IShellView2 * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IShellView2 * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IShellView2 * This,
            /* [in] */ LPMSG lpmsg);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IShellView2 * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            IShellView2 * This,
            /* [in] */ UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow )( 
            IShellView2 * This,
            /* [in] */ IShellView *psvPrevious,
            /* [in] */ LPCFOLDERSETTINGS lpfs,
            /* [in] */ IShellBrowser *psb,
            /* [out] */ RECT *prcView,
            /* [out] */ HWND *phWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyViewWindow )( 
            IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentInfo )( 
            IShellView2 * This,
            /* [out] */ LPFOLDERSETTINGS lpfs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPages )( 
            IShellView2 * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfn,
            /* [in] */ LPARAM lparam);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            IShellView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IShellView2 * This,
            /* [in] */ LPCITEMIDLIST pidlItem,
            /* [in] */ UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemObject )( 
            IShellView2 * This,
            /* [in] */ UINT uItem,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetView )( 
            IShellView2 * This,
            /* [out][in] */ SHELLVIEWID *pvid,
            /* [in] */ ULONG uView);
        
        HRESULT ( STDMETHODCALLTYPE *CreateViewWindow2 )( 
            IShellView2 * This,
            /* [in] */ LPSV2CVW2_PARAMS lpParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleRename )( 
            IShellView2 * This,
            /* [in] */ LPCITEMIDLIST pidlNew);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndPositionItem )( 
            IShellView2 * This,
            /* [in] */ LPCITEMIDLIST pidlItem,
            /* [in] */ UINT uFlags,
            /* [in] */ POINT *ppt);
        
        END_INTERFACE
    } IShellView2Vtbl;

    interface IShellView2
    {
        CONST_VTBL struct IShellView2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellView2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellView2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellView2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellView2_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IShellView2_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IShellView2_TranslateAccelerator(This,lpmsg)	\
    (This)->lpVtbl -> TranslateAccelerator(This,lpmsg)

#define IShellView2_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#define IShellView2_UIActivate(This,uState)	\
    (This)->lpVtbl -> UIActivate(This,uState)

#define IShellView2_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IShellView2_CreateViewWindow(This,psvPrevious,lpfs,psb,prcView,phWnd)	\
    (This)->lpVtbl -> CreateViewWindow(This,psvPrevious,lpfs,psb,prcView,phWnd)

#define IShellView2_DestroyViewWindow(This)	\
    (This)->lpVtbl -> DestroyViewWindow(This)

#define IShellView2_GetCurrentInfo(This,lpfs)	\
    (This)->lpVtbl -> GetCurrentInfo(This,lpfs)

#define IShellView2_AddPropertySheetPages(This,dwReserved,pfn,lparam)	\
    (This)->lpVtbl -> AddPropertySheetPages(This,dwReserved,pfn,lparam)

#define IShellView2_SaveViewState(This)	\
    (This)->lpVtbl -> SaveViewState(This)

#define IShellView2_SelectItem(This,pidlItem,uFlags)	\
    (This)->lpVtbl -> SelectItem(This,pidlItem,uFlags)

#define IShellView2_GetItemObject(This,uItem,riid,ppv)	\
    (This)->lpVtbl -> GetItemObject(This,uItem,riid,ppv)


#define IShellView2_GetView(This,pvid,uView)	\
    (This)->lpVtbl -> GetView(This,pvid,uView)

#define IShellView2_CreateViewWindow2(This,lpParams)	\
    (This)->lpVtbl -> CreateViewWindow2(This,lpParams)

#define IShellView2_HandleRename(This,pidlNew)	\
    (This)->lpVtbl -> HandleRename(This,pidlNew)

#define IShellView2_SelectAndPositionItem(This,pidlItem,uFlags,ppt)	\
    (This)->lpVtbl -> SelectAndPositionItem(This,pidlItem,uFlags,ppt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellView2_GetView_Proxy( 
    IShellView2 * This,
    /* [out][in] */ SHELLVIEWID *pvid,
    /* [in] */ ULONG uView);


void __RPC_STUB IShellView2_GetView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView2_CreateViewWindow2_Proxy( 
    IShellView2 * This,
    /* [in] */ LPSV2CVW2_PARAMS lpParams);


void __RPC_STUB IShellView2_CreateViewWindow2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView2_HandleRename_Proxy( 
    IShellView2 * This,
    /* [in] */ LPCITEMIDLIST pidlNew);


void __RPC_STUB IShellView2_HandleRename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellView2_SelectAndPositionItem_Proxy( 
    IShellView2 * This,
    /* [in] */ LPCITEMIDLIST pidlItem,
    /* [in] */ UINT uFlags,
    /* [in] */ POINT *ppt);


void __RPC_STUB IShellView2_SelectAndPositionItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellView2_INTERFACE_DEFINED__ */


#ifndef __IFolderView_INTERFACE_DEFINED__
#define __IFolderView_INTERFACE_DEFINED__

/* interface IFolderView */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IFolderView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79ed5811-705c-4d33-af5f-b215f4bb645f")
    IFolderView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentViewMode( 
            /* [out][in] */ UINT *pViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentViewMode( 
            /* [in] */ UINT ViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolder( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemCount( 
            /* [in] */ int *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ int iItemIndex,
            /* [out] */ LPITEMIDLIST *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectedItem( 
            /* [out] */ int *piItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [in] */ int iItem,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentViewMode )( 
            IFolderView * This,
            /* [out][in] */ UINT *pViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentViewMode )( 
            IFolderView * This,
            /* [in] */ UINT ViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            IFolderView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *ItemCount )( 
            IFolderView * This,
            /* [in] */ int *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IFolderView * This,
            /* [in] */ int iItemIndex,
            /* [out] */ LPITEMIDLIST *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *SelectedItem )( 
            IFolderView * This,
            /* [out] */ int *piItem);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IFolderView * This,
            /* [in] */ int iItem,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IFolderViewVtbl;

    interface IFolderView
    {
        CONST_VTBL struct IFolderViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFolderView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFolderView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFolderView_GetCurrentViewMode(This,pViewMode)	\
    (This)->lpVtbl -> GetCurrentViewMode(This,pViewMode)

#define IFolderView_SetCurrentViewMode(This,ViewMode)	\
    (This)->lpVtbl -> SetCurrentViewMode(This,ViewMode)

#define IFolderView_GetFolder(This,riid,ppv)	\
    (This)->lpVtbl -> GetFolder(This,riid,ppv)

#define IFolderView_ItemCount(This,pcItems)	\
    (This)->lpVtbl -> ItemCount(This,pcItems)

#define IFolderView_Item(This,iItemIndex,ppidl)	\
    (This)->lpVtbl -> Item(This,iItemIndex,ppidl)

#define IFolderView_SelectedItem(This,piItem)	\
    (This)->lpVtbl -> SelectedItem(This,piItem)

#define IFolderView_SelectItem(This,iItem,dwFlags)	\
    (This)->lpVtbl -> SelectItem(This,iItem,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFolderView_GetCurrentViewMode_Proxy( 
    IFolderView * This,
    /* [out][in] */ UINT *pViewMode);


void __RPC_STUB IFolderView_GetCurrentViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderView_SetCurrentViewMode_Proxy( 
    IFolderView * This,
    /* [in] */ UINT ViewMode);


void __RPC_STUB IFolderView_SetCurrentViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderView_GetFolder_Proxy( 
    IFolderView * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IFolderView_GetFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderView_ItemCount_Proxy( 
    IFolderView * This,
    /* [in] */ int *pcItems);


void __RPC_STUB IFolderView_ItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderView_Item_Proxy( 
    IFolderView * This,
    /* [in] */ int iItemIndex,
    /* [out] */ LPITEMIDLIST *ppidl);


void __RPC_STUB IFolderView_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderView_SelectedItem_Proxy( 
    IFolderView * This,
    /* [out] */ int *piItem);


void __RPC_STUB IFolderView_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderView_SelectItem_Proxy( 
    IFolderView * This,
    /* [in] */ int iItem,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IFolderView_SelectItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolderView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0152 */
/* [local] */ 

#ifdef _FIX_ENABLEMODELESS_CONFLICT
#undef    EnableModeless 
#endif
//
// IShellBrowser::BrowseObject(pidl, wFlags)
//
//   The view calls this member to let shell explorer browse to another
//  folder. The pidl and wFlags specifies the folder to be browsed.
#define SBSP_DEFBROWSER         0x0000
#define SBSP_SAMEBROWSER        0x0001
#define SBSP_NEWBROWSER         0x0002
#define SBSP_DEFMODE            0x0000
#define SBSP_OPENMODE           0x0010
#define SBSP_EXPLOREMODE        0x0020
#define SBSP_HELPMODE           0x0040 // IEUNIX : Help window uses this.
#define SBSP_NOTRANSFERHIST     0x0080
#define SBSP_ABSOLUTE           0x0000
#define SBSP_RELATIVE           0x1000
#define SBSP_PARENT             0x2000
#define SBSP_NAVIGATEBACK       0x4000
#define SBSP_NAVIGATEFORWARD    0x8000
#define SBSP_ALLOW_AUTONAVIGATE 0x10000
#define SBSP_NOAUTOSELECT       0x04000000
#define SBSP_WRITENOHISTORY     0x08000000
#define SBSP_REDIRECT                     0x40000000
#define SBSP_INITIATEDBYHLINKFRAME        0x80000000
#define FCW_STATUS      0x0001
#define FCW_TOOLBAR     0x0002
#define FCW_TREE        0x0003
#define FCW_INTERNETBAR 0x0006
#define FCW_PROGRESS    0x0008
#define FCT_MERGE       0x0001
#define FCT_CONFIGABLE  0x0002
#define FCT_ADDTOEND    0x0004
#ifdef _NEVER_
typedef LPARAM LPTBBUTTONSB;

#else //!_NEVER_
#include <commctrl.h>
typedef LPTBBUTTON LPTBBUTTONSB;
#endif //_NEVER_


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0152_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0152_v0_0_s_ifspec;

#ifndef __IShellBrowser_INTERFACE_DEFINED__
#define __IShellBrowser_INTERFACE_DEFINED__

/* interface IShellBrowser */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E2-0000-0000-C000-000000000046")
    IShellBrowser : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertMenusSB( 
            /* [in] */ HMENU hmenuShared,
            /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenuSB( 
            /* [in] */ HMENU hmenuShared,
            /* [in] */ HOLEMENU holemenuRes,
            /* [in] */ HWND hwndActiveObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMenusSB( 
            /* [in] */ HMENU hmenuShared) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusTextSB( 
            /* [unique][in] */ LPCOLESTR pszStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModelessSB( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorSB( 
            /* [in] */ MSG *pmsg,
            /* [in] */ WORD wID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BrowseObject( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ UINT wFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewStateStream( 
            /* [in] */ DWORD grfMode,
            /* [out] */ IStream **ppStrm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlWindow( 
            /* [in] */ UINT id,
            /* [out] */ HWND *lphwnd) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SendControlMsg( 
            /* [in] */ UINT id,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ LRESULT *pret) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryActiveShellView( 
            /* [in] */ IShellView **ppshv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnViewWindowActive( 
            /* [in] */ IShellView *pshv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetToolbarItems( 
            /* [in] */ LPTBBUTTONSB lpButtons,
            /* [in] */ UINT nButtons,
            /* [in] */ UINT uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellBrowser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellBrowser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellBrowser * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IShellBrowser * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IShellBrowser * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *InsertMenusSB )( 
            IShellBrowser * This,
            /* [in] */ HMENU hmenuShared,
            /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuSB )( 
            IShellBrowser * This,
            /* [in] */ HMENU hmenuShared,
            /* [in] */ HOLEMENU holemenuRes,
            /* [in] */ HWND hwndActiveObject);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMenusSB )( 
            IShellBrowser * This,
            /* [in] */ HMENU hmenuShared);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusTextSB )( 
            IShellBrowser * This,
            /* [unique][in] */ LPCOLESTR pszStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModelessSB )( 
            IShellBrowser * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAcceleratorSB )( 
            IShellBrowser * This,
            /* [in] */ MSG *pmsg,
            /* [in] */ WORD wID);
        
        HRESULT ( STDMETHODCALLTYPE *BrowseObject )( 
            IShellBrowser * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ UINT wFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewStateStream )( 
            IShellBrowser * This,
            /* [in] */ DWORD grfMode,
            /* [out] */ IStream **ppStrm);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlWindow )( 
            IShellBrowser * This,
            /* [in] */ UINT id,
            /* [out] */ HWND *lphwnd);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SendControlMsg )( 
            IShellBrowser * This,
            /* [in] */ UINT id,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ LRESULT *pret);
        
        HRESULT ( STDMETHODCALLTYPE *QueryActiveShellView )( 
            IShellBrowser * This,
            /* [in] */ IShellView **ppshv);
        
        HRESULT ( STDMETHODCALLTYPE *OnViewWindowActive )( 
            IShellBrowser * This,
            /* [in] */ IShellView *pshv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetToolbarItems )( 
            IShellBrowser * This,
            /* [in] */ LPTBBUTTONSB lpButtons,
            /* [in] */ UINT nButtons,
            /* [in] */ UINT uFlags);
        
        END_INTERFACE
    } IShellBrowserVtbl;

    interface IShellBrowser
    {
        CONST_VTBL struct IShellBrowserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellBrowser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellBrowser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellBrowser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellBrowser_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IShellBrowser_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IShellBrowser_InsertMenusSB(This,hmenuShared,lpMenuWidths)	\
    (This)->lpVtbl -> InsertMenusSB(This,hmenuShared,lpMenuWidths)

#define IShellBrowser_SetMenuSB(This,hmenuShared,holemenuRes,hwndActiveObject)	\
    (This)->lpVtbl -> SetMenuSB(This,hmenuShared,holemenuRes,hwndActiveObject)

#define IShellBrowser_RemoveMenusSB(This,hmenuShared)	\
    (This)->lpVtbl -> RemoveMenusSB(This,hmenuShared)

#define IShellBrowser_SetStatusTextSB(This,pszStatusText)	\
    (This)->lpVtbl -> SetStatusTextSB(This,pszStatusText)

#define IShellBrowser_EnableModelessSB(This,fEnable)	\
    (This)->lpVtbl -> EnableModelessSB(This,fEnable)

#define IShellBrowser_TranslateAcceleratorSB(This,pmsg,wID)	\
    (This)->lpVtbl -> TranslateAcceleratorSB(This,pmsg,wID)

#define IShellBrowser_BrowseObject(This,pidl,wFlags)	\
    (This)->lpVtbl -> BrowseObject(This,pidl,wFlags)

#define IShellBrowser_GetViewStateStream(This,grfMode,ppStrm)	\
    (This)->lpVtbl -> GetViewStateStream(This,grfMode,ppStrm)

#define IShellBrowser_GetControlWindow(This,id,lphwnd)	\
    (This)->lpVtbl -> GetControlWindow(This,id,lphwnd)

#define IShellBrowser_SendControlMsg(This,id,uMsg,wParam,lParam,pret)	\
    (This)->lpVtbl -> SendControlMsg(This,id,uMsg,wParam,lParam,pret)

#define IShellBrowser_QueryActiveShellView(This,ppshv)	\
    (This)->lpVtbl -> QueryActiveShellView(This,ppshv)

#define IShellBrowser_OnViewWindowActive(This,pshv)	\
    (This)->lpVtbl -> OnViewWindowActive(This,pshv)

#define IShellBrowser_SetToolbarItems(This,lpButtons,nButtons,uFlags)	\
    (This)->lpVtbl -> SetToolbarItems(This,lpButtons,nButtons,uFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellBrowser_InsertMenusSB_Proxy( 
    IShellBrowser * This,
    /* [in] */ HMENU hmenuShared,
    /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths);


void __RPC_STUB IShellBrowser_InsertMenusSB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_SetMenuSB_Proxy( 
    IShellBrowser * This,
    /* [in] */ HMENU hmenuShared,
    /* [in] */ HOLEMENU holemenuRes,
    /* [in] */ HWND hwndActiveObject);


void __RPC_STUB IShellBrowser_SetMenuSB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_RemoveMenusSB_Proxy( 
    IShellBrowser * This,
    /* [in] */ HMENU hmenuShared);


void __RPC_STUB IShellBrowser_RemoveMenusSB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_SetStatusTextSB_Proxy( 
    IShellBrowser * This,
    /* [unique][in] */ LPCOLESTR pszStatusText);


void __RPC_STUB IShellBrowser_SetStatusTextSB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_EnableModelessSB_Proxy( 
    IShellBrowser * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IShellBrowser_EnableModelessSB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_TranslateAcceleratorSB_Proxy( 
    IShellBrowser * This,
    /* [in] */ MSG *pmsg,
    /* [in] */ WORD wID);


void __RPC_STUB IShellBrowser_TranslateAcceleratorSB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_BrowseObject_Proxy( 
    IShellBrowser * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ UINT wFlags);


void __RPC_STUB IShellBrowser_BrowseObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_GetViewStateStream_Proxy( 
    IShellBrowser * This,
    /* [in] */ DWORD grfMode,
    /* [out] */ IStream **ppStrm);


void __RPC_STUB IShellBrowser_GetViewStateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_GetControlWindow_Proxy( 
    IShellBrowser * This,
    /* [in] */ UINT id,
    /* [out] */ HWND *lphwnd);


void __RPC_STUB IShellBrowser_GetControlWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IShellBrowser_SendControlMsg_Proxy( 
    IShellBrowser * This,
    /* [in] */ UINT id,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ LRESULT *pret);


void __RPC_STUB IShellBrowser_SendControlMsg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_QueryActiveShellView_Proxy( 
    IShellBrowser * This,
    /* [in] */ IShellView **ppshv);


void __RPC_STUB IShellBrowser_QueryActiveShellView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellBrowser_OnViewWindowActive_Proxy( 
    IShellBrowser * This,
    /* [in] */ IShellView *pshv);


void __RPC_STUB IShellBrowser_OnViewWindowActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IShellBrowser_SetToolbarItems_Proxy( 
    IShellBrowser * This,
    /* [in] */ LPTBBUTTONSB lpButtons,
    /* [in] */ UINT nButtons,
    /* [in] */ UINT uFlags);


void __RPC_STUB IShellBrowser_SetToolbarItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellBrowser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0153 */
/* [local] */ 

typedef IShellBrowser *LPSHELLBROWSER;

#define SNCF_IGNORERAS   0x00000001


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0153_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0153_v0_0_s_ifspec;

#ifndef __IShellNetCrawler_INTERFACE_DEFINED__
#define __IShellNetCrawler_INTERFACE_DEFINED__

/* interface IShellNetCrawler */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellNetCrawler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49c929ee-a1b7-4c58-b539-e63be392b6f3")
    IShellNetCrawler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellNetCrawlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellNetCrawler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellNetCrawler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellNetCrawler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IShellNetCrawler * This,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IShellNetCrawlerVtbl;

    interface IShellNetCrawler
    {
        CONST_VTBL struct IShellNetCrawlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellNetCrawler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellNetCrawler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellNetCrawler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellNetCrawler_Update(This,dwFlags)	\
    (This)->lpVtbl -> Update(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellNetCrawler_Update_Proxy( 
    IShellNetCrawler * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IShellNetCrawler_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellNetCrawler_INTERFACE_DEFINED__ */


#ifndef __IProfferService_INTERFACE_DEFINED__
#define __IProfferService_INTERFACE_DEFINED__

/* interface IProfferService */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IProfferService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb728b20-f786-11ce-92ad-00aa00a74cd0")
    IProfferService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProfferService( 
            /* [in] */ REFGUID rguidService,
            /* [in] */ IServiceProvider *psp,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeService( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProfferServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProfferService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProfferService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProfferService * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProfferService )( 
            IProfferService * This,
            /* [in] */ REFGUID rguidService,
            /* [in] */ IServiceProvider *psp,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *RevokeService )( 
            IProfferService * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IProfferServiceVtbl;

    interface IProfferService
    {
        CONST_VTBL struct IProfferServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProfferService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProfferService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProfferService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProfferService_ProfferService(This,rguidService,psp,pdwCookie)	\
    (This)->lpVtbl -> ProfferService(This,rguidService,psp,pdwCookie)

#define IProfferService_RevokeService(This,dwCookie)	\
    (This)->lpVtbl -> RevokeService(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProfferService_ProfferService_Proxy( 
    IProfferService * This,
    /* [in] */ REFGUID rguidService,
    /* [in] */ IServiceProvider *psp,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB IProfferService_ProfferService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProfferService_RevokeService_Proxy( 
    IProfferService * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IProfferService_RevokeService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProfferService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0155 */
/* [local] */ 

#define SID_SProfferService IID_IProfferService    // nearest service that you can proffer to
typedef /* [v1_enum] */ 
enum _CFITYPE
    {	CFITYPE_CSIDL	= 0,
	CFITYPE_PIDL	= CFITYPE_CSIDL + 1,
	CFITYPE_PATH	= CFITYPE_PIDL + 1
    } 	CFITYPE;

/* [v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0155_0001
    {	CFINITF_CHILDREN	= 0,
	CFINITF_FLAT	= 0x1
    } ;
typedef UINT CFINITF;

typedef struct _COMPFOLDERINIT
    {
    UINT uType;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ int csidl;
        /* [case()] */ LPCITEMIDLIST pidl;
        /* [case()][string] */ LPOLESTR pszPath;
        } 	DUMMYUNIONNAME;
    LPOLESTR pszName;
    } 	COMPFOLDERINIT;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0155_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0155_v0_0_s_ifspec;

#ifndef __ICompositeFolder_INTERFACE_DEFINED__
#define __ICompositeFolder_INTERFACE_DEFINED__

/* interface ICompositeFolder */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ICompositeFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("601ac3dd-786a-4eb0-bf40-ee3521e70bfb")
    ICompositeFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitComposite( 
            /* [in] */ WORD wSignature,
            /* [in] */ REFCLSID refclsid,
            /* [in] */ CFINITF flags,
            /* [in] */ ULONG celt,
            /* [size_is][in] */ const COMPFOLDERINIT *rgCFs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToParent( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv,
            /* [out] */ LPITEMIDLIST *ppidlLast) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICompositeFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICompositeFolder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICompositeFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICompositeFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitComposite )( 
            ICompositeFolder * This,
            /* [in] */ WORD wSignature,
            /* [in] */ REFCLSID refclsid,
            /* [in] */ CFINITF flags,
            /* [in] */ ULONG celt,
            /* [size_is][in] */ const COMPFOLDERINIT *rgCFs);
        
        HRESULT ( STDMETHODCALLTYPE *BindToParent )( 
            ICompositeFolder * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv,
            /* [out] */ LPITEMIDLIST *ppidlLast);
        
        END_INTERFACE
    } ICompositeFolderVtbl;

    interface ICompositeFolder
    {
        CONST_VTBL struct ICompositeFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICompositeFolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICompositeFolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICompositeFolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICompositeFolder_InitComposite(This,wSignature,refclsid,flags,celt,rgCFs)	\
    (This)->lpVtbl -> InitComposite(This,wSignature,refclsid,flags,celt,rgCFs)

#define ICompositeFolder_BindToParent(This,pidl,riid,ppv,ppidlLast)	\
    (This)->lpVtbl -> BindToParent(This,pidl,riid,ppv,ppidlLast)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICompositeFolder_InitComposite_Proxy( 
    ICompositeFolder * This,
    /* [in] */ WORD wSignature,
    /* [in] */ REFCLSID refclsid,
    /* [in] */ CFINITF flags,
    /* [in] */ ULONG celt,
    /* [size_is][in] */ const COMPFOLDERINIT *rgCFs);


void __RPC_STUB ICompositeFolder_InitComposite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICompositeFolder_BindToParent_Proxy( 
    ICompositeFolder * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv,
    /* [out] */ LPITEMIDLIST *ppidlLast);


void __RPC_STUB ICompositeFolder_BindToParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICompositeFolder_INTERFACE_DEFINED__ */


#ifndef __IParentAndItem_INTERFACE_DEFINED__
#define __IParentAndItem_INTERFACE_DEFINED__

/* interface IParentAndItem */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IParentAndItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3a4b685-b685-4805-99d9-5dead2873236")
    IParentAndItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetParentAndItem( 
            /* [in] */ LPCITEMIDLIST pidlParent,
            /* [in] */ IShellFolder *psf,
            /* [in] */ LPCITEMIDLIST pidlChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentAndItem( 
            /* [out] */ LPITEMIDLIST *ppidlParent,
            /* [out] */ IShellFolder **ppsf,
            /* [out] */ LPITEMIDLIST *ppidlChild) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParentAndItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IParentAndItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IParentAndItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IParentAndItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetParentAndItem )( 
            IParentAndItem * This,
            /* [in] */ LPCITEMIDLIST pidlParent,
            /* [in] */ IShellFolder *psf,
            /* [in] */ LPCITEMIDLIST pidlChild);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentAndItem )( 
            IParentAndItem * This,
            /* [out] */ LPITEMIDLIST *ppidlParent,
            /* [out] */ IShellFolder **ppsf,
            /* [out] */ LPITEMIDLIST *ppidlChild);
        
        END_INTERFACE
    } IParentAndItemVtbl;

    interface IParentAndItem
    {
        CONST_VTBL struct IParentAndItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParentAndItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IParentAndItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IParentAndItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IParentAndItem_SetParentAndItem(This,pidlParent,psf,pidlChild)	\
    (This)->lpVtbl -> SetParentAndItem(This,pidlParent,psf,pidlChild)

#define IParentAndItem_GetParentAndItem(This,ppidlParent,ppsf,ppidlChild)	\
    (This)->lpVtbl -> GetParentAndItem(This,ppidlParent,ppsf,ppidlChild)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IParentAndItem_SetParentAndItem_Proxy( 
    IParentAndItem * This,
    /* [in] */ LPCITEMIDLIST pidlParent,
    /* [in] */ IShellFolder *psf,
    /* [in] */ LPCITEMIDLIST pidlChild);


void __RPC_STUB IParentAndItem_SetParentAndItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IParentAndItem_GetParentAndItem_Proxy( 
    IParentAndItem * This,
    /* [out] */ LPITEMIDLIST *ppidlParent,
    /* [out] */ IShellFolder **ppsf,
    /* [out] */ LPITEMIDLIST *ppidlChild);


void __RPC_STUB IParentAndItem_GetParentAndItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IParentAndItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0157 */
/* [local] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0157_0001
    {	PUIF_DEFAULT	= 0,
	PUIF_RIGHTALIGN	= 0x1,
	PUIF_NOLABELININFOTIP	= 0x2
    } 	PROPERTYUI_FLAGS;

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0157_0002
    {	PUIFFDF_DEFAULT	= 0,
	PUIFFDF_RIGHTTOLEFT	= 0x1,
	PUIFFDF_SHORTFORMAT	= 0x2,
	PUIFFDF_NOTIME	= 0x4,
	PUIFFDF_FRIENDLYDATE	= 0x8,
	PUIFFDF_NOUNITS	= 0x10
    } 	PROPERTYUI_FORMAT_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0157_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0157_v0_0_s_ifspec;

#ifndef __IPropertyUI_INTERFACE_DEFINED__
#define __IPropertyUI_INTERFACE_DEFINED__

/* interface IPropertyUI */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IPropertyUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d43eacec-eaaf-4aae-ba46-eecba97d988a")
    IPropertyUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParsePropertyName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ FMTID *pfmtid,
            /* [out] */ PROPID *ppid,
            /* [out] */ ULONG *pchEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCannonicalName( 
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescription( 
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultWidth( 
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ ULONG *pcxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ PROPERTYUI_FLAGS *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ const VARIANT *pvar,
            /* [in] */ PROPERTYUI_FORMAT_FLAGS flags,
            /* [size_is][out] */ LPWSTR pwszText,
            /* [in] */ DWORD cchText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyUI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParsePropertyName )( 
            IPropertyUI * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ FMTID *pfmtid,
            /* [out] */ PROPID *ppid,
            /* [out] */ ULONG *pchEaten);
        
        HRESULT ( STDMETHODCALLTYPE *GetCannonicalName )( 
            IPropertyUI * This,
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IPropertyUI * This,
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescription )( 
            IPropertyUI * This,
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [size_is][out] */ LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultWidth )( 
            IPropertyUI * This,
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ ULONG *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IPropertyUI * This,
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [out] */ PROPERTYUI_FLAGS *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertyUI * This,
            /* [in] */ REFFMTID fmtid,
            /* [in] */ PROPID pid,
            /* [in] */ const VARIANT *pvar,
            /* [in] */ PROPERTYUI_FORMAT_FLAGS flags,
            /* [size_is][out] */ LPWSTR pwszText,
            /* [in] */ DWORD cchText);
        
        END_INTERFACE
    } IPropertyUIVtbl;

    interface IPropertyUI
    {
        CONST_VTBL struct IPropertyUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyUI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyUI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyUI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyUI_ParsePropertyName(This,pszName,pfmtid,ppid,pchEaten)	\
    (This)->lpVtbl -> ParsePropertyName(This,pszName,pfmtid,ppid,pchEaten)

#define IPropertyUI_GetCannonicalName(This,fmtid,pid,pwszText,cchText)	\
    (This)->lpVtbl -> GetCannonicalName(This,fmtid,pid,pwszText,cchText)

#define IPropertyUI_GetDisplayName(This,fmtid,pid,pwszText,cchText)	\
    (This)->lpVtbl -> GetDisplayName(This,fmtid,pid,pwszText,cchText)

#define IPropertyUI_GetPropertyDescription(This,fmtid,pid,pwszText,cchText)	\
    (This)->lpVtbl -> GetPropertyDescription(This,fmtid,pid,pwszText,cchText)

#define IPropertyUI_GetDefaultWidth(This,fmtid,pid,pcxChars)	\
    (This)->lpVtbl -> GetDefaultWidth(This,fmtid,pid,pcxChars)

#define IPropertyUI_GetFlags(This,fmtid,pid,pFlags)	\
    (This)->lpVtbl -> GetFlags(This,fmtid,pid,pFlags)

#define IPropertyUI_FormatForDisplay(This,fmtid,pid,pvar,flags,pwszText,cchText)	\
    (This)->lpVtbl -> FormatForDisplay(This,fmtid,pid,pvar,flags,pwszText,cchText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyUI_ParsePropertyName_Proxy( 
    IPropertyUI * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ FMTID *pfmtid,
    /* [out] */ PROPID *ppid,
    /* [out] */ ULONG *pchEaten);


void __RPC_STUB IPropertyUI_ParsePropertyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyUI_GetCannonicalName_Proxy( 
    IPropertyUI * This,
    /* [in] */ REFFMTID fmtid,
    /* [in] */ PROPID pid,
    /* [size_is][out] */ LPWSTR pwszText,
    /* [in] */ DWORD cchText);


void __RPC_STUB IPropertyUI_GetCannonicalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyUI_GetDisplayName_Proxy( 
    IPropertyUI * This,
    /* [in] */ REFFMTID fmtid,
    /* [in] */ PROPID pid,
    /* [size_is][out] */ LPWSTR pwszText,
    /* [in] */ DWORD cchText);


void __RPC_STUB IPropertyUI_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyUI_GetPropertyDescription_Proxy( 
    IPropertyUI * This,
    /* [in] */ REFFMTID fmtid,
    /* [in] */ PROPID pid,
    /* [size_is][out] */ LPWSTR pwszText,
    /* [in] */ DWORD cchText);


void __RPC_STUB IPropertyUI_GetPropertyDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyUI_GetDefaultWidth_Proxy( 
    IPropertyUI * This,
    /* [in] */ REFFMTID fmtid,
    /* [in] */ PROPID pid,
    /* [out] */ ULONG *pcxChars);


void __RPC_STUB IPropertyUI_GetDefaultWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyUI_GetFlags_Proxy( 
    IPropertyUI * This,
    /* [in] */ REFFMTID fmtid,
    /* [in] */ PROPID pid,
    /* [out] */ PROPERTYUI_FLAGS *pFlags);


void __RPC_STUB IPropertyUI_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyUI_FormatForDisplay_Proxy( 
    IPropertyUI * This,
    /* [in] */ REFFMTID fmtid,
    /* [in] */ PROPID pid,
    /* [in] */ const VARIANT *pvar,
    /* [in] */ PROPERTYUI_FORMAT_FLAGS flags,
    /* [size_is][out] */ LPWSTR pwszText,
    /* [in] */ DWORD cchText);


void __RPC_STUB IPropertyUI_FormatForDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0158 */
/* [local] */ 

#if (_WIN32_IE >= 0x0500)
//-------------------------------------------------------------------------
//
// Folder Category Support
//


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0158_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0158_v0_0_s_ifspec;

#ifndef __ICategoryProvider_INTERFACE_DEFINED__
#define __ICategoryProvider_INTERFACE_DEFINED__

/* interface ICategoryProvider */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ICategoryProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9af64809-5864-4c26-a720-c1f78c086ee3")
    ICategoryProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CanCategorizeOnSCID( 
            SHCOLUMNID *pscid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultCategory( 
            GUID *pguid,
            SHCOLUMNID *pscid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCategoryForSCID( 
            SHCOLUMNID *pscid,
            GUID *pguid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumCategories( 
            IEnumGUID **penum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCategoryName( 
            GUID *pguid,
            LPWSTR pszName,
            UINT cch) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateCategory( 
            GUID *pguid,
            REFIID riid,
            /* [iid_is] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategoryProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategoryProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategoryProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategoryProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CanCategorizeOnSCID )( 
            ICategoryProvider * This,
            SHCOLUMNID *pscid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultCategory )( 
            ICategoryProvider * This,
            GUID *pguid,
            SHCOLUMNID *pscid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCategoryForSCID )( 
            ICategoryProvider * This,
            SHCOLUMNID *pscid,
            GUID *pguid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumCategories )( 
            ICategoryProvider * This,
            IEnumGUID **penum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCategoryName )( 
            ICategoryProvider * This,
            GUID *pguid,
            LPWSTR pszName,
            UINT cch);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateCategory )( 
            ICategoryProvider * This,
            GUID *pguid,
            REFIID riid,
            /* [iid_is] */ void **ppv);
        
        END_INTERFACE
    } ICategoryProviderVtbl;

    interface ICategoryProvider
    {
        CONST_VTBL struct ICategoryProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategoryProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICategoryProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICategoryProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICategoryProvider_CanCategorizeOnSCID(This,pscid)	\
    (This)->lpVtbl -> CanCategorizeOnSCID(This,pscid)

#define ICategoryProvider_GetDefaultCategory(This,pguid,pscid)	\
    (This)->lpVtbl -> GetDefaultCategory(This,pguid,pscid)

#define ICategoryProvider_GetCategoryForSCID(This,pscid,pguid)	\
    (This)->lpVtbl -> GetCategoryForSCID(This,pscid,pguid)

#define ICategoryProvider_EnumCategories(This,penum)	\
    (This)->lpVtbl -> EnumCategories(This,penum)

#define ICategoryProvider_GetCategoryName(This,pguid,pszName,cch)	\
    (This)->lpVtbl -> GetCategoryName(This,pguid,pszName,cch)

#define ICategoryProvider_CreateCategory(This,pguid,riid,ppv)	\
    (This)->lpVtbl -> CreateCategory(This,pguid,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategoryProvider_CanCategorizeOnSCID_Proxy( 
    ICategoryProvider * This,
    SHCOLUMNID *pscid);


void __RPC_STUB ICategoryProvider_CanCategorizeOnSCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategoryProvider_GetDefaultCategory_Proxy( 
    ICategoryProvider * This,
    GUID *pguid,
    SHCOLUMNID *pscid);


void __RPC_STUB ICategoryProvider_GetDefaultCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategoryProvider_GetCategoryForSCID_Proxy( 
    ICategoryProvider * This,
    SHCOLUMNID *pscid,
    GUID *pguid);


void __RPC_STUB ICategoryProvider_GetCategoryForSCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategoryProvider_EnumCategories_Proxy( 
    ICategoryProvider * This,
    IEnumGUID **penum);


void __RPC_STUB ICategoryProvider_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategoryProvider_GetCategoryName_Proxy( 
    ICategoryProvider * This,
    GUID *pguid,
    LPWSTR pszName,
    UINT cch);


void __RPC_STUB ICategoryProvider_GetCategoryName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategoryProvider_CreateCategory_Proxy( 
    ICategoryProvider * This,
    GUID *pguid,
    REFIID riid,
    /* [iid_is] */ void **ppv);


void __RPC_STUB ICategoryProvider_CreateCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICategoryProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0159 */
/* [local] */ 

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0159_0001
    {	CATINFO_NORMAL	= 0,
	CATINFO_COLLAPSED	= 0x1,
	CATINFO_HIDDEN	= 0x2
    } 	CATEGORYINFO_FLAGS;

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_shobjidl_0159_0002
    {	CATSORT_DEFAULT	= 0,
	CATSORT_NAME	= 0x1
    } 	CATSORT_FLAGS;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_shobjidl_0159_0003
    {
    CATEGORYINFO_FLAGS cif;
    WCHAR wszName[ 260 ];
    } 	CATEGORY_INFO;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0159_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0159_v0_0_s_ifspec;

#ifndef __ICategorizer_INTERFACE_DEFINED__
#define __ICategorizer_INTERFACE_DEFINED__

/* interface ICategorizer */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ICategorizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3b14589-9174-49a8-89a3-06a1ae2b9ba7")
    ICategorizer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDescription( 
            LPWSTR pszDesc,
            UINT cch) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [in] */ UINT cidl,
            /* [size_is][in] */ LPCITEMIDLIST *apidl,
            /* [size_is][out][in] */ DWORD *rgCategoryIds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCategoryInfo( 
            DWORD dwCategoryId,
            CATEGORY_INFO *pci) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareCategory( 
            CATSORT_FLAGS csfFlags,
            DWORD dwCategoryId1,
            DWORD dwCategoryId2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategorizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategorizer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategorizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategorizer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ICategorizer * This,
            LPWSTR pszDesc,
            UINT cch);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            ICategorizer * This,
            /* [in] */ UINT cidl,
            /* [size_is][in] */ LPCITEMIDLIST *apidl,
            /* [size_is][out][in] */ DWORD *rgCategoryIds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCategoryInfo )( 
            ICategorizer * This,
            DWORD dwCategoryId,
            CATEGORY_INFO *pci);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CompareCategory )( 
            ICategorizer * This,
            CATSORT_FLAGS csfFlags,
            DWORD dwCategoryId1,
            DWORD dwCategoryId2);
        
        END_INTERFACE
    } ICategorizerVtbl;

    interface ICategorizer
    {
        CONST_VTBL struct ICategorizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategorizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICategorizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICategorizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICategorizer_GetDescription(This,pszDesc,cch)	\
    (This)->lpVtbl -> GetDescription(This,pszDesc,cch)

#define ICategorizer_GetCategory(This,cidl,apidl,rgCategoryIds)	\
    (This)->lpVtbl -> GetCategory(This,cidl,apidl,rgCategoryIds)

#define ICategorizer_GetCategoryInfo(This,dwCategoryId,pci)	\
    (This)->lpVtbl -> GetCategoryInfo(This,dwCategoryId,pci)

#define ICategorizer_CompareCategory(This,csfFlags,dwCategoryId1,dwCategoryId2)	\
    (This)->lpVtbl -> CompareCategory(This,csfFlags,dwCategoryId1,dwCategoryId2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategorizer_GetDescription_Proxy( 
    ICategorizer * This,
    LPWSTR pszDesc,
    UINT cch);


void __RPC_STUB ICategorizer_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategorizer_GetCategory_Proxy( 
    ICategorizer * This,
    /* [in] */ UINT cidl,
    /* [size_is][in] */ LPCITEMIDLIST *apidl,
    /* [size_is][out][in] */ DWORD *rgCategoryIds);


void __RPC_STUB ICategorizer_GetCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategorizer_GetCategoryInfo_Proxy( 
    ICategorizer * This,
    DWORD dwCategoryId,
    CATEGORY_INFO *pci);


void __RPC_STUB ICategorizer_GetCategoryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICategorizer_CompareCategory_Proxy( 
    ICategorizer * This,
    CATSORT_FLAGS csfFlags,
    DWORD dwCategoryId1,
    DWORD dwCategoryId2);


void __RPC_STUB ICategorizer_CompareCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICategorizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0160 */
/* [local] */ 

#endif // (_WIN32_IE >= 0x0500)
//  BindHandler GUIDs for IShellItem::BindToHandler (defined in shlguid.h)
//  BHID_SFObject            restricts usage to IShellFolder::BindToObject()
//  BHID_SFUIObject          restricts usage to IShellFolder::GetUIObjectOf()
//  BHID_SFViewObject        restricts usage to IShellFolder::CreateViewObject()
//  BHID_LocalCopyHelper     creates and initializes CLSID_LocalCopyHelper
//  BHID_LinkTargetItem      CLSID_ShellItem initialized with the target this item (SFGAO_LINK only)
//  BHID_Storage             attempts to get the stg/stm riid from BTO, but defaults to shell implementations on failure


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0160_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0160_v0_0_s_ifspec;

#ifndef __IShellItem_INTERFACE_DEFINED__
#define __IShellItem_INTERFACE_DEFINED__

/* interface IShellItem */
/* [unique][object][uuid][helpstring] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL_IShellItem_0001
    {	SIGDN_NORMALDISPLAY	= 0,
	SIGDN_PARENTRELATIVEPARSING	= 0x80018001,
	SIGDN_DESKTOPABSOLUTEPARSING	= 0x80028000,
	SIGDN_PARENTRELATIVEEDITING	= 0x80031001,
	SIGDN_DESKTOPABSOLUTEEDITING	= 0x8004c000,
	SIGDN_FILESYSPATH	= 0x80058000,
	SIGDN_URL	= 0x80068000
    } 	SIGDN;


EXTERN_C const IID IID_IShellItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1079acf9-29bd-11d3-8e0d-00c04f6837d5")
    IShellItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindToHandler( 
            /* [in] */ IBindCtx *pbc,
            /* [in] */ REFGUID rbhid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ LPOLESTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ SFGAOF *psfgaoAttribs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IShellItem *psi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            IShellItem * This,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ REFGUID rbhid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IShellItem * This,
            /* [out] */ IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IShellItem * This,
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ LPOLESTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IShellItem * This,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ SFGAOF *psfgaoAttribs);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IShellItem * This,
            /* [in] */ IShellItem *psi);
        
        END_INTERFACE
    } IShellItemVtbl;

    interface IShellItem
    {
        CONST_VTBL struct IShellItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellItem_BindToHandler(This,pbc,rbhid,riid,ppvOut)	\
    (This)->lpVtbl -> BindToHandler(This,pbc,rbhid,riid,ppvOut)

#define IShellItem_GetParent(This,ppsi)	\
    (This)->lpVtbl -> GetParent(This,ppsi)

#define IShellItem_GetDisplayName(This,sigdnName,ppszName)	\
    (This)->lpVtbl -> GetDisplayName(This,sigdnName,ppszName)

#define IShellItem_GetAttributes(This,sfgaoMask,psfgaoAttribs)	\
    (This)->lpVtbl -> GetAttributes(This,sfgaoMask,psfgaoAttribs)

#define IShellItem_IsEqual(This,psi)	\
    (This)->lpVtbl -> IsEqual(This,psi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellItem_BindToHandler_Proxy( 
    IShellItem * This,
    /* [in] */ IBindCtx *pbc,
    /* [in] */ REFGUID rbhid,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvOut);


void __RPC_STUB IShellItem_BindToHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellItem_GetParent_Proxy( 
    IShellItem * This,
    /* [out] */ IShellItem **ppsi);


void __RPC_STUB IShellItem_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellItem_GetDisplayName_Proxy( 
    IShellItem * This,
    /* [in] */ SIGDN sigdnName,
    /* [string][out] */ LPOLESTR *ppszName);


void __RPC_STUB IShellItem_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellItem_GetAttributes_Proxy( 
    IShellItem * This,
    /* [in] */ SFGAOF sfgaoMask,
    /* [out] */ SFGAOF *psfgaoAttribs);


void __RPC_STUB IShellItem_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellItem_IsEqual_Proxy( 
    IShellItem * This,
    /* [in] */ IShellItem *psi);


void __RPC_STUB IShellItem_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellItem_INTERFACE_DEFINED__ */


#ifndef __IEnumShellItems_INTERFACE_DEFINED__
#define __IEnumShellItems_INTERFACE_DEFINED__

/* interface IEnumShellItems */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEnumShellItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70629033-e363-4a28-a567-0db78006e6d7")
    IEnumShellItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IShellItem **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumShellItems **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumShellItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumShellItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumShellItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumShellItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumShellItems * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IShellItem **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumShellItems * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumShellItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumShellItems * This,
            /* [out] */ IEnumShellItems **ppenum);
        
        END_INTERFACE
    } IEnumShellItemsVtbl;

    interface IEnumShellItems
    {
        CONST_VTBL struct IEnumShellItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumShellItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumShellItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumShellItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumShellItems_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumShellItems_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumShellItems_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumShellItems_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumShellItems_Next_Proxy( 
    IEnumShellItems * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IShellItem **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumShellItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellItems_Skip_Proxy( 
    IEnumShellItems * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumShellItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellItems_Reset_Proxy( 
    IEnumShellItems * This);


void __RPC_STUB IEnumShellItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellItems_Clone_Proxy( 
    IEnumShellItems * This,
    /* [out] */ IEnumShellItems **ppenum);


void __RPC_STUB IEnumShellItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumShellItems_INTERFACE_DEFINED__ */


#ifndef __IItemHandler_INTERFACE_DEFINED__
#define __IItemHandler_INTERFACE_DEFINED__

/* interface IItemHandler */
/* [object][uuid] */ 


EXTERN_C const IID IID_IItemHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c830b704-f3a3-4e3c-a099-d8bdbbc29a07")
    IItemHandler : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            IShellItem *psi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IItemHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IItemHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IItemHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IItemHandler * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IItemHandler * This,
            IShellItem *psi);
        
        END_INTERFACE
    } IItemHandlerVtbl;

    interface IItemHandler
    {
        CONST_VTBL struct IItemHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IItemHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IItemHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IItemHandler_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IItemHandler_Init(This,psi)	\
    (This)->lpVtbl -> Init(This,psi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IItemHandler_Init_Proxy( 
    IItemHandler * This,
    IShellItem *psi);


void __RPC_STUB IItemHandler_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IItemHandler_INTERFACE_DEFINED__ */


#ifndef __ILocalCopy_INTERFACE_DEFINED__
#define __ILocalCopy_INTERFACE_DEFINED__

/* interface ILocalCopy */
/* [object][uuid][helpstring] */ 

//  flags for ILocalCopy methods
//  LCDOWN_READONLY            read only helper, Upload() fails with E_ACCESSDENIED
//  LCDOWN_SAVEAS              write only helper, no download required for Download()
//  LC_FORCEROUNDTRIP          never use local cache (always roundtrip both Upload() and Download())

enum __MIDL_ILocalCopy_0001
    {	LCDOWN_READONLY	= 0x1,
	LC_SAVEAS	= 0x2,
	LC_FORCEROUNDTRIP	= 0x10
    } ;
typedef DWORD LCFLAGS;


EXTERN_C const IID IID_ILocalCopy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("679d9e36-f8f9-11d2-8deb-00c04f6837d5")
    ILocalCopy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Download( 
            /* [in] */ LCFLAGS flags,
            /* [in] */ IBindCtx *pbc,
            /* [string][out] */ LPWSTR *ppszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Upload( 
            /* [in] */ LCFLAGS flags,
            /* [in] */ IBindCtx *pbc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocalCopyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILocalCopy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILocalCopy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILocalCopy * This);
        
        HRESULT ( STDMETHODCALLTYPE *Download )( 
            ILocalCopy * This,
            /* [in] */ LCFLAGS flags,
            /* [in] */ IBindCtx *pbc,
            /* [string][out] */ LPWSTR *ppszPath);
        
        HRESULT ( STDMETHODCALLTYPE *Upload )( 
            ILocalCopy * This,
            /* [in] */ LCFLAGS flags,
            /* [in] */ IBindCtx *pbc);
        
        END_INTERFACE
    } ILocalCopyVtbl;

    interface ILocalCopy
    {
        CONST_VTBL struct ILocalCopyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocalCopy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILocalCopy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILocalCopy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILocalCopy_Download(This,flags,pbc,ppszPath)	\
    (This)->lpVtbl -> Download(This,flags,pbc,ppszPath)

#define ILocalCopy_Upload(This,flags,pbc)	\
    (This)->lpVtbl -> Upload(This,flags,pbc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILocalCopy_Download_Proxy( 
    ILocalCopy * This,
    /* [in] */ LCFLAGS flags,
    /* [in] */ IBindCtx *pbc,
    /* [string][out] */ LPWSTR *ppszPath);


void __RPC_STUB ILocalCopy_Download_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILocalCopy_Upload_Proxy( 
    ILocalCopy * This,
    /* [in] */ LCFLAGS flags,
    /* [in] */ IBindCtx *pbc);


void __RPC_STUB ILocalCopy_Upload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILocalCopy_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0164 */
/* [local] */ 

#ifdef UNICODE
#define IShellLink      IShellLinkW
#else
#define IShellLink      IShellLinkA
#endif
typedef /* [public] */ 
enum __MIDL___MIDL_itf_shobjidl_0164_0001
    {	SLR_NO_UI	= 0x1,
	SLR_ANY_MATCH	= 0x2,
	SLR_UPDATE	= 0x4,
	SLR_NOUPDATE	= 0x8,
	SLR_NOSEARCH	= 0x10,
	SLR_NOTRACK	= 0x20,
	SLR_NOLINKINFO	= 0x40,
	SLR_INVOKE_MSI	= 0x80
    } 	SLR_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_shobjidl_0164_0002
    {	SLGP_SHORTPATH	= 0x1,
	SLGP_UNCPRIORITY	= 0x2,
	SLGP_RAWPATH	= 0x4
    } 	SLGP_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0164_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0164_v0_0_s_ifspec;

#ifndef __IShellLinkA_INTERFACE_DEFINED__
#define __IShellLinkA_INTERFACE_DEFINED__

/* interface IShellLinkA */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellLinkA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214EE-0000-0000-C000-000000000046")
    IShellLinkA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [size_is][out] */ LPSTR pszFile,
            /* [in] */ int cch,
            /* [full][out][in] */ WIN32_FIND_DATAA *pfd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ LPITEMIDLIST *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIDList( 
            /* [in] */ LPCITEMIDLIST pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [size_is][out] */ LPSTR pszName,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ LPCSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkingDirectory( 
            /* [size_is][out] */ LPSTR pszDir,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkingDirectory( 
            /* [in] */ LPCSTR pszDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArguments( 
            /* [size_is][out] */ LPSTR pszArgs,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArguments( 
            /* [in] */ LPCSTR pszArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotkey( 
            /* [out] */ WORD *pwHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotkey( 
            /* [in] */ WORD wHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowCmd( 
            /* [out] */ int *piShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShowCmd( 
            /* [in] */ int iShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [size_is][out] */ LPSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ int *piIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [in] */ LPCSTR pszIconPath,
            /* [in] */ int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelativePath( 
            /* [in] */ LPCSTR pszPathRel,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ LPCSTR pszFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellLinkA * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellLinkA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellLinkA * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IShellLinkA * This,
            /* [size_is][out] */ LPSTR pszFile,
            /* [in] */ int cch,
            /* [full][out][in] */ WIN32_FIND_DATAA *pfd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            IShellLinkA * This,
            /* [out] */ LPITEMIDLIST *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *SetIDList )( 
            IShellLinkA * This,
            /* [in] */ LPCITEMIDLIST pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IShellLinkA * This,
            /* [size_is][out] */ LPSTR pszName,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IShellLinkA * This,
            /* [in] */ LPCSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkingDirectory )( 
            IShellLinkA * This,
            /* [size_is][out] */ LPSTR pszDir,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkingDirectory )( 
            IShellLinkA * This,
            /* [in] */ LPCSTR pszDir);
        
        HRESULT ( STDMETHODCALLTYPE *GetArguments )( 
            IShellLinkA * This,
            /* [size_is][out] */ LPSTR pszArgs,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetArguments )( 
            IShellLinkA * This,
            /* [in] */ LPCSTR pszArgs);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotkey )( 
            IShellLinkA * This,
            /* [out] */ WORD *pwHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotkey )( 
            IShellLinkA * This,
            /* [in] */ WORD wHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowCmd )( 
            IShellLinkA * This,
            /* [out] */ int *piShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetShowCmd )( 
            IShellLinkA * This,
            /* [in] */ int iShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IShellLinkA * This,
            /* [size_is][out] */ LPSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ int *piIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconLocation )( 
            IShellLinkA * This,
            /* [in] */ LPCSTR pszIconPath,
            /* [in] */ int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetRelativePath )( 
            IShellLinkA * This,
            /* [in] */ LPCSTR pszPathRel,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IShellLinkA * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IShellLinkA * This,
            /* [in] */ LPCSTR pszFile);
        
        END_INTERFACE
    } IShellLinkAVtbl;

    interface IShellLinkA
    {
        CONST_VTBL struct IShellLinkAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellLinkA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellLinkA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellLinkA_GetPath(This,pszFile,cch,pfd,fFlags)	\
    (This)->lpVtbl -> GetPath(This,pszFile,cch,pfd,fFlags)

#define IShellLinkA_GetIDList(This,ppidl)	\
    (This)->lpVtbl -> GetIDList(This,ppidl)

#define IShellLinkA_SetIDList(This,pidl)	\
    (This)->lpVtbl -> SetIDList(This,pidl)

#define IShellLinkA_GetDescription(This,pszName,cch)	\
    (This)->lpVtbl -> GetDescription(This,pszName,cch)

#define IShellLinkA_SetDescription(This,pszName)	\
    (This)->lpVtbl -> SetDescription(This,pszName)

#define IShellLinkA_GetWorkingDirectory(This,pszDir,cch)	\
    (This)->lpVtbl -> GetWorkingDirectory(This,pszDir,cch)

#define IShellLinkA_SetWorkingDirectory(This,pszDir)	\
    (This)->lpVtbl -> SetWorkingDirectory(This,pszDir)

#define IShellLinkA_GetArguments(This,pszArgs,cch)	\
    (This)->lpVtbl -> GetArguments(This,pszArgs,cch)

#define IShellLinkA_SetArguments(This,pszArgs)	\
    (This)->lpVtbl -> SetArguments(This,pszArgs)

#define IShellLinkA_GetHotkey(This,pwHotkey)	\
    (This)->lpVtbl -> GetHotkey(This,pwHotkey)

#define IShellLinkA_SetHotkey(This,wHotkey)	\
    (This)->lpVtbl -> SetHotkey(This,wHotkey)

#define IShellLinkA_GetShowCmd(This,piShowCmd)	\
    (This)->lpVtbl -> GetShowCmd(This,piShowCmd)

#define IShellLinkA_SetShowCmd(This,iShowCmd)	\
    (This)->lpVtbl -> SetShowCmd(This,iShowCmd)

#define IShellLinkA_GetIconLocation(This,pszIconPath,cch,piIcon)	\
    (This)->lpVtbl -> GetIconLocation(This,pszIconPath,cch,piIcon)

#define IShellLinkA_SetIconLocation(This,pszIconPath,iIcon)	\
    (This)->lpVtbl -> SetIconLocation(This,pszIconPath,iIcon)

#define IShellLinkA_SetRelativePath(This,pszPathRel,dwReserved)	\
    (This)->lpVtbl -> SetRelativePath(This,pszPathRel,dwReserved)

#define IShellLinkA_Resolve(This,hwnd,fFlags)	\
    (This)->lpVtbl -> Resolve(This,hwnd,fFlags)

#define IShellLinkA_SetPath(This,pszFile)	\
    (This)->lpVtbl -> SetPath(This,pszFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellLinkA_GetPath_Proxy( 
    IShellLinkA * This,
    /* [size_is][out] */ LPSTR pszFile,
    /* [in] */ int cch,
    /* [full][out][in] */ WIN32_FIND_DATAA *pfd,
    /* [in] */ DWORD fFlags);


void __RPC_STUB IShellLinkA_GetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_GetIDList_Proxy( 
    IShellLinkA * This,
    /* [out] */ LPITEMIDLIST *ppidl);


void __RPC_STUB IShellLinkA_GetIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetIDList_Proxy( 
    IShellLinkA * This,
    /* [in] */ LPCITEMIDLIST pidl);


void __RPC_STUB IShellLinkA_SetIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_GetDescription_Proxy( 
    IShellLinkA * This,
    /* [size_is][out] */ LPSTR pszName,
    /* [in] */ int cch);


void __RPC_STUB IShellLinkA_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetDescription_Proxy( 
    IShellLinkA * This,
    /* [in] */ LPCSTR pszName);


void __RPC_STUB IShellLinkA_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_GetWorkingDirectory_Proxy( 
    IShellLinkA * This,
    /* [size_is][out] */ LPSTR pszDir,
    /* [in] */ int cch);


void __RPC_STUB IShellLinkA_GetWorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetWorkingDirectory_Proxy( 
    IShellLinkA * This,
    /* [in] */ LPCSTR pszDir);


void __RPC_STUB IShellLinkA_SetWorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_GetArguments_Proxy( 
    IShellLinkA * This,
    /* [size_is][out] */ LPSTR pszArgs,
    /* [in] */ int cch);


void __RPC_STUB IShellLinkA_GetArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetArguments_Proxy( 
    IShellLinkA * This,
    /* [in] */ LPCSTR pszArgs);


void __RPC_STUB IShellLinkA_SetArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_GetHotkey_Proxy( 
    IShellLinkA * This,
    /* [out] */ WORD *pwHotkey);


void __RPC_STUB IShellLinkA_GetHotkey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetHotkey_Proxy( 
    IShellLinkA * This,
    /* [in] */ WORD wHotkey);


void __RPC_STUB IShellLinkA_SetHotkey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_GetShowCmd_Proxy( 
    IShellLinkA * This,
    /* [out] */ int *piShowCmd);


void __RPC_STUB IShellLinkA_GetShowCmd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetShowCmd_Proxy( 
    IShellLinkA * This,
    /* [in] */ int iShowCmd);


void __RPC_STUB IShellLinkA_SetShowCmd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_GetIconLocation_Proxy( 
    IShellLinkA * This,
    /* [size_is][out] */ LPSTR pszIconPath,
    /* [in] */ int cch,
    /* [out] */ int *piIcon);


void __RPC_STUB IShellLinkA_GetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetIconLocation_Proxy( 
    IShellLinkA * This,
    /* [in] */ LPCSTR pszIconPath,
    /* [in] */ int iIcon);


void __RPC_STUB IShellLinkA_SetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetRelativePath_Proxy( 
    IShellLinkA * This,
    /* [in] */ LPCSTR pszPathRel,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IShellLinkA_SetRelativePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_Resolve_Proxy( 
    IShellLinkA * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD fFlags);


void __RPC_STUB IShellLinkA_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkA_SetPath_Proxy( 
    IShellLinkA * This,
    /* [in] */ LPCSTR pszFile);


void __RPC_STUB IShellLinkA_SetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellLinkA_INTERFACE_DEFINED__ */


#ifndef __IShellLinkW_INTERFACE_DEFINED__
#define __IShellLinkW_INTERFACE_DEFINED__

/* interface IShellLinkW */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IShellLinkW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214F9-0000-0000-C000-000000000046")
    IShellLinkW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [size_is][out] */ LPWSTR pszFile,
            /* [in] */ int cch,
            /* [full][out][in] */ WIN32_FIND_DATAW *pfd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDList( 
            /* [out] */ LPITEMIDLIST *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIDList( 
            /* [in] */ LPCITEMIDLIST pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [size_is][out] */ LPWSTR pszName,
            int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkingDirectory( 
            /* [size_is][out] */ LPWSTR pszDir,
            int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkingDirectory( 
            /* [in] */ LPCWSTR pszDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArguments( 
            /* [size_is][out] */ LPWSTR pszArgs,
            int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArguments( 
            /* [in] */ LPCWSTR pszArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotkey( 
            /* [out] */ WORD *pwHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotkey( 
            /* [in] */ WORD wHotkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowCmd( 
            /* [out] */ int *piShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShowCmd( 
            /* [in] */ int iShowCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [size_is][out] */ LPWSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ int *piIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [in] */ LPCWSTR pszIconPath,
            /* [in] */ int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelativePath( 
            /* [in] */ LPCWSTR pszPathRel,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ LPCWSTR pszFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellLinkW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellLinkW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellLinkW * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IShellLinkW * This,
            /* [size_is][out] */ LPWSTR pszFile,
            /* [in] */ int cch,
            /* [full][out][in] */ WIN32_FIND_DATAW *pfd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDList )( 
            IShellLinkW * This,
            /* [out] */ LPITEMIDLIST *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *SetIDList )( 
            IShellLinkW * This,
            /* [in] */ LPCITEMIDLIST pidl);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IShellLinkW * This,
            /* [size_is][out] */ LPWSTR pszName,
            int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IShellLinkW * This,
            /* [in] */ LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorkingDirectory )( 
            IShellLinkW * This,
            /* [size_is][out] */ LPWSTR pszDir,
            int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorkingDirectory )( 
            IShellLinkW * This,
            /* [in] */ LPCWSTR pszDir);
        
        HRESULT ( STDMETHODCALLTYPE *GetArguments )( 
            IShellLinkW * This,
            /* [size_is][out] */ LPWSTR pszArgs,
            int cch);
        
        HRESULT ( STDMETHODCALLTYPE *SetArguments )( 
            IShellLinkW * This,
            /* [in] */ LPCWSTR pszArgs);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotkey )( 
            IShellLinkW * This,
            /* [out] */ WORD *pwHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotkey )( 
            IShellLinkW * This,
            /* [in] */ WORD wHotkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowCmd )( 
            IShellLinkW * This,
            /* [out] */ int *piShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetShowCmd )( 
            IShellLinkW * This,
            /* [in] */ int iShowCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IShellLinkW * This,
            /* [size_is][out] */ LPWSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ int *piIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconLocation )( 
            IShellLinkW * This,
            /* [in] */ LPCWSTR pszIconPath,
            /* [in] */ int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetRelativePath )( 
            IShellLinkW * This,
            /* [in] */ LPCWSTR pszPathRel,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IShellLinkW * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD fFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IShellLinkW * This,
            /* [in] */ LPCWSTR pszFile);
        
        END_INTERFACE
    } IShellLinkWVtbl;

    interface IShellLinkW
    {
        CONST_VTBL struct IShellLinkWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellLinkW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellLinkW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellLinkW_GetPath(This,pszFile,cch,pfd,fFlags)	\
    (This)->lpVtbl -> GetPath(This,pszFile,cch,pfd,fFlags)

#define IShellLinkW_GetIDList(This,ppidl)	\
    (This)->lpVtbl -> GetIDList(This,ppidl)

#define IShellLinkW_SetIDList(This,pidl)	\
    (This)->lpVtbl -> SetIDList(This,pidl)

#define IShellLinkW_GetDescription(This,pszName,cch)	\
    (This)->lpVtbl -> GetDescription(This,pszName,cch)

#define IShellLinkW_SetDescription(This,pszName)	\
    (This)->lpVtbl -> SetDescription(This,pszName)

#define IShellLinkW_GetWorkingDirectory(This,pszDir,cch)	\
    (This)->lpVtbl -> GetWorkingDirectory(This,pszDir,cch)

#define IShellLinkW_SetWorkingDirectory(This,pszDir)	\
    (This)->lpVtbl -> SetWorkingDirectory(This,pszDir)

#define IShellLinkW_GetArguments(This,pszArgs,cch)	\
    (This)->lpVtbl -> GetArguments(This,pszArgs,cch)

#define IShellLinkW_SetArguments(This,pszArgs)	\
    (This)->lpVtbl -> SetArguments(This,pszArgs)

#define IShellLinkW_GetHotkey(This,pwHotkey)	\
    (This)->lpVtbl -> GetHotkey(This,pwHotkey)

#define IShellLinkW_SetHotkey(This,wHotkey)	\
    (This)->lpVtbl -> SetHotkey(This,wHotkey)

#define IShellLinkW_GetShowCmd(This,piShowCmd)	\
    (This)->lpVtbl -> GetShowCmd(This,piShowCmd)

#define IShellLinkW_SetShowCmd(This,iShowCmd)	\
    (This)->lpVtbl -> SetShowCmd(This,iShowCmd)

#define IShellLinkW_GetIconLocation(This,pszIconPath,cch,piIcon)	\
    (This)->lpVtbl -> GetIconLocation(This,pszIconPath,cch,piIcon)

#define IShellLinkW_SetIconLocation(This,pszIconPath,iIcon)	\
    (This)->lpVtbl -> SetIconLocation(This,pszIconPath,iIcon)

#define IShellLinkW_SetRelativePath(This,pszPathRel,dwReserved)	\
    (This)->lpVtbl -> SetRelativePath(This,pszPathRel,dwReserved)

#define IShellLinkW_Resolve(This,hwnd,fFlags)	\
    (This)->lpVtbl -> Resolve(This,hwnd,fFlags)

#define IShellLinkW_SetPath(This,pszFile)	\
    (This)->lpVtbl -> SetPath(This,pszFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellLinkW_GetPath_Proxy( 
    IShellLinkW * This,
    /* [size_is][out] */ LPWSTR pszFile,
    /* [in] */ int cch,
    /* [full][out][in] */ WIN32_FIND_DATAW *pfd,
    /* [in] */ DWORD fFlags);


void __RPC_STUB IShellLinkW_GetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_GetIDList_Proxy( 
    IShellLinkW * This,
    /* [out] */ LPITEMIDLIST *ppidl);


void __RPC_STUB IShellLinkW_GetIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetIDList_Proxy( 
    IShellLinkW * This,
    /* [in] */ LPCITEMIDLIST pidl);


void __RPC_STUB IShellLinkW_SetIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_GetDescription_Proxy( 
    IShellLinkW * This,
    /* [size_is][out] */ LPWSTR pszName,
    int cch);


void __RPC_STUB IShellLinkW_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetDescription_Proxy( 
    IShellLinkW * This,
    /* [in] */ LPCWSTR pszName);


void __RPC_STUB IShellLinkW_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_GetWorkingDirectory_Proxy( 
    IShellLinkW * This,
    /* [size_is][out] */ LPWSTR pszDir,
    int cch);


void __RPC_STUB IShellLinkW_GetWorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetWorkingDirectory_Proxy( 
    IShellLinkW * This,
    /* [in] */ LPCWSTR pszDir);


void __RPC_STUB IShellLinkW_SetWorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_GetArguments_Proxy( 
    IShellLinkW * This,
    /* [size_is][out] */ LPWSTR pszArgs,
    int cch);


void __RPC_STUB IShellLinkW_GetArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetArguments_Proxy( 
    IShellLinkW * This,
    /* [in] */ LPCWSTR pszArgs);


void __RPC_STUB IShellLinkW_SetArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_GetHotkey_Proxy( 
    IShellLinkW * This,
    /* [out] */ WORD *pwHotkey);


void __RPC_STUB IShellLinkW_GetHotkey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetHotkey_Proxy( 
    IShellLinkW * This,
    /* [in] */ WORD wHotkey);


void __RPC_STUB IShellLinkW_SetHotkey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_GetShowCmd_Proxy( 
    IShellLinkW * This,
    /* [out] */ int *piShowCmd);


void __RPC_STUB IShellLinkW_GetShowCmd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetShowCmd_Proxy( 
    IShellLinkW * This,
    /* [in] */ int iShowCmd);


void __RPC_STUB IShellLinkW_SetShowCmd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_GetIconLocation_Proxy( 
    IShellLinkW * This,
    /* [size_is][out] */ LPWSTR pszIconPath,
    /* [in] */ int cch,
    /* [out] */ int *piIcon);


void __RPC_STUB IShellLinkW_GetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetIconLocation_Proxy( 
    IShellLinkW * This,
    /* [in] */ LPCWSTR pszIconPath,
    /* [in] */ int iIcon);


void __RPC_STUB IShellLinkW_SetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetRelativePath_Proxy( 
    IShellLinkW * This,
    /* [in] */ LPCWSTR pszPathRel,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IShellLinkW_SetRelativePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_Resolve_Proxy( 
    IShellLinkW * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD fFlags);


void __RPC_STUB IShellLinkW_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellLinkW_SetPath_Proxy( 
    IShellLinkW * This,
    /* [in] */ LPCWSTR pszFile);


void __RPC_STUB IShellLinkW_SetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellLinkW_INTERFACE_DEFINED__ */


#ifndef __IActionProgressDialog_INTERFACE_DEFINED__
#define __IActionProgressDialog_INTERFACE_DEFINED__

/* interface IActionProgressDialog */
/* [unique][helpstring][uuid][object] */ 

/* [v1_enum] */ 
enum __MIDL_IActionProgressDialog_0001
    {	SPINITF_NORMAL	= 0,
	SPINITF_MODAL	= 0x1,
	SPINITF_NOMINIMIZE	= 0x8
    } ;
typedef DWORD SPINITF;


EXTERN_C const IID IID_IActionProgressDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49ff1172-eadc-446d-9285-156453a6431c")
    IActionProgressDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ SPINITF flags,
            /* [string][in] */ LPCWSTR pszTitle,
            /* [string][in] */ LPCWSTR pszCancel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActionProgressDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActionProgressDialog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActionProgressDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActionProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IActionProgressDialog * This,
            /* [in] */ SPINITF flags,
            /* [string][in] */ LPCWSTR pszTitle,
            /* [string][in] */ LPCWSTR pszCancel);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IActionProgressDialog * This);
        
        END_INTERFACE
    } IActionProgressDialogVtbl;

    interface IActionProgressDialog
    {
        CONST_VTBL struct IActionProgressDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActionProgressDialog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActionProgressDialog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActionProgressDialog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActionProgressDialog_Initialize(This,flags,pszTitle,pszCancel)	\
    (This)->lpVtbl -> Initialize(This,flags,pszTitle,pszCancel)

#define IActionProgressDialog_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActionProgressDialog_Initialize_Proxy( 
    IActionProgressDialog * This,
    /* [in] */ SPINITF flags,
    /* [string][in] */ LPCWSTR pszTitle,
    /* [string][in] */ LPCWSTR pszCancel);


void __RPC_STUB IActionProgressDialog_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActionProgressDialog_Stop_Proxy( 
    IActionProgressDialog * This);


void __RPC_STUB IActionProgressDialog_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActionProgressDialog_INTERFACE_DEFINED__ */


#ifndef __IHWEventHandler_INTERFACE_DEFINED__
#define __IHWEventHandler_INTERFACE_DEFINED__

/* interface IHWEventHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHWEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C1FB73D0-EC3A-4ba2-B512-8CDB9187B6D1")
    IHWEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCWSTR pszParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleEvent( 
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [string][in] */ LPCWSTR pszAltDeviceID,
            /* [string][in] */ LPCWSTR pszEventType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHWEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHWEventHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHWEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHWEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IHWEventHandler * This,
            /* [string][in] */ LPCWSTR pszParams);
        
        HRESULT ( STDMETHODCALLTYPE *HandleEvent )( 
            IHWEventHandler * This,
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [string][in] */ LPCWSTR pszAltDeviceID,
            /* [string][in] */ LPCWSTR pszEventType);
        
        END_INTERFACE
    } IHWEventHandlerVtbl;

    interface IHWEventHandler
    {
        CONST_VTBL struct IHWEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHWEventHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHWEventHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHWEventHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHWEventHandler_Initialize(This,pszParams)	\
    (This)->lpVtbl -> Initialize(This,pszParams)

#define IHWEventHandler_HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType)	\
    (This)->lpVtbl -> HandleEvent(This,pszDeviceID,pszAltDeviceID,pszEventType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHWEventHandler_Initialize_Proxy( 
    IHWEventHandler * This,
    /* [string][in] */ LPCWSTR pszParams);


void __RPC_STUB IHWEventHandler_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHWEventHandler_HandleEvent_Proxy( 
    IHWEventHandler * This,
    /* [string][in] */ LPCWSTR pszDeviceID,
    /* [string][in] */ LPCWSTR pszAltDeviceID,
    /* [string][in] */ LPCWSTR pszEventType);


void __RPC_STUB IHWEventHandler_HandleEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHWEventHandler_INTERFACE_DEFINED__ */


#ifndef __IActionProgress_INTERFACE_DEFINED__
#define __IActionProgress_INTERFACE_DEFINED__

/* interface IActionProgress */
/* [unique][helpstring][uuid][object] */ 

/* [v1_enum] */ 
enum __MIDL_IActionProgress_0001
    {	SPBEGINF_NORMAL	= 0,
	SPBEGINF_AUTOTIME	= 0x2,
	SPBEGINF_NOPROGRESSBAR	= 0x10
    } ;
typedef DWORD SPBEGINF;

typedef /* [v1_enum] */ 
enum _SPACTION
    {	SPACTION_NONE	= 0,
	SPACTION_MOVING	= SPACTION_NONE + 1,
	SPACTION_COPYING	= SPACTION_MOVING + 1,
	SPACTION_RECYCLING	= SPACTION_COPYING + 1,
	SPACTION_APPLYINGATTRIBS	= SPACTION_RECYCLING + 1,
	SPACTION_DOWNLOADING	= SPACTION_APPLYINGATTRIBS + 1,
	SPACTION_SEARCHING_INTERNET	= SPACTION_DOWNLOADING + 1,
	SPACTION_CALCULATING	= SPACTION_SEARCHING_INTERNET + 1,
	SPACTION_UPLOADING	= SPACTION_CALCULATING + 1
    } 	SPACTION;

typedef /* [v1_enum] */ 
enum _SPTEXT
    {	SPTEXT_ACTIONDESCRIPTION	= 1,
	SPTEXT_ACTIONDETAIL	= SPTEXT_ACTIONDESCRIPTION + 1
    } 	SPTEXT;


EXTERN_C const IID IID_IActionProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49ff1173-eadc-446d-9285-156453a6431c")
    IActionProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin( 
            /* [in] */ SPACTION action,
            /* [in] */ SPBEGINF flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateProgress( 
            /* [in] */ ULONGLONG ulCompleted,
            /* [in] */ ULONGLONG ulTotal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateText( 
            /* [in] */ SPTEXT sptext,
            /* [string][in] */ LPCWSTR pszText,
            /* [in] */ BOOL fMayCompact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCancel( 
            /* [out] */ BOOL *pfCancelled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetCancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActionProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActionProgress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActionProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActionProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin )( 
            IActionProgress * This,
            /* [in] */ SPACTION action,
            /* [in] */ SPBEGINF flags);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateProgress )( 
            IActionProgress * This,
            /* [in] */ ULONGLONG ulCompleted,
            /* [in] */ ULONGLONG ulTotal);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateText )( 
            IActionProgress * This,
            /* [in] */ SPTEXT sptext,
            /* [string][in] */ LPCWSTR pszText,
            /* [in] */ BOOL fMayCompact);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCancel )( 
            IActionProgress * This,
            /* [out] */ BOOL *pfCancelled);
        
        HRESULT ( STDMETHODCALLTYPE *ResetCancel )( 
            IActionProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IActionProgress * This);
        
        END_INTERFACE
    } IActionProgressVtbl;

    interface IActionProgress
    {
        CONST_VTBL struct IActionProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActionProgress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActionProgress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActionProgress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActionProgress_Begin(This,action,flags)	\
    (This)->lpVtbl -> Begin(This,action,flags)

#define IActionProgress_UpdateProgress(This,ulCompleted,ulTotal)	\
    (This)->lpVtbl -> UpdateProgress(This,ulCompleted,ulTotal)

#define IActionProgress_UpdateText(This,sptext,pszText,fMayCompact)	\
    (This)->lpVtbl -> UpdateText(This,sptext,pszText,fMayCompact)

#define IActionProgress_QueryCancel(This,pfCancelled)	\
    (This)->lpVtbl -> QueryCancel(This,pfCancelled)

#define IActionProgress_ResetCancel(This)	\
    (This)->lpVtbl -> ResetCancel(This)

#define IActionProgress_End(This)	\
    (This)->lpVtbl -> End(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActionProgress_Begin_Proxy( 
    IActionProgress * This,
    /* [in] */ SPACTION action,
    /* [in] */ SPBEGINF flags);


void __RPC_STUB IActionProgress_Begin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActionProgress_UpdateProgress_Proxy( 
    IActionProgress * This,
    /* [in] */ ULONGLONG ulCompleted,
    /* [in] */ ULONGLONG ulTotal);


void __RPC_STUB IActionProgress_UpdateProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActionProgress_UpdateText_Proxy( 
    IActionProgress * This,
    /* [in] */ SPTEXT sptext,
    /* [string][in] */ LPCWSTR pszText,
    /* [in] */ BOOL fMayCompact);


void __RPC_STUB IActionProgress_UpdateText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActionProgress_QueryCancel_Proxy( 
    IActionProgress * This,
    /* [out] */ BOOL *pfCancelled);


void __RPC_STUB IActionProgress_QueryCancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActionProgress_ResetCancel_Proxy( 
    IActionProgress * This);


void __RPC_STUB IActionProgress_ResetCancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActionProgress_End_Proxy( 
    IActionProgress * This);


void __RPC_STUB IActionProgress_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActionProgress_INTERFACE_DEFINED__ */


#ifndef __IShellExtInit_INTERFACE_DEFINED__
#define __IShellExtInit_INTERFACE_DEFINED__

/* interface IShellExtInit */
/* [unique][local][object][uuid] */ 


EXTERN_C const IID IID_IShellExtInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E8-0000-0000-C000-000000000046")
    IShellExtInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCITEMIDLIST pidlFolder,
            /* [in] */ IDataObject *pdtobj,
            /* [in] */ HKEY hkeyProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellExtInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellExtInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellExtInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellExtInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IShellExtInit * This,
            /* [in] */ LPCITEMIDLIST pidlFolder,
            /* [in] */ IDataObject *pdtobj,
            /* [in] */ HKEY hkeyProgID);
        
        END_INTERFACE
    } IShellExtInitVtbl;

    interface IShellExtInit
    {
        CONST_VTBL struct IShellExtInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellExtInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellExtInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellExtInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellExtInit_Initialize(This,pidlFolder,pdtobj,hkeyProgID)	\
    (This)->lpVtbl -> Initialize(This,pidlFolder,pdtobj,hkeyProgID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellExtInit_Initialize_Proxy( 
    IShellExtInit * This,
    /* [in] */ LPCITEMIDLIST pidlFolder,
    /* [in] */ IDataObject *pdtobj,
    /* [in] */ HKEY hkeyProgID);


void __RPC_STUB IShellExtInit_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellExtInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0170 */
/* [local] */ 

typedef IShellExtInit *LPSHELLEXTINIT;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0170_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0170_v0_0_s_ifspec;

#ifndef __IShellPropSheetExt_INTERFACE_DEFINED__
#define __IShellPropSheetExt_INTERFACE_DEFINED__

/* interface IShellPropSheetExt */
/* [unique][local][object][uuid] */ 


enum __MIDL_IShellPropSheetExt_0001
    {	EXPPS_FILETYPES	= 0x1
    } ;
typedef UINT EXPPS;


EXTERN_C const IID IID_IShellPropSheetExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214E9-0000-0000-C000-000000000046")
    IShellPropSheetExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPages( 
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplacePage( 
            /* [in] */ EXPPS uPageID,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellPropSheetExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellPropSheetExt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellPropSheetExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellPropSheetExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IShellPropSheetExt * This,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *ReplacePage )( 
            IShellPropSheetExt * This,
            /* [in] */ EXPPS uPageID,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } IShellPropSheetExtVtbl;

    interface IShellPropSheetExt
    {
        CONST_VTBL struct IShellPropSheetExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellPropSheetExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellPropSheetExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellPropSheetExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellPropSheetExt_AddPages(This,pfnAddPage,lParam)	\
    (This)->lpVtbl -> AddPages(This,pfnAddPage,lParam)

#define IShellPropSheetExt_ReplacePage(This,uPageID,pfnReplaceWith,lParam)	\
    (This)->lpVtbl -> ReplacePage(This,uPageID,pfnReplaceWith,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellPropSheetExt_AddPages_Proxy( 
    IShellPropSheetExt * This,
    /* [in] */ LPFNSVADDPROPSHEETPAGE pfnAddPage,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IShellPropSheetExt_AddPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellPropSheetExt_ReplacePage_Proxy( 
    IShellPropSheetExt * This,
    /* [in] */ EXPPS uPageID,
    /* [in] */ LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IShellPropSheetExt_ReplacePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellPropSheetExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0171 */
/* [local] */ 

typedef IShellPropSheetExt *LPSHELLPROPSHEETEXT;



extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0171_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0171_v0_0_s_ifspec;

#ifndef __IRemoteComputer_INTERFACE_DEFINED__
#define __IRemoteComputer_INTERFACE_DEFINED__

/* interface IRemoteComputer */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IRemoteComputer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000214FE-0000-0000-C000-000000000046")
    IRemoteComputer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCWSTR pszMachine,
            /* [in] */ BOOL bEnumerating) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComputerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteComputer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteComputer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteComputer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IRemoteComputer * This,
            /* [in] */ LPCWSTR pszMachine,
            /* [in] */ BOOL bEnumerating);
        
        END_INTERFACE
    } IRemoteComputerVtbl;

    interface IRemoteComputer
    {
        CONST_VTBL struct IRemoteComputerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComputer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteComputer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteComputer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteComputer_Initialize(This,pszMachine,bEnumerating)	\
    (This)->lpVtbl -> Initialize(This,pszMachine,bEnumerating)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteComputer_Initialize_Proxy( 
    IRemoteComputer * This,
    /* [in] */ LPCWSTR pszMachine,
    /* [in] */ BOOL bEnumerating);


void __RPC_STUB IRemoteComputer_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteComputer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0172 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0172_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0172_v0_0_s_ifspec;

#ifndef __IDavStorage_INTERFACE_DEFINED__
#define __IDavStorage_INTERFACE_DEFINED__

/* interface IDavStorage */
/* [object][uuid][helpstring] */ 


EXTERN_C const IID IID_IDavStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D0E62481-D5A2-4b86-AC11-C048E6D81DB6")
    IDavStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ LPWSTR pwszUrl,
            /* [in] */ LPWSTR pwszUsername,
            /* [in] */ LPWSTR pwszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDavStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDavStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDavStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDavStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDavStorage * This,
            /* [in] */ LPWSTR pwszUrl,
            /* [in] */ LPWSTR pwszUsername,
            /* [in] */ LPWSTR pwszPassword);
        
        END_INTERFACE
    } IDavStorageVtbl;

    interface IDavStorage
    {
        CONST_VTBL struct IDavStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDavStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDavStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDavStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDavStorage_Init(This,pwszUrl,pwszUsername,pwszPassword)	\
    (This)->lpVtbl -> Init(This,pwszUrl,pwszUsername,pwszPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDavStorage_Init_Proxy( 
    IDavStorage * This,
    /* [in] */ LPWSTR pwszUrl,
    /* [in] */ LPWSTR pwszUsername,
    /* [in] */ LPWSTR pwszPassword);


void __RPC_STUB IDavStorage_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDavStorage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0173 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0173_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0173_v0_0_s_ifspec;

#ifndef __IDynamicStorage_INTERFACE_DEFINED__
#define __IDynamicStorage_INTERFACE_DEFINED__

/* interface IDynamicStorage */
/* [object][uuid][helpstring] */ 


EXTERN_C const IID IID_IDynamicStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("694D8DB5-F7A4-4e72-A547-2F3DD5FA5B0D")
    IDynamicStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddIDList( 
            /* [in] */ DWORD cpidl,
            /* [size_is][in] */ LPITEMIDLIST *rgpidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddUnknown( 
            /* [in] */ REFIID riid,
            /* [in] */ IUnknown *pUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStorage( 
            /* [in] */ IStorage *pStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDataObject( 
            /* [in] */ LPDATAOBJECT pdtobj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDynamicStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDynamicStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDynamicStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDynamicStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddIDList )( 
            IDynamicStorage * This,
            /* [in] */ DWORD cpidl,
            /* [size_is][in] */ LPITEMIDLIST *rgpidl);
        
        HRESULT ( STDMETHODCALLTYPE *AddUnknown )( 
            IDynamicStorage * This,
            /* [in] */ REFIID riid,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *AddStorage )( 
            IDynamicStorage * This,
            /* [in] */ IStorage *pStorage);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IDynamicStorage * This,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *AddDataObject )( 
            IDynamicStorage * This,
            /* [in] */ LPDATAOBJECT pdtobj);
        
        END_INTERFACE
    } IDynamicStorageVtbl;

    interface IDynamicStorage
    {
        CONST_VTBL struct IDynamicStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDynamicStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDynamicStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDynamicStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDynamicStorage_AddIDList(This,cpidl,rgpidl)	\
    (This)->lpVtbl -> AddIDList(This,cpidl,rgpidl)

#define IDynamicStorage_AddUnknown(This,riid,pUnknown)	\
    (This)->lpVtbl -> AddUnknown(This,riid,pUnknown)

#define IDynamicStorage_AddStorage(This,pStorage)	\
    (This)->lpVtbl -> AddStorage(This,pStorage)

#define IDynamicStorage_AddStream(This,pStream)	\
    (This)->lpVtbl -> AddStream(This,pStream)

#define IDynamicStorage_AddDataObject(This,pdtobj)	\
    (This)->lpVtbl -> AddDataObject(This,pdtobj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDynamicStorage_AddIDList_Proxy( 
    IDynamicStorage * This,
    /* [in] */ DWORD cpidl,
    /* [size_is][in] */ LPITEMIDLIST *rgpidl);


void __RPC_STUB IDynamicStorage_AddIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDynamicStorage_AddUnknown_Proxy( 
    IDynamicStorage * This,
    /* [in] */ REFIID riid,
    /* [in] */ IUnknown *pUnknown);


void __RPC_STUB IDynamicStorage_AddUnknown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDynamicStorage_AddStorage_Proxy( 
    IDynamicStorage * This,
    /* [in] */ IStorage *pStorage);


void __RPC_STUB IDynamicStorage_AddStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDynamicStorage_AddStream_Proxy( 
    IDynamicStorage * This,
    /* [in] */ IStream *pStream);


void __RPC_STUB IDynamicStorage_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDynamicStorage_AddDataObject_Proxy( 
    IDynamicStorage * This,
    /* [in] */ LPDATAOBJECT pdtobj);


void __RPC_STUB IDynamicStorage_AddDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDynamicStorage_INTERFACE_DEFINED__ */


#ifndef __IQueryContinue_INTERFACE_DEFINED__
#define __IQueryContinue_INTERFACE_DEFINED__

/* interface IQueryContinue */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IQueryContinue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7307055c-b24a-486b-9f25-163e597a28a9")
    IQueryContinue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryContinueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryContinue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryContinue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryContinue * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContinue )( 
            IQueryContinue * This);
        
        END_INTERFACE
    } IQueryContinueVtbl;

    interface IQueryContinue
    {
        CONST_VTBL struct IQueryContinueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryContinue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQueryContinue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQueryContinue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQueryContinue_QueryContinue(This)	\
    (This)->lpVtbl -> QueryContinue(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQueryContinue_QueryContinue_Proxy( 
    IQueryContinue * This);


void __RPC_STUB IQueryContinue_QueryContinue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQueryContinue_INTERFACE_DEFINED__ */


#ifndef __IUserNotification_INTERFACE_DEFINED__
#define __IUserNotification_INTERFACE_DEFINED__

/* interface IUserNotification */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IUserNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70f9d15e-6e45-45e7-aaff-836f0343485f")
    IUserNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBalloonInfo( 
            /* [in] */ LPCWSTR pszTitle,
            /* [in] */ LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBalloonRetry( 
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconInfo( 
            /* [in] */ HICON hIcon,
            /* [in] */ LPCWSTR pszToolTip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonInfo )( 
            IUserNotification * This,
            /* [in] */ LPCWSTR pszTitle,
            /* [in] */ LPCWSTR pszText,
            /* [in] */ DWORD dwInfoFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetBalloonRetry )( 
            IUserNotification * This,
            /* [in] */ DWORD dwShowTime,
            /* [in] */ DWORD dwInterval,
            /* [in] */ UINT cRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconInfo )( 
            IUserNotification * This,
            /* [in] */ HICON hIcon,
            /* [in] */ LPCWSTR pszToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            IUserNotification * This,
            /* [in] */ IQueryContinue *pqc,
            /* [in] */ DWORD dwContinuePollInterval);
        
        END_INTERFACE
    } IUserNotificationVtbl;

    interface IUserNotification
    {
        CONST_VTBL struct IUserNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUserNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUserNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUserNotification_SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags)	\
    (This)->lpVtbl -> SetBalloonInfo(This,pszTitle,pszText,dwInfoFlags)

#define IUserNotification_SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount)	\
    (This)->lpVtbl -> SetBalloonRetry(This,dwShowTime,dwInterval,cRetryCount)

#define IUserNotification_SetIconInfo(This,hIcon,pszToolTip)	\
    (This)->lpVtbl -> SetIconInfo(This,hIcon,pszToolTip)

#define IUserNotification_Show(This,pqc,dwContinuePollInterval)	\
    (This)->lpVtbl -> Show(This,pqc,dwContinuePollInterval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUserNotification_SetBalloonInfo_Proxy( 
    IUserNotification * This,
    /* [in] */ LPCWSTR pszTitle,
    /* [in] */ LPCWSTR pszText,
    /* [in] */ DWORD dwInfoFlags);


void __RPC_STUB IUserNotification_SetBalloonInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserNotification_SetBalloonRetry_Proxy( 
    IUserNotification * This,
    /* [in] */ DWORD dwShowTime,
    /* [in] */ DWORD dwInterval,
    /* [in] */ UINT cRetryCount);


void __RPC_STUB IUserNotification_SetBalloonRetry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserNotification_SetIconInfo_Proxy( 
    IUserNotification * This,
    /* [in] */ HICON hIcon,
    /* [in] */ LPCWSTR pszToolTip);


void __RPC_STUB IUserNotification_SetIconInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserNotification_Show_Proxy( 
    IUserNotification * This,
    /* [in] */ IQueryContinue *pqc,
    /* [in] */ DWORD dwContinuePollInterval);


void __RPC_STUB IUserNotification_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUserNotification_INTERFACE_DEFINED__ */


#ifndef __IDockingWindow_INTERFACE_DEFINED__
#define __IDockingWindow_INTERFACE_DEFINED__

/* interface IDockingWindow */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDockingWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("012dd920-7b26-11d0-8ca9-00a0c92dbfe8")
    IDockingWindow : public IOleWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowDW( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseDW( 
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBorderDW( 
            /* [in] */ LPCRECT prcBorder,
            /* [in] */ IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDockingWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDockingWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDockingWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDockingWindow * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IDockingWindow * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IDockingWindow * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDW )( 
            IDockingWindow * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDW )( 
            IDockingWindow * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorderDW )( 
            IDockingWindow * This,
            /* [in] */ LPCRECT prcBorder,
            /* [in] */ IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved);
        
        END_INTERFACE
    } IDockingWindowVtbl;

    interface IDockingWindow
    {
        CONST_VTBL struct IDockingWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDockingWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDockingWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDockingWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDockingWindow_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IDockingWindow_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IDockingWindow_ShowDW(This,fShow)	\
    (This)->lpVtbl -> ShowDW(This,fShow)

#define IDockingWindow_CloseDW(This,dwReserved)	\
    (This)->lpVtbl -> CloseDW(This,dwReserved)

#define IDockingWindow_ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)	\
    (This)->lpVtbl -> ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDockingWindow_ShowDW_Proxy( 
    IDockingWindow * This,
    /* [in] */ BOOL fShow);


void __RPC_STUB IDockingWindow_ShowDW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDockingWindow_CloseDW_Proxy( 
    IDockingWindow * This,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IDockingWindow_CloseDW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDockingWindow_ResizeBorderDW_Proxy( 
    IDockingWindow * This,
    /* [in] */ LPCRECT prcBorder,
    /* [in] */ IUnknown *punkToolbarSite,
    /* [in] */ BOOL fReserved);


void __RPC_STUB IDockingWindow_ResizeBorderDW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDockingWindow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shobjidl_0177 */
/* [local] */ 

#define DBIM_MINSIZE    0x0001
#define DBIM_MAXSIZE    0x0002
#define DBIM_INTEGRAL   0x0004
#define DBIM_ACTUAL     0x0008
#define DBIM_TITLE      0x0010
#define DBIM_MODEFLAGS  0x0020
#define DBIM_BKCOLOR    0x0040
#include <pshpack8.h>
typedef /* [public][public] */ struct __MIDL___MIDL_itf_shobjidl_0177_0001
    {
    DWORD dwMask;
    POINTL ptMinSize;
    POINTL ptMaxSize;
    POINTL ptIntegral;
    POINTL ptActual;
    WCHAR wszTitle[ 256 ];
    DWORD dwModeFlags;
    COLORREF crBkgnd;
    } 	DESKBANDINFO;

#include <poppack.h>
#define DBIMF_NORMAL            0x0000
#define DBIMF_FIXED             0x0001
#define DBIMF_FIXEDBMP          0x0004   // a fixed background bitmap (if supported)
#define DBIMF_VARIABLEHEIGHT    0x0008
#define DBIMF_UNDELETEABLE      0x0010
#define DBIMF_DEBOSSED          0x0020
#define DBIMF_BKCOLOR           0x0040
#define DBIMF_USECHEVRON        0x0080
#define DBIMF_BREAK             0x0100
#define DBIF_VIEWMODE_NORMAL         0x0000
#define DBIF_VIEWMODE_VERTICAL       0x0001
#define DBIF_VIEWMODE_FLOATING       0x0002
#define DBIF_VIEWMODE_TRANSPARENT    0x0004

enum __MIDL___MIDL_itf_shobjidl_0177_0002
    {	DBID_BANDINFOCHANGED	= 0,
	DBID_SHOWONLY	= 1,
	DBID_MAXIMIZEBAND	= 2,
	DBID_PUSHCHEVRON	= 3,
	DBID_DELAYINIT	= 4,
	DBID_FINISHINIT	= 5,
	DBID_SETWINDOWTHEME	= 6
    } ;
#define DBPC_SELECTFIRST    (DWORD)-1
#define DBPC_SELECTLAST     (DWORD)-2
#define CGID_DeskBand IID_IDeskBand


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0177_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0177_v0_0_s_ifspec;

#ifndef __IDeskBand_INTERFACE_DEFINED__
#define __IDeskBand_INTERFACE_DEFINED__

/* interface IDeskBand */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDeskBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB0FE172-1A3A-11D0-89B3-00A0C90A90AC")
    IDeskBand : public IDockingWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBandInfo( 
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out][in] */ DESKBANDINFO *pdbi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeskBand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeskBand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeskBand * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IDeskBand * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ContextSensitiveHelp )( 
            IDeskBand * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDW )( 
            IDeskBand * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDW )( 
            IDeskBand * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBorderDW )( 
            IDeskBand * This,
            /* [in] */ LPCRECT prcBorder,
            /* [in] */ IUnknown *punkToolbarSite,
            /* [in] */ BOOL fReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandInfo )( 
            IDeskBand * This,
            /* [in] */ DWORD dwBandID,
            /* [in] */ DWORD dwViewMode,
            /* [out][in] */ DESKBANDINFO *pdbi);
        
        END_INTERFACE
    } IDeskBandVtbl;

    interface IDeskBand
    {
        CONST_VTBL struct IDeskBandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDeskBand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDeskBand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDeskBand_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IDeskBand_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IDeskBand_ShowDW(This,fShow)	\
    (This)->lpVtbl -> ShowDW(This,fShow)

#define IDeskBand_CloseDW(This,dwReserved)	\
    (This)->lpVtbl -> CloseDW(This,dwReserved)

#define IDeskBand_ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)	\
    (This)->lpVtbl -> ResizeBorderDW(This,prcBorder,punkToolbarSite,fReserved)


#define IDeskBand_GetBandInfo(This,dwBandID,dwViewMode,pdbi)	\
    (This)->lpVtbl -> GetBandInfo(This,dwBandID,dwViewMode,pdbi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDeskBand_GetBandInfo_Proxy( 
    IDeskBand * This,
    /* [in] */ DWORD dwBandID,
    /* [in] */ DWORD dwViewMode,
    /* [out][in] */ DESKBANDINFO *pdbi);


void __RPC_STUB IDeskBand_GetBandInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDeskBand_INTERFACE_DEFINED__ */



#ifndef __ShellObjects_LIBRARY_DEFINED__
#define __ShellObjects_LIBRARY_DEFINED__

/* library ShellObjects */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_ShellObjects;

EXTERN_C const CLSID CLSID_DriveSizeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("94357B53-CA29-4b78-83AE-E8FE7409134F")
DriveSizeCategorizer;
#endif

EXTERN_C const CLSID CLSID_DriveTypeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("B0A8F3CF-4333-4bab-8873-1CCB1CADA48B")
DriveTypeCategorizer;
#endif

EXTERN_C const CLSID CLSID_FreeSpaceCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("B5607793-24AC-44c7-82E2-831726AA6CB7")
FreeSpaceCategorizer;
#endif

EXTERN_C const CLSID CLSID_TimeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("3bb4118f-ddfd-4d30-a348-9fb5d6bf1afe")
TimeCategorizer;
#endif

EXTERN_C const CLSID CLSID_SizeCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("55d7b852-f6d1-42f2-aa75-8728a1b2d264")
SizeCategorizer;
#endif

EXTERN_C const CLSID CLSID_AlphabeticalCategorizer;

#ifdef __cplusplus

class DECLSPEC_UUID("3c2654c6-7372-4f6b-b310-55d6128f49d2")
AlphabeticalCategorizer;
#endif

EXTERN_C const CLSID CLSID_CompositeFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("FEF10DED-355E-4e06-9381-9B24D7F7CC88")
CompositeFolder;
#endif

EXTERN_C const CLSID CLSID_LocalCopyHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("021003e9-aac0-4975-979f-14b5d4e717f8")
LocalCopyHelper;
#endif

EXTERN_C const CLSID CLSID_ShellItem;

#ifdef __cplusplus

class DECLSPEC_UUID("9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917")
ShellItem;
#endif

EXTERN_C const CLSID CLSID_ImageProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("7ab770c7-0e23-4d7a-8aa2-19bfad479829")
ImageProperties;
#endif

EXTERN_C const CLSID CLSID_PropertiesUI;

#ifdef __cplusplus

class DECLSPEC_UUID("d912f8cf-0396-4915-884e-fb425d32943b")
PropertiesUI;
#endif

EXTERN_C const CLSID CLSID_UserNotification;

#ifdef __cplusplus

class DECLSPEC_UUID("0010890e-8789-413c-adbc-48f5b511b3af")
UserNotification;
#endif
#endif /* __ShellObjects_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shobjidl_0178 */
/* [local] */ 


extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0178_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shobjidl_0178_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HGLOBAL_UserSize(     unsigned long *, unsigned long            , HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserMarshal(  unsigned long *, unsigned char *, HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserUnmarshal(unsigned long *, unsigned char *, HGLOBAL * ); 
void                      __RPC_USER  HGLOBAL_UserFree(     unsigned long *, HGLOBAL * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long *, HICON * ); 

unsigned long             __RPC_USER  HMENU_UserSize(     unsigned long *, unsigned long            , HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal(  unsigned long *, unsigned char *, HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal(unsigned long *, unsigned char *, HMENU * ); 
void                      __RPC_USER  HMENU_UserFree(     unsigned long *, HMENU * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPCITEMIDLIST_UserSize(     unsigned long *, unsigned long            , LPCITEMIDLIST * ); 
unsigned char * __RPC_USER  LPCITEMIDLIST_UserMarshal(  unsigned long *, unsigned char *, LPCITEMIDLIST * ); 
unsigned char * __RPC_USER  LPCITEMIDLIST_UserUnmarshal(unsigned long *, unsigned char *, LPCITEMIDLIST * ); 
void                      __RPC_USER  LPCITEMIDLIST_UserFree(     unsigned long *, LPCITEMIDLIST * ); 

unsigned long             __RPC_USER  LPITEMIDLIST_UserSize(     unsigned long *, unsigned long            , LPITEMIDLIST * ); 
unsigned char * __RPC_USER  LPITEMIDLIST_UserMarshal(  unsigned long *, unsigned char *, LPITEMIDLIST * ); 
unsigned char * __RPC_USER  LPITEMIDLIST_UserUnmarshal(unsigned long *, unsigned char *, LPITEMIDLIST * ); 
void                      __RPC_USER  LPITEMIDLIST_UserFree(     unsigned long *, LPITEMIDLIST * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbcapture\resource.h ===
#define IDS_BADDIRNAME 1000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbattrib\xbattrib.cpp ===
/*
**
** xbdel
**
** Delete files on the Xbox
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "xbfile.hxx"
#include "xbfilr.hxx"
#include "optn.hxx"
#include <xboxverp.h>

DWORD dwAttributes;
DWORD dwMask;
BOOL fSuccess;

struct OFIL : public FILR
{
	OFIL(void) : FILR() {}
	OFIL(const char *sz) : FILR(sz) {}

	void DoWork(void);
	FILR *PfilrCopy(void) const { return new OFIL(*this); }
};

void OFIL::DoWork(void)
{
	PDM_FILE_ATTRIBUTES pdmfa;
	HRESULT hr;
    DM_FILE_ATTRIBUTES dmfaNew;

	pdmfa = PdmfaGet();
    if(dwMask) {
        pdmfa->Attributes ^= (pdmfa->Attributes ^ dwAttributes) & dwMask;
        if(pdmfa->Attributes == 0)
            pdmfa->Attributes = FILE_ATTRIBUTE_NORMAL;
        memset(&dmfaNew, 0, sizeof dmfaNew);
        dmfaNew.Attributes = pdmfa->Attributes;
        hr = HrSetFileAttributes(&dmfaNew);
        if(FAILED(hr))
            Warning(hr, 0);
        else
            fSuccess = TRUE;
    } else {
        /* Nothing to change, so we'll display */
        char sz[MAX_PATH+1];
        FillDisplayName(sz);
        printf("%c %c %c %s\n", pdmfa->Attributes & FILE_ATTRIBUTE_DIRECTORY ?
            'D' : ' ', pdmfa->Attributes & FILE_ATTRIBUTE_HIDDEN ?
            'H' : ' ', pdmfa->Attributes & FILE_ATTRIBUTE_READONLY ?
            'R' : ' ', sz);
        fSuccess = TRUE;
    }
}

BOOL OPTH::FParseOption(char *&sz, char ch)
{
    DWORD dw;

    switch(ch) {
    case '+':
    case '-':
        if(0 == _stricmp(sz, "ro")) {
            dw = FILE_ATTRIBUTE_READONLY;
            sz += 1;
        } else if(0 == _stricmp(sz, "hid")) {
            dw = FILE_ATTRIBUTE_HIDDEN;
            sz += 2;
        } else
            dw = 0;
        if(dw) {
            dwMask |= dw;
            if(ch == '+')
                dwAttributes |= dw;
            else
                dwAttributes &= ~dw;
            return TRUE;
        }
        if(ch == '+')
            return FALSE;
        break;
    }
	return FParseFilrOption(*sz);
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbattrib version " VER_PRODUCTVERSION_STR "\n\n"
        "Change file attributes of one or more files on the Xbox development\n"
        "or target system.\n");
	fprintf(stderr, "\nusage: %s [/x xboxname] [options] file [file] ...\n",
		m_szExe);
	fprintf(stderr, "\t/r\trecursive change\n"
		"\t/s\tsearch in subdirectories\n"
        "\t/h\tinclude hidden files\n"
        "\t+ro\tmake file read-only\n"
        "\t-ro\tmake file read-write\n"
        "\t+hid\tmake file hidden\n"
        "\t-hid\tmake file visible\n"
		"Specify Xbox files as xE:\\..., xD:\\..., etc.\n");
	exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
	char *szExe = *rgszArg;
    BOOL fRet = 0;

    /* Cut down on repeated connection requests */
    DmUseSharedConnection(TRUE);

	/* Process arguments */
	OPTH opth(cArg, rgszArg, "-/+");

	if(cArg < 1)
		opth.UsageFailure();

	for(; cArg--; ++rgszArg) {
		OFIL ofil(*rgszArg);
        fSuccess = FALSE;
		ofil.DoTree();
        fRet = fRet || !fSuccess;
	}

	DmUseSharedConnection(FALSE);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbcp\resource.h ===
#define IDS_NOTDIR 1000
#define IDS_ISDIR 1001
#define IDS_NOTEMPFILE 1002
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbdir\resource.h ===
#define IDS_BADDIRNAME 1000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbcapture\xbcapture.cpp ===
/*
**
** xbcapture
**
** Capture the screen of Xbox
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "optn.hxx"
#include "resource.h"
#include <xboxverp.h>
#include "xbfile.hxx"

BOOL OPTH::FParseOption(char *&sz, char)
{
    return TRUE;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbcapture version " VER_PRODUCTVERSION_STR "\n\n"
            "Captures the current image on the XBox's front buffer and saves\n"
            "it as the specified bitmap file.\n\n");
    fprintf(stderr, "\nusage: %s [/x xboxname] bitmap\n", m_szExe);
    exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
    DM_XBE xbe;
    HRESULT hr;

    /* Cut down on repeated connection requests */
    DmUseSharedConnection(TRUE);

    /* Process arguments */
    OPTH opth(cArg, rgszArg);

    if(cArg < 1)
        opth.UsageFailure();

    // verify destination filename ends in '.bmp'
    if (strlen(*rgszArg) < 4 || lstrcmpi(*rgszArg + strlen(*rgszArg) - 4, ".bmp"))
        fprintf(stderr, "Warning: The specified filename does not have a .bmp extension. The file may be unusable.\r\n");

    /* Screen Capture */
    hr = DmScreenShot(*rgszArg);
    if(FAILED(hr)) {
        if(hr == XBDM_FILEERROR)
            hr = HrLastError();
        Fatal(hr, 0, *rgszArg);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbcp\xbcp.cpp ===
/*
**
** xbcp
**
** Copy files to and from the Xbox
**
*/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "xbfile.hxx"
#include "xbfilr.hxx"
#include "optn.hxx"
#include "resource.h"
#include "xbfileres.h"
#include <xboxverp.h>

BOOL fQuiet;
BOOL fSuccess;
BOOL fForceRO;
BOOL fForceReplace;
BOOL fCopyIfNewer;
BOOL fSkipEmptyDirs;
BOOL fEnsureDir;

struct OFIL : public FILR
{
	OFIL *m_pofilFileDir;
	OFIL *m_pofilDirDir;
	FIL *m_pfilDestDir;
	int m_fDestDirExists;

	OFIL(const char *sz) : FILR(sz) {}
	OFIL(const FIL &fil) : FILR(fil) {}

	void DoWork(void);
	BOOL FStartDir(void);
	void EndDir(void);
	FILR *PfilrCopy(void) const { return new OFIL(*this); }

	BOOL FEnsureDestDirExists(void);
	void CopyOneFile(const FIL &filDst);
	void CopyOneName(const FIL &filDst, const FIL *pfilDstDir);
};

BOOL FReplaceFile(const FIL &fil)
{
	char sz[1024];

	if(fForceReplace)
		return TRUE;

	for(;;) {
		fil.FillDisplayName(sz);

		printf("Overwrite %s? (Yes/No/All): ", sz);
		if(!fgets(sz, sizeof sz, stdin)) {
			putchar('\n');
			return FALSE;
		}
		switch(*sz) {
		case 'y':
		case 'Y':
			return TRUE;
		case 'n':
		case 'N':
			return FALSE;
		case 'a':
		case 'A':
			return fForceReplace = TRUE;
		}
	}
}

void OFIL::CopyOneFile(const FIL &filDst)
{
	HRESULT hr;
	DM_FILE_ATTRIBUTES dmfa;
	PDM_FILE_ATTRIBUTES pdmfaSrc = PdmfaGet();
	char szSrc[1024];
	char szDst[1024];
	const FIL *pfilLocal;
	const FIL *pfilRemote;
	int ids = 0;

	/* Let's make sure we're good to go */
	if(!pdmfaSrc)
		return;

	/* If we're going to copy a directory, we just want to make the destination
	 * directory and be done */
	hr = filDst.HrGetFileAttributes(&dmfa);
	if(pdmfaSrc->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
		if(SUCCEEDED(hr)) {
			if(!(dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
				filDst.Warning(0, IDS_NOTDIR);
				return;
			} else if(fCopyIfNewer) {
				/* We'll just bail now and not report the name */
				fSuccess = TRUE;
				return;
			}
		}
	} else if(SUCCEEDED(hr)) {
		if(dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY) {
			/* We can't copy a file into a directory */
			filDst.Warning(0, IDS_ISDIR);
			return;
		}
		
		/* If we're doing copy-if-newer, then we'll reject the copy if the
		 * destination is too new */
		if(fCopyIfNewer && ((PULARGE_INTEGER)&dmfa.ChangeTime)->QuadPart >= 
			((PULARGE_INTEGER)&pdmfaSrc->ChangeTime)->QuadPart)
		{
			fSuccess = TRUE;
			return;
		}

		if(dmfa.Attributes & FILE_ATTRIBUTE_READONLY) {
			if(fForceRO) {
				dmfa.Attributes &= ~FILE_ATTRIBUTE_READONLY;
                if(!dmfa.Attributes)
                    dmfa.Attributes = FILE_ATTRIBUTE_NORMAL;
				hr = filDst.HrSetFileAttributes(&dmfa);
				if(FAILED(hr)) {
					filDst.Warning(hr, 0);
					return;
				}
			} else {
				filDst.Warning(0, IDS_READONLY);
				return;
			}
		}

		/* We're going to overwrite this file, so we need to ask */
		if(!FReplaceFile(filDst))
			return;
	}

	if(!fQuiet) {
		char szFileSrc[1024];
		char szFileDst[1024];

		FillDisplayName(szFileSrc);
		filDst.FillDisplayName(szFileDst);
		printf("%s => %s\n", szFileSrc, szFileDst);
	}

	/* Now we're ready to perform the copy */
	if(pdmfaSrc->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
		/* hr is still valid from the call to filDst.GetFileAttributes */
		if(FAILED(hr))
			hr = filDst.HrMkdir();
		if(FAILED(hr))
			filDst.Warning(hr, 0);
        else
            fSuccess = TRUE;
		return;
	}

	FillFullName(szSrc);
	filDst.FillFullName(szDst);
	if(m_fXbox) {
		if(filDst.m_fXbox) {
			/* Copy to a temp file first */
			FIL filTmp;
			char szTmp[1024];
			if(SUCCEEDED(filTmp.HrLocalTempFile())) {
				filTmp.FillFullName(szTmp);
				hr = DmReceiveFile(szTmp, szSrc);
				pfilRemote = this;
				if(SUCCEEDED(hr)) {
					hr = DmSendFile(szTmp, szDst);
					pfilRemote = &filDst;
				}
				if(hr == XBDM_FILEERROR)
					ids = IDS_NOTEMPFILE;
				filTmp.HrDelete();
			} else {
				pfilRemote = this;
				hr = E_UNEXPECTED;
				ids = IDS_NOTEMPFILE;
			}
        } else {
    		hr = DmReceiveFile(szDst, szSrc);
			pfilLocal = &filDst;
			pfilRemote = this;
        }
	} else {
        if(!filDst.m_fXbox)
            hr = CopyFile(szSrc, szDst, FALSE) ? XBDM_NOERR : XBDM_FILEERROR;
        else
		    hr = DmSendFile(szSrc, szDst);
		pfilLocal = this;
		pfilRemote = &filDst;
	}
	if(FAILED(hr)) {
		if(hr == XBDM_FILEERROR)
			pfilLocal->Warning(HrLastError(), ids);
		else
			pfilRemote->Warning(hr, ids);
    } else {
		fSuccess = TRUE;
	
    	/* Copy the attributes to the destination file */
		filDst.HrSetFileAttributes(pdmfaSrc);
    }
}

BOOL OFIL::FStartDir(void)
{
	/* Fix up the containment chain */
	m_pofilDirDir = m_pofilFileDir;
	m_pofilFileDir = this;

	/* We need to construct a FIL that corresponds to the destination directory
	 * that matches this source directory */
	m_pfilDestDir = new FIL(*m_pofilDirDir->m_pfilDestDir);
	m_pfilDestDir->Descend();
	strcpy(m_pfilDestDir->m_szName, m_szName);
	m_fDestDirExists = FALSE;

	return TRUE;
}

void OFIL::EndDir(void)
{
	m_pofilFileDir = m_pofilDirDir;
	delete m_pfilDestDir;
}

BOOL OFIL::FEnsureDestDirExists(void)
{
	HRESULT hr;
	DM_FILE_ATTRIBUTES dmfa;

	if(!m_fDestDirExists) {
		if(!m_pofilDirDir->FEnsureDestDirExists())
			return FALSE;
		m_fDestDirExists = 1;
		hr = m_pfilDestDir->HrGetFileAttributes(&dmfa);
		if(SUCCEEDED(hr)) {
			if(!(dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
				m_fDestDirExists = -1;
				Warning(hr, IDS_NOTDIR);
			}
		} else {
			hr = m_pfilDestDir->HrMkdir();
			if(FAILED(hr)) {
				m_fDestDirExists = -1;
				if(!fRecurse)
					/* If we're recursing, we should have already caught this
					 * error */
					Warning(hr, 0);
			}
		}
	}
	return m_fDestDirExists == 1;
}		

void OFIL::DoWork(void)
{
	PDM_FILE_ATTRIBUTES pdmfa = PdmfaGet();

	/* If this is a directory, we'll "copy" it (ie., make a destination
	 * directory) if we're recursive and not skipping empty directories */
	if(pdmfa) {
		if(pdmfa->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
			if(!fRecurse) {
				Warning(0, IDS_ISDIR);
				return;
			}
			if(fSkipEmptyDirs)
				return;
		}

		/* OK, we're going to copy this file.  Make sure the destination
		 * directory exists, and away we go */
		if(m_pofilFileDir->FEnsureDestDirExists()) {
			FIL filDst(*m_pofilFileDir->m_pfilDestDir);
			filDst.Descend();
			strcpy(filDst.m_szName, m_szName);

			CopyOneFile(filDst);
		}
	}
}

void OFIL::CopyOneName(const FIL &filDst, const FIL *pfilDstDir)
{
	/* Because we may go off and treat this ofil as a single file, we need to
	 * create another ofil to represent its parent directory */

	m_pfilDestDir = new FIL(filDst);
	OFIL ofil(*this);
	m_fDestDirExists = 1;
    if(!pfilDstDir && 0 == strcmp(m_szName, ".") || 0 == strcmp(m_szName, ".."))
    {
        /* We're copying "." or ".." into another existing directory.  Clearly
         * we can't create a subdir called "." or "..", so we'll just assume
         * that the correct action is to copy the _contents_ of "." */
        pfilDstDir = &filDst;
    }
	if(pfilDstDir) {
		/* Since we're faking up the matching directory, we expand out the
		 * startdir-dotree-enddir logic here and then replace the startdir
		 * logic with the equivalent faking */
		ofil.m_pfilDestDir = new FIL(*pfilDstDir);
		ofil.m_fDestDirExists = 0;
		ofil.m_pofilDirDir = this;
		ofil.m_pofilFileDir = &ofil;
		ofil.DoSubTree(NULL);
		ofil.EndDir();
	} else {
		ofil.m_pofilFileDir = this;
		ofil.DoTree(FALSE);
	}
	delete m_pfilDestDir;
}

BOOL OPTH::FParseOption(char *&sz, char)
{
	switch(*sz) {
	case 'f':
	case 'F':
		++fForceRO;
		// fall through
	case 'y':
	case 'Y':
		++fForceReplace;
		break;
	case 'q':
	case 'Q':
		++fQuiet;
		break;
	case 'd':
	case 'D':
		++fCopyIfNewer;
		break;
	case 'e':
	case 'E':
		++fSkipEmptyDirs;
		break;
	case 't':
	case 'T':
		++fEnsureDir;
		break;
	default:
		return FParseFilrOption(*sz);
	}
	return TRUE;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbcp version " VER_PRODUCTVERSION_STR "\n\n"
        "Copies one or more files to to or from the Xbox target system\n");
	fprintf(stderr, "\nusage: %s [/x xboxname] [options] srcfile ... destfile\n",
		m_szExe);
	fprintf(stderr, "\t/r\trecursive copy\n"
		"\t/s\tsearch in subdirectories\n"
        "\t/h\tinclude hidden files\n"
		"\t/q\tsuppress file list output\n"
		"\t/y\tdon't prompt to overwrite\n"
		"\t/d\tcopy files only if newer\n"
		"\t/e\tdon't copy empty directories\n"
		"\t/t\tcreate destination directory if it does not exist\n"
		"\t/f\tforce copy over read-only files\n"
		"Specify Xbox files as xE:\\..., xD:\\..., etc.\n");
	exit(1);
}

int __cdecl _tmain(int cArg, TCHAR **rgszArg)
{
	HRESULT hr;
	DM_FILE_ATTRIBUTES dmfa;
	FIL filDst;

    /* Cut down on repeated connection requests */
    DmUseSharedConnection(TRUE);

	/* Process arguments */
	OPTH opth(cArg, rgszArg);

	if(cArg < 1)
		opth.UsageFailure();

	if(cArg == 1)
		filDst = ".";
	else
		filDst = rgszArg[cArg - 1];
	if(filDst.FIsWildName()) {
		fprintf(stderr, "error: wildcards not allowed in destination name\n");
		exit(1);
	}

	hr = filDst.HrGetFileAttributes(&dmfa);

	/* Ensure we're copying to a directory if there's more than one file */
	if((cArg == 2 && FIsWildName(*rgszArg) || cArg > 2 || fSubdirs))
	{
		if(FAILED(hr) && fEnsureDir) {
			hr = filDst.HrEnsureDir();
			if(SUCCEEDED(hr))
				hr = filDst.HrGetFileAttributes(&dmfa);
		}
		if(FAILED(hr) || !(dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY))
			filDst.Fatal(hr, FAILED(hr) ? 0 : IDS_NOTDIR);
	}

	if(cArg == 1)
		/* Need to fake another argument so that we actually do the copy */
		++cArg;

	if(FAILED(hr) || !(dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
		/* If the destination file does not exist, then it's going to become a
		 * direct copy of whatever the first argument is.  If the first
		 * arg is a directory, then we create the second file as a directory
		 * and copy into it.  If the first arg is a file, we just do the
		 * copy */
		OFIL ofilSrc(*rgszArg);
		PDM_FILE_ATTRIBUTES pdmfa = ofilSrc.PdmfaGet();
		if(pdmfa) {
			if((pdmfa->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !fRecurse)
				ofilSrc.Fatal(0, IDS_ISDIR);
			hr = XBDM_NOERR;
			FIL filDir(filDst);
			filDir.m_szName[0] = 0;
			if(fEnsureDir)
				hr = filDir.HrEnsureDir();
			else
				hr = XBDM_NOERR;
			if(SUCCEEDED(hr)) {
				if(pdmfa->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
					/* We're copying the directory into a new location.  First
					 * copy the directory, so we get the output, then
					 * proceed to copy the tree */
					ofilSrc.CopyOneFile(filDst);
					ofilSrc.CopyOneName(filDir, &filDst);
				} else
					/* This is a straight file copy */
					ofilSrc.CopyOneFile(filDst);
				hr = E_FAIL;
			}
		}
	}
	if(SUCCEEDED(hr)) {
		for(; --cArg; ++rgszArg) {
			OFIL ofilSrc(*rgszArg);
			ofilSrc.CopyOneName(filDst, NULL);
		}
	}

	DmUseSharedConnection(FALSE);

    return fSuccess ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbdel\resource.h ===
#define IDS_DELDIR 1000
#define IDS_DELRO 1001
#define IDS_CANNOTDELETE  1002
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbecopy\resource.h ===
#define IDS_XBCP_ERROR   1001
#define IDS_XBCP_WARNING 1002
#define IDS_UNKOPT       1003
#define IDS_EXTARG       1004
#define IDS_BADFILEARGS  1005
#define IDS_GENERICERR   1006
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbdel\xbdel.cpp ===
/*
**
** xbdel
**
** Delete files on the Xbox
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "xbfile.hxx"
#include "xbfilr.hxx"
#include "optn.hxx"
#include "resource.h"
#include "xbfileres.h"
#include <xboxverp.h>

BOOL fForce;
//BOOL fRecurseAll;
BOOL fVerbose;
BOOL fSuccess;
BOOL fSucceedAlways;

struct OFIL : public FILR
{
	OFIL(void) : FILR(), m_fDeleteMe(FALSE) {}
	OFIL(const char *sz) : FILR(sz), m_fDeleteMe(FALSE) {}

	void DoWork(void);
	void EndDir(void);
	FILR *PfilrCopy(void) const { return new OFIL(*this); }

	BOOL FConfirmDelete(void) const;
	void DeleteOne(BOOL fDir);

	//BOOL m_fRecurseSav;
	BOOL m_fDeleteMe;
};

#if 0
BOOL OFIL::FConfirmDelete(void) const
{
	char szMsg[1024];
	char szName[1024];

	FillDisplayName(szName);

	for(;;) {
		if(!FFmtIds(IDS_DELDIR, szMsg, szName))
			sprintf(szMsg, "Delete %s? (Yes/No/All): ");
		printf(szMsg);
		if(!fgets(szMsg, sizeof szMsg, stdin)) {
			putchar('\n');
			return FALSE;
		}
		switch(szMsg[0]) {
		case 'a':
		case 'A':
			fRecurseAll = TRUE;
			// fall through
		case 'y':
		case 'Y':
			return fRecurse = TRUE;
		case 'n':
		case 'N':
			return FALSE;
		}
	}
}
#endif

void OFIL::DeleteOne(BOOL fDir)
{
	HRESULT hr;
	PDM_FILE_ATTRIBUTES pdmfa = PdmfaGet();

	if(pdmfa) {
		if(pdmfa->Attributes & FILE_ATTRIBUTE_READONLY) {
			if(fForce) {
				pdmfa->Attributes &= ~FILE_ATTRIBUTE_READONLY;
                if(!pdmfa->Attributes)
                    pdmfa->Attributes = FILE_ATTRIBUTE_NORMAL;
				HrSetFileAttributes(pdmfa);
			} else {
				Warning(0, IDS_READONLY);
				return;
			}
		}
		hr = HrDelete(fDir);
		if(FAILED(hr))
			Warning(hr, 0);
        else
            fSuccess = TRUE;
	}
}

void OFIL::EndDir(void)
{
	HRESULT hr;
	PDM_FILE_ATTRIBUTES pdmfa = PdmfaGet();

	if(m_fDeleteMe)
		DeleteOne(TRUE);
	//fRecurse = fRecurseAll ? TRUE : m_fRecurseSav;
}

void OFIL::DoWork(void)
{
	PDM_FILE_ATTRIBUTES pdmfa;
	HRESULT hr;

	pdmfa = PdmfaGet();
	if(pdmfa) {
		if(pdmfa->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
			/* We've been asked to delete this directory.  If we're marked
			 * as recursive, we'll delete it -- though not now; we'll need
			 * to delete it after its contents are gone.  If we're not marked
			 * as recursive, we'll ask whether we should switch to
			 * recursive mode, one-time or permanently, and do the appropriate
			 * work */
			//m_fRecurseSav = fRecurse;
			if(fRecurse /* || FConfirmDelete() */)
				m_fDeleteMe = TRUE;
			else {
                Warning(0, IDS_CANNOTDELETE);
				m_fDeleteMe = FALSE;
            }
		} else
			DeleteOne(FALSE);
	}
}

BOOL OPTH::FParseOption(char *&sz, char)
{
	switch(*sz) {
	case 'v':
		++fVerbose;
		break;
	case 'f':
		++fForce;
		break;
	case 'q':
		++fSucceedAlways;
        break;
	default:
		return FParseFilrOption(*sz);
	}
	return TRUE;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbdel version " VER_PRODUCTVERSION_STR "\n\n"
        "Deletes one or more files from the Xbox development or target system.\n");
	fprintf(stderr, "\nusage: %s [/x xboxname] [options] file [file] ...\n",
		m_szExe);
	fprintf(stderr, "\t/r\trecursive delete\n"
		"\t/s\tsearch in subdirectories\n"
        "\t/h\tinclude hidden files\n"
		"\t/f\tforce delete of read-only files\n"
		"Specify Xbox files as xE:\\..., xD:\\..., etc.\n");
	exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
	char *szExe = *rgszArg;
    BOOL fRet;

    /* Cut down on repeated connection requests */
    DmUseSharedConnection(TRUE);

	/* Process arguments */
	OPTH opth(cArg, rgszArg);

	if(cArg < 1)
		opth.UsageFailure();

    fRet = 0;
	for(; cArg--; ++rgszArg) {
		OFIL ofil(*rgszArg);
        fSuccess = FALSE;
		ofil.DoTree();
        fRet = fRet || !fSuccess;
	}

	DmUseSharedConnection(FALSE);

    return !fSucceedAlways && fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbecopy\xbecopy.cpp ===
/*
 *
 * xbecopy.cpp
 *
 * Copy an xbe to the remote, called by VC
 *
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include <xboxverp.h>
#include "xbfile.hxx"
#include "resource.h"

BOOL fNologo;

HRESULT HrEnsureDir(const FIL &fil)
{
	BOOL fRoot;
	HRESULT hr;
	DM_FILE_ATTRIBUTES dmfa;

	if(0 != strcmp(fil.m_szDir, "\\.")) {
		FIL filDir;
		/* Ensure that the parent directory exists */
		filDir = fil.m_szDir;
		filDir.m_fXbox = fil.m_fXbox;
		filDir.m_szName[0] = 0;
		hr = HrEnsureDir(filDir);
		if(FAILED(hr))
			return hr;
	}
	hr = fil.HrGetFileAttributes(&dmfa);
	if(SUCCEEDED(hr)) {
		if(dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)
			return XBDM_NOERR;
		else
			return XBDM_NOSUCHFILE;
	} else if(hr != XBDM_NOSUCHFILE)
		return hr;
	return fil.HrMkdir();
}

int __cdecl main(int cArg, char **rgszArg)
{
	char *rgszFiles[2];
	int iszFiles = 0;
	HRESULT hr;
	DM_FILE_ATTRIBUTES dmfa;
	WIN32_FILE_ATTRIBUTE_DATA fa;

    SetIdpIds(IDP_ERROR, IDS_XBCP_ERROR);
    SetIdpIds(IDP_WARNING, IDS_XBCP_WARNING);

	/* Parse the arguments.  Anything starting with a '/' we consider an
	 * argument, and everything else is a filename.  We accept two filenames,
	 * the source file and the remote file */

	while(++rgszArg, --cArg) {
		if(**rgszArg == '/') {
			if(!_stricmp(*rgszArg, "/NOLOGO"))
				++fNologo;
			else
                Warning(0, IDS_UNKOPT, *rgszArg);
		} else {
			if(iszFiles == 2)
                Warning(0, IDS_EXTARG, *rgszArg);
			else
				rgszFiles[iszFiles++] = *rgszArg;
		}
	}

	if(!fNologo)
		fprintf(stderr, "Microsoft (R) Xbox image remote copy %s\n"
			"Copyright (C) Microsoft Corporation.  All rights reserved.\n\n",
			VER_PRODUCTVERSION_STR);

	if(iszFiles != 2)
        Fatal(0, IDS_BADFILEARGS);

	/* Copy the file */
	DmUseSharedConnection(TRUE);

	if(!GetFileAttributesEx(rgszFiles[0], GetFileExInfoStandard, &fa)) {
		char szError[256];
		if(0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
				szError, sizeof szError, NULL))
			strcpy(szError, "cannot access file");
        Fatal(0, IDS_GENERICERR, rgszFiles[0], szError);
	}

	dmfa.CreationTime = fa.ftCreationTime;
	dmfa.ChangeTime = fa.ftLastWriteTime;
	dmfa.SizeHigh = fa.nFileSizeHigh;
	dmfa.SizeLow = fa.nFileSizeLow;
	dmfa.Attributes = fa.dwFileAttributes;

	FIL filRmt;
	if(rgszFiles[1][0] == 'x')
		filRmt = rgszFiles[1];
	else {
		char szFileName[MAX_PATH+1];
		szFileName[0] = 'x';
		strcpy(szFileName+1, rgszFiles[1]);
		filRmt = szFileName;
	}
	if(!filRmt.m_fXbox) {
        filRmt.Fatal(XBDM_BADFILENAME, 0);
	}

	FIL filDir(filRmt);
	filDir.m_szName[0] = 0;
	hr = HrEnsureDir(filDir);
	if(FAILED(hr)) {
		if(hr == XBDM_NOSUCHFILE)
			filRmt.m_szName[0] = 0;
		filRmt.Fatal(hr, 0);
	}

	hr = DmSendFile(rgszFiles[0], rgszFiles[1]);
	if(SUCCEEDED(hr))
		filRmt.HrSetFileAttributes(&dmfa);

	if(FAILED(hr))
		Fatal(hr, 0, hr == XBDM_FILEERROR ? rgszFiles[0] : rgszFiles[1]);

	DmUseSharedConnection(FALSE);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbdir\xbdir.cpp ===
/*
**
** xbdir
**
** Directory list for files on the Xbox
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "xbfile.hxx"
#include "xbfilr.hxx"
#include "optn.hxx"
#include "resource.h"
#include <xboxverp.h>

enum { mdOutLong, mdOutBare, mdOutWide };
enum { mdSortNone, mdSortName, mdSortSize, mdSortDate };
TIME_ZONE_INFORMATION g_tzi;
BOOL fHaveTimeZone;
int mdOut;
int mdSort;
BOOL fReverseSort;
BOOL fListedSomething;
BOOL fFirstHeader;
int g_cDirs;
int g_cFiles, g_cCurDirFiles;
ULONGLONG g_cbyTotalFileSize, g_cbyCurDirTotalFileSize;

static char g_szBuffer[32] = {'\0'};

char *FormatBigNumber(ULONGLONG n)
{
    // Convert the number into a comma-separated string; ie "1,234,567,890"
    char *sz = (char*)(g_szBuffer + 31);
    int i = 0;

    *sz = '\0';
    do {
        *--sz = ((char)(n%10)) + '0';
        if ((++i)%3 == 0 && n/10)
            *--sz = ',';
    } while (n/=10);

    return sz;
}

char *FormatNumber(int n)
{
    return FormatBigNumber((ULONGLONG)(ULONG)n);
}

/* Directory file */
struct DIRF : public FILR {
	BOOL m_fPrintedHeader;
	DIRF *m_pdirfDir;
	DIRF *m_pdirfNext;
	DIRF **m_ppdirfNext;
	DIRF *m_pdirfHead;
	BOOL m_fPrintingDir;

	DIRF(const FIL &fil) : FILR(fil), m_fPrintingDir(FALSE) {
		m_fBreadthFirst = TRUE;
		m_fPreOrder = true;
	}

	BOOL FStartDir(void);
	void DoWork(void);
	void EndDir(void);

	virtual void PrintHeader(void);
	virtual void PrintOne(void) {}
};

/* Directory list: long */
struct DIRL : public DIRF {
	DIRL(const FIL &fil) : DIRF(fil) { m_fPrintingDir = TRUE; }

	FILR *PfilrCopy(void) const { return new DIRL(*this); }

	void PrintOne(void);
};

/* Directory list: wide */
struct DIRW : public DIRF {

	DIRW(const FIL &fil) : DIRF(fil) {}

	void EndDir(void);
	FILR *PfilrCopy(void) const { return new DIRW(*this); }
};

/* Directory list: bare */
struct DIRB : public DIRF {
	DIRB(const FIL &fil) : DIRF(fil) { m_fPrintingDir = TRUE; }

	FILR *PfilrCopy(void) const { return new DIRB(*this); }

	void PrintHeader(void) {}
	void PrintOne(void);
};

BOOL FFtToLt(LPFILETIME lpft, LPSYSTEMTIME lpst)
{
	SYSTEMTIME stZ;

	/* Convert the file time to a system time */
	if(!FileTimeToSystemTime(lpft, &stZ))
		return FALSE;
	/* Convert the system time to a local time */
	if(!fHaveTimeZone)
		fHaveTimeZone = GetTimeZoneInformation(&g_tzi) != TIME_ZONE_ID_UNKNOWN;
	if(!fHaveTimeZone || !SystemTimeToTzSpecificLocalTime(&g_tzi, &stZ,
			lpst))
		*lpst = stZ;
	return TRUE;
}

DIRF *PdirfSort(DIRF *pdirf)
{
	DIRF *pdirf1;
	DIRF *pdirf2;
	DIRF **ppdirf1;
	DIRF **ppdirf2;
	int sgn;

	if(!pdirf || !pdirf->m_pdirfNext)
		return pdirf;

	ppdirf1 = &pdirf1;
	ppdirf2 = &pdirf2;

	while(pdirf) {
		*ppdirf1 = pdirf;
		ppdirf1 = &pdirf->m_pdirfNext;
		pdirf = *ppdirf1;
		if(pdirf) {
			*ppdirf2 = pdirf;
			ppdirf2 = &pdirf->m_pdirfNext;
			pdirf = *ppdirf2;
		}
	}
	*ppdirf1 = *ppdirf2 = NULL;

	pdirf1 = PdirfSort(pdirf1);
	pdirf2 = PdirfSort(pdirf2);

	ppdirf1 = &pdirf;
	while(pdirf1 || pdirf2) {
		if(!pdirf1)
			sgn = 1;
		else if(!pdirf2)
			sgn = -1;
		else {
			PDM_FILE_ATTRIBUTES pdmfa1 = pdirf1->PdmfaGet();
			PDM_FILE_ATTRIBUTES pdmfa2 = pdirf2->PdmfaGet();
			if(!pdmfa1)
				sgn = 1;
			else if(!pdmfa2)
				sgn = -1;
			else {
				switch(mdSort) {
				case mdSortName:
					sgn = _stricmp(pdirf1->m_szName, pdirf2->m_szName);
					break;
				case mdSortSize:
					if(pdmfa1->SizeHigh > pdmfa2->SizeHigh)
						sgn = 1;
					else if(pdmfa1->SizeHigh < pdmfa2->SizeHigh)
						sgn = -1;
					else if(pdmfa1->SizeLow > pdmfa2->SizeLow)
						sgn = 1;
					else
						sgn = -1;
					break;
				case mdSortDate:
					if(((PULARGE_INTEGER)&pdmfa1->ChangeTime)->QuadPart >
							((PULARGE_INTEGER)&pdmfa2->ChangeTime)->QuadPart)
						sgn = 1;
					else
						sgn = -1;
					break;
				}
				if(fReverseSort)
					sgn = -sgn;
			}
		}
		if(sgn < 0) {
			*ppdirf1 = pdirf1;
			ppdirf1 = &pdirf1->m_pdirfNext;
			pdirf1 = *ppdirf1;
		} else {
			*ppdirf1 = pdirf2;
			ppdirf1 = &pdirf2->m_pdirfNext;
			pdirf2 = *ppdirf1;
		}
	}

	*ppdirf1 = NULL;
	return pdirf;
}

void DIRF::PrintHeader(void)
{
	char szName[1024];

	if(!m_pdirfDir->m_fPrintedHeader) {
        m_pdirfDir->FillDisplayName(szName);
		printf("\n Directory of %s\n\n", szName);
		m_pdirfDir->m_fPrintedHeader = TRUE;
	}
}

BOOL DIRF::FStartDir(void)
{
	m_pdirfDir = this;
	m_fPrintedHeader = FALSE;

	if (!fSubdirs || m_fMatches)
		PrintHeader();

	/* Set up to keep a list of files in this directory */
	m_ppdirfNext = &m_pdirfHead;
	return TRUE;
}

void DIRF::DoWork(void)
{
	/* Add this file to the list */
	if(m_fPrintingDir && !mdSort)
		PrintOne();
	else {
		DIRF *pdirf = (DIRF *)PfilrCopy();
		*m_pdirfDir->m_ppdirfNext = pdirf;
		m_pdirfDir->m_ppdirfNext = &pdirf->m_pdirfNext;
	}
}

void DIRF::EndDir(void)
{
    if (m_fPrintedHeader)
    {
        printf("%16s File(s)",  FormatNumber(g_cCurDirFiles));
        printf(" %13s bytes\n", FormatBigNumber(g_cbyCurDirTotalFileSize));
        g_cCurDirFiles = 0;
        g_cbyCurDirTotalFileSize = 0;
    }

	*m_ppdirfNext = NULL;
	if(mdSort) {
		DIRF *pdirfHead = PdirfSort(m_pdirfHead);
		DIRF *pdirf;

		while(pdirfHead) {
			pdirf = pdirfHead;
			pdirfHead = pdirf->m_pdirfNext;
			pdirf->PrintOne();
			delete pdirf;
		}
	}
}

/* Long list: guts */
void DIRL::PrintOne(void)
{
	PDM_FILE_ATTRIBUTES pdmfa = PdmfaGet();
	char szTime[32];
	char szSize[32];

	PrintHeader();
    fListedSomething = TRUE;
    fFirstHeader = FALSE;

	/* Get the appropriate attributes and print this sucker out */
	SYSTEMTIME st;

	if(FFtToLt(&pdmfa->ChangeTime, &st))
		sprintf(szTime, "%02d/%02d/%04d  %02d:%02d%c",
			st.wMonth, st.wDay, st.wYear,
			st.wHour > 12 ? st.wHour - 12 : st.wHour,
			st.wMinute,
			st.wHour < 12 ? 'a' : 'p');
	else
		sprintf(szTime, "%-18.18s", "  <bad date>");

	if(pdmfa->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
		sprintf(szSize, "%-18.18s", "    <DIR>");
        g_cDirs++;
    }
	else {
		int ichReal = 18;
		int ich = 0;
		DWORD dwSize = pdmfa->SizeLow;

		szSize[ichReal] = 0;
		if(dwSize == 0) {
			szSize[--ichReal] = '0';
			--ichReal;
		} else while(ichReal-- && dwSize) {
			if(ich && (ich % 3) == 0)
				szSize[ichReal--] = ',';
			szSize[ichReal] = (char)(dwSize % 10) + '0';
			dwSize /= 10;
			++ich;
		}
		while(ichReal >= 0)
			szSize[ichReal--] = ' ';

        g_cbyTotalFileSize       += pdmfa->SizeLow;
        g_cbyCurDirTotalFileSize += pdmfa->SizeLow;
        g_cFiles++;
        g_cCurDirFiles++;
	}

	printf("%s  %s %s\n", szTime, szSize, pdmfa->Name[0] ? pdmfa->Name :
		m_szName);
}

/* Bare list: guts */
void DIRB::PrintOne(void)
{
	char szName[1024];

    fListedSomething = TRUE;
	if(fSubdirs || fRecurse) {
		FillDisplayName(szName);
		puts(szName);
	} else
		puts(m_szName);
}

/* Wide list: guts */
void DIRW::EndDir(void)
{
	const int ccol = 5;
	const int cchCol = (79 / ccol) - 1;
	DIRF *rgpdirf[ccol+1];
	int icol;
    int crw;

	*m_ppdirfNext = NULL;
	if(mdSort)
		m_pdirfHead = PdirfSort(m_pdirfHead);
	rgpdirf[0] = m_pdirfHead;
	/* Set up the column heads */
	for(icol = 1; icol <= ccol; ++icol) {
		rgpdirf[icol] = rgpdirf[icol - 1] ? rgpdirf[icol - 1]->m_pdirfNext :
			NULL;
	}
    crw = rgpdirf[0] ? 1 : 0;
	if(rgpdirf[ccol]) {
		/* We have at least one file per column; populate the columns */
		icol = 0;
		while(rgpdirf[ccol]) {
			for(int icolT = icol + 1; icolT <= ccol; ++icolT)
				rgpdirf[icolT] = rgpdirf[icolT]->m_pdirfNext;
            if(icol == 0)
                ++crw;
			icol = (icol + 1) % ccol;
		}
	}

	/* With all of the columns filled, we can start printing */
	while(crw--) {
		PrintHeader();
        fListedSomething = TRUE;
		/* If this is the last row, we need to null out all columns that
		 * have been finished */
		if(!rgpdirf[ccol - 1]) {
			while(icol < ccol)
				rgpdirf[icol++] = NULL;
			icol = 0;
		}
		/* Print out the files we have */
		if(rgpdirf[0]) {
			for(int icolT = 0; icolT < ccol; ++icolT) {
				if(rgpdirf[icolT]) {
					char sz[64];
					char *pszFormat;
					PDM_FILE_ATTRIBUTES pdmfa = rgpdirf[icolT]->PdmfaGet();
					DWORD dwAttr = pdmfa ? pdmfa->Attributes : 0;
					if(dwAttr & FILE_ATTRIBUTE_DIRECTORY) {
                        pszFormat = "[%s]";
                        g_cDirs++;
                    } else {
                        if(dwAttr & FILE_ATTRIBUTE_READONLY)
						    pszFormat = "%s*";
					    else
						    pszFormat = "%s";
                        g_cbyTotalFileSize += pdmfa->SizeLow;
                        g_cbyCurDirTotalFileSize += pdmfa->SizeLow;
                        g_cFiles++;
                        g_cCurDirFiles++;
                    }
					sprintf(sz, pszFormat, rgpdirf[icolT]->m_szName);
					printf("%-*.*s ", cchCol, cchCol, sz);
					rgpdirf[icolT] = rgpdirf[icolT]->m_pdirfNext;
				}
			}
			putchar('\n');
		}
	}

	/* Now we can free the file list on this directory */
	while(m_pdirfHead) {
		DIRF *pdirf = m_pdirfHead;
		m_pdirfHead = pdirf->m_pdirfNext;
		delete pdirf;
	}

    if (m_fPrintedHeader)
    {
        printf("%16s File(s)",  FormatNumber(g_cCurDirFiles));
        printf(" %13s bytes\n", FormatBigNumber(g_cbyCurDirTotalFileSize));
        g_cCurDirFiles = 0;
        g_cbyCurDirTotalFileSize = 0;
    }
}

void ListOneDir(const FIL &fil)
{
	DIRF *pdirf;
	LPCSTR szPattern;
	DM_FILE_ATTRIBUTES dmfa;

	switch(mdOut) {
	case mdOutBare:
		pdirf = new DIRB(fil);
		break;
	case mdOutWide:
		pdirf = new DIRW(fil);
		break;
	default:
		pdirf = new DIRL(fil);
		break;
	}

	if(!pdirf->FIsWildName() && SUCCEEDED(pdirf->HrGetFileAttributes(&dmfa)) &&
		(dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		/* As a directory file, we need to treat this as a wildcard on the
		 * directory contents */
		pdirf->Descend();
		pdirf->m_szName[0] = '*';
		pdirf->m_szName[1] = 0;
        /* And since we've at least found the directory we're going to list,
         * we can act as if we've already listed something so we don't generate
         * a file not found */
        fListedSomething = TRUE;
	}
	pdirf->DoTree(TRUE);
	delete pdirf;
}

BOOL OPTH::FParseOption(char *&sz, char)
{
	switch(*sz) {
	case 'b':
		if(mdOut) {
bw:
			fprintf(stderr, "error: only one of /b and /w can be specified\n");
			exit(1);
		}
		mdOut = mdOutBare;
		break;
	case 'w':
		if(mdOut)
			goto bw;
		mdOut = mdOutWide;
		break;
	case 'o':
		if(mdSort) {
			fprintf(stderr, "error: only one sort mode can be specified\n");
			exit(1);
		}
		if(*++sz == '-') {
			++sz;
			fReverseSort = TRUE;
		}
		switch(*sz) {
		case 'd':
			mdSort = mdSortDate;
			break;
		case 'n':
			mdSort = mdSortName;
			break;
		case 's':
			mdSort = mdSortSize;
			break;
		default:
			UsageFailure();
		}
		break;
	default:
		return FParseFilrOption(*sz);
	}
	return TRUE;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbdir version " VER_PRODUCTVERSION_STR "\n\n"
        "Displays a list of files and subdirectories in a directory on either\n"
        "the Xbox development or target system.\n\n");
	fprintf(stderr, "\nusage: %s [/x xboxname] [options] files\n", m_szExe);
	fprintf(stderr, "\t/r\trecursive listing\n"
		"\t/s\tsearch in subdirectories\n"
        "\t/h\tinclude hidden files\n"
		"\t/b\tlist filenames only\n"
		"\t/w\tlist files in columns\n"
		"\t/o[-]{n,d,s}\n\torder files by one of\n"
		"\t\tn: name\n"
		"\t\td: date\n"
		"\t\ts: size\n"
		"\t\t-: reverse order\n"
		"Specify Xbox files as xE:\\..., xD:\\..., etc.\n");
	exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
    FIL filDir;
	HRESULT hr;
    DWORD cch;
    BOOL fRet;
    char szXboxName[256];
    char szTemp[1024];

    g_cFiles = 0;
    g_cDirs = 0;
    g_cbyTotalFileSize = 0;
    g_cCurDirFiles = 0;
    g_cbyCurDirTotalFileSize = 0;
    fFirstHeader = TRUE;

	/* Process arguments */
	OPTH opth(cArg, rgszArg);

	if(cArg < 0)
		opth.UsageFailure();

    /* Open up a shared connection so we can get an address out of it */
    DmUseSharedConnection(TRUE);
    hr = DmSendCommand(NULL, NULL, NULL, 0);

    /* Remember our name */
    cch = sizeof szXboxName;
    if(mdOut != mdOutBare && SUCCEEDED(DmGetXboxName(szXboxName, &cch))) {
        ULONG ulAddr;
        BYTE *pb = (BYTE *)&ulAddr;
        if(SUCCEEDED(hr) && SUCCEEDED(DmResolveXboxName(&ulAddr)))
            printf(" Xbox target system %s (%d.%d.%d.%d)\n", szXboxName,
            pb[3], pb[2], pb[1], pb[0]);
        else
            printf(" Xbox target system %s\n", szXboxName);
    }

    if(FAILED(hr))
        /* Unable to connect */
        Fatal(hr, 0);

	if(cArg == 0) {
		filDir = "*";
		ListOneDir(filDir);
	    if(fSubdirs && !fRecurse) {
		    fSubdirs = FALSE;
		    fRecurse = TRUE;
	    }
	} else {
		for(; cArg--; ++rgszArg) {
			filDir = *rgszArg;
			ListOneDir(filDir);
		}
	}

    // Output total sizes
    if (fListedSomething && mdOut != mdOutBare) {
        ULARGE_INTEGER nFreeBytes, nFreeOnDisk, nBytesOnDisk;

        if (fRecurse || fSubdirs) {
            printf("\n     Total Files Listed:\n");
            printf("%16s File(s)",  FormatNumber(g_cFiles));
            printf("%14s bytes\n", FormatBigNumber(g_cbyTotalFileSize));
        }
        printf("%16s dir(s)", FormatNumber(g_cDirs));

        if (filDir.m_fXbox)
        {
            sprintf(szTemp, "%c:\\", filDir.m_fXbox);
            DmGetDiskFreeSpace(szTemp, &nFreeBytes, &nBytesOnDisk, &nFreeOnDisk);
        } else {
            // Check if a drive was specified
            if (filDir.m_chPCDrive)
                sprintf(szTemp, "%c:\\", filDir.m_chPCDrive);
            else {
                // No drive specified - use current drive
                char sz[MAX_PATH];
                GetCurrentDirectory(MAX_PATH, sz);
                sprintf(szTemp, "%c:\\", sz[0]);
            }
            GetDiskFreeSpaceEx(szTemp, &nFreeBytes, &nBytesOnDisk, &nFreeOnDisk);
        }
        if (nFreeBytes.HighPart)
        {
            sprintf(szTemp, "  %s", FormatBigNumber(nFreeBytes.QuadPart));
            printf("%13s bytes free\n", szTemp);
        }
        else
            printf("  %13s bytes free\n", FormatNumber(nFreeBytes.LowPart));
    }

	DmUseSharedConnection(FALSE);

    if(!fListedSomething)
        printf("File Not Found\n");
    return !fListedSomething;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbfile\error.cpp ===
/*
 *
 * error.cpp
 *
 * deal with errors
 *
 */

#include "precomp.hxx"
#include "xbfileres.h"
#include <stdarg.h>

DWORD rgidsPrefix[] = {
    IDS_ERROR,
    IDS_WARNING
};

void SetIdpIds(DWORD idp, DWORD ids)
{
    rgidsPrefix[idp] = ids;
}

static void FillError(LPTSTR szBuf, LPCTSTR szError)
{
	if(szError)
		_tcscat(szBuf, szError);
	else
		LoadString(GetModuleHandle(NULL), IDS_UNEXPECTED,
			szBuf + _tcslen(szBuf), 768);
}

BOOL FDoFmtIds(DWORD ids, LPTSTR szError, BOOL fPrefix, BOOL fFailSafe,
	LPCTSTR szFailSafe, va_list val)
{
	TCHAR szRes[1024];
	BOOL fRet;
	TCHAR *rgpsz[16];
	int csz = 0;

	if(!LoadString(GetModuleHandle(NULL), ids, szRes, sizeof szRes /
			sizeof(TCHAR)))
		ids = 0;
	if(ids == 0) {
		if(fFailSafe) {
			FillError(szError, szFailSafe);
			fRet = TRUE;
		} else
			fRet = FALSE;
	} else {
		TCHAR *pchIn = szRes;
		TCHAR *pchOut = szError;

		if(fPrefix) {
			/* Skip the "error:" prefix */
			while(*pchOut)
				++pchOut;
		}

		while(*pchIn) {
			if(*pchIn == '|') {
				/* Parameter */
				int isz = 0;

				++pchIn;
				while(_istdigit(*pchIn)) {
					isz = isz * 10 + (*pchIn - '0');
					++pchIn;
				}
				if(isz < 16) {
					/* Fetch our string argument */
					while(csz <= isz)
						rgpsz[csz++] = va_arg(val, TCHAR *);

					TCHAR *pchArg = rgpsz[isz];
					while(*pchArg)
						*pchOut++ = *pchArg++;
				}
			} else
				*pchOut++ = *pchIn++;
		}
		*pchOut = 0;
		fRet = TRUE;
	}

	return fRet;
}

BOOL FFmtIds(DWORD ids, LPTSTR lpsz, ...)
{
	va_list val;

	va_start(val, lpsz);
	BOOL fRet = FDoFmtIds(ids, lpsz, FALSE, FALSE, NULL, val);
	va_end(val);
	return fRet;
}

void ShowError(HRESULT hr, DWORD ids, DWORD idsPrefix, va_list val)
{
	TCHAR szError[1024];
	TCHAR szRes[1024];
	TCHAR szDmError[256];
    HRESULT hrTranslate;

    hrTranslate = DmTranslateError(hr, szDmError, sizeof(szDmError)/sizeof(TCHAR));
    if(FAILED(hrTranslate))
    {
        _stprintf(szDmError, TEXT("ERR:0x%0.8x(%d)"), hr, hr);
    }

	if(!LoadString(GetModuleHandle(NULL), idsPrefix, szError, sizeof szError
			/ sizeof(TCHAR)))
		szError[0] = 0;

	/* Some errors always get default strings */
	switch(hr) {
	case XBDM_CANNOTCONNECT:
	case XBDM_CONNECTIONLOST:
		FillError(szError, szDmError);
		_fputts(szError, stderr);
		_fputtc('\n', stderr);
		exit(1);
	}

	/* If no resource was provided, let's see if we can cook up a string
	 * ourselves */
	if(ids == 0) {
		switch(hr) {
		case XBDM_FILEERROR:
			ids = IDS_FILEERR;
			break;
		case XBDM_NOSUCHFILE:
			ids = IDS_NOFILE;
			break;
		case XBDM_ALREADYEXISTS:
			ids = IDS_EXISTS;
			break;
		case XBDM_DIRNOTEMPTY:
			ids = IDS_DIRNOTEMPTY;
			break;
		case XBDM_BADFILENAME:
			ids = IDS_BADFILENAME;
			break;
		case XBDM_CANNOTCREATE:
			ids = IDS_CANNOTCREATE;
			break;
		case XBDM_CANNOTACCESS:
			ids = IDS_CANNOTACCESS;
			break;
		case XBDM_DEVICEFULL:
			ids = IDS_DISKFULL;
			break;
		}
	}

	/* The rest of the errors get default strings if no resource was provided,
	 * or a string with optional parameters if we do have a resource */
	FDoFmtIds(ids, szError, TRUE, TRUE, szDmError, val);

	_fputts(szError, stderr);
	_fputtc('\n', stderr);
}

void Warning(HRESULT hr, DWORD ids, ...)
{
	va_list val;

	va_start(val, ids);
	ShowError(hr, ids, rgidsPrefix[IDP_WARNING], val);
	va_end(val);
}

void Fatal(HRESULT hr, DWORD ids, ...)
{
	va_list val;

	va_start(val, ids);
	ShowError(hr, ids, rgidsPrefix[IDP_ERROR], val);
	va_end(val);

	// clean up
	DmUseSharedConnection(FALSE);
	exit(1);
}

void FIL::Fatal(HRESULT hr, DWORD ids) const
{
	TCHAR sz[1024];
	FillDisplayName(sz);
	::Fatal(hr, ids, sz);
}

void FIL::Warning(HRESULT hr, DWORD ids) const
{
	TCHAR sz[1024];
	FillDisplayName(sz);
	::Warning(hr, ids, sz);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbfile\file.cpp ===
/*
**
** file.cpp
**
** File utilities
**
*/

#include "precomp.hxx"
#include <stdio.h>
#include "xbfileres.h"

FIL &FIL::operator =(LPCTSTR sz)
{
	const TCHAR *pchFile;
	LPCTSTR szFileName = sz;

	if((sz[0] == 'x' || sz[0] == 'X') && sz[2] == ':') {
		/* Looks like it could be an Xbox name */
		WCHAR wch = sz[1];
		if(wch >= 'a' && wch <= 'z')
			m_fXbox = (char)(wch - ('a' - 'A'));
		else if(wch >= 'A' && wch <= 'Z')
			m_fXbox = (char)wch;
		else
			m_fXbox = 0;
		if(m_fXbox)
			sz += 3;
    } else {
		m_fXbox = 0;

        // Check if PC Drive specified
        if (sz[1] == ':')
            m_chPCDrive = sz[0];
        else
            m_chPCDrive = 0;
    }

	if(!*sz)
		::Fatal(0, IDS_BADPATH, szFileName);

	Basename(sz, &pchFile, NULL);
	if(pchFile == sz) {
		if(m_fXbox) {
			fprintf(stderr, "error: Xbox pathnames cannot be relative\n");
			exit(1);
		}
		_tcscpy(m_szDir, ".");
	} else if(pchFile - sz > sizeof m_szDir) {
toolong:
		fprintf(stderr, "error: filename too long\n");
		exit(-1);
	} else {
		_tcsncpy(m_szDir, sz, pchFile - sz);
		/* Last char was the \, so nuke it -- unless we're talking about the
		 * root directory */
		if(pchFile == sz+1) {
			m_szDir[pchFile - sz] = '.';
			m_szDir[pchFile - sz + 1] = 0;
		} else
			m_szDir[pchFile - sz - 1] = 0;
	}

	if(!*pchFile) {
		/* No filename, but we had a directory, so we need to append a '.' to
		 * the directory name to make it valid */
		m_szDir[pchFile - sz] = '.';
		m_szDir[pchFile - sz + 1] = 0;
	} else if(_tcslen(pchFile) >= sizeof m_szName)
		goto toolong;
	_tcscpy(m_szName, pchFile);

	return *this;
}

HRESULT FIL::HrLocalTempFile(void)
{
	TCHAR sz[MAX_PATH + 1];
	TCHAR szPath[MAX_PATH + 1];

	if(!GetTempPath(sizeof szPath, szPath))
		return E_FAIL;
	if(!GetTempFileName(szPath, "XBF", 0, sz))
		return E_FAIL;
	*this = sz;
	return S_OK;
}

HRESULT HrLastError(void)
{
	switch(GetLastError())
	{
	case ERROR_PATH_NOT_FOUND:
	case ERROR_FILE_NOT_FOUND:
		return XBDM_NOSUCHFILE;
	case ERROR_DIR_NOT_EMPTY:
		return XBDM_DIRNOTEMPTY;
	case ERROR_ALREADY_EXISTS:
		return XBDM_ALREADYEXISTS;
	case ERROR_DISK_FULL:
		return XBDM_DEVICEFULL;
	default:
		return XBDM_CANNOTACCESS;
	}
}

HRESULT FIL::HrGetFileAttributes(PDM_FILE_ATTRIBUTES pdmfa) const
{
	TCHAR szFullName[1024];
	int cchName;
	WIN32_FILE_ATTRIBUTE_DATA fa;

	FillFullName(szFullName);
    if(m_fXbox) {
        HRESULT hr = DmGetFileAttributes(szFullName, pdmfa);
        switch(hr) {
        case XBDM_CANNOTCONNECT:
        case XBDM_CONNECTIONLOST:
        case XBDM_NOXBOXNAME:
            ::Fatal(hr, 0);
        }
        return hr;
    }

	if(!GetFileAttributesEx(szFullName, GetFileExInfoStandard, &fa))
		return HrLastError();

	pdmfa->CreationTime = fa.ftCreationTime;
	pdmfa->ChangeTime = fa.ftLastWriteTime;
	pdmfa->SizeHigh = fa.nFileSizeHigh;
	pdmfa->SizeLow = fa.nFileSizeLow;
	pdmfa->Attributes = fa.dwFileAttributes;

	cchName = strlen(m_szName);
	if(cchName >= sizeof pdmfa->Name)
		cchName = sizeof pdmfa->Name - 1;
	strncpy(pdmfa->Name, m_szName, cchName);
	pdmfa->Name[cchName] = 0;
	return S_OK;
}

HRESULT FIL::HrSetFileAttributes(PDM_FILE_ATTRIBUTES pdmfa) const
{
	TCHAR szFullName[1024];
	HANDLE h;
	HRESULT hr;
	FILETIME *pftCreate;
	FILETIME *pftChange;
    DWORD dw;

	FillFullName(szFullName);
	if(m_fXbox)
		return DmSetFileAttributes(szFullName, pdmfa);

    if(pdmfa->Attributes && !SetFileAttributes(szFullName, pdmfa->Attributes))
        return HrLastError();

    /* Only open the file if we're planning to change the times */
    dw = pdmfa->CreationTime.dwHighDateTime |
        pdmfa->CreationTime.dwLowDateTime | pdmfa->ChangeTime.dwHighDateTime |
        pdmfa->ChangeTime.dwLowDateTime;
    if(!dw)
        return XBDM_NOERR;
    
	h = CreateFile(szFullName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL, NULL);
	if(INVALID_HANDLE_VALUE == h)
		return HrLastError();

	if(pdmfa->CreationTime.dwHighDateTime || pdmfa->CreationTime.dwLowDateTime)
		pftCreate = &pdmfa->CreationTime;
	else
		pftCreate = NULL;
	if(pdmfa->ChangeTime.dwHighDateTime || pdmfa->ChangeTime.dwLowDateTime)
		pftChange = &pdmfa->ChangeTime;
	else
		pftChange = NULL;

    hr = SetFileTime(h, pftCreate, NULL, pftChange) ? XBDM_NOERR :
        HrLastError();

    CloseHandle(h);
    return hr;
}

#if 0
HRESULT FIL::HrMoveFile(const FIL &filTo, BOOL fSend) const
{
	char szFullFrom[1024];
	char szFullTo[1024];
				   
	FillFullName(szFullFrom);
	filTo.FillFullName(szFullTo);
	return fSend ? DmSendFile(szFullFrom, szFullTo) : DmReceiveFile(szFullTo,
		szFullFrom);
}
#endif

void FIL::Descend(void)
{
	/* Move the filename into the directory name in preparation for descending
	 * into another subdir */
	if(*m_szName) {
		int cchDir = strlen(m_szDir);
		int cchName = strlen(m_szName);
		if(cchDir + cchName + 1 >= sizeof m_szDir) {
			fprintf(stderr, "error: filename too long\n");
			exit(1);
		}
		m_szDir[cchDir++] = '\\';
		_tcscpy(m_szDir + cchDir, m_szName);
		m_szName[0] = 0;
	}
}

void FIL::FillFullName(LPSTR sz, BOOL fOmitXboxDrive) const
{
	int ich;
	const TCHAR *pch;

	if(m_fXbox && !fOmitXboxDrive) {
		/* We're going to start with the Xbox drive letter */
		*sz++ = m_fXbox;
		*sz++ = ':';
	}

	/* First we need to copy the directory over, removing .s from the directory
	 * path as we do so */
	pch = m_szDir;
	ich = 0;

	/* Check for .\ at the beginning */
	while(pch[0] == '.') {
		if(pch[1] == '\\') {
			/* Skip the opening .\ */
			pch += 2;
			continue;
		}
		if(pch[1] == 0)
			/* Skip the . and fall through the loop below */
			++pch;
		break;
	}

	while(*pch) {
		if(pch[0] == '\\' && pch[1] == '.') {
			if(pch[2] == '\\') {
				/* Found \.\ so skip the first two chars and keep going */
				pch += 2;
				continue;
			} else if(pch[2] == 0) {
				/* Found \. at the end of the path, so nuke the last two
				 * characters */
				break;
			}
		}
		/* Whatever we found is acceptable, so copy it and keep going */
		sz[ich++] = *pch++;
	}

	/* OK, we've nailed the directory portion.  Tack on the filename */
	if(*m_szName) {
		if(ich || *m_szDir == '\\')
			sz[ich++] = '\\';
		_tcscpy(sz + ich, m_szName);
	} else {
		if(!ich)
			/* We had . or \. for the directory and nothing for the filename.
			 * Make it look right */
			 sz[ich++] = *m_szDir == '\\' ? '\\' : '.';
		sz[ich] = 0;
	}
}

void FIL::FillDisplayName(LPTSTR sz) const
{
	if(m_fXbox) {
		*sz++ = 'x';
		*sz++ = m_fXbox + ('a' - 'A');
		*sz++ = ':';
	}
	FillFullName(sz, TRUE);
}

/* We just overload this struct definition to suit our own needs */
struct _DM_WALK_DIR {
	HANDLE h;
};

HRESULT FIL::HrWalkDir(PDM_WALK_DIR *ppdmwd, LPCTSTR szPatMatch,
    FAT *pfat)
{
	WIN32_FIND_DATA wfd;
	TCHAR rgch[1024];
	TCHAR *sz;
	HRESULT hr;
    PDM_FILE_ATTRIBUTES pdmfa;
    DM_FILE_ATTRIBUTES dmfa;

	/* Make sure we're ready to receive filenames */
	if(!*ppdmwd) {
		Descend();
		if(!m_fXbox) {
			/* FindFirstFile wants a wildcard search, not just the name of the
			 * directory */
			if(szPatMatch)
				strcpy(m_szName, szPatMatch);
			else {
				m_szName[0] = '*';
				m_szName[1] = 0;
			}
		}
		FillFullName(sz = rgch);
	} else
		sz = NULL;

    pdmfa = pfat ? &pfat->dmfa : &dmfa;

	do {
		if(m_fXbox) {
			DWORD cch = sizeof m_szName - 1;
			hr = DmWalkDir(ppdmwd, sz, pdmfa);
            strcpy(m_szName, pdmfa->Name);
		} else {
			do {
				if(!*ppdmwd) {
					HANDLE h;

					h = FindFirstFile(sz, &wfd);
					if(h == INVALID_HANDLE_VALUE) {
						hr = HrLastError();
						break;
					}
					*ppdmwd = (PDM_WALK_DIR)LocalAlloc(LMEM_FIXED,
						sizeof (struct _DM_WALK_DIR));
					(*ppdmwd)->h = h;
				} else if(!FindNextFile((*ppdmwd)->h, &wfd)) {
					hr = XBDM_ENDOFLIST;
					break;
				}
				hr = XBDM_NOERR;
			} while(SUCCEEDED(hr) && (0 == strcmp(wfd.cFileName, ".") ||
				0 == strcmp(wfd.cFileName, "..")));
            if(SUCCEEDED(hr)) {
				strcpy(m_szName, wfd.cFileName);
                if(pfat)
                    pfat->fValid = SUCCEEDED(HrGetFileAttributes(pdmfa));
            }
		}
		/* We keep looping over names as long as there are names and they
		 * match the wildcard pattern, if there is one */
	} while(SUCCEEDED(hr) && m_fXbox && szPatMatch && !FWildMatch(szPatMatch));

	return hr;
}

void FIL::EndWalkDir(PDM_WALK_DIR pdmwd)
{
	if(m_fXbox)
		DmCloseDir(pdmwd);
	else if(pdmwd) {
		FindClose(pdmwd->h);
		LocalFree(pdmwd);
	}
	*m_szName = NULL;
}

HRESULT FIL::HrMkdir(void) const
{
	TCHAR sz[1024];

	FillFullName(sz);
	if(m_fXbox)
		return DmMkdir(sz);

	return CreateDirectory(sz, NULL) ? S_OK : HrLastError();
}

HRESULT FIL::HrRename(FIL &filNew) const
{
	HRESULT hr;
	TCHAR szOld[1024];
	TCHAR szNew[1024];

	/* Can't rename across the network */
	if(!m_fXbox != !filNew.m_fXbox)
		return XBDM_MUSTCOPY;
	FillFullName(szOld);
	filNew.FillFullName(szNew);
	if(m_fXbox)
		hr = DmRenameFile(szOld, szNew);
	else
		hr = MoveFileEx(szOld, szNew, MOVEFILE_WRITE_THROUGH) ? S_OK :
			HrLastError();
	return hr;
}

HRESULT FIL::HrDelete(BOOL fIsDir) const
{
	HRESULT hr;
	TCHAR sz[1024];

	FillFullName(sz);
	if(m_fXbox) {
		hr = DmDeleteFile(sz, fIsDir);
	} else if(fIsDir)
		hr = RemoveDirectory(sz) ? S_OK : HrLastError();
	else
		hr = DeleteFile(sz) ? S_OK : HrLastError();
	return hr;
}

HRESULT HrEnsureDirName(BOOL fXbox, LPSTR szName, int cchName)
{
	char *pchDir;
	HRESULT hr;

	for(pchDir = szName + cchName; pchDir-- > szName && *pchDir != '\\'; );

	if(pchDir <= szName) {
		hr = XBDM_NOERR;
		/* No subdirectory here; check for drive name */
		for(pchDir = szName; *pchDir; ++pchDir)
			if(*pchDir == ':')
				/* This looks like a drive name, so we'll say it exists */
				return hr;
		/* Doesn't look like a drive name, so we'll assume it's to be created
		 * in the current directory */
	} else {
		*pchDir = 0;
		hr = HrEnsureDirName(fXbox, szName, pchDir - szName);
		*pchDir = '\\';
	}
	if(SUCCEEDED(hr)) {
		if(fXbox)
			hr = DmMkdir(szName);
		else
			hr = CreateDirectory(szName, NULL) ? S_OK : HrLastError();
		if(hr == XBDM_ALREADYEXISTS)
			hr = XBDM_NOERR;
	}
	return hr;
}

HRESULT FIL::HrEnsureDir(void) const
{
	HRESULT hr;
	char sz[1024];
	char *pchDir;

	FillFullName(sz);

	for(pchDir = sz; *pchDir; ++pchDir);
	return HrEnsureDirName(m_fXbox, sz, pchDir - sz);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbfile\optn.cpp ===
/*
 *
 * optn.cpp
 *
 * Option handling
 *
 */

#include "precomp.hxx"

OPTH::OPTH(int &cArg, char **&rgszArg, const char *szOptionChars)
{
	m_szExe = *rgszArg;
    const char *pchOptionMarker;
    char *szXboxEnv;

    /* Grab Xbox name from environment if it's there */
    szXboxEnv = getenv("XBOXIP");
    if(szXboxEnv && FAILED(DmSetXboxNameNoRegister(szXboxEnv))) {
	    fprintf(stderr, "error in Xbox name: %s\n", szXboxEnv);
        exit(1);
    }

	/* Process arguments */
	++rgszArg;
	while(--cArg && (pchOptionMarker = strchr(szOptionChars, **rgszArg))) {
		char *szArg = *rgszArg++;
		while(*++szArg) {
			switch(*szArg) {
			case 'x':
			case 'X':
				if(!--cArg)
					UsageFailure();
				if(FAILED(DmSetXboxName(*rgszArg++))) {
					fprintf(stderr, "error in Xbox name\n");
					exit(1);
				}
				break;
#if 0
			case '+':
				_asm int 3;
				break;
#endif
			default:
				if(!FParseOption(szArg, *pchOptionMarker))
					UsageFailure();
				break;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbfile\recurse.cpp ===
/*
 *
 * recurse.cpp
 *
 * Implementation for recursive routines
 *
 */

#include "precomp.hxx"

BOOL fRecurse;
BOOL fIncludeHidden;
BOOL fSubdirs;

BOOL FParseFilrOption(char ch)
{
	switch(ch) {
	case 'h':
	case 'H':
		++fIncludeHidden;
		break;
	case 'r':
	case 'R':
		++fRecurse;
		break;
	case 's':
	case 'S':
		++fSubdirs;
		break;
	default:
		return FALSE;
	}

	return TRUE;
}

PDM_FILE_ATTRIBUTES FILR::PdmfaGet(void)
{
	if(!m_fat.fValid) {
		HRESULT hr = FIL::HrGetFileAttributes(&m_fat.dmfa);
		if(FAILED(hr)) {
			Warning(hr, 0);
			return NULL;
		}
		m_fat.fValid = TRUE;
	}
	return &m_fat.dmfa;
}

void FILR::DoOneFile(LPCSTR szPat)
{
	PDM_FILE_ATTRIBUTES pdmfa = PdmfaGet();

	if(!pdmfa)
		return;
	if(m_fMatches && !m_fDirsOnly)
		DoWork();
	if(pdmfa->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
		/* Only do this directory if it's approved */
		if((fRecurse || fSubdirs) && FStartDir()) {
			DoSubTree(fRecurse && m_fMatches ? NULL : szPat, true);
		}
	}
}

void FILR::DoSubTree(LPCSTR szPattern, bool fDoEndDir)
{
	FILR *pfilr;
	PDM_WALK_DIR pdmwd;
	HRESULT hr;
	PDM_FILE_ATTRIBUTES pdmfa;
	FILR *pfilrList;
	FILR **ppfilr;

	pfilr = PfilrCopy();

	/* Walk the file tree and process each file that matches the pattern */
	pfilr->Descend();
	ppfilr = &pfilrList;
	pdmwd = NULL;
	while(SUCCEEDED(hr = pfilr->HrWalkDir(&pdmwd, NULL))) {
		pfilr->m_fMatches = szPattern ? pfilr->FWildMatch(szPattern) : TRUE;
        /* If this is no match and we're not going to recurse, then there's 
         * no reason to do an attributes fetch */
        if(!pfilr->m_fMatches && !fRecurse && !fSubdirs)
            continue;
		pdmfa = pfilr->PdmfaGet();
		if(!pdmfa)
			continue;
		if((pdmfa->Attributes & FILE_ATTRIBUTE_HIDDEN) && !fIncludeHidden)
			continue;
		if(m_fBreadthFirst && (fRecurse || fSubdirs) &&
			(pdmfa->Attributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			*ppfilr = pfilr->PfilrCopy();
			ppfilr = &(*ppfilr)->m_pfilrNext;
			if(pfilr->m_fMatches && !m_fDirsOnly)
				pfilr->DoWork();
		} else
			pfilr->DoOneFile(szPattern);
	}
	if(hr != XBDM_ENDOFLIST)
		Warning(hr, 0);
	pfilr->EndWalkDir(pdmwd);
	delete pfilr;

	if(fDoEndDir && m_fPreOrder)
		EndDir();

	/* Do any deferred work we have */
	*ppfilr = NULL;
	while(pfilrList) {
		pfilr = pfilrList;
		pfilrList = pfilr->m_pfilrNext;
		if(pfilr->FStartDir()) {
			pfilr->DoSubTree(fRecurse ? NULL : szPattern, true);
		}
		delete pfilr;
	}

	if(fDoEndDir && !m_fPreOrder)
		EndDir();
}

void FILR::DoTree(BOOL fIncludeRootDir)
{
	if(FIsWildName() || fSubdirs || fIncludeRootDir) {
		FILR *pfilr = PfilrCopy();
		pfilr->m_szName[0] = 0;
		if(!fIncludeRootDir || pfilr->FStartDir()) {
			pfilr->DoSubTree(m_szName, fIncludeRootDir ? true : false);
		}
		delete pfilr;
	} else {
		m_fMatches = TRUE;
		DoOneFile(NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmanage\resource.h ===
#define IDS_PASSWD_MISMATCH 1000
#define IDS_NOUSER 1001
#define IDS_USEREXISTS 1002
#define IDS_ACCESSDENIED 1003
#define IDS_NOTLOCKED 1004
#define IDS_NOMANAGE 1005
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbfile\xbfileres.h ===
#define IDS_ERROR 500
#define IDS_UNEXPECTED 501
#define IDS_DIRNOTEMPTY 502
#define IDS_FILEERR 503
#define IDS_NOFILE 504
#define IDS_EXISTS 505
#define IDS_BADPATH 506
#define IDS_WARNING 507
#define IDS_BADFILENAME 508
#define IDS_CANNOTCREATE 509
#define IDS_CANNOTACCESS 510
#define IDS_DISKFULL 511
#define IDS_READONLY 512
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbfile\wildcard.cpp ===
/*
**
** wildcard.c
**
** File wildcard matching
**
*/

#include "precomp.hxx"
#include <string.h>

void Basename(LPCSTR szPath, const char **ppchFile, const char **ppchExt)
{
	const char *szDir = NULL;
	const char *szStart = szPath;
	const char *szDot = NULL;

	for(; *szPath; ++szPath) {
		if(*szPath == '\\')
			szDir = szPath;
		else if(*szPath == '.')
			szDot = szPath;
	}
	/* Weed out extensions for . and .. */
	if(szDir && (!strcmp(szDir+1, ".") || !strcmp(szDir+1, "..")))
		szDot = NULL;
	if(ppchFile)
		*ppchFile = szDir ? szDir + 1 : szStart;
	if(ppchExt)
		*ppchExt = szDot ? szDot + 1 : NULL;
}

BOOL FIsWildName(LPCSTR sz)
{
	const char *pchFile;
	
	/* We don't take wildcards in directory names */
	Basename(sz, &pchFile, NULL);
    while(*pchFile) {
		if(*pchFile == '*' || *pchFile == '?')
			return TRUE;
        ++pchFile;
    }
	return FALSE;
}

BOOL FMatchSubstr(const char *pchPat, const char *pchMatch, int cch)
{
	while(cch > 0) {
		int ichQ;

		for(ichQ = 0; ichQ < cch; ++ichQ)
			if(pchPat[ichQ] == '?')
				break;
		if(ichQ && 0 != _strnicmp(pchPat, pchMatch, ichQ))
			return FALSE;
		pchPat += ichQ + 1;
		pchMatch += ichQ + 1;
		cch -= ichQ + 1;
	}
	return TRUE;
}

BOOL FPatMatch(const char *pchPat, int cchPat, const char *pchName,
	int cchName, int *rgichStart, int *rgichLen, int cichWilds)
{
	int cchSkip;
	int cchSubstr;
    const char *pchStart = pchName;
    const char *pchWildMatch;

	/* OK, here's our loop */
    for(;;) {
        cchSkip = 0;

        /* Find out how much wildcard we have */
        while(cchPat && (*pchPat == '*' || *pchPat == '?')) {
            if(*pchPat == '*')
                cchSkip = cchName;
            else
                ++cchSkip;
            ++pchPat, --cchPat;
        }
        /* If we have no non-wildcard text left, we're done */
   	    if(cchPat == 0) {
            if(cichWilds && cchName <= cchSkip) {
                if(cchName) {
                    *rgichStart = pchName - pchStart;
                    *rgichLen = cchName;
                    --cichWilds;
                }
                if(cichWilds)
                    rgichStart[1] = -1;
            }
		    return cchName <= cchSkip;
        }

		/* Find a section of pattern to match */
        cchSubstr = 0;
		while(cchSubstr < cchPat && pchPat[cchSubstr] != '*' &&
                pchPat[cchSubstr] != '?')
			++cchSubstr;
		if(cchName < cchSubstr)
			/* The pattern to match is longer than the name itself, so this
			 * is not a match */
			return FALSE;
        pchWildMatch = cchSkip ? pchName : NULL;
		if(cchSubstr == cchPat && cchSkip + cchSubstr >= cchName) {
			/* This is a terminal match, so we can just skip to the last
             * part of the string, but not over more characters than we're
             * allowed */
			pchName += cchName - cchSubstr;
            cchSkip -= cchName - cchSubstr;
			cchName = cchSubstr;
        }
        while(cchSubstr <= cchName) {
            if(0 == _strnicmp(pchPat, pchName, cchSubstr)) {
                /* We have a match, so skip past the bit we just matched */
			    cchPat -= cchSubstr;
			    pchPat += cchSubstr;
                cchName -= cchSubstr;
                pchName += cchSubstr;
                cchSubstr = 0;
                break;
            }
			/* As long as there's no match, we keep advancing */
			if(cchSkip-- == 0)
				/* We needed to match from the first character, so this is
				 * an outright non-match */
				return FALSE;
			++pchName, --cchName;
		}
        if(cchSubstr)
            /* We have unmatched text, so we need to give up */
            return FALSE;
        if(pchWildMatch && cichWilds) {
            /* We just matched some text, so let's remember what it is */
            const char *pchWildEnd = pchName - cchSubstr;
            *rgichStart++ = pchWildMatch - pchStart;
            *rgichLen++ = pchWildEnd - pchWildMatch;
            --cichWilds;
        }
	}
}

BOOL FWildMatch(LPCSTR szPattern, LPCSTR szName)
{
	BOOL fWild = FALSE;
	const char *pchExtPat;
	const char *pchExtName;
	int cchName;

	/* We walk the pattern string.  For each non-wildcard sequence we see, we
	 * look to see whether we can find a matching sequence in the name.  We
	 * deal with the base and extension separately.  Plus, we do some
	 * a priori matching based on the presence or absence of extensions */
	
	Basename(szPattern, NULL, &pchExtPat);
	Basename(szName, NULL, &pchExtName);

	if(!pchExtPat)
		/* The pattern has no extension, so we'll treat the name as if it's
		 * a unified string as well */
		 return FPatMatch(szPattern, strlen(szPattern), szName,
			 strlen(szName));
	cchName = pchExtName ? pchExtName - szName - 1 : strlen(szName);
	if(!FPatMatch(szPattern, pchExtPat - szPattern - 1, szName, cchName))
		return FALSE;
	return pchExtName ? FPatMatch(pchExtPat, strlen(pchExtPat), pchExtName,
		strlen(pchExtName)) : FPatMatch(pchExtPat, strlen(pchExtPat), NULL,
		0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\DmConnection.cpp ===
// DmConnection.cpp: implementation of the CDmConnection class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DmConnection.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDmConnection::CDmConnection() :
	m_pdmc(NULL),
	m_sharedConnectionOpened(false)
{
}

CDmConnection::~CDmConnection()
{
	CloseConnection();

	if (m_sharedConnectionOpened) {
		DmUseSharedConnection(FALSE);
	}
}

HRESULT CDmConnection::SetXboxNameNoRegister(LPCSTR pszName)
{
	return DmSetXboxNameNoRegister(pszName);
}

HRESULT CDmConnection::SetXboxName(LPCSTR pszName)
{
	return DmSetXboxName(pszName);
}

HRESULT CDmConnection::GetXboxName(LPSTR pszName, LPDWORD pcch)
{
	return DmGetXboxName(pszName, pcch);
}

HRESULT CDmConnection::SendCommand(LPCSTR szCmd, LPSTR szResp, LPDWORD pcb)
{
	HRESULT hr;

	if (!m_pdmc && FAILED(hr = OpenConnection())) {
		return hr;
	}

	return DmSendCommand(m_pdmc, szCmd, szResp, pcb);
}

HRESULT CDmConnection::OpenConnection()
{
	if (m_pdmc) {
		return S_OK;
	}

	return DmOpenConnection(&m_pdmc);
}

HRESULT CDmConnection::CloseConnection()
{
	HRESULT hr = S_OK;

	if (m_pdmc) {
		hr = DmCloseConnection(m_pdmc);
		m_pdmc = NULL;
	}

	return hr;
}

HRESULT CDmConnection::UseSharedConnection()
{
	if (m_sharedConnectionOpened) {
		return S_OK;
	}

	HRESULT hr = DmUseSharedConnection(TRUE);

	if (SUCCEEDED(hr)) {
		m_sharedConnectionOpened = true;
	}

	return hr;
}

HRESULT CDmConnection::ReceiveSocketLine(LPSTR szResponse, LPDWORD pcbSize) const
{
	return DmReceiveSocketLine(m_pdmc, szResponse, pcbSize);
}

LPSTR CDmConnection::_stristr(LPCSTR str1, LPCSTR str2)
{
    LPSTR cp = (LPSTR)str1;
    LPSTR s1, s2;

    if (!*str2) {
		return (LPSTR)str1;
	}

    while (*cp) {
        s1 = cp;
        s2 = (LPSTR)str2;

        while (*s1 && *s2 && _tolower(*s1) == _tolower(*s2)) {
			s1++, s2++;
		}

        if (!*s2) {
			return cp;
		}

        cp++;
    }

    return NULL;
}

LPSTR CDmConnection::GetParamPointer(LPCSTR szResp, LPCSTR szName)
{
	LPSTR p = _stristr(szResp, szName);

	if (p && (p = strchr(p, '=')) != NULL) {
		p++;
		while (isspace(*p)) {
			p++;
		}
	}

	return p;
}

bool CDmConnection::GetParam(LPCSTR szResp, LPCSTR szName, LPDWORD pdwResult)
{
	LPSTR p = GetParamPointer(szResp, szName);

	if (p) {
		*pdwResult = strtoul(p, NULL, 0);
	}

	return p != NULL;
}

HRESULT CDmConnection::TranslateError(HRESULT hr, LPSTR Buffer, DWORD cb)
{
	return DmTranslateError(hr, Buffer, cb);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmanage\xbmanage.cpp ===
/*
**
** xbcp
**
** Copy files to and from the Xbox
**
*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "xbfile.hxx"
#include "optn.hxx"
#include "xbfileres.h"
#include "resource.h"
#include <xboxverp.h>

enum { mdLockNone, mdLockUnlock, mdLockLock };
enum { mdPasswdNone, mdPasswdRemove, mdPasswdSet };
enum { mdPrivNone, mdPrivUnset, mdPrivSet };
int mdLock;
int mdPasswd;
BOOL fPrompt;
BOOL fList;
LPCSTR szHostName;
ULONG grbitPriv;
ULONG grbitPrivMask;

BOOL FSetPrivs(int mdPriv, DWORD bitPriv)
{
    switch(mdPriv) {
    case mdPrivNone:
        return FALSE;
    case mdPrivUnset:
        grbitPrivMask |= bitPriv;
        grbitPriv &= ~bitPriv;
        break;
    case mdPrivSet:
        grbitPrivMask |= bitPriv;
        grbitPriv |= bitPriv;
        break;
    }
    return TRUE;
}

void GetPasswd(LPCSTR szPrompt, LPSTR szPasswd, int cchMax)
{
    int ich;
    char ch;

    _cputs(szPrompt);
    for(ich = 0;;) {
        ch = (char)_getch();
        switch(ch) {
        case 10:
        case 13:
            _putch('\r');
            _putch('\n');
            szPasswd[ich >= cchMax - 1 ? cchMax : ich] = 0;
            return;
        case 8:
        case 127:
            if(ich > 0)
                --ich;
            break;
        default:
            if(ch >= 32 && ++ich < cchMax)
                szPasswd[ich - 1] = ch;
            break;
        }
    }
}

void NotLocked(void)
{
    Warning(0, IDS_NOTLOCKED);
    DmUseSharedConnection(FALSE);
    exit(-1);
}

void UserFatal(HRESULT hr, int ids, LPCSTR szUserName)
{
    switch(hr) {
    case XBDM_NOSUCHFILE:
        ids = IDS_NOUSER;
        break;
    case XBDM_CANNOTACCESS:
        ids = IDS_ACCESSDENIED;
        break;
    case XBDM_ALREADYEXISTS:
        ids = IDS_USEREXISTS;
        break;
    }
    Fatal(hr, ids, szUserName);
}

void FillAccessSz(LPSTR sz, DWORD dmpl)
{
    LPSTR szOrig = sz;

    if(dmpl & DMPL_PRIV_READ) {
        strcpy(sz, " read");
        sz += 5;
    }
    if(dmpl & DMPL_PRIV_WRITE) {
        strcpy(sz, " write");
        sz += 6;
    }
    if(dmpl & DMPL_PRIV_CONFIGURE) {
        strcpy(sz, " configure");
        sz += 10;
    }
    if(dmpl & DMPL_PRIV_CONTROL) {
        strcpy(sz, " control");
        sz += 8;
    }
    if(dmpl & DMPL_PRIV_MANAGE) {
        strcpy(sz, " manage");
        sz += 6;
    }
    if(sz == szOrig)
        strcpy(sz, " <none>");
}

void PrintBoxInfo(BOOL fSecure)
{
    char szName[1024];
    DWORD dw;
    HRESULT hr;

    dw = sizeof szName;
    hr = DmGetXboxName(szName, &dw);
    if(FAILED(hr))
        Fatal(hr, 0);

    printf(" Xbox target system %s\n Security is %s\n\n", szName,
        fSecure ? "enabled" : "disabled");
}

BOOL OPTH::FParseOption(char *&sz, char ch)
{
    int mdPriv;
    LPCSTR szOption = sz;

    /* We always parse options as complete words */
    sz += strlen(sz) - 1;

    switch(ch) {
    case '-':
        mdPriv = mdPrivUnset;
        break;
    case '+':
        mdPriv = mdPrivSet;
        break;
    default:
        mdPriv = mdPrivNone;
        break;
    }

    if(0 == _stricmp(szOption, "read"))
        return FSetPrivs(mdPriv, DMPL_PRIV_READ);
    else if(0 == _stricmp(szOption, "write"))
        return FSetPrivs(mdPriv, DMPL_PRIV_WRITE);
    else if(0 == _stricmp(szOption, "control"))
        return FSetPrivs(mdPriv, DMPL_PRIV_CONTROL);
    else if(0 == _stricmp(szOption, "configure"))
        return FSetPrivs(mdPriv, DMPL_PRIV_CONFIGURE);
    else if(0 == _stricmp(szOption, "manage"))
        return FSetPrivs(mdPriv, DMPL_PRIV_MANAGE);
    else if(0 == _stricmp(szOption, "all"))
        return FSetPrivs(mdPriv, -1);
    else if(0 == _stricmp(szOption, "lock")) {
        if(mdLock == mdLockUnlock)
            return FALSE;
        mdLock = mdLockLock;
    } else if(0 == _stricmp(szOption, "unlock")) {
        if(mdLock == mdLockLock)
            return FALSE;
        mdLock = mdLockUnlock;
    } else if(0 == _stricmp(szOption, "setpassword")) {
        if(mdPasswd == mdPasswdRemove)
            return FALSE;
        mdPasswd = mdPasswdSet;
    } else if(0 == _stricmp(szOption, "nopassword")) {
        if(mdPasswd == mdPasswdSet)
            return FALSE;
        mdPasswd = mdPasswdRemove;
    } else if(0 == _stricmp(szOption, "prompt"))
        ++fPrompt;
    else if(0 == _stricmp(szOption, "list")) {
        if(szHostName)
            return FALSE;
        ++fList;
    } else if(0 == _strnicmp(szOption, "host:", 5)) {
        if(szHostName || fList || !szOption[5])
            return FALSE;
        szHostName = szOption + 5;
    } else
        return FALSE;

    /* We won't take non-privilege options starting with '+', so even though
     * we've already processed them, we're still going to raise an error */
    return mdPriv != mdPrivSet;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbmanage version " VER_PRODUCTVERSION_STR "\n\n"
        "Manage access permissions of Xbox target system\n");
	fprintf(stderr, "\nusage: %s [/x xboxname] [options]\n",
		m_szExe);
	fprintf(stderr,
        "\t/lock        enable remote security\n"
		"\t/unlock      disable remote security\n"
        "\t/setpassword set remote administration password\n"
		"\t/nopassword  disable remote administration password\n"
		"\t/prompt      prompt for administration password\n"
		"\t/host:name   change permissions for specified host\n"
        "\t/list        list all permissions\n"
        "\n\t\tPermissions (precede with - or + to disable or enable):\n"
		"\t read        read files and directories\n"
        "\t write       write files\n"
        "\t control     debug or remotely control\n"
        "\t configure   change system configuration or options\n"
        "\t manage      remote access management\n"
        "\t all         all access permissions\n");
	exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
	HRESULT hr;
    char szPasswd[256];
    char szPasswd2[256];
    char szLocalhost[MAX_COMPUTERNAME_LENGTH + 1];
    char szTemp[256];
    DWORD dw;
    BOOL fSecure;
    PDM_WALK_USERS pwu;
    DM_USER dmu;
    BOOL fDidWork = FALSE;
    int c;

	/* Process arguments */
	OPTH opth(cArg, rgszArg, "/-+");

    /* Get the current computer name; we may need it */
    dw = sizeof szLocalhost;
    if(!GetComputerName(szLocalhost, &dw))
        Fatal(E_UNEXPECTED, 0);

    /* We need to use a single connection, so set it up */
    DmUseSharedConnection(TRUE);

    /* If we need to enter the admin password, then fetch it and attempt to
     * connect with it */
    if(fPrompt) {
        GetPasswd("Enter admin password:", szPasswd, sizeof szPasswd);
        hr = DmOpenSecureConnection(NULL, szPasswd);
        if(FAILED(hr))
            UserFatal(hr, 0, NULL);
    }

    /* Get the current lock state */
    hr = DmIsSecurityEnabled(&fSecure);
    if(FAILED(hr))
        UserFatal(hr, 0, NULL);

    /* Lock or unlock as desired */
    switch(mdLock) {
    case mdLockUnlock:
        hr = DmEnableSecurity(FALSE);
        fDidWork = TRUE;
        fSecure = FALSE;
        break;
    case mdLockLock:
        /* If we're locking a previously unlocked box, we'll give ourselves
         * all permissions */
        hr = DmEnableSecurity(TRUE);
        if(FAILED(hr))
            UserFatal(hr, 0, NULL);
        if(!fSecure) {
            hr = DmAddUser(szLocalhost, -1);
            if(FAILED(hr))
                UserFatal(hr, 0, szTemp);
        }
        fDidWork = TRUE;
        fSecure = TRUE;
        break;
    default:
        hr = XBDM_NOERR;
        break;
    }

    /* Deal with the admin passwd as requested */
    if(mdPasswd != mdPasswdNone) {
        if(!fSecure)
            NotLocked();
        switch(mdPasswd) {
        default:
            hr = DmSetAdminPassword(NULL);
            fDidWork = TRUE;
            break;
        case mdPasswdSet:
            GetPasswd("Enter new admin password:", szPasswd, sizeof szPasswd);
            GetPasswd("Enter it again:", szPasswd2, sizeof szPasswd2);
            if(strcmp(szPasswd, szPasswd2))
                Fatal(0, IDS_PASSWD_MISMATCH);
            hr = DmSetAdminPassword(szPasswd);
            fDidWork = TRUE;
            break;
        }
        if(FAILED(hr))
            UserFatal(hr, 0, NULL);
    }

    /* List permissions if requested */
    if(fList) {
        if(!fSecure)
            NotLocked();
        PrintBoxInfo(fSecure);
        pwu = NULL;
        while(SUCCEEDED(hr = DmWalkUserList(&pwu, &dmu))) {
            FillAccessSz(szTemp, dmu.AccessPrivileges);
            printf("%s:%s\n", dmu.UserName, szTemp);
        }
        DmCloseUserList(pwu);
        if(hr != XBDM_ENDOFLIST)
            UserFatal(hr, 0, NULL);
        fDidWork = TRUE;
    }

    /* If we haven't done any work yet, we're going to be getting or setting
     * privileges.  If we don't have a hostname, we'll assume it's our
     * host */
    if(!fDidWork && !szHostName && fSecure)
        szHostName = szLocalhost;

    /* Set permissions if requested */
    if(szHostName) {
        if(!fSecure)
            NotLocked();

        /* Start by getting the specified user's privilege level.  If it's
         * query-only and no hostname was specified, we'll try a
         * self-access query */
        if(szHostName != szLocalhost || grbitPrivMask ||
                FAILED(hr = DmGetUserAccess(NULL, &dw)))
            hr = DmGetUserAccess(szHostName, &dw);

        /* If this is a query-only operation and we failed to get the
         * privileges, then report an error.  Otherwise, we'll assume zero
         * privilege */
        if(FAILED(hr)) {
            if(!grbitPrivMask)
                UserFatal(hr, 0, szHostName);
            dw = 0;
        }

        /* If this is query-only, then just display the user info */
        if(!grbitPrivMask) {
            PrintBoxInfo(fSecure);
            FillAccessSz(szTemp, dw);
            printf("%s:%s\n", szHostName, szTemp);
        } else {
            /* If we're removing manage permission, we'd better make sure
             * there's another user on the box with manage permission, or
             * we'll run into big trouble */
            if((dw & DMPL_PRIV_MANAGE) && (grbitPrivMask & DMPL_PRIV_MANAGE) &&
                ((grbitPriv & DMPL_PRIV_MANAGE) == 0))
            {
                pwu = NULL;
                c = 0;
                while(SUCCEEDED(hr = DmWalkUserList(&pwu, &dmu))) {
                    if(dmu.AccessPrivileges & DMPL_PRIV_MANAGE)
                        ++c;
                }
                DmCloseUserList(pwu);
                if(hr != XBDM_ENDOFLIST)
                    UserFatal(hr, 0, NULL);
                /* We need two users with manage permission, since we've
                 * counted this user as one */
                if(c < 2)
                    Fatal(0, IDS_NOMANAGE);
            }
            /* Change the appropriate bits */
            dw ^= (dw ^ grbitPriv) & grbitPrivMask;

            /* If the resultant permission is none, then simply remove the
             * user from the list.  Otherwise, we'll set in the new permission
             * bits.  If the previous attempt to get user privileges failed,
             * we'll try to add a new user with the requested bits */
            if(!dw)
                hr = DmRemoveUser(szHostName);
            else if(FAILED(hr))
                hr = DmAddUser(szHostName, dw);
            else
                hr = DmSetUserAccess(szHostName, dw);
            if(FAILED(hr))
                UserFatal(hr, 0, szHostName);
        }
        fDidWork = TRUE;
    }

    if(!fDidWork)
        /* We haven't done anything yet, so we'll print details on this box */
        PrintBoxInfo(fSecure);

    /* And that's it */
	DmUseSharedConnection(FALSE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\DmConnection.h ===
// DmConnection.h: interface for the CDmConnection class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DMCONNECTION_H__D4ACF6C7_4C30_45D9_BF7B_85ADF1128503__INCLUDED_)
#define AFX_DMCONNECTION_H__D4ACF6C7_4C30_45D9_BF7B_85ADF1128503__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CDmConnection  
{
public:
	CDmConnection();
	virtual ~CDmConnection();

	HRESULT OpenConnection();
	HRESULT CloseConnection();
	HRESULT SendCommand(LPCSTR szCmd, LPSTR szResp = 0, LPDWORD pcb = 0);
	HRESULT UseSharedConnection();
	HRESULT ReceiveSocketLine(LPSTR szResponse, LPDWORD pcbSize) const;

	static LPSTR _stristr(LPCSTR str1, LPCSTR str2);
	static bool GetParam(LPCSTR szResp, LPCSTR szName, LPDWORD pdwResult);

	static HRESULT GetXboxName(LPSTR pszName, LPDWORD pcch);
	static HRESULT SetXboxName(LPCSTR pszName);
	static HRESULT SetXboxNameNoRegister(LPCSTR pszName);
	static HRESULT TranslateError(HRESULT hr, LPSTR Buffer, DWORD cb);

protected:
	static LPSTR GetParamPointer(LPCSTR szResp, LPCSTR szName);
	bool m_sharedConnectionOpened;
	PDM_CONNECTION m_pdmc;
};

#endif // !defined(AFX_DMCONNECTION_H__D4ACF6C7_4C30_45D9_BF7B_85ADF1128503__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\meminfo.h ===
// meminfo.h: interface for the CXboxMemoryInfo class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MEMINFO_H__CF13C9F7_ECBF_42FE_B045_C5F358849597__INCLUDED_)
#define AFX_MEMINFO_H__CF13C9F7_ECBF_42FE_B045_C5F358849597__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "DmConnection.h"
#include "PfnDatabase.h"	// Added by ClassView
#include "vad.h"	// Added by ClassView

class CXboxMemoryInfo : public CDmConnection  
{
public:
	CXboxMemoryInfo();
	virtual ~CXboxMemoryInfo();

	HRESULT DownloadVad();
	HRESULT DownloadMmGlobal();
	HRESULT DownloadPfnDatabase();

    const CPfnDatabase& GetPfnDatabase() const;
    const CVadArray& GetVad() const;
	
    ULONG GetAvailablePages() const;
    ULONG GetTotalNumberOfPhysicalPages() const;
    ULONG GetAllocatedPagesByUsage(ULONG Usage) const;
	ULONG GetAllocatedKBytesByUsage(ULONG Usage) const;

	bool IsValidHeap(PVOID Va) const;

protected:
	CVadArray m_vad;
	CPfnDatabase m_pfn;
	MMGLOBALDATA m_MmGlobalData;
	ULONG m_HighestPhysicalPage;
    ULONG m_MmNumberOfPhysicalPages;
    ULONG m_MmAvailablePages;
	ULONG m_AllocatedPagesByUsage[MmMaximumUsage];
    const PMMPFN m_PfnDatabaseAddr;
};

#endif // !defined(AFX_MEMINFO_H__CF13C9F7_ECBF_42FE_B045_C5F358849597__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xbmemmap.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\PfnDatabase.cpp ===
// PfnDatabase.cpp: implementation of the CPfnDatabase class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PfnDatabase.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPfnDatabase::CPfnDatabase() :
    m_NumberOfPages(0),
    m_pfn(NULL)
{
}

CPfnDatabase::~CPfnDatabase()
{
    if (m_pfn) {
        _ASSERTE(LocalSize(m_pfn) == sizeof(MMPFN) * m_NumberOfPages);
        LocalFree(m_pfn);
    }
}

bool CPfnDatabase::Grow(ULONG NumberOfPages)
{
    PMMPFN ppfn;

    if (m_NumberOfPages >= NumberOfPages) {
        return true;
    }

    if (m_pfn) {
        ppfn = (PMMPFN)LocalReAlloc(m_pfn, NumberOfPages * sizeof(MMPFN), LPTR);
    } else {
        ppfn = (PMMPFN)LocalAlloc(LPTR, NumberOfPages * sizeof(MMPFN));
    }

    if (!ppfn) {
        return false;
    }

    m_pfn = ppfn;
    m_NumberOfPages = NumberOfPages;
    return true;
}

bool CPfnDatabase::MakeCopy(PMMPFN ppfn, ULONG NumberOfPages)
{
    if (!Grow(NumberOfPages)) {
        return false;
    }

    memcpy(m_pfn, ppfn, sizeof(MMPFN)*NumberOfPages);
    return true;
}

bool CPfnDatabase::IsLockedPage(ULONG Page) const
{
    _ASSERTE(Page < m_NumberOfPages);

    if (m_pfn[Page].Pte.Hard.Valid != 0 || m_pfn[Page].Busy.Busy == 0 || \
        m_pfn[Page].Busy.LockCount == 0) {
        return false;
    }

    return true;
}

bool CPfnDatabase::IsFreePage(ULONG Page) const
{
    _ASSERTE(Page < m_NumberOfPages);
    return m_pfn[Page].Busy.Busy == 0;
}

bool CPfnDatabase::IsPhysicallyMappedPage(ULONG Page) const
{
    _ASSERTE(Page < m_NumberOfPages);
    return m_pfn[Page].Pte.Hard.Valid != 0;
}

const MMPTE* CPfnDatabase::GetPte(ULONG Page) const
{
    _ASSERTE(Page < m_NumberOfPages);
    return &m_pfn[Page].Pte;
}

ULONG CPfnDatabase::GetPteIndex(ULONG Page) const
{
    _ASSERTE(Page < m_NumberOfPages);
    return m_pfn[Page].Busy.PteIndex;
}

ULONG CPfnDatabase::GetPfnDatabaseSize() const
{
    return m_NumberOfPages;
}

ULONG CPfnDatabase::GetBusyType(ULONG Page) const
{
    _ASSERTE(Page < m_NumberOfPages);
    return m_pfn[Page].Busy.BusyType;   
}

ULONG CPfnDatabase::GetLockCount(ULONG Page) const
{
    _ASSERTE(Page < m_NumberOfPages);
    return m_pfn[Page].Busy.LockCount >> 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__987EC98E_EFAB_4588_B008_88EB1090D306__INCLUDED_)
#define AFX_STDAFX_H__987EC98E_EFAB_4588_B008_88EB1090D306__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#if !defined(_X86_)
#define _X86_
#endif

#ifndef _XBOX
#define _XBOX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <ntos.h>
#include <nturtl.h>
#include <mi.h>
#include <heap.h>
#include <xboxverp.h>

#include <stdio.h>
#include <stdlib.h>
#include <crtdbg.h>
#include <windows.h>
#include <xboxdbg.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__987EC98E_EFAB_4588_B008_88EB1090D306__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\meminfo.cpp ===
// meminfo.cpp: implementation of the CXboxMemoryInfo class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "meminfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXboxMemoryInfo::CXboxMemoryInfo() :
    m_HighestPhysicalPage(0),
    m_PfnDatabaseAddr(MM_PFN_DATABASE),
    m_MmNumberOfPhysicalPages(0),
    m_MmAvailablePages(0)
{
    ZeroMemory(&m_MmGlobalData, sizeof(m_MmGlobalData));
    ZeroMemory(m_AllocatedPagesByUsage, 
        sizeof(m_AllocatedPagesByUsage));
}

CXboxMemoryInfo::~CXboxMemoryInfo()
{
}

const CPfnDatabase& CXboxMemoryInfo::GetPfnDatabase() const
{
    return m_pfn;
}

const CVadArray& CXboxMemoryInfo::GetVad() const
{
    return m_vad;
}

ULONG CXboxMemoryInfo::GetAllocatedPagesByUsage(ULONG Usage) const
{
    _ASSERTE(Usage < MmMaximumUsage);
    return m_AllocatedPagesByUsage[Usage];
}

ULONG CXboxMemoryInfo::GetAllocatedKBytesByUsage(ULONG Usage) const
{
    return GetAllocatedPagesByUsage(Usage) * 4096 / 1024;
}

ULONG CXboxMemoryInfo::GetTotalNumberOfPhysicalPages() const
{
    return m_MmNumberOfPhysicalPages;
}

ULONG CXboxMemoryInfo::GetAvailablePages() const
{
    return m_MmAvailablePages;
}

HRESULT CXboxMemoryInfo::DownloadMmGlobal()
{
    HRESULT hr;
    CHAR szResp[256];
    SIZE_T Size = sizeof(szResp);

    hr = SendCommand("mmglobal");

    if (hr != XBDM_MULTIRESPONSE) {
        return E_UNEXPECTED;
    }

    for (;;) {
        
        Size = sizeof(szResp);
        hr = ReceiveSocketLine(szResp, &Size);
        
        if (FAILED(hr) || szResp[0] == '.') {
            break;
        }

        GetParam(szResp, "MmHighestPhysicalPage", &m_HighestPhysicalPage);
        GetParam(szResp, "RetailPfnRegion", (PULONG)&m_MmGlobalData.RetailPfnRegion);
        GetParam(szResp, "SystemPteRange", (PULONG)&m_MmGlobalData.SystemPteRange);
        GetParam(szResp, "AvailablePages",
            (LPDWORD)&m_MmGlobalData.AvailablePages);
        GetParam(szResp, "AllocatedPagesByUsage",
            (LPDWORD)&m_MmGlobalData.AllocatedPagesByUsage);
        GetParam(szResp, "AddressSpaceLock",
            (LPDWORD)&m_MmGlobalData.AddressSpaceLock);
        GetParam(szResp, "VadRoot", (LPDWORD)&m_MmGlobalData.VadRoot);
        GetParam(szResp, "VadHint", (LPDWORD)&m_MmGlobalData.VadHint);
        GetParam(szResp, "VadFreeHint", (LPDWORD)&m_MmGlobalData.VadFreeHint);
        GetParam(szResp, "MmNumberOfPhysicalPages", (LPDWORD)&m_MmNumberOfPhysicalPages);
        GetParam(szResp, "MmAvailablePages", (LPDWORD)&m_MmAvailablePages);
        GetParam(szResp, "PfnDatabase", (LPDWORD)&m_PfnDatabaseAddr);
    }

    if (m_MmGlobalData.AllocatedPagesByUsage) {
        Size = sizeof(m_AllocatedPagesByUsage);
        hr = DmGetMemory(m_MmGlobalData.AllocatedPagesByUsage, Size,
                m_AllocatedPagesByUsage, &Size);
    }

    return hr;
}

HRESULT CXboxMemoryInfo::DownloadPfnDatabase()
{
    DWORD cbRead;
    PMMPFN PfnDatabaseLocal;
    SIZE_T SizeOfPfnDatabase;
    HRESULT hr;

    hr = UseSharedConnection();

    if (FAILED(hr)) {
        return hr;
    }

    if (!m_HighestPhysicalPage) {
        hr = DownloadMmGlobal();
        if (FAILED(hr)) {
            return hr;
        }
    }

    if (m_HighestPhysicalPage == 0) {
        return E_FAIL;
    }

    ULONG HighestPhysicalPage = m_HighestPhysicalPage + 1;

    SizeOfPfnDatabase = HighestPhysicalPage * sizeof(MMPFN);

    PfnDatabaseLocal = (PMMPFN)LocalAlloc(LPTR, SizeOfPfnDatabase);

    if (PfnDatabaseLocal == NULL) {
        return E_OUTOFMEMORY;
    }

#if 0
    hr = DmGetMemory(m_PfnDatabase, SizeOfPfnDatabase, PfnDatabaseLocal, &cbRead);
#else
    ULONG CurrentPage;
    ULONG EntriesToRead;

    EntriesToRead = 100;

    for (CurrentPage = 0; CurrentPage < HighestPhysicalPage; CurrentPage += EntriesToRead) {

        if ((HighestPhysicalPage - CurrentPage) < EntriesToRead) {
            EntriesToRead = HighestPhysicalPage - CurrentPage;
        }

        hr = DmGetMemory(&m_PfnDatabaseAddr[CurrentPage], 
                EntriesToRead * sizeof(MMPFN),
                &PfnDatabaseLocal[CurrentPage],
                &cbRead);

        if (FAILED(hr)) {
            break;
        }
    }
#endif

    if (SUCCEEDED(hr)) {
        if (!m_pfn.MakeCopy(PfnDatabaseLocal, HighestPhysicalPage)) {
            hr = E_OUTOFMEMORY;
        }
    }

    LocalFree(PfnDatabaseLocal);
    return hr;
}

HRESULT CXboxMemoryInfo::DownloadVad()
{
    HRESULT hr = S_OK;
    PMMADDRESS_NODE VadToDump;
    PMMADDRESS_NODE Next;
    PMMADDRESS_NODE Parent;
    PMMADDRESS_NODE First;
    PMMADDRESS_NODE Left;
    MMVAD CurrentVad;
    ULONG Done;
    ULONG Result;

    if (!m_MmGlobalData.VadRoot && FAILED(hr = DownloadMmGlobal())) {
        return hr;
    }

    //
    // Suspend all XTL threads so that VAD list is not changed.
    //

    if (FAILED(hr = DmStop())) {
        return hr;
    }

    m_vad.ResetContent();

    if (FAILED(hr = DmGetMemory(m_MmGlobalData.VadRoot, sizeof(PMMVAD), 
        &VadToDump, &Result))) {
        goto cleanup;
    }

    //VadToDump = (PMMADDRESS_NODE)m_MmGlobalData.VadRoot;

    First = VadToDump;

    if (First == NULL) {
        goto cleanup;
    }

    RtlZeroMemory(&CurrentVad, sizeof(MMVAD));

    if (FAILED(hr = DmGetMemory(First, sizeof(MMVAD), &CurrentVad, &Result))) {
        goto cleanup;
    }

    while (CurrentVad.LeftChild != NULL) {

        First = CurrentVad.LeftChild;

        if (FAILED(hr = DmGetMemory(First, sizeof(MMVAD), &CurrentVad, &Result))) {
            goto cleanup;
        }
    }

    m_vad.Add(&CurrentVad);

    Next = First;

    while (Next != NULL) {

        if (CurrentVad.RightChild == NULL) {

            Done = TRUE;

            while ((Parent = CurrentVad.Parent) != NULL) {

                //
                // Locate the first ancestor of this node of which this
                // node is the left child of and return that node as the
                // next element.
                //

                if (FAILED(hr = DmGetMemory(Parent, sizeof(MMVAD), 
                    &CurrentVad, &Result))) {
                    goto cleanup;
                }

                if (CurrentVad.LeftChild == Next) {
                    Next = Parent;
                    m_vad.Add(&CurrentVad);
                    Done = FALSE;
                    break;
                }
                Next = Parent;
            }
            if (Done) {
                Next = NULL;
                break;
            }
        } else {

            //
            // A right child exists, locate the left most child of that right child.
            //

            Next = CurrentVad.RightChild;

            if (FAILED(hr = DmGetMemory(Next, sizeof(MMVAD), &CurrentVad, 
                &Result))) {
                goto cleanup;
            }

            while ((Left = CurrentVad.LeftChild) != NULL) {
                Next = Left;
                if (FAILED(hr = DmGetMemory(Next, sizeof(MMVAD), &CurrentVad, 
                    &Result))) {
                    goto cleanup;
                }
            }

            m_vad.Add(&CurrentVad);
        }
    }

cleanup:

    DmGo();
    return hr;
}

bool CXboxMemoryInfo::IsValidHeap(PVOID Va) const
{
    HEAP Heap;
    ULONG Result;

    if (FAILED(DmGetMemory((PVOID)Va, sizeof(HEAP), &Heap, &Result))) {
        return false;
    }

    return Heap.Signature == HEAP_SIGNATURE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\PfnDatabase.h ===
// PfnDatabase.h: interface for the CPfnDatabase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PFNDATABASE_H__ECC446E6_D544_48EF_8EC3_16917F87E20B__INCLUDED_)
#define AFX_PFNDATABASE_H__ECC446E6_D544_48EF_8EC3_16917F87E20B__INCLUDED_

#include "DmConnection.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPfnDatabase
{
public:
	CPfnDatabase();
	virtual ~CPfnDatabase();

	bool MakeCopy(PMMPFN ppfn, ULONG NumberOfPages);

	bool IsLockedPage(ULONG Page) const;
	bool IsFreePage(ULONG Page) const ;
	bool IsPhysicallyMappedPage(ULONG Page) const;

	ULONG GetPfnDatabaseSize() const;
	ULONG GetLockCount(ULONG Page) const;
	ULONG GetBusyType(ULONG Page) const;
    ULONG GetPteIndex(ULONG Page) const;
	const MMPTE* GetPte(ULONG Page) const;

protected:
	bool Grow(ULONG NumberOfPages);

	PMMPFN m_pfn;
	ULONG m_NumberOfPages;

private:
    CPfnDatabase& operator=(const CPfnDatabase& rhs);
};

#endif // !defined(AFX_PFNDATABASE_H__ECC446E6_D544_48EF_8EC3_16917F87E20B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\vad.cpp ===
// vad.cpp: implementation of the CVpn class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "vad.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVadArray::CVadArray() :
    m_arraySize(0),
    m_numberOfVad(0),
    m_vadArray(NULL)
{
}

CVadArray::~CVadArray()
{
    if (m_vadArray) {
        _ASSERTE(LocalSize(m_vadArray) == sizeof(MMVAD) * m_arraySize);
        LocalFree(m_vadArray);
    }
}

bool CVadArray::GrowBy(size_t elements)
{
    PMMVAD vadArray;
    size_t NewSize;

    NewSize = (m_arraySize + elements) * sizeof(MMVAD);

    if (m_vadArray) {
        vadArray = (PMMVAD)LocalReAlloc(m_vadArray, NewSize, LPTR);
    } else {
        vadArray = (PMMVAD)LocalAlloc(LPTR, NewSize);
    }

    if (!vadArray) {
        return false;
    }

    m_vadArray = vadArray;
    m_arraySize = m_arraySize + elements;

    return true;
}

bool CVadArray::Add(const MMVAD* vad)
{
    if (m_numberOfVad == m_arraySize && !GrowBy(256)) {
        return false;
    }

    m_vadArray[m_numberOfVad] = *vad;
    m_numberOfVad++;

    return true;
}

ULONG CVadArray::GetStartingVpn(size_t element) const
{
    _ASSERTE(element < m_numberOfVad);
    return m_vadArray[element].StartingVpn;
}

ULONG CVadArray::GetEndingVpn(size_t element) const
{
    _ASSERTE(element < m_numberOfVad);
    return m_vadArray[element].EndingVpn;
}

ULONG CVadArray::GetAllocationProtecion(size_t element) const
{
    _ASSERTE(element < m_numberOfVad);
    return m_vadArray[element].AllocationProtect;
}

void CVadArray::ResetContent()
{
    m_numberOfVad = 0;
}

size_t CVadArray::GetArraySize() const
{
    return m_numberOfVad;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\vad.h ===
// vad.h: interface for the CVpn class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VAD_H__5F567D61_C0A2_4170_B7EB_F0D51EF38E01__INCLUDED_)
#define AFX_VAD_H__5F567D61_C0A2_4170_B7EB_F0D51EF38E01__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CVadArray  
{
public:
	CVadArray();
	virtual ~CVadArray();

	bool Add(const MMVAD* vad);

	void ResetContent();

	ULONG GetAllocationProtecion(size_t element) const;
	ULONG GetEndingVpn(size_t element) const;
	ULONG GetStartingVpn(size_t element) const;
	size_t GetArraySize() const;

protected:
	bool GrowBy(size_t elements);

	size_t m_numberOfVad;
	PMMVAD m_vadArray;
	size_t m_arraySize;
};

#endif // !defined(AFX_VAD_H__5F567D61_C0A2_4170_B7EB_F0D51EF38E01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmkdir\xbmkdir.cpp ===
/*
**
** xbmkdir
**
** Make directories on the Xbox
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "xbfile.hxx"
#include "optn.hxx"
#include <xboxverp.h>

BOOL fEnsurePath;

BOOL OPTH::FParseOption(char *&sz, char)
{
	switch(*sz) {
	case 't':
	case 'T':
		++fEnsurePath;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbmkdir version " VER_PRODUCTVERSION_STR "\n\n"
        "Creates a directory on the Xbox development or target system.\n");
	fprintf(stderr, "\nusage: %s [-x xboxname] directory\n", m_szExe);
	fprintf(stderr, "Specify Xbox files as xE:\\..., xD:\\..., etc.\n");
	exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
	FIL fil;
	HRESULT hr;
	DM_FILE_ATTRIBUTES dmfa;

    /* Cut down on repeated connection requests */
    DmUseSharedConnection(TRUE);

	/* Process arguments */
	OPTH opth(cArg, rgszArg);

	if(cArg != 1)
		opth.UsageFailure();

	fil = *rgszArg;

	if(fEnsurePath) {
		FIL filDir(fil);
		filDir.m_szName[0] = 0;
		hr = filDir.HrEnsureDir();
		if(SUCCEEDED(hr))
			hr = fil.HrMkdir();
	} else
		hr = fil.HrMkdir();

	if ((XBDM_ALREADYEXISTS == hr) &&
		(SUCCEEDED(fil.HrGetFileAttributes(&dmfa))) &&
		(0 != (FILE_ATTRIBUTE_DIRECTORY & dmfa.Attributes)))
	{
		/* The directory already exists - just warn, don't return failure */
		fil.Warning(hr, 0);
	}
	else if(FAILED(hr))
	{
		fil.Fatal(hr, 0);
	}

	DmUseSharedConnection(FALSE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbmemdump\xbmemmap.cpp ===
// xbmemmap.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "meminfo.h"

CXboxMemoryInfo XboxMemory;

LPCSTR BusyTypesString = "?s#$pV*ic@d.";

LPCSTR BusyDescString[] = {
	"Unknown",
    "Stack",
    "Virtual Page Table",
    "System Page Table",
    "Pool",
    "Virtual Mapped",
    "System Memory",
    "Image",
    "File System Cache",
    "Contiguous Memory",
    "Debugger",
	"Free"					// Steal MmMaximumUsage for free pages
};

void usage()
{
    fprintf(stderr,
        "xbmemdump version " VER_PRODUCTVERSION_STR "\n"
        "Copyright (c) Microsoft Corporation.  All rights reserved.\n\n"
        "Usage:\txbmemdump [options]\n\n"
        "\t-x name\t  IP address or name of Xbox\n"
        "\t-s\t  suppress display usage summary information\n"
        "\t-l\t  display page frame number layout in long output format\n"
        "\t-w\t  display page frame number layout in wide output format\n"
		"\t-n width  specify width of page frame number list for wide view\n\t\t  default = 64\n"
        "\t-vad\t  display virtual address descriptor *\n"
        "\n"
        "\t* = all threads will be suspended while downloading information\n\n");
    exit(1);
}

void FormatPagesWideView(ULONG StartPage, ULONG NumberOfPages, LPSTR Buffer)
{
	CHAR ch;
	ULONG c, i, MaxPages, BusyType;

	MaxPages = XboxMemory.GetPfnDatabase().GetPfnDatabaseSize();

	for (i=0, c=StartPage; i<NumberOfPages; i++, c++) {

		if (c >= MaxPages) {
			break;
		}

		if (XboxMemory.GetPfnDatabase().IsPhysicallyMappedPage(c)) {
			ch = BusyTypesString[MmContiguousUsage];
		} else if (XboxMemory.GetPfnDatabase().IsFreePage(c)) {
			ch = BusyTypesString[MmMaximumUsage];
		} else {
			BusyType = XboxMemory.GetPfnDatabase().GetBusyType(c);
			if (BusyType >= MmMaximumUsage) {
				BusyType = MmMaximumUsage;
			}
			ch = BusyTypesString[BusyType];
		}

		Buffer[i] = ch;
	}

	Buffer[i] = 0;
}

void DumpPfnMapInWideView(ULONG ColumnWidth)
{
	CHAR Buffer[260];
	ULONG c, pages;

	pages = XboxMemory.GetPfnDatabase().GetPfnDatabaseSize();
	memset(Buffer, '-', ColumnWidth);
	Buffer[ColumnWidth] = 0;

	fprintf(stdout, "%-10s %*s\n", "Page Frame", ColumnWidth/2, "Page Type");
	fprintf(stdout, "---------- %s\n", Buffer);

	for (c=0; c<pages; c+=ColumnWidth) {
		FormatPagesWideView(c, ColumnWidth, Buffer);
		fprintf(stdout, "0x%08X %s\n", c, Buffer);
	}

	fprintf(stdout, "\n\n");

	for (c=0; c<=MmMaximumUsage; c++) {
		fprintf(stdout, "%c - %-25s", BusyTypesString[c], BusyDescString[c]);
		if (c & 1) {
			fprintf(stdout, "\n");
		}
	}

	fprintf(stdout, "\n\n");
}

static ULONG PageCategory(ULONG Page)
{
	if (XboxMemory.GetPfnDatabase().IsPhysicallyMappedPage(Page)) {
		return 0;
	} else if (!XboxMemory.GetPfnDatabase().IsFreePage(Page)) {
		return 1;
	} else {
		return 2;
	}
}

void DumpMemoryUsageSummary(void)
{
    int i;
    ULONG value;

    fprintf(stdout, "Usage Summary:\n\n");

    value = XboxMemory.GetTotalNumberOfPhysicalPages();
    fprintf(stdout, "%6d  Total number of pages (%d MB)\n",
        value, value * 4096 / (1024 * 1024));

    value = XboxMemory.GetAvailablePages();
    fprintf(stdout, "%6d  Available number of pages (%d KB)\n\n",
        value, value * 4096 / 1024);

    for (i=0; i<MmMaximumUsage; i++) {
        fprintf(stdout, "%6d pages used for %s (%d KB)\n",
            XboxMemory.GetAllocatedPagesByUsage(i),  BusyDescString[i],
            XboxMemory.GetAllocatedKBytesByUsage(i));
    }

    fprintf(stdout, "\n\n");
}

void DumpPfnMapInLongView(void)
{
	ULONG c, pages;
	ULONG RegionBegin;
	ULONG CurrentCategory, LastCategory;
    char* CachingType;
	const MMPTE* Pte;

	pages = XboxMemory.GetPfnDatabase().GetPfnDatabaseSize();
	RegionBegin = 0;
	LastCategory = PageCategory(0);

	fprintf(stdout, "%-17s  %7s  %-18s\n", "Page Frame Range", "Size", "Usage");
	fprintf(stdout, "-----------------  -------  ------------------\n");

    for (c=1; c<=pages; c++) {

        if (c == pages) {
            goto display;
        }

		CurrentCategory = PageCategory(c);

		if (LastCategory == CurrentCategory) {

			if (CurrentCategory == 2) {

				continue;

			} else if (CurrentCategory == 1) {

                if (XboxMemory.GetPfnDatabase().GetBusyType(RegionBegin) == \
                    XboxMemory.GetPfnDatabase().GetBusyType(c)) {
					continue;
				}

			} else {

				Pte = XboxMemory.GetPfnDatabase().GetPte(RegionBegin);

                if ((Pte->Long & 0x5FF) != \
                    (XboxMemory.GetPfnDatabase().GetPte(c)->Long & 0x5FF)) {
                    goto display;
                }

                //
                // Display this block if we found end-of-allocation mark
                //

                if (XboxMemory.GetPfnDatabase().GetPte(c)->Hard.GuardOrEndOfAllocation == 1) {
                    CurrentCategory = PageCategory(++c);
                    goto display;
                }

                if ((Pte->Long & 0x7FF) == \
                    (XboxMemory.GetPfnDatabase().GetPte(c)->Long & 0x7FF)) {
					continue;
				}
			}
		}

display:

		switch (LastCategory) {

		case 0:

			Pte = XboxMemory.GetPfnDatabase().GetPte(RegionBegin);

			if (Pte->Hard.CacheDisable != 0) {
				CachingType = "UC";
			} else if (Pte->Hard.WriteThrough == 1) {
				CachingType = "WC";
			} else {
				CachingType = "WB";
			}

			printf("0x%05X - 0x%05X  %6uK  %-18s  %s  %s  %s\n",
				RegionBegin, c-1, (c-RegionBegin) * 4, "Physical Mapped",
                CachingType, Pte->Hard.Write ? "R/W" : "R/O",
				Pte->Hard.PersistAllocation ? "Persist" : "");
			break;

		case 1:
		    fprintf(stdout, "0x%05X - 0x%05X  %6uK  %-18s\n",
				RegionBegin, c-1, (c-RegionBegin) * 4,
				BusyDescString[XboxMemory.GetPfnDatabase().GetBusyType(RegionBegin)]);
			break;

		default:
			fprintf(stdout, "0x%05X - 0x%05X  %6uK  %-18s\n", RegionBegin, c-1,
				(c-RegionBegin) * 4, "Free Page");
		}

		LastCategory = CurrentCategory;
		RegionBegin = c;
	}

    fprintf(stdout, "\n\n");
}

void DumpVadList(void)
{
    size_t vad;

    fprintf(stdout, "Virtual Address Descriptor List:\n\n");
    fprintf(stdout, "%-19s  %s\n", "Virtual Address", "Protection");
    fprintf(stdout, "-------------------  ----------\n");

    for (vad=0; vad<XboxMemory.GetVad().GetArraySize(); vad++) {

        ULONG Protection = XboxMemory.GetVad().GetAllocationProtecion(vad);
        PVOID StartingVa = MI_VPN_TO_VA(XboxMemory.GetVad().GetStartingVpn(vad));
        PVOID EndingVa = MI_VPN_TO_VA(XboxMemory.GetVad().GetEndingVpn(vad));

        fprintf(stdout, "%p - %p  0x%08X  %s%s%s%s%s%s%s%s%s%s%s %s\n",
            StartingVa, EndingVa, Protection,
            Protection & PAGE_NOACCESS ? "PAGE_NOACCESS " : "",
            Protection & PAGE_READONLY ? "PAGE_READONLY " : "",
            Protection & PAGE_READWRITE ? "PAGE_READWRITE " : "",
            Protection & PAGE_WRITECOPY ? "PAGE_WRITECOPY " : "",
            Protection & PAGE_EXECUTE ? "PAGE_EXECUTE " : "",
            Protection & PAGE_EXECUTE_READ ? "PAGE_EXECUTE_READ " : "",
            Protection & PAGE_EXECUTE_READWRITE ? "PAGE_EXECUTE_READWRITE " : "",
            Protection & PAGE_EXECUTE_WRITECOPY ? "PAGE_EXECUTE_WRITECOPY " : "",
            Protection & PAGE_GUARD ? "PAGE_GUARD " : "",
            Protection & PAGE_NOCACHE ? "PAGE_NOCACHE " : "",
            Protection & PAGE_WRITECOMBINE ? "PAGE_WRITECOMBINE " : "",
            XboxMemory.IsValidHeap(StartingVa) ? "(Heap)" : "");
    }

    fprintf(stdout, "\n\n");
}

int __cdecl main(int argc, char* argv[])
{
	int i;
	ULONG size;
	HRESULT hr = S_OK;
	PCSTR pszXboxName, arg;
	bool PfnLongView = false;
	bool PfnWideView = false;
    bool SummaryView = true;
    bool VadView = false;
	CHAR Buffer[260];
	ULONG ColumnWidth = 0;

	//
	// Process and validate command line
	//

    pszXboxName = getenv("XBOXIP");

    if (pszXboxName) {
        XboxMemory.SetXboxNameNoRegister(pszXboxName);
        pszXboxName = NULL;
    }

    for (i=1; i<argc; i++) {
        arg = argv[i];
        if (*arg == '/' || *arg == '-') {
            arg++;
            if (*arg == 'x' || *arg == 'X') {
                pszXboxName = (++i < argc ? argv[i] : NULL);
			} else if (*arg == 'n' || *arg == 'N') {
				ColumnWidth = (++i < argc ? atoi(argv[i]) : 0);
            } else if (*arg == 'l' || *arg == 'L') {
                PfnLongView = *(arg+1) == '-' ? false : true;
            } else if (*arg == 'w' || *arg == 'W') {
                PfnWideView = *(arg+1) == '-' ? false : true;
            } else if (*arg == 's' || *arg == 'S') {
                SummaryView  = false;
            } else if (_stricmp(arg, "vad") == 0) {
                VadView = true;
            } else {
				usage();
			}
        } else {
            usage();
        }
    }

	if (!SummaryView && !PfnLongView && !PfnWideView) {
		usage();
	}

	if (ColumnWidth == 0 || ColumnWidth > 256) {
		ColumnWidth = 64;
	}

	//
	// Set and register new Xbox machine name if needed
	//

    if (pszXboxName) {
        hr = XboxMemory.SetXboxName(pszXboxName);
    }

	//
	// Download PFN database and all memory manager global
	//

	if (SUCCEEDED(hr)) {
		size = sizeof(Buffer);
		hr = XboxMemory.GetXboxName(Buffer, &size);
	}

	fprintf(stderr, "Downloading information from '%s'\n\n", Buffer);

    if (SUCCEEDED(hr) && SummaryView) {
        hr = XboxMemory.DownloadMmGlobal();
    }

	if (SUCCEEDED(hr) && (PfnLongView || PfnWideView)) {
		hr = XboxMemory.DownloadPfnDatabase();
	}

    if (SUCCEEDED(hr) && VadView) {
        hr = XboxMemory.DownloadVad();
    }

	//
	// Display the memory map and other information
	//

	if (SUCCEEDED(hr)) {

        if (SummaryView) {
            DumpMemoryUsageSummary();
        }

		if (PfnWideView) {
			DumpPfnMapInWideView(ColumnWidth);
		}

		if (PfnLongView) {
			DumpPfnMapInLongView();
		}

        if (VadView) {
            DumpVadList();
        }
	}

	//
	// Display error message if there is an error
	//

	if (FAILED(hr)) {
		XboxMemory.TranslateError(hr, Buffer, sizeof(Buffer));
		fprintf(stderr, "%s\n", Buffer);
		return 1;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\ptrmap.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ptrmap.h

Abstract:

    This module implements class to supports maps of void pointers keyed by
    void pointers.

--*/

#if !defined(_PTRMAP_INCLUDED)
#define _PTRMAP_INCLUDED

struct __POSITION { };
typedef __POSITION* POSITION;

#define BEFORE_START_POSITION ((POSITION)-1L)

struct CPlex {      // warning variable length structure
    CPlex* pNext;
    void* data() { return this+1; }

    static CPlex* PASCAL Create(CPlex*& pHead, UINT nMax, UINT cbElement) {
        _ASSERTE(nMax > 0 && cbElement > 0);
        CPlex* p = (CPlex*)new BYTE[sizeof(CPlex) + nMax * cbElement];
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain() {
        CPlex* p = this;
        while (p) {
            BYTE* bytes = (BYTE*)p;
            CPlex* pNext = p->pNext;
            delete[] bytes;
            p = pNext;
        }
    }
};

class CMapPtrToPtr {
protected:
    struct CAssoc {
        CAssoc* pNext;
        void* key;
        void* value;
    };

public:
    CMapPtrToPtr(int nBlockSize = 10);
    virtual ~CMapPtrToPtr();

    int GetCount() const { return m_nCount; }
    bool IsEmpty() const { return m_nCount == 0; }

    bool Lookup(void* key, void*& rValue) const;

    void*& operator[](void* key);

    void SetAt(void* key, void* newValue) { (*this)[key] = newValue; }
    void* GetValueAt(void* key) const;

    bool RemoveKey(void* key);
    void RemoveAll();

    POSITION GetStartPosition() const { return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
    void GetNextAssoc(POSITION& rNextPosition, void*& rKey, void*& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const { return m_nHashTableSize; }
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

    // Routine used to user-provided hash keys
    UINT HashKey(void* key) const { return ((UINT)(void*)(DWORD)key) >> 4; }

protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(void*, UINT&) const;
};

#endif // !defined(_PTRMAP_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\capdata.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    capdata.h

Abstract:

    This module implements routines to dump call-attributed profile (CAP)
    data for Xbox.

--*/

#if !defined(_CAPDATA_INCLUDED)
#define _CAPDATA_INCLUDED

#include "ptrmap.h"

#define THREAD_ACTIVE   1
#define THREAD_INACTIVE 0
#define THREAD_STOP     (-1)

struct CallDataEntry {
    ULONGLONG starttime;
    ULONGLONG duration;
    ULONGLONG callouttime;
    BYTE type;
    BYTE flags;
    WORD level;
    union {
        struct {            // for ENTRYTYPE_FUNCCALL
            DWORD caller;
            DWORD callee;
            DWORD calltype;
            DWORD callin;
            DWORD callout;
        };
        DWORD param;        // for ENTRYTYPE_COMMENT
        DWORD newtid;       // for ENTRYTYPE_THREADSWITCH
        DWORD filler[5];
    };
};

enum {
    ENTRYTYPE_FUNCCALL,
    ENTRYTYPE_COMMENT,
    ENTRYTYPE_THREADSWITCH,

    ENTRYFLAG_NOEND = 0x01,
    ENTRYFLAG_ORPHAN = 0x02,
    ENTRYFLAG_DPC = 0x04,
};

class CThreadProfileData {
private:
    // need this to prevent the compiler from using default copy ctor
    CThreadProfileData(const CThreadProfileData&);
    CThreadProfileData& operator=(const CThreadProfileData& rhs);

public:
    CThreadProfileData(DWORD tid, ULONGLONG tick, bool dpcflag = false);
    virtual ~CThreadProfileData();

    void CallBegin(ULONGLONG tick, ULONG_PTR caller, ULONG_PTR callee, DWORD calltype);
    void CallEnd(ULONGLONG tick, ULONG_PTR caller, DWORD calltype);
    void Comment(ULONGLONG tick, DWORD param);
    void Activate(ULONGLONG tick, INT action, DWORD newid = 0);
    void PostProcessing(ULONGLONG firsttick, ULONGLONG lasttick);

    const CallDataEntry* GetCallDataEntry(size_t position) const;

    bool IsDpcThread() const { return m_isdpc; }
    UINT CallLevel() const { return m_calllevel; }
    UINT TotalCalls() const { return m_totalcalls; }
    DWORD ThreadId() const { return m_threadid; }
    ULONGLONG ThreadTime() const { return m_inactivetime - m_starttime - m_timeadjust; }

    CThreadProfileData* NextThread() const { return m_nextthread; }
    void SetPreviousThread(CThreadProfileData* prevthread) { m_prevthread = prevthread; }
    void SetNextThread(CThreadProfileData* nextthread) { m_nextthread = nextthread; }

private:

    struct FunctionCall {
        DWORD caller;
        DWORD callee;
        size_t entryindex;
        DWORD calltype;
        ULONGLONG timeadjust;
    };

    enum {
        MAX_CALL_LEVELS = 1024,
        MAX_MEM_RESERVED = 32 * 1024UL * 1024UL,
        PER_CALL_OVERHEAD = 59  // This number is obtained by timing
    };

    bool m_isdpc;
    UINT m_calllevel;
    DWORD m_threadid;
    CThreadProfileData* m_nextthread;
    CThreadProfileData* m_prevthread;
    FunctionCall m_callstack[MAX_CALL_LEVELS];

    ULONGLONG m_starttime;
    ULONGLONG m_lastactivetime;
    ULONGLONG m_inactivetime;
    ULONGLONG m_timeadjust;

    CallDataEntry* m_inactiveentry;

    size_t m_usedentries, m_totalentries;
    CallDataEntry* m_dataentry;
    CallDataEntry* CreateNewEntry(size_t* index = 0);
    bool GrowDataEntryBy(size_t elements);

    UINT m_totalcalls;
    UINT m_percalloverhead;

    bool IsActive() { return m_inactiveentry == NULL; }
    bool InsideCall() { return m_calllevel != 0; }
    bool NestedCall() { return m_calllevel > 1; }
    FunctionCall* LastCall() { return &m_callstack[m_calllevel-1]; }

    void AdjustCallOverhead(ULONGLONG tick);
};

class CFunctionTable {
public:
    CFunctionTable();
    virtual ~CFunctionTable();

    bool add(const CallDataEntry* entry);
    int getcount() const { return m_functions.GetCount(); }
    const CallDataEntry* getentry(int index) const;

    // simple sorting interface: must be zero-based index
    typedef enum {
        sortby_address = 0,
        sortby_callin,
        sortby_callout,
        sortby_incltime,
        sortby_excltime,
        sortby_name,
        sortby_unknown
    } sortkey;

    bool sort(sortkey key);

protected:
    bool grow(int elements);
    int gettablesize() const { return m_tablesize; }
    bool lookup(ULONG_PTR address, CallDataEntry*& entry) const;

private:
    int m_tablesize;
    CallDataEntry** m_dataentry;    // array of call data entry for fast sorting
    CMapPtrToPtr m_functions;       // simple hash for fast searching

    // sorting functions
    static int __cdecl _sortby_address(const CallDataEntry** e1, const CallDataEntry** e2);
    static int __cdecl _sortby_callin(const CallDataEntry** e1, const CallDataEntry** e2);
    static int __cdecl _sortby_callout(const CallDataEntry** e1, const CallDataEntry** e2);
    static int __cdecl _sortby_incltime(const CallDataEntry** e1, const CallDataEntry** e2);
    static int __cdecl _sortby_excltime(const CallDataEntry** e1, const CallDataEntry** e2);
    static int __cdecl _sortby_name(const CallDataEntry** e1, const CallDataEntry** e2);
    static int (__cdecl *_sort_ftable[])(const CallDataEntry**, const CallDataEntry**);
};

#endif // !defined(_CAPDATA_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\ptrmap.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ptrmap.cpp

Abstract:

    This module implements class to supports maps of void pointers keyed by
    void pointers (copied from MFC).

--*/

#include "stdafx.h"

CMapPtrToPtr::CMapPtrToPtr(int nBlockSize)
{
    _ASSERTE(nBlockSize > 0);

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

CMapPtrToPtr::~CMapPtrToPtr()
{
    RemoveAll();
    _ASSERTE(m_nCount == 0);
}

void CMapPtrToPtr::RemoveAll()
{
    if (m_pHashTable != NULL) {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

bool CMapPtrToPtr::Lookup(void* key, void*& rValue) const
{
    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL) {
        return false;  // not in map
    }

    rValue = pAssoc->value;
    return true;
}

void*& CMapPtrToPtr::operator[](void* key)
{
    UINT nHash;
    CAssoc* pAssoc;

    if ((pAssoc = GetAssocAt(key, nHash)) == NULL) {

        if (m_pHashTable == NULL) {
            InitHashTable(m_nHashTableSize);
        }

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();

        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }

    return pAssoc->value;  // return new reference
}

void* CMapPtrToPtr::GetValueAt(void* key) const
{
    if (m_pHashTable == NULL) {
        return NULL;
    }

    UINT nHash = HashKey(key) % m_nHashTableSize;

    CAssoc* pAssoc;

    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext) {
        if (pAssoc->key == key) {
            return pAssoc->value;
        }
    }

    return NULL;
}

bool CMapPtrToPtr::RemoveKey(void* key)
{
    if (m_pHashTable == NULL) {
        return false;  // nothing in the table
    }

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext) {
        if (pAssoc->key == key) {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return true;
        }
        ppAssocPrev = &pAssoc->pNext;
    }

    return false;  // not found
}

void CMapPtrToPtr::GetNextAssoc(POSITION& rNextPosition,
    void*& rKey, void*& rValue) const
{
    _ASSERTE(m_pHashTable != NULL);  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERTE(pAssocRet != NULL);

    if (pAssocRet == (CAssoc*)BEFORE_START_POSITION) {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERTE(pAssocRet != NULL);  // must find something
    }

    // find next association
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL) {
        // go to next bucket

        for (UINT nBucket = (HashKey(pAssocRet->key) % m_nHashTableSize) + 1;

          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (POSITION) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

void CMapPtrToPtr::InitHashTable(UINT nHashSize, BOOL bAllocNow)
{
    _ASSERTE(m_nCount == 0);
    _ASSERTE(nHashSize > 0);

    if (m_pHashTable != NULL) {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow) {
        m_pHashTable = new CAssoc* [nHashSize];
        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }

    m_nHashTableSize = nHashSize;
}

CMapPtrToPtr::CAssoc* CMapPtrToPtr::GetAssocAt(void* key, UINT& nHash) const
{
    nHash = HashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext) {
        if (pAssoc->key == key)
            return pAssoc;
    }

    return NULL;
}

CMapPtrToPtr::CAssoc* CMapPtrToPtr::NewAssoc()
{
    if (m_pFreeList == NULL) {
        // add another block
        CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMapPtrToPtr::CAssoc));
        // chain them into free list
        CMapPtrToPtr::CAssoc* pAssoc = (CMapPtrToPtr::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }

    _ASSERTE(m_pFreeList != NULL);  // we must have something

    CMapPtrToPtr::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERTE(m_nCount > 0);  // make sure we don't overflow

    pAssoc->key = 0;
    pAssoc->value = 0;

    return pAssoc;
}

void CMapPtrToPtr::FreeAssoc(CMapPtrToPtr::CAssoc* pAssoc)
{
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERTE(m_nCount >= 0);  // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0) {
        RemoveAll();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\StdAfx.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    stdafx.cpp

Abstract:

    This is the source file that includes just the standard includes
    xbperf.pch will be the pre-compiled header stdafx.obj will contain
    the pre-compiled type information.

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\StdAfx.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    stdafx.h

Abstract:

    This is a pre-compiled header module.

--*/

#if !defined(AFX_STDAFX_H__7A5FDEFE_A50D_49AD_8B8A_0833ACCC7FAB__INCLUDED_)
#define AFX_STDAFX_H__7A5FDEFE_A50D_49AD_8B8A_0833ACCC7FAB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <crtdbg.h>
#include <windows.h>

typedef long NTSTATUS;

#include <xprofp.h>
#include <xboxdbg.h>
#include <dbghelp.h>

#include "ptrmap.h"
#include "symbol.h"
#include "capdata.h"

// error functions
VOID errmsg(CHAR* format, ...);
VOID checkerr(BOOL err, CHAR* format, ...);

extern bool verbose;
extern bool noidle;
extern CHAR* symbolpath;

// dump a binary profile data file to human-readable text format
void capdump(CHAR* cap_filename, CHAR* dump_filename);

// spew error debug message if verbose mode is enabled
#define VERBOSE !verbose ? (void)0 : errmsg

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7A5FDEFE_A50D_49AD_8B8A_0833ACCC7FAB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\symbol.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    symbol.h

Abstract:

    This module contains routines to look up debug symbols.

--*/

#if !defined(AFX_SYMBOL_H__C08868ED_292D_49F8_9C84_1EAC03C9C1C9__INCLUDED_)
#define AFX_SYMBOL_H__C08868ED_292D_49F8_9C84_1EAC03C9C1C9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// a simple hash table for maintaining recently used symbol information
struct SymEntry {
    SymEntry* next;
    UINT module;
    ULONG address;
    CHAR name[1];
};

struct SymbolFile {
    DWORD loadaddr;
    DWORD size;
    DWORD baseaddr;
    CHAR name[XPROF_MAX_MODULE_NAMELEN];
    CHAR symname[MAX_PATH+16];
};

class CSymbolTable {
public:
    SymEntry* Lookup(ULONG address, bool bDisplacement = false);
    CSymbolTable();
    virtual ~CSymbolTable();

private:

    // maximum symbol table size (should be a prime number)
    enum { SYMTABLE_SIZE = 4091 };

    SymEntry* entries[SYMTABLE_SIZE];
};

VOID loadsymfiles();
VOID unloadsymfiles();

extern CSymbolTable* symtable;
extern char* symbolpath;
extern UINT symcnt;
extern struct SymbolFile symfiles[XPROF_MAX_MODULES];

inline CHAR* lookupsymname(DWORD addr, bool bDisplacement = false)
{
    SymEntry* symentry = symtable->Lookup(addr);
    return symentry->name;
}

#endif // !defined(AFX_SYMBOL_H__C08868ED_292D_49F8_9C84_1EAC03C9C1C9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\capdata.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    capdata.cpp

Abstract:

    This module implements routines to dump call-attributed profile (CAP)
    data for Xbox.

--*/

#include "stdafx.h"

CThreadProfileData::CThreadProfileData(DWORD tid, ULONGLONG tick, bool dpcflag) :
    m_nextthread(0), m_threadid(tid), m_prevthread(0),
    m_starttime(tick), m_lastactivetime(tick), m_inactivetime(0), m_timeadjust(0),
    m_totalcalls(0), m_calllevel(0),
    m_dataentry(0), m_usedentries(0), m_totalentries(0), m_inactiveentry(0),
    m_percalloverhead(PER_CALL_OVERHEAD), m_isdpc(dpcflag)
{
    memset(m_callstack, 0, sizeof(m_callstack));
}

CThreadProfileData::~CThreadProfileData()
{
    if (m_dataentry) {
        VirtualFree(m_dataentry, 0, MEM_RELEASE);
    }
}

CallDataEntry* CThreadProfileData::CreateNewEntry(size_t* index)
{
    // commit more memory for call data entry as needed
    if (m_usedentries == m_totalentries && !GrowDataEntryBy(8192)) {
        checkerr(true, "Too much profile data.\n");
        return NULL;
    }

    if (index) {
        *index = m_usedentries;
    }

    return &m_dataentry[m_usedentries++];
}

bool CThreadProfileData::GrowDataEntryBy(size_t elements)
{
    CallDataEntry* entry = NULL;
    size_t newsize = (elements + m_totalentries) * sizeof(CallDataEntry);

    // REVIEW: reserve 32MB (hard-coded) virtual address space for each thread
    if (!m_dataentry) {
        m_dataentry = (CallDataEntry*)VirtualAlloc(0, MAX_MEM_RESERVED, MEM_RESERVE, PAGE_NOACCESS);
    }

    // commit memory as needed
    if (newsize <= MAX_MEM_RESERVED) {
        entry = (CallDataEntry*)VirtualAlloc(m_dataentry, newsize, MEM_COMMIT, PAGE_READWRITE);
        if (entry) {
            m_totalentries += elements;
        }
    }

    return entry != NULL;
}

void CThreadProfileData::AdjustCallOverhead(ULONGLONG tick)
{
    if (InsideCall()) {
        LastCall()->timeadjust += tick;
    } else {
        m_timeadjust += tick;
    }
}

void CThreadProfileData::CallBegin(ULONGLONG tick, ULONG_PTR caller, ULONG_PTR callee, DWORD calltype)
{
    checkerr(m_calllevel >= MAX_CALL_LEVELS, "Too many levels of nested calls.\n");

    size_t index;
    CallDataEntry* entry = CreateNewEntry(&index);

    entry->starttime = tick;
    entry->type = ENTRYTYPE_FUNCCALL;
    entry->flags = ENTRYFLAG_NOEND;
    entry->level = (WORD)m_calllevel;
    entry->callin = 1;

    if (caller == 0 && IsDpcThread()) {
        entry->flags |= ENTRYFLAG_DPC;
        caller = callee;
    } else if (InsideCall()) {
        if (calltype == XPROFREC_FASTCAP_START && caller != LastCall()->callee) {
            entry->flags |= ENTRYFLAG_ORPHAN;
        }
        m_dataentry[m_callstack[m_calllevel-1].entryindex].callout++;
    }

    entry->caller = caller;
    entry->callee = calltype == XPROFREC_FASTCAP_START ? callee : 0;
    entry->calltype = calltype;

    FunctionCall* call = &m_callstack[m_calllevel];
    call->caller = caller;
    call->callee = callee;
    call->calltype = calltype;
    call->entryindex = index;
    call->timeadjust = m_percalloverhead;

    m_calllevel++;
}

void CThreadProfileData::CallEnd(ULONGLONG tick, DWORD caller, DWORD calltype)
{
    if (!InsideCall()) {
        VERBOSE("Unmatched Call-End record: %s\n", lookupsymname(caller));
        return;
    }

    FunctionCall* call = LastCall();
    m_calllevel--;

    _ASSERTE(call->calltype == m_dataentry[call->entryindex].calltype);

    DWORD ExpectedCallType = call->calltype;
    DWORD Match;

    switch (call->calltype) {
    case XPROFREC_FASTCAP_START:
        ExpectedCallType = XPROFREC_FASTCAP_END;
        Match = call->caller;
        break;

    case XPROFREC_CALLCAP_START:
        ExpectedCallType = XPROFREC_CALLCAP_END;
        Match = call->caller;
        break;

    case XPROFREC_PENTER:
        ExpectedCallType = XPROFREC_PEXIT;
        Match = call->callee;
        break;

    default:
        ExpectedCallType = 0;
        Match = 0;
    }

    if (ExpectedCallType != calltype || Match != caller) {
        errmsg(
            "Call-End record doesn't match the last Call-Begin:\n"
            "    thread: 0x%02X\n"
            "    actual %s\n"
            "    expect %s %s\n",
            m_threadid,
            lookupsymname(caller),
            lookupsymname(call->caller),
            lookupsymname(call->callee));
        return;
    }

    // calculate inclusive time spend in this function call
    CallDataEntry* entry = &m_dataentry[call->entryindex];
    entry->duration = tick - entry->starttime - call->timeadjust;
    entry->flags &= ~ENTRYFLAG_NOEND;

    // calculate time spend outside previous function call
    //   note the m_calllevel-- above
    if (InsideCall()) {
        m_dataentry[LastCall()->entryindex].callouttime += entry->duration;
    }

    AdjustCallOverhead(call->timeadjust + m_percalloverhead);
}

void CThreadProfileData::Comment(ULONGLONG tick, DWORD param)
{
    CallDataEntry* entry = CreateNewEntry();

    entry->starttime = tick;
    entry->type = ENTRYTYPE_COMMENT;
    entry->level = (WORD)m_calllevel;
    entry->param = param;
}

void CThreadProfileData::Activate(ULONGLONG tick, INT action, DWORD newtid)
{
    if (action == THREAD_ACTIVE) {
        if (IsActive()) {
            VERBOSE("Thread is already active: 0x%02X!\n", m_threadid);
        } else {
            m_lastactivetime = tick;
            tick -= m_inactivetime;
            m_inactiveentry->duration = tick;
            m_inactiveentry = NULL;
            AdjustCallOverhead(tick);
        }
    } else {
        if (IsActive()) {
            m_inactivetime = tick;

            if (action == THREAD_INACTIVE) {
                CallDataEntry* entry = CreateNewEntry();
                entry->starttime = tick;
                entry->level = 0;
                entry->newtid = newtid;
                entry->type = ENTRYTYPE_THREADSWITCH;
                m_inactiveentry = entry;

                if (noidle && m_threadid == 0 && m_prevthread) {
                    // note: we're attributing the time spent in idle thread
                    // to the last thread that was running.
                    m_prevthread->AdjustCallOverhead(m_lastactivetime-m_inactivetime);
                }
            }
        } else {
            VERBOSE("Thread is already inactive: 0x%02X!\n", m_threadid);
        }
    }
}

void CThreadProfileData::PostProcessing(ULONGLONG firsttick, ULONGLONG lasttick)
{
    // if this thread is still active, deactivate it
    if (IsActive()) {
        Activate(lasttick, THREAD_STOP, 0);
    }

    if (m_calllevel) {
        VERBOSE("CALL-BEGIN record without matching CALL-END: 0x%02X\n", m_threadid);
        while (m_calllevel) {
            FunctionCall* call = &m_callstack[--m_calllevel];
            VERBOSE("  %s - %s\n",
                lookupsymname(call->caller),
                lookupsymname(call->callee));

            // for incomplete call, forget about overhead adjustment
            call->timeadjust -= m_percalloverhead;

            CallDataEntry* entry = &m_dataentry[call->entryindex];
            entry->duration = m_inactivetime - entry->starttime - call->timeadjust;
            AdjustCallOverhead(call->timeadjust);
        }
    }

    // count the total number of function calls
    ULONGLONG totalcalltime = 0;
    CallDataEntry* entry = m_dataentry;

    for (size_t i=0; i<m_usedentries; i++, entry++) {
        if (entry->type == ENTRYTYPE_FUNCCALL) {
            if (entry->level == 0) totalcalltime += entry->duration;
            m_totalcalls++;
        }
        entry->starttime -= firsttick;
    }

    if (IsDpcThread()) {
        m_timeadjust = m_inactivetime - m_starttime - totalcalltime;
    }
}

const CallDataEntry* CThreadProfileData::GetCallDataEntry(size_t position) const
{
    if (position >= m_usedentries) {
        return NULL;
    }

    return &m_dataentry[position];
}

CFunctionTable::CFunctionTable() :
    m_dataentry(0), m_tablesize(0)
{
}

CFunctionTable::~CFunctionTable()
{
    CallDataEntry* entry;
    ULONG_PTR address;
    POSITION position = m_functions.GetStartPosition();

    while (position) {
        m_functions.GetNextAssoc(position, (void*&)address, (void*&)entry);
        delete entry;
    }

    if (m_dataentry) {
        LocalFree(m_dataentry);
    }
}

bool CFunctionTable::lookup(ULONG_PTR address, CallDataEntry*& entry) const
{
    return m_functions.Lookup((void*)address, (void*&)entry);
}

bool CFunctionTable::grow(int elements)
{
    CallDataEntry** entry;
    size_t newsize = (m_tablesize + elements) * sizeof(CallDataEntry*);

    if (m_dataentry) {
        entry = (CallDataEntry**)LocalReAlloc(m_dataentry, newsize, LPTR);
    } else {
        entry = (CallDataEntry**)LocalAlloc(LPTR, newsize);
    }

    if (entry) {
        m_dataentry = entry;
        m_tablesize += elements;
    }

    return entry != NULL;
}

bool CFunctionTable::add(const CallDataEntry* entry)
{
    CallDataEntry* e;
    ULONG_PTR address = entry->callee ? entry->callee : entry->caller;

    // update call entry data if the function already exists
    if (lookup(address, e)) {

        if (e->starttime > entry->starttime) {
            e->starttime = entry->starttime;
        }

        e->duration += entry->duration;
        e->callouttime += entry->callouttime;
        e->callin += entry->callin;
        e->callout += entry->callout;
        return true;
    }

    // create new call entry data and add to the function table
    e = new CallDataEntry;

    if (!e) {
        return false;
    }

    if (getcount() == m_tablesize && !grow(4096)) {
        delete e;
        e = NULL;
    } else {
        m_dataentry[getcount()] = e;
        CopyMemory(e, entry, sizeof(*entry));
        m_functions.SetAt((void*)address, e);
    }

    return e != NULL;
}

const CallDataEntry* CFunctionTable::getentry(int index) const
{
    if (index >= getcount()) {
        return NULL;
    }

    return m_dataentry[index];
}

int __cdecl CFunctionTable::_sortby_address(const CallDataEntry** e1, const CallDataEntry** e2)
{
    int c1 = (int)((*e1)->callee ? (*e1)->callee : (*e1)->caller);
    int c2 = (int)((*e2)->callee ? (*e2)->callee : (*e2)->caller);
    return c1 - c2;
}

int __cdecl CFunctionTable::_sortby_callin(const CallDataEntry** e1, const CallDataEntry** e2)
{
    return (int)(*e1)->callin - (int)(*e2)->callin;
}

int __cdecl CFunctionTable::_sortby_callout(const CallDataEntry** e1, const CallDataEntry** e2)
{
    return (int)(*e1)->callout - (int)(*e2)->callout;
}

int __cdecl CFunctionTable::_sortby_excltime(const CallDataEntry** e1, const CallDataEntry** e2)
{
    int et1 = (int)((*e1)->duration - (*e1)->callouttime);
    int et2 = (int)((*e2)->duration - (*e2)->callouttime);
    return et1 - et2;
}

int __cdecl CFunctionTable::_sortby_incltime(const CallDataEntry** e1, const CallDataEntry** e2)
{
    return (int)(*e1)->duration - (int)(*e2)->duration;
}

int __cdecl CFunctionTable::_sortby_name(const CallDataEntry** e1, const CallDataEntry** e2)
{
    ULONG_PTR c1 = (*e1)->callee ? (*e1)->callee : (*e1)->caller;
    ULONG_PTR c2 = (*e2)->callee ? (*e2)->callee : (*e2)->caller;
    return strcmp(lookupsymname(c1), lookupsymname(c2));
}

int (__cdecl *CFunctionTable::_sort_ftable[])(const CallDataEntry**, const CallDataEntry**) = {
    _sortby_address, _sortby_callin, _sortby_callout,
    _sortby_incltime, _sortby_excltime, _sortby_name
};

bool CFunctionTable::sort(sortkey key)
{
    if (getcount() == 0 || key >= sortby_unknown) {
        return false;
    }

    qsort(m_dataentry, getcount(), sizeof(CallDataEntry*),
          (int (__cdecl *)(const void*, const void*))_sort_ftable[key]);
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\symbol.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    symbol.cpp

Abstract:

    This module contains routines to look up debug symbols.

--*/

#include "stdafx.h"

UINT symcnt;
CSymbolTable* symtable;
char* symbolpath;
struct SymbolFile symfiles[XPROF_MAX_MODULES];

CSymbolTable::CSymbolTable()
{
    for (UINT i=0; i<SYMTABLE_SIZE; i++) {
        entries[i] = NULL;
    }
}

CSymbolTable::~CSymbolTable()
{
    for (UINT i=0; i<SYMTABLE_SIZE; i++) {
        SymEntry* symentry = entries[i];
        while (symentry) {
            VOID* p = symentry;
            symentry = symentry->next;
            free(p);
        }
    }
}

SymEntry* CSymbolTable::Lookup(ULONG address, bool bDisplacement)
{
    // simple function to map from an address to a hash bucket
    DWORD hash = address % SYMTABLE_SIZE;
    SymEntry* symentry = entries[hash];

    // return the symbol entry if the address is already in the symbol table
    while (symentry) {
        if (symentry->address == address) {
            return symentry;
        }
        symentry = symentry->next;
    }

    // look up the address in the symbol files and map it to a symbol name
    struct {
        IMAGEHLP_SYMBOL s;
        CHAR extrabuf[MAX_PATH+16];
    } syminfo;

    syminfo.s.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    syminfo.s.MaxNameLength = MAX_PATH;

    DWORD disp = 0;
    BOOL ok = SymGetSymFromAddr(GetCurrentProcess(), address, &disp, &syminfo.s);

    CHAR* name = syminfo.s.Name;

    if (ok) {
        if (disp && bDisplacement) {
            sprintf(name + strlen(name), "+0x%X", disp);
        }
    } else {
        sprintf(name, "0x%X", address);
    }

    // add the new address-to-symbol mapping to symbol table
    UINT n = strlen(name) + 1;
    symentry = (SymEntry*)malloc(offsetof(SymEntry, name) + n);

    if (!symentry) {
        return NULL;
    }

    symentry->next = entries[hash];
    entries[hash] = symentry;

    symentry->address = address;
    memcpy(symentry->name, name, n);

    // figure out which module the symbol belongs to
    symentry->module = 0;

    for (n=0; n<symcnt; n++) {
        if (address >= symfiles[n].baseaddr &&
            address < symfiles[n].baseaddr + symfiles[n].size) {
            symentry->module = n;
            break;
        }
    }

    if (n == symcnt) {
        VERBOSE("Address not in range of any module: %x\n", address);
    }

    return symentry;
}

void loadsymfiles()
{
    BOOL ok = SymInitialize(GetCurrentProcess(), symbolpath, FALSE);
    checkerr(!ok, "Failed to initialize DBGHELP.DLL\n");

    SymSetOptions(SYMOPT_UNDNAME);
    SymbolFile* symfile = symfiles;

    for (UINT i=0; i<symcnt; i++, symfile++) {
        symfile->baseaddr = SymLoadModule(GetCurrentProcess(), NULL,
            symfile->name, NULL, symfile->loadaddr, symfile->size);

        if (symfile->baseaddr == 0) {
            VERBOSE("Warning: can't load symbols for image file %s (error code %d)\n", symfile->name, GetLastError());
            continue;
        }

        if (symfile->loadaddr != symfile->baseaddr) {
            VERBOSE("loadaddr %x != baseaddr %x?\n", symfile->loadaddr, symfile->baseaddr);
        }

        IMAGEHLP_MODULE modinfo;
        modinfo.SizeOfStruct = sizeof(modinfo);

        if (SymGetModuleInfo(GetCurrentProcess(), symfile->baseaddr, &modinfo)) {
            sprintf(symfile->symname, "%s", modinfo.LoadedImageName);
        }
    }
}

void unloadsymfiles()
{
    for (UINT i=0; i < symcnt; i++) {
        if (symfiles[i].baseaddr) {
            SymUnloadModule(GetCurrentProcess(), symfiles[i].baseaddr);
        }
    }
    SymCleanup(GetCurrentProcess());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbsfu\StdAfx.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    stdafx.cpp

Abstract:

    This is the source file that includes just the standard includes
    xbperf.pch will be the pre-compiled header stdafx.obj will contain
    the pre-compiled type information.

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbren\resource.h ===
#define IDS_NOTEMPFILE 1000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbreboot\xbreboot.cpp ===
/*
**
** xbreboot
**
** Reboot the remote Xbox machine
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "xbfile.hxx"
#include "optn.hxx"
#include <xboxverp.h>

DWORD g_dwFlags = DMBOOT_WARM;
HANDLE hevtReboot;
DWORD g_dwState = DMN_EXEC_START;

DWORD Reboot(DWORD dw, DWORD dwParam)
{
	if(dwParam == DMN_EXEC_PENDING && g_dwState == DMN_EXEC_REBOOT)
		/* We're ready to roll */
		SetEvent(hevtReboot);
	g_dwState = dwParam;
	return 0;
}

void SetupWait(PDMN_SESSION *ppsess)
{
    HRESULT hr;

	hevtReboot = CreateEvent(NULL, TRUE, FALSE, 0);
	if(!hevtReboot)
		Fatal(E_UNEXPECTED, 0);
	hr = DmOpenNotificationSession(DM_PERSISTENT, ppsess);
	if(FAILED(hr))
		Fatal(hr, 0);
	hr = DmNotify(*ppsess, DM_EXEC, Reboot);
	if(FAILED(hr))
		Fatal(hr, 0);
}

BOOL OPTH::FParseOption(char *&sz, char)
{
	switch(*sz) {
	case 'w':
	case 'W':
		g_dwFlags |= DMBOOT_WAIT;
		break;
	case 'c':
	case 'C':
		g_dwFlags &= ~DMBOOT_WARM;
		break;
    case 'p':
    case 'P':
        g_dwFlags |= DMBOOT_NODEBUG;
        break;
    case 's':
    case 'S':
        g_dwFlags |= DMBOOT_STOP;
        break;
	default:
		return FALSE;
	}
	return TRUE;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbreboot version " VER_PRODUCTVERSION_STR "\n\n"
        "Reboot the Xbox target system and optionally launch an Xbox title\n");
	fprintf(stderr, "\nusage: %s [/x xboxname] [options] [xbe]\n", m_szExe);
	fprintf(stderr,
		"\t-w\twait for debugger connection after reboot\n"
		"\t-c\tcold reboot (slow)\n"
        "\t-p\tprevent debugging after reboot\n"
		"Specify Xbox files as xE:\\..., xD:\\..., etc.\n");
	exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
	char *szExe = *rgszArg;
	DWORD dwFlags = DMBOOT_WARM;
	HRESULT hr;
	PDMN_SESSION psess;
	char szName[1024];
    char szArgs[2048];
    FIL fil;

	/* Cut down on repeated connection requests */
	DmUseSharedConnection(TRUE);

	/* Process arguments */
	OPTH opth(cArg, rgszArg);

	if(cArg > 0) {
		/* We're going to need to run an image, so set up for the
		 * notification */
        fil = *rgszArg;
        if(!fil.m_fXbox) {
            fprintf(stderr, "error: can only reboot to files on Xbox\n");
            exit(1);
        }
        if(g_dwFlags & DMBOOT_NODEBUG) {
            if(cArg > 1) {
                /* Can't use -p and pass arguments */
                fprintf(stderr, "error: can't use -p and pass arguments\n");
                exit(1);
            }
            /* Use the secret recipe */
            fil.FillFullName(szName);
            sprintf(szArgs, "magicboot title=\"%s\"", szName);
            hr = DmSendCommand(NULL, szArgs, NULL, NULL);
            if(FAILED(hr))
                fil.Fatal(hr, 0);
            exit(0);
        }
		g_dwFlags |= DMBOOT_WAIT;
        SetupWait(&psess);
    } else if(g_dwFlags & DMBOOT_STOP)
        SetupWait(&psess);

    if(g_dwState == DMN_EXEC_PENDING && (dwFlags & DMBOOT_WARM))
        /* We're already sitting there waiting to run a title, so we won't
         * bother actually doing the reboot */
        hr = XBDM_NOERR;
    else
    	hr = DmReboot(g_dwFlags);

	if (FAILED(hr))
	{
		Fatal(hr, 0);
	}
	if(hevtReboot) {
		if(WaitForSingleObject(hevtReboot, g_dwFlags & DMBOOT_WARM ? 30000 :
				120000) == WAIT_TIMEOUT)
			Fatal(XBDM_CONNECTIONLOST, 0);
		else if(cArg > 0) {
			char szDir[1024];
            char *pchArg = NULL;
			strcpy(szName, fil.m_szName);
			fil.m_szName[0] = 0;
			fil.FillFullName(szDir);
            fil.m_szName[0] = szName[0];
            while(++rgszArg, --cArg) {
                if(pchArg)
                    sprintf(pchArg, " %s", *rgszArg);
                else
                    strcpy(pchArg = szArgs, *rgszArg);
                while(*pchArg)
                    ++pchArg;
            }
            hr = DmSetTitle(szDir, szName, pchArg ? szArgs : NULL);
			DmGo();
			if(FAILED(hr))
				fil.Fatal(hr, 0);
		}
		DmCloseNotificationSession(psess);
	}

	DmUseSharedConnection(FALSE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbperf\xbperf.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    xbperf.cpp

Abstract:

    This module implements routines to dump call-attributed profile (CAP)
    data for Xbox.

--*/

#include "stdafx.h"
#include "xboxverp.h"

#define optequ(s1, s2) (_stricmp(s1, s2) == 0)
#define XBOX_CAP_FILENAME "e:\\xboxcap.dat"

#define CALL_TYPE(type) (entry->calltype == XPROFREC_FASTCAP_START ? 'F' : \
    (entry->calltype == XPROFREC_CALLCAP_START ? 'C' : 'P'))

enum {
    INVALIDCMD = 0x0000,
    STARTCMD   = 0x0001,
    STOPCMD    = 0x0002,
    DUMPCMD    = 0x0004
};

// sort key table: must be sorted
struct _sortkeytable {
    const char* key;
    CFunctionTable::sortkey sortkey;
};

const _sortkeytable sortkeytable[] = {
    "address", CFunctionTable::sortby_address,
    "callin", CFunctionTable::sortby_callin,
    "callout", CFunctionTable::sortby_callout,
    "excltime", CFunctionTable::sortby_excltime,
    "incltime", CFunctionTable::sortby_incltime,
    "name", CFunctionTable::sortby_name,
};

PCHAR ProgramName;

bool verbose, dumpdpc, noidle;
bool rawdump = true;
CFunctionTable::sortkey sortby = CFunctionTable::sortby_unknown;

bool summaryonly, csvformat;
CFunctionTable functable;

ULONGLONG capstarttick, capstoptick;

void checkerr(BOOL err, CHAR* format, ...)
{
    if (!err) return;
    va_list arglist;

    va_start(arglist, format);
    vfprintf(stderr, format, arglist);
    va_end(arglist);

    exit(-1);
}

void errmsg(CHAR* format, ...)
{
    va_list arglist;

    va_start(arglist, format);
    vfprintf(stderr, format, arglist);
    va_end(arglist);
}

void usage()
{
    fprintf(stderr,
        "Microsoft Xbox Call-Attributed Profiler Version " VER_PRODUCTVERSION_STR "\n"
        "Copyright (c) Microsoft Corporation.  All rights reserved.\n\n"
        "Usage:\t%s options ...\n\n"
        "\t-x xboxname\tSpecifies the target Xbox name.\n\n"
        "\t-s symbol-path\tSpecifies the symbol search path.  You can specify\n"
        "\t\t\tmultiple directories by separating them with a\n"
        "\t\t\tsemicolon.  If -s option isn't present, _NT_SYMBOL_PATH\n"
        "\t\t\tenvironment variable is used.\n\n"
        "\t-idle\t\tDo not dump the time spent in the idle thread.\n"
        "\t\t\tInstead, the time is attributed to the thread that was\n"
        "\t\t\trunning before the system switched to the idle thread.\n\n"
        "\t-summary\tDump only summary report.\n\n"
        "\t-sort column\tSort summary report by column.  Column can be one of\n"
        "\t\t\tthe following:\n\n"
        "\t\t\taddress, callin, callout, incltime, excltime or name\n\n"
        "\t-csv\t\tGenerate .csv format summary report for Microsoft Excel\n\n"
        "\tstart\t\tStart profile data collection on the Xbox.\n\n"
        "\tstop logfile\tStop profile data collection on the Xbox, and retrieve\n"
        "\t\t\tthe profile data and store it in the specified file.\n\n"
        "\tdump logfile [textfile]\n"
        "\t\t\tDump the profile data to a human-readable text file or\n"
        "\t\t\tstandard output if the textfile is not specified.\n",
        ProgramName);

    exit(1);
}

void* mapfile(CHAR* filename, DWORD* size)
{
    HANDLE file, filemap;
    VOID* fileview = NULL;

    file = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (file == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    *size = GetFileSize(file, NULL);
    if (*size == ~0UL) {
        CloseHandle(file);
        return NULL;
    }

    filemap = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL);

    if (filemap != NULL) {
        fileview = MapViewOfFile(filemap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(filemap);
    }

    CloseHandle(file);
    return fileview;
}

CThreadProfileData* capparse(VOID* fileview, DWORD filesize)
{
    checkerr(filesize < XPROF_FILE_HEADER_SIZE || (filesize & 3) != 0,
        "File size error: too small or not a multiple of 4\n");

    XProfpFileHeader* fileheader = (XProfpFileHeader*)fileview;

    if (fileheader->version != XPROF_FILE_VERSION) {
        errmsg("File version mismatch: %x != %x\n", fileheader->version,
               XPROF_FILE_VERSION);
    }

    symcnt = fileheader->module_count;

    for (UINT i=0; i < symcnt; i++) {
        symfiles[i].loadaddr = fileheader->modules[i].loadaddr;
        symfiles[i].size = fileheader->modules[i].size;
        strcpy(symfiles[i].name, fileheader->modules[i].name);
    }

    loadsymfiles();

    fileview = fileheader+1;
    filesize -= XPROF_FILE_HEADER_SIZE;

    UINT count = filesize >> 2;
    ULONG* buf = (ULONG*) fileview;
    CThreadProfileData* threads = NULL;
    CThreadProfileData* curthread = NULL;
    CThreadProfileData* dpcthread = NULL;
    ULONGLONG firsttick, lasttick;

    firsttick = lasttick = 0;

    while (count) {
        if (count < 2) goto badrec;

        ULONGLONG tick;
        ULARGE_INTEGER* uli = (ULARGE_INTEGER*) &tick;
        uli->HighPart = buf[0] & ~XPROFREC_TYPEMASK;
        uli->LowPart = buf[1];
        lasttick = tick;

        DWORD rectype = buf[0] & XPROFREC_TYPEMASK;
        DWORD recsize;

        checkerr(
            (rectype != XPROFREC_CONTROL || buf[2] != XPROF_START) &&
            (curthread == NULL),
            "The first record must be a START record.\n");

        switch (rectype) {
        case XPROFREC_FASTCAP_START:
        case XPROFREC_PENTER:
            recsize = 4;
            if (count < recsize) goto badrec;
            checkerr(buf[2] == 0 || buf[3] == 0, "Invalid function address 0.\n");
            curthread->CallBegin(tick, buf[2], buf[3], rectype);
            break;

        case XPROFREC_CALLCAP_START:
            recsize = 3;
            if (count < recsize) goto badrec;
            checkerr(buf[2] == 0, "Invalid function address 0.\n");
            curthread->CallBegin(tick, buf[2], 0, rectype);
            break;

        case XPROFREC_FASTCAP_END:
        case XPROFREC_CALLCAP_END:
            recsize = 3;
            if (count < recsize) goto badrec;
            curthread->CallEnd(tick, buf[2], rectype);
            break;

        case XPROFREC_PEXIT:
            recsize = 4;
            if (count < recsize) goto badrec;
            curthread->CallEnd(tick, buf[3], rectype);
            break;

        case XPROFREC_CONTROL:
            recsize = 4;
            if (count < recsize) goto badrec;

            switch (buf[2]) {
            case XPROF_START:
                // must be the first record of the profile data file
                if (curthread) {
                    VERBOSE("Second START record treated as STOP.\n");
                    recsize = count;
                } else {
                    firsttick = tick;
                    curthread = threads = new CThreadProfileData(buf[3], tick);
                    checkerr(curthread == NULL, "Out of memory\n");
                }
                break;

            case XPROF_STOP:
                if (count > recsize) {
                    VERBOSE("Ignore data after STOP record.\n");
                }
                recsize = count;
                break;

            case XPROF_COMMENT:
                curthread->Comment(tick, buf[3]);
                break;

            case XPROF_THREAD_SWITCH:
                checkerr(curthread->IsDpcThread(),
                    "Thread switch in the middle of a DPC routine!\n");

                {
                    DWORD newtid = buf[3];

                    // deactivate the current thread
                    if (newtid == curthread->ThreadId()) {
                        errmsg("Switching to the same thread: %x?!\n", newtid);
                    }
                    curthread->Activate(tick, THREAD_INACTIVE, newtid);

                    // check if the new thread is already present
                    CThreadProfileData* oldthread = curthread;
                    curthread = threads;
                    while (curthread && curthread->ThreadId() != newtid) {
                        curthread = curthread->NextThread();
                    }

                    if (curthread) {
                        // cctivate the new thread if already present
                        curthread->Activate(tick, THREAD_ACTIVE);
                    } else {
                        // otherwise, create the new thread
                        curthread = new CThreadProfileData(newtid, tick);
                        checkerr(curthread == NULL, "Out of memory\n");

                        curthread->SetNextThread(threads);
                        threads = curthread;
                    }
                    curthread->SetPreviousThread(oldthread);
                }
                break;

            case XPROF_DPC_BEGIN:
                checkerr(curthread->IsDpcThread(), "Nested DPC call not expected!\n");
                curthread->Activate(tick, THREAD_INACTIVE, -1);

                if (dpcthread == NULL) {
                    dpcthread = new CThreadProfileData(-1, tick, TRUE);
                    checkerr(dpcthread == NULL, "Out of memory\n");
                } else {
                    dpcthread->Activate(tick, THREAD_ACTIVE);
                }

                dpcthread->SetNextThread(curthread);
                curthread = dpcthread;
                curthread->CallBegin(tick, 0, buf[3], rectype);
                break;

            case XPROF_DPC_END:
                if (curthread == dpcthread) {
                    checkerr(dpcthread->CallLevel() != 1, "Unbalanced DPC call.\n");
                    dpcthread->CallEnd(tick, buf[3], rectype);

                    dpcthread->Activate(tick, THREAD_INACTIVE);
                    curthread = dpcthread->NextThread();
                    curthread->Activate(tick, THREAD_ACTIVE);
                } else {
                    VERBOSE("Unexpected DPC-END record.\n");
                }
                break;

            default:
                goto badrec;
            }
            break;

        default:
            goto badrec;
        }

        count -= recsize;
        buf += recsize;
    }

    if (dpcthread) {
        if (dumpdpc) {
            dpcthread->SetNextThread(threads);
            threads = dpcthread;
        } else {
            delete dpcthread;
        }
    }

    // revert the thread list and perform postprocessing
    curthread = threads;
    threads = NULL;
    while (curthread) {
        CThreadProfileData* p = curthread;
        curthread = p->NextThread();
        p->SetNextThread(threads);
        threads = p;
        p->PostProcessing(firsttick, lasttick);
    }

    capstarttick = firsttick;
    capstoptick = lasttick;
    return threads;

badrec:
    errmsg("Bad record at offset: %x\n", (BYTE*) buf - (BYTE*) fileview);
    exit(-1);
}

void DumpThreadName(FILE* fout, DWORD tid)
{
    if (tid == ~0UL) {
        fprintf(fout, "[DPC]");
    } else if (tid == 0) {
        fprintf(fout, "[IDLE]");
    } else {
        fprintf(fout, "0x%02X", tid);
    }
}

void DumpIndent(FILE* fout, UINT level)
{
    for (UINT i=0; i<level; i++) {
        fprintf(fout, "%-2d ", i);
    }
}

UINT OpfDump(FILE* fout, CThreadProfileData* thread)
{
    fprintf(fout, "0\t0\tThread ");
    DumpThreadName(fout, thread->ThreadId());
    fprintf(fout, "\t0\t%I64u\t \t0\n", thread->ThreadTime()/733UI64);

    const CallDataEntry* entry;
    size_t position = 0;

    while ((entry = thread->GetCallDataEntry(position)) != NULL) {

        if (entry->type != ENTRYTYPE_FUNCCALL) {
            position++;
            continue;
        }

        SymEntry* symentry = symtable->Lookup(entry->callee ? entry->callee : entry->caller);

        fprintf(fout, "%d\t%d\t%s\t%d\t%I64u\t%c%s\n", 1, entry->level+1, symentry->name,
            symentry->module, entry->duration/733UI64, CALL_TYPE(entry->calltype),
            (entry->flags & ENTRYFLAG_NOEND) ? "\tIncomplete call" :
            (entry->flags & ENTRYFLAG_ORPHAN) ? "\tCallback?" : "");

        position++;
    }

    return thread->TotalCalls();
}

UINT RawDump(FILE* fout, CThreadProfileData* thread)
{
    fprintf(fout, "Thread ");
    DumpThreadName(fout, thread->ThreadId());
    fprintf(fout, " : time = %I64u\n", thread->ThreadTime()/733UI64);

    fprintf(fout, "%12s %12s   function\n", "start time", "duration");

    const CallDataEntry* entry;
    size_t position = 0;

    while ((entry = thread->GetCallDataEntry(position)) != NULL) {

        if (entry->type == ENTRYTYPE_THREADSWITCH && thread->IsDpcThread()) {
            position++;
            continue;
        }

        fprintf(fout, "%12I64u %12I64u ", entry->starttime/733UI64, entry->duration/733UI64);
        fprintf(fout, "%c ", (entry->flags & ENTRYFLAG_NOEND) ? '-' :
                 (entry->flags & ENTRYFLAG_ORPHAN) ? '?' : ' ');

        if (entry->type == ENTRYTYPE_FUNCCALL) {
            SymEntry* symentry;
            if (entry->level == 0) {
                if (thread->IsDpcThread()) {
                    fprintf(fout, "[DPC] ");
                } else if (entry->callee) {
                    symentry = symtable->Lookup(entry->caller);
                    fprintf(fout, "%s => ", symentry->name);
                }
            } else {
                DumpIndent(fout, entry->level);
                if (entry->callee && (entry->flags & ENTRYFLAG_ORPHAN)) {
                    symentry = symtable->Lookup(entry->caller);
                    fprintf(fout, "%s => ", symentry->name);
                }
            }

            symentry = symtable->Lookup(entry->callee ? entry->callee : entry->caller);
            fprintf(fout, "%s\n", symentry->name);
        } else if (entry->type == ENTRYTYPE_THREADSWITCH) {
            fprintf(fout, "thread-switch ");
            DumpThreadName(fout, entry->newtid);
            fprintf(fout, "\n");
        } else if (entry->type == ENTRYTYPE_COMMENT) {
            DumpIndent(fout, entry->level);
            fprintf(fout, "comment 0x%02X\n", entry->param);
        } else {
            fprintf(fout, "*** unknown entry type: 0x%02X\n", entry->type);
        }

        position++;
    }

    fprintf(fout, "\n");
    return thread->TotalCalls();
}

UINT AddSummary(CThreadProfileData* thread)
{
    const CallDataEntry* entry;
    size_t position = 0;

    while ((entry = thread->GetCallDataEntry(position)) != NULL) {

        if (entry->type != ENTRYTYPE_FUNCCALL) {
            position++;
            continue;
        }

        if (entry->type == ENTRYTYPE_FUNCCALL) {
            functable.add(entry);
        }

        position++;
    }

    return thread->TotalCalls();
}

void SummaryDump(FILE* fout)
{
    int i, count;

    if ((count = functable.getcount()) != 0) {
        fprintf(fout, csvformat ? "%s,%s,%s,%s,%s,%s\n" : "%-8s %7s %7s %9s %9s %s\n",
            "FuncAddr", " CallIn", "CallOut", "InclTime", "ExclTime", "Function Name");
    }

    if (sortby != CFunctionTable::sortby_unknown) {
        functable.sort(sortby);
    }

    for (i=0; i<count; i++) {
        const CallDataEntry* entry = functable.getentry(i);
        ULONG_PTR address = entry->callee ? entry->callee : entry->caller;
        fprintf(fout, csvformat ? "0x%X,%u,%u,%I64u,%I64u,%s\n" : \
            "%08X %7u %7u %9I64u %9I64u %s\n", address, entry->callin,
            entry->callout, entry->duration/733UI64,
            (entry->duration - entry->callouttime)/733UI64,
            lookupsymname(address));
    }
}

void capdump(CHAR* cap_filename, CHAR* dump_filename)
{
    // map the profile data file into memory
    VOID* fileview;
    DWORD filesize;
    CThreadProfileData* threads;

    fileview = mapfile(cap_filename, &filesize);
    checkerr(fileview == NULL, "Couldn't open profile data file\n", cap_filename);

    symtable = new CSymbolTable();

    // parse the profile data file
    __try {
        threads = capparse(fileview, filesize);
        UnmapViewOfFile(fileview);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        checkerr(TRUE, "Error reading profile data\n");
    }

    // dump the profile data file in text format
    FILE* fout = dump_filename ? fopen(dump_filename, "w") : stdout;
    checkerr(fout == NULL, "Can't open dump file %s\n", dump_filename);

    if (!summaryonly && !rawdump) {
        fprintf(fout, "Calls\tLevel\tFunction\tModule\tTime\tType\tWarnings\n");
    }

    UINT totalcalls = 0;
    UINT threadcnt = 0;
    CThreadProfileData* p;

    for (p=threads; p; p=p->NextThread()) {

        if (noidle && p->ThreadId() == 0) {
            continue;
        }

        if (summaryonly) {
            totalcalls += AddSummary(p);
        } else if (rawdump) {
            totalcalls += RawDump(fout, p);
        } else {
            totalcalls += OpfDump(fout, p);
        }

        threadcnt++;
    }

    if (summaryonly) {
        SummaryDump(fout);
    }

    if (!csvformat) {
        fprintf(fout, "\n");
        fprintf(fout, "MODULES:\n");

        SymbolFile* symfile = symfiles;

        for (UINT i=0; i < symcnt; i++, symfile++) {
            fprintf(fout, "#%d %s\n", i, symfile->name);
            fprintf(fout, "Path = %s\n", symfile->name);
            fprintf(fout, "Symbols = %s\n", symfile->symname);
            fprintf(fout, "Base Address = 0x%08X Size = 0x%X\n\n", symfile->baseaddr, symfile->size);
        }

        fprintf(fout, "INSTRUMENTATION:\n");
        fprintf(fout, "start   : %I64u\n", capstarttick/733UI64);
        fprintf(fout, "stop    : %I64u\n", capstoptick/733UI64);
        fprintf(fout, "duration: %I64u microseconds\n\n", (capstoptick-capstarttick)/733UI64);

        fprintf(fout, "STATISTICS:\n");
        fprintf(fout, "Total Threads = %d\n", threadcnt);
        fprintf(fout, "Maximum Concurrent Threads = %d\n", threadcnt);
        fprintf(fout, "Total Function Nodes = %d\n", totalcalls);
        fprintf(fout, "Total Function Calls = %d\n", totalcalls);
    }

    delete symtable;
    unloadsymfiles();

    if (fout != stdout) {
        fclose(fout);
    }

    while (threads) {
        p = threads;
        threads = p->NextThread();
        delete p;
    }
}

int __cdecl main(int argc, char* argv[])
{
    HRESULT hr;
    ULONG cmd = INVALIDCMD;
    char* cap_filename = NULL;
    char* dump_filename = NULL;

    ProgramName = strrchr(*argv, '\\');

    if (!ProgramName) {
        ProgramName = *argv;
    } else {
        ProgramName++;
    }

    argv++;
    argc--;

    while (argc--) {
        char* opt = *argv++;
        int params = 0;

        if (optequ(opt, "-x") && argc >= 1) {
            hr = DmSetXboxName(*argv);
            checkerr(FAILED(hr), "Error setting Xbox name: %x\n", hr);
            params += 1;
        } else if (optequ(opt, "start") && !cmd) {
            cmd = STARTCMD;
        } else if (optequ(opt, "stop") && !cmd && argc >= 1) {
            cmd = STOPCMD;
            cap_filename = *argv;
            params += 1;
        } else if (optequ(opt, "dump") && !cmd && argc >= 1) {
            cmd = DUMPCMD;
            cap_filename = argv[0];
            dump_filename = argc > 1 ? argv[1] : NULL;
            params += (dump_filename ? 2 : 1);
        } else if (optequ(opt, "-s") && !symbolpath && argc >= 1) {
            symbolpath = *argv;
            params += 1;
        } else if (optequ(opt, "-v")) {
            verbose = true;
        } else if (optequ(opt, "-idle")) {
            noidle = true;
        } else if (optequ(opt, "-opf")) {
            rawdump = false;
        } else if (optequ(opt, "-dpc")) {
            dumpdpc = true;
        } else if (optequ(opt, "-csv")) {
            csvformat = true;
        } else if (optequ(opt, "-sort") && argc >= 1) {
            for (int i=0; i<sizeof(sortkeytable)/sizeof(sortkeytable[0]); i++) {
                if (!_stricmp(sortkeytable[i].key, argv[0])) {
                    sortby = sortkeytable[i].sortkey;
                }
            }
            if (sortby == CFunctionTable::sortby_unknown) {
                usage();
            }
            params += 1;
        } else if (optequ(opt, "-summary")) {
            summaryonly = true;
        } else {
            usage();
        }

        argv += params;
        argc -= params;
    }

    // comma delimited format is valid only in summary report
    if (!summaryonly && (csvformat || sortby != CFunctionTable::sortby_unknown)) {
        usage();
    }

    switch (cmd) {
    case STARTCMD:
    case STOPCMD:
        DmUseSharedConnection(TRUE);
        hr = DmCAPControl(cmd == STARTCMD ? "start" : "stop");
        checkerr(FAILED(hr), "Error sending command to Xbox: %x\n", hr);

        if (cmd == STOPCMD) {
            hr = DmReceiveFile(cap_filename, XBOX_CAP_FILENAME);
            checkerr(FAILED(hr), "Error retrieving profile data: %x\n", hr);
        }

        DmUseSharedConnection(FALSE);
        break;

    case DUMPCMD:
        capdump(cap_filename, dump_filename);
        break;

    default:
        usage();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbpscapture\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbpscapture.rc
//
#define IDD_PSCAPTURE                   101
#define IDC_EDIT1                       1000
#define IDC_EDIT2                       1001
#define IDC_TEXT2                       1002
#define IDC_ChangeDirButton             1003
#define IDC_TempDirText                 1004
#define IDC_Label1                      1005
#define IDC_DeleteTempButton            1006
#define IDC_StatusText                  1007
#define IDC_EDIT3                       1008
#define IDC_RADIO1                      1009
#define IDC_RADIO2                      1010
#define IDC_EDIT4                       1011
#define IDC_CHECK1                      1012
#define IDC_TEXT1                       -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbsetcfg\xbsetcfg.cpp ===
/*
**
** xbsetcfg
**
** Set the remote Xbox machine
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>

// fake this to get the av.h header to be included.
typedef unsigned long NTSTATUS;
    
#include <av.h>

#include "xbfile.hxx"
#include "xbox.h"
#include "xboxp.h"

int __cdecl main(int cArg, char **rgszArg)
{
    char *szExe = *rgszArg;
    DWORD dwConfigValue = 0;
    DWORD dwPAL60Flags = 0;
    BOOL fSeenV = FALSE;
    DWORD dwTempVal;

    HRESULT hr;

    /* Process arguments */
    ++rgszArg;
    while(--cArg) {
        if (**rgszArg != '-' && **rgszArg != '/')
        {
            goto usage;
        }
        char *szArg = *rgszArg++;
        while(*++szArg) {
            switch(*szArg) {
            case 'x':
            case 'X':
                if(!--cArg)
                    goto usage;
                if(FAILED(DmSetXboxName(*rgszArg++))) {
                    fprintf(stderr, "error in Xbox name\n");
                    exit(1);
                }
                break;

            case 'v':
            case 'V':
            {
                if(!--cArg)
                    goto usage;

                if (dwConfigValue)
                    goto usage;

                fSeenV = TRUE;

                char* pszNextArg = *rgszArg++;

                if (0 == _stricmp(pszNextArg, "NTSC-M"))
                {
                    dwConfigValue = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
                }
                else if (0 == _stricmp(pszNextArg, "NTSC-J"))
                {
                    dwConfigValue = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz;
                }
                else if (0 == _stricmp(pszNextArg, "PAL-I"))
                {
                    dwConfigValue = AV_STANDARD_PAL_I | AV_FLAGS_50Hz;
                }
                else if (0 == _stricmp(pszNextArg, "PAL-M"))
                {
                    dwConfigValue = AV_STANDARD_PAL_M | AV_FLAGS_60Hz;
                }
                else
                {
                    fprintf(stderr, "invalid arg %s: must be NTSC-M, NTSC-J, or PAL-I\n", pszNextArg);
                    exit(1);
                }
                break;
            }

            case 'D':
            {
                char szDir[MAX_PATH + 1];
                char szName[MAX_PATH + 1];
                char szCommand[1024];
                char *pch;
                char *pchArg = *rgszArg;

                if(1 != --cArg)
                    goto usage;
                FIL fil(*rgszArg);
                if(!fil.m_fXbox) {
                    fprintf(stderr, "error: illegal filename %s\n", pchArg);
                    exit(1);
                }
                strcpy(szName, fil.m_szName);
                fil.m_szName[0] = 0;
                fil.FillFullName(szDir);
                fil.m_szName[0] = szName[0];
                sprintf(szCommand, "deftitle dir=\"%s\" name=\"%s\"",
                    szDir, szName);
                hr = DmSendCommand(NULL, szCommand, NULL, NULL);
                if(FAILED(hr))
                    fil.Fatal(hr, 0);
                goto done;
            }

            case 'l':
            case 'L':
                if(0 != --cArg)
                    goto usage;
                hr = DmSendCommand(NULL, "deftitle launcher", NULL, NULL);
                goto done;

            case 'd':
                if(0 != --cArg)
                    goto usage;
                hr = DmSendCommand(NULL, "deftitle none", NULL, NULL);
                goto done;

            case 'W':
            case 'w':
                if (!fSeenV)
                    goto usage;

                dwConfigValue |= AV_FLAGS_WIDESCREEN;
                break;

            case '6':
                if (!fSeenV)
                    goto usage;

                if((dwConfigValue & AV_STANDARD_MASK) != AV_STANDARD_PAL_I) {
                    fprintf(stderr, "error: -6 valid only with PAL-I\n");
                    exit(1);
                }
                dwPAL60Flags = AV_FLAGS_60Hz;
                break;

            case '4':
                if (!fSeenV)
                    goto usage;

                if(((dwConfigValue & AV_STANDARD_MASK) != AV_STANDARD_NTSC_M) &&
                   ((dwConfigValue & AV_STANDARD_MASK) != AV_STANDARD_NTSC_J)) {
                    fprintf(stderr, "error: -4 valid only with NTSC-M or NTSC-J\n");
                    exit(1);
                }
                dwConfigValue |= AV_FLAGS_HDTV_480p;
                break;

            case '7':
                if (!fSeenV)
                    goto usage;

                if(((dwConfigValue & AV_STANDARD_MASK) != AV_STANDARD_NTSC_M) &&
                   ((dwConfigValue & AV_STANDARD_MASK) != AV_STANDARD_NTSC_J)) {
                    fprintf(stderr, "error: -7 valid only with NTSC-M or NTSC-J\n");
                    exit(1);
                }
                dwConfigValue |= AV_FLAGS_HDTV_720p;
                break;

            case '1':
                if (!fSeenV)
                    goto usage;

                if(((dwConfigValue & AV_STANDARD_MASK) != AV_STANDARD_NTSC_M) &&
                   ((dwConfigValue & AV_STANDARD_MASK) != AV_STANDARD_NTSC_J)) {
                    fprintf(stderr, "error: -1 valid only with NTSC-M or NTSC-J\n");
                    exit(1);
                }
                dwConfigValue |= AV_FLAGS_HDTV_1080i;
                break;

            case 'a':
            case 'A':
            {
#define TEMP_STEREO_FLAG 0x00008000
                
                DWORD dwAudioFlags = 0;

                if(1 != --cArg)
                    goto usage;

                char* pszNextArg = *rgszArg++;

                while (*pszNextArg && !isspace(*pszNextArg))
                {
                    switch (toupper(*pszNextArg))
                    {
                        case 'D':
                            if (XC_AUDIO_FLAGS_BASIC(dwAudioFlags) & (XC_AUDIO_FLAGS_MONO | TEMP_STEREO_FLAG))
                            {
                                fprintf(stderr, "invalid arg after -a: only R can be specified with D\n");
                                exit(1);
                            }
                            dwAudioFlags |= (XC_AUDIO_FLAGS_ENABLE_AC3 | XC_AUDIO_FLAGS_SURROUND);
                            break;
                            
                        case 'T':
                            dwAudioFlags |= XC_AUDIO_FLAGS_ENABLE_DTS;
                            break;
                            
                        case 'S':
                            if (dwAudioFlags & XC_AUDIO_FLAGS_ENABLE_AC3)
                            {
                                fprintf(stderr, "invalid arg after -a: only R can be specified with D\n");
                                exit(1);
                            }
                            
                            if (XC_AUDIO_FLAGS_BASIC(dwAudioFlags))
                            {
                                fprintf(stderr, "invalid arg after -a: only one of R, S, or M can be specified\n");
                                exit(1);
                            }

                            //
                            // Treat stereo like a bit flag for now (even though it is really 0)
                            //
                            
                            dwAudioFlags |= TEMP_STEREO_FLAG;
                            break;
                            
                        case 'R':
                            if (XC_AUDIO_FLAGS_BASIC(dwAudioFlags) & ~XC_AUDIO_FLAGS_SURROUND)
                            {
                                fprintf(stderr, "invalid arg after -a: only one of R, S, or M can be specified\n");
                                exit(1);
                            }
                            
                            dwAudioFlags |= XC_AUDIO_FLAGS_SURROUND;
                            break;
                            
                        case 'M':
                            if (dwAudioFlags & XC_AUDIO_FLAGS_ENABLE_AC3)
                            {
                                fprintf(stderr, "invalid arg after -a: only R can be specified with D\n");
                                exit(1);
                            }
                            
                            if (XC_AUDIO_FLAGS_BASIC(dwAudioFlags))
                            {
                                fprintf(stderr, "invalid arg after -a: only one of R, S, or M can be specified\n");
                                exit(1);
                            }

                            dwAudioFlags |= XC_AUDIO_FLAGS_MONO;
                            break;

                        default:
                            fprintf(stderr, "invalid arg after -a: only D, T, R, S, or M can be specified\n");
                            exit(1);
                    }
                    
                    pszNextArg++;
                }

                if (0 == XC_AUDIO_FLAGS_BASIC(dwAudioFlags))
                {
                    fprintf(stderr, "invalid arg after -a: R, S, or M must be specified\n");
                    exit(1);
                }

                //
                // Mask off our fake stereo bit flag (it is really 0)
                //
                
                dwAudioFlags &= ~TEMP_STEREO_FLAG;
                            
                hr = DmSetConfigValue(XC_AUDIO_FLAGS, REG_DWORD, &dwAudioFlags, sizeof(dwAudioFlags));
                goto done;
            }

            case 'n':
            case 'N':
            {
                DWORD dwLanguage = 0;

                if(1 != --cArg)
                    goto usage;

                char* pszNextArg = *rgszArg++;

                // This better be a one character argument, if not, goto usage
                if ((*(pszNextArg + 1) != '\0') &&
                    (!isspace(*(pszNextArg + 1))))
                {
                    fprintf(stderr, "invalid arg after -n: 1, 2, 3, 4, 5, or 6 must be specified\n");
                    exit(1);
                }

                switch (*pszNextArg)
                {
                    case '1':
                        dwLanguage = XC_LANGUAGE_ENGLISH;
                        break;
                        
                    case '2':
                        dwLanguage = XC_LANGUAGE_JAPANESE;
                        break;
                        
                    case '3':
                        dwLanguage = XC_LANGUAGE_GERMAN;
                        break;
                        
                    case '4':
                        dwLanguage = XC_LANGUAGE_FRENCH;
                        break;
                        
                    case '5':
                        dwLanguage = XC_LANGUAGE_SPANISH;
                        break;
                        
                    case '6':
                        dwLanguage = XC_LANGUAGE_ITALIAN;
                        break;
                }
                            

                if (0 == dwLanguage)
                {
                    fprintf(stderr, "invalid arg after -n: 1, 2, 3, 4, 5, or 6 must be specified\n");
                    exit(1);
                }

                hr = DmSetConfigValue(XC_LANGUAGE, REG_DWORD, &dwLanguage, sizeof(dwLanguage));
                goto done;
            }

            case 't':
            case 'T':
            {
                //
                // Set the clock on the xbox
                // also if the time zone or language information is invalid
                // initialize them to their default values
                //
                FILETIME filetime;
                CHAR cmdbuf[64];
                if(0 != --cArg)
                    goto usage;
                GetSystemTimeAsFileTime(&filetime);
                sprintf(cmdbuf, "setsystime clockhi=0x%08x clocklo=0x%08x tz=1",
                    filetime.dwHighDateTime, filetime.dwLowDateTime);
                hr = DmSendCommand(NULL, cmdbuf, NULL, NULL);
                goto done;
            }

            default:
                goto usage;
            }
        }
    }

    if ((cArg < 0)) {
usage:
        fprintf(stderr, "usage: %s [-x xboxname]\n", szExe);
        fprintf(stderr, "\n");
        fprintf(stderr, "To change the video flags:\n");
        fprintf(stderr, "        -v      {NTSC-M|NTSC-J|PAL-I} [-w] [-6] [-4] [-7] [-1]\n");
        fprintf(stderr, "                 -w == enable widescreen support\n");
        fprintf(stderr, "                 -6 == enable PAL-60\n");
        fprintf(stderr, "                 -4 == enable 480p (HDTV only)\n");
        fprintf(stderr, "                 -7 == enable 720p (HDTV only)\n");
        fprintf(stderr, "                 -1 == enable 1080i (HDTV only)\n");
        fprintf(stderr, "\n");
        fprintf(stderr, "To change the audio flags:\n");
        fprintf(stderr, "        -a      {D|T|{R|S|M}}\n");
        fprintf(stderr, "                 D == enable Dolby Digital output\n");
        fprintf(stderr, "                 T == enable DTS output\n");
        fprintf(stderr, "                 R == set 2 channel output to Dolby Surround\n");
        fprintf(stderr, "                 S == set 2 channel output to Stereo (only if DD not enabled)\n");
        fprintf(stderr, "                 M == set 2 channel output to Mono (only if DD not enabled)\n");
        fprintf(stderr, "\n");
        fprintf(stderr, "To change the default language:\n");
        fprintf(stderr, "        -n      {1|2|3|4|5|6}\n");
        fprintf(stderr, "                 1 == English\n");
        fprintf(stderr, "                 2 == Japanese\n");
        fprintf(stderr, "                 3 == German\n");
        fprintf(stderr, "                 4 == French\n");
        fprintf(stderr, "                 5 == Spanish\n");
        fprintf(stderr, "                 6 == Italian\n");
        fprintf(stderr, "\n");
        fprintf(stderr, "To change the default title:\n");
        fprintf(stderr, "        -l      set the default title to be the launcher\n");
        fprintf(stderr, "        -d      set the default title to be the dashboard\n");
        exit(1);
    }

    if(!(dwConfigValue & AV_REFRESH_MASK))
        goto usage;

    dwTempVal = dwPAL60Flags | (dwConfigValue & (AV_HDTV_MODE_MASK | AV_FLAGS_WIDESCREEN));

    hr = DmSetConfigValue(XC_VIDEO_FLAGS, REG_DWORD, &dwTempVal, sizeof(dwTempVal));

    if (SUCCEEDED(hr))
    {
        dwTempVal = (dwConfigValue & (AV_STANDARD_MASK | AV_REFRESH_MASK));
        hr = DmSetConfigValue(XC_FACTORY_AV_REGION, REG_DWORD, &dwTempVal, sizeof(dwTempVal));
    }

done:
    if (FAILED(hr))
    {
        Fatal(hr, 0);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbsfu\StdAfx.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    stdafx.h

Abstract:

    This is a pre-compiled header module.

--*/

#if !defined(AFX_STDAFX_H__7A5FDEFE_A50D_49AD_8B8A_0833ACCC7FAB__INCLUDED_)
#define AFX_STDAFX_H__7A5FDEFE_A50D_49AD_8B8A_0833ACCC7FAB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <crtdbg.h>
#include <windows.h>
#include <xboxdbg.h>
#include <dbghelp.h>
#include <xboxverp.h>

const unsigned long CrcTable32[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

unsigned long
__inline
CRC32(
    unsigned long InitialCrc,
    const void *Buffer,
    unsigned long Bytes
    )
{
    unsigned long Crc = InitialCrc;
    const unsigned char *p = (unsigned char *)Buffer;
    unsigned long Count = Bytes;

    while (Count--) {
        Crc = (Crc >> 8) ^ CrcTable32[((unsigned char)(Crc)) ^ *p++];
    }

    return Crc;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7A5FDEFE_A50D_49AD_8B8A_0833ACCC7FAB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbren\xbren.cpp ===
/*
**
** xbren
**
** Rename files on the Xbox
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "xbfile.hxx"
#include "xbfilr.hxx"
#include "optn.hxx"
#include "resource.h"
#include <xboxverp.h>

BOOL fSuccess;
FIL *g_pfilDst;
const char *g_pchWExt;

struct OFIL : public FILR {
	OFIL(void) : FILR() {}
	OFIL(const char *sz) : FILR(sz) {}

	void DoWork(void);
	FILR *PfilrCopy(void) const { return new OFIL(*this); }

    const char *m_pchPat;
};

void OFIL::DoWork(void)
{
    FIL filNew(*this);
    HRESULT hr;

    if(m_pchPat) {
        int rgichStart[16];
        int rgichLen[16];
        int cich;
        const char *pchExt;
        char *pch, *pchOut;

        /* We match the original name once again so we can figure out what the
         * wildcards matched */
        cich = 0;
        if(g_pchWExt) {
            int cch;
            Basename(m_szName, NULL, &pchExt);
            cch = pchExt ? pchExt - m_szName - 1 : strlen(m_szName);
            if(FPatMatch(m_pchPat, g_pchWExt - m_pchPat - 1, m_szName, cch,
                rgichStart, rgichLen, 15))
            {
                while(cich < 15 && rgichStart[cich] >= 0)
                    ++cich;
            }
            if(pchExt && FPatMatch(g_pchWExt, strlen(g_pchWExt), pchExt,
                strlen(pchExt), &rgichStart[cich], &rgichLen[cich], 15 - cich))
            {
                while(cich < 15 && rgichStart[cich] >= 0) {
                    rgichStart[cich] += pchExt - m_szName;
                    ++cich;
                }
            }
        } else {
            if(FPatMatch(m_pchPat, strlen(m_pchPat), m_szName,
                strlen(m_szName), rgichStart, rgichLen, 15))
            {
                while(cich < 15 && rgichStart[cich] >= 0)
                    ++cich;
            }
        }
        rgichStart[cich] = -1;

        /* With the matching out of the way, we can now do the substitution */
        cich = 0;
        pch = g_pfilDst->m_szName;
        pchOut = filNew.m_szName;
        while(*pch) {
            if(*pch == '?' || *pch == '*') {
                /* Skip past the wildcard */
                while(*pch == '?' || *pch == '*')
                    ++pch;
                /* Now stick in the substitute characters */
                if(rgichStart[cich] >= 0) {
                    memcpy(pchOut, m_szName + rgichStart[cich], rgichLen[cich]);
                    pchOut += rgichLen[cich];
                    ++cich;
                }
            } else
                *pchOut++ = *pch++;
        }
        *pchOut = 0;
    } else {
        strcpy(filNew.m_szName, g_pfilDst->m_szName);
    }

    hr = HrRename(filNew);
    if(hr == XBDM_ALREADYEXISTS || hr == XBDM_BADFILENAME)
        filNew.Warning(hr, 0);
    else if(FAILED(hr))
        Warning(hr, 0);
    else
        fSuccess = TRUE;
}

BOOL OPTH::FParseOption(char *&sz, char)
{
    switch(*sz) {
    case 's':
    case 'S':
    case 'h':
    case 'H':
        return FParseFilrOption(*sz);
    }
    return FALSE;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbren version " VER_PRODUCTVERSION_STR "\n\n"
        "Renames a file or files on the Xbox development or target system.\n");
	fprintf(stderr, "\nusage: %s [/x xboxname] [options] oldname newname\n",
        m_szExe);
    fprintf(stderr, "newname must not contain any path elements\n"
        "\t/s search in subdirectories\n"
	    "Specify Xbox files as xE:\\..., xD:\\..., etc.\n");
	exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
	char *szExe = *rgszArg;
	HRESULT hr;

    /* Cut down on repeated connection requests */
    DmUseSharedConnection(TRUE);

	/* Process arguments */
	OPTH opth(cArg, rgszArg);

	if(cArg != 2)
        opth.UsageFailure();

	OFIL ofilOld(rgszArg[0]);
	FIL filNew(rgszArg[1]);

    /* The new filename must be just a single local filename */
    if(filNew.m_fXbox || strcmp(filNew.m_szDir, ".")) {
        fprintf(stderr, "error: new name cannot contain path elements\n");
        exit(1);
    }

    /* Zero or two wildcards */
    if(ofilOld.FIsWildName()) {
        if(!filNew.FIsWildName()) {
            fprintf(stderr, "error: destination can't be wildcard\n");
            exit(1);
        }
        ofilOld.m_pchPat = ofilOld.m_szName;
        Basename(ofilOld.m_szName, NULL, &g_pchWExt);
    } else {
        if(filNew.FIsWildName()) {
            fprintf(stderr, "error: destination must be wildcard\n");
            exit(1);
        }
        ofilOld.m_pchPat = NULL;
    }

    g_pfilDst = &filNew;
    ofilOld.DoTree(FALSE);

    return !fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbvscapture\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbvscapture.rc
//
#define IDD_VSCAPTURE                   101
#define IDB_BITMAP1                     106
#define IDC_EDIT1                       1000
#define IDC_EDIT2                       1001
#define IDC_TEXT2                       1002
#define IDC_ChangeDirButton             1003
#define IDC_TempDirText                 1004
#define IDC_Label1                      1005
#define IDC_DeleteTempButton            1006
#define IDC_StatusText                  1007
#define IDC_EDIT3                       1008
#define IDC_RADIO1                      1009
#define IDC_RADIO2                      1010
#define IDC_EDIT4                       1011
#define IDC_CHECK1                      1012
#define IDC_TEXT1                       -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbxray\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbxray.rc
//
#define IDD_XRAY                        101
#define IDC_StatusText                  1007
#define IDC_EDIT4                       1011
#define IDC_CHECK1                      1012
#define IDC_CHECK2                      1013
#define IDC_SLIDER1                     1014
#define IDC_RADIO1                      1015
#define IDC_RADIO2                      1016
#define IDC_RADIO3                      1017
#define IDC_RADIO4                      1018
#define IDC_RADIO5                      1019
#define IDC_RADIO6                      1020
#define IDC_RADIO7                      1021
#define IDC_RADIO8                      1022
#define IDC_STATIC2                     1023
#define IDC_STATIC1                     1024
#define IDC_STATIC3                     1025
#define IDC_RADIO9                      1026
#define IDC_RADIO10                     1027
#define IDC_RADIO11                     1028
#define IDC_SCROLLBAR1                  1029
#define IDC_STATIC4                     1030
#define IDC_RADIO13                     1031
#define IDC_RADIO14                     1032
#define IDC_RADIO15                     1033
#define IDC_RADIO16                     1034
#define IDC_GRAY                        1035
#define IDC_SUPER                       1036
#define IDC_LevelText                   -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1036
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbsfu\xbsfu.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    xbsfu.cpp

Abstract:

    This module implements routines to update system files on XDK.

--*/

#include "stdafx.h"

HRESULT
WINAPI
SfuUpdateSystemFile(
    IN CONST CHAR* Source,
    IN CONST CHAR* Destination,
    IN PDM_CONNECTION Connection
    )
{
    HRESULT hr = E_FAIL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    HANDLE MapHandle = NULL;
    PVOID MapView = NULL;
    LARGE_INTEGER FileSize;
    DWORD CRC;
    CHAR CommandBuffer[512];
    CHAR Response[128];
    DWORD ResponseSize = sizeof(Response);

    __try {

        FileHandle = CreateFile(Source, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, 0);

        if (FileHandle == INVALID_HANDLE_VALUE) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }

        if (!GetFileSizeEx(FileHandle, &FileSize)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }

        if (FileSize.HighPart) {
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            __leave;
        }

        MapHandle = CreateFileMapping(FileHandle, 0, PAGE_READONLY, 0, 0, 0);

        if (!MapHandle) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }

        MapView = MapViewOfFile(MapHandle, FILE_MAP_READ, 0, 0, 0);

        if (!MapView) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }

        CRC = CRC32(~0UL, MapView, FileSize.LowPart);

        if (_snprintf(CommandBuffer, sizeof(CommandBuffer) - 1,
                "sysfileupd name=%s crc=0x%x size=0x%x", Destination, CRC,
                FileSize.LowPart) < 0) {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
            __leave;
        }

        hr = DmSendCommand(Connection, CommandBuffer, Response, &ResponseSize);

        if (hr != XBDM_READYFORBIN) {
            __leave;
        }

        hr = DmSendBinary(Connection,  MapView, FileSize.LowPart);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = HRESULT_FROM_NT(GetExceptionCode());
    }

    if (FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(FileHandle);
    }

    if (MapHandle) {
        CloseHandle(MapHandle);
    }

    if (MapView) {
        UnmapViewOfFile(MapView);
    }

    return hr;
}

void usage()
{
    fprintf(stderr,
        "Xbox System File Update Version " VER_PRODUCTVERSION_STR "\n"
        "Copyright (c) Microsoft Corporation.  All rights reserved.\n\n"
        "Usage:\t  xbsfu source destination\n\n"
        "Example:  The following command will upload xbdm.dll from current\n"
        "\t  directory to first partition on Xbox hard drive\n\n"
        "\t  xbsfu xbdm.dll \\device\\harddisk0\\partition1\\xbdm.dll\n");
    exit(1);
}

int __cdecl main(int argc, char* argv[])
{
    PDM_CONNECTION pdmc = NULL;
    HRESULT hr;

    if (argc != 3) {
        usage();
    }

    hr = DmOpenConnection(&pdmc);

    if (SUCCEEDED(hr)) {
        hr = SfuUpdateSystemFile(argv[1], argv[2], pdmc);
    }

    if (FAILED(hr)) {
        char buffer[128];
        DmTranslateError(hr, buffer, sizeof(buffer));
        fprintf(stderr, "%s\n", buffer);
    } else {
        fprintf(stderr, "The operation completed successfully\n");
    }

    if (pdmc) {
        DmCloseConnection(pdmc);
    }

    return FAILED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbvscapture\xbvscapture.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xbvscapture.cpp
 *  Content:    Vertex Shader Debugger
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <time.h>
#include "d3d8-xbox.h"

typedef struct _D3DVsInstruction {
    unsigned long eos:1;        /* 0:00 last instruction */
    unsigned long cin:1;        /* 0:01 ctx indexed address */
    unsigned long  om:1;        /* 0:02 output mux */
    unsigned long  oc:9;        /* 0:03 output write control */
    unsigned long owm:4;        /* 0:12 output write mask */
    unsigned long swm:4;        /* 0:16 secondary register write mask */
    unsigned long  rw:4;        /* 0:20 register write */
    unsigned long rwm:4;        /* 0:24 primary register write mask */
    unsigned long cmx:2;        /* 0:28 c mux (NA,r1,v,c) */
    unsigned long crr:4;        /* 0:30 c register read */
    unsigned long cws:2;        /* 1:02 c w swizzle */
    unsigned long czs:2;        /* 1:04 c z swizzle */
    unsigned long cys:2;        /* 1:06 c y swizzle */
    unsigned long cxs:2;        /* 1:08 c x swizzle */
    unsigned long cne:1;        /* 1:10 c negate */
    unsigned long bmx:2;        /* 1:11 b mux (NA,r1,v,c) */
    unsigned long brr:4;        /* 1:13 b register read */
    unsigned long bws:2;        /* 1:17 b w swizzle */
    unsigned long bzs:2;        /* 1:19 b z swizzle */
    unsigned long bys:2;        /* 1:21 b y swizzle */
    unsigned long bxs:2;        /* 1:23 b x swizzle */
    unsigned long bne:1;        /* 1:25 b negate */
    unsigned long amx:2;        /* 1:26 a mux (NA,r0,v,c) */
    unsigned long arr:4;        /* 1:28 a register read */
    unsigned long aws:2;        /* 2:00 a w swizzle */
    unsigned long azs:2;        /* 2:02 a z swizzle */
    unsigned long ays:2;        /* 2:04 a y swizzle */
    unsigned long axs:2;        /* 2:06 a x swizzle */
    unsigned long ane:1;        /* 2:08 a negate */
    unsigned long  va:4;        /* 2:09 ibuffer address */
    unsigned long  ca:8;        /* 2:13 ctx address */
    unsigned long mac:4;        /* 2:21 MLU/ALU op */
    unsigned long ilu:3;        /* 2:25 ILU op */
} D3DVsInstruction;

static const char* kOutNames[] = {"oPos",
    "o1?", "o2?",
    "oD0", "oD1",
    "oFog", "oPts",
    "oB0", "oB1",
    "oT0", "oT1", "oT2", "oT3", "???"
};

extern "C"
HRESULT DisassembleInstruction(const D3DVsInstruction* pI, char* outBuf, DWORD outLength);

void ConvertPackedDWordsToUCode(const DWORD* pIn, D3DVsInstruction* pucode)
{
    memset(pucode,0,sizeof(D3DVsInstruction));
    DWORD x = *pIn++;
    DWORD y = *pIn++;
    DWORD z = *pIn++;
    DWORD w = *pIn++;
    // Word X -- ignore
    // Word Y
	pucode->aws = (y >> 0);
	pucode->azs = (y >> 2);
    pucode->aws = (y >> 0);
    pucode->azs = (y >> 2);
    pucode->ays = (y >> 4);
    pucode->axs = (y >> 6);
    pucode->ane = (y >> 8);
    pucode->va  = (y >> 9);
    pucode->ca  = (y >>13);
    pucode->mac = (y >>21);
    pucode->ilu = (y >>25);
    //Word Z
    pucode->crr = ((0xc & (z << 2)) | ((w >> 30) & 0x3));
    pucode->cws = (z >> 2);
    pucode->czs = (z >> 4);
    pucode->cys = (z >> 6);
    pucode->cxs = (z >> 8);
    pucode->cne = (z >>10);
    pucode->bmx = (z >>11);
    pucode->brr = (z >>13);
    pucode->bws = (z >>17);
    pucode->bzs = (z >>19);
    pucode->bys = (z >>21);
    pucode->bxs = (z >>23);
    pucode->bne = (z >>25);
    pucode->amx = (z >>26);
    pucode->arr = (z >>28);

    //Word W
    pucode->eos = (w >> 0);
    pucode->cin = (w >> 1);
    pucode->om  = (w >> 2);
    pucode->oc  = (w >> 3);
    pucode->owm = (w >>12);
    pucode->swm = (w >>16);
    pucode->rw  = (w >>20);
    pucode->rwm = (w >>24);
    pucode->cmx = (w >>28);
} 

/*
**
** xbvscapture
**
** Captures a vertex shader snapshot
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "resource.h"
#include <xboxverp.h>
#include "xbfile.hxx"

#define SHADER_CAPTURE_BUFFER_SIZE 32768

// Identifiers for data blocks in the capture buffer
#define VSS_EOF         0x80000000
#define VSS_VERTEX      0x81000000
#define VSS_INSTRUCTION 0x82000000
#define VSS_PROGRAM     0x84000000
#define VSS_STATS       0x85000000

typedef struct vtxreg
{
    DWORD w,z,y,x;
} VTXREG;

typedef struct vtxio
{
    DWORD regs;     // lower 16 are VAB, upper are temp
    DWORD outs;     // output registers
    DWORD cnst;     // which constant
} VTXIO;

DWORD g_dwFlags = 0;
DWORD g_dwMarker;

char g_HTMLFilename[MAX_PATH];
char g_BMPFilename[MAX_PATH];
char g_TmpPath[MAX_PATH];
INT g_ProgramLength;
struct _program
{
    VTXREG inst;
    char   buf[1024];
}Program[126];

BYTE buf[SHADER_CAPTURE_BUFFER_SIZE];

DWORD UsedInputRegisters;
DWORD UsedOutputRegisters;

VTXREG vals[256];
BYTE   idxs[500];

void GenerateHTML(BYTE *buf, FILE *fp);

BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    SetDlgItemText(hwnd, IDC_StatusText, "Initializing...");
    GetTempPath(1024, g_TmpPath);
    SetDlgItemInt(hwnd, IDC_EDIT1, 0, FALSE);
    SetDlgItemInt(hwnd, IDC_EDIT2, 100, FALSE);
    SetDlgItemText(hwnd, IDC_EDIT3, g_TmpPath);
    CheckDlgButton(hwnd, IDC_CHECK1, FALSE); 
    SetDlgItemInt(hwnd, IDC_EDIT4, 0, FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), FALSE);
    SetDlgItemText(hwnd, IDC_StatusText, "Ready to Capture");
    return TRUE;
}

DWORD WINAPI ThreadProc(LPVOID pParam)
{
    char cmd[1024];
    sprintf(cmd, "\"%s\"", pParam);
    system(cmd);
    return TRUE;
}

DWORD *FindOpcode(DWORD op, BYTE *buf)
{
    DWORD *dwbuf = (DWORD*)buf;
    
    while((*dwbuf & 0xff000000) != VSS_EOF)
    {
        if((*dwbuf & 0xff000000) == op)
            return dwbuf;   // found
        
        dwbuf += *dwbuf & 0x00ffffff;   // move to next opcode
        if(((DWORD)dwbuf - (DWORD)buf) > SHADER_CAPTURE_BUFFER_SIZE)
            return NULL;    // not found and no EOF
    }
    if((op == VSS_EOF) && ((*dwbuf & 0xff000000) == VSS_EOF))
        return dwbuf;
    
    return NULL;    // not found
}

void WriteOutputFiles(BYTE *buf)
{
    FILE *fp;
    BYTE *bptr;
    HRESULT hr;
    char errorbuf[MAX_PATH];
    
    // generate filenames
    
    SYSTEMTIME sysTime;
    GetLocalTime(&sysTime);
    char time[1024];
    sprintf(time, "%02d-%02d-%02d-%02d-%02d", 
            sysTime.wMonth, sysTime.wDay, sysTime.wHour, 
            sysTime.wMinute, sysTime.wSecond);
    sprintf(g_HTMLFilename, "%sxbvscpta%s.htm", g_TmpPath, time);
    sprintf(g_BMPFilename, "%sxbvscptb%s.bmp", g_TmpPath, time);
    
    // get the screen shot
    hr = DmScreenShot(g_BMPFilename);  // don't report an error if it occurs
    
    fp = fopen(g_HTMLFilename, "w");
    if(!fp)
    {
        sprintf(errorbuf, "Unable to open file %s.", g_HTMLFilename);
        MessageBox(NULL, (const char*)errorbuf, "File Write Error", MB_OK | MB_TASKMODAL);
        return;
    }
    GenerateHTML(buf, fp);                                          // generate the html
    fclose(fp);
    CreateThread(NULL, 0, &ThreadProc, g_HTMLFilename, 0, NULL);    // display the html
}

void DeleteFiles(char *cPattern)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    char Filename[MAX_PATH];

    sprintf(Filename, "%s%s", g_TmpPath, cPattern);
    hFind = FindFirstFile(Filename, &FindFileData);
    while(hFind != INVALID_HANDLE_VALUE)
    {
        sprintf(Filename, "%s%s", g_TmpPath, FindFileData.cFileName);
        DeleteFile(Filename);
        BOOL bSuccess = FindNextFile(hFind, &FindFileData);
        if(!bSuccess)
        {
            FindClose(hFind);
            break;
        }
    }
}

void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
    case IDCANCEL:
        EndDialog(hwnd, id);
        break;
    case IDOK:
        HRESULT hr;
        SetDlgItemText(hwnd, IDC_StatusText, "Capturing one frame...");
        
        
        g_dwMarker = GetDlgItemInt(hwnd, IDC_EDIT4, NULL, FALSE);
        hr = DmVertexShaderSnapshot(GetDlgItemInt(hwnd, IDC_EDIT1, NULL, FALSE), 
                                    GetDlgItemInt(hwnd, IDC_EDIT2, NULL, FALSE),
                                    g_dwFlags,
                                    g_dwMarker,
                                    buf);
        if(FAILED(hr)) 
        {
            if(hr == XBDM_FILEERROR)
                hr = HrLastError();
            MessageBox(NULL, (const char*)buf, "xbvscapture Error", MB_OK | MB_TASKMODAL);
        }
        else
        {
            SetDlgItemText(hwnd, IDC_StatusText, "Writing HTML Output");
            GetDlgItemText(hwnd, IDC_EDIT3, g_TmpPath, MAX_PATH);
            WriteOutputFiles(buf);
        }
        SetDlgItemText(hwnd, IDC_StatusText, "Ready to Capture");
        
        break;

    case IDC_DeleteTempButton:
        SetDlgItemText(hwnd, IDC_StatusText, "Deleting xbvscpta*.htm");
        DeleteFiles("xbvscpta*.htm");
        SetDlgItemText(hwnd, IDC_StatusText, "Deleting xbvscptb*.bmp");
        DeleteFiles("xbvscptb*.bmp");
        SetDlgItemText(hwnd, IDC_StatusText, "Ready to Capture");
        break;

    case IDC_CHECK1:
        if(IsDlgButtonChecked(hwnd, IDC_CHECK1) == BST_CHECKED)
        {
            // enable marker window
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), TRUE);
            g_dwFlags |= 0x1;  // set marker flag
        }
        else
        {
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), FALSE);
            g_dwFlags &= ~0x1;  // reset marker flag
        }
        break;
    }
}

BOOL CALLBACK Dlg_Proc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    HANDLE_MSG(hDlg, WM_COMMAND, Dlg_OnCommand);
    HANDLE_MSG(hDlg, WM_INITDIALOG, Dlg_OnInitDialog);
    case WM_HELP: printf("Help!\n"); break;
    default:
        return FALSE;
    }
    return TRUE;
}

int __cdecl main(int cArg, char **rgszArg)
{
    // if command line parameters, run silently
    if(cArg > 1)
    {
        DWORD dwX, dwY;
        HRESULT hr;
        
        dwX = atoi(rgszArg[1]);
        dwY = atoi(rgszArg[2]);
        hr = DmVertexShaderSnapshot(dwX, dwY, 0, 0, buf);
        
        if(FAILED(hr)) 
        {
            if(hr == XBDM_FILEERROR)
                hr = HrLastError();
            MessageBox(NULL, (const char*)buf, "xbvscapture Error", MB_OK | MB_TASKMODAL);
        }
        else
        {
            WriteOutputFiles(buf);
        }
        Sleep(5000);
        return 0;
    }
    
    // display the UI
    DialogBox(NULL, MAKEINTRESOURCE(IDD_VSCAPTURE), NULL, Dlg_Proc);
    return 0;
}


void GetVertexInputsAndOutputs(VTXREG *pInst, VTXIO *pInputs, VTXIO *pOutputs)
{
    // initialize
    pInputs->regs = pOutputs->regs = 0;           // no regs selected
    pInputs->outs = pOutputs->outs = 0;           // no outputs selected
    pInputs->cnst = pOutputs->cnst = 0xffffffff;  // invalid constant

    // decode instruction
    DWORD aws = (pInst->y >>  0) & 0x3;
    DWORD azs = (pInst->y >>  2) & 0x3;
    DWORD ays = (pInst->y >>  4) & 0x3;
    DWORD axs = (pInst->y >>  6) & 0x3;
    DWORD ane = (pInst->y >>  8) & 0x1;
    DWORD va =  (pInst->y >>  9) & 0xf;
    DWORD ca =  (pInst->y >> 13) & 0xff;
    DWORD mac = (pInst->y >> 21) & 0xf;
    DWORD ilu = (pInst->y >> 25) & 0x7;

    DWORD crr = (pInst->z <<  2) & 0xc;
    DWORD cws = (pInst->z >>  2) & 0x3;
    DWORD czs = (pInst->z >>  4) & 0x3;
    DWORD cys = (pInst->z >>  6) & 0x3;
    DWORD cxs = (pInst->z >>  8) & 0x3;
    DWORD cne = (pInst->z >> 10) & 0x1;
    DWORD bmx = (pInst->z >> 11) & 0x3;
    DWORD brr = (pInst->z >> 13) & 0xf;
    DWORD bws = (pInst->z >> 17) & 0x3;
    DWORD bzs = (pInst->z >> 19) & 0x3;
    DWORD bys = (pInst->z >> 21) & 0x3;
    DWORD bxs = (pInst->z >> 23) & 0x3;
    DWORD bne = (pInst->z >> 25) & 0x1;
    DWORD amx = (pInst->z >> 26) & 0x3;
    DWORD arr = (pInst->z >> 28) & 0xf;

    DWORD eos = (pInst->w >>  0) & 0x1;
    DWORD cin = (pInst->w >>  1) & 0x1;
    DWORD om =  (pInst->w >>  2) & 0x1;
    DWORD oc =  (pInst->w >>  3) & 0x1ff;
    DWORD owm = (pInst->w >> 12) & 0xf;
    DWORD swm = (pInst->w >> 16) & 0xf;
    DWORD rw =  (pInst->w >> 20) & 0xf;
    DWORD rwm = (pInst->w >> 24) & 0xf;
    DWORD cmx = (pInst->w >> 28) & 0x3;
    crr |= (pInst->w >> 30) & 0x3;

    // decode inputs
    if(mac != 0)
    {
        switch(amx)
        {
        case 1: pInputs->regs |= (1 << (16+arr)); break;   // temp register input
        case 2: pInputs->regs |= (1 << va); break;       // vab register input
        case 3: pInputs->cnst = ca;                      // constant
        }
    }
    if((mac != 0x1) &&  // MAC_MOV
       (mac != 0x3) &&  // MAC_ADD
       (mac != 0xd))    // MAC_ARL
    {
        switch(bmx)
        {
        case 1: pInputs->regs |= (1 << (16+brr)); break;   // temp register input
        case 2: pInputs->regs |= (1 << va); break;       // vab register input
        case 3: pInputs->cnst = ca;                      // constant
        }
    }
    if((mac == 0x3) ||  // MAC_ADD
       (mac == 0x4) ||  // MAC_MAD
       (ilu != 0))
    {
        switch(cmx)
        {
        case 1: pInputs->regs |= (1 << (16+crr)); break;   // temp register input
        case 2: pInputs->regs |= (1 << va); break;       // vab register input
        case 3: pInputs->cnst = ca;                      // constant
        }
    }

    // decode outputs
    if(rwm)
        pOutputs->regs |= (1 << (16+rw));              // temp register output
    
    if(owm)
    {
        if(oc & 0x100)
            pOutputs->outs |= (1 << (oc & 0xff));
        else
            pOutputs->cnst = oc;
    }
    if(swm)
    {
        if((mac != 0) && (ilu != 0))
            pOutputs->regs |= (1 << (16+1));               // add R1 output
        else
            pOutputs->regs |= (1 << (16+rw));              // temp register output
    }
}

FLOAT sprintval(char *buf, DWORD idxptr, DWORD swiz)
{
    BYTE idx = idxs[idxptr];
    sprintf(buf, "%g %g %g %g", *(FLOAT*)&(vals[idx].x), 
                                *(FLOAT*)&(vals[idx].y), 
                                *(FLOAT*)&(vals[idx].z), 
                                *(FLOAT*)&(vals[idx].w));
    switch(swiz)
    {
    case 0: return *(FLOAT*)&(vals[idx].x);
    case 1: return *(FLOAT*)&(vals[idx].y);
    case 2: return *(FLOAT*)&(vals[idx].z);
    case 3: return *(FLOAT*)&(vals[idx].w);
    }
    return 0;
}

void CountVertices(BYTE *buf, DWORD *min, DWORD *max)
{
    DWORD *ptr;

    *min = 0xffffffff;
    *max = 0;
    ptr = FindOpcode(VSS_VERTEX, buf);
    while(ptr)
    {
        if((*ptr & 0xff000000) == VSS_VERTEX)
        {
            if(*(ptr+1) > *max) *max = *(ptr+1);
            if(*(ptr+1) < *min) *min = *(ptr+1);
        }
        else if((*ptr & 0xff000000) == VSS_EOF)
            break;

        ptr = ptr + (*ptr & 0x00ffffff);
    }
}

void GenerateHTML(BYTE *buf, FILE *fp)
{
    DWORD *ptr, inputcnt, skip;
    int i, icnt;
    DWORD dwX, dwY, dwColor, dwDepth;
    VTXREG inst;
    DWORD ARLType=0, ARLCount, ARLSwizzle;
    FLOAT ARLVal, ARLRet;
    INT a0x, idx;
    DWORD *idxdwptr;
    INT idxcnt, valcnt, idxptr;
    DWORD minVert, maxVert;
    char vertstr[256];
    char valstr[256];
    DWORD idcnt=0;
    struct tm *newtime;
    time_t aclock;

    time( &aclock );                 /* Get time in seconds */
    newtime = localtime( &aclock );  /* Convert time to struct tm form*/

    // print html header
    fprintf(fp,
"<html>\n"
"<head>\n"
"<title>Vertex Shader Debugger</title>\n"
"<style>\n"
"<!--\n"
" p.Normal    {margin:0in;font-size:10.0pt;font-family:\"Courier New\";}\n"
" p.Bold      {margin:0in;font-size:10.0pt;font-family:\"Courier New\";font-weight:\"bold\"}\n"
" p.Tiny      {margin:0in;font-size:8.0pt;font-family:\"Arial\";}\n"
" p.Big       {margin:0in;font-size:14.0pt;font-family:\"Courier New\";}\n"
" td.Outcolor {background:#fff0e0;padding:0in 5.4pt 0in 5.4pt;}\n"
" td.Incolor  {background:#e0f0ff;padding:0in 5.4pt 0in 5.4pt;}\n"
" td.OReg     {background:#FFFFbb;padding:0in 5.4pt 0in 5.4pt;}\n"
" td.GreenReg {background:#d0ffd0;padding:0in 5.4pt 0in 5.4pt;}\n"
" td.TanReg   {background:#ffddaa;padding:0in 5.4pt 0in 5.4pt;} \n"
"-->\n"
"</style>\n"
"</head>\n"
"<body bgcolor=d0d0d0>\n"
"<p class=Big><B>Vertex Shader Debugger</B></p>\n"
"<SCRIPT type=\"text\\javascript\">\n"
"<!--\n"
"function change(a,b,vari)\n"
"{\n"
"  if (vari.innerHTML==a) vari.innerHTML = b;\n"
"  else vari.innerHTML = a;\n"
"}\n"
"// -->\n"
"</SCRIPT>\n"
"<p class=Normal>%s</p>\n"
"<img src=\"%s\">\n"
"<p class=Normal>&nbsp;</p>\n", asctime( newtime ), g_BMPFilename);
    
    if(g_dwFlags & 0x1)
    {
        fprintf(fp, "<p class=Bold>Vertices filtered by debug marker %d</p>\n", g_dwMarker);
    }
    
    ptr = FindOpcode(VSS_STATS, buf);
    if(ptr)
    {
        fprintf(fp,
"<table border=0 cellspacing=0 cellpadding=0>\n"
" <tr>\n"
"  <td><p class=Bold align=center>Scene Statistics</p></td>\n"
" </tr>\n"
" <tr>\n"
"  <td><p  align=right>Vertices using a shader:</p></td>\n"
"  <td><p  align=right>%d</p></td>\n"
" </tr>\n"
" <tr>\n"
"  <td><p  align=right>Vertices using the fixed pipeline:</p></td>\n"
"  <td><p  align=right>%d</p></td>\n"
" </tr>\n"
" <tr>\n"
"  <td><p  align=right>Total vertices in scene:</p></td>\n"
"  <td><p  align=right>%d</p></td>\n"
" </tr>\n"
"</table>\n"
"<p class=Bold>&nbsp;</p>\n", *(ptr+1), *(ptr+2), *(ptr+1)+*(ptr+2));
    }

    CountVertices(buf, &minVert, &maxVert);
    if(minVert != 0xffffffff)
        fprintf(fp, "<p class=Bold>Snapshot of shader vertices %d through %d</p>\n", minVert, maxVert);
    else
        fprintf(fp, "<p class=Bold>No Vertices Captured</p>\n");

    fprintf(fp, "<p class=Bold>&nbsp;</p>\n");

    char inregstr[10][64], outregstr[10][64], invalstr[10][64], outvalstr[10][64];
    DWORD incnt, outcnt;
    
    // Find the first vertex
    ptr = FindOpcode(VSS_PROGRAM, buf);
    if(!ptr) 
    {
        ptr = FindOpcode(VSS_EOF, buf);
    }
    else
    {
        fprintf(fp,
"<p class=tiny>Click on vertex to expand.  All values shown in XYZW order.</p>\n"
"<p> &nbsp;</p>\n");
    }
    
    while((*ptr & 0xff000000) != VSS_EOF)
    {
        switch(*ptr & 0xff000000)
        {
        case VSS_STATS:
            ptr += 3;       // skip stats info
            break;

        case VSS_VERTEX:
            ptr++;
            sprintf(vertstr, "Vertex %d", *ptr);
            ptr++;
            valcnt = (*ptr >> 16) & 0xffff;
            idxcnt = (*ptr & 0xffff);
            ptr++;
            for(i=0; i<valcnt; i++)
            {
                vals[i].x = *ptr++;
                vals[i].y = *ptr++;
                vals[i].z = *ptr++;
                vals[i].w = *ptr++;
            }
            idxdwptr = (DWORD *)idxs;
            for(i=0; i<idxcnt; i++)
                *idxdwptr++ = *ptr++;
            
            sprintf(valstr, "%g %g %g %g", *(FLOAT*)&(vals[0].x), 
                                           *(FLOAT*)&(vals[0].y), 
                                           *(FLOAT*)&(vals[0].z), 
                                           *(FLOAT*)&(vals[0].w));
            fprintf(fp, 
"<SPAN id=id%04d onmouseover=\"this.style.cursor='hand'\"" 
"onclick=\"change('<P class=Big><BUTTON>+</BUTTON><B>%s</B> (V0: %s)</P>',"
"'"
"<P class=Big><BUTTON>-</BUTTON><B>%s</B> (V0: %s)</P><TABLE bgcolor=#c0c0c0>", idcnt, vertstr, valstr, vertstr, valstr);

            idxptr = 0;
            for(icnt=0; icnt<g_ProgramLength; icnt++)
            {
                if(Program[icnt].inst.w & 0x2)    // (cin)
                  idx = a0x;
                else
                  idx = 0;
                
                fprintf(fp, "<TR><TD colspan=4><p class=Bold>%s</p></TD></TR>", Program[icnt].buf);
    
                UINT j;
                for(j=0; j<10; j++)
                {
                    strcpy(inregstr[j], "");
                    strcpy(outregstr[j], "");
                    strcpy(invalstr[j], "");
                    strcpy(outvalstr[j], "");
                }
                incnt = outcnt = 0;
                
                VTXIO inputs, outputs;
                GetVertexInputsAndOutputs(&(Program[icnt].inst), &inputs, &outputs);
                
                if(((Program[icnt].inst.y >> 21) & 0xf) == 0xd)  // is this an ARL instruction?
                {
                    ARLType = ((Program[icnt].inst.z >> 26) & 0x3);  // (amx)
                    ARLSwizzle = ((Program[icnt].inst.y >> 6) & 0x3); // (axs)
                    switch(ARLType)
                    {
                    case 1: // temp
                        ARLCount = ((Program[icnt].inst.z >> 28) & 0xf);  // (arr)
                        break;
                    case 2: // vab
                        ARLCount = ((Program[icnt].inst.y >> 9) & 0xf);   // (va)
                        break;
                    case 3: // const
                        ARLCount = ((Program[icnt].inst.y >> 13) & 0xff); // (ca)
                        break;
                    }
                }
                
                // Dump inputs
                // vab
                for(i=0; i<16; i++)
                {
                    if(inputs.regs & (1<<i))
                    {
                        sprintf(inregstr[incnt], "V%d:", i);
                        ARLRet = sprintval(invalstr[incnt++], idxptr++, ARLSwizzle);
                        if((ARLType == 2) && (ARLCount == (DWORD)i))
                            ARLVal = ARLRet;
                    }
                }
            
                // constant
                if(inputs.cnst != 0xffffffff)
                {
                    sprintf(inregstr[incnt], "C%d:", inputs.cnst-96+idx);
                    ARLRet = sprintval(invalstr[incnt++], idxptr++, ARLSwizzle);
                    if((ARLType == 3) && (ARLCount == inputs.cnst))
                        ARLVal = ARLRet;
                }
                
                // temp
                for(i=0; i<16; i++)
                {
                    if(inputs.regs & (1<<(i+16)))
                    {
                        sprintf(inregstr[incnt], "R%d:", i);
                        ARLRet = sprintval(invalstr[incnt++], idxptr++, ARLSwizzle);
                        if((ARLType == 1) && (ARLCount == (DWORD)i))
                            ARLVal = ARLRet;
                    }
                }
                
                // Dump outputs
                // Output Registers
                for(i=0; i<16; i++)
                {
                    if(outputs.outs & (1<<i))
                    {
                        sprintf(outregstr[outcnt], "%s:", kOutNames[i]);
                        ARLRet = sprintval(outvalstr[outcnt++], idxptr++, ARLSwizzle);
                    }
                }
            
                // constant
                if(outputs.cnst != 0xffffffff)
                {
                    sprintf(outregstr[outcnt], "C%d:", inputs.cnst-96);
                    ARLRet = sprintval(outvalstr[outcnt++], idxptr++, ARLSwizzle);
                }
                
                // temp
                for(i=0; i<16; i++)
                {
                    if(outputs.regs & (1<<(i+16)))
                    {
                        sprintf(outregstr[outcnt], "    R%d: ", i);
                        ARLRet = sprintval(outvalstr[outcnt++], idxptr++, ARLSwizzle);
                    }
                }
                
                // Update a0.x if necessary
                if(ARLType != 0)
                {
                    a0x = (INT)(*((FLOAT *)(&(ARLVal))));
                    if((Program[icnt].inst.y >> 8) & 0x1) // (ane)
                        a0x = -a0x;
                }

                // print inputs and outputs
                for(j=0; j<10; j++)
                {
                    if((j>=incnt) && (j>=outcnt)) break;
                    char *inclr, *outclr;
                    if(j>=incnt)
                        inclr = "";
                    else
                        inclr = "class = InColor";
                    if(j>=outcnt)
                        outclr = "";
                    else
                        outclr = "class = OutColor";
                    fprintf(fp,
"<TR>"
"<TD %s><P class=Normal>%s</P></TD>"
"<TD %s><P class=Normal>%s</P></TD>"
"<TD %s><P class=Normal>%s</P></TD>"
"<TD %s><P class=Normal>%s</P></TD>"
"</TR>", outclr, outregstr[j], outclr, outvalstr[j], inclr, inregstr[j], inclr, invalstr[j]);
                }
            }
            fprintf(fp,
"</TABLE>\\"
"<p class=Normal>&nbsp;</p>\\"
"   ',id%04d)\">"
"   <P class=Big><BUTTON>+</BUTTON><B>%s</B> (V0: %s)</P></SPAN>\n", idcnt++, vertstr, valstr);

            break;

        case VSS_PROGRAM:
            a0x = 0;
            DWORD packed[4];
            D3DVsInstruction VsInst;
            g_ProgramLength = ((*ptr++ & 0x00ffffff)-1)/3;
            for(i=0; i<g_ProgramLength; i++)
            {
                Program[i].inst.x = 0;
                Program[i].inst.y = *ptr++;
                Program[i].inst.z = *ptr++;
                Program[i].inst.w = *ptr++;
                packed[0] = 0;
                packed[1] = Program[i].inst.y;
                packed[2] = Program[i].inst.z;
                packed[3] = Program[i].inst.w;
                ConvertPackedDWordsToUCode(packed, &VsInst);
                DisassembleInstruction(&VsInst, Program[i].buf, 1024);
                char *cptr;
                cptr = Program[i].buf;
                while(*cptr != '\0')
                {
                    if((*cptr == 13) || (*cptr == 10))
                        *cptr = ' ';
                    cptr++;
                }

            }
            break;

        default:
            goto error;
        }
    }
    return;

error:
    fprintf(fp, "Error parsing snapshot data\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\ddk\inc\scsi.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    scsi.h

Abstract:

    These are the structures and defines that are used in the
    SCSI port and class drivers.

Authors:

Revision History:

--*/
#ifndef _NTSCSI_
#define _NTSCSI_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4200)

// begin_ntminitape

//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

#include <pshpack1.h>
typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC, *PCDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE, *PCDB6READWRITE;

    //
    // SCSI Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY, *PCDB6INQUIRY;

    struct _CDB6VERIFY {
        UCHAR OperationCode;
        UCHAR Fixed : 1;
        UCHAR ByteCompare : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR VerificationLength[3];
        UCHAR Control;
    } CDB6VERIFY, *PCDB6VERIFY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT, *PCDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        union {
            struct {
                UCHAR LogicalBlockByte0;
                UCHAR LogicalBlockByte1;
                UCHAR LogicalBlockByte2;
                UCHAR LogicalBlockByte3;
            };
            ULONG LogicalBlock;
        };
        UCHAR Reserved2;
        union {
            struct {
                UCHAR TransferBlocksMsb;
                UCHAR TransferBlocksLsb;
            };
            ULONG TransferBlocks;
        };
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // Standard 12-byte CDB
    //

    struct _CDB12 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];      // [0]=MSB, [3]=LSB
        UCHAR TransferLength[4];    // [0]=MSB, [3]=LSB
        UCHAR Reserved2;
        UCHAR Control;
    } CDB12, *PCDB12;

    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME, *PPAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Format2 : 4;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3[3];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC, *PREAD_TOC;

    struct _READ_DISK_INFORMATION {
        UCHAR OperationCode;    // 0x51
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_DISK_INFORMATION, *PREAD_DISK_INFORMATION;

    struct _READ_TRACK_INFORMATION {
        UCHAR OperationCode;    // 0x52
        UCHAR Track : 1;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2 : 1;
        UCHAR Lun : 3;
        UCHAR BlockAddress[4];  // or Track Number
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_TRACK_INFORMATION, *PREAD_TRACK_INFORMATION;

    struct _READ_HEADER {
        UCHAR OperationCode;    // 0x44
        UCHAR Reserved1 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved2 : 3;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_HEADER, *PREAD_HEADER;

    struct _PLAY_AUDIO {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingBlockAddress[4];
        UCHAR Reserved2;
        UCHAR PlayLength[2];
        UCHAR Control;
    } PLAY_AUDIO, *PPLAY_AUDIO;

    struct _PLAY_AUDIO_MSF {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF, *PPLAY_AUDIO_MSF;

    struct _PLAY_CD {
        UCHAR OperationCode;    // 0xBC
        UCHAR Reserved1 : 1;
        UCHAR CMSF : 1;         // LBA = 0, MSF = 1
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;

        union {
            struct _LBA {
                UCHAR StartingBlockAddress[4];
                UCHAR PlayLength[4];
            } LBA;

            struct _MSF {
                UCHAR Reserved1;
                UCHAR StartingM;
                UCHAR StartingS;
                UCHAR StartingF;
                UCHAR EndingM;
                UCHAR EndingS;
                UCHAR EndingF;
                UCHAR Reserved2;
            } MSF;
        };

        UCHAR Audio : 1;
        UCHAR Composite : 1;
        UCHAR Port1 : 1;
        UCHAR Port2 : 1;
        UCHAR Reserved2 : 3;
        UCHAR Speed : 1;
        UCHAR Control;
    } PLAY_CD, *PPLAY_CD;

    struct _SCAN_CD {
        UCHAR OperationCode;    // 0xBA
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 3;
        UCHAR Direct : 1;
        UCHAR Lun : 3;
        UCHAR StartingAddress[4];
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 6;
        UCHAR Type : 2;
        UCHAR Reserved4;
        UCHAR Control;
    } SCAN_CD, *PSCAN_CD;

    struct _STOP_PLAY_SCAN {
        UCHAR OperationCode;    // 0x4E
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } STOP_PLAY_SCAN, *PSTOP_PLAY_SCAN;

    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL, *PSUBCHANNEL;

    //
    // Read CD. Used by Atapi for raw sector reads.
    //

    struct _READ_CD {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved0 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR StartingLBA[4];
        UCHAR TransferBlocks[3];
        UCHAR Reserved2 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved3 : 5;
        UCHAR Control;
    } READ_CD, *PREAD_CD;

    struct _READ_CD_MSF {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved3;
        UCHAR Reserved4 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved5 : 5;
        UCHAR Control;
    } READ_CD_MSF, *PREAD_CD_MSF;

    //
    // Plextor Read CD-DA
    //

    struct _PLXTR_READ_CDDA {
        UCHAR OperationCode;
        UCHAR Reserved0 : 5;
        UCHAR LogicalUnitNumber :3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR TransferBlockByte2;
        UCHAR TransferBlockByte3;
        UCHAR SubCode;
        UCHAR Control;
    } PLXTR_READ_CDDA, *PPLXTR_READ_CDDA;

    //
    // NEC Read CD-DA
    //

    struct _NEC_READ_CDDA {
        UCHAR OperationCode;
        UCHAR Reserved0;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved1;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR Control;
    } NEC_READ_CDDA, *PNEC_READ_CDDA;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE, *PMODE_SENSE;

    struct _MODE_SENSE10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3[4];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } MODE_SENSE10, *PMODE_SENSE10;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT, *PMODE_SELECT;

    struct _MODE_SELECT10 {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[5];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } MODE_SELECT10, *PMODE_SELECT10;

    struct _LOCATE {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE, *PLOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];  // [0]=MSB, [1]=LSB
        UCHAR AllocationLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Control;
    } LOGSENSE, *PLOGSENSE;

    struct _LOGSELECT {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR PCRBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Control;
    } LOGSELECT, *PLOGSELECT;

    struct _PRINT {
        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT, *PPRINT;

    struct _SEEK {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK, *PSEEK;

    struct _ERASE {
        UCHAR OperationCode;
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE, *PERASE;

    struct _START_STOP {
        UCHAR OperationCode;
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP, *PSTART_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL, *PMEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK, *PSEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS, *PREQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION, *PPARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS, *PWRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS, *PSPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION, *PREAD_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
    } CDB6READWRITETAPE, *PCDB6READWRITETAPE;

    //
    // Medium changer CDB's
    //

    struct _INIT_ELEMENT_STATUS {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 7;
        UCHAR NoBarCode : 1;
    } INIT_ELEMENT_STATUS, *PINIT_ELEMENT_STATUS;

    struct _INITIALIZE_ELEMENT_RANGE {
        UCHAR OperationCode;
        UCHAR Range : 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR FirstElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved3;
        UCHAR Reserved4 : 7;
        UCHAR NoBarCode : 1;
    } INITIALIZE_ELEMENT_RANGE, *PINITIALIZE_ELEMENT_RANGE;

    struct _POSITION_TO_ELEMENT {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } POSITION_TO_ELEMENT, *PPOSITION_TO_ELEMENT;

    struct _MOVE_MEDIUM {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } MOVE_MEDIUM, *PMOVE_MEDIUM;

    struct _EXCHANGE_MEDIUM {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR Destination1ElementAddress[2];
        UCHAR Destination2ElementAddress[2];
        UCHAR Flip1 : 1;
        UCHAR Flip2 : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } EXCHANGE_MEDIUM, *PEXCHANGE_MEDIUM;

    struct _READ_ELEMENT_STATUS {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } READ_ELEMENT_STATUS, *PREAD_ELEMENT_STATUS;

    struct _SEND_VOLUME_TAG {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR Reserved1 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR Reserved2;
        UCHAR ActionCode : 5;
        UCHAR Reserved3 : 3;
        UCHAR Reserved4[2];
        UCHAR ParameterListLength[2];
        UCHAR Reserved5;
        UCHAR Control;
    } SEND_VOLUME_TAG, *PSEND_VOLUME_TAG;

    struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } REQUEST_VOLUME_ELEMENT_ADDRESS, *PREQUEST_VOLUME_ELEMENT_ADDRESS;

    //
    // Atapi 2.5 Changer 12-byte CDBs
    //

    struct _LOAD_UNLOAD {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3: 6;
        UCHAR Reserved4[3];
        UCHAR Slot;
        UCHAR Reserved5[3];
    } LOAD_UNLOAD, *PLOAD_UNLOAD;

    struct _MECH_STATUS {
        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[6];
        UCHAR AllocationLength[2];
        UCHAR Reserved2[1];
        UCHAR Control;
    } MECH_STATUS, *PMECH_STATUS;

    //
    // C/DVD 0.9 CDBs
    //

    struct _SYNCHRONIZE_CACHE10 {

        UCHAR OperationCode;    // 0x35

        UCHAR RelAddr : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 3;
        UCHAR Lun : 3;

        UCHAR LogicalBlockAddress[4];   // Unused - set to zero
        UCHAR Reserved2;
        UCHAR BlockCount[2];            // Unused - set to zero
        UCHAR Control;
    } SYNCHRONIZE_CACHE10, *PSYNCHRONIZE_CACHE10;

    struct _GET_EVENT_STATUS_NOTIFICATION {
        UCHAR OperationCode;    // 0x4a

        UCHAR Immediate : 1;
        UCHAR Reserved : 4;
        UCHAR Lun : 3;

        UCHAR Reserved2[2];
        UCHAR NotificationClassRequest;
        UCHAR Reserved3[2];
        UCHAR EventListLength[2];  // [0]=MSB, [1]=LSB

        UCHAR Control;
    } GET_EVENT_STATUS_NOTIFICATION, *PGET_EVENT_STATUS_NOTIFICATION;

    struct _READ_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xAD
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR RMDBlockNumber[4];
        UCHAR LayerNumber;
        UCHAR Format;
        UCHAR AllocationLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Reserved3 : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } READ_DVD_STRUCTURE, *PREAD_DVD_STRUCTURE;

    struct _SEND_KEY {
        UCHAR OperationCode;    // 0xA3
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[6];
        UCHAR ParameterListLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } SEND_KEY, *PSEND_KEY;

    struct _REPORT_KEY {
        UCHAR OperationCode;    // 0xA4
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];   // for title key
        UCHAR Reserved2[2];
        UCHAR AllocationLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } REPORT_KEY, *PREPORT_KEY;

    struct _SET_READ_AHEAD {
        UCHAR OperationCode;    // 0xA7
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR TriggerLBA[4];
        UCHAR ReadAheadLBA[4];
        UCHAR Reserved2;
        UCHAR Control;
    } SET_READ_AHEAD, *PSET_READ_AHEAD;

    struct _READ_FORMATTED_CAPACITIES {
        UCHAR OperationCode;    // 0xA7
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_FORMATTED_CAPACITIES, *PREAD_FORMATTED_CAPACITIES;

    //
    // SCSI-3
    //

    struct _REPORT_LUNS {
        UCHAR OperationCode;    // 0xA0
        UCHAR Reserved1[5];
        UCHAR AllocationLength[4];
        UCHAR Reserved2[1];
        UCHAR Control;
    } REPORT_LUNS, *PREPORT_LUNS;

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;
#include <poppack.h>

//
// C/DVD CDB Constants & Structures.
//

//
// GET_EVENT_STATUS_NOTIFICATION
//

#define NOTIFICATION_NO_CLASS_EVENTS                0x0
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_EVENTS  0x2
#define NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS      0x4
#define NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS       0x6

typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {

    UCHAR EventDataLength[2];   // [0]=MSB, [1]=LSB

    UCHAR NotificationClass : 3;
    UCHAR Reserved : 4;
    UCHAR NEA : 1;

    UCHAR SupportedEventClasses;
    UCHAR ClassEventData[0];
} NOTIFICATION_EVENT_STATUS_HEADER, *PNOTIFICATION_EVENT_STATUS_HEADER;

//
// Class event data may be one or more (or none) of the following:
//

#define NOTIFICATION_POWER_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_POWER_EVENT_CHANGE_SUCCEEDED   0x1
#define NOTIFICATION_POWER_EVENT_CHANGE_FAILED      0x2

#define NOTIFICATION_POWER_STATUS_ACTIVE            0x1
#define NOTIFICATION_POWER_STATUS_IDLE              0x2
#define NOTIFICATION_POWER_STATUS_STANDBY           0x3

typedef struct _NOTIFICATION_POWER_STATUS {
    UCHAR PowerEvent : 4;
    UCHAR Reserved : 4;
    UCHAR PowerStatus;
    UCHAR Reserved2[2];
} NOTIFICATION_POWER_STATUS, *PNOTIFICATION_POWER_STATUS;


#define NOTIFICATION_MEDIA_EVENT_NO_EVENT           0x0
#define NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST      0x1
#define NOTIFICATION_MEDIA_EVENT_NEW_MEDIA          0x2
#define NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL      0x3

typedef struct _NOTIFICATION_MEDIA_STATUS {
    UCHAR MediaStatus : 4;
    UCHAR Reserved : 4;

    UCHAR PowerStatus;
    UCHAR StartSlot;
    UCHAR EndSlot;
} NOTIFICATION_MEDIA_STATUS, *PNOTIFICATION_MEDIA_STATUS;


#define NOTIFICATION_BUSY_EVENT_NO_EVENT            0x0
#define NOTIFICATION_BUSY_EVENT_BUSY                0x1

#define NOTIFICATION_BUSY_STATUS_NO_EVENT           0x0
#define NOTIFICATION_BUSY_STATUS_POWER              0x1
#define NOTIFICATION_BUSY_STATUS_IMMEDIATE          0x2
#define NOTIFICATION_BUSY_STATUS_DEFERRED           0x3

typedef struct _NOTIFICATION_BUSY_STATUS {
    UCHAR DeviceBusyEvent : 4;
    UCHAR Reserved : 4;

    UCHAR DeviceBusyStatus;
    UCHAR Time[2];     // [0]=MSB, [1]=LSB
} NOTIFICATION_BUSY_STATUS, *PNOTIFICATION_BUSY_STATUS;

//
// Read DVD Structure Definitions and Constants
//

#define DVD_FORMAT_LEAD_IN          0x00
#define DVD_FORMAT_COPYRIGHT        0x01
#define DVD_FORMAT_DISK_KEY         0x02
#define DVD_FORMAT_BCA              0x03
#define DVD_FORMAT_MANUFACTURING    0x04

typedef struct _READ_DVD_STRUCTURES_HEADER {
    UCHAR Length[2];
    UCHAR Reserved[2];

    UCHAR Data[0];
} READ_DVD_STRUCTURES_HEADER, *PREAD_DVD_STRUCTURES_HEADER;

//
// DiskKey, BCA & Manufacturer information will provide byte arrays as their
// data.
//

//
// CDVD 0.9 Send & Report Key Definitions and Structures
//

#define DVD_REPORT_AGID            0x00
#define DVD_CHALLENGE_KEY          0x01
#define DVD_KEY_1                  0x02
#define DVD_KEY_2                  0x03
#define DVD_TITLE_KEY              0x04
#define DVD_REPORT_ASF             0x05
#define DVD_INVALIDATE_AGID        0x3F

typedef struct _CDVD_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
    UCHAR Data[0];
} CDVD_KEY_HEADER, *PCDVD_KEY_HEADER;

typedef struct _CDVD_REPORT_AGID_DATA {
    UCHAR Reserved1[3];
    UCHAR Reserved2 : 6;
    UCHAR AGID : 2;
} CDVD_REPORT_AGID_DATA, *PCDVD_REPORT_AGID_DATA;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
    UCHAR ChallengeKeyValue[10];
    UCHAR Reserved[2];
} CDVD_CHALLENGE_KEY_DATA, *PCDVD_CHALLENGE_KEY_DATA;

typedef struct _CDVD_KEY_DATA {
    UCHAR Key[5];
    UCHAR Reserved[3];
} CDVD_KEY_DATA, *PCDVD_KEY_DATA;

typedef struct _CDVD_REPORT_ASF_DATA {
    UCHAR Reserved1[3];
    UCHAR Success : 1;
    UCHAR Reserved2 : 7;
} CDVD_REPORT_ASF_DATA, *PCDVD_REPORT_ASF_DATA;

typedef struct _CDVD_TITLE_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved1[1];
    UCHAR Reserved2 : 3;
    UCHAR CGMS : 2;
    UCHAR CP_SEC : 1;
    UCHAR CPM : 1;
    UCHAR Zero : 1;
    CDVD_KEY_DATA TitleKey;
} CDVD_TITLE_KEY_HEADER, *PCDVD_TITLE_KEY_HEADER;

//
// Read Formatted Capacity Data - returned in Big Endian Format
//

typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
    UCHAR NumberOfBlocks[4];
    UCHAR Maximum : 1;
    UCHAR Valid : 1;
    UCHAR BlockLength[3];
} FORMATTED_CAPACITY_DESCRIPTOR, *PFORMATTED_CAPACITY_DESCRIPTOR;

typedef struct _FORMATTED_CAPACITY_LIST {
    UCHAR Reserved[3];
    UCHAR CapacityListLength;
    FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0];
} FORMATTED_CAPACITY_LIST, *PFORMATTED_CAPACITY_LIST;

//
// PLAY_CD definitions and constants
//

#define CD_EXPECTED_SECTOR_ANY          0x0
#define CD_EXPECTED_SECTOR_CDDA         0x1
#define CD_EXPECTED_SECTOR_MODE1        0x2
#define CD_EXPECTED_SECTOR_MODE2        0x3
#define CD_EXPECTED_SECTOR_MODE2_FORM1  0x4
#define CD_EXPECTED_SECTOR_MODE2_FORM2  0x5

//
// Read Disk Information Definitions and Capabilities
//

#define DISK_STATUS_EMPTY       0x00
#define DISK_STATUS_INCOMPLETE  0x01
#define DISK_STATUS_COMPLETE    0x02

#define LAST_SESSION_EMPTY      0x00
#define LAST_SESSION_INCOMPLETE 0x01
#define LAST_SESSION_COMPLETE   0x03

#define DISK_TYPE_CDDA          0x01
#define DISK_TYPE_CDI           0x10
#define DISK_TYPE_XA            0x20
#define DISK_TYPE_UNDEFINED     0xFF

typedef struct _OPC_TABLE_ENTRY {
    UCHAR Speed[2];
    UCHAR OPCValue[6];
} OPC_TABLE_ENTRY, *POPC_TABLE_ENTRY;

typedef struct _DISK_INFORMATION {
    UCHAR Length[2];

    UCHAR DiskStatus : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable : 1;
    UCHAR Reserved1 : 3;

    UCHAR FirstTrackNumber;
    UCHAR NumberOfSessions;
    UCHAR LastSessionFirstTrack;
    UCHAR LastSessionLastTrack;

    UCHAR Reserved2 : 5;
    UCHAR GEN : 1;
    UCHAR DBC_V : 1;
    UCHAR DID_V : 1;

    UCHAR DiskType;
    UCHAR Reserved3[3];

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // MSF
    UCHAR LastPossibleStartTime[4]; // MSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
    OPC_TABLE_ENTRY OPCTable[0];
} DISK_INFORMATION, *PDISK_INFORMATION;

//
// Read Header definitions and structures
//

typedef struct _DATA_BLOCK_HEADER {
    UCHAR DataMode;
    UCHAR Reserved[4];
    union {
        UCHAR LogicalBlockAddress[4];
        struct {
            UCHAR Reserved;
            UCHAR M;
            UCHAR S;
            UCHAR F;
        } MSF;
    };
} DATA_BLOCK_HEADER, *PDATA_BLOCK_HEADER;

#define DATA_BLOCK_MODE0    0x0
#define DATA_BLOCK_MODE1    0x1
#define DATA_BLOCK_MODE2    0x2

//
// Read TOC Format Codes
//

#define READ_TOC_FORMAT_TOC         0x00
#define READ_TOC_FORMAT_SESSION     0x01
#define READ_TOC_FORMAT_FULL_TOC    0x02
#define READ_TOC_FORMAT_PMA         0x03
#define READ_TOC_FORMAT_ATIP        0x04

typedef struct _TRACK_INFORMATION {
    UCHAR Length[2];
    UCHAR TrackNumber;
    UCHAR SessionNumber;
    UCHAR Reserved1;
    UCHAR TrackMode : 4;
    UCHAR Copy : 1;
    UCHAR Damage : 1;
    UCHAR Reserved2 : 2;
    UCHAR DataMode : 4;
    UCHAR FP : 1;
    UCHAR Packet : 1;
    UCHAR Blank : 1;
    UCHAR RT : 1;
    UCHAR NWA_V : 1;
    UCHAR Reserved3 : 7;
    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4];
} TRACK_INFORMATION, *PTRACK_INFORMATION;



//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SETBITON                             1
#define SETBITOFF                            0

//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_PAGE_CD_AUDIO_CONTROL      0x0E
#define MODE_PAGE_DATA_COMPRESS         0x0F
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_CDVD_FEATURE_SET      0x18
#define MODE_PAGE_POWER_CONDITION       0x1A
#define MODE_PAGE_FAULT_REPORTING       0x1C
#define MODE_PAGE_CDVD_INACTIVITY       0x1D
#define MODE_PAGE_ELEMENT_ADDRESS       0x1D
#define MODE_PAGE_TRANSPORT_GEOMETRY    0x1E
#define MODE_PAGE_DEVICE_CAPABILITIES   0x1F
#define MODE_PAGE_CAPABILITIES          0x2A

#define MODE_SENSE_RETURN_ALL           0x3f

#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0


//
// SCSI CDB operation codes
//

#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_INIT_ELEMENT_STATUS 0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17

#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E
#define SCSIOP_READ_FORMATTED_CAPACITY 0x23
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_POSITION_TO_ELEMENT 0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D
#define SCSIOP_STOP_PLAY_SCAN      0x4E
#define SCSIOP_READ_DISK_INFORMATION 0x51
#define SCSIOP_READ_TRACK_INFORMATION 0x52
#define SCSIOP_MODE_SELECT10       0x55
#define SCSIOP_MODE_SENSE10        0x5A
#define SCSIOP_REPORT_LUNS         0xA0
#define SCSIOP_SEND_KEY            0xA3
#define SCSIOP_REPORT_KEY          0xA4
#define SCSIOP_MOVE_MEDIUM         0xA5
#define SCSIOP_LOAD_UNLOAD_SLOT    0xA6
#define SCSIOP_EXCHANGE_MEDIUM     0xA6
#define SCSIOP_SET_READ_AHEAD      0xA7
#define SCSIOP_READ_DVD_STRUCTURE  0xAD
#define SCSIOP_REQUEST_VOL_ELEMENT 0xB5
#define SCSIOP_SEND_VOLUME_TAG     0xB6
#define SCSIOP_READ_ELEMENT_STATUS 0xB8
#define SCSIOP_READ_CD_MSF         0xB9
#define SCSIOP_SCAN_CD             0xBA
#define SCSIOP_PLAY_CD             0xBC
#define SCSIOP_MECHANISM_STATUS    0xBD
#define SCSIOP_READ_CD             0xBE
#define SCSIOP_INIT_ELEMENT_RANGE  0xE7

//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1

// end_ntminitape

//
// CDB Force media access used in extended read and write commands.
//

#define CDB_FORCE_MEDIA_ACCESS 0x08

//
// Denon CD ROM operation codes
//

#define SCSIOP_DENON_EJECT_DISC    0xE6
#define SCSIOP_DENON_STOP_AUDIO    0xE7
#define SCSIOP_DENON_PLAY_AUDIO    0xE8
#define SCSIOP_DENON_READ_TOC      0xE9
#define SCSIOP_DENON_READ_SUBCODE  0xEB

//
// SCSI Bus Messages
//

#define SCSIMESS_ABORT                0x06
#define SCSIMESS_ABORT_WITH_TAG       0x0D
#define SCSIMESS_BUS_DEVICE_RESET     0X0C
#define SCSIMESS_CLEAR_QUEUE          0X0E
#define SCSIMESS_COMMAND_COMPLETE     0X00
#define SCSIMESS_DISCONNECT           0X04
#define SCSIMESS_EXTENDED_MESSAGE     0X01
#define SCSIMESS_IDENTIFY             0X80
#define SCSIMESS_IDENTIFY_WITH_DISCON 0XC0
#define SCSIMESS_IGNORE_WIDE_RESIDUE  0X23
#define SCSIMESS_INITIATE_RECOVERY    0X0F
#define SCSIMESS_INIT_DETECTED_ERROR  0X05
#define SCSIMESS_LINK_CMD_COMP        0X0A
#define SCSIMESS_LINK_CMD_COMP_W_FLAG 0X0B
#define SCSIMESS_MESS_PARITY_ERROR    0X09
#define SCSIMESS_MESSAGE_REJECT       0X07
#define SCSIMESS_NO_OPERATION         0X08
#define SCSIMESS_HEAD_OF_QUEUE_TAG    0X21
#define SCSIMESS_ORDERED_QUEUE_TAG    0X22
#define SCSIMESS_SIMPLE_QUEUE_TAG     0X20
#define SCSIMESS_RELEASE_RECOVERY     0X10
#define SCSIMESS_RESTORE_POINTERS     0X03
#define SCSIMESS_SAVE_DATA_POINTER    0X02
#define SCSIMESS_TERMINATE_IO_PROCESS 0X11

//
// SCSI Extended Message operation codes
//

#define SCSIMESS_MODIFY_DATA_POINTER  0X00
#define SCSIMESS_SYNCHRONOUS_DATA_REQ 0X01
#define SCSIMESS_WIDE_DATA_REQUEST    0X03

//
// SCSI Extended Message Lengths
//

#define SCSIMESS_MODIFY_DATA_LENGTH   5
#define SCSIMESS_SYNCH_DATA_LENGTH    3
#define SCSIMESS_WIDE_DATA_LENGTH     2

//
// SCSI extended message structure
//

#pragma pack (1)
typedef struct _SCSI_EXTENDED_MESSAGE {
    UCHAR InitialMessageCode;
    UCHAR MessageLength;
    UCHAR MessageType;
    union _EXTENDED_ARGUMENTS {

        struct {
            UCHAR Modifier[4];
        } Modify;

        struct {
            UCHAR TransferPeriod;
            UCHAR ReqAckOffset;
        } Synchronous;

        struct{
            UCHAR Width;
        } Wide;
    }ExtendedArguments;
}SCSI_EXTENDED_MESSAGE, *PSCSI_EXTENDED_MESSAGE;
#pragma pack ()

//
// SCSI bus status codes.
//

#define SCSISTAT_GOOD                  0x00
#define SCSISTAT_CHECK_CONDITION       0x02
#define SCSISTAT_CONDITION_MET         0x04
#define SCSISTAT_BUSY                  0x08
#define SCSISTAT_INTERMEDIATE          0x10
#define SCSISTAT_INTERMEDIATE_COND_MET 0x14
#define SCSISTAT_RESERVATION_CONFLICT  0x18
#define SCSISTAT_COMMAND_TERMINATED    0x22
#define SCSISTAT_QUEUE_FULL            0x28

//
// Enable Vital Product Data Flag (EVPD)
// used with INQUIRY command.
//

#define CDB_INQUIRY_EVPD           0x01

//
// Defines for format CDB
//

#define LUN0_FORMAT_SAVING_DEFECT_LIST 0
#define USE_DEFAULTMSB  0
#define USE_DEFAULTLSB  0

#define START_UNIT_CODE 0x01
#define STOP_UNIT_CODE  0x00

// begin_ntminitape

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR ReservedBit : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

#define DEVICE_QUALIFIER_ACTIVE         0x00
#define DEVICE_QUALIFIER_NOT_ACTIVE     0x01
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Sense Data Format
//

typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE       0x00
#define SCSI_ADSENSE_LUN_NOT_READY  0x04

#define SCSI_ADSENSE_TRACK_ERROR    0x14
#define SCSI_ADSENSE_SEEK_ERROR     0x15
#define SCSI_ADSENSE_REC_DATA_NOECC 0x17
#define SCSI_ADSENSE_REC_DATA_ECC   0x18

#define SCSI_ADSENSE_ILLEGAL_COMMAND 0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK  0x21
#define SCSI_ADSENSE_INVALID_CDB    0x24
#define SCSI_ADSENSE_INVALID_LUN    0x25
#define SCSI_ADWRITE_PROTECT        0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED 0x28
#define SCSI_ADSENSE_BUS_RESET      0x29

#define SCSI_ADSENSE_INVALID_MEDIA  0x30
#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE 0x3a
#define SCSI_ADSENSE_POSITION_ERROR 0x3b

// the second is for legacy apps.
#define SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED 0x5d
#define SCSI_FAILURE_PREDICTION_THRESHOLD_EXCEEDED SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED

#define SCSI_ADSENSE_COPY_PROTECTION_FAILURE 0x6f

#define SCSI_ADSENSE_VENDOR_UNIQUE  0x80

#define SCSI_ADSENSE_MUSIC_AREA     0xA0
#define SCSI_ADSENSE_DATA_AREA      0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW 0xA7

//
// SCSI_ADSENSE_LUN_NOT_READY (0x04) qualifiers
//

#define SCSI_SENSEQ_CAUSE_NOT_REPORTABLE         0x00
#define SCSI_SENSEQ_BECOMING_READY               0x01
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED        0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_FORMAT_IN_PROGRESS           0x04
#define SCSI_SENSEQ_OPERATION_IN_PROGRESS        0x07

//
// SCSI_ADSENSE_NO_SENSE (0x00) qualifiers
//

#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI_ADSENSE_ILLEGAL_BLOCK (0x21) qualifiers
//

#define SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR 0x01

//
// SCSI_ADSENSE_POSITION_ERROR (0x3b) qualifiers
//

#define SCSI_SENSEQ_DESTINATION_FULL 0x0d
#define SCSI_SENSEQ_SOURCE_EMPTY     0x0e

// end_ntminitape

//
// SCSI_ADSENSE_INVALID_MEDIA (0x30) qualifiers
//

#define SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED 0x00
#define SCSI_SENSEQ_UNKNOWN_FORMAT 0x01
#define SCSI_SENSEQ_INCOMPATIBLE_FORMAT 0x02

//
// SCSI_ADSENSE_COPY_PROTECTION_FAILURE (0x6f) qualifiers
//
#define SCSI_SENSEQ_AUTHENTICATION_FAILURE                          0x00
#define SCSI_SENSEQ_KEY_NOT_PRESENT                                 0x01
#define SCSI_SENSEQ_KEY_NOT_ESTABLISHED                             0x02
#define SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION 0x03
#define SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT           0x04
#define SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR                  0x05


//
// SCSI IO Device Control Codes
//

#define FILE_DEVICE_SCSI 0x0000001b

#define IOCTL_SCSI_EXECUTE_IN   ((FILE_DEVICE_SCSI << 16) + 0x0011)
#define IOCTL_SCSI_EXECUTE_OUT  ((FILE_DEVICE_SCSI << 16) + 0x0012)
#define IOCTL_SCSI_EXECUTE_NONE ((FILE_DEVICE_SCSI << 16) + 0x0013)

//
// SMART support in atapi
//

#define IOCTL_SCSI_MINIPORT_SMART_VERSION           ((FILE_DEVICE_SCSI << 16) + 0x0500)
#define IOCTL_SCSI_MINIPORT_IDENTIFY                ((FILE_DEVICE_SCSI << 16) + 0x0501)
#define IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS      ((FILE_DEVICE_SCSI << 16) + 0x0502)
#define IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS   ((FILE_DEVICE_SCSI << 16) + 0x0503)
#define IOCTL_SCSI_MINIPORT_ENABLE_SMART            ((FILE_DEVICE_SCSI << 16) + 0x0504)
#define IOCTL_SCSI_MINIPORT_DISABLE_SMART           ((FILE_DEVICE_SCSI << 16) + 0x0505)
#define IOCTL_SCSI_MINIPORT_RETURN_STATUS           ((FILE_DEVICE_SCSI << 16) + 0x0506)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE ((FILE_DEVICE_SCSI << 16) + 0x0507)
#define IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES   ((FILE_DEVICE_SCSI << 16) + 0x0508)
#define IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS   ((FILE_DEVICE_SCSI << 16) + 0x0509)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE ((FILE_DEVICE_SCSI << 16) + 0x050a)

//
// CLUSTER support
// deliberately skipped some values to allow for expansion above.
//
#define IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE     ((FILE_DEVICE_SCSI << 16) + 0x0520)
#define IOCTL_SCSI_MINIPORT_NOT_CLUSTER_CAPABLE    ((FILE_DEVICE_SCSI << 16) + 0x0521)


// begin_ntminitape

//
// Read Capacity Data - returned in Big Endian format
//

typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;

//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;


//
// Mode data structures.
//

//
// Define Mode parameter header.
//

typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

typedef struct _MODE_PARAMETER_HEADER10 {
    UCHAR ModeDataLength[2];
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR Reserved[2];
    UCHAR BlockDescriptorLength[2];
}MODE_PARAMETER_HEADER10, *PMODE_PARAMETER_HEADER10;

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;

//
// Define Disconnect-Reconnect page.
//

typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;

//
// Define mode caching page.
//

typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefetch[2];
    UCHAR MaximumPrefetch[2];
    UCHAR MaximumPrefetchCeiling[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;

//
// Define mode flexible disk page.
//

typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
}MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;

//
// Define mode format page.
//

typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternateSectorsPerZone[2];
    UCHAR AlternateTracksPerZone[2];
    UCHAR AlternateTracksPerLogicalUnit[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[3];
}MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;

//
// Define rigid disk driver geometry page.
//

typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[3];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[3];
    UCHAR StartReducedCurrent[3];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[3];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;

//
// Define read write recovery page
//

typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR ARRE : 1;
    UCHAR AWRE : 1;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;

//
// Define read recovery page - cdrom
//

typedef struct _MODE_READ_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];

} MODE_READ_RECOVERY_PAGE, *PMODE_READ_RECOVERY_PAGE;


//
// Define Informational Exception Control Page. Used for failure prediction
//

typedef struct _MODE_INFO_EXCEPTIONS
{
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    UCHAR LogErr : 1;
    UCHAR Reserved2 : 1;
    UCHAR Test : 1;
    UCHAR Dexcpt : 1;
    UCHAR Reserved3 : 3;
    UCHAR Perf : 1;

    UCHAR ReportMethod : 4;
    UCHAR Reserved4 : 4;

    UCHAR IntervalTimer[4];       // [0]=MSB, [3]=LSB
    UCHAR ReportCount[4];         // [0]=MSB, [3]=LSB

} MODE_INFO_EXCEPTIONS, *PMODE_INFO_EXCEPTIONS;

//
// Begin C/DVD 0.9 definitions
//

//
// Power Condition Mode Page Format
//

typedef struct _POWER_CONDITION_PAGE {
    UCHAR PageCode : 6;         // 0x1A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;           // 0x0A
    UCHAR Reserved2;

    UCHAR Standby : 1;
    UCHAR Idle : 1;
    UCHAR Reserved3 : 6;

    UCHAR IdleTimer[4];         // [0]=MSB, [3]=LSB
    UCHAR StandbyTimer[4];      // [0]=MSB, [3]=LSB
} POWER_CONDITION_PAGE, *PPOWER_CONDITION_PAGE;

//
// CD-Audio Control Mode Page Format
//

typedef struct _CDDA_OUTPUT_PORT {
    UCHAR ChannelSelection : 4;
    UCHAR Reserved : 4;
    UCHAR Volume;
} CDDA_OUTPUT_PORT, *PCDDA_OUTPUT_PORT;


typedef struct _CDAUDIO_CONTROL_PAGE {
    UCHAR PageCode : 6;     // 0x0E
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x0E

    UCHAR Reserved2 : 1;
    UCHAR StopOnTrackCrossing : 1;         // Default 0
    UCHAR Immediate : 1;    // Always 1
    UCHAR Reserved3 : 5;

    UCHAR Reserved4[3];
    UCHAR Obsolete[2];

    CDDA_OUTPUT_PORT CDDAOutputPorts[4];

} CDAUDIO_CONTROL_PAGE, *PCDAUDIO_CONTROL_PAGE;

#define CDDA_CHANNEL_MUTED      0x0
#define CDDA_CHANNEL_ZERO       0x1
#define CDDA_CHANNEL_ONE        0x2
#define CDDA_CHANNEL_TWO        0x4
#define CDDA_CHANNEL_THREE      0x8

//
// C/DVD Feature Set Support & Version Page
//

typedef struct _CDVD_FEATURE_SET_PAGE {
    UCHAR PageCode : 6;     // 0x18
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x16

    UCHAR CDAudio[2];       // [0]=MSB, [1]=LSB
    UCHAR EmbeddedChanger[2];
    UCHAR PacketSMART[2];
    UCHAR PersistantPrevent[2];
    UCHAR EventStatusNotification[2];
    UCHAR DigitalOutput[2];
    UCHAR CDSequentialRecordable[2];
    UCHAR DVDSequentialRecordable[2];
    UCHAR RandomRecordable[2];
    UCHAR KeyExchange[2];
    UCHAR Reserved2[2];
} CDVD_FEATURE_SET_PAGE, *PCDVD_FEATURE_SET_PAGE;

//
// CDVD Inactivity Time-out Page Format
//

typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
    UCHAR PageCode : 6;     // 0x1D
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x08
    UCHAR Reserved2[2];

    UCHAR SWPP : 1;
    UCHAR DISP : 1;
    UCHAR Reserved3 : 6;

    UCHAR Reserved4;
    UCHAR GroupOneMinimumTimeout[2];
    UCHAR GroupTwoMinimumTimeout[2];
} CDVD_INACTIVITY_TIMEOUT_PAGE, *PCDVD_INACTIVITY_TIMEOUT_PAGE;

//
// CDVD Capabilities & Mechanism Status Page
//

#define CDVD_LMT_CADDY              0
#define CDVD_LMT_TRAY               1
#define CDVD_LMT_POPUP              2
#define CDVD_LMT_RESERVED1          3
#define CDVD_LMT_CHANGER_INDIVIDUAL 4
#define CDVD_LMT_CHANGER_CARTRIDGE  5
#define CDVD_LMT_RESERVED2          6
#define CDVD_LMT_RESERVED3          7


typedef struct _CDVD_CAPABILITIES_PAGE {
    UCHAR PageCode : 6;     // 0x2A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;                        // offset 0

    UCHAR PageLength;       // 0x18         // offset 1

    UCHAR CDRRead : 1;
    UCHAR CDERead : 1;
    UCHAR Method2 : 1;
    UCHAR DVDROMRead : 1;
    UCHAR DVDRRead : 1;
    UCHAR DVDRAMRead : 1;
    UCHAR Reserved2 : 2;                    // offset 2

    UCHAR CDRWrite : 1;
    UCHAR CDEWrite : 1;
    UCHAR TestWrite : 1;
    UCHAR Reserved3 : 1;
    UCHAR DVDRWrite : 1;
    UCHAR DVDRAMWrite : 1;
    UCHAR Reserved4 : 2;                    // offset 3

    UCHAR AudioPlay : 1;
    UCHAR Composite : 1;
    UCHAR DigitalPortOne : 1;
    UCHAR DigitalPortTwo : 1;
    UCHAR Mode2Form1 : 1;
    UCHAR Mode2Form2 : 1;
    UCHAR MultiSession : 1;
    UCHAR Reserved5 : 1;                    // offset 4

    UCHAR CDDA : 1;
    UCHAR CDDAAccurate : 1;
    UCHAR RWSupported : 1;
    UCHAR RWDeinterleaved : 1;
    UCHAR C2Pointers : 1;
    UCHAR ISRC : 1;
    UCHAR UPC : 1;
    UCHAR ReadBarCodeCapable : 1;           // offset 5

    UCHAR Lock : 1;
    UCHAR LockState : 1;
    UCHAR PreventJumper : 1;
    UCHAR Eject : 1;
    UCHAR Reserved6 : 1;
    UCHAR LoadingMechanismType : 3;         // offset 6

    UCHAR SeparateVolume : 1;
    UCHAR SeperateChannelMute : 1;
    UCHAR SupportsDiskPresent : 1;
    UCHAR SWSlotSelection : 1;
    UCHAR SideChangeCapable : 1;
    UCHAR RWInLeadInReadable : 1;
    UCHAR Reserved7 : 2;                    // offset 7

    UCHAR ObsoleteReserved[2];              // offset 8
    UCHAR NumberVolumeLevels[2];            // offset 10
    UCHAR BufferSize[2];                    // offset 12
    UCHAR ObsoleteReserved2[2];             // offset 14
    UCHAR ObsoleteReserved3;                // offset 16

    UCHAR Reserved8 : 1;
    UCHAR BCK : 1;
    UCHAR RCK : 1;
    UCHAR LSBF : 1;
    UCHAR Length : 2;
    UCHAR Reserved9 : 2;                    // offset 17

    UCHAR ObsoleteReserved4[2];             // offset 18
    UCHAR CopyManagementRevision[2];        // offset 20
    UCHAR Reserved10[2];                    // offset 22
} CDVD_CAPABILITIES_PAGE, *PCDVD_CAPABILITIES_PAGE;


typedef struct _LUN_LIST {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
    UCHAR Lun[0][8];        // 4 level of addressing.  2 bytes each.
} LUN_LIST, *PLUN_LIST;


#define LOADING_MECHANISM_CADDY                 0x00
#define LOADING_MECHANISM_TRAY                  0x01
#define LOADING_MECHANISM_POPUP                 0x02
#define LOADING_MECHANISM_INDIVIDUAL_CHANGER    0x04
#define LOADING_MECHANISM_CARTRIDGE_CHANGER     0x05

//
// end C/DVD 0.9 mode page definitions

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8
#define MODE_HEADER_LENGTH                   4
#define MODE_HEADER_LENGTH10                 8

typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;

// end_ntminitape

//
// CDROM audio control (0x0E)
//

#define CDB_AUDIO_PAUSE 0
#define CDB_AUDIO_RESUME 1

#define CDB_DEVICE_START 0x11
#define CDB_DEVICE_STOP 0x10

#define CDB_EJECT_MEDIA 0x10
#define CDB_LOAD_MEDIA 0x01

#define CDB_SUBCHANNEL_HEADER      0x00
#define CDB_SUBCHANNEL_BLOCK       0x01

#define CDROM_AUDIO_CONTROL_PAGE   0x0E
#define MODE_SELECT_IMMEDIATE      0x04
#define MODE_SELECT_PFBIT          0x10

#define CDB_USE_MSF                0x01

typedef struct _PORT_OUTPUT {
    UCHAR ChannelSelection;
    UCHAR Volume;
} PORT_OUTPUT, *PPORT_OUTPUT;

typedef struct _AUDIO_OUTPUT {
    UCHAR CodePage;
    UCHAR ParameterLength;
    UCHAR Immediate;
    UCHAR Reserved[2];
    UCHAR LbaFormat;
    UCHAR LogicalBlocksPerSecond[2];
    PORT_OUTPUT PortOutput[4];
} AUDIO_OUTPUT, *PAUDIO_OUTPUT;

//
// Multisession CDROM
//

#define GET_LAST_SESSION 0x01
#define GET_SESSION_DATA 0x02;

//
// Atapi 2.5 changer
//

typedef struct _MECHANICAL_STATUS_INFORMATION_HEADER {
    UCHAR CurrentSlot : 5;
    UCHAR ChangerState : 2;
    UCHAR Fault : 1;
    UCHAR Reserved : 5;
    UCHAR MechanismState : 3;
    UCHAR CurrentLogicalBlockAddress[3];
    UCHAR NumberAvailableSlots;
    UCHAR SlotTableLength[2];
} MECHANICAL_STATUS_INFORMATION_HEADER, *PMECHANICAL_STATUS_INFORMATION_HEADER;

typedef struct _SLOT_TABLE_INFORMATION {
    UCHAR DiscChanged : 1;
    UCHAR Reserved : 6;
    UCHAR DiscPresent : 1;
    UCHAR Reserved2[3];
} SLOT_TABLE_INFORMATION, *PSLOT_TABLE_INFORMATION;

typedef struct _MECHANICAL_STATUS {
    MECHANICAL_STATUS_INFORMATION_HEADER MechanicalStatusHeader;
    SLOT_TABLE_INFORMATION SlotTableInfo[1];
} MECHANICAL_STATUS, *PMECHANICAL_STATUS;


// begin_ntminitape

//
// Tape definitions
//

typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB 4 byte big endians values.
//

typedef union _FOUR_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };

    ULONG AsULong;
} FOUR_BYTE, *PFOUR_BYTE;

typedef union _TWO_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
    };

    USHORT AsUShort;
} TWO_BYTE, *PTWO_BYTE;

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES(Destination, Source) {                \
    PFOUR_BYTE d = (PFOUR_BYTE)(Destination);               \
    PFOUR_BYTE s = (PFOUR_BYTE)(Source);                    \
    d->Byte3 = s->Byte0;                                    \
    d->Byte2 = s->Byte1;                                    \
    d->Byte1 = s->Byte2;                                    \
    d->Byte0 = s->Byte3;                                    \
}

//
// Byte reversing macro for converting
// USHORTS from big to little endian in place
//

#define REVERSE_SHORT(Short) {          \
    UCHAR tmp;                          \
    PTWO_BYTE w = (PTWO_BYTE)(Short);   \
    tmp = w->Byte0;                     \
    w->Byte0 = w->Byte1;                \
    w->Byte1 = tmp;                     \
    }

//
// Byte reversing macro for convering
// ULONGS between big & little endian in place
//

#define REVERSE_LONG(Long) {            \
    UCHAR tmp;                          \
    PFOUR_BYTE l = (PFOUR_BYTE)(Long);  \
    tmp = l->Byte3;                     \
    l->Byte3 = l->Byte0;                \
    l->Byte0 = tmp;                     \
    tmp = l->Byte2;                     \
    l->Byte2 = l->Byte1;                \
    l->Byte1 = tmp;                     \
    }

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    UCHAR tmp;                                      \
    for (tmp = 0; tmp < 32; tmp++) {                \
        if (((Data) >> tmp) == 1) {                 \
            break;                                  \
        }                                           \
    }                                               \
    ASSERT(tmp != 32);                              \
    (Bit) = tmp;                                    \
}

// end_ntminitape

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif

#endif // !defined _NTSCSI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbxray\xbxray.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xbxray.cpp
 *  Content:    Overdraw visualization tool
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "resource.h"
#include <xboxverp.h>
#include "xbfile.hxx"

// encodings for flags
#define INCREMENTSHIFT  4
#define INCREMENTMASK   (0xff << INCREMENTSHIFT)

#define FILLMODESHIFT   12
#define FILLMODEMASK    (0x3 << FILLMODESHIFT)

#define ZENABLESHIFT    14
#define ZENABLEMASK     (0x3 << ZENABLESHIFT)

#define STENCILENABLESHIFT    16
#define STENCILENABLEMASK     (0x3 << STENCILENABLESHIFT)

#define CULLMODESHIFT    18
#define CULLMODEMASK     (0x3 << CULLMODESHIFT)

#define GRAYSHIFT       20
#define GRAYMASK        (0x1 << GRAYSHIFT)

char buf[65536];

DWORD g_dwFlags = 0;
DWORD g_nPos;
DWORD g_dwMarker;
BOOL g_bEnabled = FALSE;
SCROLLINFO si;

void enableXray(HWND hwnd)
{
    HRESULT hr = S_OK;
    g_dwMarker = GetDlgItemInt(hwnd, IDC_EDIT4, NULL, FALSE);
    DWORD flags=0;
    flags = 0x08000000 | g_dwFlags;
    flags |= g_nPos << INCREMENTSHIFT;
    if(IsDlgButtonChecked(hwnd, IDC_RADIO2 ) == BST_CHECKED) flags |= (1 << FILLMODESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO3 ) == BST_CHECKED) flags |= (2 << FILLMODESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO4 ) == BST_CHECKED) flags |= (3 << FILLMODESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO6 ) == BST_CHECKED) flags |= (1 << ZENABLESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO7 ) == BST_CHECKED) flags |= (2 << ZENABLESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO8 ) == BST_CHECKED) flags |= (3 << ZENABLESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO10) == BST_CHECKED) flags |= (1 << STENCILENABLESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO11) == BST_CHECKED) flags |= (2 << STENCILENABLESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO14) == BST_CHECKED) flags |= (1 << CULLMODESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO15) == BST_CHECKED) flags |= (2 << CULLMODESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_RADIO16) == BST_CHECKED) flags |= (3 << CULLMODESHIFT);
    if(IsDlgButtonChecked(hwnd, IDC_GRAY)    == BST_CHECKED) flags |= (1 << GRAYSHIFT);
    
    hr = DmVertexShaderSnapshot(0, 1, flags, g_dwMarker, (unsigned char *)buf);
    if(FAILED(hr)) 
    {
        if(hr == XBDM_FILEERROR)
            hr = HrLastError();
        MessageBox(NULL, (const char*)buf, "xbxray Error", MB_OK | MB_TASKMODAL);
    }
    g_bEnabled = TRUE;
    SetDlgItemText(hwnd, IDC_StatusText, "Xray is active");
}

void disableXray(HWND hwnd)
{
    HRESULT hr = S_OK;
    hr = DmVertexShaderSnapshot(0, 1, 0x04000000, 0, (unsigned char *)buf);
    if(FAILED(hr)) 
    {
        if(hr == XBDM_FILEERROR)
            hr = HrLastError();
        MessageBox(NULL, (const char*)buf, "xbxray Error", MB_OK | MB_TASKMODAL);
    }
    g_bEnabled = FALSE;
    SetDlgItemText(hwnd, IDC_StatusText, "Ready");
}

void updateXray(HWND hwnd)
{
    // if enabled, send new parameters
    if(g_bEnabled) enableXray(hwnd);
}

BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    SetDlgItemText(hwnd, IDC_StatusText, "Initializing...");
    EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), FALSE);
    
    // initialize the scroll bar
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS | SIF_RANGE;
    g_nPos = si.nPos = 32;
    si.nMin = 1;
    si.nMax = 255;
    SetScrollInfo(GetDlgItem(hwnd, IDC_SCROLLBAR1), SB_CTL, &si, TRUE);
    sprintf(buf, "%d Levels", 255/si.nPos + 1);
    SetDlgItemText(hwnd, IDC_LevelText, buf);

    CheckDlgButton(hwnd, IDC_RADIO1, BST_CHECKED);
    CheckDlgButton(hwnd, IDC_RADIO7, BST_CHECKED);
    CheckDlgButton(hwnd, IDC_RADIO9, BST_CHECKED);
    CheckDlgButton(hwnd, IDC_RADIO13, BST_CHECKED);

    CheckDlgButton(hwnd, IDC_GRAY, BST_CHECKED);

    SetDlgItemText(hwnd, IDC_StatusText, "Ready");
    return TRUE;
}

void Dlg_OnHScroll(HWND hwnd, HWND hwndCtl, UINT uCode, int nPos)
{
    si.fMask = SIF_POS;
    GetScrollInfo(hwndCtl, SB_CTL, &si);
    switch(uCode)
    {
    case SB_LINELEFT:
    case SB_PAGELEFT:
        si.nPos -= 1;
        break;
    case SB_LINERIGHT:
    case SB_PAGERIGHT:
        si.nPos += 1;
        break;
    case SB_THUMBTRACK:
        si.nPos = nPos;
        break;
    }
    SetScrollInfo(hwndCtl, SB_CTL, &si, TRUE);
    GetScrollInfo(hwndCtl, SB_CTL, &si);
    sprintf(buf, "%d Levels", 255/si.nPos + 1);
    SetDlgItemText(hwnd, IDC_LevelText, buf);
    g_nPos = si.nPos;
    updateXray(hwnd);
}

void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
    case IDCANCEL:
        EndDialog(hwnd, id);
        break;

    case IDC_CHECK1:
        if(IsDlgButtonChecked(hwnd, IDC_CHECK1) == BST_CHECKED)
        {
            enableXray(hwnd);
        }
        else
        {
            disableXray(hwnd);
        }
        break;
    case IDC_CHECK2:
        if(IsDlgButtonChecked(hwnd, IDC_CHECK2) == BST_CHECKED)
        {
            // enable marker window
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), TRUE);
            g_dwFlags |= 0x1;  // set marker flag
            updateXray(hwnd);
        }
        else
        {
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), FALSE);
            g_dwFlags &= ~0x1;  // reset marker flag
            updateXray(hwnd);
        }
        break;
    
    case IDC_RADIO1:
    case IDC_RADIO2:
    case IDC_RADIO3:
    case IDC_RADIO4:
    case IDC_RADIO5:
    case IDC_RADIO6:
    case IDC_RADIO7:
    case IDC_RADIO8:
    case IDC_RADIO9:
    case IDC_RADIO10:
    case IDC_RADIO11:
    case IDC_RADIO13:
    case IDC_RADIO14:
    case IDC_RADIO15:
    case IDC_RADIO16:
    case IDC_GRAY:
    case IDC_EDIT4:
        updateXray(hwnd);
        break;
    }
}

BOOL CALLBACK Dlg_Proc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    HANDLE_MSG(hDlg, WM_COMMAND, Dlg_OnCommand);
    HANDLE_MSG(hDlg, WM_INITDIALOG, Dlg_OnInitDialog);
    HANDLE_MSG(hDlg, WM_HSCROLL, Dlg_OnHScroll);
    case WM_HELP: printf("Help!\n"); break;
    default:
        return FALSE;
    }
    return TRUE;
}

int __cdecl main(int cArg, char **rgszArg)
{
    // display the UI
    DialogBox(NULL, MAKEINTRESOURCE(IDD_XRAY), NULL, Dlg_Proc);
    disableXray(NULL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\ddk\inc\ntddk.h ===
/*++ BUILD Version: 0095    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddk.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#ifndef _NTDDK_
#define _NTDDK_

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#include <wdmwarn4.h>
#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <bugcodes.h>

#ifdef __cplusplus
extern "C" {   // extern "C"
#endif

//
// Define types that are not exported.
//

typedef struct _KTHREAD *PKTHREAD;
typedef struct _ETHREAD *PETHREAD;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _PEB *PPEB;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _DEVICE_HANDLER_OBJECT *PDEVICE_HANDLER_OBJECT;
typedef struct _BUS_HANDLER *PBUS_HANDLER;

#if defined(_M_ALPHA)
void *__rdthread(void);
#pragma intrinsic(__rdthread)

unsigned char __swpirql(unsigned char);
#pragma intrinsic(__swpirql)

void *__rdpcr(void);
#pragma intrinsic(__rdpcr)
#define PCR ((PKPCR)__rdpcr())

#define KeGetCurrentThread() ((struct _KTHREAD *) __rdthread())
#endif // defined(_M_ALPHA)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#if defined(_M_IA64)

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xffff0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

PKTHREAD NTAPI KeGetCurrentThread();

#endif // defined(_M_IA64)

#define PsGetCurrentProcess() IoGetCurrentProcess()
#define PsGetCurrentThread() ((PETHREAD) (KeGetCurrentThread()))
extern PCCHAR KeNumberProcessors;

#ifndef FAR
#define FAR
#endif

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SINGLE_LIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;


//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define POOL_TAGGING 1

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DEVL


extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG( FlagName ) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else
#define IF_NTOS_DEBUG( FlagName ) if (FALSE)
#endif

//
// Kernel definitions that need to be here for forward reference purposes
//

//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//

typedef struct _KAPC {
    CSHORT Type;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;

// begin_ntndis
//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    BOOLEAN Inserted;
    UCHAR Padding;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

// end_ntndis
//
// switch to DBG when appropriate
//

#if DBG
#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#else
#define PAGED_CODE()
#endif

//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//
// end_wdm

#if !defined(_NTSYSTEM_)

#define NTKERNELAPI DECLSPEC_IMPORT         // wdm

#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.
//

#define NTHALAPI NTKERNELAPI

//
// Define a statically allocated object string.
//

#define INITIALIZED_OBJECT_STRING(ObjectString, Value)                      \
    OCHAR ObjectString##Buffer[] = Value;                                   \
    OBJECT_STRING ObjectString = {                                          \
        sizeof(Value) - sizeof(OCHAR),                                      \
        sizeof(Value),                                                      \
        ObjectString##Buffer                                                \
    }

#define INITIALIZED_OBJECT_STRING_RDATA(ObjectString, Value)                \
    OCHAR DECLSPEC_RDATA ObjectString##Buffer[] = Value;                    \
    OBJECT_STRING DECLSPEC_RDATA ObjectString = {                           \
        sizeof(Value) - sizeof(OCHAR),                                      \
        sizeof(Value),                                                      \
        ObjectString##Buffer                                                \
    }

//
// Define a statically allocated list entry.
//

#define INITIALIZED_LIST_ENTRY(ListEntry)                       \
    LIST_ENTRY ListEntry = {                                    \
        &ListEntry, &ListEntry                                  \
    }

//
//  Define an access token from a programmer's viewpoint.  The structure is
//  completely opaque and the programer is only allowed to have pointers
//  to tokens.
//

typedef PVOID PACCESS_TOKEN;            // winnt

//
// Pointer to a SECURITY_DESCRIPTOR  opaque data type.
//

typedef PVOID PSECURITY_DESCRIPTOR;     // winnt

//
// Define a pointer to the Security ID data type (an opaque data type)
//

typedef PVOID PSID;     // winnt

typedef ULONG ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

// end_winnt
//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)


//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


#include <pshpack4.h>

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    ULONG Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#include <poppack.h>

// This is the *current* ACL revision

#define ACL_REVISION     (2)
#define ACL_REVISION_DS  (4)

// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated

#define ACL_REVISION1   (1)
#define MIN_ACL_REVISION ACL_REVISION2
#define ACL_REVISION2   (2)
#define ACL_REVISION3   (3)
#define ACL_REVISION4   (4)
#define MAX_ACL_REVISION ACL_REVISION4

typedef struct _ACL {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
} ACL;
typedef ACL *PACL;

//
// Current security descriptor revision value
//

#define SECURITY_DESCRIPTOR_REVISION     (1)
#define SECURITY_DESCRIPTOR_REVISION1    (1)

//
// Privilege attributes
//

#define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L)
#define SE_PRIVILEGE_ENABLED            (0x00000002L)
#define SE_PRIVILEGE_USED_FOR_ACCESS    (0x80000000L)

//
// Privilege Set Control flags
//

#define PRIVILEGE_SET_ALL_NECESSARY    (1)

//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

typedef struct _PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;

//
// These must be converted to LUIDs before use.
//

#define SE_MIN_WELL_KNOWN_PRIVILEGE       (2L)
#define SE_CREATE_TOKEN_PRIVILEGE         (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE   (3L)
#define SE_LOCK_MEMORY_PRIVILEGE          (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE       (5L)

//
// Unsolicited Input is obsolete and unused.
//

#define SE_UNSOLICITED_INPUT_PRIVILEGE    (6L)

#define SE_MACHINE_ACCOUNT_PRIVILEGE      (6L)
#define SE_TCB_PRIVILEGE                  (7L)
#define SE_SECURITY_PRIVILEGE             (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE       (9L)
#define SE_LOAD_DRIVER_PRIVILEGE          (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE       (11L)
#define SE_SYSTEMTIME_PRIVILEGE           (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE  (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE    (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE      (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE     (16L)
#define SE_BACKUP_PRIVILEGE               (17L)
#define SE_RESTORE_PRIVILEGE              (18L)
#define SE_SHUTDOWN_PRIVILEGE             (19L)
#define SE_DEBUG_PRIVILEGE                (20L)
#define SE_AUDIT_PRIVILEGE                (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE   (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE        (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE      (24L)
#define SE_UNDOCK_PRIVILEGE               (25L)
#define SE_SYNC_AGENT_PRIVILEGE           (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE    (27L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE       (SE_ENABLE_DELEGATION_PRIVILEGE)

//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;

#define SECURITY_MAX_IMPERSONATION_LEVEL SecurityDelegation

#define DEFAULT_IMPERSONATION_LEVEL SecurityImpersonation

//
// Security Tracking Mode
//

#define SECURITY_DYNAMIC_TRACKING      (TRUE)
#define SECURITY_STATIC_TRACKING       (FALSE)

typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    ULONG Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;


typedef ULONG SECURITY_INFORMATION, *PSECURITY_INFORMATION;

#define OWNER_SECURITY_INFORMATION       (0x00000001L)
#define GROUP_SECURITY_INFORMATION       (0x00000002L)
#define DACL_SECURITY_INFORMATION        (0x00000004L)
#define SACL_SECURITY_INFORMATION        (0x00000008L)

#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)
#define PROTECTED_SACL_SECURITY_INFORMATION     (0x40000000L)
#define UNPROTECTED_DACL_SECURITY_INFORMATION   (0x20000000L)
#define UNPROTECTED_SACL_SECURITY_INFORMATION   (0x10000000L)


#define LOW_PRIORITY 0              // Lowest thread priority level
#define LOW_REALTIME_PRIORITY 16    // Lowest realtime priority level
#define HIGH_PRIORITY 31            // Highest thread priority level
#define MAXIMUM_PRIORITY 32         // Number of thread priority levels
// begin_winnt
#define MAXIMUM_WAIT_OBJECTS 64     // Maximum number of wait objects

#define MAXIMUM_SUSPEND_COUNT MAXCHAR // Maximum times thread can be suspended
// end_winnt

//
// Thread affinity
//

typedef ULONG KAFFINITY;
typedef KAFFINITY *PKAFFINITY;

//
// Thread priority
//

typedef LONG KPRIORITY;

//
// Spin Lock
//

// begin_ntndis begin_winnt

typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;

// end_ntndis end_winnt

//
// Interrupt routine (first level dispatch)
//

typedef
VOID
(*PKINTERRUPT_ROUTINE) (
    VOID
    );

//
// Profile source types
//
typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

//
// for move macros
//
#ifdef _MAC
#ifndef _INC_STRING
#include <string.h>
#endif /* _INC_STRING */
#else
#include <string.h>
#endif // _MAC

//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//

#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

VOID
NTAPI
RtlRip(
    IN PVOID ApiName,
    IN PVOID Expression,
    IN PVOID Message
    );

#define RIP(Message) \
    do { RtlRip( NULL, NULL, Message ); } while(0)

#define RIP_ON_NOT_TRUE(ApiName, Expression) \
    do { if (!(Expression)) RtlRip(ApiName, #Expression, NULL); } while(0)

#define RIP_ON_NOT_TRUE_WITH_MESSAGE(Expression, Message) \
    do { if (!(Expression)) RtlRip(NULL, #Expression, Message); } while(0)

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#define RIP(msg)
#define RIP_ON_NOT_TRUE(api, exp)
#define RIP_ON_NOT_TRUE_WITH_MESSAGE(exp, msg)
#endif // DBG

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

// end_wdm end_nthal end_ntifs end_ntndis



#if defined(_M_ALPHA) || defined(_M_AXP64) || defined(_M_IA64)
PVOID
_ReturnAddress (
    VOID
    );

#pragma intrinsic(_ReturnAddress)

#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;
#else
NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );
#endif

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags);

NTSYSAPI                                            
NTSTATUS                                            
NTAPI                                               
RtlCharToInteger (                                  
    PCSZ String,                                    
    ULONG Base,                                     
    PULONG Value                                    
    );                                              

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );

#ifdef _WIN64
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlInt64ToUnicodeString(Value, Base, String)
#else
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlIntegerToUnicodeString(Value, Base, String)
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    PUNICODE_STRING String,
    ULONG Base,
    PULONG Value
    );


//
//  String manipulation routines
//

NTSYSAPI
VOID
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    PANSI_STRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );


NTSYSAPI
VOID
NTAPI
RtlCopyString(
    PSTRING DestinationString,
    PSTRING SourceString
    );

NTSYSAPI
CHAR
NTAPI
RtlUpperChar (
    CHAR Character
    );

NTSYSAPI
CHAR
NTAPI
RtlLowerChar (
    CHAR Character
    );

NTSYSAPI
LONG
NTAPI
RtlCompareString(
    PSTRING String1,
    PSTRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
    PSTRING String1,
    PSTRING String2,
    BOOLEAN CaseInSensitive
    );


NTSYSAPI
VOID
NTAPI
RtlUpperString(
    PSTRING DestinationString,
    PSTRING SourceString
    );

//
// NLS String functions
//

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    const UNICODE_STRING *String1,
    const UNICODE_STRING *String2,
    BOOLEAN CaseInSensitive
    );

// end_wdm

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PUNICODE_STRING SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );

// end_ntndis end_wdm

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    WCHAR SourceCharacter
    );

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    WCHAR SourceCharacter
    );

// begin_wdm

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    PANSI_STRING AnsiString
    );


//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlAnsiStringToUnicodeSize(
//      PANSI_STRING AnsiString
//      );
//

#define RtlAnsiStringToUnicodeSize(STRING) (                 \
    ((STRING)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR) \
)


// begin_ntminiport

#include <guiddef.h>

// end_ntminiport

#ifndef DEFINE_GUIDEX
    #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
#endif // !defined(DEFINE_GUIDEX)

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#ifndef __IID_ALIGNED__
    #define __IID_ALIGNED__
    #ifdef __cplusplus
        inline int IsEqualGUIDAligned(REFGUID guid1, REFGUID guid2)
        {
            return ((*(PLONGLONG)(&guid1) == *(PLONGLONG)(&guid2)) && (*((PLONGLONG)(&guid1) + 1) == *((PLONGLONG)(&guid2) + 1)));
        }
    #else // !__cplusplus
        #define IsEqualGUIDAligned(guid1, guid2) \
            ((*(PLONGLONG)(guid1) == *(PLONGLONG)(guid2)) && (*((PLONGLONG)(guid1) + 1) == *((PLONGLONG)(guid2) + 1)))
    #endif // !__cplusplus
#endif // !__IID_ALIGNED__

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    );

//
// Fast primitives to compare, move, and zero memory
//

// begin_winnt begin_ntndis

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory (
    const VOID *Source1,
    const VOID *Source2,
    SIZE_T Length
    );

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

// end_ntndis end_winnt

#if defined(_M_ALPHA)

//
// Guaranteed byte granularity memory copy function.
//

NTSYSAPI
VOID
NTAPI
RtlCopyBytes (
   PVOID Destination,
   CONST VOID *Source,
   SIZE_T Length
   );

//
// Guaranteed byte granularity memory zero function.
//

NTSYSAPI
VOID
NTAPI
RtlZeroBytes (
   PVOID Destination,
   SIZE_T Length
   );

//
// Guaranteed byte granularity memory fill function.
//

NTSYSAPI
VOID
NTAPI
RtlFillBytes (
    PVOID Destination,
    SIZE_T Length,
    UCHAR Fill
    );

#else

#define RtlCopyBytes RtlCopyMemory
#define RtlZeroBytes RtlZeroMemory
#define RtlFillBytes RtlFillMemory

#endif

//
// Define kernel debugger print prototypes and macros.
//
// N.B. The following function cannot be directly imported because there are
//      a few places in the source tree where this function is redefined.
//

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

// end_wdm

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

// begin_wdm

#define DBG_STATUS_CONTROL_C        1
#define DBG_STATUS_SYSRQ            2
#define DBG_STATUS_BUGCHECK_FIRST   3
#define DBG_STATUS_BUGCHECK_SECOND  4
#define DBG_STATUS_FATAL            5
#define DBG_STATUS_DEBUG_CONTROL    6

#if DBG

#define KdPrint(_x_) DbgPrint _x_
#define KdBreakPoint() DbgBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s) DbgBreakPointWithStatus(s)

// begin_wdm

#else

#define KdPrint(_x_)
#define KdBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s)

// begin_wdm
#endif

#ifndef _DBGNT_

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

// end_wdm

ULONG
_cdecl
DbgPrintReturnControlC(
    PCH Format,
    ...
    );

// begin_wdm
#endif // _DBGNT_
//
// Large integer arithmetic routines.
//

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

#if !defined(MIDL_PASS)

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    )
{
    LARGE_INTEGER Sum;

    Sum.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
    return Sum;
}

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (LONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (ULONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

__inline
ULONG
NTAPI
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    ULONG Quotient;

    Quotient = (ULONG)(Dividend.QuadPart / Divisor);
    if (ARGUMENT_PRESENT( Remainder )) {

        *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
    }

    return Quotient;
}

//
// Large integer negation - -(64-bits)
//

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = -Subtrahend.QuadPart;
    return Difference;
}

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
    return Difference;
}

#endif

//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

// end_wdm
//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

// begin_wdm
//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#define RtlLargeIntegerAnd(Result, Source, Mask)   \
        {                                           \
            Result.HighPart = Source.HighPart & Mask.HighPart; \
            Result.LowPart = Source.LowPart & Mask.LowPart; \
        }

//
// Large integer conversion routines.
//

#if defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)

//
// Convert signed integer to large integer.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    );

//
// Convert unsigned integer to large integer.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );


//
// Large integer shift routines.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

#else

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4035)               // re-enable below

//
// Convert signed integer to large integer.
//

__inline LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    )
{
    __asm {
        mov     eax, SignedInteger
        cdq                 ; (edx:eax) = signed LargeInt
    }
}

//
// Convert unsigned integer to large integer.
//

__inline LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    )
{
    __asm {
        sub     edx, edx    ; zero highpart
        mov     eax, UnsignedInteger
    }
}

//
// Large integer shift routines.
//

__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm    {
        mov     cl, ShiftCount
        and     cl, 0x3f                    ; mod 64

        cmp     cl, 32
        jc      short sl10

        mov     edx, LargeInteger.LowPart   ; ShiftCount >= 32
        xor     eax, eax                    ; lowpart is zero
        shl     edx, cl                     ; store highpart
        jmp     short done

sl10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shld    edx, eax, cl
        shl     eax, cl
done:
    }
}


__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm    {
        mov     cl, ShiftCount
        and     cl, 0x3f               ; mod 64

        cmp     cl, 32
        jc      short sr10

        mov     eax, LargeInteger.HighPart  ; ShiftCount >= 32
        xor     edx, edx                    ; lowpart is zero
        shr     eax, cl                     ; store highpart
        jmp     short done

sr10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shrd    eax, edx, cl
        shr     edx, cl
done:
    }
}


__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm {
        mov     cl, ShiftCount
        and     cl, 3fh                 ; mod 64

        cmp     cl, 32
        jc      short sar10

        mov     eax, LargeInteger.HighPart
        sar     eax, cl
        bt      eax, 31                     ; sign bit set?
        sbb     edx, edx                    ; duplicate sign bit into highpart
        jmp     short done
sar10:
        mov     eax, LargeInteger.LowPart   ; (eax) = LargeInteger.LowPart
        mov     edx, LargeInteger.HighPart  ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        sar     edx, cl
done:
    }
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4035)
#endif

#endif

//
// Large integer comparison routines.
//
// BOOLEAN
// RtlLargeIntegerGreaterThan (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterThanOrEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerNotEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThan (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThanOrEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterThanZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterOrEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerNotEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThanZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerLessOrEqualToZero (
//     LARGE_INTEGER Operand
//     );
//

#define RtlLargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define RtlLargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define RtlLargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define RtlLargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define RtlLargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define RtlLargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define RtlLargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define RtlLargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define RtlLargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define RtlLargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)


//
//  Time conversion routines
//

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;


NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields (
    PLARGE_INTEGER Time,
    PTIME_FIELDS TimeFields
    );

//
//  A time field record (Weekday ignored) -> 64 bit Time value
//

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

//
// The following macros store and retrieve USHORTS and ULONGS from potentially
// unaligned addresses, avoiding alignment faults.  they should probably be
// rewritten in assembler
//

#define SHORT_SIZE  (sizeof(USHORT))
#define SHORT_MASK  (SHORT_SIZE - 1)
#define LONG_SIZE       (sizeof(LONG))
#define LONGLONG_SIZE   (sizeof(LONGLONG))
#define LONG_MASK       (LONG_SIZE - 1)
#define LONGLONG_MASK   (LONGLONG_SIZE - 1)
#define LOWBYTE_MASK 0x00FF

#define FIRSTBYTE(VALUE)  ((VALUE) & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) (((VALUE) >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  (((VALUE) >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) (((VALUE) >> 24) & LOWBYTE_MASK)

//
// if MIPS Big Endian, order of bytes is reversed.
//

#define SHORT_LEAST_SIGNIFICANT_BIT  0
#define SHORT_MOST_SIGNIFICANT_BIT   1

#define LONG_LEAST_SIGNIFICANT_BIT       0
#define LONG_3RD_MOST_SIGNIFICANT_BIT    1
#define LONG_2ND_MOST_SIGNIFICANT_BIT    2
#define LONG_MOST_SIGNIFICANT_BIT        3

//++
//
// VOID
// RtlStoreUshort (
//     PUSHORT ADDRESS
//     USHORT VALUE
//     )
//
// Routine Description:
//
// This macro stores a USHORT value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store USHORT value
//     VALUE - USHORT to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUshort(ADDRESS,VALUE)                     \
         if ((ULONG_PTR)(ADDRESS) & SHORT_MASK) {         \
             ((PUCHAR) (ADDRESS))[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PUSHORT) (ADDRESS)) = (USHORT) VALUE;     \
         }


//++
//
// VOID
// RtlStoreUlong (
//     PULONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG value
//     VALUE - ULONG to store
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call storeushort in the
//     unaligned case.
//
//--

#define RtlStoreUlong(ADDRESS,VALUE)                      \
         if ((ULONG_PTR)(ADDRESS) & LONG_MASK) {          \
             ((PUCHAR) (ADDRESS))[LONG_LEAST_SIGNIFICANT_BIT      ] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_3RD_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(SECONDBYTE(VALUE));   \
             ((PUCHAR) (ADDRESS))[LONG_2ND_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(THIRDBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_MOST_SIGNIFICANT_BIT       ] = (UCHAR)(FOURTHBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PULONG) (ADDRESS)) = (ULONG) (VALUE);     \
         }

//++
//
// VOID
// RtlStoreUlonglong (
//     PULONGLONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONGLONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONGLONG value
//     VALUE - ULONGLONG to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUlonglong(ADDRESS,VALUE)                        \
         if ((ULONG_PTR)(ADDRESS) & LONGLONG_MASK) {            \
             RtlStoreUlong((ULONG_PTR)(ADDRESS),                \
                           (ULONGLONG)(VALUE) & 0xFFFFFFFF);    \
             RtlStoreUlong((ULONG_PTR)(ADDRESS)+sizeof(ULONG),  \
                           (ULONGLONG)(VALUE) >> 32);           \
         } else {                                               \
             *((PULONGLONG)(ADDRESS)) = (ULONGLONG)(VALUE);     \
         }

//++
//
// VOID
// RtlStoreUlongPtr (
//     PULONG_PTR ADDRESS
//     ULONG_PTR VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG_PTR value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG_PTR value
//     VALUE - ULONG_PTR to store
//
// Return Value:
//
//     none.
//
//--

#ifdef _WIN64

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlonglong(ADDRESS,VALUE)

#else

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlong(ADDRESS,VALUE)

#endif

//++
//
// VOID
// RtlRetrieveUshort (
//     PUSHORT DESTINATION_ADDRESS
//     PUSHORT SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a USHORT value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store USHORT value
//     SOURCE_ADDRESS - where to retrieve USHORT value from
//
// Return Value:
//
//     none.
//
//--

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                   \
         if ((ULONG_PTR)SRC_ADDRESS & SHORT_MASK) {                       \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
         }                                                            \
         else {                                                       \
             *((PUSHORT) DEST_ADDRESS) = *((PUSHORT) SRC_ADDRESS);    \
         }                                                            \

//++
//
// VOID
// RtlRetrieveUlong (
//     PULONG DESTINATION_ADDRESS
//     PULONG SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a ULONG value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store ULONG value
//     SOURCE_ADDRESS - where to retrieve ULONG value from
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call retrieveushort in the
//     unaligned case.
//
//--

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                    \
         if ((ULONG_PTR)SRC_ADDRESS & LONG_MASK) {                        \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
             ((PUCHAR) DEST_ADDRESS)[2] = ((PUCHAR) SRC_ADDRESS)[2];  \
             ((PUCHAR) DEST_ADDRESS)[3] = ((PUCHAR) SRC_ADDRESS)[3];  \
         }                                                            \
         else {                                                       \
             *((PULONG) DEST_ADDRESS) = *((PULONG) SRC_ADDRESS);      \
         }
//
//  BitMap routines.  The following structure, routines, and macros are
//  for manipulating bitmaps.  The user is responsible for allocating a bitmap
//  structure (which is really a header) and a buffer (which must be longword
//  aligned and multiple longwords in size).
//

typedef struct _RTL_BITMAP {
    ULONG SizeOfBitMap;                     // Number of bits in bit map
    PULONG Buffer;                          // Pointer to the bit map itself
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;

//
//  The following routine initializes a new bitmap.  It does not alter the
//  data currently in the bitmap.  This routine must be called before
//  any other bitmap routine/macro.
//

NTSYSAPI
VOID
NTAPI
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );

//
//  The following two routines either clear or set all of the bits
//  in a bitmap.
//

NTSYSAPI
VOID
NTAPI
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
VOID
NTAPI
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap.  The region will be at least
//  as large as the number specified, and the search of the bitmap will
//  begin at the specified hint index (which is a bit index within the
//  bitmap, zero based).  The return value is the bit index of the located
//  region (zero based) or -1 (i.e., 0xffffffff) if such a region cannot
//  be located
//

NTSYSAPI
ULONG
NTAPI
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap and either set or clear the bits
//  within the located region.  The region will be as large as the number
//  specified, and the search for the region will begin at the specified
//  hint index (which is a bit index within the bitmap, zero based).  The
//  return value is the bit index of the located region (zero based) or
//  -1 (i.e., 0xffffffff) if such a region cannot be located.  If a region
//  cannot be located then the setting/clearing of the bitmap is not performed.
//

NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines clear or set bits within a specified region
//  of the bitmap.  The starting index is zero based.
//

NTSYSAPI
VOID
NTAPI
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );

NTSYSAPI
VOID
NTAPI
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );

//
//  The following routine locates a set of contiguous regions of clear
//  bits within the bitmap.  The caller specifies whether to return the
//  longest runs or just the first found lcoated.  The following structure is
//  used to denote a contiguous run of bits.  The two routines return an array
//  of this structure, one for each run located.
//

typedef struct _RTL_BITMAP_RUN {

    ULONG StartingIndex;
    ULONG NumberOfBits;

} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );

//
//  The following routine locates the longest contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the longest region found.
//

NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following routine locates the first contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the region found.
//

NTSYSAPI
ULONG
NTAPI
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following macro returns the value of the bit stored within the
//  bitmap at the specified location.  If the bit is set a value of 1 is
//  returned otherwise a value of 0 is returned.
//
//      ULONG
//      RtlCheckBit (
//          PRTL_BITMAP BitMapHeader,
//          ULONG BitPosition
//          );
//
//
//  To implement CheckBit the macro retrieves the longword containing the
//  bit in question, shifts the longword to get the bit in question into the
//  low order bit position and masks out all other bits.
//

#define RtlCheckBit(BMH,BP) ((((BMH)->Buffer[(BP) / 32]) >> ((BP) % 32)) & 0x1)

//
//  The following two procedures return to the caller the total number of
//  clear or set bits within the specified bitmap.
//

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two procedures return to the caller a boolean value
//  indicating if the specified range of bits are all clear or set.
//

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

//
//  The following two procedures return to the caller a value indicating
//  the position within a ULONGLONG of the most or least significant non-zero
//  bit.  A value of zero results in a return value of -1.
//

NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    );

NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    );


NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    PACCESS_MASK AccessMask,
    PGENERIC_MAPPING GenericMapping
    );

//
// Range list package
//

typedef struct _RTL_RANGE {

    //
    // The start of the range
    //
    ULONGLONG Start;    // Read only

    //
    // The end of the range
    //
    ULONGLONG End;      // Read only

    //
    // Data the user passed in when they created the range
    //
    PVOID UserData;     // Read/Write

    //
    // The owner of the range
    //
    PVOID Owner;        // Read/Write

    //
    // User defined flags the user specified when they created the range
    //
    UCHAR Attributes;    // Read/Write

    //
    // Flags (RTL_RANGE_*)
    //
    UCHAR Flags;       // Read only

} RTL_RANGE, *PRTL_RANGE;


#define RTL_RANGE_SHARED    0x01
#define RTL_RANGE_CONFLICT  0x02

typedef struct _RTL_RANGE_LIST {

    //
    // The list of ranges
    //
    LIST_ENTRY ListHead;

    //
    // These always come in useful
    //
    ULONG Flags;        // use RANGE_LIST_FLAG_*

    //
    // The number of entries in the list
    //
    ULONG Count;

    //
    // Every time an add/delete operation is performed on the list this is
    // incremented.  It is checked during iteration to ensure that the list
    // hasn't changed between GetFirst/GetNext or GetNext/GetNext calls
    //
    ULONG Stamp;

} RTL_RANGE_LIST, *PRTL_RANGE_LIST;

typedef struct _RANGE_LIST_ITERATOR {

    PLIST_ENTRY RangeListHead;
    PLIST_ENTRY MergedHead;
    PVOID Current;
    ULONG Stamp;

} RTL_RANGE_LIST_ITERATOR, *PRTL_RANGE_LIST_ITERATOR;


NTSYSAPI
VOID
NTAPI
RtlInitializeRangeList(
    IN OUT PRTL_RANGE_LIST RangeList
    );

NTSYSAPI
VOID
NTAPI
RtlFreeRangeList(
    IN PRTL_RANGE_LIST RangeList
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopyRangeList(
    OUT PRTL_RANGE_LIST CopyRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

#define RTL_RANGE_LIST_ADD_IF_CONFLICT      0x00000001
#define RTL_RANGE_LIST_ADD_SHARED           0x00000002

NTSYSAPI
NTSTATUS
NTAPI
RtlAddRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR Attributes,
    IN ULONG Flags,
    IN PVOID UserData,  OPTIONAL
    IN PVOID Owner      OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PVOID Owner
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteOwnersRanges(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN PVOID Owner
    );

#define RTL_RANGE_LIST_SHARED_OK           0x00000001
#define RTL_RANGE_LIST_NULL_CONFLICT_OK    0x00000002

typedef
BOOLEAN
(*PRTL_CONFLICT_RANGE_CALLBACK) (
    IN PVOID Context,
    IN PRTL_RANGE Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFindRange(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Minimum,
    IN ULONGLONG Maximum,
    IN ULONG Length,
    IN ULONG Alignment,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PULONGLONG Start
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIsRangeAvailable(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PBOOLEAN Available
    );

#define FOR_ALL_RANGES(RangeList, Iterator, Current)            \
    for (RtlGetFirstRange((RangeList), (Iterator), &(Current)); \
         (Current) != NULL;                                     \
         RtlGetNextRange((Iterator), &(Current), TRUE)          \
         )

#define FOR_ALL_RANGES_BACKWARDS(RangeList, Iterator, Current)  \
    for (RtlGetLastRange((RangeList), (Iterator), &(Current));  \
         (Current) != NULL;                                     \
         RtlGetNextRange((Iterator), &(Current), FALSE)         \
         )

NTSYSAPI
NTSTATUS
NTAPI
RtlGetFirstRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetNextRange(
    IN OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range,
    IN BOOLEAN MoveForwards
    );

#define RTL_RANGE_LIST_MERGE_IF_CONFLICT    RTL_RANGE_LIST_ADD_IF_CONFLICT

NTSYSAPI
NTSTATUS
NTAPI
RtlMergeRangeLists(
    OUT PRTL_RANGE_LIST MergedRangeList,
    IN PRTL_RANGE_LIST RangeList1,
    IN PRTL_RANGE_LIST RangeList2,
    IN ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInvertRangeList(
    OUT PRTL_RANGE_LIST InvertedRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

// end_nthal

// begin_wdm

//
// Byte swap routines.  These are used to convert from little-endian to
// big-endian and vice-versa.
//

USHORT
FASTCALL
RtlUshortByteSwap(
    IN USHORT Source
    );

ULONG
FASTCALL
RtlUlongByteSwap(
    IN ULONG Source
    );

ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    IN ULONGLONG Source
    );


//
// Routine for converting from a volume device object to a DOS name.
//

NTSYSAPI
NTSTATUS
NTAPI
RtlVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );

typedef struct _OSVERSIONINFOA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif // UNICODE

typedef struct _OSVERSIONINFOEXA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
#ifdef UNICODE
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#endif // UNICODE

//
// RtlVerifyVersionInfo() conditions
//

#define VER_EQUAL                       1
#define VER_GREATER                     2
#define VER_GREATER_EQUAL               3
#define VER_LESS                        4
#define VER_LESS_EQUAL                  5
#define VER_AND                         6
#define VER_OR                          7

#define VER_CONDITION_MASK              7
#define VER_NUM_BITS_PER_CONDITION_MASK 3

//
// RtlVerifyVersionInfo() type mask bits
//

#define VER_MINORVERSION                0x0000001
#define VER_MAJORVERSION                0x0000002
#define VER_BUILDNUMBER                 0x0000004
#define VER_PLATFORMID                  0x0000008
#define VER_SERVICEPACKMINOR            0x0000010
#define VER_SERVICEPACKMAJOR            0x0000020
#define VER_SUITENAME                   0x0000040
#define VER_PRODUCT_TYPE                0x0000080

//
// RtlVerifyVersionInfo() os product type values
//

#define VER_NT_WORKSTATION              0x0000001
#define VER_NT_DOMAIN_CONTROLLER        0x0000002
#define VER_NT_SERVER                   0x0000003

//
// dwPlatformId defines:
//

#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2


//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//

#define VER_SET_CONDITION(_m_,_t_,_c_)  \
        ((_m_)=VerSetConditionMask((_m_),(_t_),(_c_)))

ULONGLONG
NTAPI
VerSetConditionMask(
        IN  ULONGLONG   ConditionMask,
        IN  ULONG   TypeMask,
        IN  UCHAR   Condition
        );
//
//
//

NTSYSAPI
NTSTATUS
RtlGetVersion(
    OUT PRTL_OSVERSIONINFOW lpVersionInformation
    );

NTSYSAPI
NTSTATUS
RtlVerifyVersionInfo(
    IN PRTL_OSVERSIONINFOEXW VersionInfo,
    IN ULONG TypeMask,
    IN ULONGLONG  ConditionMask
    );

//

typedef struct _RTL_CRITICAL_SECTION {

    //
    //  The following field is used for blocking when there is contention for
    //  the resource
    //

    union {
// end_winnt
        struct {
            UCHAR Type;
            UCHAR Absolute;
            UCHAR Size;
            UCHAR Inserted;
            LONG SignalState;
            LIST_ENTRY WaitListHead;
        } Event;
// begin_winnt
        ULONG_PTR RawEvent[4];
    } Synchronization;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

NTSYSAPI
VOID
NTAPI
RtlEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
VOID
NTAPI
RtlLeaveCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
ULONG
NTAPI
RtlTryEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
VOID
NTAPI
RtlInitializeCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

#define RtlDeleteCriticalSection(CriticalSection) ((void)0)

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_MEMORY_UNIT         0x0000003a
#define FILE_DEVICE_MEDIA_BOARD         0x0000003b

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// begin_winnt

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_LIST_DIRECTORY       ( 0x0001 )    // directory

#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define FILE_ADD_FILE             ( 0x0002 )    // directory

#define FILE_APPEND_DATA          ( 0x0004 )    // file
#define FILE_ADD_SUBDIRECTORY     ( 0x0004 )    // directory
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )    // named pipe


#define FILE_READ_EA              ( 0x0008 )    // file & directory

#define FILE_WRITE_EA             ( 0x0010 )    // file & directory

#define FILE_EXECUTE              ( 0x0020 )    // file
#define FILE_TRAVERSE             ( 0x0020 )    // directory

#define FILE_DELETE_CHILD         ( 0x0040 )    // directory

#define FILE_READ_ATTRIBUTES      ( 0x0080 )    // all

#define FILE_WRITE_ATTRIBUTES     ( 0x0100 )    // all

#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)

#define FILE_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   FILE_READ_DATA           |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_READ_EA             |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   FILE_WRITE_DATA          |\
                                   FILE_WRITE_ATTRIBUTES    |\
                                   FILE_WRITE_EA            |\
                                   FILE_APPEND_DATA         |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_EXECUTE             |\
                                   SYNCHRONIZE)

// end_winnt


//
// Define share access rights to files and directories
//

#define FILE_SHARE_READ                 0x00000001  // winnt
#define FILE_SHARE_WRITE                0x00000002  // winnt
#define FILE_SHARE_DELETE               0x00000004  // winnt
#define FILE_SHARE_VALID_FLAGS          0x00000007

//
// Define the file attributes values
//
// Note:  0x00000008 is reserved for use for the old DOS VOLID (volume ID)
//        and is therefore not considered valid in NT.
//
// Note:  0x00000010 is reserved for use for the old DOS SUBDIRECTORY flag
//        and is therefore not considered valid in NT.  This flag has
//        been disassociated with file attributes since the other flags are
//        protected with READ_ and WRITE_ATTRIBUTES access to the file.
//
// Note:  Note also that the order of these flags is set to allow both the
//        FAT and the Pinball File Systems to directly set the attributes
//        flags in attributes words without having to pick each flag out
//        individually.  The order of these flags should not be changed!
//

#define FILE_ATTRIBUTE_READONLY             0x00000001  // winnt
#define FILE_ATTRIBUTE_HIDDEN               0x00000002  // winnt
#define FILE_ATTRIBUTE_SYSTEM               0x00000004  // winnt
//OLD DOS VOLID                             0x00000008

#define FILE_ATTRIBUTE_DIRECTORY            0x00000010  // winnt
#define FILE_ATTRIBUTE_ARCHIVE              0x00000020  // winnt
#define FILE_ATTRIBUTE_DEVICE               0x00000040  // winnt
#define FILE_ATTRIBUTE_NORMAL               0x00000080  // winnt

#define FILE_ATTRIBUTE_TEMPORARY            0x00000100  // winnt
#define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200
#define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800

#define FILE_ATTRIBUTE_OFFLINE              0x00001000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED            0x00004000

//
//  This definition is old and will disappear shortly
//

#define FILE_ATTRIBUTE_CONTENT_INDEXED      FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

#define FILE_ATTRIBUTE_VALID_FLAGS      0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS  0x000031a7

//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_SET_FLAGS                    0x00000036

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005

//
// Define special ByteOffset parameters for read and write operations
//

#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe

//
// Define alignment requirement values
//

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

//
// Define the maximum length of a filename string
//

#define MAXIMUM_FILENAME_LENGTH         256

//
// Define the various device characteristics flags
//

#define FILE_REMOVABLE_MEDIA            0x00000001
#define FILE_READ_ONLY_DEVICE           0x00000002
#define FILE_FLOPPY_DISKETTE            0x00000004
#define FILE_WRITE_ONCE_MEDIA           0x00000008
#define FILE_REMOTE_DEVICE              0x00000010
#define FILE_DEVICE_IS_MOUNTED          0x00000020
#define FILE_VIRTUAL_VOLUME             0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME  0x00000080
#define FILE_DEVICE_SECURE_OPEN         0x00000100

// end_wdm

//
// flags specified here will be propagated up and down a device stack
// after FDO and all filter devices are added, but before the device
// stack is started
//

#define FILE_CHARACTERISTICS_PROPAGATED (   FILE_REMOVABLE_MEDIA   | \
                                            FILE_READ_ONLY_DEVICE  | \
                                            FILE_FLOPPY_DISKETTE   | \
                                            FILE_WRITE_ONCE_MEDIA  | \
                                            FILE_DEVICE_SECURE_OPEN  )

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#if defined(_WIN64)
typedef struct _IO_STATUS_BLOCK32 {
    NTSTATUS Status;
    ULONG Information;
} IO_STATUS_BLOCK32, *PIO_STATUS_BLOCK32;
#endif


//
// Define an Asynchronous Procedure Call from I/O viewpoint
//

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );
#define PIO_APC_ROUTINE_DEFINED

//
// Define the file information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.
//

typedef enum _FILE_INFORMATION_CLASS {
// end_wdm
    FileDirectoryInformation       = 1,
    FileFullDirectoryInformation, // 2
    FileBothDirectoryInformation, // 3
    FileBasicInformation,         // 4  wdm
    FileStandardInformation,      // 5  wdm
    FileInternalInformation,      // 6
    FileEaInformation,            // 7
    FileAccessInformation,        // 8
    FileNameInformation,          // 9
    FileRenameInformation,        // 10
    FileLinkInformation,          // 11
    FileNamesInformation,         // 12
    FileDispositionInformation,   // 13
    FilePositionInformation,      // 14 wdm
    FileFullEaInformation,        // 15
    FileModeInformation,          // 16
    FileAlignmentInformation,     // 17
    FileAllInformation,           // 18
    FileAllocationInformation,    // 19
    FileEndOfFileInformation,     // 20 wdm
    FileAlternateNameInformation, // 21
    FileStreamInformation,        // 22
    FilePipeInformation,          // 23
    FilePipeLocalInformation,     // 24
    FilePipeRemoteInformation,    // 25
    FileMailslotQueryInformation, // 26
    FileMailslotSetInformation,   // 27
    FileCompressionInformation,   // 28
    FileObjectIdInformation,      // 29
    FileCompletionInformation,    // 30
    FileMoveClusterInformation,   // 31
    FileQuotaInformation,         // 32
    FileReparsePointInformation,  // 33
    FileNetworkOpenInformation,   // 34
    FileAttributeTagInformation,  // 35
    FileTrackingInformation,      // 36
    FileMaximumInformation
// begin_wdm
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

//
// Define the various structures which are returned on query operations
//

typedef struct _FILE_BASIC_INFORMATION {                    
    LARGE_INTEGER CreationTime;                             
    LARGE_INTEGER LastAccessTime;                           
    LARGE_INTEGER LastWriteTime;                            
    LARGE_INTEGER ChangeTime;                               
    ULONG FileAttributes;                                   
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         
                                                            
typedef struct _FILE_STANDARD_INFORMATION {                 
    LARGE_INTEGER AllocationSize;                           
    LARGE_INTEGER EndOfFile;                                
    ULONG NumberOfLinks;                                    
    BOOLEAN DeletePending;                                  
    BOOLEAN Directory;                                      
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;   
                                                            
typedef struct _FILE_POSITION_INFORMATION {                 
    LARGE_INTEGER CurrentByteOffset;                        
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;   
                                                            
typedef struct _FILE_ALIGNMENT_INFORMATION {                
    ULONG AlignmentRequirement;                             
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION; 
                                                            
typedef struct _FILE_NAME_INFORMATION {                     
    ULONG FileNameLength;                                   
    OCHAR FileName[1];                                      
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;           
                                                            
typedef struct _FILE_NETWORK_OPEN_INFORMATION {                 
    LARGE_INTEGER CreationTime;                                 
    LARGE_INTEGER LastAccessTime;                               
    LARGE_INTEGER LastWriteTime;                                
    LARGE_INTEGER ChangeTime;                                   
    LARGE_INTEGER AllocationSize;                               
    LARGE_INTEGER EndOfFile;                                    
    ULONG FileAttributes;                                       
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;   
                                                                
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {               
    ULONG FileAttributes;                                       
    ULONG ReparseTag;                                           
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;  
                                                                
typedef struct _FILE_DISPOSITION_INFORMATION {                  
    BOOLEAN DeleteFile;                                         
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION; 
                                                                
typedef struct _FILE_END_OF_FILE_INFORMATION {                  
    LARGE_INTEGER EndOfFile;                                    
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION; 
                                                                
//
// Define the file system information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation       = 1,
    FileFsLabelInformation,      // 2
    FileFsSizeInformation,       // 3
    FileFsDeviceInformation,     // 4
    FileFsAttributeInformation,  // 5
    FileFsControlInformation,    // 6
    FileFsFullSizeInformation,   // 7
    FileFsObjectIdInformation,   // 8
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_FS_DEVICE_INFORMATION {                    
    DEVICE_TYPE DeviceType;                                     
    ULONG Characteristics;                                      
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;     
                                                                

//
// Define segment buffer structure for scatter/gather read/write.
//

typedef union _FILE_SEGMENT_ELEMENT {
    PVOID Buffer;
    ULONG Alignment;
} FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

#ifdef _WIN64
#define PORT_MAXIMUM_MESSAGE_LENGTH 512
#else
#define PORT_MAXIMUM_MESSAGE_LENGTH 256
#endif
//
// Registry Specific Access Rights.
//

#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)

#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))


#define KEY_WRITE               ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_EXECUTE             ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_ALL_ACCESS          ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))

//
// Open/Create Options
//

#define REG_OPTION_RESERVED         (0x00000000L)   // Parameter is reserved

#define REG_OPTION_NON_VOLATILE     (0x00000000L)   // Key is preserved
                                                    // when system is rebooted

#define REG_OPTION_VOLATILE         (0x00000001L)   // Key is not preserved
                                                    // when system is rebooted

#define REG_OPTION_CREATE_LINK      (0x00000002L)   // Created key is a
                                                    // symbolic link

#define REG_OPTION_BACKUP_RESTORE   (0x00000004L)   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

#define REG_OPTION_OPEN_LINK        (0x00000008L)   // Open symbolic link

#define REG_LEGAL_OPTION            \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_NON_VOLATILE        |\
                 REG_OPTION_VOLATILE            |\
                 REG_OPTION_CREATE_LINK         |\
                 REG_OPTION_BACKUP_RESTORE      |\
                 REG_OPTION_OPEN_LINK)

//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

//
// Key restore flags
//

#define REG_WHOLE_HIVE_VOLATILE     (0x00000001L)   // Restore whole hive volatile
#define REG_REFRESH_HIVE            (0x00000002L)   // Unwind changes to last flush
#define REG_NO_LAZY_FLUSH           (0x00000004L)   // Never lazy flush this hive
#define REG_FORCE_RESTORE           (0x00000008L)   // Force the restore process even when we have open handles on subkeys

//
// Key query structures
//

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
//          Class[1];           // Variable length string not declared
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];           // Variable length
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

// end_wdm
typedef struct _KEY_NAME_INFORMATION {
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

// begin_wdm
typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation
// end_wdm
    ,
    KeyNameInformation
// begin_wdm
} KEY_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION {
    LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation
} KEY_SET_INFORMATION_CLASS;

//
// Value entry query structures
//

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS;



#define OBJ_NAME_PATH_SEPARATOR ((OCHAR)L'\\')

//
// Object Manager Object Type Specific Access Rights.
//

#define OBJECT_TYPE_CREATE (0x0001)

#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

//
// Object Manager Directory Specific Access Rights.
//

#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)

#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Object Manager Symbolic Link Specific Access Rights.
//

#define SYMBOLIC_LINK_QUERY (0x0001)

#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

typedef struct _OBJECT_NAME_INFORMATION {               
    OBJECT_STRING Name;                                 
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;   
#define DUPLICATE_CLOSE_SOURCE      0x00000001  // winnt
#define DUPLICATE_SAME_ACCESS       0x00000002  // winnt
#define DUPLICATE_SAME_ATTRIBUTES   0x00000004
typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    ULONG AllocationProtect;
    SIZE_T RegionSize;
    ULONG State;
    ULONG Protect;
    ULONG Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

//
// Section Access Rights.
//

// begin_winnt
#define SECTION_QUERY       0x0001
#define SECTION_MAP_WRITE   0x0002
#define SECTION_MAP_READ    0x0004
#define SECTION_MAP_EXECUTE 0x0008
#define SECTION_EXTEND_SIZE 0x0010

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|\
                            SECTION_MAP_WRITE |      \
                            SECTION_MAP_READ |       \
                            SECTION_MAP_EXECUTE |    \
                            SECTION_EXTEND_SIZE)
// end_winnt

#define SEGMENT_ALL_ACCESS SECTION_ALL_ACCESS

#define PAGE_NOACCESS          0x01     // winnt
#define PAGE_READONLY          0x02     // winnt
#define PAGE_READWRITE         0x04     // winnt
#define PAGE_WRITECOPY         0x08     // winnt
#define PAGE_EXECUTE           0x10     // winnt
#define PAGE_EXECUTE_READ      0x20     // winnt
#define PAGE_EXECUTE_READWRITE 0x40     // winnt
#define PAGE_EXECUTE_WRITECOPY 0x80     // winnt
#define PAGE_GUARD            0x100     // winnt
#define PAGE_NOCACHE          0x200     // winnt
#define PAGE_WRITECOMBINE     0x400     // winnt
#define PAGE_VIDEO              0x0     // winnt
#define PAGE_OLD_VIDEO        0x800

#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_RESET           0x80000     
#define MEM_TOP_DOWN       0x100000     
#define MEM_NOZERO         0x800000     
#define MEM_LARGE_PAGES  0x20000000     
#define MEM_4MB_PAGES    0x80000000     
#define SEC_RESERVE       0x4000000     
#define PROCESS_DUP_HANDLE        (0x0040)  // winnt
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)

// end_ntifs

#define MAXIMUM_PROCESSORS 32

// end_winnt

//
// Thread Specific Access Rights
//

#define THREAD_TERMINATE               (0x0001)  // winnt
#define THREAD_SET_INFORMATION         (0x0020)  // winnt

#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0x3FF)

//
// ClientId
//

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

//
// Thread Environment Block (and portable part of Thread Information Block)
//

//
//  NT_TIB - Thread Information Block - Portable part.
//
//      This is the subsystem portable part of the Thread Information Block.
//      It appears as the first part of the TEB for all threads which have
//      a user mode component.
//
//

// begin_winnt

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    union {
        PVOID FiberData;
        ULONG Version;
    };
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;
//
// Process Information Classes
//

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
    ProcessDeviceMap,
    ProcessSessionInformation,
    ProcessForegroundInformation,
    ProcessWow64Information,
    MaxProcessInfoClass
    } PROCESSINFOCLASS;
//
// Thread Information Classes
//

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair_Reusable,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    MaxThreadInfoClass
    } THREADINFOCLASS;
//
// Process Information Structures
//

//
// PageFaultHistory Information
//  NtQueryInformationProcess using ProcessWorkingSetWatch
//
typedef struct _PROCESS_WS_WATCH_INFORMATION {
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;

//
// Basic Process Information
//  NtQueryInformationProcess using ProcessBasicInfo
//

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;


//
// Process Device Map information
//  NtQueryInformationProcess using ProcessDeviceMap
//  NtSetInformationProcess using ProcessDeviceMap
//

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[ 32 ];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;


//
// Multi-User Session specific Process Information
//  NtQueryInformationProcess using ProcessSessionInformation
//

typedef struct _PROCESS_SESSION_INFORMATION {
    ULONG SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;


//
// Process Quotas
//  NtQueryInformationProcess using ProcessQuotaLimits
//  NtQueryInformationProcess using ProcessPooledQuotaLimits
//  NtSetInformationProcess using ProcessQuotaLimits
//

// begin_winnt begin_ntsrv

typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS;
typedef QUOTA_LIMITS *PQUOTA_LIMITS;

// end_winnt end_ntsrv

//
// Process I/O Counters
//  NtQueryInformationProcess using ProcessIoCounters
//

// begin_winnt
typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;
// end_winnt

//
// Process Virtual Memory Counters
//  NtQueryInformationProcess using ProcessVmCounters
//

typedef struct _VM_COUNTERS {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} VM_COUNTERS;
typedef VM_COUNTERS *PVM_COUNTERS;

//
// Process Pooled Quota Usage and Limits
//  NtQueryInformationProcess using ProcessPooledUsageAndLimits
//

typedef struct _POOLED_USAGE_AND_LIMITS {
    SIZE_T PeakPagedPoolUsage;
    SIZE_T PagedPoolUsage;
    SIZE_T PagedPoolLimit;
    SIZE_T PeakNonPagedPoolUsage;
    SIZE_T NonPagedPoolUsage;
    SIZE_T NonPagedPoolLimit;
    SIZE_T PeakPagefileUsage;
    SIZE_T PagefileUsage;
    SIZE_T PagefileLimit;
} POOLED_USAGE_AND_LIMITS;
typedef POOLED_USAGE_AND_LIMITS *PPOOLED_USAGE_AND_LIMITS;

//
// Process Security Context Information
//  NtSetInformationProcess using ProcessAccessToken
// PROCESS_SET_ACCESS_TOKEN access to the process is needed
// to use this info level.
//

typedef struct _PROCESS_ACCESS_TOKEN {

    //
    // Handle to Primary token to assign to the process.
    // TOKEN_ASSIGN_PRIMARY access to this token is needed.
    //

    HANDLE Token;

    //
    // Handle to the initial thread of the process.
    // A process's access token can only be changed if the process has
    // no threads or one thread.  If the process has no threads, this
    // field must be set to NULL.  Otherwise, it must contain a handle
    // open to the process's only thread.  THREAD_QUERY_INFORMATION access
    // is needed via this handle.

    HANDLE Thread;

} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

//
// Process/Thread System and User Time
//  NtQueryInformationProcess using ProcessTimes
//  NtQueryInformationThread using ThreadTimes
//

typedef struct _KERNEL_USER_TIMES {
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES;
typedef KERNEL_USER_TIMES *PKERNEL_USER_TIMES;
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
#define NtCurrentProcess() ( (HANDLE) -1 )  
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
#define NtCurrentThread() ( (HANDLE) -2 )   

#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

#define NORMAL_DISPATCH_LENGTH 22                   
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define SMBUS_LEVEL 15              // System Management Bus interrupt level
#define PROFILE_LEVEL 26            // Profiler timer interrupt level
#define SCI_LEVEL 27                // System Control Interrupt (SCI) level
#define CLOCK_LEVEL 28              // Interval clock interrupt level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level
#define SYNCH_LEVEL (IPI_LEVEL-1)   // Synchronization level

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTHALAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTHALAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTHALAPI
ULONG
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


//
// Processor Control Region Structure Definition
//

typedef struct _KPCR {

    NT_TIB  NtTib;
    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;

} KPCR;
typedef KPCR *PKPCR;

//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Cr0NpxState;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000
#define PAGE_SIZE_LARGE 0x400000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L
#define PAGE_SHIFT_LARGE 22L

// end_wdm

//
// Define the highest user address and user probe address.
//

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000


//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

// begin_wdm

#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList

// end_wdm

//
// Prototypes for architectural specific versions of Exi386 Api
//

NTKERNELAPI
LARGE_INTEGER
ExInterlockedExchangeAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment
    );

//
// Intrinsic interlocked functions
//

#if (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(NO_INTERLOCKED_INTRINSICS)) && !defined(_WINBASE_)

// begin_wdm

NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

NTKERNELAPI
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

// end_wdm

#endif


#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

#pragma warning(disable:4035)               // re-enable below


//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

FORCEINLINE KIRQL KeGetCurrentIrql(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetPcr()->Irql;
#else
    __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }
#endif
}    



#endif // !defined(MIDL_PASS) && defined(_M_IX86)


NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );


#endif // defined(_X86_)


#if defined(_X86_)

//
// Define system time structure.
//

typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

#endif


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif

//
// Size of kernel mode stack.
//

#define KERNEL_STACK_SIZE 12288

//
// Size of kernel mode stack minus the overhead associated with the FPU save
// area and thread local storage area.  A thread's stack should have at least
// this many bytes available for actual stack usage.
//

#define KERNEL_USABLE_STACK_SIZE (KERNEL_STACK_SIZE - sizeof(FX_SAVE_AREA) - 512)

#ifdef _X86_

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// Define the size of FP registers in the FXSAVE format.
//

#define SIZE_OF_FX_REGISTERS        128

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records

// end_wx86

#define CONTEXT_CONTROL         (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER         (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS        (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT  (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER |\
                      CONTEXT_SEGMENTS)

// begin_wx86

#endif

#define MAXIMUM_SUPPORTED_EXTENSION     512

#include <pshpack1.h>
typedef struct _FLOATING_SAVE_AREA {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   XmmRegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
    ULONG   Cr0NpxState;
} FLOATING_SAVE_AREA;
#include <poppack.h>

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} CONTEXT;

typedef CONTEXT *PCONTEXT;

// begin_ntminiport

#endif //_X86_

#endif // _X86_
//
// Event Specific Access Rights.
//

#define EVENT_QUERY_STATE       0x0001
#define EVENT_MODIFY_STATE      0x0002  // winnt
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) // winnt

//
// Semaphore Specific Access Rights.
//

#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002  // winnt

#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) // winnt

//
// Timer APC routine definition.
//

typedef
VOID
(*PTIMER_APC_ROUTINE) (
    IN PVOID TimerContext,
    IN ULONG TimerLowValue,
    IN LONG TimerHighValue
    );


//
// Defined processor features
//

#define PF_FLOATING_POINT_PRECISION_ERRATA  0   // winnt
#define PF_FLOATING_POINT_EMULATED          1   // winnt
#define PF_COMPARE_EXCHANGE_DOUBLE          2   // winnt
#define PF_MMX_INSTRUCTIONS_AVAILABLE       3   // winnt
#define PF_PPC_MOVEMEM_64BIT_OK             4   // winnt
#define PF_ALPHA_BYTE_INSTRUCTIONS          5   // winnt
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6   // winnt
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7   // winnt
#define PF_RDTSC_INSTRUCTION_AVAILABLE      8   // winnt
#define PF_PAE_ENABLED                      9   // winnt

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign,                 // None == 0 == standard design
    NEC98x86,                       // NEC PC98xx series on X86
    EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#ifndef IsNEC_98
#define IsNEC_98 (FALSE)
#endif

#ifndef IsNotNEC_98
#define IsNotNEC_98 (TRUE)
#endif

#ifndef SetNEC_98
#define SetNEC_98
#endif

#ifndef SetNotNEC_98
#define SetNotNEC_98
#endif

#define PROCESSOR_FEATURE_MAX 64

// begin_winnt
//
// Predefined Value Types.
//

#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // Unicode nul terminated string
#define REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
#define REG_LINK                    ( 6 )   // Symbolic Link (unicode)
#define REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
#define REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
#define REG_QWORD                   ( 11 )  // 64-bit number
#define REG_QWORD_LITTLE_ENDIAN     ( 11 )  // 64-bit number (same as REG_QWORD)

// end_winnt
//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

//
// Start Type
//

#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;


//
// Resource List definitions
//

// begin_ntminiport begin_ntndis

//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
#define CmResourceTypeAssignedResource    8   // BUGBUG--remove
#define CmResourceTypeSubAllocateFrom     9   // BUGBUG--remove
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the PASSIGNED_RESOURCE type
//

#ifndef PASSIGNED_RESOURCE_DEFINED
#define PASSIGNED_RESOURCE_DEFINED
typedef PVOID PASSIGNED_RESOURCE;
#endif // PASSIGNED_RESOURCE_DEFINED

// end_wdm

//
// Define the bit masks for Flags common for all CM_RESOURCE_TYPE
//
// BUGBUG--remove the following 3 flags...
//
#define CM_RESOURCE_COMMON_COMPUTE_LENGTH_FROM_DEPENDENTS   0x8000
#define CM_RESOURCE_COMMON_NOT_REASSIGNED                   0x4000
#define CM_RESOURCE_COMMON_SUBSTRACTIVE                     0x2000

// begin_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
// end_wdm
#define CM_RESOURCE_PORT_FORWARD_FIRST_256_OF_EACH_1024     0x0002  // BUGBUG--remove
// begin_wdm
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040
// end_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeBusNumber
//

#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001  // BUGBUG--remove

//
// Define the bit masks for Flags when type is CmResourceTypeSubAllocateFrom
//

#define CM_RESOURCE_SUBALLOCATEFROM_FIXED_TRANSLATION   0x0001  // BUGBUG--remove
#define CM_RESOURCE_SUBALLOCATEFROM_WIRED_TRANSLATION   0x0002  // BUGBUG--remove

// end_ntminiport end_ntndis

// begin_wdm

//
// This structure defines one type of resource used by a driver.
//
// There can only be *1* DeviceSpecificData block. It must be located at
// the end of all resource descriptors in a full descriptor block.
//

//
// Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//
// begin_ntndis

#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // end_wdm
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        // begin_wdm
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // end_wdm
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        // begin_wdm
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// end_wdm
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// begin_wdm
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

// end_ntndis
//
// Define the structures used to interpret configuration data of
// \\Registry\machine\hardware\description tree.
// Basically, these structures are used to interpret component
// sepcific data.
//

//
// Define DEVICE_FLAGS
//

typedef struct _DEVICE_FLAGS {
    ULONG Failed : 1;
    ULONG ReadOnly : 1;
    ULONG Removable : 1;
    ULONG ConsoleIn : 1;
    ULONG ConsoleOut : 1;
    ULONG Input : 1;
    ULONG Output : 1;
} DEVICE_FLAGS, *PDEVICE_FLAGS;

//
// Define Component Information structure
//

typedef struct _CM_COMPONENT_INFORMATION {
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    ULONG AffinityMask;
} CM_COMPONENT_INFORMATION, *PCM_COMPONENT_INFORMATION;

//
// The following structures are used to interpret x86
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
// (Most of the structures are defined by BIOS.  They are
// not aligned on word (or dword) boundary.
//

//
// Define the Rom Block structure
//

typedef struct _CM_ROM_BLOCK {
    ULONG Address;
    ULONG Size;
} CM_ROM_BLOCK, *PCM_ROM_BLOCK;

// begin_ntminiport begin_ntndis

#include "pshpack1.h"

// end_ntminiport end_ntndis

//
// Define INT13 driver parameter block
//

typedef struct _CM_INT13_DRIVE_PARAMETER {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} CM_INT13_DRIVE_PARAMETER, *PCM_INT13_DRIVE_PARAMETER;

// begin_ntminiport begin_ntndis

//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86

// end_ntminiport end_ntndis

//
// The following structures are used to interpret mips
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
//

//
// Device data records for adapters.
//

//
// The device data record for the Emulex SCSI controller.
//

typedef struct _CM_SCSI_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR HostIdentifier;
} CM_SCSI_DEVICE_DATA, *PCM_SCSI_DEVICE_DATA;

//
// Device data records for controllers.
//

//
// The device data record for the Video controller.
//

typedef struct _CM_VIDEO_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG VideoClock;
} CM_VIDEO_DEVICE_DATA, *PCM_VIDEO_DEVICE_DATA;

//
// The device data record for the SONIC network controller.
//

typedef struct _CM_SONIC_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT DataConfigurationRegister;
    UCHAR EthernetAddress[8];
} CM_SONIC_DEVICE_DATA, *PCM_SONIC_DEVICE_DATA;

//
// The device data record for the serial controller.
//

typedef struct _CM_SERIAL_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG BaudClock;
} CM_SERIAL_DEVICE_DATA, *PCM_SERIAL_DEVICE_DATA;

//
// Device data records for peripherals.
//

//
// The device data record for the Monitor peripheral.
//

typedef struct _CM_MONITOR_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT HorizontalScreenSize;
    USHORT VerticalScreenSize;
    USHORT HorizontalResolution;
    USHORT VerticalResolution;
    USHORT HorizontalDisplayTimeLow;
    USHORT HorizontalDisplayTime;
    USHORT HorizontalDisplayTimeHigh;
    USHORT HorizontalBackPorchLow;
    USHORT HorizontalBackPorch;
    USHORT HorizontalBackPorchHigh;
    USHORT HorizontalFrontPorchLow;
    USHORT HorizontalFrontPorch;
    USHORT HorizontalFrontPorchHigh;
    USHORT HorizontalSyncLow;
    USHORT HorizontalSync;
    USHORT HorizontalSyncHigh;
    USHORT VerticalBackPorchLow;
    USHORT VerticalBackPorch;
    USHORT VerticalBackPorchHigh;
    USHORT VerticalFrontPorchLow;
    USHORT VerticalFrontPorch;
    USHORT VerticalFrontPorchHigh;
    USHORT VerticalSyncLow;
    USHORT VerticalSync;
    USHORT VerticalSyncHigh;
} CM_MONITOR_DEVICE_DATA, *PCM_MONITOR_DEVICE_DATA;

//
// The device data record for the Floppy peripheral.
//

typedef struct _CM_FLOPPY_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    CHAR Size[8];
    ULONG MaxDensity;
    ULONG MountDensity;
    //
    // New data fields for version >= 2.0
    //
    UCHAR StepRateHeadUnloadTime;
    UCHAR HeadLoadTime;
    UCHAR MotorOffTime;
    UCHAR SectorLengthCode;
    UCHAR SectorPerTrack;
    UCHAR ReadWriteGapLength;
    UCHAR DataTransferLength;
    UCHAR FormatGapLength;
    UCHAR FormatFillCharacter;
    UCHAR HeadSettleTime;
    UCHAR MotorSettleTime;
    UCHAR MaximumTrackValue;
    UCHAR DataTransferRate;
} CM_FLOPPY_DEVICE_DATA, *PCM_FLOPPY_DEVICE_DATA;

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;

//
// Declaration of the structure for disk geometries
//

typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    ULONG BytesPerSector;
    ULONG NumberOfCylinders;
    ULONG SectorsPerTrack;
    ULONG NumberOfHeads;
} CM_DISK_GEOMETRY_DEVICE_DATA, *PCM_DISK_GEOMETRY_DEVICE_DATA;

// end_wdm
//
// Declaration of the structure for the PcCard ISA IRQ map
//

typedef struct _CM_PCCARD_DEVICE_DATA {
    UCHAR Flags;
    UCHAR ErrorCode;
    USHORT Reserved;
    ULONG BusData;
    ULONG DeviceId;
    ULONG LegacyBaseAddress;
    UCHAR IRQMap[16];
} CM_PCCARD_DEVICE_DATA, *PCM_PCCARD_DEVICE_DATA;

// Definitions for Flags

#define PCCARD_MAP_ERROR        0x01
#define PCCARD_DEVICE_PCI       0x10

#define PCCARD_SCAN_DISABLED    0x01
#define PCCARD_MAP_ZERO         0x02
#define PCCARD_NO_TIMER         0x03
#define PCCARD_NO_PIC           0x04
#define PCCARD_NO_LEGACY_BASE   0x05
#define PCCARD_DUP_LEGACY_BASE  0x06
#define PCCARD_NO_CONTROLLERS   0x07

// begin_wdm
// begin_ntminiport

//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

// end_wdm

        struct {
            PASSIGNED_RESOURCE AssignedResource;
        } AssignedResource;     // will be obsoleted

        struct {
            UCHAR Type;                 // use CM_RESOURCE_TYPE
            UCHAR Reserved[3];
            PASSIGNED_RESOURCE AssignedResource;
            PHYSICAL_ADDRESS Transformation;
        } SubAllocateFrom;      // will be obsoleted

// begin_wdm

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;

// end_ntminiport


typedef struct _IO_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;

    ULONG Count;
    IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;


typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
    ULONG ListSize;
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    ULONG SlotNumber;
    ULONG Reserved[3];
    ULONG AlternativeLists;
    IO_RESOURCE_LIST  List[1];
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;

//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

//
// Define maximum number of exception parameters.
//

// begin_winnt
#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    ULONG ExceptionRecord;
    ULONG ExceptionAddress;
    ULONG NumberParameters;
    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG NumberParameters;
    ULONG __unusedAlignment;
    ULONG64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
// end_winnt


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrFsCacheIn,
    WrFsCacheOut,
    Spare4,
    Spare5,
    Spare6,
    WrKernel,
    MaximumWaitReason
    } KWAIT_REASON;

//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;


typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *RESTRICTED_POINTER NextWaitBlock;
    USHORT WaitKey;
    USHORT WaitType;
} KWAIT_BLOCK, *PKWAIT_BLOCK, *RESTRICTED_POINTER PRKWAIT_BLOCK;

//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

// end_wdm

//
// Thread system function
//

typedef
VOID
(*PKSYSTEM_ROUTINE) (
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    );

// begin_wdm
//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    UCHAR Size;
    BOOLEAN Busy;
    LIST_ENTRY DeviceListHead;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

//
// Define the interrupt service function type and the empty struct
// type.
//

typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );

//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
    BOOLEAN Abandoned;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT;

//
//
// Semaphore object
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;

//
//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

//
// DPC object
//

NTKERNELAPI
VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );

#define INITIALIZED_KDPC(_Dpc, _DeferredRoutine, _DeferredContext)  \
    KDPC _Dpc = {                                                   \
        DpcObject,                                                  \
        FALSE,                                                      \
        0,                                                          \
        NULL,                                                       \
        NULL,                                                       \
        _DeferredRoutine,                                           \
        _DeferredContext                                            \
    }

NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    );

DECLSPEC_NORETURN
VOID
KeRetireDpcListLoop(
    VOID
    );

//
// Device queue object
//

NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI                                         
BOOLEAN                                             
KeSynchronizeExecution (                            
    IN PKINTERRUPT Interrupt,                       
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
    IN PVOID SynchronizeContext                     
    );                                              
                                                    
//
// Kernel dispatcher object functions
//
// Event Object
//


NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );


#define KeClearEvent(Event) ((Event)->Header.SignalState = 0)

NTKERNELAPI
LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

#define KeReadStateEvent(Event) (Event)->Header.SignalState

// begin_wdm

NTKERNELAPI
LONG
KeResetEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

//
// Semaphore object
//

NTKERNELAPI
VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    );

#define KeReadStateSemaphore(Semaphore) (Semaphore)->Header.SignalState

NTKERNELAPI
LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    );

NTKERNELAPI                                         
NTSTATUS                                            
KeDelayExecutionThread (                            
    IN KPROCESSOR_MODE WaitMode,                    
    IN BOOLEAN Alertable,                           
    IN PLARGE_INTEGER Interval                      
    );                                              
                                                    
NTKERNELAPI                                         
LONG                                                
KeSetBasePriorityThread (                           
    IN PKTHREAD Thread,                             
    IN LONG Increment                               
    );                                              
NTKERNELAPI                                         
KPRIORITY                                           
KeSetPriorityThread (                               
    IN PKTHREAD Thread,                             
    IN KPRIORITY Priority                           
    );                                              
                                                    

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)) && !defined(_NTSYSTEM_DRIVER_)

// begin_wdm

NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );

NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );

// end_wdm

#else

//++
//
// VOID
// KeEnterCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function disables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeEnterCriticalRegion() KeGetCurrentThread()->KernelApcDisable -= 1;

//++
//
// VOID
// KeLeaveCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function enables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeLeaveCriticalRegion() KiLeaveCriticalRegion()

#endif

// begin_wdm

//
// Timer object
//

#define KeInitializeTimer(Timer) KeInitializeTimerEx(Timer, NotificationTimer)

NTKERNELAPI
VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    );

#define INITIALIZED_KTIMER(_Timer, _Type)                   \
    KTIMER _Timer = {                                       \
        TimerNotificationObject + _Type,                    \
        FALSE,                                              \
        sizeof(KTIMER) / sizeof(LONG),                      \
        FALSE,                                              \
        FALSE,                                              \
        &_Timer.Header.WaitListHead,                        \
        &_Timer.Header.WaitListHead                         \
    }

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );

#define KeClearTimer(Timer) ((Timer)->Header.SignalState = 0)

#define KeReadStateTimer(Timer) ((BOOLEAN)(Timer)->Header.SignalState)

NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    );

NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    );


NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray
    );

NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

//
// spin lock functions
//

#define KeInitializeSpinLock(a)             *(a) = 0

#define KeAcquireSpinLockAtDpcLevel(a)      ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)
#define KeReleaseSpinLockFromDpcLevel(a)

#define KeAcquireSpinLock(a,b)              *(b) = KeRaiseIrqlToDpcLevel()
#define KeReleaseSpinLock(a,b)              KeLowerIrql(b)

#define KeTryToAcquireSpinLock(a,b)         (KeAcquireSpinLock(a,b),TRUE)


#if defined(_X86_)

NTHALAPI
VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

NTHALAPI
KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

NTHALAPI
KIRQL
KeRaiseIrqlToDpcLevel(
    VOID
    );

NTHALAPI
KIRQL
KeRaiseIrqlToSynchLevel(
    VOID
    );

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

#endif

//
// Miscellaneous kernel functions
//

// end_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck (
    IN ULONG BugCheckCode
    );

// begin_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    );

// end_wdm

NTKERNELAPI
VOID
KeEnterKernelDebugger (
    VOID
    );


NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );

NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

#if !defined(_NTSYSTEM_)

#define KeQueryTickCount() *KeTickCount

#else

#define KeQueryTickCount() KeTickCount

#endif

#define KiQueryLowTickCount KeQueryTickCount

//
// Context swap notify routine.
//

typedef
VOID
(FASTCALL *PSWAP_CONTEXT_NOTIFY_ROUTINE)(
    IN HANDLE OldThreadId,
    IN HANDLE NewThreadId
    );

//
// Thread select notify routine.
//

typedef
LOGICAL
(FASTCALL *PTHREAD_SELECT_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId
    );

//
// Time update notify routine.
//

typedef
VOID
(FASTCALL *PTIME_UPDATE_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId,
    IN KPROCESSOR_MODE Mode
    );

//
// Define external data.
// because of indirection for all drivers external to ntoskrnl these are actually ptrs
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_XBDM_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;

#endif




typedef struct _DBGKD_DEBUG_DATA_HEADER64 *PDBGKD_DEBUG_DATA_HEADER64;

BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    );

VOID
KdDeregisterDebuggerDataBlock32(
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader
    );


NTKERNELAPI
PVOID
ExAllocatePool(
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b) ExAllocatePool(a)
#endif //POOL_TAGGING

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );

//

NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );

// end_ntndis

NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment
    );

// begin_wdm begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
LONGLONG
FASTCALL
ExInterlockedCompareExchange64 (
    IN PLONGLONG Destination,
    IN PLONGLONG Exchange,
    IN PLONGLONG Comperand
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead
    );

// begin_ntndis

//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables MIPS, Alpha, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
// The PowerPc, however, must use a spinlock to synchronize access to the
// list.
//
// N.B. A spinlock must be specified with SLIST operations. However, it may
//      not actually be used.
//

/*++

VOID
ExInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#define ExInitializeSListHead(_listhead_) (_listhead_)->Alignment = 0

/*++

USHORT
ExQueryDepthSList (
    IN PSLIST_HEADERT SListHead
    )

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#define ExQueryDepthSList(_listhead_) (USHORT)(_listhead_)->Depth

#if !defined(_WINBASE_)

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#endif

// end_ntndis
//
// Raise status from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseStatus (
    IN NTSTATUS Status
    );


//
// UUID Generation
//

typedef GUID UUID;

//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0

//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

// end_ntifs
//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6

// begin_ntifs
//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

// end_ntifs
//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6

// begin_ntifs
//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

// end_ntifs
//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1


//++
//
// ULONG_PTR
// ROUND_TO_PAGES(
//     IN ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES(
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  ((ULONG)((ULONG_PTR)(Size) >> PAGE_SHIFT) + \
                               (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// ULONG
// BYTE_OFFSET_LARGE(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the large page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET_LARGE(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE_LARGE - 1)))

//++
//
// PVOID
// PAGE_ALIGN(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN_LARGE(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN_LARGE(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE_LARGE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES(
//     IN PVOID Va,
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
   (((((Size) - 1) >> PAGE_SHIFT) + \
   (((((ULONG)(Size-1)&(PAGE_SIZE-1)) + (PtrToUlong(Va) & (PAGE_SIZE -1)))) >> PAGE_SHIFT)) + 1L)

#define COMPUTE_PAGES_SPANNED(Va, Size) \
    ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))


NTKERNELAPI
VOID
MmLockUnlockBufferPages(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN UnlockPages
    );

NTKERNELAPI
VOID
MmLockUnlockPhysicalPage(
    IN ULONG_PTR PhysicalAddress,
    IN BOOLEAN UnlockPage
    );

// begin_wdm

NTKERNELAPI
PVOID
MmMapIoSpace(
    IN ULONG_PTR PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
VOID
MmUnmapIoSpace(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );


NTKERNELAPI
ULONG_PTR
MmGetPhysicalAddress(
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemory(
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemoryEx(
    IN SIZE_T NumberOfBytes,
    IN ULONG_PTR LowestAcceptableAddress,
    IN ULONG_PTR HighestAcceptableAddress,
    IN ULONG_PTR Alignment,
    IN ULONG Protect
    );

NTKERNELAPI
VOID
MmFreeContiguousMemory(
    IN PVOID BaseAddress
    );

NTKERNELAPI
VOID
MmPersistContiguousMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN Persist
    );

NTKERNELAPI
PVOID
MmAllocateSystemMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
ULONG
MmFreeSystemMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
SIZE_T
MmQueryAllocationSize(
    IN PVOID BaseAddress
    );

NTKERNELAPI
ULONG
MmQueryAddressProtect(
    IN PVOID VirtualAddress
    );

NTKERNELAPI
VOID
MmSetAddressProtect(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes,
    IN ULONG NewProtect
    );

NTKERNELAPI
BOOLEAN
MmIsAddressValid(
    IN PVOID VirtualAddress
    );

//
// System Thread and Process Creation and Termination
//

NTKERNELAPI
NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN DebuggerThread
    );

NTKERNELAPI
NTSTATUS
PsCreateSystemThreadEx(
    OUT PHANDLE ThreadHandle,
    IN SIZE_T ThreadExtensionSize,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN CreateSuspended,
    IN BOOLEAN DebuggerThread,
    IN PKSYSTEM_ROUTINE SystemRoutine OPTIONAL
    );

DECLSPEC_NORETURN
NTKERNELAPI
VOID
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );


typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
    IN PETHREAD Thread,
    IN HANDLE ThreadId,
    IN BOOLEAN Create
    );

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009

//
// Define the major function codes for IRPs.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CLOSE                    0x01
#define IRP_MJ_READ                     0x02
#define IRP_MJ_WRITE                    0x03
#define IRP_MJ_QUERY_INFORMATION        0x04
#define IRP_MJ_SET_INFORMATION          0x05
#define IRP_MJ_FLUSH_BUFFERS            0x06
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x07
#define IRP_MJ_DIRECTORY_CONTROL        0x08
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x09
#define IRP_MJ_DEVICE_CONTROL           0x0a
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0b
#define IRP_MJ_SHUTDOWN                 0x0c
#define IRP_MJ_CLEANUP                  0x0d
#define IRP_MJ_MAXIMUM_FUNCTION         0x0d

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

// end_ntndis

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_OPEN_TARGET_DIRECTORY        0x0004
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;

// end_wdm

// begin_wdm begin_ntndis
//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver device object deletion routine type.
//

typedef
VOID
(*PDRIVER_DELETEDEVICE) (
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define driver dismount volume routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISMOUNTVOLUME) (
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define Device Object (DO) flags
//
#define DO_EXCLUSIVE                    0x00000002      
#define DO_DIRECT_IO                    0x00000004      
#define DO_DEVICE_HAS_NAME              0x00000008      
#define DO_DEVICE_INITIALIZING          0x00000010      
//
// Device Object structure definition
//

typedef struct _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *MountedOrSelfDevice;
    struct _IRP *CurrentIrp;
    ULONG Flags;                                // See above:  DO_...
    PVOID DeviceExtension;
    UCHAR DeviceType;
    UCHAR StartIoFlags;
    CCHAR StackSize;
    BOOLEAN DeletePending;
    ULONG SectorSize;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KEVENT DeviceLock;
    ULONG StartIoKey;
} DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis

typedef struct _DRIVER_OBJECT {

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_DELETEDEVICE DriverDeleteDevice;
    PDRIVER_DISMOUNTVOLUME DriverDismountVolume;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_SYNCHRONOUS_IO               0x00000001
#define FO_ALERTABLE_IO                 0x00000002
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000004
#define FO_SEQUENTIAL_ONLY              0x00000008
#define FO_CLEANUP_COMPLETE             0x00000010
#define FO_HANDLE_CREATED               0x00000020
#define FO_RANDOM_ACCESS                0x00000040

#include "pshpack4.h"

typedef struct _FILE_OBJECT {
    CSHORT Type;
    BOOLEAN DeletePending : 1;
    BOOLEAN ReadAccess : 1;
    BOOLEAN WriteAccess : 1;
    BOOLEAN DeleteAccess : 1;
    BOOLEAN SharedRead : 1;
    BOOLEAN SharedWrite : 1;
    BOOLEAN SharedDelete : 1;
    BOOLEAN Reserved : 1;
    UCHAR Flags;
    PDEVICE_OBJECT DeviceObject;
    PVOID FsContext;
    PVOID FsContext2;
    NTSTATUS FinalStatus;
    LARGE_INTEGER CurrentByteOffset;
    struct _FILE_OBJECT *RelatedFileObject;
    PIO_COMPLETION_CONTEXT CompletionContext;
    LONG LockCount;
    KEVENT Lock;
    KEVENT Event;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

#include "poppack.h"

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_CREATE_OPERATION            0x00000008
#define IRP_READ_OPERATION              0x00000010
#define IRP_WRITE_OPERATION             0x00000020
#define IRP_CLOSE_OPERATION             0x00000040
// end_wdm

#define IRP_DEFER_IO_COMPLETION         0x00000080
#define IRP_OB_QUERY_NAME               0x00000100
#define IRP_UNLOCK_USER_BUFFER          0x00000200
#define IRP_SCATTER_GATHER_OPERATION    0x00000400
#define IRP_UNMAP_SEGMENT_ARRAY         0x00000800
#define IRP_NO_CANCELIO                 0x00001000

// begin_wdm
//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // If this is a scatter/gather I/O request, then the individual pages for
    // the request can be obtained via this array.
    //

    PFILE_SEGMENT_ELEMENT SegmentArray;

    //
    // Stores the number of bytes that were locked down for direct I/O.
    //

    ULONG LockedBufferLength;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[5];
                } ;
            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_MUST_COMPLETE                0x02
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_FSCACHE_REQUEST              0x80

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define I/O Request Packet (IRP) stack locations
//

#include "pshpack4.h"

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            ACCESS_MASK DesiredAccess;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            POBJECT_STRING RemainingName;
        } Create;

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            union {
                ULONG BufferOffset;
                PVOID CacheBuffer;
            };
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            union {
                ULONG BufferOffset;
                PVOID CacheBuffer;
            };
            LARGE_INTEGER ByteOffset;
        } Write;


        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
        } SetFile;

        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;


        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //


        //
        // System service parameters for:  NtDeviceIoControlFile
        //

        struct {
            ULONG OutputBufferLength;
            PVOID InputBuffer;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
        } DeviceIoControl;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //


        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;

#include "poppack.h"

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    UCHAR OpenCount;
    UCHAR Readers;
    UCHAR Writers;
    UCHAR Deleters;
    UCHAR SharedRead;
    UCHAR SharedWrite;
    UCHAR SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

//
// Public I/O routine definitions
//

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)


NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN POBJECT_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

// end_nthal

NTKERNELAPI
NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN ULONG Options
    );


NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName,
    IN POBJECT_STRING DeviceName
    );

NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName
    );

NTKERNELAPI
NTSTATUS
IoDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDismountVolumeByName(
    IN POBJECT_STRING DeviceName
    );

NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )

// end_nthal

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

// begin_nthal

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )


NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );


NTKERNELAPI
NTSTATUS
IoInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))


//  begin_wdm

NTKERNELAPI
VOID
IoMarkIrpMustComplete(
    IN OUT PIRP Irp
    );

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )


NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

//  begin_wdm

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    irpSp->CompletionRoutine = (Routine);                                   \
    irpSp->Context = (CompletionContext);                                   \
    irpSp->Control = 0;                                                     \
    if ((Success)) { irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { irpSp->Control |= SL_INVOKE_ON_CANCEL; } }

//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION irpSp; \
    PIO_STACK_LOCATION nextIrpSp; \
    irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++;

NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );


//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

// end_ntifs


NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL
    );

// begin_ntifs

//
// I/O driver configuration functions.
//

NTHALAPI
VOID
HalReadWritePCISpace(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG RegisterNumber,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN WritePCISpace
    );

#define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
    HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)

#define HalWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
    HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, TRUE)

NTHALAPI
ULONG
HalGetInterruptVector(
    IN ULONG BusInterruptLevel,
    OUT PKIRQL Irql
    );

#include <pshpack1.h>

typedef struct _PCI_DEVICE_ADDRESS {
    UCHAR     Type;  //CmResourceType
    UCHAR     Valid;
    UCHAR     Reserved[2];

    union {

        struct {
            PVOID TranslatedAddress;
            ULONG Length;
        } Port;

        struct {
            PVOID TranslatedAddress;
            ULONG Length;
        } Memory;

    } u;

} PCI_DEVICE_ADDRESS, *PPCI_DEVICE_ADDRESS;

typedef struct _PCI_DEVICE_DESCRIPTOR {
    ULONG     Bus;
    ULONG     Slot;
    USHORT    VendorID;
    USHORT    DeviceID;

    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    UCHAR     Reserved[1];

    struct {

        PCI_DEVICE_ADDRESS Address[1];

        struct {
            ULONG Vector;
            ULONG Affinity;
            KIRQL Irql;         // KIRQL is uchar!

        } Interrupt;

    } ResourceData;

} PCI_DEVICE_DESCRIPTOR, *PPCI_DEVICE_DESCRIPTOR;

#include <poppack.h>

//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter(
    VOID
    );

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceFrequency(
    VOID
    );

//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor(
    IN ULONG MicroSeconds
    );

// end_wdm

DECLSPEC_NORETURN
NTHALAPI
VOID
HalHaltSystem(
    VOID
    );


NTKERNELAPI
NTSTATUS
ObCreateObject(
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectBodySize,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByHandle(
    IN HANDLE Handle,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *Object
    );

NTKERNELAPI
VOID
ObMakeTemporaryObject(
    IN PVOID Object
    );

NTKERNELAPI
VOID
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    );

#define ObReferenceObject(Object) ObfReferenceObject(Object)

NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType
    );

NTKERNELAPI
VOID
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    );

#define ObDereferenceObject(Object) ObfDereferenceObject(Object)


//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_wdm begin_ntminiport begin_ntndis

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_wdm end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_wdm begin_ntminiport begin_ntndis

    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_ntminiport



#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' kdD')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,' kdD')
#endif

extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *ExSemaphoreObjectType;

//
// Define exported ZwXxx routines to device drivers.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

NTSTATUS
ZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    );

NTSTATUS
ZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
ZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    );

NTSTATUS
ZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN WakeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    );

#ifdef __cplusplus
}    // extern "C"
#endif

#endif // _NTDDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\ddk\inc\usb.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    usb.h

    Generated from usb.x

Abstract:

    Header File for all class drivers

Environment:

    Xbox
    C++ Only

--*/

#ifndef __USB_X__
#define __USB_X__

#ifndef __cplusplus
#error "usb.h may only be included by C++ modules"
#endif

#define EXTERNUSB extern "C"

//
//	USB drivers, and XAPI code modules that rely on USB all go into 
//	the XPP section.
//
#pragma code_seg(".XPPCODE")
#pragma data_seg(".XPP$Data")
#pragma const_seg(".XPPRDATA")

#include <usb100.h>

//
// XBOX platform USB device classes
//

#define XBOX_DEVICE_CLASS_INPUT_DEVICE              0x58
#define XBOX_DEVICE_CLASS_XDCS                      0x59
#define XBOX_DEVICE_CLASS_AUDIO_DEVICE              0x78

//
// USBD status codes
//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+---------------------------+-------------------------------+
//  | S |               Status Code                                 |
//  +---+---------------------------+-------------------------------+
//
//  where
//
//      S - is the state code
//
//          00 - completed with success
//          01 - request is pending
//          10 - completed with error, endpoint not stalled
//          11 - completed with error, endpoint stalled
//
//
//      Code - is the status code
//

typedef LONG USBD_STATUS;

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
//  Macro to ensure that error bit is set.
//
#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)


//
// Generic test for stall on any status value.
//

#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
#define USBD_STATUS_HALTED                   ((USBD_STATUS)0xC0000000L)
#define USBD_STATUS_ERROR                    ((USBD_STATUS)0x80000000L)

//
// HC status codes
// Note: these status codes have both the error and the stall bit set.
//
#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000EL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

//
// HC status codes
// Note: these status codes have the error bit and not the stall bit set.
//
#define USBD_ISOCH_STATUS_CRC                      (1)
#define USBD_ISOCH_STATUS_BTSTUFF                  (2)
#define USBD_ISOCH_STATUS_DATA_TOGGLE_MISMATCH     (3)
#define USBD_ISOCH_STATUS_STALL_PID                (4)
#define USBD_ISOCH_STATUS_DEV_NOT_RESPONDING       (5)
#define USBD_ISOCH_STATUS_PID_CHECK_FAILURE        (6)
#define USBD_ISOCH_STATUS_UNEXPECTED_PID           (7)
#define USBD_ISOCH_STATUS_DATA_OVERRUN             (8)
#define USBD_ISOCH_STATUS_DATA_UNDERRUN            (9)
#define USBD_ISOCH_STATUS_RESERVED1                (A)
#define USBD_ISOCH_STATUS_RESERVED2                (B)
#define USBD_ISOCH_STATUS_BUFFER_OVERRUN           (C)
#define USBD_ISOCH_STATUS_BUFFER_UNDERRUN          (D)
#define USBD_ISOCH_STATUS_NOT_ACCESSED             (E)

//
// returned by HCD if a transfer is submitted to an endpoint that is 
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED         ((USBD_STATUS)0xC0000030L)

//
// Software status codes
// Note: the following status codes have only the error bit set
//
#define USBD_STATUS_NO_MEMORY                ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)
#define USBD_STATUS_UNSUPPORTED_DEVICE       ((USBD_STATUS)0x80000400L)
#define USBD_STATUS_TRANSFER_TOO_LONG        ((USBD_STATUS)0x80000500L)

//
// returned by USBD if it cannot complete a URB request, typically this 
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000600L)

#define USBD_STATUS_NO_DEVICE                ((USBD_STATUS)0x80000700L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000800L)
//
// generic HC error
// 
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000900L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
// 
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000A00L)


// 
// returned if the requested start frame is not within
// USBD_ISOCH_START_FRAME_RANGE of the current USB frame, 
// note that the stall bit is set
// 
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000B00L)
//
// returned by HCD if all packets in an iso transfer complete with an error 
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000C00L)
//
// returned by HCD if an attempt is made to attach more isoch
// buffers to an endpoint than specified as the maximum when opening
// the endpoint.
//
#define USBD_STATUS_ISOCH_TOO_MANY_BUFFERS   ((USBD_STATUS)0xC0000D00L)
//
// returned by HCD if an attempt is made to start an endpoint which is
// already started.
//
#define USBD_STATUS_ISOCH_ALREADY_STARTED    ((USBD_STATUS)0xC0000E00L)
//
// returned by HCD if an attempt is made to stop an endpoint which is
// not already started.
//
#define USBD_STATUS_ISOCH_NOT_STARTED        ((USBD_STATUS)0xC0000F00L)
//
// returned by HCD if an attempt is made to start an endpoint setup for
// circular DMA with fewer than MaxAttachedBuffers,
//
#define USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS ((USBD_STATUS)0xC0001000L)
//
// This build of the usb driver does not support isochronous requests.
//
#define USBD_STATUS_ISOCH_NOT_SUPPORTED      ((USBD_STATUS)0xC0002000L)
//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_CANCELING                ((USBD_STATUS)0x40020000L)

//
//	Status returned by hub, when a reset completes successfully and the
//	device is low-speed.
//
#define USBD_STATUS_LOWSPEED				 ((USBD_STATUS)0x01000000L)

extern "C" {

//------------------------------------------------------------------------------------
// URB Function Codes   - High bit indicates that USBD (pre-)processes URB
//------------------------------------------------------------------------------------
//-- special bit in URB_FUNCTION codes -----------------
#define URB_FUNCTION_USBD_PROCESSED                 0x80    
#define URB_FUNCTION_ASYNCHRONOUS                   0x40
//------------------------------------------------------
#define URB_FUNCTION_CONTROL_TRANSFER               (0x00 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER     (0x01 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_OPEN_ENDPOINT                  0x02
#define URB_FUNCTION_CLOSE_ENDPOINT                 (0x03 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_ENDPOINT_STATE             0x04
#define URB_FUNCTION_SET_ENDPOINT_STATE             0x05
#define URB_FUNCTION_ABORT_ENDPOINT                 (0x06 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_FRAME_NUMBER               0x07
#define URB_FUNCTION_OPEN_DEFAULT_ENDPOINT          (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_OPEN_ENDPOINT)
#define URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT         (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_CLOSE_ENDPOINT)
#define URB_FUNCTION_RESET_PORT                     (URB_FUNCTION_USBD_PROCESSED | 0x08)
#define URB_FUNCTION_ISOCH_OPEN_ENDPOINT            0x09
#define URB_FUNCTION_ISOCH_CLOSE_ENDPOINT           (0x0A | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_ISOCH_ATTACH_BUFFER            0x0B
#define URB_FUNCTION_ISOCH_START_TRANSFER           0x0C
#define URB_FUNCTION_ISOCH_STOP_TRANSFER            0x0D

//------------------------------------------------------------------------------------
//  Values for the transfer directions
//------------------------------------------------------------------------------------
#define USB_TRANSFER_DIRECTION_OUT              0x01
#define USB_TRANSFER_DIRECTION_IN               0x02

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_GET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_HALTED              	0x01    //Set on return if endpoint is halted.
#define USB_ENDPOINT_STATE_TRANSFERS_QUEUED     0x02    //Set on return if one or more transfers are queued to endpoint.

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_SET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_CLEAR_HALT		    0x00    //Clear endpoint halt.
#define USB_ENDPOINT_STATE_KEEP_HALT		    0x01    //Do not clear enddpoint halt
#define USB_ENDPOINT_STATE_DATA_TOGGLE_RESET    0x04    //Reset data toggle. (i.e. DATA0)
#define USB_ENDPOINT_STATE_DATA_TOGGLE_SET      0x08    //Set data toggle. (i.e. DATA1), provided for testing.
//There is no USB_ENDPOINT_STATE_SET_HALT, since only the hardware may set it.

//----------------------------------------------------------------------------------------------------------------------
// Macros for the InterruptDelay variable in transfer and attach buffer URBs - this is really an OpenHCI thing,
// but gives more control to class drivers.  These are the same as OHCI_TD_DELAY_INTERRUPT_XXX
// DUE TO BUG 9512 IT IS ONLY SAFE TO USE USBD_DELAY_INTERRUPT_0_MS.  OTHERWISE, YOU MAY EXPERIENCE PROBLEMS
// WHEN CLOSING THE ENDPOINT.  SEE BUG 9512 FOR MORE DETAILS.
//----------------------------------------------------------------------------------------------------------------------
#define USBD_DELAY_INTERRUPT_0_MS        0   // Interrupt at end of frame TD is completed
#define USBD_DELAY_INTERRUPT_1_MS        1   // Interrupt within 1 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_2_MS        2   // Interrupt within 2 frames of TD compeletion
#define USBD_DELAY_INTERRUPT_3_MS        3   // Interrupt within 3 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_4_MS        4   // Interrupt within 4 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_5_MS        5   // Interrupt within 5 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_6_MS        6   // Interrupt within  frame of TD compeletion
#define USBD_DELAY_INTERRUPT_NONE        7   // Do not Interrupt upon completion of TD

//------------------------------------------------------------------------------------
// USBD Structures for class drivers
//------------------------------------------------------------------------------------
typedef union _URB *PURB;
typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

//
//  See approptate HCD header file for
//  for flags.
//
struct _URB_HCD_AREA
{
    union
    {
        USHORT  HcdTDCount;
        USHORT  HcdOriginalLength;  //While programed contains the original length
    
	};
    USHORT  HcdUrbFlags;
	PURB    HcdUrbLink;     //Used while the URB is pending
};

struct _URB_HEADER
{
    UCHAR               Length;
    UCHAR               Function;
    USBD_STATUS         Status;
    PURB_COMPLETE_PROC  CompleteProc;       // A completetion routine if the URB is not associated with an Irp
    PVOID               CompleteContext;    // Context to pass into the completion routine.
};

typedef struct _USB_CONTROL_SETUP_PACKET
{
    UCHAR   bmRequestType;
    UCHAR   bRequest;
    USHORT  wValue;
    USHORT  wIndex;
    USHORT  wLength;
} USB_CONTROL_SETUP_PACKET;

typedef struct _URB_CONTROL_TRANSFER
{
    struct _URB_HEADER          Hdr;                    
    PVOID                       EndpointHandle;
    ULONG                       TransferBufferLength;
    PVOID                       TransferBuffer;
    UCHAR                       TransferDirection;
    BOOLEAN                     ShortTransferOK;
    UCHAR                       InterruptDelay;
    UCHAR                       Padding;
    struct _URB_HCD_AREA        Hca;
    USB_CONTROL_SETUP_PACKET    SetupPacket;
} URB_CONTROL_TRANSFER, *PURB_CONTROL_TRANSFER;

typedef struct _URB_BULK_OR_INTERRUPT_TRANSFER
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   TransferBufferLength;
    PVOID                   TransferBuffer;
    UCHAR                   TransferDirection;
    BOOLEAN                 ShortTransferOK;
    UCHAR                   InterruptDelay;
    UCHAR                   Padding;
    struct _URB_HCD_AREA    Hca;   // fields for HCD use
} URB_BULK_OR_INTERRUPT_TRANSFER, *PURB_BULK_OR_INTERRUPT_TRANSFER;


typedef struct _URB_OPEN_ENDPOINT
{
    struct _URB_HEADER          Hdr;
    PVOID                       EndpointHandle;
    UCHAR                       FunctionAddress;
    UCHAR                       EndpointAddress;
    UCHAR                       EndpointType;
    UCHAR                       Interval;
    PULONG                      DataToggleBits; // Filled out by USBD
    USHORT                      MaxPacketSize;
    BOOLEAN                     LowSpeed;   //Temporary - filled out by USBD
} URB_OPEN_ENDPOINT, *PURB_OPEN_ENDPOINT;

typedef struct _URB_CLOSE_ENDPOINT
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    PURB                   HcdNextClose;   // An extra pointer which Hcd can use to link pending closes.
    PULONG                 DataToggleBits; // Filled out by USBD
} URB_CLOSE_ENDPOINT, *PURB_CLOSE_ENDPOINT;

typedef struct _URB_GET_SET_ENDPOINT_STATE
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   EndpointState;
} URB_GET_SET_ENDPOINT_STATE, *PURB_GET_SET_ENDPOINT_STATE;

typedef struct _URB_ABORT_ENDPOINT
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    PURB                    HcdNextAbort;   // An extra pointer which Hcd can use to link pending aborts.
} URB_ABORT_ENDPOINT, *PURB_ABORT_ENDPOINT;

typedef struct _URB_RESET_PORT
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    UCHAR               PortNumber;
} URB_RESET_PORT, *PURB_RESET_PORT;

typedef struct _URB_GET_FRAME_NUMBER
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    ULONG               FrameNumber;
} URB_GET_FRAME_NUMBER, *PURB_GET_FRAME_NUMBER;


//------------------------------------------------
// Isoch related URBs and related structures
//------------------------------------------------
typedef struct _USBD_ISOCH_PACKET_STATUS_WORD
{
    USHORT BytesRead:12;
    USHORT ConditionCode:4;
} USBD_ISOCH_PACKET_STATUS_WORD, *PUSBD_ISOCH_PACKET_STATUS_WORD;

typedef struct _USBD_ISOCH_TRANSFER_STATUS
{
    USBD_STATUS                     Status;
    ULONG                           FrameCount;
    USBD_ISOCH_PACKET_STATUS_WORD   PacketStatus[8];
} USBD_ISOCH_TRANSFER_STATUS, *PUSBD_ISOCH_TRANSFER_STATUS;

typedef VOID (*PFNUSBD_ISOCH_TRANSFER_COMPLETE)(PUSBD_ISOCH_TRANSFER_STATUS Status, PVOID Context);

typedef struct _USBD_ISOCH_BUFFER_DESCRIPTOR
{
    ULONG                               FrameCount;
    PVOID                               TransferBuffer;
    USHORT                              Pattern[8];
    PFNUSBD_ISOCH_TRANSFER_COMPLETE     TransferComplete;
    PVOID                               Context;
} USBD_ISOCH_BUFFER_DESCRIPTOR, *PUSBD_ISOCH_BUFFER_DESCRIPTOR;

typedef struct _URB_ISOCH_ATTACH_BUFFER
{
    struct _URB_HEADER            Hdr;
    PVOID                         EndpointHandle;
    UCHAR                         InterruptDelay;
    PUSBD_ISOCH_BUFFER_DESCRIPTOR BufferDescriptor;
} URB_ISOCH_ATTACH_BUFFER, *PURB_ISOCH_ATTACH_BUFFER;

typedef struct _URB_ISOCH_START_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    ULONG                  FrameNumber;
    ULONG                  Flags;
} URB_ISOCH_START_TRANSFER, *PURB_ISOCH_START_TRANSFER;
#define URB_FLAG_ISOCH_START_ASAP 0x0001
#define USBD_ISOCH_START_FRAME_RANGE 1024

typedef struct _URB_ISOCH_STOP_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
} URB_ISOCH_STOP_TRANSFER, *PURB_ISOCH_STOP_TRANSFER;

typedef struct _URB_ISOCH_OPEN_ENDPOINT
{
    struct _URB_HEADER              Hdr;
    PVOID                           EndpointHandle;
    UCHAR                           FunctionAddress;
    UCHAR                           EndpointAddress;
    USHORT                          MaxPacketSize;
    USHORT                          Flags;
    USHORT                          Pad;
} URB_ISOCH_OPEN_ENDPOINT, *PURB_ISOCH_OPEN_ENDPOINT;
#define URB_FLAG_ISOCH_CIRCULAR_DMA 0x0001

typedef struct _URB_CLOSE_ENDPOINT URB_ISOCH_CLOSE_ENDPOINT, *PURB_ISOCH_CLOSE_ENDPOINT;

//------------------------------------------------
// Union of all URBs
//------------------------------------------------
typedef union _URB
{
    struct _URB_HEADER              Header;
    URB_CONTROL_TRANSFER            ControlTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  BulkOrInterruptTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  CommonTransfer;
    URB_OPEN_ENDPOINT               OpenEndpoint;
    URB_CLOSE_ENDPOINT              CloseEndpoint;
    URB_GET_SET_ENDPOINT_STATE      GetSetEndpointState;
    URB_ABORT_ENDPOINT              AbortEndpoint;
    URB_RESET_PORT                  ResetPort;
    URB_GET_FRAME_NUMBER            GetFrame;
    URB_ISOCH_ATTACH_BUFFER         IsochAttachBuffer;
    URB_ISOCH_START_TRANSFER        IsochStartTransfer;
    URB_ISOCH_STOP_TRANSFER         IsochStopTransfer;
    URB_ISOCH_OPEN_ENDPOINT         IsochOpenEndpoint;
    URB_ISOCH_CLOSE_ENDPOINT        IsochCloseEndpoint;
} URB;

//------------------------------------------------------------------------------------
// Macros to build USB Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CONTROL_TRANSFER(\
                        _UrbControlTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_,\
                        _bmRequestType_,\
                        _bRequest_,\
                        _wValue_,\
                        _wIndex_,\
                        _wLength_\
    )\
    {\
        (_UrbControlTransfer_)->Hdr.Length                  =   sizeof(URB_CONTROL_TRANSFER);\
        (_UrbControlTransfer_)->Hdr.Function                =   URB_FUNCTION_CONTROL_TRANSFER;\
        (_UrbControlTransfer_)->Hdr.CompleteProc            =   (_CompleteProc_);\
        (_UrbControlTransfer_)->Hdr.CompleteContext         =   (_CompleteContext_);\
        (_UrbControlTransfer_)->EndpointHandle              =   (_EndpointHandle_);\
        (_UrbControlTransfer_)->TransferBuffer              =   (_TransferBuffer_);\
        (_UrbControlTransfer_)->TransferBufferLength        =   (_TransferBufferLength_);\
        (_UrbControlTransfer_)->TransferDirection           =   (_TransferDirection_);\
        (_UrbControlTransfer_)->ShortTransferOK             =   (_ShortTransferOK_);\
        (_UrbControlTransfer_)->InterruptDelay              =   USBD_DELAY_INTERRUPT_0_MS;\
        (_UrbControlTransfer_)->SetupPacket.bmRequestType   =   (_bmRequestType_);\
        (_UrbControlTransfer_)->SetupPacket.bRequest        =   (_bRequest_);\
        (_UrbControlTransfer_)->SetupPacket.wValue          =   (_wValue_);\
        (_UrbControlTransfer_)->SetupPacket.wIndex          =   (_wIndex_);\
        (_UrbControlTransfer_)->SetupPacket.wLength         =   (_wLength_);\
    }


#define USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(\
                        _UrbBulkOrInterruptTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_\
    )\
    {\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Length          =   sizeof(URB_BULK_OR_INTERRUPT_TRANSFER);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Function        =   URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteProc    =   (_CompleteProc_);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteContext =   (_CompleteContext_);\
        (_UrbBulkOrInterruptTransfer_)->EndpointHandle      =   (_EndpointHandle_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBuffer      =   (_TransferBuffer_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBufferLength=   (_TransferBufferLength_);\
        (_UrbBulkOrInterruptTransfer_)->TransferDirection   =   (_TransferDirection_);\
        (_UrbBulkOrInterruptTransfer_)->ShortTransferOK     =   (_ShortTransferOK_);\
        (_UrbBulkOrInterruptTransfer_)->InterruptDelay      =   USBD_DELAY_INTERRUPT_0_MS;\
    }

//
// Isoch requests
//

#define USB_BUILD_ISOCH_OPEN_ENDPOINT(\
                        _UrbIsochOpenEndpoint_,\
                        _EndpointAddress_,\
                        _MaxPacketSize_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochOpenEndpoint_)->Hdr.Length         =   sizeof(URB_ISOCH_OPEN_ENDPOINT);\
        (_UrbIsochOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_ISOCH_OPEN_ENDPOINT;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteContext=   NULL;\
        (_UrbIsochOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbIsochOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
        (_UrbIsochOpenEndpoint_)->Flags              =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_CLOSE_ENDPOINT(\
                        _UrbIsochCloseEndpoint_,\
                        _EndpointHandle_,\
						_CompleteProc_,\
						_CompleteContext_\
    )\
    {\
        (_UrbIsochCloseEndpoint_)->Hdr.Length           =   sizeof(URB_ISOCH_CLOSE_ENDPOINT);\
        (_UrbIsochCloseEndpoint_)->Hdr.Function         =   URB_FUNCTION_ISOCH_CLOSE_ENDPOINT;\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteProc     =   (_CompleteProc_);\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteContext  =   (_CompleteContext_);\
        (_UrbIsochCloseEndpoint_)->EndpointHandle       =   (_EndpointHandle_);\
    }

#define USB_BUILD_ISOCH_START_TRANSFER(\
                        _UrbIsochStartTransfer_,\
                        _EndpointHandle_,\
                        _FrameNumber_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochStartTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_START_TRANSFER);\
        (_UrbIsochStartTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_START_TRANSFER;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStartTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochStartTransfer_)->FrameNumber          =   (_FrameNumber_);\
        (_UrbIsochStartTransfer_)->Flags                =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_STOP_TRANSFER(\
                        _UrbIsochStopTransfer_,\
                        _EndpointHandle_\
    )\
    {\
        (_UrbIsochStopTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_STOP_TRANSFER);\
        (_UrbIsochStopTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_STOP_TRANSFER;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStopTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
    }


#define USB_BUILD_ISOCH_ATTACH_BUFFER(\
                        _UrbIsochAttachBuffer_,\
                        _EndpointHandle_,\
                        _InterruptDelay_,\
                        _BufferDescriptor_\
    )\
    {\
        (_UrbIsochAttachBuffer_)->Hdr.Length            =   sizeof(URB_ISOCH_ATTACH_BUFFER);\
        (_UrbIsochAttachBuffer_)->Hdr.Function          =   URB_FUNCTION_ISOCH_ATTACH_BUFFER;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteProc      =   NULL;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteContext   =   NULL;\
        (_UrbIsochAttachBuffer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochAttachBuffer_)->InterruptDelay       =   (_InterruptDelay_);\
        (_UrbIsochAttachBuffer_)->BufferDescriptor     =   (_BufferDescriptor_);\
    }

//
// Bulk or Interrupt requests
//

#define USB_BUILD_OPEN_ENDPOINT(\
                        _UrbOpenEndpoint_,\
                        _EndpointAddress_,\
                        _EndpointType_,\
                        _MaxPacketSize_,\
                        _Interval_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbOpenEndpoint_)->EndpointType       =   (_EndpointType_);\
        (_UrbOpenEndpoint_)->Interval           =   (_Interval_);\
        (_UrbOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
    }

#define USB_BUILD_CLOSE_ENDPOINT(\
                        _UrbCloseEndpoint_,\
                        _EndpointHandle_,\
                        _CompleteProc_,\
                        _CompleteContext_\
    )\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
        (_UrbCloseEndpoint_)->EndpointHandle    =   (_EndpointHandle_);\
    }

#define USB_BUILD_OPEN_DEFAULT_ENDPOINT(\
                            _UrbOpenEndpoint_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_DEFAULT_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
    }

#define USB_BUILD_CLOSE_DEFAULT_ENDPOINT(_UrbCloseEndpoint_, _CompleteProc_, _CompleteContext_)\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
    }

#define USB_BUILD_GET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_GET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_SET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_, _StateFlags_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_SET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
    (_UrbGetSetEndpointState_)->EndpointState       =   (_StateFlags_);\
}

#define USB_BUILD_ABORT_ENDPOINT(_UrbAbortEndpoint_, _EndpointHandle_, _CompleteProc_, _CompleteContext_)\
{\
    (_UrbAbortEndpoint_)->Hdr.Length          =   sizeof(URB_ABORT_ENDPOINT);\
    (_UrbAbortEndpoint_)->Hdr.Function        =   URB_FUNCTION_ABORT_ENDPOINT;\
    (_UrbAbortEndpoint_)->Hdr.CompleteProc    =   (_CompleteProc_);\
	(_UrbAbortEndpoint_)->Hdr.CompleteContext =   (_CompleteContext_);\
    (_UrbAbortEndpoint_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_RESET_PORT(_UrbResetPort_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_RESET_PORT);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_RESET_PORT;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

#define USB_BUILD_GET_FRAME(_UrbGetFrame_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_GET_FRAME);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_GET_FRAME;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

//------------------------------------------------------------------------------------
// Macros to build standard USB Command Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CLEAR_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_CLEAR_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_SET_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_GET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Configuration_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_Configuration_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = TRUE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}

#define USB_BUILD_SET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_OUT;\
    (_UrbControlTransfer_)->ShortTransferOK             = FALSE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}


#define USB_BUILD_GET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_AlternateSetting_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_AlternateSetting_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_STATUS(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _Index_,\
                _Status_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Status_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|(_Recipient_));\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_STATUS;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

#define USB_BUILD_SYNC_FRAME(\
                _UrbControlTransfer_,\
                _Endpoint_,\
                _Frame_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Frame_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|USB_COMMAND_TO_ENDPOINT);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SYNC_FRAME;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Endpoint_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

//-------------------------------------------------------------------------------------------------------------
// Get the USB status code
//-------------------------------------------------------------------------------------------------------------
#define URB_STATUS(urb) ((urb)->Header.Status)
} //end of 'extern "C"'
//------------------------------------------------------------------------------------
// bmRequestType values for commands over control pipes, belongs in usb100.h
//------------------------------------------------------------------------------------

//  Data Direction
#define USB_HOST_TO_DEVICE              0x00    
#define USB_DEVICE_TO_HOST              0x80

//  Type
#define USB_STANDARD_COMMAND            0x00
#define USB_CLASS_COMMAND               0x20
#define USB_VENDOR_COMMAND              0x40

//  Recipient
#define USB_COMMAND_TO_DEVICE           0x00
#define USB_COMMAND_TO_INTERFACE        0x01
#define USB_COMMAND_TO_ENDPOINT         0x02
#define USB_COMMAND_TO_OTHER            0x03

//------------------------------------------------------------------------------------
// The enumerator only provides the first eight bytes of the device descriptor
//------------------------------------------------------------------------------------
typedef struct _USB_DEVICE_DESCRIPTOR8 {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
} USB_DEVICE_DESCRIPTOR8, *PUSB_DEVICE_DESCRIPTOR8;
//------------------------------------------------------------------------------------
//  Forward declaration of classes
//------------------------------------------------------------------------------------
class IUsbDevice;

//--------------------------------------------------------------------------------------------------------------
// Resource Requirements Structure
//--------------------------------------------------------------------------------------------------------------
typedef struct _USB_RESOURCE_REQUIREMENTS
{
    UCHAR ConnectorType;
    UCHAR MaxDevices;
    UCHAR MaxCompositeInterfaces;
    UCHAR MaxControlEndpoints;
    UCHAR MaxBulkEndpoints;
    UCHAR MaxInterruptEndpoints;
    UCHAR MaxControlTDperTransfer;
    UCHAR MaxBulkTDperTransfer;
    //Isoch
    UCHAR MaxIsochEndpoints;
    UCHAR MaxIsochMaxBuffers;
} USB_RESOURCE_REQUIREMENTS, *PUSB_RESOURCE_REQUIREMENTS;
//-------------------------------------------------------------------------------------------------
// This class is used to assist initialization.
//-------------------------------------------------------------------------------------------------
class IUsbInit
{
  public:
    ULONG GetMaxDeviceTypeCount(PXPP_DEVICE_TYPE XppDeviceType);
    VOID  RegisterResources(PUSB_RESOURCE_REQUIREMENTS pResourceRequirements);
    BOOL  UseDefaultCount();
};
//--------------------------------------------------------------------------------------------------------------
// Class Driver Static Registration 
//--------------------------------------------------------------------------------------------------------------
typedef union _PNP_CLASS_ID
{
    LONG AsLong;
    struct
    {
        UCHAR bClassSpecificType;
        UCHAR bClass;
        UCHAR bSubClass;
        UCHAR bProtocol;
    } USB;
} PNP_CLASS_ID, *PPNP_CLASS_ID;

// The high-bit of bClassSpecificType is set
// if the class driver has not indicated a class
// specific type.  Prior to calling AddDevice
// this is used to track whether this is a 
// device level or interface level class.
// 
// USB_CLASS_DRIVER_DECLARATION assumes PNP_INTERFACE_LEVEL_CLASS
// 
#define PNP_CLASS_SPECIFIC_TYPE_NOT_SET(bClassSpecificType) (bClassSpecificType&0x80)
#define PNP_DEVICE_LEVEL_CLASS    0x81
#define PNP_INTERFACE_LEVEL_CLASS 0x82

typedef
VOID
 (*PFNINIT_USB_DRIVER)(IUsbInit *UsbInit);

typedef
VOID
 (*PFNADD_USB_DEVICE)(
    IN IUsbDevice *Device
    );

typedef
VOID
 (*PFNREMOVE_USB_DEVICE)(
    IN IUsbDevice *Device
    );


typedef struct _USB_DEVICE_TYPE_DESCRIPTION
{
    PXPP_DEVICE_TYPE XppDeviceType;
} USB_DEVICE_TYPE_DESCRIPTION, *PUSB_DEVICE_TYPE_DESCRIPTION;

#define USB_CONNECTOR_TYPE_DIRECT     0  //Plugs directly into the front of xbox (or a hub port)
#define USB_CONNECTOR_TYPE_HIGH_POWER 1  //Plugs into a high power slot in gamepad
#define USB_CONNECTOR_TYPE_LOW_POWER  2  //Plugs into a high power or low power slot in gamepad

typedef struct _USB_CLASS_DRIVER_DESCRIPTION
{
    PNP_CLASS_ID                 ClassId;
    PFNINIT_USB_DRIVER           Init;
    PFNADD_USB_DEVICE            AddDevice;
    PFNREMOVE_USB_DEVICE         RemoveDevice;
    ULONG                        DeviceTypeCount;
    PXPP_DEVICE_TYPE             *DeviceTypes;
} USB_CLASS_DRIVER_DESCRIPTION, *PUSB_CLASS_DRIVER_DESCRIPTION;

#define DECLARE_XPP_TYPE(XppTypeName)\
EXTERNUSB XPP_DEVICE_TYPE XppTypeName##_TABLE = {0,0,0};

#define USB_DEVICE_TYPE_TABLE_BEGIN(ClassName)\
EXTERNUSB PXPP_DEVICE_TYPE ClassName##Types[]={

#define USB_DEVICE_TYPE_TABLE_ENTRY(XppDeviceType)\
                 (XppDeviceType)

#define USB_DEVICE_TYPE_TABLE_END() };

#define USB_CLASS_DRIVER_DECLARATION(ClassName, bClass, bSubClass, bProtocol)\
               EXTERNUSB VOID ClassName##Init(IUsbInit *UsbInit);\
               EXTERNUSB VOID ClassName##AddDevice(IUsbDevice *Device);\
               EXTERNUSB VOID ClassName##RemoveDevice(IUsbDevice *Device);\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description = {\
                    PNP_INTERFACE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DRIVER_DECLARATION_DUPLICATE(ClassName, DuplicateNumber, bClass, bSubClass, bProtocol)\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##DuplicateNumber##Description = {\
                    PNP_INTERFACE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DRIVER_DECLARATION_DEVICE_LEVEL(ClassName, bClass, bSubClass, bProtocol)\
               EXTERNUSB VOID ClassName##Init(IUsbInit *UsbInit);\
               EXTERNUSB VOID ClassName##AddDevice(IUsbDevice *Device);\
               EXTERNUSB VOID ClassName##RemoveDevice(IUsbDevice *Device);\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description = {\
                    PNP_DEVICE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DECLARATION_POINTER(ClassName)\
                EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION *ClassName##DescriptionPointer=&ClassName##Description;
#define USB_CLASS_DECLARATION_POINTER_DUPLICATE(ClassName, DuplicateNumber)\
                EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION *ClassName##DuplicateNumber##DescriptionPointer=\
                &ClassName##DuplicateNumber##Description;

#define REFERENCE_CLASS(ClassName)\
    EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description;\
    static USB_CLASS_DRIVER_DESCRIPTION *classMU = &(ClassName##Description);

//---------------------------------------------------------------------------------------------------------------
//  IUsbDevice is the main interface to the core driver
//---------------------------------------------------------------------------------------------------------------
class IUsbDevice
{
    public:
    /*  IUsbDevice methods calleable at any time by class driver*/
    USBD_STATUS SubmitRequest(PURB Urb);
    USBD_STATUS CancelRequest(PURB Urb);
    BOOLEAN IsHardwareConnected() const;
    PVOID GetExtension() const;
    PVOID SetExtension(PVOID Extension);
    UCHAR GetInterfaceNumber() const;
	void SetClassSpecificType(UCHAR ClassSpecificType);
    ULONG GetPort() const;

    /*  IUsbDevice methods related to device enumeration*/
    void AddComplete(USBD_STATUS UsbdStatus);
    void RemoveComplete();
    void DeviceNotResponding();

    /*  IUsbDevice methods calleable only at enum time*/
    const USB_DEVICE_DESCRIPTOR8 *GetDeviceDescriptor() const;
    const USB_CONFIGURATION_DESCRIPTOR *GetConfigurationDescriptor() const;
    const USB_INTERFACE_DESCRIPTOR *GetInterfaceDescriptor() const;
    const USB_ENDPOINT_DESCRIPTOR *GetEndpointDescriptor(UCHAR EndpointType, BOOLEAN Direction, UCHAR Index) const;
    
	/*  IUsbDevice methods used only by hubs */
    void DeviceConnected(UCHAR PortNumber, UCHAR RetryCount);
    void DeviceDisconnected(UCHAR PortNumber);
    void ResetComplete(USBD_STATUS UsbdStatus, PVOID Context);
    void DisableComplete(USBD_STATUS UsbdStatus, PVOID Context);

    /* static IUsbDevice methods */
    static ULONG Win32FromUsbdStatus(USBD_STATUS UsbdStatus);
	static NTSTATUS NtStatusFromUsbdStatus(USBD_STATUS UsbdStatus);
};
//--------------------------------------------------------------------------------
//  Hub driver must implement this method
//--------------------------------------------------------------------------------
extern VOID USBHUB_DisableResetPort(
	                    IN IUsbDevice *HubDevice,
	                    IN UCHAR PortNumber,
	                    IN PVOID Context,
                        IN BOOLEAN Disable
	                    );

#endif //__USB_X__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\ddk\inc\miniport.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

#define ASSERT( exp )

#ifndef FAR
#define FAR
#endif


#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifndef __cplusplus
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_IA64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT     __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

// end_winnt

//
// Void
//
// begin_winnt

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif

#if (_MSC_VER >= 1200) && defined(_M_IX86)
#define FORCEINLINE static __forceinline
#else
#define FORCEINLINE __inline
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR PCTSTR, LPCTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;


#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif


#endif //_X86_

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#include <guiddef.h>


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;


//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
#define CmResourceTypeAssignedResource    8   // BUGBUG--remove
#define CmResourceTypeSubAllocateFrom     9   // BUGBUG--remove
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the PASSIGNED_RESOURCE type
//

#ifndef PASSIGNED_RESOURCE_DEFINED
#define PASSIGNED_RESOURCE_DEFINED
typedef PVOID PASSIGNED_RESOURCE;
#endif // PASSIGNED_RESOURCE_DEFINED

// end_wdm

//
// Define the bit masks for Flags common for all CM_RESOURCE_TYPE
//
// BUGBUG--remove the following 3 flags...
//
#define CM_RESOURCE_COMMON_COMPUTE_LENGTH_FROM_DEPENDENTS   0x8000
#define CM_RESOURCE_COMMON_NOT_REASSIGNED                   0x4000
#define CM_RESOURCE_COMMON_SUBSTRACTIVE                     0x2000

// begin_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
// end_wdm
#define CM_RESOURCE_PORT_FORWARD_FIRST_256_OF_EACH_1024     0x0002  // BUGBUG--remove
// begin_wdm
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040
// end_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeBusNumber
//

#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001  // BUGBUG--remove

//
// Define the bit masks for Flags when type is CmResourceTypeSubAllocateFrom
//

#define CM_RESOURCE_SUBALLOCATEFROM_FIXED_TRANSLATION   0x0001  // BUGBUG--remove
#define CM_RESOURCE_SUBALLOCATEFROM_WIRED_TRANSLATION   0x0002  // BUGBUG--remove


#include "pshpack1.h"


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

// end_wdm

        struct {
            PASSIGNED_RESOURCE AssignedResource;
        } AssignedResource;     // will be obsoleted

        struct {
            UCHAR Type;                 // use CM_RESOURCE_TYPE
            UCHAR Reserved[3];
            PASSIGNED_RESOURCE AssignedResource;
            PHYSICAL_ADDRESS Transformation;
        } SubAllocateFrom;      // will be obsoleted

// begin_wdm

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;


#endif /* _MINIPORT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbutils\xbpscapture\xbpscapture.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xbpscapture.cpp
 *  Content:    Pixel Shader Debugger
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <time.h>
#include "d3d8-xbox.h"

/*
**
** xbpssnapshot
**
** Captures a pixel shader snapshot
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "resource.h"
#include <xboxverp.h>
#include "xbfile.hxx"

#define SHADER_CAPTURE_BUFFER_SIZE 32768

// Identifiers for data blocks in the capture buffer
#define PSS_EOF         0x00000000
#define PSS_PIXEL       0x01000000
#define PSS_FINAL       0x02000000
#define PSS_PRIMITIVE   0x03000000
#define PSS_STAGE       0x04000000
#define PSS_FINALSTAGE  0x05000000
#define PSS_IMAGE       0x06000000
#define PSS_NOSHADER    0x07000000
#define PSS_STAGE0      0x08000000

DWORD g_dwFlags = 0;
DWORD g_dwMarker;

char g_HTMLFilename[MAX_PATH];
char g_BMPFilename[MAX_PATH];
char g_BMP2Filename[MAX_PATH];
char g_BMP3Filename[MAX_PATH];
char g_TmpPath[MAX_PATH];

BYTE buf[SHADER_CAPTURE_BUFFER_SIZE];

DWORD UsedInputRegisters;
DWORD UsedOutputRegisters;

void GenerateHTML(BYTE *buf, FILE *fp);

BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    SetDlgItemText(hwnd, IDC_StatusText, "Initializing...");
    GetTempPath(1024, g_TmpPath);
    SetDlgItemInt(hwnd, IDC_EDIT1, 320, FALSE);
    SetDlgItemInt(hwnd, IDC_EDIT2, 240, FALSE);
    SetDlgItemText(hwnd, IDC_EDIT3, g_TmpPath);
    CheckDlgButton(hwnd, IDC_CHECK1, FALSE); 
    SetDlgItemInt(hwnd, IDC_EDIT4, 0, FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), FALSE);
    SetDlgItemText(hwnd, IDC_StatusText, "Ready to Capture");
    return TRUE;
}

DWORD WINAPI ThreadProc(LPVOID pParam)
{
    char cmd[1024];
    sprintf(cmd, "\"%s\"", pParam);
    system(cmd);
    return TRUE;
}

DWORD *FindOpcode(DWORD op, BYTE *buf)
{
    DWORD *dwbuf = (DWORD*)buf;
    while((*dwbuf & 0xff000000) != PSS_EOF)
    {
        if((*dwbuf & 0xff000000) == op)
            return dwbuf;   // found
        dwbuf += *dwbuf & 0x00ffffff;   // move to next opcode
        if(((DWORD)dwbuf - (DWORD)buf) > SHADER_CAPTURE_BUFFER_SIZE)
            return NULL;    // not found and no EOF
    }
    return NULL;    // not found
}

void WriteOutputFiles(BYTE *buf)
{
    FILE *fp;
    BYTE *bptr;
    HRESULT hr;
    char errorbuf[MAX_PATH];
    
    // generate filenames
    
    SYSTEMTIME sysTime;
    GetLocalTime(&sysTime);
    char time[1024];
    sprintf(time, "%02d-%02d-%02d-%02d-%02d", 
            sysTime.wMonth, sysTime.wDay, sysTime.wHour, 
            sysTime.wMinute, sysTime.wSecond);
    sprintf(g_HTMLFilename, "%sxbpscpta%s.htm", g_TmpPath, time);
    sprintf(g_BMPFilename, "%sxbpscptb%s.bmp", g_TmpPath, time);
    sprintf(g_BMP2Filename, "%sxbpscptc%s.bmp", g_TmpPath, time);
    sprintf(g_BMP3Filename, "%sxbpscptd%s.bmp", g_TmpPath, time);
    
    DWORD *ptr = FindOpcode(PSS_IMAGE, buf);
    if(ptr)
    {
        // write out the 64x64 vicinity image
        fp = fopen(g_BMPFilename, "wb");
        if(!fp)
        {
            sprintf(errorbuf, "Unable to open file %s.", g_BMPFilename);
            MessageBox(NULL, (const char*)errorbuf, "File Write Error", MB_OK | MB_TASKMODAL);
            return;
        }
        DWORD dwLen = (*ptr & 0xffffff) - 1;
        DWORD dwX, dwY;
        ptr++;
        dwX = *ptr & 0xffff;
        dwY = (*ptr >> 16) & 0xffff;
        
        // write the .bmp header
        BITMAPFILEHEADER bmfh;
        BITMAPINFOHEADER bmih;

        ZeroMemory( &bmfh, sizeof(BITMAPFILEHEADER) );
        bmfh.bfType = 'MB';
        bmfh.bfSize = (sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + dwX*3 * dwY);
        bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
        fwrite(&bmfh, 1, sizeof(BITMAPFILEHEADER), fp);
        
        ZeroMemory(&bmih, sizeof(BITMAPINFOHEADER));
        bmih.biSize = sizeof(BITMAPINFOHEADER);
        bmih.biWidth = dwX;
        bmih.biHeight = dwY;
        bmih.biPlanes = 1;
        bmih.biBitCount = 24;
        fwrite(&bmih, 1, sizeof(BITMAPINFOHEADER), fp);
        
        ptr++;
        
        // draw an xor box around the center area
        for(dwX=29; dwX <= 35; dwX++)
        {
            for(dwY=29; dwY <= 35; dwY++)
            {
                if((dwX == 29) || (dwX == 35) || (dwY == 29) || (dwY == 35))
                {
                    bptr = (BYTE *)ptr + (dwX + dwY*64)*3;
                    *bptr     ^= 0xff;
                    *(bptr+1) ^= 0xff;
                    *(bptr+2) ^= 0xff;
                }
            }
        }
        // write out the bits
        fwrite(ptr, sizeof(DWORD), dwLen, fp);

        fclose(fp);
    
        // write out the 5x5 near vicinity image
        // (assumes that ptr points to start of image bits)
        struct
        {
            BYTE b,g,r;
        } img[128][128];
        INT i,j;
        
        // clear the image
        for(i=0; i<128; i++)
            for(j=0; j<128; j++)
                img[j][i].b = img[j][i].g = img[j][i].r = 0;

        // draw a white border around the center pixel
        for(i=51; i<=76; i++)
        {
            for(j=51; j<=76; j++)
            {
                img[j][i].b = 0xff;
                img[j][i].g = 0xff;
                img[j][i].r = 0xff;
            }
        }
        
        // draw very large pixels
        INT pi, pj;
        for(pj = 34; pj > 29; pj--)
        {
            for(pi = 30; pi < 35; pi++)
            {
                bptr = (BYTE *)ptr + (pj*64 + pi)*3;
                
                INT sx = (pi-29)*25-24+1;
                INT sy = (pj-29)*25-24+1;

                for(i=sx; i<(sx+24); i++)
                {
                    for(j=sy; j<(sy+24); j++)
                    {
                        img[j][i].b = *bptr;
                        img[j][i].g = *(bptr+1);
                        img[j][i].r = *(bptr+2);
                    }
                }
            }
        }
        fp = fopen(g_BMP2Filename, "wb");
        if(!fp)
        {
            sprintf(errorbuf, "Unable to open file %s.", g_BMP2Filename);
            MessageBox(NULL, (const char*)errorbuf, "File Write Error", MB_OK | MB_TASKMODAL);
            return;
        }
        // write the .bmp header
        ZeroMemory( &bmfh, sizeof(BITMAPFILEHEADER) );
        bmfh.bfType = 'MB';
        bmfh.bfSize = (sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + 128*128*3);
        bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
        fwrite(&bmfh, 1, sizeof(BITMAPFILEHEADER), fp);
        
        ZeroMemory(&bmih, sizeof(BITMAPINFOHEADER));
        bmih.biSize = sizeof(BITMAPINFOHEADER);
        bmih.biWidth = 128;
        bmih.biHeight = 128;
        bmih.biPlanes = 1;
        bmih.biBitCount = 24;
        fwrite(&bmih, 1, sizeof(BITMAPINFOHEADER), fp);
        
        // write out the bits
        fwrite(img, sizeof(BYTE), 128*128*3, fp);

        fclose(fp);
    }

    // get the screen shot
    hr = DmScreenShot(g_BMP3Filename);  // don't report an error if it occurs


    fp = fopen(g_HTMLFilename, "w");
    if(!fp)
    {
        sprintf(errorbuf, "Unable to open file %s.", g_HTMLFilename);
        MessageBox(NULL, (const char*)errorbuf, "File Write Error", MB_OK | MB_TASKMODAL);
        return;
    }
    GenerateHTML(buf, fp);                                          // generate the html
    fclose(fp);
    CreateThread(NULL, 0, &ThreadProc, g_HTMLFilename, 0, NULL);    // display the html
}

void DeleteFiles(char *cPattern)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    char Filename[MAX_PATH];

    sprintf(Filename, "%s%s", g_TmpPath, cPattern);
    hFind = FindFirstFile(Filename, &FindFileData);
    while(hFind != INVALID_HANDLE_VALUE)
    {
        sprintf(Filename, "%s%s", g_TmpPath, FindFileData.cFileName);
        DeleteFile(Filename);
        BOOL bSuccess = FindNextFile(hFind, &FindFileData);
        if(!bSuccess)
        {
            FindClose(hFind);
            break;
        }
    }
}

void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
    case IDCANCEL:
        EndDialog(hwnd, id);
        break;
    case IDOK:
        HRESULT hr;
        SetDlgItemText(hwnd, IDC_StatusText, "Capturing one frame...");
        
        g_dwMarker = GetDlgItemInt(hwnd, IDC_EDIT4, NULL, FALSE);
        hr = DmPixelShaderSnapshot(GetDlgItemInt(hwnd, IDC_EDIT1, NULL, FALSE), 
                                   GetDlgItemInt(hwnd, IDC_EDIT2, NULL, FALSE),
                                    g_dwFlags,
                                    g_dwMarker,
                                    buf);
        if(FAILED(hr)) 
        {
            if(hr == XBDM_FILEERROR)
                hr = HrLastError();
            MessageBox(NULL, (const char*)buf, "xbpscapture Error", MB_OK | MB_TASKMODAL);
        }
        else
        {
            SetDlgItemText(hwnd, IDC_StatusText, "Writing HTML Output");
            GetDlgItemText(hwnd, IDC_EDIT3, g_TmpPath, MAX_PATH);
            WriteOutputFiles(buf);
        }
        SetDlgItemText(hwnd, IDC_StatusText, "Ready to Capture");
        
        break;

    case IDC_DeleteTempButton:
        
        SetDlgItemText(hwnd, IDC_StatusText, "Deleting xbpscpta*.htm");
        DeleteFiles("xbpscpta*.htm");
        SetDlgItemText(hwnd, IDC_StatusText, "Deleting xbpscptb*.bmp");
        DeleteFiles("xbpscptb*.bmp");
        SetDlgItemText(hwnd, IDC_StatusText, "Deleting xbpscptc*.bmp");
        DeleteFiles("xbpscptc*.bmp");
        SetDlgItemText(hwnd, IDC_StatusText, "Deleting xbpscptd*.bmp");
        DeleteFiles("xbpscptd*.bmp");
        SetDlgItemText(hwnd, IDC_StatusText, "Ready to Capture");
        break;

    case IDC_CHECK1:
        if(IsDlgButtonChecked(hwnd, IDC_CHECK1) == BST_CHECKED)
        {
            // enable marker window
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), TRUE);
            g_dwFlags |= 0x1;  // set marker flag
        }
        else
        {
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT4), FALSE);
            g_dwFlags &= ~0x1;  // reset marker flag
        }
        break;
    }
}

BOOL CALLBACK Dlg_Proc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    HANDLE_MSG(hDlg, WM_COMMAND, Dlg_OnCommand);
    HANDLE_MSG(hDlg, WM_INITDIALOG, Dlg_OnInitDialog);
    case WM_HELP: printf("Help!\n"); break;
    default:
        return FALSE;
    }
    return TRUE;
}

int __cdecl main(int cArg, char **rgszArg)
{
    // if command line parameters, run silently
    if(cArg > 1)
    {
        DWORD dwX, dwY;
        HRESULT hr;
        
        dwX = atoi(rgszArg[1]);
        dwY = atoi(rgszArg[2]);
        hr = DmPixelShaderSnapshot(dwX, dwY, 0, 0, buf);
        
        if(FAILED(hr)) 
        {
            if(hr == XBDM_FILEERROR)
                hr = HrLastError();
            MessageBox(NULL, (const char*)buf, "xbpscapture Error", MB_OK | MB_TASKMODAL);
        }
        else
        {
            WriteOutputFiles(buf);
        }
        Sleep(5000);
        return 0;
    }
    
    // display the UI
    DialogBox(NULL, MAKEINTRESOURCE(IDD_PSCAPTURE), NULL, Dlg_Proc);
    return 0;
}

DWORD smearalpha(DWORD in)
{
    return (((in >>  0) & 0xff000000) |
            ((in >>  8) & 0x00ff0000) |
            ((in >> 16) & 0x0000ff00) |
            ((in >> 24) & 0x000000ff));
}

struct inputRegister
{
    char name[32];
    BOOL isZero;
    BOOL isOne;
    BOOL isMinusOne;
}inRGB[7], inA[4];

void getInputReg(struct inputRegister *pIR, BYTE val, BOOL isRGB)
{
    BYTE reg, im, chan;
    char *pName;
    char *pSuffix;

    im = val & 0xe0;
    chan = (val >> 4) & 0x1;
    reg = (val & 0xf);

    pIR->isZero = ((reg == PS_REGISTER_ZERO) &&
                   ((im == PS_INPUTMAPPING_UNSIGNED_IDENTITY) ||
                    (im == PS_INPUTMAPPING_SIGNED_IDENTITY)));
    pIR->isOne = ((reg == PS_REGISTER_ZERO) &&
                  ((im == PS_INPUTMAPPING_UNSIGNED_INVERT) ||
                   (im == PS_INPUTMAPPING_EXPAND_NEGATE)));
    pIR->isMinusOne = ((reg == PS_REGISTER_ZERO) && (im == PS_INPUTMAPPING_EXPAND_NORMAL));
    
    switch(reg)
    {
    case PS_REGISTER_ZERO: 
        UsedInputRegisters |= (1 << PS_REGISTER_ZERO); 
        pName = "zero"; 
        break;
    case PS_REGISTER_C0:
        UsedInputRegisters |= (1 << PS_REGISTER_C0);
        pName = "c0"; 
        break;
    case PS_REGISTER_C1:
        UsedInputRegisters |= (1 << PS_REGISTER_C1);
        pName = "c1"; 
        break;
    case PS_REGISTER_FOG:
        UsedInputRegisters |= (1 << PS_REGISTER_FOG);
        pName = "fog"; 
        break;
    case PS_REGISTER_V0:
        UsedInputRegisters |= (1 << PS_REGISTER_V0);
        pName = "v0"; 
        break;
    case PS_REGISTER_V1:
        UsedInputRegisters |= (1 << PS_REGISTER_V1);
        pName = "v1"; 
        break;
    case PS_REGISTER_T0:
        UsedInputRegisters |= (1 << PS_REGISTER_T0);
        pName = "t0"; 
        break;
    case PS_REGISTER_T1:
        UsedInputRegisters |= (1 << PS_REGISTER_T1);
        pName = "t1"; 
        break;
    case PS_REGISTER_T2:
        UsedInputRegisters |= (1 << PS_REGISTER_T2);
        pName = "t2"; 
        break;
    case PS_REGISTER_T3:
        UsedInputRegisters |= (1 << PS_REGISTER_T3);
        pName = "t3"; 
        break;
    case PS_REGISTER_R0:
        UsedInputRegisters |= (1 << PS_REGISTER_R0);
        pName = "r0"; 
        break;
    case PS_REGISTER_R1:
        UsedInputRegisters |= (1 << PS_REGISTER_R1);
        pName = "r1"; 
        break;
    case PS_REGISTER_V1R0_SUM:
        UsedInputRegisters |= (1 << PS_REGISTER_V1R0_SUM);
        UsedInputRegisters |= (1 << PS_REGISTER_V1);
        UsedInputRegisters |= (1 << PS_REGISTER_R0);
        pName = "sum"; 
        break;
    case PS_REGISTER_EF_PROD:
        UsedInputRegisters |= (1 << PS_REGISTER_EF_PROD);
        pName = "prod"; 
        break;
    }

    if(isRGB)
    {
        if(chan == 1)
            pSuffix = ".a";
        else
            pSuffix = ".rgb";
    }
    else
    {
        if(chan == 1)
            pSuffix = ".a";
        else
            pSuffix = ".b";
    }

    switch(im)
    {
    case PS_INPUTMAPPING_UNSIGNED_IDENTITY:
        sprintf(pIR->name, "%s%s_sat", pName, pSuffix);
        break;
    case PS_INPUTMAPPING_UNSIGNED_INVERT:
        sprintf(pIR->name, "(1-%s%s)", pName, pSuffix);
        break;
    case PS_INPUTMAPPING_EXPAND_NORMAL:
        sprintf(pIR->name, "%s%s_bx2", pName, pSuffix);
        break;
    case PS_INPUTMAPPING_EXPAND_NEGATE:
        sprintf(pIR->name, "-%s%s_bx2)", pName, pSuffix);
        break;
    case PS_INPUTMAPPING_HALFBIAS_NORMAL:
        sprintf(pIR->name, "%s%s_bias", pName, pSuffix);
        break;
    case PS_INPUTMAPPING_HALFBIAS_NEGATE:
        sprintf(pIR->name, "-%s%s_bias", pName, pSuffix);
        break;
    case PS_INPUTMAPPING_SIGNED_IDENTITY:
        sprintf(pIR->name, "%s%s", pName, pSuffix);
        break;
    case PS_INPUTMAPPING_SIGNED_NEGATE:
        sprintf(pIR->name, "-%s%s", pName, pSuffix);
        break;
    }
}

char * getoutput(DWORD val)
{
    switch(val)
    {
    case PS_REGISTER_DISCARD:
        UsedOutputRegisters |= (1 << PS_REGISTER_DISCARD);
        return("discard");
    case PS_REGISTER_C0:
        UsedOutputRegisters |= (1 << PS_REGISTER_C0);
        return("c0");
    case PS_REGISTER_C1:
        UsedOutputRegisters |= (1 << PS_REGISTER_C1);
        return("c1");
    case PS_REGISTER_FOG:
        UsedOutputRegisters |= (1 << PS_REGISTER_FOG);
        return("fog");
    case PS_REGISTER_V0:
        UsedOutputRegisters |= (1 << PS_REGISTER_V0);
        return("v0");
    case PS_REGISTER_V1:
        UsedOutputRegisters |= (1 << PS_REGISTER_V1);
        return("v1");
    case PS_REGISTER_T0:
        UsedOutputRegisters |= (1 << PS_REGISTER_T0);
        return("t0");
    case PS_REGISTER_T1:
        UsedOutputRegisters |= (1 << PS_REGISTER_T1);
        return("t1");
    case PS_REGISTER_T2:
        UsedOutputRegisters |= (1 << PS_REGISTER_T2);
        return("t2");
    case PS_REGISTER_T3:
        UsedOutputRegisters |= (1 << PS_REGISTER_T3);
        return("t3");
    case PS_REGISTER_R0:
        UsedOutputRegisters |= (1 << PS_REGISTER_R0);
        return("r0");
    case PS_REGISTER_R1:
        UsedOutputRegisters |= (1 << PS_REGISTER_R1);
        return("r1");
    case PS_REGISTER_V1R0_SUM:
        UsedOutputRegisters |= (1 << PS_REGISTER_V1R0_SUM);
        return("sum");
    case PS_REGISTER_EF_PROD:
        UsedOutputRegisters |= (1 << PS_REGISTER_EF_PROD);
        return("prod");
    }
    return("");
}

void combineAndPrint(char *pRGB, char *pA, FILE *fp)
{
    char stripRGB[1024], stripA[1024], *pStr;

    // strip .rgb from first input string
    strcpy(stripRGB, pRGB);
    pStr = strstr(stripRGB, ".rgb");
    while(pStr)
    {
        strcpy(pStr, pStr+4);
        pStr = strstr(stripRGB, ".rgb");
    }
    
    // strip .a from second input string
    strcpy(stripA, pA);
    pStr = strstr(stripA, ".a");
    while(pStr)
    {
        strcpy(pStr, pStr+2);
        pStr = strstr(stripA, ".a");
    }

    // if the strings are the same, print only one of them
    if(strcmp(stripRGB, stripA) == 0)
    {
        pStr = strstr(stripRGB, "muxargument0");
        if(pStr)
        {
            UsedInputRegisters |= (1 << PS_REGISTER_R0);
            memcpy(pStr, "(r0.a > 0.5)", 12);
        }
        fprintf(fp, "<p class=Normal>%s</p>\n", stripRGB);
    }
    else
    {
        pStr = strstr(pRGB, "muxargument0");
        if(pStr)
        {
            UsedInputRegisters |= (1 << PS_REGISTER_R0);
            memcpy(pStr, "(r0.a > 0.5)", 12);
        }
        fprintf(fp, "<p class=Normal>%s</p>\n", pRGB);
        pStr = strstr(pA, "muxargument0");
        if(pStr)
        {
            UsedInputRegisters |= (1 << PS_REGISTER_R0);
            memcpy(pStr, "(r0.a > 0.5)", 12);
        }
        fprintf(fp, "<p class=Normal>%s</p>\n", pA);
    }
}

void GetOutputModifier(DWORD dwVal, char **pre, char **post)
{
    *pre = *post = "\0";
    switch((dwVal >> 12) & 0x38)
    {
    case PS_COMBINEROUTPUT_BIAS:
        *pre = "(";
        *post = ") - 0.5";
        break;
    case PS_COMBINEROUTPUT_SHIFTLEFT_1:
        *pre = "(";
        *post = ") * 2";
        break;
    case PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS:
        *pre = "((";
        *post = ") - 0.5) * 2";
        break;
    case PS_COMBINEROUTPUT_SHIFTLEFT_2:
        *pre = "(";
        *post = ") * 4";
        break;
    case PS_COMBINEROUTPUT_SHIFTRIGHT_1:
        *pre = "(";
        *post = ") / 2";
        break;
    }
}

void PrintCombinerDescription(FILE *fp, DWORD *pComb, BOOL bIsFinal)
{
    // initialize record of which registers are used
    UsedInputRegisters = 0;
    UsedOutputRegisters = 0;

    if(!bIsFinal)
    {
        getInputReg(&(inRGB[0]), (BYTE)((*pComb >> 24) & 0xff), TRUE);
        getInputReg(&(inRGB[1]), (BYTE)((*pComb >> 16) & 0xff), TRUE);
        getInputReg(&(inRGB[2]), (BYTE)((*pComb >>  8) & 0xff), TRUE);
        getInputReg(&(inRGB[3]), (BYTE)((*pComb >>  0) & 0xff), TRUE);
    
        getInputReg(&(inA[0]), (BYTE)((*(pComb+1) >> 24) & 0xff), FALSE);
        getInputReg(&(inA[1]), (BYTE)((*(pComb+1) >> 16) & 0xff), FALSE);
        getInputReg(&(inA[2]), (BYTE)((*(pComb+1) >>  8) & 0xff), FALSE);
        getInputReg(&(inA[3]), (BYTE)((*(pComb+1) >>  0) & 0xff), FALSE);
        
        // get AB
        BOOL abdot = (*(pComb+2) >> 12) & PS_COMBINEROUTPUT_AB_DOT_PRODUCT;
        char abRGB[64], abA[64];
        if(abdot)
        {
            sprintf(abRGB, "%s . %s", inRGB[0].name, inRGB[1].name);
        }
        else
        {
            if(inRGB[0].isOne)
                sprintf(abRGB, "%s", inRGB[1].name);
            else if(inRGB[1].isOne)
                sprintf(abRGB, "%s", inRGB[0].name);
            else if(inRGB[0].isMinusOne)
                sprintf(abRGB, "-%s", inRGB[1].name);
            else if(inRGB[1].isMinusOne)
                sprintf(abRGB, "-%s", inRGB[0].name);
            else if(inRGB[0].isZero || inRGB[1].isZero)
                strcpy(abRGB, "0");
            else
                sprintf(abRGB, "%s * %s", inRGB[0].name, inRGB[1].name);
        }
        if(inA[0].isOne)
            sprintf(abA, "%s", inA[1].name);
        else if(inA[1].isOne)
            sprintf(abA, "%s", inA[0].name);
        else if(inA[0].isMinusOne)
            sprintf(abA, "-%s", inA[1].name);
        else if(inA[1].isMinusOne)
            sprintf(abA, "-%s", inA[0].name);
        else if(inA[0].isZero || inA[1].isZero)
            strcpy(abA, "0");
        else
            sprintf(abA, "%s * %s", inA[0].name, inA[1].name);
        
        // get CD
        BOOL cddot = (*(pComb+2) >> 12) & PS_COMBINEROUTPUT_CD_DOT_PRODUCT;
        char cdRGB[64], cdA[64];
        if(cddot)
        {
            sprintf(cdRGB, "%s . %s", inRGB[2].name, inRGB[3].name);
        }
        else
        {
            if(inRGB[2].isOne)
                sprintf(cdRGB, "%s", inRGB[3].name);
            else if(inRGB[3].isOne)
                sprintf(cdRGB, "%s", inRGB[2].name);
            else if(inRGB[2].isMinusOne)
                sprintf(cdRGB, "-%s", inRGB[3].name);
            else if(inRGB[3].isMinusOne)
                sprintf(cdRGB, "-%s", inRGB[2].name);
            else if(inRGB[2].isZero || inRGB[3].isZero)
                strcpy(cdRGB, "0");
            else
                sprintf(cdRGB, "%s * %s", inRGB[2].name, inRGB[3].name);
        }
        if(inA[2].isOne)
            sprintf(cdA, "%s", inA[3].name);
        else if(inA[3].isOne)
            sprintf(cdA, "%s", inA[2].name);
        else if(inA[2].isMinusOne)
            sprintf(cdA, "-%s", inA[3].name);
        else if(inA[3].isMinusOne)
            sprintf(cdA, "-%s", inA[2].name);
        else if(inA[2].isZero || inA[3].isZero)
            strcpy(cdA, "0");
        else
            sprintf(cdA, "%s * %s", inA[2].name, inA[3].name);

        DWORD abOutRGB, cdOutRGB, sumOutRGB;
        DWORD abOutA, cdOutA, sumOutA;
        abOutRGB = ((*(pComb+2)) >> 4) & 0xf;
        cdOutRGB = ((*(pComb+2)) >> 0) & 0xf;
        sumOutRGB = ((*(pComb+2)) >> 8) & 0xf;
        abOutA = ((*(pComb+3)) >> 4) & 0xf;
        cdOutA = ((*(pComb+3)) >> 0) & 0xf;
        sumOutA = ((*(pComb+3)) >> 8) & 0xf;

        char abInstA[1024], abInstRGB[1024];
        char cdInstA[1024], cdInstRGB[1024];
        char sumInstA[1024], sumInstRGB[1024];
        char *preRGB, *postRGB, *preA, *postA;

        GetOutputModifier(*(pComb+2), &preRGB, &postRGB);
        GetOutputModifier(*(pComb+3), &preA, &postA);

        abInstA[0] = abInstRGB[0] = '\0';
        cdInstA[0] = cdInstRGB[0] = '\0';
        sumInstA[0] = sumInstRGB[0] = '\0';

        if(abOutRGB != PS_REGISTER_DISCARD)
            sprintf(abInstRGB, "%s.rgb = %s;", getoutput(abOutRGB), abRGB);
        if(abOutA != PS_REGISTER_DISCARD)
            sprintf(abInstA, "%s.a = %s;", getoutput(abOutA), abA);
        if(cdOutRGB != PS_REGISTER_DISCARD)
            sprintf(cdInstRGB, "%s.rgb = %s;", getoutput(cdOutRGB), cdRGB);
        if(cdOutA != PS_REGISTER_DISCARD)
            sprintf(cdInstA, "%s.a = %s;", getoutput(cdOutA), cdA);
        if(sumOutRGB != PS_REGISTER_DISCARD)
        {
            BOOL rgbmux = (*(pComb+2) >> 12) & PS_COMBINEROUTPUT_AB_CD_MUX;
            if(rgbmux)
                sprintf(sumInstRGB, "%s.rgb = %smuxargument0 ? %s : %s%s;", getoutput(sumOutRGB), preRGB, cdRGB, abRGB, postRGB);
            else                              
                sprintf(sumInstRGB, "%s.rgb = %s%s + %s%s;", getoutput(sumOutRGB), preRGB, abRGB, cdRGB, postRGB);
        }
        if(sumOutA != PS_REGISTER_DISCARD)
        {
            BOOL amux   = (*(pComb+3) >> 12) & PS_COMBINEROUTPUT_AB_CD_MUX;
            if(amux)
                sprintf(sumInstA, "%s.a = %smuxargument0 ? %s : %s%s;", getoutput(sumOutA), preA, cdA, abA, postA);
            else
                sprintf(sumInstA, "%s.a = %s%s + %s%s;", getoutput(sumOutA), preA, abA, cdA, postA);
        }
        combineAndPrint(abInstRGB, abInstA, fp);
        combineAndPrint(cdInstRGB, cdInstA, fp);
        combineAndPrint(sumInstRGB, sumInstA, fp);
    }
    else
    {
        getInputReg(&(inRGB[0]), (BYTE)((*pComb >> 24) & 0xff), TRUE);
        getInputReg(&(inRGB[1]), (BYTE)((*pComb >> 16) & 0xff), TRUE);
        getInputReg(&(inRGB[2]), (BYTE)((*pComb >>  8) & 0xff), TRUE);
        getInputReg(&(inRGB[3]), (BYTE)((*pComb >>  0) & 0xff), TRUE);
        getInputReg(&(inRGB[4]), (BYTE)((*(pComb+1) >> 24) & 0xff), TRUE);
        getInputReg(&(inRGB[5]), (BYTE)((*(pComb+1) >> 16) & 0xff), TRUE);
        getInputReg(&(inRGB[6]), (BYTE)((*(pComb+1) >>  8) & 0xff), FALSE);
        
        char xfc[1024], reg[64];
        if(inRGB[0].isZero)
        {
            sprintf(xfc, "out.rgb = %s", inRGB[2].name);
        }
        else if(inRGB[0].isOne)
        {
            sprintf(xfc, "out.rgb = %s", inRGB[1].name);
        }
        else
        {
            sprintf(xfc, "out.rgb = (%s * %s) + (1-%s) * %s", 
                    inRGB[0].name, inRGB[1].name, inRGB[0].name, inRGB[2].name);
        }

        if(!inRGB[3].isZero)
        {
            sprintf(reg, " + %s", inRGB[3].name);
            strcat(xfc, reg);
        }
        fprintf(fp, "<p class=Normal>%s</p>\n", xfc);

        if((UsedInputRegisters >> PS_REGISTER_EF_PROD) & 0x1)
        {
            sprintf(xfc, "prod.rgb = (%s * %s)", inRGB[4].name, inRGB[5].name);
            fprintf(fp, "<p class=Normal>%s</p>\n", xfc);
        }
        
        if((UsedInputRegisters >> PS_REGISTER_V1R0_SUM) & 0x1)
        {
            sprintf(xfc, "sum.rgb = (r0.rgb + v1.rgb)");
            fprintf(fp, "<p class=Normal>%s</p>\n", xfc);
        }

        sprintf(xfc, "out.a = %s", inRGB[6].name);
        fprintf(fp, "<p class=Normal>%s</p>\n", xfc);
    }
}

void PrintReg(DWORD *pReg, CHAR *pName, CHAR *pStyle, FILE *fp, BOOL bIsBold, DWORD *pAddr)
{
    CHAR *pTextStyle;
    CHAR signhex[64], sign[64], ulong[64], color[64], alpha[64], signint[64];
    static DWORD id=0;
    short dwA = (short)((*pReg >> 16) & 0xffff);
    short dwR = (short)((*pReg >>  0) & 0xffff);
    short dwG = (short)((*(pReg+1) >> 16) & 0xffff);
    short dwB = (short)((*(pReg+1) >>  0) & 0xffff);

    sprintf(signhex, "0x%03x 0x%03x 0x%03x 0x%03x", (USHORT)dwA & 0x1ff, (USHORT)dwR & 0x1ff, (USHORT)dwG & 0x1ff, (USHORT)dwB & 0x1ff);
    sprintf(sign, "%1.7f %1.7f %1.7f %1.7f", dwA/255.f, dwR/255.f, dwG/255.f, dwB/255.f);
    sprintf(ulong, "0x%02x%02x%02x%02x", (USHORT)dwA & 0xff, (USHORT)dwR & 0xff, (USHORT)dwG & 0xff, (USHORT)dwB & 0xff);
    sprintf(color, "%02x%02x%02x", (USHORT)dwR & 0xff, (USHORT)dwG & 0xff, (USHORT)dwB & 0xff);
    sprintf(alpha, "%02x%02x%02x", (USHORT)dwA & 0xff, (USHORT)dwA & 0xff, (USHORT)dwA & 0xff);
    sprintf(signint, "%d %d %d %d", dwA, dwR, dwG, dwB);
    
    if(bIsBold)
        pTextStyle="Bold";
    else
        pTextStyle="Normal";

    fprintf(fp,
" <tr>\n"
"  <td class=%s><p class=%s>%s</p></td>\n"
"  <td class=%s><p class=%s><SPAN ID=id%04d onmouseover=\"this.style.cursor='hand'\" onclick=\"change('%s','%s','%s','%s',id%04d)\">%s</SPAN></p></td>\n"
"  <td width=10 style='background:#%s'></td>\n"
"  <td width=30 style='background:#%s'></td>\n", pStyle, pTextStyle, pName, pStyle, pTextStyle, id, signhex, ulong, sign, signint, id, signhex, alpha, color);
    if(pAddr == 0)
    {
        fprintf(fp, " </tr>\n");
    }
    else
    {
        dwA = (short)((*pAddr >> 16) & 0xffff);
        dwR = (short)((*pAddr >>  0) & 0xffff);
        dwG = (short)((*(pAddr+1) >> 16) & 0xffff);
        dwB = (short)((*(pAddr+1) >>  0) & 0xffff);
        sprintf(sign, "  Addr=(%1.6f %1.6f %1.6f %1.6f)", dwR/255.f, dwG/255.f, dwB/255.f, dwA/255.f);
        fprintf(fp,
"  <td class=Normal><p class=Normal>%s</p></td>\n"
"  </tr>\n", sign);
    }
    id++;
}

void PrintRegisterBlock(DWORD *ptr, FILE *fp, DWORD mask)
{
    if((mask >> PS_REGISTER_R0) & 0x1)
        PrintReg(ptr, "R0:", "CyanReg", fp, FALSE, 0); 
    if((mask >> PS_REGISTER_R1) & 0x1)
        PrintReg(ptr+2, "R1:", "CyanReg", fp, FALSE, 0); 
    if((mask >> PS_REGISTER_C0) & 0x1)
        PrintReg(ptr+4, "C0:", "OReg", fp, FALSE, 0); 
    if((mask >> PS_REGISTER_C1) & 0x1)
        PrintReg(ptr+6, "C1:", "OReg", fp, FALSE, 0); 
    if((mask >> PS_REGISTER_V0) & 0x1)
        PrintReg(ptr+8, "V0:", "GreenReg", fp, FALSE, 0); 
    if((mask >> PS_REGISTER_V1) & 0x1)
        PrintReg(ptr+10, "V1:", "GreenReg", fp, FALSE, 0); 
    if((mask >> PS_REGISTER_FOG) & 0x1)
        PrintReg(ptr+20, "Fog:", "TanReg", fp, FALSE, 0); 
    if((mask >> PS_REGISTER_V1R0_SUM) & 0x1)
        PrintReg(ptr+22, "Sum:", "TanReg", fp, FALSE, 0); 
    if((mask >> PS_REGISTER_EF_PROD) & 0x1)
        PrintReg(ptr+24, "Prod:", "TanReg", fp, FALSE, 0); 
    if(mask == 0xffffffff)
    {
        if((mask >> PS_REGISTER_T0) & 0x1)
            PrintReg(ptr+12, "T0:", "TanReg", fp, FALSE, ptr+20); 
        if((mask >> PS_REGISTER_T1) & 0x1)
            PrintReg(ptr+14, "T1:", "TanReg", fp, FALSE, ptr+22); 
        if((mask >> PS_REGISTER_T2) & 0x1)
            PrintReg(ptr+16, "T2:", "TanReg", fp, FALSE, ptr+24); 
        if((mask >> PS_REGISTER_T3) & 0x1)
            PrintReg(ptr+18, "T3:", "TanReg", fp, FALSE, ptr+26); 
    }
    else
    {
        if((mask >> PS_REGISTER_T0) & 0x1)
            PrintReg(ptr+12, "T0:", "TanReg", fp, FALSE, 0); 
        if((mask >> PS_REGISTER_T1) & 0x1)
            PrintReg(ptr+14, "T1:", "TanReg", fp, FALSE, 0); 
        if((mask >> PS_REGISTER_T2) & 0x1)
            PrintReg(ptr+16, "T2:", "TanReg", fp, FALSE, 0); 
        if((mask >> PS_REGISTER_T3) & 0x1)
            PrintReg(ptr+18, "T3:", "TanReg", fp, FALSE, 0); 
    }
}

BOOL ParsePrimitives(BYTE *buf, FILE *fp)
{
    DWORD dwPrimCount=0;
    DWORD *ptr = FindOpcode(PSS_PRIMITIVE, buf);
    DWORD dwStageCount;
    DWORD dwReg;
    DWORD *pDescPtr;
    DWORD dwDPre, dwCPre, dwDPost, dwCPost;
    DWORD *pNext;
    if(!ptr) 
    {
        fprintf(fp, "<p class=Bold><B>No Primitives affected this pixel.</B></p>\n");
        return TRUE;
    }

    while(1)
    {
        switch(*ptr & 0xff000000)
        {
        case PSS_EOF:
            return TRUE;
        case PSS_PRIMITIVE:
            ptr++;
            dwCPre = *ptr++;
            dwDPre = *ptr++;
            dwCPost = *ptr++;
            dwDPost = *ptr++;
            fprintf(fp, 
"<HR>"
"<p class=Normal>&nbsp;</p>\n"
"<p class=Big><B>Primitive %d</B></p>\n"
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n"
" <tr>\n"
"  <td class=RedReg><p class=Normal>Before:</p></td>\n"
"  <td class=RedReg><p class=Normal>depth=0x%08x</p></td>\n"
"  <td class=RedReg><p class=Normal>color=0x%08x</p></td>\n"
"  <td width=10 style='background:#%06x'></td>\n"
"  <td width=30 style='background:#%06x'></td>\n"
" </tr>\n"
" <tr>\n"
"  <td class=RedReg><p class=Normal>After:</p></td>\n"
"  <td class=RedReg><p class=Normal>depth=0x%08x</p></td>\n"
"  <td class=RedReg><p class=Normal>color=0x%08x</p></td>\n"
"  <td width=10 style='background:#%06x'></td>\n"
"  <td width=30 style='background:#%06x'></td>\n"
" </tr>\n"
"</table>\n", dwPrimCount++, dwDPre, dwCPre, smearalpha(dwCPre)&0xffffff, dwCPre&0xffffff,
              dwDPost, dwCPost, smearalpha(dwCPost)&0xffffff, dwCPost&0xffffff);
            dwStageCount=1;
            break;
        
        case PSS_NOSHADER:
            ptr++;
            fprintf(fp, 
"<p class=Normal>No pixel shader was active for this primitive.</p>\n");
            break;
        
        case PSS_STAGE0:
            ptr++;
            pDescPtr = ptr;   // save combiner description pointer
            ptr += 4;

            // print all registers
            fprintf(fp, 
"<p class=Normal>&nbsp;</p>\n"
"<p class=Normal>Initial State:</p>\n");
                fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");

            if((dwPrimCount == 1))
                fprintf(fp, "<p class=Tiny>Click on register values to change the format.  Values are (A R G B)</p>\n");
    
            PrintRegisterBlock(ptr, fp, 0xffffffff & ~((1 << PS_REGISTER_FOG) |
                                                       (1 << PS_REGISTER_V1R0_SUM) |
                                                       (1 << PS_REGISTER_EF_PROD))); // display initial registers
            fprintf(fp, "</table>\n");
            
            fprintf(fp, 
"<p class=Normal>&nbsp;</p>\n"
"<p class=Bold>Combiner Stage %d:</p>\n", dwStageCount++);

            PrintCombinerDescription(fp, pDescPtr, FALSE);
            fprintf(fp, "<p class=Normal>Inputs:</p>\n");
            
            fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");
            PrintRegisterBlock(ptr, fp, UsedInputRegisters);
            ptr += 28;
            fprintf(fp, "</table>\n");
            
            if((*ptr & 0xff000000) == PSS_STAGE)
            {
                fprintf(fp, "<p class=Normal>Outputs:</p>\n");
                fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");
                PrintRegisterBlock(ptr+5, fp, UsedOutputRegisters);
                fprintf(fp, "</table>\n");
            }
            else if((*ptr & 0xff000000) == PSS_FINALSTAGE)
            {
                fprintf(fp, "<p class=Normal>Outputs (saturated):</p>\n");
                fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");
                PrintRegisterBlock(ptr+3, fp, UsedOutputRegisters);
                fprintf(fp, "</table>\n");
            }
            break;

        case PSS_STAGE:
            ptr++;
            pDescPtr = ptr;   // save combiner description pointer
            ptr += 4;

            fprintf(fp, 
"<p class=Normal>&nbsp;</p>\n"
"<p class=Bold>Combiner Stage %d:</p>\n", dwStageCount++);

            PrintCombinerDescription(fp, pDescPtr, FALSE);
            fprintf(fp, "<p class=Normal>Inputs:</p>\n");
            
            fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");
            PrintRegisterBlock(ptr, fp, UsedInputRegisters);
            ptr += 20;
            fprintf(fp, "</table>\n");
            
            if((*ptr & 0xff000000) == PSS_STAGE)
            {
                fprintf(fp, "<p class=Normal>Outputs:</p>\n");
                fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");
                PrintRegisterBlock(ptr+5, fp, UsedOutputRegisters);
                fprintf(fp, "</table>\n");
            }
            else if((*ptr & 0xff000000) == PSS_FINALSTAGE)
            {
                fprintf(fp, "<p class=Normal>Outputs (saturated):</p>\n");
                fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");
                PrintRegisterBlock(ptr+3, fp, UsedOutputRegisters);
                fprintf(fp, "</table>\n");
            }
            break;

        case PSS_FINALSTAGE:
            fprintf(fp, 
"<p class=Normal>&nbsp;</p>\n"
"<p class=Bold>Final Combiner Stage:</p>\n");
            ptr++;
            pDescPtr = ptr;   // save combiner description pointer
            ptr += 2;

            PrintCombinerDescription(fp, pDescPtr, TRUE);
            fprintf(fp, "<p class=Normal>Inputs:</p>\n");
            fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");
            PrintRegisterBlock(ptr, fp, UsedInputRegisters);
            fprintf(fp, "</table>\n");
            
            fprintf(fp, "<p class=Normal>Output:</p>\n");
            fprintf(fp, 
"<table border=1 cellspacing=0 cellpadding=0 style='margin-left:.30in;border-collapse:collapse;border:none'>\n");
            short output[4];
            output[0] = (SHORT)((dwCPost >> 16) & 0xff);
            output[1] = (SHORT)((dwCPost >> 24) & 0xff);
            output[2] = (SHORT)((dwCPost >>  0) & 0xff);
            output[3] = (SHORT)((dwCPost >>  8) & 0xff);
            PrintReg((DWORD *)output, "Out", "RedReg", fp, FALSE, 0); 
            fprintf(fp, "</table>\n");

            ptr += 20;
            break;

        case PSS_PIXEL:
        case PSS_FINAL:
        case PSS_IMAGE:
            ptr += (*ptr & 0x00ffffff);
            break;

        default:
            return FALSE;   //unrecognized opcode
        }
    }

    return TRUE;
}

void GenerateHTML(BYTE *buf, FILE *fp)
{
    DWORD *ptr;
    DWORD dwX, dwY, dwColor, dwDepth;
    struct tm *newtime;
    time_t aclock;

    time( &aclock );                 /* Get time in seconds */
    newtime = localtime( &aclock );  /* Convert time to struct tm form*/

    // Find the pixel coordinates
    ptr = FindOpcode(PSS_PIXEL, buf);
    if(!ptr) goto error;
    ptr++;
    dwX = *ptr & 0xffff;
    dwY = (*ptr >> 16) & 0xffff;

    // print html header
    fprintf(fp,
"<html>\n"
"<head>\n"
"<title>Pixel Shader Snapshot <%d,%d></title>\n"
"<style>\n"
"<!--\n"
" p.Normal    {margin:0in;font-size:10.0pt;font-family:\"Courier New\";}\n"
" p.Bold      {margin:0in;font-size:10.0pt;font-family:\"Courier New\";font-weight:\"bold\"}\n"
" p.Tiny      {margin:0in;font-size:8.0pt;font-family:\"Arial\";}\n"
" p.Big       {margin:0in;font-size:14.0pt;font-family:\"Courier New\";}\n"
" td.RedReg   {background:#ffd0d0;padding:0in 5.4pt 0in 5.4pt;}\n"
" td.CyanReg  {background:#d0FFFF;padding:0in 5.4pt 0in 5.4pt;}\n"
" td.OReg     {background:#FFFFbb;padding:0in 5.4pt 0in 5.4pt;}\n"
" td.GreenReg {background:#d0ffd0;padding:0in 5.4pt 0in 5.4pt;}\n"
" td.TanReg   {background:#ffddaa;padding:0in 5.4pt 0in 5.4pt;} \n"
"-->\n"
"</style>\n"
"</head>\n"
"<body bgcolor=d0d0d0>\n"
"<p class=Big><B>Pixel Shader Snapshot for Pixel <%d,%d></B></p>\n"
"<SCRIPT type=\"text\\javascript\">\n"
"<!--\n"
"function change(a,b,c,d,vari)\n"
"{\n"
"  if (vari.innerHTML==a) vari.innerHTML = b;\n"
"  else if (vari.innerHTML==b) vari.innerHTML = c;\n"
"  else if (vari.innerHTML==c) vari.innerHTML = d;\n"
"  else vari.innerHTML = a;\n"
"}\n"
"// -->\n"
"function launchCapture()\n"
"{\n"
"    var cmdline = \"\"\n"
"    cmdline = \"xbpscapture.exe \" + window.event.offsetX + \" \" + window.event.offsetY\n"
"    var WshShell = new ActiveXObject(\"WScript.Shell\");\n"
"    WshShell.Run(cmdline);\n"
"}\n"
"</SCRIPT>\n"
"<p class=Normal>&nbsp;</p>\n"
"<p class=Normal>%s</p>\n"
"<img onmouseover=\"this.style.cursor='crosshair'\" onclick=\"launchCapture()\" src=\"%s\">\n"
"<table border=0 cellspacing=10 cellpadding=0 style='border-collapse:collapse;border:none'>\n"
" <tr>\n"
"  <td><p class=Normal><img width=256 height=256 src=\"%s\"></p></td>\n"
"  <td><p class=Normal><img width=256 height=256 src=\"%s\"></p></td>\n"
" </tr>\n"
" <tr>\n"
"  <td align=center><p class=Normal>64x64 pixels around sample point</p></td>\n"
"  <td align=center><p class=Normal>5x5 pixels around sample point</p></td>\n"
" </tr>\n"
" <tr>\n"
"  <td align=center><p class=Normal>(scaled 4x, center 5x5 marked)</p></td>\n"
"  <td align=center><p class=Normal>(scaled 51.2x)</p></td>\n"
" </tr>\n"
"</table>\n"
"<p class=Normal>&nbsp;</p>\n", dwX, dwY, dwX, dwY, asctime( newtime ), 
                                g_BMP3Filename, g_BMPFilename, g_BMP2Filename);

    if(g_dwFlags & 0x1)
    {
        fprintf(fp, "<p class=Bold>Pixels filtered by debug marker %d</p>\n", g_dwMarker);
    }
    
    fprintf(fp, "<p class=Normal>&nbsp;</p>\n");

    // Find the final framebuffer values
    ptr = FindOpcode(PSS_FINAL, buf);
    if(!ptr) goto error;
    ptr++;
    dwColor = *ptr++;
    dwDepth = *ptr;
    fprintf(fp,
"<table border=1 cellspacing=0 cellpadding=0 style='border-collapse:collapse;border:none'>\n"
" <tr>\n"
"  <td class=RedReg><p class=Normal>Final values for <%d,%d>:</p></td>\n"
"  <td class=RedReg><p class=Normal>depth=0x%08x</p></td>\n"
"  <td class=RedReg><p class=Normal>color=0x%08x</p></td>\n"
"  <td width=10 style='background:#%06x'></td>\n"
"  <td width=30 style='background:#%06x'></td>\n"
" </tr>\n"
"</table>\n"
"<p class=Normal>&nbsp;</p>\n", dwX, dwY, dwDepth, dwColor, smearalpha(dwColor) & 0xffffff, dwColor & 0xffffff);

    if(!ParsePrimitives(buf, fp)) goto error;
    fprintf(fp, "</body>\n</html>\n");
    return;

error:
    fprintf(fp, "Error parsing snapshot data\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\bin\i386mk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    i386mk.inc

Abstract:

        This module contains the x86 specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
DELAYLOAD_VERSION=0x0100
!endif

#
# x86 option control
#
UMBASE=$(UMBASE:*=i386)
UMLIBS=$(UMLIBS:*=i386)
NTRES=$(NTRES:*=i386)
UMRES=$(UMRES:*=i386)
UMOBJS=$(UMOBJS:*=i386)
LINKLIBS=$(LINKLIBS:*=i386)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=i386)
DLLBASE=$(DLLBASE:*=i386)
DLLDEF=$(DLLDEF:*=i386)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=i386)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=i386)
DYNLINK_LIB=$(DYNLINK_LIB:*=i386)
TARGETEXEFILES=$(TARGETEXEFILES:*=i386)
TARGETLIBFILES=$(TARGETLIBFILES:*=i386)
TARGETOBJFILES=$(TARGETOBJFILES:*=i386)
UMOBJFILES=$(UMOBJFILES:*=i386)
UMEXEFILES=$(UMEXEFILES:*=i386)
HEADERFILE=$(HEADERFILE:*=i386)
HEADEROBJNAME=$(HEADEROBJNAME:*=i386)
HEADEROBJ=$(HEADEROBJ:*=i386)
PRECOMPILED=$(PRECOMPILED:*=i386)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=i386)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=i386)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=i386)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=i386)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=i386)
ORDER=$(ORDER:*=i386)
OBJLIBFILES=$(OBJLIBFILES:*=i386)
MISCFILES=$(MISCFILES) $(I386_MISCFILES)

!ifdef CHICAGO_PRODUCT
USE_MAPSYM=1
!endif

# "$(TARGETTYPE)"=="DRIVER"     ||
# "$(TARGETTYPE)" == "HAL" ||
# "$(TARGETTYPE)" == "EXPORT_DRIVER" ||

!IF "$(TARGETTYPE)"=="GDI_DRIVER" || \
    "$(TARGETTYPE)"=="MINIPORT"
#
#Drivers don't link with link libs.
#
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!ELSE
!IF defined(USE_NTDLL) || defined (USE_NOLIBS)
! ifndef RESOURCE_ONLY_DLL
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
! endif
!ENDIF
!ENDIF

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=i386)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=i386)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=i386)
!endif

!IF "$(DLLENTRY)" != "-noentry"
!   IF "$(DLLENTRY:@12=)" == "$(DLLENTRY)"
DLLENTRY=$(DLLENTRY)@12
!   ENDIF
!ENDIF

!IFDEF STD_CALL_ENTRY
UMENTRY=$(UMENTRY)@4
!ENDIF

ENTRY_SUFFIX=@4
GDI_ENTRY_SUFFIX=@12

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS)

!IFDEF 386_WARNING_LEVEL
MSC_WARNING_LEVEL=$(386_WARNING_LEVEL)
!ENDIF

!ifdef 386_PERFFLAGS
PERFFLAGS = $(386_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(386_OPTIMIZATION)
MSC_OPTIMIZATION=$(386_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

!ifdef NOCODFLAGS
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION:/FAcs=)
USER_C_FLAGS=$(USER_C_FLAGS:/FAcs=)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

!IFDEF 386_CPPFLAGS
MSC_CPPFLAGS=$(386_CPPFLAGS)
!ENDIF

!ifdef USE_VS70_RULES

!else # USE_VS70_RULES

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

! ifdef USE_RTTI
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif

!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!else
EH_FLAGS=/GX-
!endif

!ifdef USE_INCREMENTAL_COMPILING
! ifndef RESOURCE_ONLY_DLL
C_INCREMENTAL_FLAG = /Gi /Gm
USE_PDB_TO_COMPILE = 1
!endif
!else
C_INCREMENTAL_FLAG = /Gi- /Gm-
!endif

!ifndef X86_CPU_OPTIMIZATION
X86_CPU_OPTIMIZATION=/GB
!endif

# Undocumented switch definitions
# /QIfdiv- : Don't emit code to test for bad pentiums
# /QIf     : Emit FPO records for every function
# /QI0f    : Workaround Pentium bug

# ERATTA_FLAGS=/QIfdiv- /QIf
ERATTA_FLAGS=/QIfdiv- /QIf /QI0f

!ifdef NEWCOMPILER
# /d2compflag : Emit VC5 compatible S_COMPILE symbolic records.
ERATTA_FLAGS=$(ERATTA_FLAGS) /d2compflag

!if [set __GUIDLIB_CL_FLAGS=/d2compflag]
!endif
!endif

STDFLAGS= /c /Zel /Zp8 /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(X86_CPU_OPTIMIZATION) $(C_INCREMENTAL_FLAG) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING)

!IF "$(386_STDCALL)" == "0"
MSC_CALL_TYPE=/Gd
MSC_CALL_DEFINE=
!ELSE
!   IF "$(386_STDCALL)" == "2"
MSC_CALL_TYPE=/Gr
MSC_CALL_DEFINE=
!   ELSE
MSC_CALL_TYPE=/Gz
MSC_CALL_DEFINE=-DSTD_CALL
!   ENDIF
!ENDIF

!IF $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!   IFDEF NTNOFPO
!MESSAGE $(NTMAKEENV)\i386mk.inc(1) : Overriding FPO default with NTNOFPO
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-
!   ELSE
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=1
DBGFLAGS=$(DBGFLAGS) /Oy
!   ENDIF
!ELSE
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
!ENDIF

!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
USE_PDB=1
!ENDIF

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! ifdef USE_VS70_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGETNAME).pdb
!  IF [ if not exist $(TARGETPATH) mkdir $(TARGETPATH) ]
!  ENDIF
!  else if "$(COMPILE_PDB_NAME)" != ""
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386\$(COMPILE_PDB_NAME).pdb
!  else if "$(TARGETNAME)" != ""
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386\$(TARGETNAME)_COMP.pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
!  endif
! else ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
!  ifndef ROOT
ROOT=$(MAKEDIR)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(ROOT)\$(_OBJ_DIR)\i386\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\i386^\
! endif
!endif

#
# 386 option control
#

ENV_DEFINES= $(MSC_CPPFLAGS) $(NTCPPFLAGS)

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF

STD_DEFINES= -D_X86_=1 -Di386=1 $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) $(ENV_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES) $(USER_C_DEFINES)
CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
386_ASMFLAGS=$(386_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ENV_DEFINES) $(ASM_DEFINES)

386_CDEFINES=$(CDEFINES)
386_CFLAGS=$(CFLAGS)

!if "$(SUBSTITUTE_386_CC)" != ""
CC_NAME = $(SUBSTITUTE_386_CC) -nologo
!else
CC_NAME = $(VC_PATH)cl -nologo
!endif

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef 386_ASSEMBLER_NAME
386_ASSEMBLER_NAME  = ml
!endif

GLOBAL_C_FLAGS = -Ii386\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(CC_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(CXX_FLAGS) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

!if defined(NOMASMCOMPATIBILITY)
386_ASSEMBLER=$(386_ASSEMBLER_NAME) -c -coff -Cx -nologo -Ii386\ -I. $(INCPATH1) $(386_ASMFLAGS)
!else
386_ASSEMBLER=$(386_ASSEMBLER_NAME) -c -coff -Cx -nologo -Ii386\ -I. $(INCPATH1) -Zm $(386_ASMFLAGS)
!endif

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)

ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)


{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

{..\i386\}.asm{}.lst:
    $(386_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\i386\$(@B).obj $<

{i386\}.asm{}.lst:
    $(386_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\i386\$(@B).obj $<

{..\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $<

{$(_OBJ_DIR)\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $<

{i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $<

!IFDEF _NT386LIBS
_NTLIBS=$(_NT386LIBS)
!ENDIF

COPYDST=$(386COPYDST)
LIB_COPY=nti386cp.cmd

!IFDEF SILVER
NTTEST_LINK_OPTIONS=-fixed -base:0x80100000 -entry:main
!ELSE
NTTEST_LINK_OPTIONS=-fixed -base:0x80010000 -entry:main
!ENDIF

!if 0
!if defined(LINKER_WIN98OPT) || defined (CHICAGO_PRODUCT)
LINKER_FLAGS=$(LINKER_FLAGS) /opt:win98
!else
LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NTDDKCOMP__

/*
 * pointer to video memory
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDMEM *LPVIDMEM;

#else

/*
 * pointer to video memory, potentially 64-bit
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDEOMEMORY *LPVIDMEM;

#endif

/*
 * Structure for querying extended heap alignment requirements
 */

typedef struct _SURFACEALIGNMENT
{
    union
    {
        struct
        {
            DWORD       dwStartAlignment;
            DWORD       dwPitchAlignment;
            DWORD       dwFlags;
            DWORD       dwReserved2;
        } Linear;
        struct
        {
            DWORD       dwXAlignment;
            DWORD       dwYAlignment;
            DWORD       dwFlags;
            DWORD       dwReserved2;
        } Rectangular;
    };
} SURFACEALIGNMENT;
typedef struct _SURFACEALIGNMENT FAR *LPSURFACEALIGNMENT;

#define SURFACEALIGN_DISCARDABLE	0x00000001l /* Surface can be discarded to   */
                                                    /* make room for another surface */


typedef struct _HEAPALIGNMENT
{
    DWORD                dwSize;
    DDSCAPS              ddsCaps;       /* Indicates which alignment fields are valid.*/
    DWORD                dwReserved;
    SURFACEALIGNMENT     ExecuteBuffer; /* Surfaces tagged with DDSCAPS_EXECUTEBUFFER */
    SURFACEALIGNMENT     Overlay;       /* Surfaces tagged with DDSCAPS_OVERLAY       */
    SURFACEALIGNMENT     Texture;       /* Surfaces tagged with DDSCAPS_TEXTURE       */
    SURFACEALIGNMENT     ZBuffer;       /* Surfaces tagged with DDSCAPS_ZBUFFER       */
    SURFACEALIGNMENT     AlphaBuffer;   /* Surfaces tagged with DDSCAPS_ALPHA         */
    SURFACEALIGNMENT     Offscreen;     /* Surfaces tagged with DDSCAPS_OFFSCREENPLAIN*/
    SURFACEALIGNMENT     FlipTarget;    /* Surfaces whose bits are potential primaries i.e. back buffers*/
} HEAPALIGNMENT;
typedef struct _HEAPALIGNMENT FAR *LPHEAPALIGNMENT;

typedef struct _DD_GETHEAPALIGNMENTDATA
{
    ULONG_PTR                  dwInstance;         // driver context
    DWORD                      dwHeap;             // heap index passed by DirectDraw
    HRESULT                    ddRVal;             // return value
    VOID*                      GetHeapAlignment;   // Unused: Win95 compatibility
    HEAPALIGNMENT              Alignment;          // Filled in by driver.
} DD_GETHEAPALIGNMENTDATA;
typedef struct _DD_GETHEAPALIGNMENTDATA *PDD_GETHEAPALIGNMENTDATA;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
    BOOL                bDiscardable;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    /*
     * The pUp, pDown, pLeft and pRight members were removed in DX5
     */
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
    FLATPTR             pBits;
    BOOL                bDiscardable;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

typedef struct _VMEMHEAP
{
    DWORD		        dwFlags;
    DWORD                       stride;
    LPVOID		        freeList;
    LPVOID		        allocList;
    DWORD                       dwTotalSize;
    FLATPTR                     fpGARTLin;      /* AGP: GART linear base of heap (app. visible)   */
    FLATPTR                     fpGARTDev;      /* AGP: GART device base of heap (driver visible) */
    DWORD                       dwCommitedSize; /* AGP: Number of bytes commited to heap          */
    /*
     * Extended alignment data:
     * Filled in by DirectDraw in response to a GetHeapAlignment HAL call.
     */
    DWORD                       dwCoalesceCount;
    HEAPALIGNMENT               Alignment;
    /*
     * These are analogous to VIDMEM.ddsCaps and VIDMEM.ddsCapsAlt. These values are queried from the
     * driver by a GetDriverInfo call. See the documentation for GUID_DDMoreSurfaceCaps
     */
    DDSCAPSEX                   ddsCapsEx;
    DDSCAPSEX                   ddsCapsExAlt;
#ifndef IS_16
    // Full physical address of heap base for NT AGP heaps.
    LARGE_INTEGER               liPhysAGPBase;
#endif
    // hdev for use with VidMemAllocAligned on NT.  Set by the system at
    // initialization time.
    HANDLE                      hdevAGP;
    // Physical reservation handle for NT heaps.
    LPVOID                      pvPhysRsrv;
} VMEMHEAP;

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l /* Heap is linear                    */
#define VMEMHEAP_RECTANGULAR		0x00000002l /* Heap is rectangular               */
#define VMEMHEAP_ALIGNMENT  		0x00000004l /* Heap has extended alignment info  */

/*
 * This legacy export doesn't handle nonlocal heaps
 * This function is not available on Windows NT
 */
#ifndef __NTDDKCOMP__
extern FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
#endif

/*
 * This export can be used by drivers to allocate aligned surfaces from heaps which
 * they have previously exposed to DirectDraw. This function can allocate from nonlocal heaps.
 */
extern FLATPTR WINAPI HeapVidMemAllocAligned(
                LPVIDMEM lpVidMem,
                DWORD dwWidth,
                DWORD dwHeight,
                LPSURFACEALIGNMENT lpAlignment ,
                LPLONG lpNewPitch );

/*
 * This export can free memory allocated via either allocation function
 */
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\dx95type.h ===
/******************************Module*Header*******************************\
*
* Module Name: dx95type.h
*
* Portability module for NT kernel-mode DirectX components created from
* Win95 sources
*
* Copyright (c) 1996-1997 Microsoft Corp.
*
\**************************************************************************/

#ifndef __DX95TYPE_H__
#define __DX95TYPE_H__

// Basic includes
#ifndef NODXINCLUDES
#ifdef WINNT
#include <stddef.h>
// Includes ddrawint.h and d3dnthal.h
#include <winddi.h>
#else // WINNT
#include <ddrawi.h>
#include <d3dhal.h>
#endif // WINNT
#endif // NODXINCLUDES

// Simple memory allocation of N bytes
#ifndef NODXMALLOC
#ifdef WINNT
#define DXMALLOC(n) EngAllocMem(0, n, 'amxD')
#define DXMALLOCZ(n) EngAllocMem(FL_ZERO_MEMORY, n, 'amxD')
#define DXFREE(p) EngFreeMem(p)
#else // WINNT
#define DXMALLOC(n) HeapAlloc(GetProcessHeap(), 0, n)
#define DXMALLOCZ(n) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n)
#define DXFREE(n) HeapFree(GetProcessHeap(), 0, n)
#endif // WINNT
#endif // NODXMALLOC

// Surface and palette access macros
#ifndef NODXLCL
#ifdef WINNT
#define DDS_LCL(pdds) (pdds)
#define DDP_LCL(pddp) (pddp)
#else // WINNT
#define DDS_LCL(pdds) (((DDRAWI_DDRAWSURFACE_INT *)(pdds))->lpLcl)
#define DDP_LCL(pddp) (((DDRAWI_DDRAWPALETTE_INT *)(pddp))->lpLcl)
#endif // WINNT
#define DDS_LCL_OR_NULL(pdds) ((pdds) == NULL ? NULL : DDS_LCL(pdds))
#define DDP_LCL_OR_NULL(pddp) ((pddp) == NULL ? NULL : DDP_LCL(pddp))
#endif // NODXLCL

// Typedefs and defines to create a Win95-like compilation environment

#ifndef NODX95TYPES
#ifdef WINNT

typedef D3DNTHALDEVICEDESC_V1           D3DDEVICEDESC_V1;
typedef PDD_SURFACE_LOCAL               LPDDRAWI_DDRAWSURFACE_LCL;
typedef PDD_SURFACE_MORE                LPDDRAWI_DDRAWSURFACE_MORE;
typedef PDD_SURFACE_GLOBAL              LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_DIRECTDRAW_GLOBAL           LPDDRAWI_DIRECTDRAW_GBL;
typedef PDD_ATTACHLIST                  LPATTACHLIST;

typedef DDNTCORECAPS                    DDCORECAPS;
typedef PDDNTCORECAPS                   LPDDCORECAPS;
typedef DD_HALINFO                      DDHALINFO;
typedef PDD_HALINFO                     LPDDHALINFO;
typedef DD_MORECAPS                     DDMORECAPS;
typedef PDD_MORECAPS                    LPDDMORECAPS;

// DirectDraw HAL function data structures

typedef PDD_CREATEPALETTEDATA           LPDDHAL_CREATEPALETTEDATA;
typedef PDD_CREATESURFACEDATA           LPDDHAL_CREATESURFACEDATA;
typedef PDD_CREATESURFACEEXDATA         LPDDHAL_CREATESURFACEEXDATA;
typedef PDD_CANCREATESURFACEDATA        LPDDHAL_CANCREATESURFACEDATA;
typedef PDD_WAITFORVERTICALBLANKDATA    LPDDHAL_WAITFORVERTICALBLANKDATA;
typedef PDD_DESTROYDRIVERDATA           LPDDHAL_DESTROYDRIVERDATA;
typedef PDD_SETMODEDATA                 LPDDHAL_SETMODEDATA;
typedef PDD_DRVSETCOLORKEYDATA          LPDDHAL_DRVSETCOLORKEYDATA;
typedef PDD_GETSCANLINEDATA             LPDDHAL_GETSCANLINEDATA;
typedef PDD_MAPMEMORYDATA               LPDDHAL_MAPMEMORYDATA;
typedef PDD_SETEXCLUSIVEMODEDATA        LPDDHAL_SETEXCLUSIVEMODEDATA;
typedef PDD_FLIPTOGDISURFACEDATA        LPDDHAL_FLIPTOGDISURFACEDATA;
typedef PDD_UPDATENONLOCALHEAPDATA      LPDDHAL_UPDATENONLOCALHEAPDATA;
typedef PDD_GETHEAPALIGNMENTDATA        LPDDHAL_GETHEAPALIGNMENTDATA;
typedef DD_CREATEPALETTEDATA            DDHAL_CREATEPALETTEDATA;
typedef DD_CREATESURFACEDATA            DDHAL_CREATESURFACEDATA;
typedef DD_CREATESURFACEEXDATA          DDHAL_CREATESURFACEEXDATA;
typedef DD_CANCREATESURFACEDATA         DDHAL_CANCREATESURFACEDATA;
typedef DD_WAITFORVERTICALBLANKDATA     DDHAL_WAITFORVERTICALBLANKDATA;
typedef DD_DRVSETCOLORKEYDATA           DDHAL_DRVSETCOLORKEYDATA;
typedef DD_GETSCANLINEDATA              DDHAL_GETSCANLINEDATA;
typedef DD_MAPMEMORYDATA                DDHAL_MAPMEMORYDATA;
typedef DD_SETEXCLUSIVEMODEDATA         DDHAL_SETEXCLUSIVEMODEDATA;
typedef DD_FLIPTOGDISURFACEDATA         DDHAL_FLIPTOGDISURFACEDATA;
typedef DD_UPDATENONLOCALHEAPDATA       DDHAL_UPDATENONLOCALHEAPDATA;

typedef PDD_DESTROYPALETTEDATA          LPDDHAL_DESTROYPALETTEDATA;
typedef PDD_SETENTRIESDATA              LPDDHAL_SETENTRIESDATA;
typedef DD_DESTROYPALETTEDATA           DDHAL_DESTROYPALETTEDATA;
typedef DD_SETENTRIESDATA               DDHAL_SETENTRIESDATA;

typedef PDD_BLTDATA                     LPDDHAL_BLTDATA;
typedef PDD_LOCKDATA                    LPDDHAL_LOCKDATA;
typedef PDD_UNLOCKDATA                  LPDDHAL_UNLOCKDATA;
typedef PDD_UPDATEOVERLAYDATA           LPDDHAL_UPDATEOVERLAYDATA;
typedef PDD_SETOVERLAYPOSITIONDATA      LPDDHAL_SETOVERLAYPOSITIONDATA;
typedef PDD_SETPALETTEDATA              LPDDHAL_SETPALETTEDATA;
typedef PDD_FLIPDATA                    LPDDHAL_FLIPDATA;
typedef PDD_DESTROYSURFACEDATA          LPDDHAL_DESTROYSURFACEDATA;
typedef PDD_SETCLIPLISTDATA             LPDDHAL_SETCLIPLISTDATA;
typedef PDD_ADDATTACHEDSURFACEDATA      LPDDHAL_ADDATTACHEDSURFACEDATA;
typedef PDD_SETCOLORKEYDATA             LPDDHAL_SETCOLORKEYDATA;
typedef PDD_GETBLTSTATUSDATA            LPDDHAL_GETBLTSTATUSDATA;
typedef PDD_GETFLIPSTATUSDATA           LPDDHAL_GETFLIPSTATUSDATA;
typedef PDD_GETAVAILDRIVERMEMORYDATA    LPDDHAL_GETAVAILDRIVERMEMORYDATA;
typedef PDD_GETDRIVERINFODATA           LPDDHAL_GETDRIVERINFODATA;
typedef PDD_GETDRIVERSTATEDATA          LPDDHAL_GETDRIVERSTATEDATA;
typedef PDD_DESTROYDDLOCALDATA          LPDDHAL_DESTROYDDLOCALDATA;
typedef DD_BLTDATA                      DDHAL_BLTDATA;
typedef DD_LOCKDATA                     DDHAL_LOCKDATA;
typedef DD_UNLOCKDATA                   DDHAL_UNLOCKDATA;
typedef DD_UPDATEOVERLAYDATA            DDHAL_UPDATEOVERLAYDATA;
typedef DD_SETOVERLAYPOSITIONDATA       DDHAL_SETOVERLAYPOSITIONDATA;
typedef DD_SETPALETTEDATA               DDHAL_SETPALETTEDATA;
typedef DD_FLIPDATA                     DDHAL_FLIPDATA;
typedef DD_DESTROYSURFACEDATA           DDHAL_DESTROYSURFACEDATA;
typedef DD_SETCLIPLISTDATA              DDHAL_SETCLIPLISTDATA;
typedef DD_ADDATTACHEDSURFACEDATA       DDHAL_ADDATTACHEDSURFACEDATA;
typedef DD_SETCOLORKEYDATA              DDHAL_SETCOLORKEYDATA;
typedef DD_GETBLTSTATUSDATA             DDHAL_GETBLTSTATUSDATA;
typedef DD_GETFLIPSTATUSDATA            DDHAL_GETFLIPSTATUSDATA;
typedef DD_GETAVAILDRIVERMEMORYDATA     DDHAL_GETAVAILDRIVERMEMORYDATA;
typedef DD_GETDRIVERINFODATA            DDHAL_GETDRIVERINFODATA;
typedef DD_GETDRIVERSTATEDATA           DDHAL_GETDRIVERSTATEDATA;
typedef DD_DESTROYDDLOCALDATA           DDHAL_DESTROYDDLOCALDATA;

typedef PDD_CANCREATEVPORTDATA          LPDDHAL_CANCREATEVPORTDATA;
typedef PDD_CREATEVPORTDATA             LPDDHAL_CREATEVPORTDATA;
typedef PDD_FLIPVPORTDATA               LPDDHAL_FLIPVPORTDATA;
typedef PDD_GETVPORTCONNECTDATA         LPDDHAL_GETVPORTCONNECTDATA;
typedef PDD_GETVPORTBANDWIDTHDATA       LPDDHAL_GETVPORTBANDWIDTHDATA;
typedef PDD_GETVPORTINPUTFORMATDATA     LPDDHAL_GETVPORTINPUTFORMATDATA;
typedef PDD_GETVPORTOUTPUTFORMATDATA    LPDDHAL_GETVPORTOUTPUTFORMATDATA;
typedef PDD_GETVPORTFIELDDATA           LPDDHAL_GETVPORTFIELDDATA;
typedef PDD_GETVPORTLINEDATA            LPDDHAL_GETVPORTLINEDATA;
typedef PDD_DESTROYVPORTDATA            LPDDHAL_DESTROYVPORTDATA;
typedef PDD_GETVPORTFLIPSTATUSDATA      LPDDHAL_GETVPORTFLIPSTATUSDATA;
typedef PDD_UPDATEVPORTDATA             LPDDHAL_UPDATEVPORTDATA;
typedef PDD_WAITFORVPORTSYNCDATA        LPDDHAL_WAITFORVPORTSYNCDATA;
typedef PDD_GETVPORTSIGNALDATA          LPDDHAL_GETVPORTSIGNALDATA;
typedef PDD_VPORTCOLORDATA              LPDDHAL_VPORTCOLORDATA;
typedef DD_CANCREATEVPORTDATA           DDHAL_CANCREATEVPORTDATA;
typedef DD_CREATEVPORTDATA              DDHAL_CREATEVPORTDATA;
typedef DD_FLIPVPORTDATA                DDHAL_FLIPVPORTDATA;
typedef DD_GETVPORTCONNECTDATA          DDHAL_GETVPORTCONNECTDATA;
typedef DD_GETVPORTBANDWIDTHDATA        DDHAL_GETVPORTBANDWIDTHDATA;
typedef DD_GETVPORTINPUTFORMATDATA      DDHAL_GETVPORTINPUTFORMATDATA;
typedef DD_GETVPORTOUTPUTFORMATDATA     DDHAL_GETVPORTOUTPUTFORMATDATA;
typedef DD_GETVPORTFIELDDATA            DDHAL_GETVPORTFIELDDATA;
typedef DD_GETVPORTLINEDATA             DDHAL_GETVPORTLINEDATA;
typedef DD_DESTROYVPORTDATA             DDHAL_DESTROYVPORTDATA;
typedef DD_GETVPORTFLIPSTATUSDATA       DDHAL_GETVPORTFLIPSTATUSDATA;
typedef DD_UPDATEVPORTDATA              DDHAL_UPDATEVPORTDATA;
typedef DD_WAITFORVPORTSYNCDATA         DDHAL_WAITFORVPORTSYNCDATA;
typedef DD_GETVPORTSIGNALDATA           DDHAL_GETVPORTSIGNALDATA;
typedef DD_VPORTCOLORDATA               DDHAL_VPORTCOLORDATA;

typedef PDD_COLORCONTROLDATA            LPDDHAL_COLORCONTROLDATA;
typedef DD_COLORCONTROLDATA             DDHAL_COLORCONTROLDATA;

typedef PDD_SYNCSURFACEDATA             LPDDHAL_SYNCSURFACEDATA;
typedef PDD_SYNCVIDEOPORTDATA           LPDDHAL_SYNCVIDEOPORTDATA;
typedef DD_SYNCSURFACEDATA              DDHAL_SYNCSURFACEDATA;
typedef DD_SYNCVIDEOPORTDATA            DDHAL_SYNCVIDEOPORTDATA;

typedef PDD_GETMOCOMPGUIDSDATA          LPDDHAL_GETMOCOMPGUIDSDATA;
typedef PDD_GETMOCOMPFORMATSDATA        LPDDHAL_GETMOCOMPFORMATSDATA;
typedef PDD_CREATEMOCOMPDATA            LPDDHAL_CREATEMOCOMPDATA;
typedef PDD_GETMOCOMPCOMPBUFFDATA       LPDDHAL_GETMOCOMPCOMPBUFFDATA;
typedef PDD_GETINTERNALMOCOMPDATA       LPDDHAL_GETINTERNALMOCOMPDATA;
typedef PDD_BEGINMOCOMPFRAMEDATA        LPDDHAL_BEGINMOCOMPFRAMEDATA;
typedef PDD_ENDMOCOMPFRAMEDATA          LPDDHAL_ENDMOCOMPFRAMEDATA;
typedef PDD_RENDERMOCOMPDATA            LPDDHAL_RENDERMOCOMPDATA;
typedef PDD_QUERYMOCOMPSTATUSDATA       LPDDHAL_QUERYMOCOMPSTATUSDATA;
typedef PDD_DESTROYMOCOMPDATA           LPDDHAL_DESTROYMOCOMPDATA;
typedef DD_GETMOCOMPGUIDSDATA           DDHAL_GETMOCOMPGUIDSDATA;
typedef DD_GETMOCOMPFORMATSDATA         DDHAL_GETMOCOMPFORMATSDATA;
typedef DD_CREATEMOCOMPDATA             DDHAL_CREATEMOCOMPDATA;
typedef DD_GETMOCOMPCOMPBUFFDATA        DDHAL_GETMOCOMPCOMPBUFFDATA;
typedef DD_GETINTERNALMOCOMPDATA        DDHAL_GETINTERNALMOCOMPDATA;
typedef DD_BEGINMOCOMPFRAMEDATA         DDHAL_BEGINMOCOMPFRAMEDATA;
typedef DD_ENDMOCOMPFRAMEDATA           DDHAL_ENDMOCOMPFRAMEDATA;
typedef DD_RENDERMOCOMPDATA             DDHAL_RENDERMOCOMPDATA;
typedef DD_QUERYMOCOMPSTATUSDATA        DDHAL_QUERYMOCOMPSTATUSDATA;
typedef DD_DESTROYMOCOMPDATA            DDHAL_DESTROYMOCOMPDATA;

// DirectDraw HAL call backs

typedef PDD_SETCOLORKEY                 LPDDHAL_SETCOLORKEY;
typedef PDD_CANCREATESURFACE            LPDDHAL_CANCREATESURFACE;
typedef PDD_WAITFORVERTICALBLANK        LPDDHAL_WAITFORVERTICALBLANK;
typedef PDD_CREATESURFACE               LPDDHAL_CREATESURFACE;
typedef PDD_DESTROYDRIVER               LPDDHAL_DESTROYDRIVER;
typedef PDD_SETMODE                     LPDDHAL_SETMODE;
typedef PDD_CREATEPALETTE               LPDDHAL_CREATEPALETTE;
typedef PDD_GETSCANLINE                 LPDDHAL_GETSCANLINE;
typedef PDD_MAPMEMORY                   LPDDHAL_MAPMEMORY;
typedef PDD_GETAVAILDRIVERMEMORY        LPDDHAL_GETAVAILDRIVERMEMORY;
typedef PDD_GETDRIVERINFODATA           LPDDHAL_GETDRIVERINFODATA;
typedef PDD_SYNCSURFACEDATA             LPDDHAL_SYNCSURFACEDATA;
typedef PDD_SYNCVIDEOPORTDATA           LPDDHAL_SYNCVIDEOPORTDATA;
typedef PDD_SETEXCLUSIVEMODE            LPDDHAL_SETEXCLUSIVEMODE;
typedef PDD_FLIPTOGDISURFACE            LPDDHAL_FLIPTOGDISURFACE;

typedef PDD_ALPHABLT                    LPDDHAL_ALPHABLT;
typedef PDD_CREATESURFACEEX             LPDDHAL_CREATESURFACEEX;
typedef PDD_GETDRIVERSTATE              LPDDHAL_GETDRIVERSTATE;

typedef PDD_PALCB_DESTROYPALETTE        LPDDHALPALCB_DESTROYPALETTE;
typedef PDD_PALCB_SETENTRIES            LPDDHALPALCB_SETENTRIES;

typedef PDD_SURFCB_LOCK                 LPDDHALSURFCB_LOCK;
typedef PDD_SURFCB_UNLOCK               LPDDHALSURFCB_UNLOCK;
typedef PDD_SURFCB_BLT                  LPDDHALSURFCB_BLT;
typedef PDD_SURFCB_UPDATEOVERLAY        LPDDHALSURFCB_UPDATEOVERLAY;
typedef PDD_SURFCB_SETOVERLAYPOSITION   LPDDHALSURFCB_SETOVERLAYPOSITION;
typedef PDD_SURFCB_SETPALETTE           LPDDHALSURFCB_SETPALETTE;
typedef PDD_SURFCB_FLIP                 LPDDHALSURFCB_FLIP;
typedef PDD_SURFCB_DESTROYSURFACE       LPDDHALSURFCB_DESTROYSURFACE;
typedef PDD_SURFCB_SETCLIPLIST          LPDDHALSURFCB_SETCLIPLIST;
typedef PDD_SURFCB_ADDATTACHEDSURFACE   LPDDHALSURFCB_ADDATTACHEDSURFACE;
typedef PDD_SURFCB_SETCOLORKEY          LPDDHALSURFCB_SETCOLORKEY;
typedef PDD_SURFCB_GETBLTSTATUS         LPDDHALSURFCB_GETBLTSTATUS;
typedef PDD_SURFCB_GETFLIPSTATUS        LPDDHALSURFCB_GETFLIPSTATUS;

typedef PDD_VPORTCB_CANCREATEVIDEOPORT  LPDDHALVPORTCB_CANCREATEVIDEOPORT;
typedef PDD_VPORTCB_CREATEVIDEOPORT     LPDDHALVPORTCB_CREATEVIDEOPORT;
typedef PDD_VPORTCB_FLIP                LPDDHALVPORTCB_FLIP;
typedef PDD_VPORTCB_GETBANDWIDTH        LPDDHALVPORTCB_GETBANDWIDTH;
typedef PDD_VPORTCB_GETINPUTFORMATS     LPDDHALVPORTCB_GETINPUTFORMATS;
typedef PDD_VPORTCB_GETOUTPUTFORMATS    LPDDHALVPORTCB_GETOUTPUTFORMATS;
typedef PDD_VPORTCB_GETFIELD            LPDDHALVPORTCB_GETFIELD;
typedef PDD_VPORTCB_GETLINE             LPDDHALVPORTCB_GETLINE;
typedef PDD_VPORTCB_GETVPORTCONNECT     LPDDHALVPORTCB_GETVPORTCONNECT;
typedef PDD_VPORTCB_DESTROYVPORT        LPDDHALVPORTCB_DESTROYVPORT;
typedef PDD_VPORTCB_GETFLIPSTATUS       LPDDHALVPORTCB_GETFLIPSTATUS;
typedef PDD_VPORTCB_UPDATE              LPDDHALVPORTCB_UPDATE;
typedef PDD_VPORTCB_WAITFORSYNC         LPDDHALVPORTCB_WAITFORSYNC;
typedef PDD_VPORTCB_GETSIGNALSTATUS     LPDDHALVPORTCB_GETSIGNALSTATUS;
typedef PDD_VPORTCB_COLORCONTROL        LPDDHALVPORTCB_COLORCONTROL;

typedef PDD_MOCOMPCB_GETGUIDS           LPDDHALMOCOMPCB_GETGUIDS;
typedef PDD_MOCOMPCB_GETFORMATS         LPDDHALMOCOMPCB_GETFORMATS;
typedef PDD_MOCOMPCB_CREATE             LPDDHALMOCOMPCB_CREATE;
typedef PDD_MOCOMPCB_GETCOMPBUFFINFO    LPDDHALMOCOMPCB_GETCOMPBUFFINFO;
typedef PDD_MOCOMPCB_GETINTERNALINFO    LPDDHALMOCOMPCB_GETINTERNALINFO;
typedef PDD_MOCOMPCB_BEGINFRAME         LPDDHALMOCOMPCB_BEGINFRAME;
typedef PDD_MOCOMPCB_ENDFRAME           LPDDHALMOCOMPCB_ENDFRAME;
typedef PDD_MOCOMPCB_RENDER             LPDDHALMOCOMPCB_RENDER;
typedef PDD_MOCOMPCB_QUERYSTATUS        LPDDHALMOCOMPCB_QUERYSTATUS;
typedef PDD_MOCOMPCB_DESTROY            LPDDHALMOCOMPCB_DESTROY;

typedef DD_CALLBACKS                    DDHAL_DDCALLBACKS;
typedef DD_PALETTECALLBACKS             DDHAL_DDPALETTECALLBACKS;
typedef DD_SURFACECALLBACKS             DDHAL_DDSURFACECALLBACKS;
typedef DD_VIDEOPORTCALLBACKS           DDHAL_DDVIDEOPORTCALLBACKS;
typedef DD_COLORCONTROLCALLBACKS        DDHAL_DDCOLORCONTROLCALLBACKS;
typedef DD_KERNELCALLBACKS              DDHAL_DDKERNELCALLBACKS;
typedef DD_MOTIONCOMPCALLBACKS          DDHAL_DDMOTIONCOMPCALLBACKS;
typedef DD_MISCELLANEOUS2CALLBACKS      DDHAL_DDMISCELLANEOUS2CALLBACKS;
typedef DD_D3DBUFCALLBACKS              DDHAL_D3DBUFCALLBACKS;
typedef DD_NTCALLBACKS                  DDHAL_DDNTCALLBACKS;

typedef PDD_CALLBACKS                   LPDDHAL_DDCALLBACKS;
typedef PDD_PALETTECALLBACKS            LPDDHAL_DDPALETTECALLBACKS;
typedef PDD_SURFACECALLBACKS            LPDDHAL_DDSURFACECALLBACKS;
typedef PDD_VIDEOPORTCALLBACKS          LPDDHAL_DDVIDEOPORTCALLBACKS;
typedef PDD_COLORCONTROLCALLBACKS       LPDDHAL_DDCOLORCONTROLCALLBACKS;
typedef PDD_KERNELCALLBACKS             LPDDHAL_DDKERNELCALLBACKS;
typedef PDD_MOTIONCOMPCALLBACKS         LPDDHAL_DDMOTIONCOMPCALLBACKS;
typedef PDD_MISCELLANEOUS2CALLBACKS     LPDDHAL_DDMISCELLANEOUS2CALLBACKS;
typedef PDD_D3DBUFCALLBACKS             LPDDHAL_D3DBUFCALLBACKS;
typedef PDD_NTCALLBACKS                 LPDDHAL_DDNTCALLBACKS;

// bit definition for dwFlags in dwPaletteFlags in D3DHAL_DP2SETPALETTE
#define DDRAWIPAL_256       0x00000001l // 256 entry palette
#define DDRAWIPAL_16        0x00000002l // 16 entry palette
#define DDRAWIPAL_GDI       0x00000004l // palette allocated through GDI
#define DDRAWIPAL_STORED_8  0x00000008l // palette stored as 8bpp/entry
#define DDRAWIPAL_STORED_16 0x00000010l // palette stored as 16bpp/entry
#define DDRAWIPAL_STORED_24 0x00000020l // palette stored as 24bpp/entry
#define DDRAWIPAL_EXCLUSIVE 0x00000040l // palette being used in exclusive mode
#define DDRAWIPAL_INHEL     0x00000080l // palette is done in the hel
#define DDRAWIPAL_DIRTY         0x00000100l     // gdi palette out 'o sync
#define DDRAWIPAL_ALLOW256  0x00000200l // can fully update palette
#define DDRAWIPAL_4             0x00000400l     // 4 entry palette
#define DDRAWIPAL_2             0x00000800l     // 2 entry palette
#define DDRAWIPAL_STORED_8INDEX 0x00001000l     // palette stored as 8-bit index into dst palette
#define DDRAWIPAL_ALPHA     0x00002000l // palette entries contain alpha

typedef D3DNTHAL_CALLBACKS              D3DHAL_CALLBACKS;
typedef D3DNTHAL_GLOBALDRIVERDATA       D3DHAL_GLOBALDRIVERDATA;
typedef D3DNTHAL_CONTEXTCREATEDATA      D3DHAL_CONTEXTCREATEDATA;
typedef D3DNTHAL_CONTEXTDESTROYDATA     D3DHAL_CONTEXTDESTROYDATA;
typedef D3DNTHAL_CONTEXTDESTROYALLDATA  D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DNTHAL_SCENECAPTUREDATA       D3DHAL_SCENECAPTUREDATA;
typedef D3DNTHAL_TEXTURECREATEDATA      D3DHAL_TEXTURECREATEDATA;
typedef D3DNTHAL_TEXTUREDESTROYDATA     D3DHAL_TEXTUREDESTROYDATA;
typedef D3DNTHAL_TEXTURESWAPDATA        D3DHAL_TEXTURESWAPDATA;
typedef D3DNTHAL_TEXTUREGETSURFDATA     D3DHAL_TEXTUREGETSURFDATA;

typedef D3DNTHAL_CALLBACKS2             D3DHAL_CALLBACKS2;
typedef D3DNTHAL_SETRENDERTARGETDATA    D3DHAL_SETRENDERTARGETDATA;

typedef D3DNTHAL_CALLBACKS3             D3DHAL_CALLBACKS3;
typedef D3DNTHAL_CLEAR2DATA             D3DHAL_CLEAR2DATA;
typedef D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA   D3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DNTHAL_DRAWPRIMITIVES2DATA    D3DHAL_DRAWPRIMITIVES2DATA;
typedef D3DNTHAL_D3DEXTENDEDCAPS        D3DHAL_D3DEXTENDEDCAPS;

typedef LPD3DNTHAL_CALLBACKS            LPD3DHAL_CALLBACKS;
typedef LPD3DNTHAL_GLOBALDRIVERDATA     LPD3DHAL_GLOBALDRIVERDATA;
typedef LPD3DNTHAL_CONTEXTCREATEDATA    LPD3DHAL_CONTEXTCREATEDATA;
typedef LPD3DNTHAL_CONTEXTDESTROYDATA   LPD3DHAL_CONTEXTDESTROYDATA;
typedef LPD3DNTHAL_CONTEXTDESTROYALLDATA LPD3DHAL_CONTEXTDESTROYALLDATA;
typedef LPD3DNTHAL_SCENECAPTUREDATA     LPD3DHAL_SCENECAPTUREDATA;
typedef LPD3DNTHAL_TEXTURECREATEDATA    LPD3DHAL_TEXTURECREATEDATA;
typedef LPD3DNTHAL_TEXTUREDESTROYDATA   LPD3DHAL_TEXTUREDESTROYDATA;
typedef LPD3DNTHAL_TEXTURESWAPDATA      LPD3DHAL_TEXTURESWAPDATA;
typedef LPD3DNTHAL_TEXTUREGETSURFDATA   LPD3DHAL_TEXTUREGETSURFDATA;

typedef LPD3DNTHAL_CALLBACKS2           LPD3DHAL_CALLBACKS2;
typedef LPD3DNTHAL_SETRENDERTARGETDATA  LPD3DHAL_SETRENDERTARGETDATA;

typedef LPD3DNTHAL_CALLBACKS3           LPD3DHAL_CALLBACKS3;
typedef LPD3DNTHAL_CLEAR2DATA           LPD3DHAL_CLEAR2DATA;
typedef LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef LPD3DNTHAL_DRAWPRIMITIVES2DATA  LPD3DHAL_DRAWPRIMITIVES2DATA;
typedef LPD3DNTHAL_D3DEXTENDEDCAPS      LPD3DHAL_D3DEXTENDEDCAPS;

#define D3DHAL2_CB32_SETRENDERTARGET          D3DNTHAL2_CB32_SETRENDERTARGET

#define D3DHAL_CONTEXT_BAD              D3DNTHAL_CONTEXT_BAD
#define D3DHAL_OUTOFCONTEXTS            D3DNTHAL_OUTOFCONTEXTS
#define D3DHALSTATE_GET_RENDER          D3DNTHALSTATE_GET_RENDER
#define D3DHAL_SCENE_CAPTURE_START      D3DNTHAL_SCENE_CAPTURE_START
#define D3DHAL_SCENE_CAPTURE_END        D3DNTHAL_SCENE_CAPTURE_END

#define D3DHAL3_CB32_CLEAR2                   D3DNTHAL3_CB32_CLEAR2
#define D3DHAL3_CB32_RESERVED                 D3DNTHAL3_CB32_RESERVED
#define D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE  D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE
#define D3DHAL3_CB32_DRAWPRIMITIVES2          D3DNTHAL3_CB32_DRAWPRIMITIVES2

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------
typedef D3DNTHAL_DP2COMMAND D3DHAL_DP2COMMAND;
typedef LPDNT3DHAL_DP2COMMAND LPD3DHAL_DP2COMMAND;
typedef D3DNTHAL_DP2OPERATION D3DHAL_DP2OPERATION;
typedef D3DNTHAL_DP2POINTS D3DHAL_DP2POINTS;
typedef D3DNTHAL_DP2LINELIST D3DHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST D3DHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP D3DHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2INDEXEDLINESTRIP D3DHAL_DP2INDEXEDLINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST D3DHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST D3DHAL_DP2INDEXEDTRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST2 D3DHAL_DP2INDEXEDTRIANGLELIST2;
typedef D3DNTHAL_DP2TRIANGLESTRIP D3DHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2INDEXEDTRIANGLESTRIP D3DHAL_DP2INDEXEDTRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN D3DHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2INDEXEDTRIANGLEFAN D3DHAL_DP2INDEXEDTRIANGLEFAN;
typedef D3DNTHAL_DP2RENDERSTATE D3DHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE D3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_DP2TRIANGLEFAN_IMM D3DHAL_DP2TRIANGLEFAN_IMM;
typedef D3DNTHAL_DP2STARTVERTEX D3DHAL_DP2STARTVERTEX;
typedef D3DNTHAL_DP2VIEWPORTINFO D3DHAL_DP2VIEWPORTINFO;
typedef D3DNTHAL_DP2WINFO D3DHAL_DP2WINFO;
typedef D3DNTHAL_DP2SETPALETTE      D3DHAL_DP2SETPALETTE;
typedef D3DNTHAL_DP2UPDATEPALETTE   D3DHAL_DP2UPDATEPALETTE;
typedef D3DNTHAL_DP2ZRANGE          D3DHAL_DP2ZRANGE;
typedef D3DNTHAL_DP2SETMATERIAL     D3DHAL_DP2SETMATERIAL;
typedef D3DNTHAL_DP2SETLIGHT        D3DHAL_DP2SETLIGHT;
typedef D3DNTHAL_DP2SETCLIPPLANE    D3DHAL_DP2SETCLIPPLANE;
typedef D3DNTHAL_DP2CREATELIGHT     D3DHAL_DP2CREATELIGHT;
typedef D3DNTHAL_DP2SETTRANSFORM    D3DHAL_DP2SETTRANSFORM;
typedef D3DNTHAL_DP2EXT             D3DHAL_DP2EXT;
typedef D3DNTHAL_DP2TEXBLT          D3DHAL_DP2TEXBLT;
typedef D3DNTHAL_DP2STATESET        D3DHAL_DP2STATESET;
typedef D3DNTHAL_DP2SETPRIORITY     D3DHAL_DP2SETPRIORITY;
typedef D3DNTHAL_DP2SETRENDERTARGET D3DHAL_DP2SETRENDERTARGET;
typedef D3DNTHAL_DP2CLEAR           D3DHAL_DP2CLEAR;
typedef D3DNTHAL_DP2SETTEXLOD       D3DHAL_DP2SETTEXLOD;

#define D3DDP2OP_POINTS               D3DNTDP2OP_POINTS
#define D3DDP2OP_INDEXEDLINELIST      D3DNTDP2OP_INDEXEDLINELIST
#define D3DDP2OP_INDEXEDLINELIST2     D3DNTDP2OP_INDEXEDLINELIST2
#define D3DDP2OP_INDEXEDTRIANGLELIST  D3DNTDP2OP_INDEXEDTRIANGLELIST
#define D3DDP2OP_INDEXEDTRIANGLELIST2 D3DNTDP2OP_INDEXEDTRIANGLELIST2
#define D3DDP2OP_RENDERSTATE          D3DNTDP2OP_RENDERSTATE
#define D3DDP2OP_LINELIST             D3DNTDP2OP_LINELIST
#define D3DDP2OP_LINESTRIP            D3DNTDP2OP_LINESTRIP
#define D3DDP2OP_INDEXEDLINESTRIP     D3DNTDP2OP_INDEXEDLINESTRIP
#define D3DDP2OP_TRIANGLELIST         D3DNTDP2OP_TRIANGLELIST
#define D3DDP2OP_TRIANGLESTRIP        D3DNTDP2OP_TRIANGLESTRIP
#define D3DDP2OP_INDEXEDTRIANGLESTRIP D3DNTDP2OP_INDEXEDTRIANGLESTRIP
#define D3DDP2OP_TRIANGLEFAN          D3DNTDP2OP_TRIANGLEFAN
#define D3DDP2OP_INDEXEDTRIANGLEFAN   D3DNTDP2OP_INDEXEDTRIANGLEFAN
#define D3DDP2OP_TRIANGLEFAN_IMM      D3DNTDP2OP_TRIANGLEFAN_IMM
#define D3DDP2OP_LINELIST_IMM         D3DNTDP2OP_LINELIST_IMM
#define D3DDP2OP_TEXTURESTAGESTATE    D3DNTDP2OP_TEXTURESTAGESTATE
#define D3DDP2OP_VIEWPORTINFO         D3DNTDP2OP_VIEWPORTINFO
#define D3DDP2OP_WINFO                D3DNTDP2OP_WINFO
#define D3DDP2OP_SETPALETTE           D3DNTDP2OP_SETPALETTE
#define D3DDP2OP_UPDATEPALETTE        D3DNTDP2OP_UPDATEPALETTE

#define D3DDP2OP_ZRANGE               D3DNTDP2OP_ZRANGE
#define D3DDP2OP_SETMATERIAL          D3DNTDP2OP_SETMATERIAL
#define D3DDP2OP_SETLIGHT             D3DNTDP2OP_SETLIGHT
#define D3DDP2OP_CREATELIGHT          D3DNTDP2OP_CREATELIGHT
#define D3DDP2OP_SETTRANSFORM         D3DNTDP2OP_SETTRANSFORM
#define D3DDP2OP_EXT                  D3DNTDP2OP_EXT                  
#define D3DDP2OP_TEXBLT               D3DNTDP2OP_TEXBLT
#define D3DDP2OP_STATESET             D3DNTDP2OP_STATESET
#define D3DDP2OP_SETPRIORITY          D3DNTDP2OP_SETPRIORITY
#define D3DDP2OP_SETRENDERTARGET      D3DNTDP2OP_SETRENDERTARGET
#define D3DDP2OP_CLEAR                D3DNTDP2OP_CLEAR
#define D3DDP2OP_SETTEXLOD            D3DNTDP2OP_SETTEXLOD
#define D3DDP2OP_SETCLIPPLANE         D3DNTDP2OP_SETCLIPPLANE

#define D3DERR_COMMAND_UNPARSED       D3DNTERR_COMMAND_UNPARSED
#define D3DHALDP2_USERMEMVERTICES     D3DNTHALDP2_USERMEMVERTICES
#define D3DHALDP2_EXECUTEBUFFER       D3DNTHALDP2_EXECUTEBUFFER
#define D3DHALDP2_SWAPVERTEXBUFFER    D3DNTHALDP2_SWAPVERTEXBUFFER
#define D3DHALDP2_SWAPCOMMANDBUFFER   D3DNTHALDP2_SWAPCOMMANDBUFFER
#define D3DHALDP2_REQVERTEXBUFSIZE    D3DNTHALDP2_REQVERTEXBUFSIZE
#define D3DHALDP2_REQCOMMANDBUFSIZE   D3DNTHALDP2_REQCOMMANDBUFSIZE
#define D3DHALDP2_VIDMEMVERTEXBUF     D3DNTHALDP2_VIDMEMVERTEXBUF
#define D3DHALDP2_VIDMEMCOMMANDBUF    D3DNTHALDP2_VIDMEMCOMMANDBUF


#define PFND3DPARSEUNKNOWNCOMMAND     PFND3DNTPARSEUNKNOWNCOMMAND
#endif // WINNT
#endif // NODX95TYPES

#endif // __DX95TYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\d3dnthal.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dnthal.h
 *  Content:    Direct3D HAL include file for NT
 *
 ***************************************************************************/

#ifndef _D3DNTHAL_H_
#define _D3DNTHAL_H_

#include <ddrawint.h>
#ifndef _WINDOWS_
#define _WINDOWS_
#include <d3dtypes.h>
#include <d3dcaps.h>
#undef _WINDOWS_
#else
#include <d3dtypes.h>
#include <d3dcaps.h>
#endif

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DNTHAL_NUMCLIPVERTICES    20

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DNTHAL_DEFAULT_TL_NUM ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DNTHAL_DEFAULT_H_NUM  ((32 * 1024) / sizeof (D3DHVERTEX))

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 *
 * For DX5 and subsequent runtimes, D3DNTDEVICEDESC is a user-visible
 * structure that is not seen by the device drivers. The runtime
 * stitches a D3DNTDEVICEDESC together using the D3DNTDEVICEDESC_V1
 * embedded in the GLOBALDRIVERDATA and the extended caps queried
 * from the driver using GetDriverInfo.
 */

typedef struct _D3DNTHALDeviceDesc_V1 {
    DWORD        dwSize;             /* Size of D3DNTHALDEVICEDESC_V1 structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD        dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */
} D3DNTHALDEVICEDESC_V1, *LPD3DNTHALDEVICEDESC_V1;

#define D3DNTHALDEVICEDESCSIZE_V1 (sizeof(D3DNTHALDEVICEDESC_V1))

/*
 * This is equivalent to the D3DNTDEVICEDESC understood by DX5, available only
 * from DX6. It is the same as D3DNTDEVICEDESC structure in DX5.
 * D3DNTDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DNTDEVICEDESC together using the
 * D3DNTDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DNTHALDeviceDesc_V2 {
    DWORD        dwSize;             /* Size of D3DNTDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

} D3DNTHALDEVICEDESC_V2, *LPD3DNTHALDEVICEDESC_V2;

#define D3DNTHALDEVICEDESCSIZE_V2 (sizeof(D3DNTHALDEVICEDESC_V2))

#if(DIRECT3D_VERSION >= 0x0700)
/*
 * This is equivalent to the D3DNTDEVICEDESC understood by DX6, available only
 * from DX6. It is the same as D3DNTDEVICEDESC structure in DX6.
 * D3DNTDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DNTDEVICEDESC together using the
 * D3DNTDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DNTDeviceDesc_V3 {
    DWORD        dwSize;             /* Size of D3DNTDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
} D3DNTDEVICEDESC_V3, *LPD3DNTDEVICEDESC_V3;

#define D3DNTDEVICEDESCSIZE_V3 (sizeof(D3DNTDEVICEDESC_V3))
#endif /* DIRECT3D_VERSION >= 0x0700 */
/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 *
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */
typedef struct _D3DNTHAL_GLOBALDRIVERDATA {
    DWORD       dwSize;         // Size of this structure
    D3DNTHALDEVICEDESC_V1 hwCaps;       // Capabilities of the hardware
    DWORD       dwNumVertices;      // see following comment
    DWORD       dwNumClipVertices;  // see following comment
    DWORD       dwNumTextureFormats;    // Number of texture formats
    LPDDSURFACEDESC lpTextureFormats;   // Pointer to texture formats
} D3DNTHAL_GLOBALDRIVERDATA;
typedef D3DNTHAL_GLOBALDRIVERDATA *LPD3DNTHAL_GLOBALDRIVERDATA;

#define D3DNTHAL_GLOBALDRIVERDATASIZE (sizeof(D3DNTHAL_GLOBALDRIVERDATA))

#if(DIRECT3D_VERSION >= 0x0700)
/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DNTHAL_D3DDX6EXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

} D3DNTHAL_D3DDX6EXTENDEDCAPS;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DNTHAL_D3DEXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure
    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* 0 implies TLVERTEX only, 1..8 imply full FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
#if(DIRECT3D_VERSION >= 0x0700)
    /* fields added for DX7 */
    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DNTHAL_D3DEXTENDEDCAPS;

typedef D3DNTHAL_D3DEXTENDEDCAPS *LPD3DNTHAL_D3DEXTENDEDCAPS;

#define D3DNTHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DNTHAL_D3DEXTENDEDCAPS))

// This is a temporary fix to make older NT drivers to compile
#define dvVertexProcessingCaps dwVertexProcessingCaps

#if(DIRECT3D_VERSION >= 0x0700)
typedef D3DNTHAL_D3DDX6EXTENDEDCAPS *LPD3DNTHAL_D3DDX6EXTENDEDCAPS;
#define D3DNTHAL_D3DDX6EXTENDEDCAPSSIZE (sizeof(D3DNTHAL_D3DDX6EXTENDEDCAPS))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 */

typedef ULONG_PTR D3DINTHAL_BUFFERHANDLE, *LPD3DINTHAL_BUFFERHANDLE;

typedef struct _D3DNTHAL_CONTEXTCREATEDATA {
union
{
    PDD_DIRECTDRAW_GLOBAL lpDDGbl;  // in:  obsolete
    PDD_DIRECTDRAW_LOCAL lpDDLcl;   // in:  Driver struct
};
union
{
    PDD_SURFACE_LOCAL   lpDDS;      // in:  obsolete
    PDD_SURFACE_LOCAL   lpDDSLcl;   // in:  Surface to be used as target
};
union
{
    PDD_SURFACE_LOCAL   lpDDSZ;     // in:  obsolete
    PDD_SURFACE_LOCAL   lpDDSZLcl;  // in:  Surface to be used as Z
};
    DWORD               dwPID;      // in:  Current process id
    ULONG_PTR           dwhContext; // in/out: Context handle
    HRESULT             ddrval;     // out: Return value
} D3DNTHAL_CONTEXTCREATEDATA;
typedef D3DNTHAL_CONTEXTCREATEDATA *LPD3DNTHAL_CONTEXTCREATEDATA;

typedef struct _D3DNTHAL_CONTEXTDESTROYDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTDESTROYDATA;
typedef D3DNTHAL_CONTEXTDESTROYDATA *LPD3DNTHAL_CONTEXTDESTROYDATA;

typedef struct _D3DNTHAL_CONTEXTDESTROYALLDATA {
    DWORD       dwPID;      // in:  Process id to destroy contexts for
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTDESTROYALLDATA;
typedef D3DNTHAL_CONTEXTDESTROYALLDATA *LPD3DNTHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DNTHAL_SCENECAPTUREDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    DWORD       dwFlag;     // in:  Indicates beginning or end
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_SCENECAPTUREDATA;
typedef D3DNTHAL_SCENECAPTUREDATA *LPD3DNTHAL_SCENECAPTUREDATA;

typedef struct _D3DNTHAL_TEXTURECREATEDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    HANDLE          hDDS;       // in:  Handle to surface object
    ULONG_PTR    dwHandle;   // out: Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTURECREATEDATA;
typedef D3DNTHAL_TEXTURECREATEDATA *LPD3DNTHAL_TEXTURECREATEDATA;

typedef struct _D3DNTHAL_TEXTUREDESTROYDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    ULONG_PTR    dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTUREDESTROYDATA;
typedef D3DNTHAL_TEXTUREDESTROYDATA *LPD3DNTHAL_TEXTUREDESTROYDATA;

typedef struct _D3DNTHAL_TEXTURESWAPDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    ULONG_PTR    dwHandle1;  // in:  Handle to texture 1
    ULONG_PTR    dwHandle2;  // in:  Handle to texture 2
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTURESWAPDATA;
typedef D3DNTHAL_TEXTURESWAPDATA *LPD3DNTHAL_TEXTURESWAPDATA;

typedef struct _D3DNTHAL_TEXTUREGETSURFDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    HANDLE      hDDS;       // out: Handle to surface object
    ULONG_PTR    dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTUREGETSURFDATA;
typedef D3DNTHAL_TEXTUREGETSURFDATA *LPD3DNTHAL_TEXTUREGETSURFDATA;

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DNTHAL_SCENE_CAPTURE_START    0x00000000L
#define D3DNTHAL_SCENE_CAPTURE_END  0x00000001L

/* --------------------------------------------------------------
 * Return values from HAL functions.
 */

/*
 * The context passed in was bad.
 */
#define D3DNTHAL_CONTEXT_BAD        0x000000200L

/*
 * No more contexts left.
 */
#define D3DNTHAL_OUTOFCONTEXTS      0x000000201L

/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *  retcode = HalCall(HalCallData* lpData);
 */

typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTCREATECB)  (LPD3DNTHAL_CONTEXTCREATEDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTDESTROYCB) (LPD3DNTHAL_CONTEXTDESTROYDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTDESTROYALLCB) (LPD3DNTHAL_CONTEXTDESTROYALLDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_SCENECAPTURECB)   (LPD3DNTHAL_SCENECAPTUREDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTURECREATECB)  (LPD3DNTHAL_TEXTURECREATEDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTUREDESTROYCB) (LPD3DNTHAL_TEXTUREDESTROYDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTURESWAPCB)    (LPD3DNTHAL_TEXTURESWAPDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTUREGETSURFCB) (LPD3DNTHAL_TEXTUREGETSURFDATA);

typedef struct _D3DNTHAL_CALLBACKS {
    DWORD           dwSize;

    // Device context
    LPD3DNTHAL_CONTEXTCREATECB  ContextCreate;
    LPD3DNTHAL_CONTEXTDESTROYCB ContextDestroy;
    LPD3DNTHAL_CONTEXTDESTROYALLCB ContextDestroyAll;

    // Scene Capture
    LPD3DNTHAL_SCENECAPTURECB   SceneCapture;

    // Execution
    LPVOID          dwReserved10;       // Must be zero (was Execute)
    LPVOID          dwReserved11;       // Must be zero (was ExecuteClipped)
    LPVOID          dwReserved22;       // Must be zero (was RenderState)
    LPVOID          dwReserved23;       // Must be zero (was RenderPrimitive)

    ULONG_PTR            dwReserved;     // Must be zero

    // Textures
    LPD3DNTHAL_TEXTURECREATECB  TextureCreate;
    LPD3DNTHAL_TEXTUREDESTROYCB TextureDestroy;
    LPD3DNTHAL_TEXTURESWAPCB    TextureSwap;
    LPD3DNTHAL_TEXTUREGETSURFCB TextureGetSurf;

    LPVOID                       dwReserved12;           // Must be zero
    LPVOID                       dwReserved13;           // Must be zero
    LPVOID                       dwReserved14;           // Must be zero
    LPVOID                       dwReserved15;           // Must be zero
    LPVOID                       dwReserved16;           // Must be zero
    LPVOID                       dwReserved17;           // Must be zero
    LPVOID                       dwReserved18;           // Must be zero
    LPVOID                       dwReserved19;           // Must be zero
    LPVOID                       dwReserved20;           // Must be zero
    LPVOID                       dwReserved21;           // Must be zero

    // Pipeline state
    LPVOID                       dwReserved24;           // Was GetState;

    ULONG_PTR            dwReserved0;        // Must be zero
    ULONG_PTR            dwReserved1;        // Must be zero
    ULONG_PTR            dwReserved2;        // Must be zero
    ULONG_PTR            dwReserved3;        // Must be zero
    ULONG_PTR            dwReserved4;        // Must be zero
    ULONG_PTR            dwReserved5;        // Must be zero
    ULONG_PTR            dwReserved6;        // Must be zero
    ULONG_PTR            dwReserved7;        // Must be zero
    ULONG_PTR            dwReserved8;        // Must be zero
    ULONG_PTR            dwReserved9;        // Must be zero

} D3DNTHAL_CALLBACKS;
typedef D3DNTHAL_CALLBACKS *LPD3DNTHAL_CALLBACKS;

#define D3DNTHAL_SIZE_V1 sizeof( D3DNTHAL_CALLBACKS )

typedef struct _D3DNTHAL_SETRENDERTARGETDATA {
    ULONG_PTR            dwhContext;     // in:  Context handle
    PDD_SURFACE_LOCAL   lpDDS;          // in:  new render target
    PDD_SURFACE_LOCAL   lpDDSZ;         // in:  new Z buffer
    HRESULT             ddrval;         // out: Return value
} D3DNTHAL_SETRENDERTARGETDATA;
typedef D3DNTHAL_SETRENDERTARGETDATA *LPD3DNTHAL_SETRENDERTARGETDATA;


typedef DWORD (APIENTRY *LPD3DNTHAL_SETRENDERTARGETCB) (LPD3DNTHAL_SETRENDERTARGETDATA);

typedef struct _D3DNTHAL_CALLBACKS2
{
    DWORD                       dwSize;                 // size of struct
    DWORD                       dwFlags;                // flags for callbacks

    LPD3DNTHAL_SETRENDERTARGETCB  SetRenderTarget;
    LPVOID                dwReserved1;           // was Clear
    LPVOID                dwReserved2;           // was DrawOnePrimitive
    LPVOID                dwReserved3;           // was DrawOneIndexedPrimitive
    LPVOID                dwReserved4;           // was DrawPrimitives
} D3DNTHAL_CALLBACKS2;
typedef D3DNTHAL_CALLBACKS2 *LPD3DNTHAL_CALLBACKS2;

#define D3DNTHAL2_CB32_SETRENDERTARGET    0x00000001L


typedef struct _D3DNTHAL_CLEAR2DATA
{
    ULONG_PTR            dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for
                                        //      Z-buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DNTHAL_CLEAR2DATA;
typedef D3DNTHAL_CLEAR2DATA FAR *LPD3DNTHAL_CLEAR2DATA;

typedef struct _D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR        dwhContext; // in:  Context handle
    DWORD           dwFlags;    // in:  Flags, currently set to 0
    ULONG_PTR        dwReserved; //
    DWORD           dwNumPasses;// out: Number of passes the hardware
                                //      can perform the operation in
    HRESULT         ddrval;     // out: return value
} D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA FAR *LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA;

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------

//
// Command structure for vertex buffer rendering
//

typedef struct _D3DNTHAL_DP2COMMAND
{
    BYTE bCommand;           // vertex command
    BYTE bReserved;
    union
    {
        WORD wPrimitiveCount;   // primitive count for unconnected primitives
        WORD wStateCount;     // count of render states to follow
    };
} D3DNTHAL_DP2COMMAND, *LPDNT3DHAL_DP2COMMAND;

//
// DrawPrimitives2 commands:
//

typedef enum _D3DNTHAL_DP2OPERATION
{
    D3DNTDP2OP_POINTS               = 1,
    D3DNTDP2OP_INDEXEDLINELIST      = 2,
    D3DNTDP2OP_INDEXEDTRIANGLELIST  = 3,
    D3DNTDP2OP_RESERVED0            = 4,
    D3DNTDP2OP_RENDERSTATE          = 8,
    D3DNTDP2OP_LINELIST             = 15,
    D3DNTDP2OP_LINESTRIP            = 16,
    D3DNTDP2OP_INDEXEDLINESTRIP     = 17,
    D3DNTDP2OP_TRIANGLELIST         = 18,
    D3DNTDP2OP_TRIANGLESTRIP        = 19,
    D3DNTDP2OP_INDEXEDTRIANGLESTRIP = 20,
    D3DNTDP2OP_TRIANGLEFAN          = 21,
    D3DNTDP2OP_INDEXEDTRIANGLEFAN   = 22,
    D3DNTDP2OP_TRIANGLEFAN_IMM      = 23,
    D3DNTDP2OP_LINELIST_IMM         = 24,
    D3DNTDP2OP_TEXTURESTAGESTATE    = 25,
    D3DNTDP2OP_INDEXEDTRIANGLELIST2 = 26,
    D3DNTDP2OP_INDEXEDLINELIST2     = 27,
    D3DNTDP2OP_VIEWPORTINFO         = 28,
    D3DNTDP2OP_WINFO                = 29,
    D3DNTDP2OP_SETPALETTE           = 30,
    D3DNTDP2OP_UPDATEPALETTE        = 31,
#if(DIRECT3D_VERSION >= 0x0700)
    //new for DX7
    D3DNTDP2OP_ZRANGE               = 32,
    D3DNTDP2OP_SETMATERIAL          = 33,
    D3DNTDP2OP_SETLIGHT             = 34,
    D3DNTDP2OP_CREATELIGHT          = 35,
    D3DNTDP2OP_SETTRANSFORM         = 36,
    D3DNTDP2OP_EXT                  = 37,
    D3DNTDP2OP_TEXBLT               = 38,
    D3DNTDP2OP_STATESET             = 39,
    D3DNTDP2OP_SETPRIORITY          = 40,
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DNTDP2OP_SETRENDERTARGET      = 41,
    D3DNTDP2OP_CLEAR                = 42,
#if(DIRECT3D_VERSION >= 0x0700)
    D3DNTDP2OP_SETTEXLOD            = 43,
    D3DNTDP2OP_SETCLIPPLANE         = 44,
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DNTHAL_DP2OPERATION;

//
// DrawPrimitives2 point primitives
//

typedef struct _D3DNTHAL_DP2POINTS
{
    WORD wCount;
    WORD wVStart;
} D3DNTHAL_DP2POINTS;

//
// DrawPrimitives2 line primitives
//

typedef struct _D3DNTHAL_DP2STARTVERTEX {
    WORD wVStart;
} D3DNTHAL_DP2STARTVERTEX, *LPD3DNTHAL_DP2STARTVERTEX;

typedef struct _D3DNTHAL_DP2LINELIST
{
    WORD wVStart;
} D3DNTHAL_DP2LINELIST;

typedef struct _D3DNTHAL_DP2INDEXEDLINELIST
{
    WORD wV1;
    WORD wV2;
} D3DNTHAL_DP2INDEXEDLINELIST;

typedef struct _D3DNTHAL_DP2LINESTRIP
{
    WORD wVStart;
} D3DNTHAL_DP2LINESTRIP;

typedef struct _D3DNTHAL_DP2INDEXEDLINESTRIP
{
    WORD wV[2];
} D3DNTHAL_DP2INDEXEDLINESTRIP;

//
// DrawPrimitives2 triangle primitives
//

typedef struct _D3DNTHAL_DP2TRIANGLELIST
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLELIST;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLELIST
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
    WORD wFlags;
} D3DNTHAL_DP2INDEXEDTRIANGLELIST;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    WORD wV1;
    WORD wV2;
    WORD wV3;
} D3DNTHAL_DP2INDEXEDTRIANGLELIST2, *LPD3DNTHAL_DP2INDEXEDTRIANGLELIST2;

typedef struct _D3DNTHAL_DP2TRIANGLESTRIP
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLESTRIP;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLESTRIP
{
    WORD wV[3];
} D3DNTHAL_DP2INDEXEDTRIANGLESTRIP;

typedef struct _D3DNTHAL_DP2TRIANGLEFAN
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLEFAN;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLEFAN
{
    WORD wV[3];
} D3DNTHAL_DP2INDEXEDTRIANGLEFAN;

typedef struct _D3DNTHAL_DP2TRIANGLEFAN_IMM {
    DWORD dwEdgeFlags;
} D3DNTHAL_DP2TRIANGLEFAN_IMM, *LPD3DNTHAL_DP2TRIANGLEFAN_IMM;

//
// DrawPrimitives2 Renderstate changes
//

typedef struct _D3DNTHAL_DP2RENDERSTATE
{
    D3DRENDERSTATETYPE RenderState;
    union
    {
        D3DVALUE fState;
        DWORD dwState;
    };
} D3DNTHAL_DP2RENDERSTATE;

typedef struct _D3DNTHAL_DP2TEXTURESTAGESTATE
{
    WORD wStage;
    WORD TSState;
    DWORD dwValue;
} D3DNTHAL_DP2TEXTURESTAGESTATE;

typedef struct _D3DNTHAL_DP2VIEWPORTINFO {
    DWORD dwX;
    DWORD dwY;
    DWORD dwWidth;
    DWORD dwHeight;
} D3DNTHAL_DP2VIEWPORTINFO, *LPD3DNTHAL_DP2VIEWPORTINFO;

typedef struct _D3DNTHAL_DP2WINFO {
    D3DVALUE        dvWNear;
    D3DVALUE        dvWFar;
} D3DNTHAL_DP2WINFO, *LPD3DNTHAL_DP2WINFO;

typedef struct _D3DNTHAL_DP2SETPALETTE
{
    DWORD dwPaletteHandle;
    DWORD dwPaletteFlags;
    DWORD dwSurfaceHandle;
} D3DNTHAL_DP2SETPALETTE, *LPD3DNTHAL_DP2SETPALETTE;

typedef struct _D3DNTHAL_DP2UPDATEPALETTE
{
    DWORD dwPaletteHandle;
    WORD  wStartIndex;
    WORD  wNumEntries;
} D3DNTHAL_DP2UPDATEPALETTE, *LPD3DNTHAL_DP2UPDATEPALETTE;

typedef struct _D3DNTHAL_DP2SETRENDERTARGET
{
    DWORD hRenderTarget;
    DWORD hZBuffer;
} D3DNTHAL_DP2SETRENDERTARGET, *LPD3DNTHAL_DP2SETRENDERTARGET;

#if(DIRECT3D_VERSION >= 0x0700)
// Values for dwOperations in the D3DHAL_DP2STATESET
#define D3DHAL_STATESETBEGIN     0
#define D3DHAL_STATESETEND       1
#define D3DHAL_STATESETDELETE    2
#define D3DHAL_STATESETEXECUTE   3
#define D3DHAL_STATESETCAPTURE   4

typedef struct _D3DNTHAL_DP2STATESET
{
    DWORD       dwOperation;
    DWORD       dwParam;        // State set handle passed with D3DHAL_STATESETBEGIN,
                                // D3DHAL_STATESETEXECUTE, D3DHAL_STATESETDELETE
                                // D3DHAL_STATESETCAPTURE
    D3DSTATEBLOCKTYPE   sbType; // Type use with D3DHAL_STATESETBEGIN/END
} D3DNTHAL_DP2STATESET, *LPD3DNTHAL_DP2STATESET;
//
// T&L Hal specific stuff
//
typedef struct _D3DNTHAL_DP2ZRANGE
{
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;
} D3DNTHAL_DP2ZRANGE, *LPD3DNTHAL_DP2ZRANGE;

typedef D3DMATERIAL7 D3DNTHAL_DP2SETMATERIAL, *LPD3DNTHAL_DP2SETMATERIAL;

typedef struct _D3DNTHAL_DP2SETLIGHT
{
    DWORD     dwIndex;
    DWORD     lightData;
} D3DNTHAL_DP2SETLIGHT, *LPD3DNTHAL_DP2SETLIGHT;

typedef struct _D3DNTHAL_DP2SETCLIPPLANE
{
    DWORD     dwIndex;
    D3DVALUE  plane[4];
} D3DNTHAL_DP2SETCLIPPLANE, *LPD3DNTHAL_DP2SETCLIPPLANE;

typedef struct _D3DNTHAL_DP2CREATELIGHT
{
    DWORD dwIndex;
} D3DNTHAL_DP2CREATELIGHT, *LPD3DNTHAL_DP2CREATELIGHT;

typedef struct _D3DNTHAL_DP2SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
} D3DNTHAL_DP2SETTRANSFORM, *LPD3DNTHAL_DP2SETTRANSFORM;

typedef struct _D3DNTHAL_DP2EXT
{
    DWORD dwExtToken;
    DWORD dwSize;
} D3DNTHAL_DP2EXT, *LPD3DNTHAL_DP2EXT;
typedef struct _D3DNTHAL_DP2TEXBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    POINT   pDest;
    RECTL   rSrc;       // src rect
    DWORD   dwFlags;    // blt flags
} D3DNTHAL_DP2TEXBLT, *LPD3DNTHAL_DP2TEXBLT;

typedef struct _D3DNTHAL_DP2SETPRIORITY
{
    DWORD dwDDDestSurface;// dest surface
    DWORD dwPriority;
} D3DNTHAL_DP2SETPRIORITY, *LPD3DNTHAL_DP2SETPRIORITY;

typedef struct _D3DNTHAL_DP2CLEAR
{
  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear
    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer
    RECT                Rects[1];       // in:  Rectangles to clear
} D3DNTHAL_DP2CLEAR, *LPD3DNTHAL_DP2CLEAR;

typedef struct _D3DNTHAL_DP2SETTEXLOD
{
    DWORD dwDDSurface;
    DWORD dwLOD;
} D3DNTHAL_DP2SETTEXLOD, *LPD3DNTHAL_DP2SETTEXLOD;

#endif /* DIRECT3D_VERSION >= 0x0700 */


typedef struct _D3DNTHAL_DRAWPRIMITIVES2DATA
{
    ULONG_PTR          dwhContext;        // in: Context handle
    DWORD             dwFlags;           // in: flags (look below)
    DWORD             dwVertexType;      // in: vertex type
    PDD_SURFACE_LOCAL lpDDCommands;      // in: vertex buffer command data
    DWORD             dwCommandOffset;   // in: offset to start of vb commands
    DWORD             dwCommandLength;   // in: number of bytes of command data
    union
    {
        PDD_SURFACE_LOCAL lpDDVertex;    // in: surface containing vertex data
        LPVOID lpVertices;               // in: User mode pointer to vertices
    };
    DWORD             dwVertexOffset;    // in: offset to start of vertex data
    DWORD             dwVertexLength;    // in: number of bytes of vertex data
    DWORD             dwReqVertexBufSize;// in: number of bytes required for
                                         //     the next vertex buffer
    DWORD             dwReqCommandBufSize; // in: number if bytes required for
                                         //     the next commnand buffer
    LPDWORD           lpdwRStates;       // in: Pointer to the array where render states are updated
    union
    {
        DWORD         dwVertexSize;      // in: Size of each vertex in bytes
        HRESULT       ddrval;            // out: return value
    };
    DWORD             dwErrorOffset;     // out: offset in LPDDVBCOMMAND to
                                         //      first failed D3DNTHAL_VBCOMMAND
} D3DNTHAL_DRAWPRIMITIVES2DATA;
typedef D3DNTHAL_DRAWPRIMITIVES2DATA FAR *LPD3DNTHAL_DRAWPRIMITIVES2DATA;

// Indicates that the lpVertices field in the DrawPrimitives2 data is
// valid, i.e. user allocated memory.
#define D3DNTHALDP2_USERMEMVERTICES   0x00000001L
// Indicates that the command buffer and vertex buffer are a system memory execute buffer
// resulting from the use of the Execute buffer API.
#define D3DNTHALDP2_EXECUTEBUFFER     0x00000002L

// The swap flags indicate if it is OK for the driver to swap the submitted buffers with new
// buffers and asyncronously work on the submitted buffers.
#define D3DNTHALDP2_SWAPVERTEXBUFFER  0x00000004L
#define D3DNTHALDP2_SWAPCOMMANDBUFFER 0x00000008L
// The requested flags are present if the new buffers which the driver can allocate need to be
// of atleast a given size. If any of these flags are set, the corresponding dwReq* field in
// D3DNTHAL_DRAWPRIMITIVES2DATA will also be set with the requested size in bytes.
#define D3DNTHALDP2_REQVERTEXBUFSIZE  0x00000010L
#define D3DNTHALDP2_REQCOMMANDBUFSIZE 0x00000020L
// These flags are set by the driver upon return from DrawPrimitives2 indicating if the new
// buffers are not in system memory.
#define D3DNTHALDP2_VIDMEMVERTEXBUF   0x00000040L
#define D3DNTHALDP2_VIDMEMCOMMANDBUF  0x00000080L


// Return values for the driver callback used in DP2 implementations
// Used by the driver to ask runtime to parse the execute buffer
#define D3DNTERR_COMMAND_UNPARSED         MAKE_DDHRESULT(3000)


typedef DWORD (APIENTRY *LPD3DNTHAL_CLEAR2CB) (LPD3DNTHAL_CLEAR2DATA);
typedef DWORD (APIENTRY *LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB) (LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (APIENTRY *LPD3DNTHAL_DRAWPRIMITIVES2CB) (LPD3DNTHAL_DRAWPRIMITIVES2DATA);

typedef struct _D3DNTHAL_CALLBACKS3
{
    DWORD                       dwSize;                 // size of struct
    DWORD                       dwFlags;                // flags for callbacks

    LPD3DNTHAL_CLEAR2CB            Clear2;
    LPVOID                         lpvReserved;
    LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB  ValidateTextureStageState;
    LPD3DNTHAL_DRAWPRIMITIVES2CB   DrawPrimitives2;
} D3DNTHAL_CALLBACKS3;
typedef D3DNTHAL_CALLBACKS3 *LPD3DNTHAL_CALLBACKS3;

#define D3DNTHAL3_CB32_CLEAR2             0x00000001L
#define D3DNTHAL3_CB32_RESERVED           0x00000002L
#define D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE   0x00000004L
#define D3DNTHAL3_CB32_DRAWPRIMITIVES2    0x00000008L

// typedef for the Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
typedef HRESULT (CALLBACK *PFND3DNTPARSEUNKNOWNCOMMAND) (LPVOID lpvCommands,
                                                         LPVOID *lplpvReturnedCommand);

/* --------------------------------------------------------------
 * Texture stage renderstate mapping definitions.
 *
 * 256 renderstate slots [256, 511] are reserved for texture processing
 * stage controls, which provides for 8 texture processing stages each
 * with 32 DWORD controls.
 *
 * The renderstates within each stage are indexed by the
 * D3DTEXTURESTAGESTATETYPE enumerants by adding the appropriate
 * enumerant to the base for a given texture stage.
 *
 * Note, "state overrides" bias the renderstate by 256, so the two
 * ranges overlap.  Overrides are enabled for exebufs only, so all
 * this means is that Texture3 cannot be used with exebufs.
 */

/*
 * Base of all texture stage state values in renderstate array.
 */
#define D3DNTHAL_TSS_RENDERSTATEBASE 256UL

/*
 * Maximum number of stages allowed.
 */
#define D3DNTHAL_TSS_MAXSTAGES 8

/*
 * Number of state DWORDS per stage.
 */
#define D3DNTHAL_TSS_STATESPERSTAGE 64

/*
 * Texture handle's offset into the 32-DWORD cascade state vector
 */
#ifndef D3DTSS_TEXTUREMAP
#define D3DTSS_TEXTUREMAP 0
#endif

#define D3DRENDERSTATE_EVICTMANAGEDTEXTURES 61  // DDI render state only to Evict textures
#define D3DRENDERSTATE_SCENECAPTURE         62  // DDI only to replace SceneCapture

#endif /* _D3DNTHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmapi.h
 *  Content:	Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD  dwFunctionNum,
    LPVOID lpvInBuffer,
    DWORD  cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD  cbOutBuffer
);

typedef
DWORD
(FAR PASCAL *LPDXAPI)(
    DWORD   dwFunctionNum,
    LPVOID  lpvInBuffer,
    DWORD   cbInBuffer,
    LPVOID  lpvOutBuffer,
    DWORD   cbOutBuffer
);

#define DXAPI_MAJORVERSION		1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI					0x500

typedef ULONG (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        ULONG_PTR            dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
	HANDLE	            hDirectDraw;
        ULONG_PTR            dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
	HANDLE		    hDirectDraw;
        ULONG               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
	DWORD	ddRVal;
        DWORD	dwCaps;
	DWORD	dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
	DWORD	ddRVal;
	DWORD	dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD			(DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE			(DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
	DWORD	ddRVal;
	DWORD	dwStateCaps;
	DWORD	dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE			(DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
	DWORD	dwState;
	DWORD	dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK					(DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
	DWORD	ddRVal;
	DWORD	dwSurfHeight;
	DWORD	dwSurfWidth;
	LONG	lSurfPitch;
	PVOID	lpSurface;
	DWORD	SurfaceCaps;
	DWORD	dwFormatFlags;
	DWORD	dwFormatFourCC;
	DWORD	dwFormatBitCount;
	union
	{
	    DWORD	dwRBitMask;
	    DWORD	dwYBitMask;
    	};
    	union
    	{
	    DWORD	dwGBitMask;
	    DWORD	dwUBitMask;
	};
	union
	{
	    DWORD	dwBBitMask;
	    DWORD	dwVBitMask;
	};
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY				(DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
	HANDLE	hDirectDraw;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP				(DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE	(DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
	DWORD	ddRVal;
	HANDLE	hVideoSurface;
	HANDLE	hVBISurface;
	BOOL	bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE		(DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK			(DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
	HANDLE 	            hDirectDraw;
	ULONG	            dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
	ULONG_PTR            dwParam1;
	ULONG_PTR            dwParam2;
	PVOID	            pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK			(DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY				(DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
	HANDLE 	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
	DWORD 	ddRVal;
	BOOL	bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE			(DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
	HANDLE  hDirectDraw;
	HANDLE  hVideoPort;
	DWORD   dwStartLine;
	DWORD   dwEndLine;
	DWORD   dwCaptureEveryNFields;
	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	PVOID   pContext;
	DWORD	dwFlags;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
	DWORD	ddRVal;
	HANDLE	hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

    #define DDOPENCAPTURE_VIDEO	0x0001	// Capture from the video stream
    #define DDOPENCAPTURE_VBI	0x0002	// Capture from the VBI stream

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER			(DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
	DWORD   	dwFieldNumber;
	DWORD   	bPolarity;
	LARGE_INTEGER	liTimeStamp;
	DWORD   	ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
	HANDLE  hCapture;
	DWORD   dwFlags;
	PMDL    pMDL;
	PKEVENT pKEvent;
	LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY	0x0001	// lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM	0x0002	// lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT		0x0004	// invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS			(DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB				0x0001
#define DDSTATE_WEAVE				0x0002
#define DDSTATE_EXPLICITLY_SET			0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP		0x0008
#define DDSTATE_SKIPEVENFIELDS			0x0010

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC			0x0001
#define DDEVENT_VP_VSYNC			0x0002
#define DDEVENT_VP_LINE				0x0004
#define DDEVENT_PRERESCHANGE			0x0008
#define DDEVENT_POSTRESCHANGE			0x0010
#define DDEVENT_PREDOSBOX			0x0020
#define DDEVENT_POSTDOSBOX			0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC			0x0001	// dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC			0x0002	// dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE	  		0x0004	// dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE			0x0008	// dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE			0x0010	// dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX			0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX			0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW		0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE			0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT			0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE			0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\ddrawint.h ===
/*++

Copyright (c) 1995-1997, Microsoft Corporation

Module Name:

    ddrawint.h

Abstract:

    Private entry points, defines and types for Windows NT DirectDraw
    driver interface.  Corresponds to Windows' 'ddrawi.h' file.

    The structure names for NT are different from that of Win95.  Use
    dx95type.h to aid in porting DirectX code from Win95 to NT.

--*/

#ifndef __DD_INCLUDED__
#define __DD_INCLUDED__

/*
 * These GUIDs are used to identify driver info structures, not interfaces,
 * so the prefix GUID_ is used instead of IID_.
 */

DEFINE_GUID( GUID_MiscellaneousCallbacks,       0xefd60cc0, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_Miscellaneous2Callbacks,      0x406B2F00, 0x3E5A, 0x11D1, 0xB6, 0x40, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x6A);
DEFINE_GUID( GUID_VideoPortCallbacks,           0xefd60cc1, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_ColorControlCallbacks,        0xefd60cc2, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_MotionCompCallbacks,          0xb1122b40, 0x5dA5, 0x11d1, 0x8f, 0xcF, 0x00, 0xc0, 0x4f, 0xc2, 0x9b, 0x4e);
DEFINE_GUID( GUID_VideoPortCaps,                0xefd60cc3, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCaps,                      0x7bf06991, 0x8794, 0x11d0, 0x91, 0x39, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);
DEFINE_GUID( GUID_D3DExtendedCaps, 		0x7de41f80, 0x9d93, 0x11d0, 0x89, 0xab, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID( GUID_D3DCallbacks,                 0x7bf06990, 0x8794, 0x11d0, 0x91, 0x39, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);
DEFINE_GUID( GUID_D3DCallbacks2,                0xba584e1, 0x70b6, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks3,                0xddf41230, 0xec0a, 0x11d0, 0xa9, 0xb6, 0x00, 0xaa, 0x00, 0xc0, 0x99, 0x3e);
DEFINE_GUID( GUID_NonLocalVidMemCaps,           0x86c4fa80, 0x8d84, 0x11d0, 0x94, 0xe8, 0x00, 0xc0, 0x4f, 0xc3, 0x41, 0x37);
DEFINE_GUID( GUID_KernelCallbacks,              0x80863800, 0x6B06, 0x11D0, 0x9B, 0x06, 0x0, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_KernelCaps,                   0xFFAA7540, 0x7AA8, 0x11D0, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_ZPixelFormats,                0x93869880, 0x36cf, 0x11d1, 0x9b, 0x1b, 0x0, 0xaa, 0x0, 0xbb, 0xb8, 0xae);
DEFINE_GUID( GUID_DDMoreCaps,                   0x880baf30, 0xb030, 0x11d0, 0x8e, 0xa7, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b);
DEFINE_GUID( GUID_D3DParseUnknownCommandCallback, 0x2e04ffa0, 0x98e4, 0x11d1, 0x8c, 0xe1, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_NTCallbacks,                  0x6fe9ecde, 0xdf89, 0x11d1, 0x9d, 0xb0, 0x00, 0x60, 0x08, 0x27, 0x71, 0xba);
DEFINE_GUID( GUID_DDMoreSurfaceCaps,            0x3b8a0466, 0xf269, 0x11d1, 0x88, 0x0b, 0x0, 0xc0, 0x4f, 0xd9, 0x30, 0xc5);
DEFINE_GUID( GUID_GetHeapAlignment,             0x42e02f16, 0x7b41, 0x11d2, 0x8b, 0xff, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_UpdateNonLocalHeap,           0x42e02f17, 0x7b41, 0x11d2, 0x8b, 0xff, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_NTPrivateDriverCaps,          0xfad16a23, 0x7b66, 0x11d2, 0x83, 0xd7, 0x0, 0xc0, 0x4f, 0x7c, 0xe5, 0x8c);
DEFINE_GUID( GUID_DDStereoMode,                 0xf828169c, 0xa8e8, 0x11d2, 0xa1, 0xf2, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);

#ifndef GUID_DEFS_ONLY

#ifndef _NO_DDRAWINT_NO_COM
#ifndef _NO_COM
#define _NO_COM
#include "ddraw.h"
#include "dvp.h"
#undef _NO_COM
#else
#include "ddraw.h"
#include "dvp.h"
#endif
#else
#include "ddraw.h"
#include "dvp.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/*
 * offset into video meory
 */
typedef ULONG_PTR FLATPTR;

/*
 * maximum number of surfaces that can be autoflipped between
 */
#define MAX_AUTOFLIP_BUFFERS    10

/*
 * Indicates the surface is D3D buffer, i.e., a linear chunk of
 * memory that holds a Direct3D structure. A driver reports this
 * cap to indicate that it can create buffers in video memory and
 * Direct3D uses this bit to request buffers. However, it is not
 * visible to the API.
 */
#define DDSCAPS_EXECUTEBUFFER DDSCAPS_RESERVED2
#define DDSCAPS_COMMANDBUFFER DDSCAPS_RESERVED3
#define DDSCAPS_VERTEXBUFFER DDSCAPS_RESERVED4


/*
 * Internal formats are not exposed to applications.
//@@BEGIN_MSINTERNAL
 * NOTE: Must keep these in sync with enum in d3d8types.h
//@@END_MSINTERNAL
 */

#define D3DFMT_INTERNAL_D32                  71
#define D3DFMT_INTERNAL_S1D15                72
#define D3DFMT_INTERNAL_D15S1                73
#define D3DFMT_INTERNAL_S8D24                74
#define D3DFMT_INTERNAL_D24S8                75
#define D3DFMT_INTERNAL_X8D24                76
#define D3DFMT_INTERNAL_D24X8                77

/*
 * pre-declare pointers to structs containing data for DDHAL driver fns
 */
typedef struct _DD_CREATEPALETTEDATA *PDD_CREATEPALETTEDATA;
typedef struct _DD_CREATESURFACEDATA *PDD_CREATESURFACEDATA;
typedef struct _DD_CANCREATESURFACEDATA *PDD_CANCREATESURFACEDATA;
typedef struct _DD_WAITFORVERTICALBLANKDATA *PDD_WAITFORVERTICALBLANKDATA;
typedef struct _DD_DESTROYDRIVERDATA *PDD_DESTROYDRIVERDATA;
typedef struct _DD_SETMODEDATA *PDD_SETMODEDATA;
typedef struct _DD_DRVSETCOLORKEYDATA *PDD_DRVSETCOLORKEYDATA;
typedef struct _DD_GETSCANLINEDATA *PDD_GETSCANLINEDATA;
typedef struct _DD_MAPMEMORYDATA *PDD_MAPMEMORYDATA;

typedef struct _DD_DESTROYPALETTEDATA *PDD_DESTROYPALETTEDATA;
typedef struct _DD_SETENTRIESDATA *PDD_SETENTRIESDATA;

typedef struct _DD_BLTDATA *PDD_BLTDATA;
typedef struct _DD_LOCKDATA *PDD_LOCKDATA;
typedef struct _DD_UNLOCKDATA *PDD_UNLOCKDATA;
typedef struct _DD_UPDATEOVERLAYDATA *PDD_UPDATEOVERLAYDATA;
typedef struct _DD_SETOVERLAYPOSITIONDATA *PDD_SETOVERLAYPOSITIONDATA;
typedef struct _DD_SETPALETTEDATA *PDD_SETPALETTEDATA;
typedef struct _DD_FLIPDATA *PDD_FLIPDATA;
typedef struct _DD_DESTROYSURFACEDATA *PDD_DESTROYSURFACEDATA;
typedef struct _DD_SETCLIPLISTDATA *PDD_SETCLIPLISTDATA;
typedef struct _DD_ADDATTACHEDSURFACEDATA *PDD_ADDATTACHEDSURFACEDATA;
typedef struct _DD_SETCOLORKEYDATA *PDD_SETCOLORKEYDATA;
typedef struct _DD_GETBLTSTATUSDATA *PDD_GETBLTSTATUSDATA;
typedef struct _DD_GETFLIPSTATUSDATA *PDD_GETFLIPSTATUSDATA;

typedef struct _DD_CANCREATEVPORTDATA *PDD_CANCREATEVPORTDATA;
typedef struct _DD_CREATEVPORTDATA *PDD_CREATEVPORTDATA;
typedef struct _DD_FLIPVPORTDATA *PDD_FLIPVPORTDATA;
typedef struct _DD_GETVPORTCONNECTDATA *PDD_GETVPORTCONNECTDATA;
typedef struct _DD_GETVPORTBANDWIDTHDATA *PDD_GETVPORTBANDWIDTHDATA;
typedef struct _DD_GETVPORTINPUTFORMATDATA *PDD_GETVPORTINPUTFORMATDATA;
typedef struct _DD_GETVPORTOUTPUTFORMATDATA *PDD_GETVPORTOUTPUTFORMATDATA;
typedef struct _DD_GETVPORTAUTOFLIPSURFACEDATA *PDD_GETVPORTAUTOFLIPSURFACEDATA;
typedef struct _DD_GETVPORTFIELDDATA *PDD_GETVPORTFIELDDATA;
typedef struct _DD_GETVPORTLINEDATA *PDD_GETVPORTLINEDATA;
typedef struct _DD_DESTROYVPORTDATA *PDD_DESTROYVPORTDATA;
typedef struct _DD_GETVPORTFLIPSTATUSDATA *PDD_GETVPORTFLIPSTATUSDATA;
typedef struct _DD_UPDATEVPORTDATA *PDD_UPDATEVPORTDATA;
typedef struct _DD_WAITFORVPORTSYNCDATA *PDD_WAITFORVPORTSYNCDATA;
typedef struct _DD_GETVPORTSIGNALDATA *PDD_GETVPORTSIGNALDATA;
typedef struct _DD_VPORTCOLORDATA *PDD_VPORTCOLORDATA;

typedef struct _DD_COLORCONTROLDATA *PDD_COLORCONTROLDATA;

typedef struct _DD_GETAVAILDRIVERMEMORYDATA *PDD_GETAVAILDRIVERMEMORYDATA;

typedef struct _DD_FREEDRIVERMEMORYDATA *PDD_FREEDRIVERMEMORYDATA;
typedef struct _DD_SETEXCLUSIVEMODEDATA *PDD_SETEXCLUSIVEMODEDATA;
typedef struct _DD_FLIPTOGDISURFACEDATA *PDD_FLIPTOGDISURFACEDATA;

typedef struct _DD_GETDRIVERINFODATA *PDD_GETDRIVERINFODATA;

typedef struct _DD_SYNCSURFACEDATA *PDD_SYNCSURFACEDATA;
typedef struct _DD_SYNCVIDEOPORTDATA *PDD_SYNCVIDEOPORTDATA;

typedef struct _DD_GETMOCOMPGUIDSDATA *PDD_GETMOCOMPGUIDSDATA;
typedef struct _DD_GETMOCOMPFORMATSDATA *PDD_GETMOCOMPFORMATSDATA;
typedef struct _DD_CREATEMOCOMPDATA *PDD_CREATEMOCOMPDATA;
typedef struct _DD_GETMOCOMPCOMPBUFFDATA *PDD_GETMOCOMPCOMPBUFFDATA;
typedef struct _DD_GETINTERNALMOCOMPDATA *PDD_GETINTERNALMOCOMPDATA;
typedef struct _DD_BEGINMOCOMPFRAMEDATA *PDD_BEGINMOCOMPFRAMEDATA;
typedef struct _DD_ENDMOCOMPFRAMEDATA *PDD_ENDMOCOMPFRAMEDATA;
typedef struct _DD_RENDERMOCOMPDATA *PDD_RENDERMOCOMPDATA;
typedef struct _DD_QUERYMOCOMPSTATUSDATA *PDD_QUERYMOCOMPSTATUSDATA;
typedef struct _DD_DESTROYMOCOMPDATA *PDD_DESTROYMOCOMPDATA;

// Miscelleneous2 callbacks
typedef struct _DD_CREATESURFACEEXDATA *PDD_CREATESURFACEEXDATA;
typedef struct _DD_GETDRIVERSTATEDATA *PDD_GETDRIVERSTATEDATA;
typedef struct _DD_DESTROYDDLOCALDATA *PDD_DESTROYDDLOCALDATA;
typedef struct _DD_MORESURFACECAPS *PDD_MORESURFACECAPS;
typedef struct _DD_STEREOMODE *PDD_STEREOMODE;
typedef struct _DD_UPDATENONLOCALHEAPDATA *PDD_UPDATENONLOCALHEAPDATA;



/*
 * The following structure is defined in dmemmgr.h
 */
struct _DD_GETHEAPALIGNMENTDATA;
typedef struct _DD_GETHEAPALIGNMENTDATA *PDD_GETHEAPALIGNMENTDATA;

/*
 * value in the fpVidMem; indicates dwBlockSize is valid (surface object)
 */
#define DDHAL_PLEASEALLOC_BLOCKSIZE     0x00000002l
#define DDHAL_PLEASEALLOC_USERMEM       0x00000004l

/*
 * video memory data structures (passed in DD_HALINFO)
 */
typedef struct _VIDEOMEMORY
{
    DWORD               dwFlags;        // flags
    FLATPTR             fpStart;        // start of memory chunk
    union
    {
        FLATPTR         fpEnd;          // end of memory chunk
        DWORD           dwWidth;        // width of chunk (rectanglar memory)
    };
    DDSCAPS             ddsCaps;        // what this memory CANNOT be used for
    DDSCAPS             ddsCapsAlt;     // what this memory CANNOT be used for if it must
    union
    {
        struct _VMEMHEAP *lpHeap;       // heap pointer, used by DDRAW
        DWORD           dwHeight;       // height of chunk (rectanguler memory)
    };
} VIDEOMEMORY;
typedef VIDEOMEMORY *LPVIDEOMEMORY;

/*
 * flags for vidmem struct
 */
#define VIDMEM_ISLINEAR         0x00000001l     // heap is linear
#define VIDMEM_ISRECTANGULAR    0x00000002l     // heap is rectangular
#define VIDMEM_ISHEAP           0x00000004l     // heap is preallocated by driver
#define VIDMEM_ISNONLOCAL       0x00000008l     // heap populated with non-local video memory
#define VIDMEM_ISWC             0x00000010l     // heap populated with write combining memory
#define VIDMEM_HEAPDISABLED     0x00000020l     // heap disabled

typedef struct _VIDEOMEMORYINFO
{
    FLATPTR             fpPrimary;              // offset to primary surface
    DWORD               dwFlags;                // flags
    DWORD               dwDisplayWidth;         // current display width
    DWORD               dwDisplayHeight;        // current display height
    LONG                lDisplayPitch;          // current display pitch
    DDPIXELFORMAT       ddpfDisplay;            // pixel format of display
    DWORD               dwOffscreenAlign;       // byte alignment for offscreen surfaces
    DWORD               dwOverlayAlign;         // byte alignment for overlays
    DWORD               dwTextureAlign;         // byte alignment for textures
    DWORD               dwZBufferAlign;         // byte alignment for z buffers
    DWORD               dwAlphaAlign;           // byte alignment for alpha
    PVOID               pvPrimary;              // kernel-mode pointer to primary surface
} VIDEOMEMORYINFO;
typedef VIDEOMEMORYINFO *LPVIDEOMEMORYINFO;

/*
 * These structures contain the entry points in the display driver that
 * DDRAW will call.   Entries that the display driver does not care about
 * should be NULL.   Passed to DDRAW in DD_HALINFO.
 */
typedef struct _DD_DIRECTDRAW_GLOBAL *PDD_DIRECTDRAW_GLOBAL;
typedef struct _DD_SURFACE_GLOBAL *PDD_SURFACE_GLOBAL;
typedef struct _DD_PALETTE_GLOBAL *PDD_PALETTE_GLOBAL;
typedef struct _DD_CLIPPER_GLOBAL *PDD_CLIPPER_GLOBAL;
typedef struct _DD_DIRECTDRAW_LOCAL *PDD_DIRECTDRAW_LOCAL;
typedef struct _DD_SURFACE_LOCAL *PDD_SURFACE_LOCAL;
typedef struct _DD_SURFACE_MORE *PDD_SURFACE_MORE;
typedef struct _DD_SURFACE_INT *PDD_SURFACE_INT;
typedef struct _DD_VIDEOPORT_LOCAL *PDD_VIDEOPORT_LOCAL;
typedef struct _DD_PALETTE_LOCAL *PDD_PALETTE_LOCAL;
typedef struct _DD_CLIPPER_LOCAL *PDD_CLIPPER_LOCAL;
typedef struct _DD_MOTIONCOMP_LOCAL *PDD_MOTIONCOMP_LOCAL;

/*
 * DIRECTDRAW object callbacks
 */
typedef DWORD   (APIENTRY *PDD_SETCOLORKEY)(PDD_DRVSETCOLORKEYDATA );
typedef DWORD   (APIENTRY *PDD_CANCREATESURFACE)(PDD_CANCREATESURFACEDATA );
typedef DWORD   (APIENTRY *PDD_WAITFORVERTICALBLANK)(PDD_WAITFORVERTICALBLANKDATA );
typedef DWORD   (APIENTRY *PDD_CREATESURFACE)(PDD_CREATESURFACEDATA);
typedef DWORD   (APIENTRY *PDD_DESTROYDRIVER)(PDD_DESTROYDRIVERDATA);
typedef DWORD   (APIENTRY *PDD_SETMODE)(PDD_SETMODEDATA);
typedef DWORD   (APIENTRY *PDD_CREATEPALETTE)(PDD_CREATEPALETTEDATA);
typedef DWORD   (APIENTRY *PDD_GETSCANLINE)(PDD_GETSCANLINEDATA);
typedef DWORD   (APIENTRY *PDD_MAPMEMORY)(PDD_MAPMEMORYDATA);

typedef DWORD   (APIENTRY *PDD_GETDRIVERINFO)(PDD_GETDRIVERINFODATA);

typedef struct DD_CALLBACKS
{
    DWORD                       dwSize;
    DWORD                       dwFlags;
    PDD_DESTROYDRIVER           DestroyDriver;
    PDD_CREATESURFACE           CreateSurface;
    PDD_SETCOLORKEY             SetColorKey;
    PDD_SETMODE                 SetMode;
    PDD_WAITFORVERTICALBLANK    WaitForVerticalBlank;
    PDD_CANCREATESURFACE        CanCreateSurface;
    PDD_CREATEPALETTE           CreatePalette;
    PDD_GETSCANLINE             GetScanLine;
    PDD_MAPMEMORY               MapMemory;
} DD_CALLBACKS;

typedef DD_CALLBACKS *PDD_CALLBACKS;

#define DDHAL_CB32_DESTROYDRIVER        0x00000001l
#define DDHAL_CB32_CREATESURFACE        0x00000002l
#define DDHAL_CB32_SETCOLORKEY          0x00000004l
#define DDHAL_CB32_SETMODE              0x00000008l
#define DDHAL_CB32_WAITFORVERTICALBLANK 0x00000010l
#define DDHAL_CB32_CANCREATESURFACE     0x00000020l
#define DDHAL_CB32_CREATEPALETTE        0x00000040l
#define DDHAL_CB32_GETSCANLINE          0x00000080l
#define DDHAL_CB32_MAPMEMORY            0x80000000l

// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_MiscellaneousCallbacks

typedef DWORD   (APIENTRY *PDD_GETAVAILDRIVERMEMORY)(PDD_GETAVAILDRIVERMEMORYDATA);

typedef struct _DD_MISCELLANEOUSCALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_GETAVAILDRIVERMEMORY            GetAvailDriverMemory;
} DD_MISCELLANEOUSCALLBACKS, *PDD_MISCELLANEOUSCALLBACKS;

#define DDHAL_MISCCB32_GETAVAILDRIVERMEMORY    0x00000001l

// DDHAL_DDMISCELLANEOUS2CALLBACKS:
//   This structure can be queried from the driver from DX7 onward
//   using GetDriverInfo with GUID_Miscellaneous2Callbacks

typedef DWORD   (APIENTRY *PDD_ALPHABLT)(PDD_BLTDATA);
typedef DWORD   (APIENTRY *PDD_CREATESURFACEEX)(PDD_CREATESURFACEEXDATA);
typedef DWORD   (APIENTRY *PDD_GETDRIVERSTATE)(PDD_GETDRIVERSTATEDATA);
typedef DWORD   (APIENTRY *PDD_DESTROYDDLOCAL)(PDD_DESTROYDDLOCALDATA);

typedef struct _DD_MISCELLANEOUS2CALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_ALPHABLT                        AlphaBlt;
    PDD_CREATESURFACEEX                 CreateSurfaceEx;
    PDD_GETDRIVERSTATE                  GetDriverState;
    PDD_DESTROYDDLOCAL                  DestroyDDLocal;
} DD_MISCELLANEOUS2CALLBACKS, *PDD_MISCELLANEOUS2CALLBACKS;

#define DDHAL_MISC2CB32_ALPHABLT                 0x00000001l
#define DDHAL_MISC2CB32_CREATESURFACEEX          0x00000002l
#define DDHAL_MISC2CB32_GETDRIVERSTATE           0x00000004l
#define DDHAL_MISC2CB32_DESTROYDDLOCAL           0x00000008l

// This is used in the CreateSurfaceEx callback to indicate that the
// SwapHandle emulation is being done
#define DDHAL_CREATESURFACEEX_SWAPHANDLES      0x00000001l

// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_NTCallbacks

typedef DWORD   (APIENTRY *PDD_FREEDRIVERMEMORY)(PDD_FREEDRIVERMEMORYDATA);
typedef DWORD   (APIENTRY *PDD_SETEXCLUSIVEMODE)(PDD_SETEXCLUSIVEMODEDATA);
typedef DWORD   (APIENTRY *PDD_FLIPTOGDISURFACE)(PDD_FLIPTOGDISURFACEDATA);

typedef struct _DD_NTCALLBACKS {
    DWORD                   dwSize;
    DWORD                   dwFlags;
    PDD_FREEDRIVERMEMORY    FreeDriverMemory;
    PDD_SETEXCLUSIVEMODE    SetExclusiveMode;
    PDD_FLIPTOGDISURFACE    FlipToGDISurface;
} DD_NTCALLBACKS, *PDD_NTCALLBACKS;

#define DDHAL_NTCB32_FREEDRIVERMEMORY   0x00000001l
#define DDHAL_NTCB32_SETEXCLUSIVEMODE   0x00000002l
#define DDHAL_NTCB32_FLIPTOGDISURFACE   0x00000004l

/*
 * DIRECTDRAWPALETTE object callbacks
 */
typedef DWORD   (APIENTRY *PDD_PALCB_DESTROYPALETTE)(PDD_DESTROYPALETTEDATA );
typedef DWORD   (APIENTRY *PDD_PALCB_SETENTRIES)(PDD_SETENTRIESDATA );

typedef struct DD_PALETTECALLBACKS
{
    DWORD                       dwSize;
    DWORD                       dwFlags;
    PDD_PALCB_DESTROYPALETTE    DestroyPalette;
    PDD_PALCB_SETENTRIES        SetEntries;
} DD_PALETTECALLBACKS;

typedef DD_PALETTECALLBACKS *PDD_PALETTECALLBACKS;

#define DDHAL_PALCB32_DESTROYPALETTE    0x00000001l
#define DDHAL_PALCB32_SETENTRIES        0x00000002l

/*
 * DIRECTDRAWSURFACE object callbacks
 */
typedef DWORD   (APIENTRY *PDD_SURFCB_LOCK)(PDD_LOCKDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_UNLOCK)(PDD_UNLOCKDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_BLT)(PDD_BLTDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_UPDATEOVERLAY)(PDD_UPDATEOVERLAYDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETOVERLAYPOSITION)(PDD_SETOVERLAYPOSITIONDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETPALETTE)(PDD_SETPALETTEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_FLIP)(PDD_FLIPDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_DESTROYSURFACE)(PDD_DESTROYSURFACEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETCLIPLIST)(PDD_SETCLIPLISTDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_ADDATTACHEDSURFACE)(PDD_ADDATTACHEDSURFACEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETCOLORKEY)(PDD_SETCOLORKEYDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_GETBLTSTATUS)(PDD_GETBLTSTATUSDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_GETFLIPSTATUS)(PDD_GETFLIPSTATUSDATA);


typedef struct DD_SURFACECALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_SURFCB_DESTROYSURFACE           DestroySurface;
    PDD_SURFCB_FLIP                     Flip;
    PDD_SURFCB_SETCLIPLIST              SetClipList;
    PDD_SURFCB_LOCK                     Lock;
    PDD_SURFCB_UNLOCK                   Unlock;
    PDD_SURFCB_BLT                      Blt;
    PDD_SURFCB_SETCOLORKEY              SetColorKey;
    PDD_SURFCB_ADDATTACHEDSURFACE       AddAttachedSurface;
    PDD_SURFCB_GETBLTSTATUS             GetBltStatus;
    PDD_SURFCB_GETFLIPSTATUS            GetFlipStatus;
    PDD_SURFCB_UPDATEOVERLAY            UpdateOverlay;
    PDD_SURFCB_SETOVERLAYPOSITION       SetOverlayPosition;
    LPVOID                              reserved4;
    PDD_SURFCB_SETPALETTE               SetPalette;
} DD_SURFACECALLBACKS;
typedef DD_SURFACECALLBACKS *PDD_SURFACECALLBACKS;

#define DDHAL_SURFCB32_DESTROYSURFACE           0x00000001l
#define DDHAL_SURFCB32_FLIP                     0x00000002l
#define DDHAL_SURFCB32_SETCLIPLIST              0x00000004l
#define DDHAL_SURFCB32_LOCK                     0x00000008l
#define DDHAL_SURFCB32_UNLOCK                   0x00000010l
#define DDHAL_SURFCB32_BLT                      0x00000020l
#define DDHAL_SURFCB32_SETCOLORKEY              0x00000040l
#define DDHAL_SURFCB32_ADDATTACHEDSURFACE       0x00000080l
#define DDHAL_SURFCB32_GETBLTSTATUS             0x00000100l
#define DDHAL_SURFCB32_GETFLIPSTATUS            0x00000200l
#define DDHAL_SURFCB32_UPDATEOVERLAY            0x00000400l
#define DDHAL_SURFCB32_SETOVERLAYPOSITION       0x00000800l
#define DDHAL_SURFCB32_RESERVED4                0x00001000l
#define DDHAL_SURFCB32_SETPALETTE               0x00002000l

/*
 * DIRECTVIDEOPORT object callbacks
 */
typedef DWORD (APIENTRY *PDD_VPORTCB_CANCREATEVIDEOPORT)(PDD_CANCREATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_CREATEVIDEOPORT)(PDD_CREATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_FLIP)(PDD_FLIPVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETBANDWIDTH)(PDD_GETVPORTBANDWIDTHDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETINPUTFORMATS)(PDD_GETVPORTINPUTFORMATDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETOUTPUTFORMATS)(PDD_GETVPORTOUTPUTFORMATDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETAUTOFLIPSURF)(PDD_GETVPORTAUTOFLIPSURFACEDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETFIELD)(PDD_GETVPORTFIELDDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETLINE)(PDD_GETVPORTLINEDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETVPORTCONNECT)(PDD_GETVPORTCONNECTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_DESTROYVPORT)(PDD_DESTROYVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETFLIPSTATUS)(PDD_GETVPORTFLIPSTATUSDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_UPDATE)(PDD_UPDATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_WAITFORSYNC)(PDD_WAITFORVPORTSYNCDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETSIGNALSTATUS)(PDD_GETVPORTSIGNALDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_COLORCONTROL)(PDD_VPORTCOLORDATA);

typedef struct DD_VIDEOPORTCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_VPORTCB_CANCREATEVIDEOPORT      CanCreateVideoPort;
    PDD_VPORTCB_CREATEVIDEOPORT         CreateVideoPort;
    PDD_VPORTCB_FLIP                    FlipVideoPort;
    PDD_VPORTCB_GETBANDWIDTH            GetVideoPortBandwidth;
    PDD_VPORTCB_GETINPUTFORMATS         GetVideoPortInputFormats;
    PDD_VPORTCB_GETOUTPUTFORMATS        GetVideoPortOutputFormats;
    LPVOID                              lpReserved1;
    PDD_VPORTCB_GETFIELD                GetVideoPortField;
    PDD_VPORTCB_GETLINE                 GetVideoPortLine;
    PDD_VPORTCB_GETVPORTCONNECT         GetVideoPortConnectInfo;
    PDD_VPORTCB_DESTROYVPORT            DestroyVideoPort;
    PDD_VPORTCB_GETFLIPSTATUS           GetVideoPortFlipStatus;
    PDD_VPORTCB_UPDATE                  UpdateVideoPort;
    PDD_VPORTCB_WAITFORSYNC             WaitForVideoPortSync;
    PDD_VPORTCB_GETSIGNALSTATUS         GetVideoSignalStatus;
    PDD_VPORTCB_COLORCONTROL            ColorControl;
} DD_VIDEOPORTCALLBACKS;

typedef DD_VIDEOPORTCALLBACKS *PDD_VIDEOPORTCALLBACKS;

#define DDHAL_VPORT32_CANCREATEVIDEOPORT        0x00000001l
#define DDHAL_VPORT32_CREATEVIDEOPORT           0x00000002l
#define DDHAL_VPORT32_FLIP                      0x00000004l
#define DDHAL_VPORT32_GETBANDWIDTH              0x00000008l
#define DDHAL_VPORT32_GETINPUTFORMATS           0x00000010l
#define DDHAL_VPORT32_GETOUTPUTFORMATS          0x00000020l
#define DDHAL_VPORT32_GETAUTOFLIPSURF           0x00000040l
#define DDHAL_VPORT32_GETFIELD                  0x00000080l
#define DDHAL_VPORT32_GETLINE                   0x00000100l
#define DDHAL_VPORT32_GETCONNECT                0x00000200l
#define DDHAL_VPORT32_DESTROY                   0x00000400l
#define DDHAL_VPORT32_GETFLIPSTATUS             0x00000800l
#define DDHAL_VPORT32_UPDATE                    0x00001000l
#define DDHAL_VPORT32_WAITFORSYNC               0x00002000l
#define DDHAL_VPORT32_GETSIGNALSTATUS           0x00004000l
#define DDHAL_VPORT32_COLORCONTROL              0x00008000l

/*
 * DIRECTDRAWCOLORCONTROL object callbacks
 */
typedef DWORD (APIENTRY *PDD_COLORCB_COLORCONTROL)(PDD_COLORCONTROLDATA);

typedef struct _DD_COLORCONTROLCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_COLORCB_COLORCONTROL            ColorControl;
} DD_COLORCONTROLCALLBACKS;

typedef DD_COLORCONTROLCALLBACKS *PDD_COLORCONTROLCALLBACKS;

#define DDHAL_COLOR_COLORCONTROL                0x00000001l

/*
 * DIRECTDRAWSURFACEKERNEL object callbacks
 * This structure can be queried from the driver from DX5 onward
 * using GetDriverInfo with GUID_KernelCallbacks
 */
typedef DWORD (APIENTRY *PDD_KERNELCB_SYNCSURFACE)(PDD_SYNCSURFACEDATA);
typedef DWORD (APIENTRY *PDD_KERNELCB_SYNCVIDEOPORT)(PDD_SYNCVIDEOPORTDATA);

typedef struct DD_KERNELCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_KERNELCB_SYNCSURFACE            SyncSurfaceData;
    PDD_KERNELCB_SYNCVIDEOPORT          SyncVideoPortData;
} DD_KERNELCALLBACKS, *PDD_KERNELCALLBACKS;

#define DDHAL_KERNEL_SYNCSURFACEDATA            0x00000001l
#define DDHAL_KERNEL_SYNCVIDEOPORTDATA          0x00000002l

/*
 * DIRECTDRAWVIDEO object callbacks
 */
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETGUIDS)( PDD_GETMOCOMPGUIDSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETFORMATS)( PDD_GETMOCOMPFORMATSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_CREATE)( PDD_CREATEMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETCOMPBUFFINFO)( PDD_GETMOCOMPCOMPBUFFDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETINTERNALINFO)( PDD_GETINTERNALMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_BEGINFRAME)( PDD_BEGINMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_ENDFRAME)( PDD_ENDMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_RENDER)( PDD_RENDERMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_QUERYSTATUS)( PDD_QUERYMOCOMPSTATUSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_DESTROY)( PDD_DESTROYMOCOMPDATA);

typedef struct DD_MOTIONCOMPCALLBACKS
{
    DWORD                           dwSize;
    DWORD                           dwFlags;
    PDD_MOCOMPCB_GETGUIDS           GetMoCompGuids;
    PDD_MOCOMPCB_GETFORMATS         GetMoCompFormats;
    PDD_MOCOMPCB_CREATE             CreateMoComp;
    PDD_MOCOMPCB_GETCOMPBUFFINFO    GetMoCompBuffInfo;
    PDD_MOCOMPCB_GETINTERNALINFO    GetInternalMoCompInfo;
    PDD_MOCOMPCB_BEGINFRAME         BeginMoCompFrame;
    PDD_MOCOMPCB_ENDFRAME           EndMoCompFrame;
    PDD_MOCOMPCB_RENDER             RenderMoComp;
    PDD_MOCOMPCB_QUERYSTATUS        QueryMoCompStatus;
    PDD_MOCOMPCB_DESTROY            DestroyMoComp;
} DD_MOTIONCOMPCALLBACKS;
typedef DD_MOTIONCOMPCALLBACKS *PDD_MOTIONCOMPCALLBACKS;

#define DDHAL_MOCOMP32_GETGUIDS                 0x00000001
#define DDHAL_MOCOMP32_GETFORMATS               0x00000002
#define DDHAL_MOCOMP32_CREATE                   0x00000004
#define DDHAL_MOCOMP32_GETCOMPBUFFINFO          0x00000008
#define DDHAL_MOCOMP32_GETINTERNALINFO          0x00000010
#define DDHAL_MOCOMP32_BEGINFRAME               0x00000020
#define DDHAL_MOCOMP32_ENDFRAME                 0x00000040
#define DDHAL_MOCOMP32_RENDER                   0x00000080
#define DDHAL_MOCOMP32_QUERYSTATUS              0x00000100
#define DDHAL_MOCOMP32_DESTROY                  0x00000200

/*
 * CALLBACK RETURN VALUES
 *
 * these are values returned by the driver from the above callback routines
 */
/*
 * indicates that the display driver didn't do anything with the call
 */
#define DDHAL_DRIVER_NOTHANDLED         0x00000000l

/*
 * indicates that the display driver handled the call; HRESULT value is valid
 */
#define DDHAL_DRIVER_HANDLED            0x00000001l

/*
 * indicates that the display driver couldn't handle the call because it
 * ran out of color key hardware resources
 */
#define DDHAL_DRIVER_NOCKEYHW           0x00000002l

/*
 * Capabilities structure for non-local video memory
 */
typedef struct _DD_NONLOCALVIDMEMCAPS
{
    DWORD   dwSize;
    DWORD   dwNLVBCaps;           // driver specific capabilities for non-local->local vidmem blts
    DWORD   dwNLVBCaps2;          // more driver specific capabilities non-local->local vidmem blts
    DWORD   dwNLVBCKeyCaps;       // driver color key capabilities for non-local->local vidmem blts
    DWORD   dwNLVBFXCaps;         // driver FX capabilities for non-local->local blts
    DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DD_NONLOCALVIDMEMCAPS;
typedef struct _DD_NONLOCALVIDMEMCAPS *PDD_NONLOCALVIDMEMCAPS;

/*
 * DDRAW internal version of DIRECTDRAWPALETTE object; it has data after the vtable
 */
typedef struct _DD_PALETTE_GLOBAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_PALETTE_GLOBAL;

typedef struct _DD_PALETTE_LOCAL
{
    ULONG                       dwReserved0;    // reserved for future expansion
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_PALETTE_LOCAL;

/*
 * DDRAW internal version of DIRECTDRAWCLIPPER object; it has data after the vtable
 */
typedef struct _DD_CLIPPER_GLOBAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_CLIPPER_GLOBAL;

typedef struct _DD_CLIPPER_LOCAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_CLIPPER_LOCAL;

typedef struct _DD_ATTACHLIST *PDD_ATTACHLIST;
typedef struct _DD_ATTACHLIST
{
    PDD_ATTACHLIST              lpLink;         // link to next attached surface
    PDD_SURFACE_LOCAL           lpAttached;     // attached surface local object
} DD_ATTACHLIST;

/*
 * DDRAW surface interface struct
 */
typedef struct _DD_SURFACE_INT
{
    PDD_SURFACE_LOCAL           lpLcl;          // pointer to interface data
} DD_SURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DD_SURFACE_GLOBAL
{
    DWORD                       dwBlockSizeY;   // block size that display driver requested (return)
    union {
        LPVIDEOMEMORY           lpVidMemHeap;   // heap vidmem was alloc'ed from
        DWORD                   dwBlockSizeX;   // block size that display driver requested (return)
        DWORD                   dwUserMemSize;  // user-mode memory size that display driver requested (return)
    };
    FLATPTR                     fpVidMem;       // pointer to video memory
    union
    {
        LONG                    lPitch;         // pitch of surface
        DWORD                   dwLinearSize;   // linear size of non-rectangular surface
    };
    LONG                        yHint;          // y-coordinate of surface
    LONG                        xHint;          // x-coordinate of surface
    DWORD                       wHeight;        // height of surface
    DWORD                       wWidth;         // width of surface
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    DDPIXELFORMAT               ddpfSurface;    // pixel format of surface
    FLATPTR                     fpHeapOffset;   // raw offset in source heap
    HANDLE                      hCreatorProcess;// opaque identifier for creating process
} DD_SURFACE_GLOBAL;

/*
 * a structure holding additional LCL surface information (to maintain some
 * compatibility with Win95).
 */
typedef struct _DD_SURFACE_MORE
{
    DWORD                       dwMipMapCount;      // number of mip-map levels
    PDD_VIDEOPORT_LOCAL         lpVideoPort;        // video port currently writing data to this surface
    DWORD                       dwOverlayFlags;     // current overlay flags
    DDSCAPSEX                   ddsCapsEx;          // more surface capabilities
    DWORD                       dwSurfaceHandle;    // cookie for use with CreateSurfaceEx DDI
} DD_SURFACE_MORE, *PDD_SURFACE_MORE;

/*
 * the LCL structure is local data for each individual surface object
 */
typedef struct _DD_SURFACE_LOCAL
{
    PDD_SURFACE_GLOBAL          lpGbl;            // pointer to surface shared data
    DWORD                       dwFlags;          // flags
    DDSCAPS                     ddsCaps;          // capabilities of surface
    ULONG_PTR                   dwReserved1;      // reserved for use by display driver
    union
    {
        DDCOLORKEY              ddckCKSrcOverlay; // color key for source overlay use
        DDCOLORKEY              ddckCKSrcBlt;     // color key for source blt and texture use
    };
    union
    {
        DDCOLORKEY              ddckCKDestOverlay;// color key for destination overlay use
        DDCOLORKEY              ddckCKDestBlt;    // color key for destination blt
    };
    PDD_SURFACE_MORE            lpSurfMore;       // pointer to additional local data
    PDD_ATTACHLIST              lpAttachList;     // link to surfaces we attached to
    PDD_ATTACHLIST              lpAttachListFrom; // link to surfaces that attached to us
    RECT                        rcOverlaySrc;     // Overlay source rectangle relative to surface
} DD_SURFACE_LOCAL;

#define DDRAWISURF_HASCKEYSRCBLT        0x00000800L     // surface has CKSrcBlt
#define DDRAWISURF_HASPIXELFORMAT       0x00002000L     // surface structure has pixel format data
#define DDRAWISURF_HASOVERLAYDATA       0x00004000L     // surface structure has overlay data
#define DDRAWISURF_FRONTBUFFER          0x04000000L     // surface was originally a front buffer
#define DDRAWISURF_BACKBUFFER           0x08000000L     // surface was originally backbuffer
#define DDRAWISURF_INVALID              0x10000000L     // surface has been invalidated by mode set
#define DDRAWISURF_DRIVERMANAGED        0x40000000L     // surface is a driver managed texture (D3D)

/*
 * More driver capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS structure in DX6.
 */
typedef struct _DD_MORECAPS
{
    DWORD   dwSize; 		    // size of DDMORECAPS structure
    DWORD   dwAlphaCaps;	    // driver-specific alpha caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBAlphaCaps;	    // driver-specific alpha capabilities for System->Vmem blts
    DWORD   dwVSBAlphaCaps;	    // driver-specific alpha capabilities for Vmem->System blts
    DWORD   dwSSBAlphaCaps;	    // driver-specific alpha capabilities for System->System blts
    DWORD   dwFilterCaps;           // driver-specific filter caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBFilterCaps;        // driver-specific filter capabilities for System->Vmem blts
    DWORD   dwVSBFilterCaps;        // driver-specific filter capabilities for Vmem->System blts
    DWORD   dwSSBFilterCaps;        // driver-specific filter capabilities for System->System blts
} DD_MORECAPS;

typedef DD_MORECAPS *PDD_MORECAPS;

/*
 * rop stuff
 */
#define ROP_HAS_SOURCE          0x00000001l
#define ROP_HAS_PATTERN         0x00000002l
#define ROP_HAS_SOURCEPATTERN   ROP_HAS_SOURCE | ROP_HAS_PATTERN

/*
 * This structure mirrors the first entries of the DDCAPS but is of a fixed
 * size and will not grow as DDCAPS grows. This is the structure your driver
 * returns in DDCOREINFO. Additional caps will be requested via a GetDriverInfo
 * call.
 */
typedef struct _DDNTCORECAPS
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwMaxVideoPorts;        // maximum number of usable video ports
    DWORD       dwCurrVideoPorts;       // current number of video ports used
    DWORD       dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
} DDNTCORECAPS, *PDDNTCORECAPS;

/*
 * structure for D3D buffer callbacks
 */
typedef struct _DD_D3DBUFCALLBACKS
{
    DWORD dwSize;
    DWORD dwFlags;
    PDD_CANCREATESURFACE        CanCreateD3DBuffer;
    PDD_CREATESURFACE           CreateD3DBuffer;
    PDD_SURFCB_DESTROYSURFACE   DestroyD3DBuffer;
    PDD_SURFCB_LOCK             LockD3DBuffer;
    PDD_SURFCB_UNLOCK           UnlockD3DBuffer;
} DD_D3DBUFCALLBACKS, *PDD_D3DBUFCALLBACKS;

#define DDHAL_EXEBUFCB32_CANCREATEEXEBUF    0x00000001l
#define DDHAL_EXEBUFCB32_CREATEEXEBUF       0x00000002l
#define DDHAL_EXEBUFCB32_DESTROYEXEBUF      0x00000004l
#define DDHAL_EXEBUFCB32_LOCKEXEBUF         0x00000008l
#define DDHAL_EXEBUFCB32_UNLOCKEXEBUF       0x00000010l

/*
 * NT friendly names
 */
#define DDHAL_D3DBUFCB32_CANCREATED3DBUF    DDHAL_EXEBUFCB32_CANCREATEEXEBUF    
#define DDHAL_D3DBUFCB32_CREATED3DBUF       DDHAL_EXEBUFCB32_CREATEEXEBUF       
#define DDHAL_D3DBUFCB32_DESTROYD3DBUF      DDHAL_EXEBUFCB32_DESTROYEXEBUF      
#define DDHAL_D3DBUFCB32_LOCKD3DBUF         DDHAL_EXEBUFCB32_LOCKEXEBUF         
#define DDHAL_D3DBUFCB32_UNLOCKD3DBUF       DDHAL_EXEBUFCB32_UNLOCKEXEBUF       


/*
 * structure for display driver to call DDHAL_Create with
 * the _V4 version was used by NT4 drivers
 */
typedef struct _DD_HALINFO_V4
{
    DWORD                       dwSize;
    VIDEOMEMORYINFO             vmiData;                // video memory info
    DDNTCORECAPS                ddCaps;                 // hw specific caps
    PDD_GETDRIVERINFO           GetDriverInfo;          // callback for querying driver data
    DWORD                       dwFlags;                // create flags
} DD_HALINFO_V4, *PDD_HALINFO_V4;

typedef struct _DD_HALINFO
{
    DWORD                       dwSize;
    VIDEOMEMORYINFO             vmiData;                // video memory info
    DDNTCORECAPS                ddCaps;                 // hw specific caps
    PDD_GETDRIVERINFO           GetDriverInfo;          // callback for querying driver data
    DWORD                       dwFlags;                // create flags
    LPVOID                      lpD3DGlobalDriverData;  // D3D global Data
    LPVOID                      lpD3DHALCallbacks;      // D3D callbacks
    PDD_D3DBUFCALLBACKS         lpD3DBufCallbacks;      // Buffer callbacks
} DD_HALINFO, *PDD_HALINFO;

#define DDHALINFO_GETDRIVERINFOSET      0x00000004l     // indicates that GetDriverInfo is set

/*
 * DDRAW version of DirectDraw object;
 *
 */
typedef struct _DD_DIRECTDRAW_GLOBAL
{
    VOID*                       dhpdev;         // driver's private PDEV pointer
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    ULONG_PTR                   dwReserved2;    // reserved for use by display driver
    LPDDVIDEOPORTCAPS           lpDDVideoPortCaps;// Info returned by the HAL (an array if more than one video port)
} DD_DIRECTDRAW_GLOBAL;

typedef struct _DD_DIRECTDRAW_LOCAL
{
    PDD_DIRECTDRAW_GLOBAL       lpGbl;            // pointer to data
} DD_DIRECTDRAW_LOCAL;

typedef struct _DD_VIDEOPORT_LOCAL
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // pointer to DIRECTDRAW_LCL
    DDVIDEOPORTDESC             ddvpDesc;         // description used at create time
    DDVIDEOPORTINFO             ddvpInfo;         // most recent video port info
    PDD_SURFACE_INT             lpSurface;        // surface receiving the data
    PDD_SURFACE_INT             lpVBISurface;     // surface receiving the VBI data
    DWORD                       dwNumAutoflip;    // Number of current autoflip surfaces
    DWORD                       dwNumVBIAutoflip; // Number of VBI surfaces currently being autoflipped
    ULONG_PTR                   dwReserved1;      // Reserved for display driver
    ULONG_PTR                   dwReserved2;      // Reserved for display driver
    ULONG_PTR                   dwReserved3;      // Reserved for display driver
} DD_VIDEOPORT_LOCAL;

#define DDRAWIVPORT_ON                  0x00000001      // Video port is pumping data
#define DDRAWIVPORT_SOFTWARE_AUTOFLIP   0x00000002      // Video port cannot use hardware autoflip
#define DDRAWIVPORT_COLORKEYANDINTERP   0x00000004      // Overlay cannot bob and colorkey at same time

typedef struct _DD_MOTIONCOMP_LOCAL
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // pointer to DIRECTDRAW_LCL
    GUID                            guid;
    DWORD                           dwUncompWidth;
    DWORD                           dwUncompHeight;
    DDPIXELFORMAT                   ddUncompPixelFormat;
    DWORD                           dwDriverReserved1;
    DWORD                           dwDriverReserved2;
    DWORD                           dwDriverReserved3;
    LPVOID                          lpDriverReserved1;
    LPVOID                          lpDriverReserved2;
    LPVOID                          lpDriverReserved3;
} DD_MOTIONCOMP_LOCAL;


/*
 * More driver surface capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS.ddsCaps structure in DX6.
 */
typedef struct _DD_MORESURFACECAPS
{
    DWORD       dwSize;             // size of DDMORESURFACECAPS structure
    DDSCAPSEX   ddsCapsMore;
    /*
     * The DDMORESURFACECAPS struct is of variable size. The following list may be
     * filled in by DX6-aware drivers (see DDVERSIONINFO) to restrict their
     * video memory heaps (those which are exposed to DirectDraw) to
     * certain sets of DDSCAPS_ bits. Thse entries are exactly analogous to
     * the ddsCaps and ddsCapsAlt members of the VIDMEM structures listed in
     * the VIDMEMINFO.pvmList member of DDHALINFO.vmiData. There should be
     * exactly DDHALINFO.vmiData.dwNumHeaps copies of tagExtendedHeapRestrictions
     * in this struct. The size of this struct is thus:
     *  DDMORESURFACECAPS.dwSize = sizeof(DDMORESURFACECAPS) +
     *          (DDHALINFO.vmiData.dwNumHeaps-1) * sizeof(DDSCAPSEX)*2;
     * Note the -1 accounts for the fact that DDMORESURFACECAPS is declared to have 1
     * tagExtendedHeapRestrictions member.
     */
    struct tagNTExtendedHeapRestrictions
    {
        DDSCAPSEX   ddsCapsEx;
        DDSCAPSEX   ddsCapsExAlt;
    } ddsExtendedHeapRestrictions[1];
} DD_MORESURFACECAPS;

// for DX7, we check each mode in the driver if it supports 
// Stereo, driver returns DD_OK if mode is ok for stereo
typedef struct _DD_STEREOMODE
{
    DWORD       dwSize;             // size of DDSTEREOMODECAPS structure

    DWORD       dwHeight;
    DWORD       dwWidth;
    DWORD       dwBpp;
    DWORD       dwRefreshRate;

    BOOL        bSupported;

} DD_STEREOMODE;

typedef struct _DD_UPDATENONLOCALHEAPDATA
{
    PDD_DIRECTDRAW_GLOBAL      lpDD;                // driver struct
    DWORD                      dwHeap;              // heap index
    FLATPTR                    fpGARTLin;           // linear GART address of start of heap
    FLATPTR                    fpGARTDev;           // high physical GART address of start of heap
    ULONG_PTR                  ulPolicyMaxBytes;    // maximum amount of AGP memory to use
    HRESULT                    ddRVal;              // return value
    VOID*                      UpdateNonLocalHeap;  // Unused: Win95 compatibility
} DD_UPDATENONLOCALHEAPDATA;

/*
 * Private caps that the driver passes to change DirectDraw behavior.
 * These caps are not exposed to the application
 */

typedef struct DD_NTPRIVATEDRIVERCAPS
{
    DWORD                               dwSize;
    DWORD                               dwPrivateCaps;
} DD_NTPRIVATEDRIVERCAPS;

// Driver wants DD_CREATESURFACEDATA.lplpSList to contain a list of
// surfaces to create rather than always a single surface.
#define DDHAL_PRIVATECAP_ATOMICSURFACECREATION 0x00000001l

// Driver wants to be notified when creating a primary surface.
#define DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION  0x00000002l

/////////////////////////////////////////////////////////////////////////////
// NT Note:
//
// The following structures must match, field for field, the corresponding
// structures as declared in 'ddrawi.h.'  We cannot simply use the same
// structures because the sub-structures such as DD_DIRECTDRAW_GLOBAL are
// different, and have to be properly typed for the drivers.
//
/////////////////////////////////////////////////////////////////////////////

/****************************************************************************
 *
 * DDHAL structures for Surface Object callbacks
 *
 ***************************************************************************/

/*
 * This special flag is seen only by drivers.  The DD runtime sets this
 * bit in DDHAL_BLTDATA.dwFlags if the dwAFlags and ddrgbaScaleFactors
 * members at the end of the DDHAL_BLTDATA structure are valid.
 * The flag is always set if the DDHAL_BLTDATA structure is passed to
 * the driver via the AlphaBlt HAL callback; otherwise, the flag is zero.
 */
#define DDBLT_AFLAGS 		0x80000000L

/*
 * This flag will be set in DDHAL_BLTDATA.dwAFlags if the call was originated
 * by the AlphaBlt API method. If the call was originated by the Blt API,
 * this flag will not be set.
 * Drivers which have a unified Blt/AlphaBlt DDI can use this flag to distinguish
 * between the two API calls.
 */
#define DDABLT_SRCOVERDEST      0x00000001L

/*
 * structure for passing information to DDHAL Blt fn
 */
typedef struct _DD_BLTDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    RECTL                       rDest;          // dest rect
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    RECTL                       rSrc;           // src rect
    DWORD                       dwFlags;        // blt flags
    DWORD                       dwROPFlags;     // ROP flags (valid for ROPS only)
    DDBLTFX                     bltFX;          // blt FX
    HRESULT                     ddRVal;         // return value
    VOID*                       Blt;            // Unused: Win95 compatibility
    BOOL                        IsClipped;      // clipped blt?
    RECTL                       rOrigDest;      // unclipped dest rect
                                                // (only valid if IsClipped)
    RECTL                       rOrigSrc;       // unclipped src rect
                                                // (only valid if IsClipped)
    DWORD                       dwRectCnt;      // count of dest rects
                                                // (only valid if IsClipped)
    LPRECT                      prDestRects;    // array of dest rects
                                                // (only valid if IsClipped)
    DWORD                       dwAFlags;       // DDABLT_ flags (for AlphaBlt DDI)
    DDARGB                      ddargbScaleFactors;  // ARGB scaling factors (AlphaBlt)
} DD_BLTDATA;

/*
 * structure for passing information to DDHAL Lock fn
 */
typedef struct _DD_LOCKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       bHasRect;       // rArea is valid
    RECTL                       rArea;          // area being locked
    LPVOID                      lpSurfData;     // pointer to screen memory (return value)
    HRESULT                     ddRVal;         // return value
    VOID*                       Lock;           // Unused: Win95 compatibility
    DWORD                       dwFlags;        // DDLOCK flags
    FLATPTR                     fpProcess;      // process start address
} DD_LOCKDATA;

/*
 * structure for passing information to DDHAL Unlock fn
 */
typedef struct _DD_UNLOCKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       Unlock;         // Unused: Win95 compatibility
} DD_UNLOCKDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DD_UPDATEOVERLAYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    RECTL                       rDest;          // dest rect
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    RECTL                       rSrc;           // src rect
    DWORD                       dwFlags;        // flags
    DDOVERLAYFX                 overlayFX;      // overlay FX
    HRESULT                     ddRVal;         // return value
    VOID*                       UpdateOverlay;  // Unused: Win95 compatibility
} DD_UPDATEOVERLAYDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DD_SETOVERLAYPOSITIONDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    LONG                        lXPos;          // x position
    LONG                        lYPos;          // y position
    HRESULT                     ddRVal;         // return value
    VOID*                       SetOverlayPosition; // Unused: Win95 compatibility
} DD_SETOVERLAYPOSITIONDATA;
/*
 * structure for passing information to DDHAL SetPalette fn
 */
typedef struct _DD_SETPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette to set to surface
    HRESULT                     ddRVal;         // return value
    VOID*                       SetPalette;     // Unused: Win95 compatibility
    BOOL                        Attach;         // attach this palette?
} DD_SETPALETTEDATA;

/*
 * structure for passing information to DDHAL Flip fn
 */
typedef struct _DD_FLIPDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpSurfCurr;     // current surface
    PDD_SURFACE_LOCAL           lpSurfTarg;     // target surface (to flip to)
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       Flip;           // Unused: Win95 compatibility
    PDD_SURFACE_LOCAL           lpSurfCurrLeft;     // left target surface (to flip to)
    PDD_SURFACE_LOCAL           lpSurfTargLeft;     // left target surface (to flip to)
} DD_FLIPDATA;

/*
 * structure for passing information to DDHAL DestroySurface fn
 */
typedef struct _DD_DESTROYSURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       DestroySurface;// Unused: Win95 compatibility
} DD_DESTROYSURFACEDATA;

/*
 * structure for passing information to DDHAL SetClipList fn
 */
typedef struct _DD_SETCLIPLISTDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       SetClipList;    // Unused: Win95 compatibility
} DD_SETCLIPLISTDATA;

/*
 * structure for passing information to DDHAL AddAttachedSurface fn
 */
typedef struct _DD_ADDATTACHEDSURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    PDD_SURFACE_LOCAL           lpSurfAttached; // surface to attach
    HRESULT                     ddRVal;         // return value
    VOID*                       AddAttachedSurface; // Unused: Win95 compatibility
} DD_ADDATTACHEDSURFACEDATA;

/*
 * structure for passing information to DDHAL SetColorKey fn
 */
typedef struct _DD_SETCOLORKEYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    DDCOLORKEY                  ckNew;          // new color key
    HRESULT                     ddRVal;         // return value
    VOID*                       SetColorKey;    // Unused: Win95 compatibility
} DD_SETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetBltStatus fn
 */
typedef struct _DD_GETBLTSTATUSDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       GetBltStatus;   // Unused: Win95 compatibility
} DD_GETBLTSTATUSDATA;

/*
 * structure for passing information to DDHAL GetFlipStatus fn
 */
typedef struct _DD_GETFLIPSTATUSDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       GetFlipStatus;  // Unused: Win95 compatibility
} DD_GETFLIPSTATUSDATA;

/****************************************************************************
 *
 * DDHAL structures for Palette Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL DestroyPalette fn
 */
typedef struct _DD_DESTROYPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette struct
    HRESULT                     ddRVal;         // return value
    VOID*                       DestroyPalette; // Unused: Win95 compatibility
} DD_DESTROYPALETTEDATA;

/*
 * structure for passing information to DDHAL SetEntries fn
 */
typedef struct _DD_SETENTRIESDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette struct
    DWORD                       dwBase;         // base palette index
    DWORD                       dwNumEntries;   // number of palette entries
    LPPALETTEENTRY              lpEntries;      // color table
    HRESULT                     ddRVal;         // return value
    VOID*                       SetEntries;     // Unused: Win95 compatibility
} DD_SETENTRIESDATA;

/****************************************************************************
 *
 * DDHAL structures for Driver Object callbacks
 *
 ***************************************************************************/

typedef DDSURFACEDESC* PDD_SURFACEDESC;

/*
 * structure for passing information to DDHAL CreateSurface fn
 */
typedef struct _DD_CREATESURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACEDESC             lpDDSurfaceDesc;// description of surface being created
    PDD_SURFACE_LOCAL           *lplpSList;     // list of created surface objects
    DWORD                       dwSCnt;         // number of surfaces in SList
    HRESULT                     ddRVal;         // return value
    VOID*                       CreateSurface;  // Unused: Win95 compatibility
} DD_CREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CanCreateSurface fn
 */
typedef struct _DD_CANCREATESURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;                   // driver struct
    PDD_SURFACEDESC             lpDDSurfaceDesc;        // description of surface being created
    DWORD                       bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT                     ddRVal;                 // return value
    VOID*                       CanCreateSurface;       // Unused: Win95 compatibility
} DD_CANCREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CreatePalette fn
 */
typedef struct _DD_CREATEPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // ddraw palette struct
    LPPALETTEENTRY              lpColorTable;   // colors to go in palette
    HRESULT                     ddRVal;         // return value
    VOID*                       CreatePalette;  // Unused: Win95 compatibility
    BOOL                        is_excl;        // process has exclusive mode
} DD_CREATEPALETTEDATA;

/*
 * Return if the vertical blank is in progress
 */
#define DDWAITVB_I_TESTVB                       0x80000006l

/*
 * structure for passing information to DDHAL WaitForVerticalBlank fn
 */
typedef struct _DD_WAITFORVERTICALBLANKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwFlags;        // flags
    DWORD                       bIsInVB;        // is in vertical blank
    DWORD                       hEvent;         // event
    HRESULT                     ddRVal;         // return value
    VOID*                       WaitForVerticalBlank; // Unused: Win95 compatibility
} DD_WAITFORVERTICALBLANKDATA;

/*
 * structure for passing information to DDHAL driver SetColorKey fn
 */
typedef struct _DD_DRVSETCOLORKEYDATA
{
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    DDCOLORKEY                  ckNew;          // new color key
    HRESULT                     ddRVal;         // return value
    VOID*                       SetColorKey;    // Unused: Win95 compatibility
} DD_DRVSETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetScanLine fn
 */
typedef struct _DD_GETSCANLINEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwScanLine;     // returned scan line
    HRESULT                     ddRVal;         // return value
    VOID*                       GetScanLine;    // Unused: Win95 compatibility
} DD_GETSCANLINEDATA;

/*
 * structure for passing information to DDHAL MapMemory fn
 */
typedef struct _DD_MAPMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    BOOL                        bMap;           // TRUE if map; FALSe if un-map
    HANDLE                      hProcess;       // process handle
    FLATPTR                     fpProcess;      // returned address in process' address space
    HRESULT                     ddRVal;         // return value
} DD_MAPMEMORYDATA;

/****************************************************************************
 *
 * DDHAL structures for VideoPort callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CanCreateVideoPort fn
 */
typedef struct _DD_CANCREATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;               // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    HRESULT                     ddRVal;             // return value
    VOID*                       CanCreateVideoPort; // Unused: Win95 compatibility
} DD_CANCREATEVPORTDATA;

/*
 * structure for passing information to DDHAL CreateVideoPort fn
 */
typedef struct _DD_CREATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;              // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    PDD_VIDEOPORT_LOCAL         lpVideoPort;       // Video port created
    HRESULT                     ddRVal;            // return value
    VOID*                       CreateVideoPort;   // Unused: Win95 compatibility
} DD_CREATEVPORTDATA;

/*
 * structure for passing information to DDHAL FlipVideoPort fn
 */
typedef struct _DD_FLIPVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;          // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;   // Video port object
    PDD_SURFACE_LOCAL           lpSurfCurr;    // current surface
    PDD_SURFACE_LOCAL           lpSurfTarg;    // target surface
    HRESULT                     ddRVal;        // return value
    VOID*                       FlipVideoPort; // Unused: Win95 compatibility
} DD_FLIPVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortBandwidth fn
 */
typedef struct _DD_GETVPORTBANDWIDTHDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                  // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;           // Video port object
    LPDDPIXELFORMAT             lpddpfFormat;          // Format for bandwidth
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwFlags;               // Prescale factor for bandwidth
    LPDDVIDEOPORTBANDWIDTH      lpBandwidth;           // Returned bandwidth parameters
    HRESULT                     ddRVal;                // return value
    VOID*                       GetVideoPortBandwidth; // Unused: Win95 compatibility
} DD_GETVPORTBANDWIDTHDATA;

/*
 * structure for passing information to DDHAL GetVideoPortInputFormats fn
 */
typedef struct _DD_GETVPORTINPUTFORMATDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                     // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;              // Video port object
    DWORD                       dwFlags;                  // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfFormat;             // Array of formats
    DWORD                       dwNumFormats;             // # of formats in array
    HRESULT                     ddRVal;                   // return value
    VOID*                       GetVideoPortInputFormats; // Unused: Win95 compatibility
} DD_GETVPORTINPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortOutputFormats fn
 */
typedef struct _DD_GETVPORTOUTPUTFORMATDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                     // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;              // Video port object
    DWORD                       dwFlags;                  // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfInputFormat;        // Input format
    LPDDPIXELFORMAT             lpddpfOutputFormats;      // Array of output formats
    DWORD                       dwNumFormats;             // # of formats in array
    HRESULT                     ddRVal;                   // return value
    VOID*                       GetVideoPortInputFormats; // Unused: Win95 compatibility
} DD_GETVPORTOUTPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortField fn
 */
typedef struct _DD_GETVPORTFIELDDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;              // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;       // Video port object
    BOOL                        bField;            // TRUE if even
    HRESULT                     ddRVal;            // return value
    VOID*                       GetVideoPortField; // Unused: Win95 compatibility
} DD_GETVPORTFIELDDATA;

/*
 * structure for passing information to DDHAL GetVideoPortLine fn
 */
typedef struct _DD_GETVPORTLINEDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    DWORD                       dwLine;           // Current line counter
    HRESULT                     ddRVal;           // return value
    VOID*                       GetVideoPortLine; // Unused: Win95 compatibility
} DD_GETVPORTLINEDATA;

/*
 * structure for passing information to DDHAL GetVideoPortConnectInfo fn
 */
typedef struct _DD_GETVPORTCONNECTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                    // driver struct
    DWORD                       dwPortId;                // ID of desired video port
    LPDDVIDEOPORTCONNECT        lpConnect;               // Array of DDVIDEOPORTCONNECT structures
    DWORD                       dwNumEntries;            // # of structures in array
    HRESULT                     ddRVal;                  // return value
    VOID*                       GetVideoPortConnectInfo; // Unused: Win95 compatibility
} DD_GETVPORTCONNECTDATA;

/*
 * structure for passing information to DDHAL DestroyVideoPort fn
 */
typedef struct _DD_DESTROYVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    HRESULT                     ddRVal;           // return value
    VOID*                       DestroyVideoPort; // Unused: Win95 compatibility
} DD_DESTROYVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortFlipStatus fn
 */
typedef struct _DD_GETVPORTFLIPSTATUSDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                   // driver struct
    FLATPTR                     fpSurface;              // surface struct
    HRESULT                     ddRVal;                 // return value
    VOID*                       GetVideoPortFlipStatus; // Unused: Win95 compatibility
} DD_GETVPORTFLIPSTATUSDATA;

typedef DDVIDEOPORTINFO*   PDD_VIDEOPORTINFO;
/*
 * structure for passing information to DDHAL UpdateVideoPort fn
 */
typedef struct _DD_UPDATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    PDD_SURFACE_INT            *lplpDDSurface;    // surface struct
    PDD_SURFACE_INT            *lplpDDVBISurface; // VBI surface structure
    PDD_VIDEOPORTINFO           lpVideoInfo;      // Video information
    DWORD                       dwFlags;          // DDRAWI_VPORTSTART, DDRAWI_VPORTSTOP, DDRAWI_VPORTUPDATE
    DWORD                       dwNumAutoflip;    // # of autoflip surfaces. If > 1, lpDDSurface is an array.
    DWORD                       dwNumVBIAutoflip; // # of autoflip surfaces. If > 1, lpDDVBISurface is an array.
    HRESULT                     ddRVal;           // return value
    VOID*                       UpdateVideoPort;  // Unused: Win95 compatibility
} DD_UPDATEVPORTDATA;

#define DDRAWI_VPORTSTART       0x0001
#define DDRAWI_VPORTSTOP        0x0002
#define DDRAWI_VPORTUPDATE      0x0003

/*
 * structure for passing information to DDHAL WaitForVideoPortSync fn
 */
typedef struct _DD_WAITFORVPORTSYNCDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;            // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;     // Video port object
    DWORD                       dwFlags;         // DDVPEVENT_XXXX
    DWORD                       dwLine;
    DWORD                       dwTimeOut;       // Max time to wait before returning
    HRESULT                     ddRVal;          // return value
    VOID*                       UpdateVideoPort; // Unused: Win95 compatibility
} DD_WAITFORVPORTSYNCDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DD_GETVPORTSIGNALDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                 // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;          // Video port object
    DWORD                       dwStatus;             // Video signal status
    HRESULT                     ddRVal;               // return value
    VOID*                       GetVideoSignalStatus; // Unused: Win95 compatibility
} DD_GETVPORTSIGNALDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DD_VPORTCOLORDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;         // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;  // Video port object
    DWORD                       dwFlags;      // Video signal status
    LPDDCOLORCONTROL            lpColorData;
    HRESULT                     ddRVal;       // return value
    VOID*                       ColorControl; // Unused: Win95 compatibility
} DD_VPORTCOLORDATA;

#define DDRAWI_VPORTGETCOLOR    0x0001
#define DDRAWI_VPORTSETCOLOR    0x0002

/****************************************************************************
 *
 * DDHAL structures for Color Control callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL ColorControl fn
 */
typedef struct _DD_COLORCONTROLDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface
    LPDDCOLORCONTROL            lpColorData;    // color control information
    DWORD                       dwFlags;        // DDRAWI_GETCOLOR/DDRAWI_SETCOLOR
    HRESULT                     ddRVal;         // return value
    VOID*                       ColorControl;   // Unused: Win95 compatibility
} DD_COLORCONTROLDATA;

#define DDRAWI_GETCOLOR         0x0001
#define DDRAWI_SETCOLOR         0x0002

/****************************************************************************
 *
 * DDHAL structure for GetDriverData callback
 *
 ***************************************************************************/

typedef struct _DD_GETDRIVERINFODATA {

    // Input fields filled in by DirectDraw

    VOID*                       dhpdev;         // Driver context
    DWORD                       dwSize;         // Size of this structure
    DWORD                       dwFlags;        // Flags
    GUID                        guidInfo;       // GUID that DirectX is querying for
    DWORD                       dwExpectedSize; // Size of callbacks structure expected by DirectDraw.
    PVOID                       lpvData;        // Buffer that will receive the requested data

    // Output fields filled in by driver

    DWORD                       dwActualSize;   // Size of callbacks structure expected by driver
    HRESULT                     ddRVal;         // Return value from driver

} DD_GETDRIVERINFODATA;

/****************************************************************************
 *
 * DDHAL structure for misc. driver callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetAvailDriverMemory fn
 */
typedef struct _DD_GETAVAILDRIVERMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;            // driver struct
    DDSCAPS                     DDSCaps;         // caps for type of surface memory
    DWORD                       dwTotal;         // total memory for this kind of surface
    DWORD                       dwFree;          // free memory for this kind of surface
    HRESULT                     ddRVal;          // return value
    VOID*                       GetAvailDriverMemory; // Unused: Win95 compatibility
} DD_GETAVAILDRIVERMEMORYDATA;


/****************************************************************************
 *
 * DDHAL structures for NT callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL FreeDriverMemory fn
 */
typedef struct _DD_FREEDRIVERMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;            // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;     // surface object trying to be created
    HRESULT                     ddRVal;          // return value
    VOID*                       FreeDriverMemory;// Unused: Win95 compatibility
} DD_FREEDRIVERMEMORYDATA;

/*
 * structure for passing information to DDHAL SetExclusiveMode fn
 */
typedef struct _DD_SETEXCLUSIVEMODEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwEnterExcl;    // TRUE if entering exclusive mode, FALSE is leaving
    DWORD                       dwReserved;     // reserved for future use
    HRESULT                     ddRVal;         // return value
    VOID*                       SetExclusiveMode; // Unused: Win95 compatibility
} DD_SETEXCLUSIVEMODEDATA;

/*
 * structure for passing information to DDHAL FlipToGDISurface fn
 */
typedef struct _DD_FLIPTOGDISURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwToGDI;        // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD                       dwReserved;     // reserved for future use
    HRESULT                     ddRVal;         // return value
    VOID*                       FlipToGDISurface; // Unused: Win95 compatibility
} DD_FLIPTOGDISURFACEDATA;

/****************************************************************************
 *
 * DDHAL structure for kernel callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL SyncSurfaceData fn
 */
typedef struct _DD_SYNCSURFACEDATA
{
    PDD_DIRECTDRAW_LOCAL   lpDD;        // driver struct
    PDD_SURFACE_LOCAL      lpDDSurface; // Surface to sync with
    DWORD       dwSurfaceOffset;        // Offset in frame buffer of surface
    ULONG_PTR    fpLockPtr;              // Surface lock ptr
    LONG        lPitch;                 // Surface pitch
    DWORD       dwOverlayOffset;        // Added to dwSurfaceOffset for origin, clipping, etc.
    ULONG       dwDriverReserved1;      // Reserved for the HAL
    ULONG       dwDriverReserved2;      // Reserved for the HAL
    ULONG       dwDriverReserved3;      // Reserved for the HAL
    ULONG       dwDriverReserved4;      // Reserved for the HAL
    HRESULT     ddRVal;
} DD_SYNCSURFACEDATA;

/*
 * structure for passing information to DDHAL SyncVideoPortData fn
 */
typedef struct _DD_SYNCVIDEOPORTDATA
{
    PDD_DIRECTDRAW_LOCAL    lpDD;       // driver struct
    PDD_VIDEOPORT_LOCAL     lpVideoPort;// Video port object
    DWORD       dwOriginOffset;         // Start address relative to surface
    DWORD       dwHeight;               // Height of total video region (per field)
    DWORD       dwVBIHeight;            // Height of VBI region (per field)
    ULONG       dwDriverReserved1;      // Reserved for the HAL
    ULONG       dwDriverReserved2;      // Reserved for the HAL
    ULONG       dwDriverReserved3;      // Reserved for the HAL
    HRESULT     ddRVal;
} DD_SYNCVIDEOPORTDATA;

/****************************************************************************
 *
 * DDHAL structure for motion comp callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetMoCompGuids
 */
typedef struct _DD_GETMOCOMPGUIDSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    DWORD                     dwNumGuids;
    GUID*                     lpGuids;
    HRESULT                   ddRVal;
} DD_GETMOCOMPGUIDSDATA;

/*
 * structure for passing information to DDHAL GetMoCompFormats
 */
typedef struct _DD_GETMOCOMPFORMATSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwNumFormats;
    LPDDPIXELFORMAT           lpFormats;
    HRESULT                   ddRVal;
} DD_GETMOCOMPFORMATSDATA;

/*
 * structure for passing information to DDHAL CreateMoComp
 */
typedef struct _DD_CREATEMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    GUID*                     lpGuid;
    DWORD                     dwUncompWidth;
    DWORD                     dwUncompHeight;
    DDPIXELFORMAT             ddUncompPixelFormat;
    LPVOID                    lpData;
    DWORD                     dwDataSize;
    HRESULT                   ddRVal;
} DD_CREATEMOCOMPDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DDCOMPBUFFERINFO
{
    DWORD                     dwSize;             // [in]   size of the struct
    DWORD                     dwNumCompBuffers;   // [out]  number of buffers required for compressed data
    DWORD                     dwWidthToCreate;    // [out]    Width of surface to create
    DWORD                     dwHeightToCreate;   // [out]    Height of surface to create
    DWORD                     dwBytesToAllocate;  // [out]    Total number of bytes used by each surface
    DDSCAPS2                  ddCompCaps;         // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT             ddPixelFormat;      // [out]  format to create surfaces to store compressed data
} DDCOMPBUFFERINFO, *LPDDCOMPBUFFERINFO;

typedef struct _DD_GETMOCOMPCOMPBUFFDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwWidth;            // [in]   width of uncompressed data
    DWORD                     dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT             ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                     dwNumTypesCompBuffs;// [in/out] number of memory types required for comp buffers
    LPDDCOMPBUFFERINFO        lpCompBuffInfo;     // [in]   driver supplied info regarding comp buffers (allocated by client)
    HRESULT                   ddRVal;             // [out]
} DD_GETMOCOMPCOMPBUFFDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DD_GETINTERNALMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwWidth;            // [in]   width of uncompressed data
    DWORD                     dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT             ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                     dwScratchMemAlloc;  // [out]  amount of scratch memory will the hal allocate for its private use
    HRESULT                   ddRVal;             // [out]
} DD_GETINTERNALMOCOMPDATA;

/*
 * structure for passing information to DDHAL BeginMoCompFrame
 */
typedef struct _DD_BEGINMOCOMPFRAMEDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    PDD_SURFACE_LOCAL         lpDestSurface;        // [in]  destination buffer in which to decoding this frame
    DWORD                     dwInputDataSize;      // [in]  size of other misc input data to begin frame
    LPVOID                    lpInputData;          // [in]  pointer to misc input data
    DWORD                     dwOutputDataSize;     // [in]  size of other misc output data to begin frame
    LPVOID                    lpOutputData;         // [in]  pointer to output misc data (allocated by client)
    HRESULT                   ddRVal;               // [out]
} DD_BEGINMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL EndMoCompFrame
 */
typedef struct _DD_ENDMOCOMPFRAMEDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    LPVOID                    lpInputData;
    DWORD                     dwInputDataSize;
    HRESULT                   ddRVal;
} DD_ENDMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL RenderMoComp
 */
typedef struct _DDMOCOMPBUFFERINFO
{
    DWORD                     dwSize;         // [in]    size of the struct
    PDD_SURFACE_LOCAL         lpCompSurface;  // [in]    pointer to buffer containing compressed data
    DWORD                     dwDataOffset;   // [in]    offset of relevant data from the beginning of buffer
    DWORD                     dwDataSize;     // [in]    size of relevant data
    LPVOID                    lpPrivate;      // Reserved by DirectDraw
} DDMOCOMPBUFFERINFO, *LPDDMOCOMPBUFFERINFO;

typedef struct _DD_RENDERMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    DWORD                     dwNumBuffers;     // [in]  Number of entries in the lpMacroBlockInfo array
    LPDDMOCOMPBUFFERINFO      lpBufferInfo;     // [in]  Surfaces containing macro block info
    DWORD                     dwFunction;       // [in]  Function
    LPVOID                    lpInputData;
    DWORD                     dwInputDataSize;
    LPVOID                    lpOutputData;
    DWORD                     dwOutputDataSize;
    HRESULT                   ddRVal;           // [out]
} DD_RENDERMOCOMPDATA;

/*
 * structure for passing information to DDHAL QueryMoCompStatus
 */
typedef struct _DD_QUERYMOCOMPSTATUSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    PDD_SURFACE_LOCAL         lpSurface;        // [in]  Surface being queried
    DWORD                     dwFlags;          // [in]  DDMCQUERY_XXX flags
    HRESULT                   ddRVal;            // [out]
} DD_QUERYMOCOMPSTATUSDATA;

#define DDMCQUERY_READ          0x00000001

/*
 * structure for passing information to DDHAL DestroyVideo
 */
typedef struct _DD_DESTROYMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    HRESULT                   ddRVal;
} DD_DESTROYMOCOMPDATA;


/****************************************************************************
 *
 * DDHAL structures for Miscellaneous2 callbacks
 *
 ***************************************************************************/
// This DDI is called by the kernel only.
typedef struct _DD_CREATESURFACEEXDATA
{
    DWORD                       dwFlags;
    PDD_DIRECTDRAW_LOCAL        lpDDLcl;        // driver struct
    PDD_SURFACE_LOCAL           lpDDSLcl;       // created surface
                                                // objects
    HRESULT                     ddRVal;         // return value
} DD_CREATESURFACEEXDATA;

// This DDI is used by both ddraw and d3d to obtain information from
// the driver.
typedef struct _DD_GETDRIVERSTATEDATA
{
    DWORD                       dwFlags;        // Flags to indicate the data
                                                // required
    union
    {
        PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
        DWORD_PTR                   dwhContext;     // d3d context
    };
    LPDWORD                     lpdwStates;     // ptr to the state data
                                                // to be filled in by the
                                                // driver
    DWORD                       dwLength;
    HRESULT                     ddRVal;         // return value
} DD_GETDRIVERSTATEDATA;

typedef struct _DD_DESTROYDDLOCALDATA
{
    DWORD dwFlags;
    PDD_DIRECTDRAW_LOCAL pDDLcl;
    HRESULT  ddRVal;
} DD_DESTROYDDLOCALDATA;


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\dxmini.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxmini.h
 *  Content:    Miniport support for DirectDraw DXAPI.  This file is
 *              analagous to Win95's ddkmmini.h.
 *
 ***************************************************************************/

#ifndef __DXMINI_INCLUDED__
#define __DXMINI_INCLUDED__

DEFINE_GUID(GUID_DxApi, 0x8a79bef0, 0xb915, 0x11d0, 0x91, 0x44, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);

#ifndef GUID_DEFS_ONLY
/*============================================================================
 *
 * MDL structure for handling pagelocked memory.  This is copied from WDM.H
 *
 *==========================================================================*/

#ifndef MDL_MAPPING_FLAGS

    typedef struct _MDL {
        struct _MDL *MdlNext;
        short MdlSize;
        short MdlFlags;
        struct _EPROCESS *Process;
        ULONG *lpMappedSystemVa;
        ULONG *lpStartVa;
        ULONG ByteCount;
        ULONG ByteOffset;
    } MDL;
    typedef MDL *PMDL;

    #define MDL_MAPPED_TO_SYSTEM_VA     0x0001
    #define MDL_PAGES_LOCKED            0x0002
    #define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
    #define MDL_ALLOCATED_FIXED_SIZE    0x0008
    #define MDL_PARTIAL                 0x0010
    #define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
    #define MDL_IO_PAGE_READ            0x0040
    #define MDL_WRITE_OPERATION         0x0080
    #define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
    #define MDL_LOCK_HELD               0x0200
    #define MDL_SCATTER_GATHER_VA       0x0400
    #define MDL_IO_SPACE                0x0800
    #define MDL_NETWORK_HEADER          0x1000
    #define MDL_MAPPING_CAN_FAIL        0x2000
    #define MDL_ALLOCATED_MUST_SUCCEED  0x4000
    #define MDL_64_BIT_VA               0x8000

    #define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )
#endif

/*============================================================================
 *
 * Error values that may be returned by the miniport
 *
 *==========================================================================*/

#define DX_OK                                   0x0
#define DXERR_UNSUPPORTED                       0x80004001
#define DXERR_GENERIC                           0x80004005
#define DXERR_OUTOFCAPS                         0x88760168

/*============================================================================
 *
 * Structures maintained by DirectDraw
 *
 *==========================================================================*/

#define DDOVER_AUTOFLIP                       	0x00100000l
#define DDOVER_BOB                       	0x00200000l
#define DDOVER_OVERRIDEBOBWEAVE			0x00400000l
#define DDOVER_INTERLEAVED			0x00800000l

//
// Data for every DXAPI surface
//

typedef struct _DDSURFACEDATA {
    DWORD       ddsCaps;                // Ring 3 creation caps
    DWORD       dwSurfaceOffset;        // Offset in frame buffer of surface
    ULONG_PTR    fpLockPtr;              // Surface lock ptr
    DWORD       dwWidth;                // Surface width
    DWORD       dwHeight;               // Surface height
    LONG        lPitch;                 // Surface pitch
    DWORD       dwOverlayFlags;         // DDOVER_XX flags
    DWORD       dwOverlayOffset;        // Offset in frame buffer of overlay
    DWORD       dwOverlaySrcWidth;	// Src width of overlay
    DWORD       dwOverlaySrcHeight;	// Src height of overlay
    DWORD       dwOverlayDestWidth;	// Dest width of overlay
    DWORD       dwOverlayDestHeight;	// Dest height of overlay
    DWORD	dwVideoPortId;		// ID of video port (-1 if not connected to a video port)
    DWORD       dwFormatFlags;
    DWORD       dwFormatFourCC;
    DWORD       dwFormatBitCount;
    DWORD       dwRBitMask;
    DWORD       dwGBitMask;
    DWORD       dwBBitMask;
    ULONG       dwDriverReserved1;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved2;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved3;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved4;      // Reserved for the HAL/Miniport
} DDSURFACEDATA, *LPDDSURFACEDATA;

//
// Data for every DXAPI video port
//

typedef struct DDVIDEOPORTDATA {
    DWORD       dwVideoPortId;          // ID of video port (0 - MaxVideoPorts-1)
    DWORD       dwVPFlags;              // Video port DDVP_ option flags
    DWORD       dwOriginOffset;         // Start address relative to surface
    DWORD       dwHeight;               // Height of total video region (per field)
    DWORD       dwVBIHeight;            // Height of VBI region (per field)
    ULONG       dwDriverReserved1;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved2;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved3;      // Reserved for the HAL/Miniport
} DDVIDEOPORTDATA, *LPDDVIDEOPORTDATA;


/*============================================================================
 *
 * Structures used to communicate with the Miniport
 *
 *==========================================================================*/

typedef struct _DX_IRQDATA {
    DWORD       dwIrqFlags;             // DDIRQ_ flags ORed in by miniport
} DX_IRQDATA, *PDX_IRQDATA;

typedef VOID (*PDX_IRQCALLBACK)(PDX_IRQDATA pIrqData);

#define DDIRQ_DISPLAY_VSYNC			0x00000001l
#define DDIRQ_BUSMASTER                         0x00000002l
#define DDIRQ_VPORT0_VSYNC			0x00000004l
#define DDIRQ_VPORT0_LINE			0x00000008l
#define DDIRQ_VPORT1_VSYNC			0x00000010l
#define DDIRQ_VPORT1_LINE			0x00000020l
#define DDIRQ_VPORT2_VSYNC			0x00000040l
#define DDIRQ_VPORT2_LINE			0x00000080l
#define DDIRQ_VPORT3_VSYNC			0x00000100l
#define DDIRQ_VPORT3_LINE			0x00000200l
#define DDIRQ_VPORT4_VSYNC			0x00000400l
#define DDIRQ_VPORT4_LINE			0x00000800l
#define DDIRQ_VPORT5_VSYNC			0x00001000l
#define DDIRQ_VPORT5_LINE			0x00002000l
#define DDIRQ_VPORT6_VSYNC			0x00004000l
#define DDIRQ_VPORT6_LINE			0x00008000l
#define DDIRQ_VPORT7_VSYNC			0x00010000l
#define DDIRQ_VPORT7_LINE			0x00020000l
#define DDIRQ_VPORT8_VSYNC			0x00040000l
#define DDIRQ_VPORT8_LINE			0x00080000l
#define DDIRQ_VPORT9_VSYNC			0x00010000l
#define DDIRQ_VPORT9_LINE			0x00020000l

// output from DxGetIrqInfo
typedef struct _DDGETIRQINFO {
    DWORD	dwFlags;
} DDGETIRQINFO, *PDDGETIRQINFO;
#define IRQINFO_HANDLED		0x01	// Miniport is managing IRQ
#define IRQINFO_NOTHANDLED	0x02	// Not supported on NT

// input to DxEnableIrq
typedef struct _DDENABLEIRQINFO {
    DWORD           dwIRQSources;
    DWORD           dwLine;             // Line for DDIRQ_VPORTx_LINE interrupt
    PDX_IRQCALLBACK IRQCallback;	// Miniport calls this when IRQ happens
    PDX_IRQDATA     lpIRQData;          // Parameter to be passed to IRQCallback
} DDENABLEIRQINFO, *PDDENABLEIRQINFO;

// input to DxSkipNextField
typedef struct _DDSKIPNEXTFIELDINFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
    DWORD               dwSkipFlags;
} DDSKIPNEXTFIELDINFO, *PDDSKIPNEXTFIELDINFO;

#define DDSKIP_SKIPNEXT                 1
#define DDSKIP_ENABLENEXT               2

// intput to DxBobNextField
typedef struct _DDBOBNEXTFIELDINFO {
    LPDDSURFACEDATA     lpSurface;
} DDBOBNEXTFIELDINFO, *PDDBOBNEXTFIELDINFO;

// intput to DxSetState
typedef struct _DDSETSTATEININFO {
    LPDDSURFACEDATA     lpSurfaceData;
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDSETSTATEININFO, *PDDSETSTATEININFO;

// output from DxSetState
typedef struct _DDSETSTATEOUTINFO {
    BOOL                bSoftwareAutoflip;
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDSETSTATEOUTINFO, *PDDSETSTATEOUTINFO;

// input to DxLock
typedef struct _DDLOCKININFO {
    LPDDSURFACEDATA     lpSurfaceData;
} DDLOCKININFO, *PDDLOCKININFO;

// output from DxLock
typedef struct _DDLOCKOUTINFO {
    ULONG_PTR            dwSurfacePtr;
} DDLOCKOUTINFO, *PDDLOCKOUTINFO;

// input to DxFlipOverlay
typedef struct _DDFLIPOVERLAYINFO {
    LPDDSURFACEDATA     lpCurrentSurface;
    LPDDSURFACEDATA     lpTargetSurface;
    DWORD               dwFlags;
} DDFLIPOVERLAYINFO, *PDDFLIPOVERLAYINFO;

// intput to DxFlipVideoPort
typedef struct _DDFLIPVIDEOPORTINFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
    LPDDSURFACEDATA     lpCurrentSurface;
    LPDDSURFACEDATA     lpTargetSurface;
    DWORD               dwFlipVPFlags;
} DDFLIPVIDEOPORTINFO, *PDDFLIPVIDEOPORTINFO;

#define DDVPFLIP_VIDEO                  0x00000001l
#define DDVPFLIP_VBI                    0x00000002l

// input to DxGetPolarity
typedef struct _DDGETPOLARITYININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETPOLARITYININFO, *PDDGETPOLARITYININFO;

// output from DxGetPolarity
typedef struct _DDGETPOLARITYOUTINFO {
    DWORD               bPolarity;
} DDGETPOLARITYOUTINFO, *PDDGETPOLARITYOUTINFO;

// input to DxGetCurrentAutoflipSurface
typedef struct _DDGETCURRENTAUTOFLIPININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETCURRENTAUTOFLIPININFO, *PDDGETCURRENTAUTOFLIPININFO;

// output from DxGetCurrentAutoflipSurface
typedef struct _DDGETCURRENTAUTOFLIPOUTINFO {
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDGETCURRENTAUTOFLIPOUTINFO, *PDDGETCURRENTAUTOFLIPOUTINFO;

// input to DxGetPreviousAutoflipSurface
typedef struct _DDGETPREVIOUSAUTOFLIPININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETPREVIOUSAUTOFLIPININFO, *PDDGETPREVIOUSAUTOFLIPININFO;

// output from DxGetPreviousAutoflipSurface
typedef struct _DDGETPREVIOUSAUTOFLIPOUTINFO {
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDGETPREVIOUSAUTOFLIPOUTINFO, *PDDGETPREVIOUSAUTOFLIPOUTINFO;

// intput to DxTransfer
typedef struct _DDTRANSFERININFO {
    LPDDSURFACEDATA	lpSurfaceData;
    DWORD		dwStartLine;
    DWORD 		dwEndLine;
    ULONG_PTR   dwTransferID;
    DWORD 		dwTransferFlags;
    PMDL  		lpDestMDL;
} DDTRANSFERININFO, *PDDTRANSFERININFO;

#define DDTRANSFER_SYSTEMMEMORY		0x00000001
#define DDTRANSFER_NONLOCALVIDMEM	0x00000002
#define DDTRANSFER_INVERT		0x00000004
#define DDTRANSFER_CANCEL		0x00000080
#define DDTRANSFER_HALFLINES		0x00000100

// output from DxTransfer
typedef struct _DDTRANSFEROUTINFO {
    DWORD dwBufferPolarity;
} DDTRANSFEROUTINFO, *PDDTRANSFEROUTINFO;

// output from DxGetTransferStatus
typedef struct _DDGETTRANSFERSTATUSOUTINFO {
    DWORD_PTR dwTransferID;
} DDGETTRANSFERSTATUSOUTINFO, *PDDGETTRANSFEROUTINFO;

/*============================================================================
 *
 * DXAPI function prototypes
 *
 *==========================================================================*/

typedef DWORD (*PDX_GETIRQINFO)(PVOID,PVOID,PDDGETIRQINFO);
typedef DWORD (*PDX_ENABLEIRQ)(PVOID,PDDENABLEIRQINFO,PVOID);
typedef DWORD (*PDX_SKIPNEXTFIELD)(PVOID,PDDSKIPNEXTFIELDINFO,PVOID);
typedef DWORD (*PDX_BOBNEXTFIELD)(PVOID,PDDBOBNEXTFIELDINFO,PVOID);
typedef DWORD (*PDX_SETSTATE)(PVOID,PDDSETSTATEININFO,PDDSETSTATEOUTINFO);
typedef DWORD (*PDX_LOCK)(PVOID,PDDLOCKININFO,PDDLOCKOUTINFO);
typedef DWORD (*PDX_FLIPOVERLAY)(PVOID,PDDFLIPOVERLAYINFO,PVOID);
typedef DWORD (*PDX_FLIPVIDEOPORT)(PVOID,PDDFLIPVIDEOPORTINFO,PVOID);
typedef DWORD (*PDX_GETPOLARITY)(PVOID,PDDGETPOLARITYININFO,PDDGETPOLARITYOUTINFO);
typedef DWORD (*PDX_GETCURRENTAUTOFLIP)(PVOID,PDDGETCURRENTAUTOFLIPININFO,PDDGETCURRENTAUTOFLIPOUTINFO);
typedef DWORD (*PDX_GETPREVIOUSAUTOFLIP)(PVOID,PDDGETPREVIOUSAUTOFLIPININFO,PDDGETPREVIOUSAUTOFLIPOUTINFO);
typedef DWORD (*PDX_TRANSFER)(PVOID,PDDTRANSFERININFO,PDDTRANSFEROUTINFO);
typedef DWORD (*PDX_GETTRANSFERSTATUS)(PVOID,PVOID,PDDGETTRANSFEROUTINFO);

/*============================================================================
 *
 * HAL table filled in by the miniport and called by DirectDraw
 *
 *==========================================================================*/

#define DXAPI_HALVERSION 0x0001

typedef struct _DXAPI_INTERFACE {

    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PVOID                   InterfaceReference;
    PVOID                   InterfaceDereference;
    PDX_GETIRQINFO          DxGetIrqInfo;
    PDX_ENABLEIRQ           DxEnableIrq;
    PDX_SKIPNEXTFIELD       DxSkipNextField;
    PDX_BOBNEXTFIELD        DxBobNextField;
    PDX_SETSTATE            DxSetState;
    PDX_LOCK                DxLock;
    PDX_FLIPOVERLAY         DxFlipOverlay;
    PDX_FLIPVIDEOPORT       DxFlipVideoPort;
    PDX_GETPOLARITY         DxGetPolarity;
    PDX_GETCURRENTAUTOFLIP  DxGetCurrentAutoflip;
    PDX_GETPREVIOUSAUTOFLIP DxGetPreviousAutoflip;
    PDX_TRANSFER	    DxTransfer;
    PDX_GETTRANSFERSTATUS   DxGetTransferStatus;

} DXAPI_INTERFACE, *PDXAPI_INTERFACE;

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\compstui.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.h


Abstract:

    This module contains global header definition for the COMMON DRIVER UI


Author:

    19-Jun-1995 Mon 11:52:01 created  -by-  Daniel Chou (danielc)

    17-Aug-1995 Thu 14:59:28 updated  -by-  Daniel Chou (danielc)
        Updated for the first draft.

    23-Aug-1995 Wed 15:13:27 updated  -by-  Daniel Chou (danielc)
        Updated for second draft

    29-Aug-1995 Tue 11:33:24 updated  -by-  Daniel Chou (danielc)
        Adding ExtChkBox for some TVOT_xxx type

    31-Aug-1995 Thu 04:04:23 updated  -by-  Daniel Chou (danielc)
        Making UNICODE type

    01-Sep-1995 Fri 17:29:18 updated  -by-  Daniel Chou (danielc)
        Change the API interface type, so that it can be dynamically called
        and generate the property pages to be merge with the shell

    05-Sep-1995 Tue 11:52:43 updated  -by-  Daniel Chou (danielc)
        Rename to compspui.h and update the API entry structure

    07-Sep-1995 Thu 14:46:55 updated  -by-  Daniel Chou (danielc)
        rename to compstui.h and update comments

    07-Sep-1995 Thu 16:07:31 updated  -by-  Daniel Chou (danielc)
        Adding UNION type for pSel/Sel, pOldSel/OldSel

    08-Sep-1995 Fri 09:23:38 updated  -by-  Daniel Chou (danielc)
        Remove TypeIdx from OPTITEM and use pOptType, and remove all
        pOptType passed in the CPSUICBPARAM and COMPROPSHEETUI structures

    25-Sep-1995 Mon 19:39:45 updated  -by-  Daniel Chou (danielc)
        add other related stuff.

    26-Sep-1995 Tue 11:02:26 updated  -by-  Daniel Chou (danielc)
        Add error codes for GETLASTERROR

    27-Sep-1995 Wed 16:32:37 updated  -by-  Daniel Chou (danielc)
        Move hWndParent, pTitle, hInst and TitleIconID out from
        COMPROPSHEETUI to COMPROPSHEETUIHEADER.

    28-Sep-1995 Thu 17:06:46 updated  -by-  Daniel Chou (danielc)
        Add hInstCaller to COMPROPSHEETUI and add _COMPSTUI_ and cplusplus
        stuff

    28-Sep-1995 Thu 23:16:34 updated  -by-  Daniel Chou (danielc)
        change tick count for trackbar/scrollbar to multiply factor. and
        add the push button flag which can overwrite the update permission so
        it can let user view the current setting from push button's dialog
        display

    07-Feb-1996 Wed 17:45:31 updated  -by-  Daniel Chou (danielc)
        Change the API CommonPropSheetUI to CommonPropertySheetUI so that it
        not using stack but message base, this way any caller can add/delete
        pages as they want without worry about how many pages been added from
        its children.


[Environment:]

    NT Windows - Common Property Sheet UI DLL.


[Notes:]


Revision History:


--*/

#ifndef _COMPSTUI_
#define _COMPSTUI_

#ifdef __cplusplus
extern "C" {
#endif


#if (!defined(RC_INVOKED))


//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif

//
// Predefined ID for the TreeView Option Type
//
//


#define TVOT_2STATES        0
#define TVOT_3STATES        1
#define TVOT_UDARROW        2
#define TVOT_TRACKBAR       3
#define TVOT_SCROLLBAR      4
#define TVOT_LISTBOX        5
#define TVOT_COMBOBOX       6
#define TVOT_EDITBOX        7
#define TVOT_PUSHBUTTON     8
#define TVOT_CHKBOX         9
#define TVOT_LAST           TVOT_CHKBOX
#define TVOT_NONE           (TVOT_LAST + 1)

//
// Predefined ID for the TreeView Option Type
//
//
// TVOT_2STATES:
//      Count       = 2
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//
//      BegCtrlID  = 2 States Group Box ID
//      BegCtrlID+1= 2 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_3STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//
// TVOT_3STATES:
//      Count       = 3
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//      pOptParam[2]=pointer to the State 3 OPTPARAM
//
//      BegCtrlID  = 3 States Group Box ID
//      BegCtrlID+1= 3 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= state 3 Radio button ID
//      BegCtrlID+7= state 3 icon control ID
//      BegCtrlID+8= Extended Check Box/Push Button control ID
//      BegCtrlID+9= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_2STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//  ** For TVOT_2STATES, TVOT_3STSATES the 'Sel' field in the OPTITEM has
//     following definitions
//
//      State 1, Sel = 0
//      State 2, Sel = 1
//      State 3, Sel = 2
//
//      for any selection which based on false/true, no/yes, off/ontrue/false,
//      none/select then state 1 (sel=0) must always be the NO, FALSE, OFF or
//      NONE type.
//
//
// TVOT_UDARROW:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = (SHORT)Low range of the up-down control
//                      lParam = (SHORT)High range of the up-down control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//          if pData pointed to no help text then common UI automatically
//          set the (# - #) as help line
//
//      BegCtrlID  = udarrow Group Box ID
//      BegCtrlID+1= udarrow title static title ID
//      BegCtrlID+2= udarrow's editbox ID
//      BegCtrlID+3= udarrow icon control ID
//      BegCtrlID+4= udarrow postfix static text ID
//      BegCtrlID+5= udarrow help static text ID
//      BegCtrlID+6= udarrow arrow ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_TRACKBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the trackbar control
//                      lParam = (SHORT)High range of the trackbar control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//      BegCtrlID  = trackbar Group Box ID
//      BegCtrlID+1= trackbar static title ID
//      BegCtrlID+2= trackbar(horizontal) ID (static FRAME to define size)
//      BegCtrlID+3= trackbar icon control ID
//      BegCtrlID+4= trackbar low range text control ID
//      BegCtrlID+5= trackbar high range text control ID
//      BegCtrlID+6= trackbar postfix ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * the tick frequency is automatically to set to PageSize increment
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_SCROLLBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the scrollbar control
//                      lParam = (SHORT)High range of the scroll control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//
//      BegCtrlID  = scrollbar(horizontal) group box ID
//      BegCtrlID+1= scrollbar(horizontal) static text ID
//      BegCtrlID+2= scrollbar(horizontal) ID
//      BegCtrlID+3= scrollbar icon control ID
//      BegCtrlID+4= scrollbar low range text control ID
//      BegCtrlID+5= scrollbar high range text control ID
//      BegCtrlID+6= scrollbar postfix control ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * Style field in the OPTPARAM is ignored
//
//
//
// TVOT_LISTBOX:
// TVOT_COMBOBOX:
//      Count       = N
//      pOptParam[0]=pointer to the first OPTPARAM (pData=string pointer)
//      pOptParam[1]=pointer to the second OPTPARAM (pData=string pointer)
//          .
//          .
//      pOptParam[N-1]=pointer to the N item string
//
//      BegCtrlID  = Listbox/ComboBox group box ID
//      BegCtrlID+1= Listbox/ComboBox static title ID
//      BegCtrlID+2= Listbox/Combobox ID
//      BegCtrlID+3= Listbox/Combobox icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, the field used as
//
//          Style =Ignored by the common UI
//          pData =Pointer to the name of item
//          IconID=Icon resource ID for the item
//          lParam=ignored by the common UI
//
//      * Only SINGLE selection is supported, to do a multiple selction use
//        multiple OPTITEM and create a header for it
//
//      * an OTLBCBS_SORT style can be specified in the OPTTYPE's LBCBStyle
//        field, and the listbox or combobox will be sorted according to the
//        item's string.
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, when it get received the keyboard
//        focus then common UI will call callback function (only if
//        OPTIF_CALLBACK bit set) with reason of CPSUICB_REASON_LBCB_ACTIVE,
//        this give caller a chance to modify following structure flags/pdata
//        which associate with the current OPTITEM.   The caller's callback
//        function can ONLY modify the flags/data specified here.
//
//          OPTTYPE pointed by the pOptType from OPTITEM
//
//              Style: OTS_LBCB_SORT
//                     OTS_LBCB_INCL_ITEM_NONE
//
//          OPTPARAMs pointed by the pOptParam from the OPTTYPE
//
//              Flags: OPTPF_HIDE
//                     OPTPF_DISABLED
//
//              pData: change string name
//
//
//      * The TVOT_COMBOBOX typically only used in the tree-view if there is
//        only one selection available for that item, when there is only one
//        item then dropdown list will not enabled by the common UI
//
//
//
// TVOT_EDITBOX:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = Edit buffer sie in character pointed by pSel
//                                 this is including the NULL terminator.
//                      lParam = ignored.
//
//      BegCtrlID  = editBox group Box ID
//      BegCtrlID+1= editBox static title ID
//      BegCtrlID+2= editbox ID
//      BegCtrlID+3= editbox icon control ID
//      BegCtrlID+4= editbox postfix ID
//      BegCtrlID+5= editbox help ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//      * Style field is ignored
//
//      * pSel in the OPTITEM is the pointer to the editing string, the pSel
//        must pointed to a buffer eqaul or larger than the count of the buffer
//        (pOptParam[1]->IconID) size
//
//
// TVOT_PUSHBUTTON:
//      Count       = 1
//
//      BegCtrlID  = push button group box ID
//      BegCtrlID+1= push button static text ID (Not used by common UI)
//      BegCtrlID+2= push button ID
//      BegCtrlID+3= push button icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//      PUSHBUTTON_TYPE_xxx specified the action and content of pData in the
//      pOptParam[0] as describe in the following
//
//          PUSHBUTTON_TYPE_DLGPROC
//
//              This push button is designed to bring up caller's dialog box
//
//                  pOptParam[0].pData  = Caller's DLGPROC
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_DLGPROC
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Caller's DIALOG resource template ID
//                                        or handle to the DLGTEMPLATE depends
//                                        on the OPTPF_USE_HDLGTEMPLATE flag
//
//
//              The 'lParam' passed to the DLGPROC's WM_INITDIALOG is the
//              CPSUICBPARAM structure pointer, and the reason field is set
//              to CPSUICB_REASON_DLGPROC.
//
//
//          PUSHBUTTON_TYPE_CALLBACK
//
//              This push button is designed to have caller process the item
//              which cannot accomplished with the dialog box along.
//
//                  pOptParam[0].pData  = CPSUICALLBACK function pointer
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_CALLBACK
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//              Durning the callback the Reason field in CPSUICBPARAM will
//              set to CPSUICB_REASON_PUSHBUTTON.
//
//              ** If pOptParam[0].pData callback function is NULL then common
//                 UI will call the pfnCallBack pointer set in the
//                 COMPROPSHEETUI structure if it is not NULL
//
//              ** The callback function should put the result of the callback
//                 in the pSel/Sel of OPTITEM associate with the push button
//
//          PUSHBUTTON_TYPE_HTCLRADJ
//
//              This push button is designed to bring up halftone color
//              adjustment dialog box.
//
//                  pOptParam[0].pData  = pointer to COLORADJUSTMENT structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTCLRADJ
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam =  Not Used;
//
//
//          PUSHBUTTON_TYPE_HTSETUP
//
//              This push button is designed to bring up device halftone
//              setup dialog box.
//
//                  pOptParam[0].pData  = pointer to DEVHTADJDATA structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTSETUP
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//
//      * 'Sel' field in the OPTITEM for the PUSHBUTTON is the last returned
//        LONG result from the called dialog box or funcitons.  The result
//        only valid if OPTIF_CHANGEONCE flag is set.  The common UI will set
//        OPTIF_CHANGEONCE if push button ever pushed.
//
//      * Since common UI donot know the meaning of the return value and
//        content of the called parameter, it is up to the caller to use
//        callback function to determine the returned result.
//
//      * When returned from the push button except push botton type
//        PUSHBUTTON_TYPE_CALLBACK common ui will call the callback function
//        if the OPTIF_CALLBACK flat is set.  The callback reason is set to
//        CPSUICB_REASON_SEL_CHANGED.
//
//      * If the passed in CPSUIF_UPDATE_PERMISSION Flags in the COMPROPSHEETUI
//        is clear then the callback function must ONLY display the dialog box
//        and not changed any OPTITEM data if OTS_PUSH_ENABLE_ALWAYS
//        flag is set in the OPTTYPE
//
//
// TVOT_CHKBOX:
//      Count               = 1
//
//      pOptparam[0].Style  = CHKBOXS_FALSE_TRUE    False/True
//                            CHKBOXS_NO_YES,       No/YES
//                            CHKBOXS_OFF_ON,       Off/ON
//                            CHKBOXS_FALSEPDATA    False/pData
//                            CHKBOXS_NO_PDATA      No/pData
//                            CHKBOXS_OFF_PDATA     Off/pData
//                            CHKBOXS_NONE_PDATA    None/pData
//      pOptParam[0].pData  = Only used if Style is CHKBOXS_NONE_PDATA
//      pOptParam[0].IconID = Icon resource ID
//      pOptParam[0].lParam = Ignored
//
//
//      BegCtrlID  = check box group ID
//      BegCtrlID+1= Check Box static text (not used by common UI)
//      BegCtrlID+2= check box button ID
//      BegCtrlID+3= check box icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//  * BegCtrlID only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//    which has non-common UI dialog box template (DlgTemplateID in the DLGPAGE
//    is not standard DP_STD_xxx common ui dialog box template).    The common
//    UI used this ID to managed caller's dialog boxes item's selections and
//    initialization.
//
//  * for each item, it has group box ID (BegCtrlID) and static text ctronl ID
//    (BegCtrlID + 1).  The common UI will set the text in one of these two
//    control ID in followng seauence.
//
//      1) If group box control ID's window (BegCtrlID) is exist and the
//         OPTITEM's flag OPTIF_NO_GROUPBOX_NAME is not set then common UI will
//         set the pName from OPTITEM to the group box.
//
//      2) If the group box name is not set and static control ID's window
//         (BegCtrlID + 1) is exist then common UI will set the pName from
//         OPTITEM to the static text control.
//
//  * for TVOT_TRACKBAR and TVOT_SCROLLBAR, if pName in the OPTITEM is set to
//    either group box or static text control then common UI will also append
//    the current selection position of trackbar or scroll bar to the pName.
//
//  * If multiple OPTITEMs using the same POPTPARAM and need different
//    BegCtrlID for each control then then a separate OPTTYPE structure should
//    be generated but POPTPARAM pointed to the same OPTPARAM[]
//
//  * If a BegCtrlID+N is not used then skip that ID in your dialog box
//    template
//
//

#define CHKBOXS_FALSE_TRUE          0
#define CHKBOXS_NO_YES              1
#define CHKBOXS_OFF_ON              2
#define CHKBOXS_FALSE_PDATA         3
#define CHKBOXS_NO_PDATA            4
#define CHKBOXS_OFF_PDATA           5
#define CHKBOXS_NONE_PDATA          6


#define PUSHBUTTON_TYPE_DLGPROC     0
#define PUSHBUTTON_TYPE_CALLBACK    1
#define PUSHBUTTON_TYPE_HTCLRADJ    2
#define PUSHBUTTON_TYPE_HTSETUP     3


#define MAX_RES_STR_CHARS           160

//
// Common Printer UI's LPTSTR
//
// All string pointer in common printer UI structures can be either a real
// memory pointer or a string resource ID.  These are applied to LPTSTR type.
//
// The LPTSTR is defined to identify that the pointer can be a real string
// pointer or a resource ID (either common printer UI provided ID or caller's
// own resource ID).  common UI using following logic to get the final string.
//
//  LPTSTR  pData;
//
//      if ((pData & ~(ULONG_PTR)0xFFFF) != 0) then pData is a NULL terminated
//      string pointer
//
//          ELSE
//
//          (pData & (ULONG_PTR)0xFFFF) = Resource ID
//
//          if (Resource ID is within the common UI string resource ID range)
//          then it load the string from common UI DLL
//
//          ELSE
//
//              it load string from caller's resource
//
//
//  *  You can use MAKEINTRESOURCE(StrResID) to set this field
//
//  * The MAX characters loaded by the common UI from the resource is defined
//    as MAX_RES_STR_CHARS
//
//  * You cannot use LPTSTR as resource ID for the TVOT_EDITBOX style's
//    pSel in the OPTITEM, this pointer must be a real buffer pointer
//
//
//
// ICONs
//
//  Common UI using two types of Icons, One is 32x32 and the other is 16x16
//  plus if any monochrome icon with 32x32 and 16x16 sizes.
//
//  The 16x16 icon when displayed on the screen is using 16x17 pixel space,
//  this is ensure that downware adjacent icon is not crowded together.
//
//  In common UI, if you need to passed a ICON ID, it can either passed a
//  common UI's predefined ID or caller's own ICON resource ID.
//
//
//  * You can use to imagedit or any other Window icon editor to create the
//    icon, each icon file should have one unique icon resource ID which is
//    not overlay with the standard common UI IDI_CPSUI_xxx identifier.  For
//    each icon file, its should have both 32x32 and 16x16 size icon on
//    different display. (ie. monochrome).
//
//    Common UI will try to load the correct size of icon from the icon
//    resource, but it will stretch them if the size is not found.
//
//

//
// Flags for the OPTTYPE
//
//

#define OPTPF_HIDE                  0x01
#define OPTPF_DISABLED              0x02
#define OPTPF_ICONID_AS_HICON       0x04
#define OPTPF_OVERLAY_WARNING_ICON  0x08
#define OPTPF_OVERLAY_STOP_ICON     0x10
#define OPTPF_OVERLAY_NO_ICON       0x20
#define OPTPF_USE_HDLGTEMPLATE      0x40

typedef struct _OPTPARAM {
    WORD        cbSize;         // size of this structure
    BYTE        Flags;          // OPTPF_xxxx flags
    BYTE        Style;          // style use in this structure
    LPTSTR      pData;          // pointer to the data
    ULONG_PTR   IconID;         // iconID;
    LPARAM      lParam;         // parameter used
    ULONG_PTR   dwReserved[2];  // reserved dword, must be 0
    } OPTPARAM, *POPTPARAM;


//
// OPTPARAM
//
//  The OPTPARAM structure is used to describe each slectable item in the
//  common UI such as 'letter', 'legal' in the form slection list box
//
//  cbSize      - size of this structure
//
//  Flags       - defined as OPTPF_xxxx
//
//                  OPTPF_HIDE
//
//                      Specified hide this listed selection item and not
//                      availabe for user to select. This only available to
//                      following TVOT_xxx types
//
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//                      If all the seclection items are OPTPF_HIDE then the
//                      OPTITEM is automatically hided by the common UI, if
//                      TVOT_3STATES has 2 states hide then an error is
//                      returned
//
//
//                  OPTPF_DISABLED
//
//                      Specified this listed selection item is disabled and
//                      not availabe for user to select.   This only available
//                      to following TVOT_xxx types
//
//                          TVOT_2STATES
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//
//                  OPTPF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  OPTPF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  OPTPF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  OPTPF_OVERLAY_NO_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  Style       - Style for the OPTPARAM, it depends on the TVOT_xxx type as
//                describe below
//
//                  TVOT_PUSBUTTON
//
//                      it can be one of PUSHBUTTON_TYPE_xxxx.
//
//                  other TVOT_xxxx
//
//                      this fields is not used.
//
//
//  pData       - Is either a pointer to the item name (string) or it is
//                used to describe other data.
//
//                   * If the pData in the OPTPARAM is supposed to be a static
//                     pointer to a string and the string is a common UI
//                     standard resource ID then common UI will check if pData
//                     is equal to IDS_CPSUI_NOTINSTALLED, if true then
//                     common UI will overaly a not installed icon on top of
//                     the OPTPARAM's Icon.   This will not applied to the
//                     TVOT_EDITBOX type since the pData is not a static text
//                     pointer or a string resource ID.
//
//                  ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if OPTPF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  lParam      - Extra data used by the OPTPARAM, it depends on the TVOT_xxx
//                type.
//
//  dwReserved[]- Reserved DWORDs, must be 0
//
//


#define OPTTF_TYPE_DISABLED             0x01
#define OPTTF_NOSPACE_BEFORE_POSTFIX    0x02


#define OTS_LBCB_SORT                   0x0001
#define OTS_LBCB_PROPPAGE_LBUSECB       0x0002
#define OTS_LBCB_PROPPAGE_CBUSELB       0x0004
#define OTS_LBCB_INCL_ITEM_NONE         0x0008
#define OTS_LBCB_NO_ICON16_IN_ITEM      0x0010
#define OTS_PUSH_INCL_SETUP_TITLE       0x0020
#define OTS_PUSH_NO_DOT_DOT_DOT         0x0040
#define OTS_PUSH_ENABLE_ALWAYS          0x0080


typedef struct _OPTTYPE {
    WORD        cbSize;
    BYTE        Type;           // TVOT_xxxx type of OPTIONS
    BYTE        Flags;          // OPTTF_xxx flags
    WORD        Count;          // Count of pOptParam passed
    WORD        BegCtrlID;      // start of item's group window ID
    POPTPARAM   pOptParam;      // pointer to the OPTPARAM
    WORD        Style;          // option type style as OTS_xxxx
    WORD        wReserved[3];   // wReserved, must be 0
    ULONG_PTR   dwReserved[3];  // DWORD reserved field (must be 0)
} OPTTYPE, *POPTTYPE;


//
// OPTTYPE
//
//  The OPTTYPE structure is used to describe a set of selection and its
//  select method,  such as Form/Tray assignment.  It has a pointer to a set
//  of selection item (OPTPARAM)
//
//
//  cbSize      - size of this structure
//
//  Type        - Specified the option type using predefined ID as TVOT_xxxx
//
//  Flags       - currently only one flag is defined
//
//
//                  OPTTF_TYPE_DISABLED
//
//                      The whole OPTTYPE's OPTPARAMs are disabled, and non of
//                      the selection in the OPTTYPE can be selected
//
//
//                  OPTTF_NOSPACE_BEFORE_POSTFIX
//
//                      This bit only valid if the OPTTYPE's pOptParam item
//                      specified a postfix string as describe in the above
//                      section.  If this flag is set then it asked common UI
//                      do not add a space character before the postfix string
//                      when it combine the pName in the OPTITEM and postfix
//                      string.   Typeically this bit is not set for the
//                      postfix string, but sometime it may be required not to
//                      add a space character in front of it, such as '%'
//                      postfix string.
//
//
//  Count       - Count of item pointed by pOptParam.  Some predefined number
//                must be set according to the TVOT_XXX description.
//
//  BegCtrlID   - Only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//                which has non-common UI dialog box template (DlgTemplateID
//                in the DLGPAGE is not standard DP_STD_xxx common ui dialog
//                box template).    The common UI used this ID to managed
//                caller's dialog boxes item's selections and initialization.
//
//                Each OPTITEM has predefined number of window ID which
//                associated with that item, the BegCtrlID specified the start
//                control window ID.  Each control window ID in the OPTITEM
//                must have the control ID sequence as describe in the TVOT_xxx
//                above.
//
//  pOptParam   - Pointer to array of OPTPARAM to describe each selectable item
//
//  Style       - Specified the style of type of control box, certain style
//                only apply to centain type of TVOT_xxxx.
//
//                OTS_LBCB_xxx only applied to TVOT_LISTBOX, TVOT_COMBOBOX
//                OTS_PUSH_xxx only applied to TVOT_PUSHBUTTON
//
//
//                  OTS_LBCB_SORT
//
//                      Specified that the listbox or combobox item is sorted
//                      in ascending order based on the pData string
//
//
//                  OTS_LBCB_PROPAGE_LBUSECB
//
//                      Used when Type is TVOT_LISTBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is comobobox instead of listbox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_PROPAGE_CBUSELB
//
//                      Used when Type is TVOT_COMBOBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is listbox instead of combobox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_INCL_ITEM_NONE
//
//                      when this flag is specified, the common ui will
//                      automatically add a 'None' selection to the listbox or
//                      combobox.   The 'Sel' will set to -1 if 'none' is
//                      selection is selected by the user.  It will also
//                      validate the 'Sel' durning the initialization,  any
//                      out of range value will be set to -1 (None).
//
//
//                  OTS_LBCB_NO_ICON16_IN_ITEM
//
//                      By default, each listbox, combox will have a small
//                      icon (16x16) in front of item text. by specified this
//                      bit, the listbox/combobox will not includes icons
//                      in the listbox/combobox.
//
//                      If clear then it specified that in the listbox/combobox
//                      to have 16x16 Icon added to the front of each item
//
//
//                  OTS_PUSH_INCL_SETUP_TITLE
//
//                      If specified for the push button then it automatically
//                      add the 'Setup' to the end of push botton text.
//
//
//                  OTS_PUSH_NO_DOT_DOT_DOT
//
//                      If specified then common UI will not add '...' to the
//                      end of the pName in the OPTITEM and push button name
//
//
//                  OTS_PUSH_ENABLE_ALWAYS
//
//                      This flag specified that even update permissio is not
//                      allowed, it still let user push the push button, if
//                      this flag is set then callback function or dialog box
//                      proc must disable all the control which let user
//                      modified the content, but just let user view the
//                      current setting.
//
//
//  wReserved[] - Reserved fields, must be 0
//
//  dwReserved[]- Reserved fields, must be 0
//
//


//
// Following are flags for the EXTPUSH
//


#define EPF_PUSH_TYPE_DLGPROC       0x0001
#define EPF_INCL_SETUP_TITLE        0x0002
#define EPF_NO_DOT_DOT_DOT          0x0004
#define EPF_ICONID_AS_HICON         0x0008
#define EPF_OVERLAY_WARNING_ICON    0x0010
#define EPF_OVERLAY_STOP_ICON       0x0020
#define EPF_OVERLAY_NO_ICON         0x0040
#define EPF_USE_HDLGTEMPLATE        0x0080


typedef struct _EXTPUSH {
    WORD                cbSize;         // size of the structure
    WORD                Flags;          // EPCBF_xxx flags
    LPTSTR              pTitle;         // extended push botton title
    union {
        DLGPROC         DlgProc;        // pointer to the dialog box proc
        FARPROC         pfnCallBack;    // callback function pointer
        } DUMMYUNIONNAME;
    ULONG_PTR           IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;          // dialog box template ID
        HANDLE  hDlgTemplate;           // handle to the dialog template
        } DUMMYUNIONNAME;
    ULONG_PTR   dwReserved[3];          // reserved field, must be 0
    } EXTPUSH, *PEXTPUSH;

//
// EXTPUSH structure is used to describe the extened push button available
// on OPTITEM/OPTITEM, each OPTTYPE can optional have either one extended check
// box or one extended push button callback.
//
//
//  cbSize          - size of this structure
//
//  Flags           - flags for the EXTPUSH as EPF_xxxx
//
//                      EPF_PUSH_TYPE_DLGPROC
//
//                          If this bit is set then it specified the extended
//                          push button is type of DLGPROC and DlgProc and
//                          DlgTemplateID is valid for common UI to call.
//
//                          If this bit is clear then it specfied the extended
//                          push button is the callback style and pfnCallBack
//                          should be called by the common UI
//
//
//                      EPF_INCL_SETUP_TITLE
//
//                          If specified for the extended push button then it
//                          automatically add the 'Setup' to the end of
//                          extended push button's title
//
//
//                      EPF_NO_DOT_DOT_DOT
//
//                          If specified then common UI will not add '...' to
//                          the end of the pTitle in the EXTPUSH.
//
//
//                      EPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID.
//
//
//                      EPF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                      EPF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                      EPF_OVERLAY_NO_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle          - Pointed to extended push botton title
//
//                      ** See LPTSTR description above
//
//  DlgProc         - Pointer to the DLGPROC function supplied by the caller.
//                    When user push the button the common UI will call
//                    DialogBoxParam() with this fucction pointer and passed
//                    CPSUICBPARAM structure pointer to the WM_INITDIALOG with
//                    the Reason set to CPSUICB_REASON_EXTPUSH.  If this
//                    filed is NULL then common UI assumed that EXTPUSH is
//                    disabled (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE), this
//                    fields only used if EPF_PUSH_TYPE_DLGPROC flag is set
//
//  pfnCallBack     - Pointer to CPSUICALLBACK function, this only used if
//                    EPF_PUSH_TYPE_DLGPROC bit is clear, duringing callback
//                    it passed the CPSUICBPARAM pointer as parameter
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    EPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - Specified the ressource ID for the dilaog box. If the
//                    DlgTemplateID = 0 then common UI will call the DlgProc
//                    with following parameter.
//
//                      DlgProc(hDlg, WM_USER, NULL, (LPARAM)pCPSUICBPaam);
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//  wReserved[]     - WORD reserved field, must be 0
//
//  dwReserved[]    - DWORD reserved field, must be 0
//
//
//


//
// Following are flags for the EXTCHKBOX
//

#define ECBF_CHECKNAME_AT_FRONT         0x0001
#define ECBF_CHECKNAME_ONLY_ENABLED     0x0002
#define ECBF_ICONID_AS_HICON            0x0004
#define ECBF_OVERLAY_WARNING_ICON       0x0008
#define ECBF_OVERLAY_ECBICON_IF_CHECKED 0x0010
#define ECBF_OVERLAY_STOP_ICON          0x0020
#define ECBF_OVERLAY_NO_ICON            0x0040
#define ECBF_CHECKNAME_ONLY             0x0080


typedef struct _EXTCHKBOX {
    WORD        cbSize;         // size of the structure
    WORD        Flags;          // ECBF_xxx flags
    LPTSTR      pTitle;         // extended checkbox title
    LPTSTR      pSeparator;     // pointer to separator string for treeview
    LPTSTR      pCheckedName;   // string to be displayed when checked
    ULONG_PTR   IconID;         // icon to be used
    WORD        wReserved[4];   // reserved word, must be 0
    ULONG_PTR   dwReserved[2];  // reserved field, must be 0
    } EXTCHKBOX, *PEXTCHKBOX;


//
// EXTCHKBOX structure is used to describe the extened check box available on
// OPTITEM/OPTITEM, each OPTTYPE can optional have one extended check box.
// When using EXTCHKBOX the selection item can be checked or not checked
// based on user input.
//
//
//  cbSize      - size of this structure
//
//  Flags       - flags for the EXTCHKBOX as ECBF_xxxx
//
//                  ECBF_CHECKNAME_AT_FRONT
//
//                      This flag specified how to display item's name and its
//                      checked name in the treeview display.   If this flag is
//                      set then the checked name is display in front of
//                      separator name, otherwise the checked name is displayed
//                      after the separator.  For Example.
//
//                      Flag Set:   pCheckedName pSeparator SelectName
//                      Flag Clear: SelectName pSeparator pCheckedName
//
//
//                  ECBF_CHECKNAME_ONLY_ENABLED
//
//                      If set then it specified that in the treeview display,
//                      it will only show the pCheckedName if this extended
//                      check box is visible and enabled.  Some items may not
//                      desired to display the pCheckedName if the extended
//                      check box is disabled, such as Copy/Collate checkbox.
//
//
//                  ECBF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  ECBF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  ECBF_OVERLAY_ECBICON_IF_CHECKED
//
//                      This bit specified to overlay the ExtChkBox's Icon to
//                      the OPTITEM's icon (or OPTPARAM) if the the extended
//                      checked box is checked
//
//
//                  ECBF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  ECBF_OVERLAY_NO_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle      - Pointed to extended check box title
//
//                  ** See LPTSTR description above
//
//  pSeparator  - Pointer to the separator to be used in the treeview
//                display or the static title control in the non-treeview
//                page,
//
//  pCheckedName- Pointed to the name to be displayed in the treeview if item
//                is checked.  pCheckedName is added according to the
//                pSeparator and the ECBF_CHECKNAME_AT_FRONT flags.
//
//                  * If the pCheckedName is equal to IDS_CPSUI_NOTINSTALLED
//                    then common UI will automatically overaly a not installed
//                    icon on top of the extended check box Icon.
//
//                      ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if ECBF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  wReserved[] - WORD reserved field, must be 0
//
//  dwReserved[]- DWORD reserved field, must be 0
//


//
// Following the the Flags for the OPTITEM
//

#define OPTIF_COLLAPSE              0x00000001L
#define OPTIF_HIDE                  0x00000002L
#define OPTIF_CALLBACK              0x00000004L
#define OPTIF_CHANGED               0x00000008L
#define OPTIF_CHANGEONCE            0x00000010L
#define OPTIF_DISABLED              0x00000020L
#define OPTIF_ECB_CHECKED           0x00000040L
#define OPTIF_EXT_HIDE              0x00000080L
#define OPTIF_EXT_DISABLED          0x00000100L
#define OPTIF_SEL_AS_HICON          0x00000200L
#define OPTIF_EXT_IS_EXTPUSH        0x00000400L
#define OPTIF_NO_GROUPBOX_NAME      0x00000800L
#define OPTIF_OVERLAY_WARNING_ICON  0x00001000L
#define OPTIF_OVERLAY_STOP_ICON     0x00002000L
#define OPTIF_OVERLAY_NO_ICON       0x00004000L
#define OPTIF_INITIAL_TVITEM        0x00008000L
#define OPTIF_HAS_POIEXT            0x00010000L

#define OPTIF_MASK                  0x0001ffffL


#define DMPUB_NONE                  0
#define DMPUB_FIRST                 1

#define DMPUB_ORIENTATION           1
#define DMPUB_SCALE                 2
#define DMPUB_COPIES_COLLATE        3
#define DMPUB_DEFSOURCE             4
#define DMPUB_PRINTQUALITY          5
#define DMPUB_COLOR                 6
#define DMPUB_DUPLEX                7
#define DMPUB_TTOPTION              8
#define DMPUB_FORMNAME              9
#define DMPUB_ICMMETHOD             10
#define DMPUB_ICMINTENT             11
#define DMPUB_MEDIATYPE             12
#define DMPUB_DITHERTYPE            13
#define DMPUB_OUTPUTBIN             14
#define DMPUB_QUALITY               15
#define DMPUB_NUP                   16
#define DMPUB_PAGEORDER             17

#define DMPUB_LAST                  17

#define DMPUB_OEM_PAPER_ITEM        97
#define DMPUB_OEM_GRAPHIC_ITEM      98
#define DMPUB_OEM_ROOT_ITEM         99
#define DMPUB_USER                  100

#define MAKE_DMPUB_HIDEBIT(DMPub)   (DWORD)(((DWORD)0x01 << ((DMPub) - 1)))
#define IS_DMPUB_HIDDEN(dw, DMPub)  (BOOL)((DWORD)(dw) &                    \
                                           MAKE_DMPUB_HIDEBIT(DMPub))

//
// DMPUB_xxxx is used in OPTITEM to identify if the item is a DEVMODE public
// field. Following it identify which field correspond to the DMPUB_xxxx
//
//
//  DMPUB_ORIENTATION   - dmOrientation
//
//  DMPUB_SCALE         - dmScale
//
//  DMPUB_COPIES_COLLATE- dmCopies/dmCollate
//
//  DMPUB_DEFSOURCE     - dmDefSource    (Should only used form by caller)
//
//  DMPUB_PRINTQUALITY  - dmPrintQuality
//
//  DMPUB_COLOR         - dmColor
//
//  DMPUB_DUPLEX        - dmDuplex
//
//  DMPUB_TTOPTION      - dmTTOption
//
//  DMPUB_FORMNAME      - dmFormName
//
//  DMPUB_ICMMETHOD     - dmICMMethod
//
//  DMPUB_ICMINTENT     - dmICMIntent
//
//  DMPUB_MEDIATYPE     - dmMediaType
//
//  DMPUB_DITHERTYPE    - dmDitherType
//
//  DMPUB_USER          - Anything greater than or equal to DMPUB_USER can be
//                        used by the caller.
//
//  DMPUB_OUTPUTBIN     - Private
//
//  DMPUB_QUALITY       - Private
//
//  DMPUB_NUP           - Private
//
//  DMPUB_PAGEORDER     - Private
//
// When common UI is called for the 'Document Properties' (DEVMODE), it will
// group some of public items together simillar to the following in the
// treeview. How it group is common UI version dependent and caller should not
// concern its placement
//
//      Paper/Output                (Add in by the common UI)
//        Document Form             (DMPUB_FORMNAME)
//        Output Bin                (DMPUB_OUTPUTBIN)
//        Orientation               (DMPUB_ORIENTATION)
//        Source                    (DMPUB_DEFSOURCE)
//        Media                     (DMPUB_MEDIATYPE)
//        Number of Copies          (DMPUB_COPIES_COLLATE)
//        Page Order                (DMPUB_PAGEORDER)
//        Page Per Sheet            (DMPUB_NUP)
//        Duplex                    (DMPUB_DUPLEX)
//
//      Graphic                     (Add in by the common UI)
//        Print Quality             (DMPUB_PRINTQUALITY)
//        Quality Settings          (DMPUB_QUALITY)
//        Color                     (DMPUB_COLOR)
//          Image Color Matching    (Add in by the common UI)
//              ICM Method          (DMPUB_ICMMETHOD)
//              ICM Intent          (DMPUB_ICMINTENT)
//        Scaling                   (DMPUB_SCALE)
//        Dithering                 (DMPUB_DITHERTYPE)
//        TrueType Option           (DMPUB_TTOPTION)
//
//      Options
//        Halftone Color Adjustment...
//        ALL Other Caller's Document sticky options
//
//
//  For 'Document Properties' the standard page 1 (user friendly page) will
//  consist following items if it appear in the OPTITEM array passed by the
//  caller.   These items must have following predefined TVOT_xxx type
//  defined here and specified in the OPTTYPE's Type field.
//
//  All DMPUB_xxx (except >= DMPUB_USER) public ID must have following
//  TVOT_xxxx type specified, else a CPDU_INVALID_DMPUB_TVOT error is returned
//
//      DMPUB_ORIENTATION       - TVOT_2STATES/TVOT_3STATES
//      DMPUB_SCALE             - TVOT_UDARROW
//      DMPUB_COPIES_COLLATE    - TVOT_UDARROW + EXTCHKBOX (Collate)
//      DMPUB_DEFSOURCE         - TVOT_LISTBOX
//      DMPUB_PRINTQUALITY      - TVOT_LISTBOX
//      DMPUB_COLOR             - TVOT_2STATES
//      DMPUB_DUPLEX            - TVOT_2STATES/TVOT_3STATES
//      DMPUB_TTOPTION          - TVOT_LISTBOX
//      DMPUB_FORMNAME          - TVOT_LISTBOX
//      DMPUB_ICMMETHOD         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_ICMINTENT         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_MEDIATYPE         - TVOT_LISTBOX
//      DMPUB_DITHERTYPE        - TVOT_LISTBOX
//
//


#define OIEXTF_ANSI_STRING      0x0001

typedef struct _OIEXT {
    WORD        cbSize;
    WORD        Flags;
    HINSTANCE   hInstCaller;
    LPTSTR      pHelpFile;
    ULONG_PTR   dwReserved[4];
    } OIEXT, *POIEXT;

//
// OIEXT is a data structure used as extension to the OPTITEM data structure
//
//
//  cbSize      - sizeof this structure
//
//  Flags       - One or more of OIEXTF_xxxx may be specified.
//
//                  OIEXTF_ANSI_STRING
//
//                      Specified that LPTSTR in this data structure is a ansi
//                      string (not UNICODE).  This bit only checked if the
//                      LPTSTR is not the resource string ID
//
//  hInstCaller - DLL instance handle, when this hInst is not NULL then all
//                resource string and icon loading for this OPTITEM and its
//                OPTTYPE, OPTPARAM are loaded from this hInstCaller Handle.
//                If this filed is NULL then it will use the hInstCaller handle
//                specified in the COMPROPSHEETUI data structure
//
//  pHelpFile   - Resource string ID or pointer to the help file for this
//                OPTITEM.  If this pointer is NULL then help file for the
//                help index is assume specified in the pHelpFile field in the
//                COMPROPSHEETUI data structure.
//
//  dwReserved  - These fields are not used now, and must 0
//


typedef struct _OPTITEM {
    WORD        cbSize;                 // size of this structure
    BYTE        Level;                  // level in the tree view
    BYTE        DlgPageIdx;             // Index to the pDlgPage
    DWORD       Flags;                  // OPTIF_xxxx flags
    ULONG_PTR   UserData;               // caller's own data
    LPTSTR      pName;                  // name of the item
    union {
        LONG    Sel;                    // current selection (index)
        LPTSTR  pSel;                   // current selection (pStr)
        } DUMMYUNIONNAME;
    union {
        PEXTCHKBOX  pExtChkBox;         // Pointer to EXTCHKBOX structure
        PEXTPUSH    pExtPush;           // Pointer to EXTPUSH
        } DUMMYUNIONNAME2;
    POPTTYPE    pOptType;               // pointer to OPTTYPE structure
    DWORD       HelpIndex;              // Help file index
    BYTE        DMPubID;                // Devmode public filed ID
    BYTE        UserItemID;             // caller's own item ID
    WORD        wReserved;              // reserved WORD field, must be 0
    POIEXT      pOIExt;                 // Optitem extension pointer
    ULONG_PTR   dwReserved[3];          // reserved DWORD fields (must be 0)
    } OPTITEM, *POPTITEM;

//
// OPTITEM is to describe each treeview item's name, selection type and
// possible selection
//
//  cbSize          - sizeof this structure
//
//  Level           - The level in the treeview, the root should have lowest
//                    number and number should start with level 0.  the maximum
//                    number of levels are 256.
//
//  DlgPageIdx      - Zero-based index to the DLGPAGE araay pointee by
//                    pDlgPage. The Maximum index is MAX_DLGPPAGE_COUNT, if
//                    pDlgPage is a standard CPSUI_PDLGPAGE_xxxx then this
//                    field is automatically set the common UI
//
//  Flags           - OPTIF_xxxx flags as describe above
//
//                      OPTIF_COLLAPSE
//
//                          Collaspe treeview item and its children so it is
//                          not expanded initially.
//
//
//                      OPTIF_HIDE
//
//                          Hide this item from the treeview
//
//
//                      OPTIF_CALLBACK
//
//                          Callback to the caller when user making some
//                          changes a pointer (pfnCallBack) must provided and
//                          process as defined by the common UI.
//
//
//                      OPTIF_CHANGED
//
//                          This item was changed and need to re-display. this
//                          flag only used when caller returned from callback
//                          funciton.
//
//
//                      OPTIF_CHANGEONCE
//
//                          This item has been changed at least once.
//
//
//                      OPTIF_DISABLED
//
//                          Disable this item so it become not selectable.
//
//
//                      OPTIF_ECB_CHECKED
//
//                          Specified the associated extended check box is
//                          in checked state.
//
//
//                      OPTIF_EXT_HIDE
//
//                          Hide the extended check box/extended push botton.
//
//
//                      OPTIF_EXT_DISABLED
//
//                          The Extended check box/push botton is disabled and
//                          not selectable
//
//
//                      OPTIF_SEL_AS_HICON
//
//                          This flag only used if this item has no type,
//                          pOptType=NULL that is, when pOptType is NULL then
//                          'Sel' field is the IconID. if flag is set then it
//                          indicate 'pSel' is the Icon handle rather
//                          than the icon resource ID specified in Sel.
//
//
//                      OPTIF_EXT_IS_EXTPUSH
//
//                          Specified that pExtPush should be used when this
//                          pointer is not NULL, if this pointer is not NULL
//                          and this flag is clear then pExtChkBox is assumed.
//
//
//                      OPTIF_NO_GROUPBOX_NAME
//
//                          Specified that do not overwrite the group box title
//                          text, if group box ID is defined. See the TVOT_xx
//                          description above.
//
//
//                      OPTIF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's
//                          IDI_CPSUI_WARNING icon.  This bit only used if this
//                          item has no type, pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_STOP
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_NO_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_NO
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_INITIAL_TVITEM
//
//                          Specified that this item will be the initial item
//                          to be selected and display on the treeview page.
//                          If the selected item is currently a child or
//                          collapse then common UI will expand the selection
//                          then scroll it into view.
//
//                          If this flag is clear or the set item is in hide
//                          status common UI will pick the initial item to
//                          display.
//
//                      OPTIF_HAS_POIEXT
//
//                          Specified that pOIExt field is a valid pointer that
//                          points to OIEXT data structure.  The pOIExt only
//                          used by the common UI if this bit is set.
//
//
//  UserData        - a 32-bit number used by the caller and common UI will not
//                    modify it.
//
//  pName           - Pointer to the item's name, such as 'Upper Tray',
//                    'Memory' or it is used as data as describe in
//                    OPTPARAM/OPTTYPE structure
//
//                      ** See LPTSTR description above
//
//  pSel
//  Sel             - Current selection for this item. This is a union field
//                    which can be a pointer to a string or a LONG index
//                    selection.
//
//                      ** If pOptType field is NULL then 'Sel' is the icon ID
//                         to be used for the header.
//
//  pExtPush
//  pExtChkBox      - Pointer to either EXTPUSH or EXTCHKBOX data structure,
//                    if this pointer is NULL then this item does not have
//                    ectended check box/push botton associate with it.
//
//                    When an extended check box is associate with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH must not set, the
//                    OPTIF_ECB_CHECKED flag specified if the extended check
//                    box is checked or not checked.
//
//                    When an Extended push botton is associated with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH flag must set.
//
//                    The following flags are used in both EXTCHKBOX or
//                    EXTPUSH
//
//                      OPTIF_EXT_HIDE,
//                      OPTIF_EXT_DISABLED
//                      OPTIF_EXT_CHANGEONCE
//
//
//  pOptType        - Pointer to the OPTTYPE structure to describe the display
//                    and selections of the item.   If this pointer is NULL
//                    then this this item does not have any selection. and it
//                    is used as sub-items' header.
//
//                      * When pOptType is NULL then the 'Sel' is the Icon ID.
//
//
//  HelpIndex       - a index to the help file for context sensitive help
//                    if HelpInex=0 then there is no help for this item
//
//  DMPubID         - specified if this item is one of the public fields in the
//                    DEVMODE structure and supported by the common UI.
//
//                      DMPUB_NONE              - Not DEVMODE public fields
//                      DMPUB_ORIENTATION       - dmOrientation
//                      DMPUB_SCALE             - dmScale
//                      DMPUB_COPIES_COLLATE    - dmCopies/dmCollate
//                      DMPUB_DEFSOURCE         - dmDefSource
//                      DMPUB_PRINTQUALITY      - dmPrintQuality
//                      DMPUB_COLOR             - dmColor
//                      DMPUB_DUPLEX            - dmDuplex
//                      DMPUB_TTOPTION          - dmTTOption
//                      DMPUB_FORMNAME          - dmFormName
//                      DMPUB_ICMMETHOD         - dmICMMethod
//                      DMPUB_ICMINTENT         - dmICMIntent
//                      DMPUB_MEDIATYPE         - dmMediaType
//                      DMPUB_DITHERTYPE        - dmDitherType
//
//                      ** for most of DMPUB_FIRST to DMPUB_LAST each OPTITEM's
//                         pName is automatically set to the standard
//                         IDS_CPSUI_xxx for the consistancy reason, the
//                         standard pName is set according to following table.
//
//                          DMPUB_ORIENTATION    - IDS_CPSUI_ORIENTATION
//                          DMPUB_SCALE          - IDS_CPSUI_SCALING
//                          DMPUB_COPIES_COLLATE - IDS_CPSUI_COPIES
//                          DMPUB_DEFSOURCE      - IDS_CPSUI_SOURCE
//                          DMPUB_PRINTQUALITY   - IDS_CPSUI_PRINTQUALITY
//                                                 IDS_CPSUI_RESOLUTION
//                          DMPUB_COLOR          - IDS_CPSUI_COLOR_APPERANCE
//                          DMPUB_DUPLEX         - IDS_CPSUI_DUPLEX
//                          DMPUB_TTOPTION       - IDS_CPSUI_TTOPTION
//                          DMPUB_FORMNAME       - IDS_CPSUI_FORMNAME
//                          DMPUB_ICMMETHOD      - IDS_CPSUI_ICMMETHOD
//                          DMPUB_ICMINTENT      - IDS_CPSUI_ICMINTENT
//                          DMPUB_MEDIATYPE      - IDS_CPSUI_MEDIA
//                          DMPUB_DITHERTYPE     - IDS_CPSUI_DITHERING
//
//                          for DMPUB_PRINTQUALITY, if the pName is not one of
//                          IDS_CPSUI_PRINTQUALITY or IDS_CPSUI_RESOLUTION then
//                          common UI will automatically default the pName to
//                          IDS_CPSUI_RESOLUTION.
//
//                          Each pData (OPTPARAM) selection in OPTPARAM which
//                          OPTITEM's pOptType pointed to should use as much
//                          as IDS_CPSUI_xxx standard name as possible.
//
//
//                      ** for DMPUB_COPIES_COLLATE the common UI automatically
//                         doing the following before the callback
//
//                          1) Enable/Disable the collate extended check box if
//                             OPTIF_EXT_HIDE is not specified and pExtChkBox
//                             is not NULL in the OPTITEM.
//
//                          2) Automatically change the postfix for this item
//                             to be 'Copy' if selection is one, and 'Copies'
//                             if selection is greater than one in the treeview
//                             page, and it will also set the postfix in
//                             standard document property page if the postfix
//                             ID is provided (BegCtrlID + 4)
//
//
//                      ** for DMPUB_COLOR the common UI automatically doing
//                         the following before the callback, the gray
//                         selection must be Sel=0 and Color slection must be
//                         Sel=1
//
//                          1) Calling halftone color adjustment with current
//                             color/mono selection
//
//                          2) Disable ICM when color is not selected
//
//
//                      ** Please see above DMPUB_xx description for details.
//
//  UserItemID      - This is a byte ID intented to be used by the caller to
//                    identify the item
//
//  wReserved       - WORD reserved. Must be zero
//
//  pOIExt          - Pointer to the OIEXT data structure to specified that
//                    it has a OPTITEM extenstion structure.
//
//  dwReserved[]    - DWORD reserved and must be 0
//
//

//
// predefined ID for call back reason
//

#define CPSUICB_REASON_SEL_CHANGED      0
#define CPSUICB_REASON_PUSHBUTTON       1
#define CPSUICB_REASON_ECB_CHANGED      2
#define CPSUICB_REASON_DLGPROC          3
#define CPSUICB_REASON_UNDO_CHANGES     4
#define CPSUICB_REASON_EXTPUSH          5
#define CPSUICB_REASON_APPLYNOW         6
#define CPSUICB_REASON_OPTITEM_SETFOCUS 7
#define CPSUICB_REASON_ITEMS_REVERTED   8
#define CPSUICB_REASON_ABOUT            9
#define CPSUICB_REASON_SETACTIVE        10
#define CPSUICB_REASON_KILLACTIVE       11


//
// predefined ID for call back action
//

#define CPSUICB_ACTION_NONE             0
#define CPSUICB_ACTION_OPTIF_CHANGED    1
#define CPSUICB_ACTION_REINIT_ITEMS     2
#define CPSUICB_ACTION_NO_APPLY_EXIT    3
#define CPSUICB_ACTION_ITEMS_APPLIED    4


typedef struct _CPSUICBPARAM {
    WORD        cbSize;             // size of this structure
    WORD        Reason;             // CPSUICB_REASON_XXXXX callback reason
    HWND        hDlg;               // handle of the dialog box
    POPTITEM    pOptItem;           // pOptItem field from COMPROPSHEETUI
    WORD        cOptItem;           // cOptItem field from COMPROPSHEETUI
    WORD        Flags;              // flags field from COMPROPSHEETUI
    POPTITEM    pCurItem;           // current selected item of callback
    union {
        LONG    OldSel;             // Last selection (index)
        LPTSTR  pOldSel;            // Last selection (pStr)
        } DUMMYUNIONNAME;
    ULONG_PTR   UserData;           // UserData in the COMPROPSHEETUI struct.
    ULONG_PTR   Result;             // OUT parameter for the APPLYNOW
    } CPSUICBPARAM, *PCPSUICBPARAM;


typedef LONG (APIENTRY *_CPSUICALLBACK)(PCPSUICBPARAM pCPSUICBParam);
#define CPSUICALLBACK   LONG APIENTRY


//
// CPSUICBPARAM is used when commom UI callback to the caller, this structure
// describe the nature of callback and passed all necessary parameter for the
// caller to make changes in the pOptItem and passed an action back to the
// commom UI to redisplay the tree or page 1 data
//
//
//  cbSize      - must be CPSUICBPARAM
//
//  Reason      - defined the nature of the callback
//
//                  CPSUICB_REASON_SEL_CHANGED
//
//                      User make change to the pCurItem.  if the item is
//                      DMPUB_COPIES_COLLATE then common UI automatically
//                      change the collate extended check box without callback
//                      to the caller of the extended check box changes
//
//
//                  CPSUICB_REASON_PUSHBUTTON
//
//                      User push the push button and push button item is set
//                      to PUSHBUTTON_TYPE_CALLBACK.
//
//
//                  CPSUICB_REASON_ECB_CHANGED
//
//                      User make change to the extended checked box (i.e. it
//                      eiterh checked or not checked) EXTCHKBOX in the
//                      pCurItem passed in the call back parameter.
//
//
//                  CPSUICB_REASON_DLGPROC
//
//                      The callback reason is PUSHBUTTON_TYPE_DLGPROC
//
//
//                  CPSUICB_REASON_UNDO_CHANGES
//
//                      This callback currently is not implmented.
//
//
//                  CPSUICB_REASON_EXTPUSH
//
//                      The callback is result of user push the extend push
//                      button.
//
//
//                  CPSUICB_REASON_APPLYNOW
//
//                      The user press the apply now button. Durning callback
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the active DlgPageIdx
//                      (compare to the OPTITEM's DlgPageIdx) which the page
//                      user hitting the apply now button if the page is
//                      non-treeview page, otherwise the 'OldSel' is set to -1
//                      (for treeview page) to indicate all valid item should
//                      be apply now, if the callback return
//                      CPSUICB_ACTION_NONE then the common UI will exit the
//                      property sheet and returned CPSUI_OK back to the
//                      caller, and if the callback function returned
//                      CPSUICB_ACTION_NO_APPLY_EXIT then common UI will not
//                      exit the property sheet and callback function must
//                      pop-up messages dialog box to tell user why it cannot
//                      exist the property sheet until certain action is take
//                      by the user.
//
//
//                  CPSUICB_REASON_OPTITEM_SETFOCUS
//
//                      This callback reason is used when an OPTITEM is getting
//                      the keyboard focus. and give the callback function a
//                      chance to examine the item.
//
//
//                  CPSUICB_REASON_ITEMS_REVERTED
//
//                      This callback reason is used when user changed items
//                      and decided to revert changes from the parent item in
//                      the treeview.  The callback funciton is called after
//                      all revertable items are reverted to its original.
//
//                      The CPSUICBPARAM's pCurItem is same as pOptItem and
//                      'OldSel' field is same as cOptItem field.  for each of
//                      reverted item, the OPTIF_CHANGED bit will be set in the
//                      OPTITEM by the common UI to indicate the item is revert
//                      by the common UI.   The callback function MUST NOT
//                      reset this bit if it is set.
//
//
//                  CPSUICB_REASON_ABOUT
//
//                      This callback reason is used when user hit 'About...'
//                      push button in the treeview page, and the flag
//                      CPSUIF_ABOUT_CALLBACK is set.  The pCurItem is set to
//                      same as pOptItem and 'pOldSel' is a pointer pointed to
//                      original copy of COMPROPSHEETUI data structure which
//                      passed to the common UI.
//
//
//                  CPSUICB_REASON_SETACTIVE
//                  CPSUICB_REASON_KILLACTIVE
//
//                      The current property sheet is gaining or loosing focus,
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the current active
//                      DlgPageIdx (compare to the OPTITEM's DlgPageIdx).
//                      if the page is non-treeview page, otherwise the
//                      'OldSel' is set to -1 (for treeview page).
//
//  hDlg        - The handle to the dialog box (Properties page TAB) current
//                active for the callback.
//
//                Durning the callback the caller must not change the
//                DWLP_USERDATA on hDlg, otherwise the common UI will be crash.
//                If callback function need to get/set DWLP_USERDATA it should
//                call common UI's SetCPSUIUserData() and GetCPSUIUserData()
//                functions instead.
//
//  pCurItem    - Pointed to POPTITEM which the callback is generated for.
//
//  pOldSel
//  OldSel      - The last OPTITEM's pSel/Sel field before the change was made
//                by the user.  The pOldSel/OldSel only valid if the callback
//                reason is CPSUICB_REASON_SEL_CHANGED, this give the callback
//                function a chance to check against the previous item
//                selection.  This is a union field which can be a pointer to
//                a string or a LONG index selection.
//
//  UserData    - a 32-bit user defined data in the COMPROPSHEETUI structure,
//                commom UI will not changed it.
//
//  Result      - When the reason is CPSUICB_REASON_APPLYNOW, the callback
//                function MUST set the requested result for the caller into
//                'Result' field when it returned a value other than the
//                CPSUICB_ACTION_NO_APPLY_EXIT and common UI will send the
//                'Result' field value to this page's parent.
//
//                The called function should save the current result of
//                pOptItem.  The default 'Result' is set to CPSUI_OK (1) from
//                common UI.  This function can alter this result before it
//                return back to to the common UI.
//
//
//  Return Values:
//
//      CPSUICB_ACTION_NONE             - No action need to be take by the
//                                        common UI.
//
//      CPSUICB_ACTION_OPTIF_CHANGED    - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-display because of OPTITEM's Flags
//                                        field changed or item's selection
//                                        changed.   This is different from
//                                        CPSUICB_ACTION_REINIT_ITEMS which
//                                        it assume OPTTYPE or OPTPARAM data
//                                        also changed.
//
//
//      CPSUICB_ACTION_REINIT_ITEMS     - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-initialized in the dilaog box
//                                        control.  This happened if item's
//                                        OPTTYPE or OPTPARAMs flag/pdata
//                                        changed.
//
//
//      CPSUICB_ACTION_NO_APPLY_EXIT    - This return value only valid durning
//                                        CPSUICB_REASON_APPLYNOW callback
//                                        reason, it tell common UI it has
//                                        some constraints in its OPTITEM which
//                                        must correct or confirm by the user
//                                        before exit.  The callback function
//                                        must display and/or have user taking
//                                        some actions before return this
//                                        action to the common UI
//
//      CPSUICB_ACTION_ITEMS_APPLIED    - When responsed to the
//                                        CPSUICB_REASON_APPLYNOW, if the
//                                        returned action is
//                                        CPSUICB_ACTION_ITEMS_APPLIED then
//                                        common UI will reset OPTIF_CHANGEONCE
//                                        bit and save the new default for the
//                                        future undo operations.
//
//

#define DP_STD_TREEVIEWPAGE             0xFFFF
#define DP_STD_DOCPROPPAGE2             0xFFFE
#define DP_STD_DOCPROPPAGE1             0XFFFD
#define DP_STD_RESERVED_START           0xFFF0

#define MAX_DLGPAGE_COUNT               64

#define DPF_ICONID_AS_HICON             0x0001
#define DPF_USE_HDLGTEMPLATE            0x0002

typedef struct _DLGPAGE {
    WORD        cbSize;         // size of this structure
    WORD        Flags;          // DPF_xxxx flags
    DLGPROC     DlgProc;        // caller's dialog box subclass procedue
    LPTSTR      pTabName;       // pointer to the tab name
    ULONG_PTR   IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;  // dialog box template ID
        HANDLE  hDlgTemplate;   // handle to the dialog template
        } DUMMYUNIONNAME;
    } DLGPAGE, *PDLGPAGE;


//
// DLGPAGE structure describe non-treeview page characteristics
//
//
//  cbSize          - size of this structure
//
//  Flags           - DPF_xxxx flags
//
//                      DPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID
//
//
//  DlgProc         - caller's supplied DLGPROC for sub-class the page
//                    dialog box processing,
//
//                    if DlgProc is not NULL then common UI do the following
//                    according the the message received except for the
//                    DP_STD_xxx pages
//
//
//                      WM_INITDIALOG
//
//                          Common UI initialize the dialog box and then call
//                          DlgProc(WM_INITDIALOG) the DlgProc should return
//                          exactly the behavior for the WM_INITDIALOG
//
//                          The lParam in the WM_INITDIALOG data structure is
//                          a pointer to the PROPSHEETPAGE data structure.
//
//                          the lParam field in the PROPSHEETPAGE (lParam
//                          passed to the WM_INITDIALOG) is the UserData
//                          defined in COMPROPSHEETUI data structure
//
//                          To access to the PSPINFO data structure which
//                          associate with this page, use the common UI macro
//                          PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) where
//                          lParam is the parameter passed to the
//                          WM_INITDIALOG message.
//
//                          The subclass function should save these pointers
//                          for its later use, but it MUST NOT modified the
//                          content of the PSPINFO data structure or system
//                          may crashed.
//
//
//                      OTHER DIALOG MESSAGES
//
//                          Iit call DlgProc() and if it returned the value is
//                          non-zero then common UI assume DlgProc() processed
//                          the message and will not process this message.
//
//                          If the returned vlaue from DlgProc() is zero then
//                          common UI will process this message.
//
//
//                      * Durning the DlgProc the caller must not change the
//                        DWLP_USERDATA on hDlg, otherwise the common UI will
//                        be crash.  If caller need to get/set DWLP_USERDATA it
//                        should call common UI's SetCPSUIUserData() and
//                        GetCPSUIUserData() instead.
//
//  pTabName        - Pointer to a string to describe the TAB title
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    DPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - The template id to be use for the ProPage, it can be
//                    one of DP_STD_xxxx, the DP_STD_xxx has 240 x 240 dialog
//                    box units.
//
//
//                      DP_STD_TREEVIEWPAGE
//
//                          Specified that this page is a standard treeview
//                          page provided by the common ui.  The treeview page
//                          is a page using treeview display all valid OPTITEM
//                          passed to the common UI.  User can modify every
//                          valid selectable OPTITEM from the treeview page.
//
//                      DP_STD_DOCPROPPAGE
//
//                          Specified that this page is a standard document
//                          property page provided by the common UI
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//
//  wReserved[]
//  dwReserved[]    - Reserved fields, must be 0
//
//
//  ** Tips of designing the dialog box controls
//
//      When designing the dialog box controls, each OPTITEM is correspoonds
//      to one input control plus one extended check box or extended push
//      button.  Since common UI will automatically disable and remove
//      OPTIF_HIDE items item from the property sheet and dynamically move
//      other controls, the following tips of designing the dialog box controls
//      should follow.
//
//      * Each item should have one input control plus optional of extended
//        check box/push botton, one icon control and other static controls
//
//      * Each item should occupied whole horizontal spaces of the property
//        sheet, items must not overlay in vertical direction.
//
//      * for TVOT_2STATES, TVOT_3STATES, if it araange radio buttons from
//        left to right in state order (ie. from first state's OPTPARAM to
//        last state's OPTPARAM) then the radio buttons and icons should
//        aligned in the Y coordinate.    If it arrange radio buttons from top
//        to bottom (ie. from first state's OPTPARAM to last state's OPTPARAM)
//        then the radio buttons and icons should aligned in the X coordinate.
//
//        common UI will automatically hide/move the radio buttons to compact
//        the dialog box controls.  If radio buttons/icons are arranged in
//        top/down order and there is other controls obscure in Y direction
//        then radio buttons will only be re-arranged but not remove any white
//        spaces in Y direction.
//
//      * If multiple items shared one group box, then the group box must
//        belongs to the first item (topmost in the dialog box group) in the
//        group, the group box must large enough to cover all the items in
//        side the group box.
//
//


#define CPSUIF_UPDATE_PERMISSION        0x0001
#define CPSUIF_ICONID_AS_HICON          0x0002
#define CPSUIF_ABOUT_CALLBACK           0x0004

#define CPSUI_PDLGPAGE_DOCPROP          (PDLGPAGE)1
#define CPSUI_PDLGPAGE_ADVDOCPROP       (PDLGPAGE)2
#define CPSUI_PDLGPAGE_PRINTERPROP      (PDLGPAGE)3
#define CPSUI_PDLGPAGE_TREEVIEWONLY     (PDLGPAGE)4

//
// For compatible misspelling #define
//

#define CPSUI_PDLGPAGE_TREEVIWONLY      CPSUI_PDLGPAGE_TREEVIEWONLY

typedef struct _COMPROPSHEETUI {
    WORD            cbSize;             // size of this structure
    WORD            Flags;              // CPSUIF_xxxx flags
    HINSTANCE       hInstCaller;        // caller's hInstance
    LPTSTR          pCallerName;        // pointer to the caller's name
    ULONG_PTR       UserData;           // caller's own data
    LPTSTR          pHelpFile;          // pointer to the help file
    _CPSUICALLBACK  pfnCallBack;        // callback function pointer
    POPTITEM        pOptItem;           // pointer to POPTITEM array
    PDLGPAGE        pDlgPage;           // pointer to the DLGPAGE array
    WORD            cOptItem;           // count of pOptItem array
    WORD            cDlgPage;           // count of pDlgPage array
    ULONG_PTR       IconID;             // icon to be used
    LPTSTR          pOptItemName;       // pointer to the optitem's data name
    WORD            CallerVersion;      // version for the caller apps
    WORD            OptItemVersion;     // version for the optitem name
    ULONG_PTR       dwReserved[4];      // reserved, must be 0
    } COMPROPSHEETUI, *PCOMPROPSHEETUI;


//
// COMPROPSHEETUI data structure is used when calling common UI to display dialog
// box of properties pages.
//
//
//  Size                - Must be sizeof (COMPROPSHEETUI)
//
//  Flags               - can be one or more of following
//
//                          CPSUIF_UPDATE_PERMISSION
//
//                              Specified the any valid pOptItem items are
//                              changeable by the user.
//
//
//                          CPSUIF_ICONID_AS_HICON
//
//                              If this flag is set then IconID DWORD field is
//                              treated as a handle to the icon rather then the
//                              resource ID
//
//
//                          CPSUIF_ABOUT_CALLBACK
//
//                              If this flag bit is set, then when user hit
//                              'About...' button in the treeview tab, it will
//                              call the callback function with a reason of
//                              CPSUICB_REASON_ABOUT, and callback MUST handle
//                              the about which pop-up dialog box to show user
//                              the information about the caller and OPTITEMs.
//
//                              If this bit is not set then common UI will call
//                              the ShellAbout() with formatted caller Name and
//                              pOptItemName with version numbers.
//
//
//  hInstCaller         - the caller's handle to its instance.  Commom UI use
//                        this handle to load caller's icon and other resources.
//
//  pCallerName         - Pointer to the caller's NULL terminated caller's
//                        name, most time this is driver's name,
//                        such as 'Postscript Driver'
//
//  UserData            - a 32-bit number used by the caller and common UI will
//                        not modify it.  this 32-bit number is passed back to
//                        the caller durning the callback function
//
//  pHelpFile           - specified a standard microsoft help file (path/file)
//                        for using in the common UI.  in OPTITEM specified
//                        HelpIndex for help in each item.
//
//  pfnCallBack         - Pointer to _CPSUICALLBACK callback function.  Common
//                        UI only callback to the caller if an OPTIF_CALLBACK
//                        is set OPTITEM data structure's flag fields and the
//                        item selection is changed by the user.
//
//  pOptItem            - Pointer to array of OPTITEM structure to be displayed
//                        by the common UI
//
//  pDlgPage            - Pointer to array of DLGPAGE structure to describe
//                        each property sheet page infomation, the following
//                        are the standard common ui DLGPAGEs.  When specified
//                        CPSUI_PDLGPAGE_xxxx, the common UI will automatically
//                        modify DlgPageIdx field in the OPTITEM, caller must
//                        set the iStartPage correctly.
//
//                          CPSUI_PDLGPAGE_DOCPROP
//
//                              specified this a common ui standard document
//                              property sheets. This includes two property
//                              sheets, 1) Page Setup 2) Advance (TreeView)
//
//
//                          CPSUI_PDLGPAGE_ADVDOCPROP
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page with tab of 'Advance'
//
//
//                          CPSUI_PDLGPAGE_PRINTERPROP
//
//                              Specified this is a common UI standard printer
//                              property sheet.  This only has one treeview
//                              page with tab of 'Device Options'
//
//
//                          CPSUI_PDLGPAGE_TREEVIEWONLY
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page
//
//
//
//  cOptItem            - Count of OPTITEM pointed by the pOptItem above
//
//  cDlgPage            - Count of DLGPAGE pointed by the pDlgPage.  If
//                        pDlgPage is one of the CPSUI_PDLGPAGE_xxxx then this
//                        field is ignored by the common UI.
//
//  IconID              - This is the icon identifier, which can be a common
//                        strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                        resource ID, or a handle to the caller defined icon
//                        if CPSUIF_ICONID_AS_HICON flag is set, in any case
//                        if the IconID is zero then it indicated no icon.
//
//  pOptItemName        - Pointer to the pOptItem data NULL terminated name,
//                        most time this is device name, such as 'HP 4si'
//
//  CallerVersion       - Version for the caller, the HIBYTE(CallerVersion) is
//                        the major version, and LOBYTE(CallerVersion) is the
//                        minor version, such as 0x310 display as 3.16, 0x3ff
//                        display as 3.255 and 0x30a display as 3.10
//
//  OptItemVersion      - Version for the OPTITEM's data, the
//                        HIBYTE(OptItemVersion) is the major version, and
//                        LOBYTE(OptItemVersion) is the minor version, such as
//                        0x310 display as 3.16, 0x3ff display as 3.255 and
//                        0x30a display as 3.10.
//
//  dwReserved[4]       - reserved fields, must be 0
//
//
//  ** pTitlee and TitleBarIcon only used if CommonPrinterPropSheetUI()
//     is the last one the Property sheet UI chain and call the PropertySheet()
//
//


#define CPSFUNC_ADD_HPROPSHEETPAGE          0
#define CPSFUNC_ADD_PROPSHEETPAGEW          1
#define CPSFUNC_ADD_PCOMPROPSHEETUIA        2
#define CPSFUNC_ADD_PCOMPROPSHEETUIW        3
#define CPSFUNC_ADD_PFNPROPSHEETUIA         4
#define CPSFUNC_ADD_PFNPROPSHEETUIW         5
#define CPSFUNC_DELETE_HCOMPROPSHEET        6
#define CPSFUNC_SET_HSTARTPAGE              7
#define CPSFUNC_GET_PAGECOUNT               8
#define CPSFUNC_SET_RESULT                  9
#define CPSFUNC_GET_HPSUIPAGES              10
#define CPSFUNC_LOAD_CPSUI_STRINGA          11
#define CPSFUNC_LOAD_CPSUI_STRINGW          12
#define CPSFUNC_LOAD_CPSUI_ICON             13
#define CPSFUNC_GET_PFNPROPSHEETUI_ICON     14
#define CPSFUNC_ADD_PROPSHEETPAGEA          15
#define CPSFUNC_INSERT_PSUIPAGEA            16
#define CPSFUNC_INSERT_PSUIPAGEW            17
#define CPSFUNC_SET_PSUIPAGE_TITLEA         18
#define CPSFUNC_SET_PSUIPAGE_TITLEW         19
#define CPSFUNC_SET_PSUIPAGE_ICON           20
#define CPSFUNC_SET_DATABLOCK               21
#define CPSFUNC_QUERY_DATABLOCK             22
#define CPSFUNC_SET_DMPUB_HIDEBITS          23
#define CPSFUNC_IGNORE_CPSUI_PSN_APPLY      24
#define CPSFUNC_DO_APPLY_CPSUI              25
#define MAX_CPSFUNC_INDEX                   25

#ifdef UNICODE
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIW
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIW
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGW
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEW
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEW
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEW

#else
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIA
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIA
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGA
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEA
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEA
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEA

#endif

//
// for the CPSFUNC_SET_RESULT
//

#define SR_OWNER            0
#define SR_OWNER_PARENT     1

typedef struct _SETRESULT_INFO {
    WORD        cbSize;
    WORD        wReserved;
    HANDLE      hSetResult;
    LRESULT     Result;
    } SETRESULT_INFO, *PSETRESULT_INFO;

//
// This is for CPSFUNC_INSERT_PSUIPAGE
//

#define HINSPSUIPAGE_FIRST              (HANDLE)0xFFFFFFFE
#define HINSPSUIPAGE_LAST               (HANDLE)0xFFFFFFFF
#define HINSPSUIPAGE_INDEX(i)           (HANDLE)MAKELONG(i, 0);

#define PSUIPAGEINSERT_GROUP_PARENT     0
#define PSUIPAGEINSERT_PCOMPROPSHEETUI  1
#define PSUIPAGEINSERT_PFNPROPSHEETUI   2
#define PSUIPAGEINSERT_PROPSHEETPAGE    3
#define PSUIPAGEINSERT_HPROPSHEETPAGE   4
#define PSUIPAGEINSERT_DLL              5
#define MAX_PSUIPAGEINSERT_INDEX        5


#define INSPSUIPAGE_MODE_BEFORE         0
#define INSPSUIPAGE_MODE_AFTER          1
#define INSPSUIPAGE_MODE_FIRST_CHILD    2
#define INSPSUIPAGE_MODE_LAST_CHILD     3
#define INSPSUIPAGE_MODE_INDEX          4


typedef struct _INSERTPSUIPAGE_INFO {
    WORD        cbSize;
    BYTE        Type;
    BYTE        Mode;
    ULONG_PTR   dwData1;
    ULONG_PTR   dwData2;
    ULONG_PTR   dwData3;
    } INSERTPSUIPAGE_INFO, *PINSERTPSUIPAGE_INFO;


//
// for the CPSFUNC_SET_HSTARTPAGE
//

#define SSP_TVPAGE          10000
#define SSP_STDPAGE1        10001
#define SSP_STDPAGE2        10002

typedef LONG_PTR (CALLBACK *PFNCOMPROPSHEET)(HANDLE hComPropSheet,
                                             UINT   Function,
                                             LPARAM lParam1,
                                             LPARAM lParam2);


typedef struct _PSPINFO {
    WORD            cbSize;
    WORD            wReserved;
    HANDLE          hComPropSheet;
    HANDLE          hCPSUIPage;
    PFNCOMPROPSHEET pfnComPropSheet;
    } PSPINFO, *PPSPINFO;

//
// PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) macro retrieve a pointer to the
// PSPINFO data structure. the lParam must be the lParam passed to the
// WM_INITDIALOG, otherwise the system can failed
//

#define PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam)  \
                (PPSPINFO)((LPBYTE)lParam + ((LPPROPSHEETPAGE)lParam)->dwSize)

//
// PSPINFO
//
//  This structure is used durning property sheet page's WM_INITDIALOG message.
//  At WM_INITDIALOG, the lParam is a pointer to the PROPSHEETPAGE, and
//  lParam field in the PROPSHEETPAGE is a pointer to the PSPINFO.  the
//  original lParam in the PROPSHEETPAGE is saved in the lParam field in the
//  PSPINFO data structure.
//
//  When process WM_INITDIALOG message, it should save the lParam (PSPINFO
//  structure pointer) for later to call common UI callback functions.
//
//
//  cbSize          - Size of this structure in bytes
//
//  wReserved       - Reserved, must be set to zero
//
//  hComPropSheet   - Handle to the parent page which is the hComPropSheet
//                    passed to the CPSFUNC_ADD_PROPSHEETPAGE
//
//  hCPSUIPage      - Handle to the this added common UI property sheet page.
//
//  pfnComPropSheet - Pointer to the common UI callback function, using this
//                    function pointer to do CPSFUNC_xxxx
//
//

typedef struct _CPSUIDATABLOCK {
    DWORD   cbData;
    LPBYTE  pbData;
    } CPSUIDATABLOCK, *PCPSUIDATABLOCK;


#define APPLYCPSUI_NO_NEWDEF        0x00000001
#define APPLYCPSUI_OK_CANCEL_BUTTON 0x00000002

//
// PFNCOMPROPSHEET function descriptions
//
// For each function index, it passed a handle, a Function Index and two (2)
// long parameters, the 'hComPropSheet' handle passed must be the handle passed
// from common UI when common UI called the caller supplied function
//
// pfnPropSheetUI(pPropSheetUIData);
//
// Following are the description of each function index
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_HPROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using handle to the
//      PROPSHEETPAGE
//
//
//  Parameters:
//
//      lParam1 - is a handle to the PROPSHEETPAGE that created by the caller
//                using CreatePropertySheetPage()
//
//      lParam2 - Not used, must be 0
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using PROPSHEETPAGE
//      data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to PROPSHEETPAGE data structure
//
//      lParam2 - Not used.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PCOMPROPSHEETUI
//
//      This function add propety page(s) to the hComPropSheet handle using
//      COMPROPSHEETUI data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to COMPROPSHEETUI data structure
//
//      lParam2 - pointer to a 32-bit location that received the total pages
//                added by the COMPROPSHEETUI data structure if sucessful else
//                it contains the ERR_CPSUI_xxx error codes.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PFNPROPSHEETUI
//
//      This function add property page(s) to the hChild handle using
//      lParam1 as PFNPROPSHEETUI function pointer and lParam2 as the function
//      parameter.   The common UI call supplied function as following
//
//          PROPSHEETUI_INFO    PSUIInfo;
//
//          PSUIInfo.cbSize          = sizeof(PROPSHEETUI_INFO);
//          PSUIInfo.Version         = PROPSHEETUI_INFO_VERSION;
//          PSUIInfo.Flags           = (Ansi) ? 0: PSUIINFO_UNICODE;
//          PSUIInfo.Reason          = PROPSHEETUI_REASON_INIT;
//          PSUIInfo.hComPropSheet   = hComPropSheet;
//          PSUIInfo.pfnComPropSheet = ComPropSheetUICallBack;
//          PSUIInfo.lParamInit      = lParam2;
//          PSUIInfo.UserData        = 0;
//          PSUIInfo.Result          = 0;
//
//          ((PFNPROPSHEETUI)lParam1)(&PSUIInfo, lParam2);
//
//
//          If the pfnPropSheetUI() need to add/delete any common UI pages then
//          it must use hComPropSheet as its handle when calling the
//          ComPropSheetUICallBack().
//
//
//  Parameters:
//
//      lParam1 - a PFNPROPSHEETUI function pointer.
//
//      lParam2 - a 32-bit data that will be used as lParam when calling
//                PFNPROPSHEETUI function pointer.
//
//
//  Return Value:
//
//      The return value is the newly added property pages function handle, if
//      return value is NULL then function failed or no page is added.
//
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_DELETE_HCOMPROPSHEET
//
//      This function delete child property page(s) from hComPropSheet parent
//      using the child handle passed.
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be deleted.
//                This handle must be the handle returned from CPSFUNC_ADD_xxx
//                functions.
//
//      lParam2 - not used, must be 0
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PAGECOUNT
//
//      This function return total property sheet pages belongs to a common
//      UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - not used, must be 0
//
//      lParam2 - not used, must be 0.
//
//
//  Return Value:
//
//      The return value is total page count if function sucessful or zero if
//      function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_RESULT
//
//      This function set the result of property sheet page to its owner that
//      added this page by CPSFUNC_ADD_xxx function indices
//
//  Parameters:
//
//      lParam1 - Handle to the common UI property sheet page that setting the
//                result.  If this handle is NULL then it is treated as
//                equal to the hComPropSheet.
//
//      lParam2 - a 32-bit DWORD result to be set.
//
//
//  Return Value:
//
//      > 0: Successful, return value is total count of parents set the result
//      = 0: There is no owner or parent for the lParam1 handle.
//      < 0: function failed because of invalid lParam1 handle.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_HSTARTPAGE
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be set
//                as initial page that appear when the property sheet dialog
//                boxes is created.  This handle must be the handle returned
//                from CPSFUNC_ADD_xxx functions.
//
//                If lParam1 is NULL then lParam2 is a string pointer to the
//                page name (tab) that to be set for the start page
//
//      lParam2 - a LONG number to specified the children index. if lParam1
//                handle is a parent then lParam2 specified zero base children
//                index for using as start page.
//
//                It also can be one of following special index
//
//                  SSP_TVPAGE
//
//                      set to the treeview page, this only valid if lParam1
//                      handle was added by the CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//                  SSP_STDPAGE
//
//                      Set to the standard document property sheet page
//                      (Page 1 user friendly page).  this only valid if
//                      lParam1 handle was added by the
//                      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.  This function can only be
//      called when the property sheet is not display yet so the place to
//      call is during the PROPSHEETUI_REASON_GET_INFO_HEADER callback.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_HPSUIPAGES
//
//      This function return array of children HPROPSHEETPAGE belongs to
//      the parent hComPropSheet UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - Pointer to an array of HPROPSHEETPAGE that to be stored
//                the handle upon return.
//
//      lParam2 - Count of HPROPSHEETPAGE array pointed by the lParam1
//
//
//  Return Value:
//
//      The return value is total HPROPSHEETPAGE stored in the array pointed
//      by the lParam1.   To get all hPropSheetPage for any common property
//      sheet handle's (hCPSUIPage) children, it can use following sequence.
//
//          if ((cPage = pfnComPropSheet(hComPropSheet,
//                                       CPSFUNC_GET_PAGECOUNT,
//                                       (LPARAM)hCPSUIPage,
//                                       0L))   &&
//              (phPage = ALLOCMEM(cPage * sizeof(HANDLE)))) {
//
//              pfnComPropSheet(hCPSUIPage,
//                              CPSFUNC_GET_HPSUIPAGES,
//                              (LPARAM)phPage,
//                              (LPARAM)cPage);
//          }
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_STRING
//
//      This function load the common property sheet UI resource string
//
//  Parameters:
//
//      lParam1 - Pointer to LPTSTR string which will stored the loaded
//                resource string from the common property sheet UI DLL.
//
//      lParam2 - LOWORD(lParam2) = Count of characters (includes null
//                                  terminator) which pointed by the lParam1
//
//                HIWORD(lParam2) = Common property sheet UI predefined string
//                                  resource ID as IDS_CPSUI_xxxx
//
//
//  Return Value:
//
//      > 0: Total characters stored in the string pointed by the lParam1, this
//           is not includes the null terminator
//      = 0: Invalid IDS_CPSUI_xxx passed from HIWORD(lParam)
//      < 0: Either lParam1 is NULL or count of character is 0 from
//           LOWORD(lParam2)
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_ICON
//
//      This function load the common property sheet UI resource icon.
//
//  Parameters:
//
//      lParam1 - Common property sheet UI predefined icon resource ID as
//                IDI_CPSUI_xxxx.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PFNPROPSHEETUI_ICON
//
//      This function let the caller return hIcon of its children pages that
//      was added by CPSFUNC_ADD_PFNPROPSHEETUI
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the hIcon will be
//                queried.  This handle must be the handle returned from
//                CPSFUNC_ADD_PFNPROPSHEETUI function.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_INSERT_PSUIPAGE
//
//      This function let the caller insert common property sheet pages at
//      set position.  The hComPropSheet must be the parent handle.
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the page position
//                will be inserted.  This handle must be the handle returned
//                from previous CPSFUNC_ADD_xxx or CPSFUNC_INSERT_PSUIPAGE that
//                added or inserted using the hComPropSheet if the Mode field
//                in INSPSUIPAGE_INFO data structure is one of the follwing
//
//                  INSPSUIPAGE_MODE_BEFORE
//                  INSPSUIPAGE_MODE_AFTER      - Common UI page handle
//
//                  INSPSUIPAGE_MODE_INDEX      - the lParam1 is an zero based
//                                                child index.
//
//                  INSPSUIPAGE_MODE_FIRST_CHILD
//                  INSPSUIPAGE_MODE_LAST_CHILD - The lParam1 is ignonred.
//
//
//                If lParam1 is a valid common property sheet page handle then
//                it is  the child page handle of hComPropSheet that added by
//                CPSFUNC_ADD_xxx or inserted by CPSFUNC_INSERT_PSUIPAGE.
//
//      lParam2 - A pointer that points to INSERTPSUIPAGE_INFO data structure.
//                Fields must set according to the following.
//
//                  cbSize  - size of this structure
//
//                  Type    - Type of page(s) to be inserted.  It can be one
//                            of the following
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          Insert a group parent that can be used to insert
//                          new pages under it.  This is typically used when
//                          a set of common UI pages must be group together and
//                          can be deleted later using a single group parent
//                          handle without individual deleting each page.
//
//                          This handle can be nested.  After this function
//                          returned the group parent handle, it can be used
//                          as hComPropSheet handle (first parameter in the
//                          common UI callback) as parent handle so insertion
//                          will be inserted at level below returned group
//                          parent handle.
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          Insert pages using COMPROPSHEETUI data structure,
//                          dwData1 is a pointer to the COMPROPSHEETUI data
//                          structure.
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          Insert pages using PFNPROPSHEETUI function pointer.
//                          The dwData1 is a PFNPROPSHEETUI function pointer.
//                          The common UI will call this pfnPropSheetUI()
//                          function pointer with PROPSHEETUI_REASON_INIT to
//                          have it add pages.
//
//                          When common UI call pfnPropSheetUI() (dwData1) it
//                          also passed a 32-bit parameter from the dwData2
//                          field in INSERTPSUIPAGE_INFO data structure.
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          Insert pages using PROPSHEETPAGE data structure.
//                          The dwData1 is a pointer to the PROPSHEETPAGE
//                          data structure.
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          Insert pages using HPROPSHEETPAGE handle.  The
//                          dwData1 is a PROPSHEETPAGE handle which was
//                          created by CreatePropertySheetPage().
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          Insert pages from a dynnmaic link library.  The
//                          dwData1 is a pointer to a null terminated string
//                          that specified the dynamic link library file name.
//
//                          The dwData2 is a pointer to a null terminated ASCII
//                          string that specified the pfnPropSheetUI function
//                          name. (MUST BE ASCII STRING)
//
//                          Common UI will do a LoadLibrary((LPTSTR)dwData1),
//                          pfnPropSheetUI = GetProcAddress((LPTSTR)dwData2)
//                          then call the pfnPropSheetUI with a lParam from
//                          dwData3.  The called reason from common UI is
//                          set to PROPSHEETUI_REASON_INIT.
//
//                          Using this method insert pages will guaranteed that
//                          library will be unload correctly.
//
//
//                  Mode    - Insert Mode, it can be one of the following
//
//
//                      INSPSUIPAGE_MODE_BEFORE
//
//                          Insert pages before the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_AFTER
//
//                          Insert pages after the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_FIRST_CHILD
//
//                          Insert pages as the first child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_LAST_CHILD
//
//                          Insert pages as the last child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_INDEX
//
//                          Insert pages as a zero base child index of its
//                          parent handle specified by hComPropSheet.
//
//                          The lParam1 is the zero based index special handle
//                          that must generated by HINSPSUIPAGE_INDEX(Index)
//                          macro.   If the index is greater than or equal to
//                          the total count of children then it will treat the
//                          mode same as INSPSUIPAGE_MODE_LAST_CHILD
//
//
//                  dwData1
//                  dwData2
//                  dwData3 - 32-bit data associate with the 'Type' field
//                            as following
//
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          dwData1 = Not used, must be 0
//                          dwData2 = Not used, must be 0
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          dwData1 = pointer to COMPORPSHEETUI data structure.
//                          dwData2 = at return if sucessful, it contains total
//                                    page added.  If failed, it contains the
//                                    ERR_CPSUI_xxx codes
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          dwData1 = PFNPROPSHEETUI function pointer
//                          dwData2 = 32-bit parameter passed to pfnPropSheetUI
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          dwData1 = Pointer to PROPSHEETPAGE data structure.
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          dwData1 = Is the HPROPSHEETPAGE handle that created
//                                    by a call to CreatePropertySheetPage().
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          dwData1 = Pointer to a null terminated dynamic link
//                                    library filename.
//                          dwData2 = Pointer to a null terminated function
//                                    name (PFNPROPSHEETUI) in the dynamin link
//                                    library.
//                          dwData3 = 32-bit parameter passed to pfnPropSheetUI
//                                    (PFNPROPSHEETUI) function from dwData2
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_TITLE
//
//      This function let the caller set a new title for a particular common
//      UI page title (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that title to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Pointer to a null terminated string for the new title
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_ICON
//
//      This function let the caller set a new icon for a particular common
//      UI page icon (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that icon to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Handle to Icon, this icon is best as 16x16 icon otherwise it
//                will be stretch to 16x16 (pixel).
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//      After this function is successful set the icon, the caller can destroy
//      the hIcon using DestroyIcon() if the hIcon is created by CreateIcon().
//      If the hIcon (lParam2) passed is using LoadIcon() then it does not need
//      to destroy the icon.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DATABLOCK
//
//      This function let the caller register a new data block so it can be
//      later query by other pages in the property sheet, this function should
//      call durning PSN_KILLACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2 to be set.
//
//      lParam2 - DWORD Identifier of data block to be set
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block registered.  If return value is less
//      or equal to zero then function failed and data block is not registered.
//
//      If lParam1 is NULL, (lParam1)->cbData or (lParam1)->pbbData is NULL
//      it return a -1 to indicate an error parameter passed.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_QUERY_DATABLOCK
//
//      This function let the caller query a registered data block so it can
//      used this data block to communicate between property sheet pages.
//      This function should call durning PSN_SETACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2
//
//      lParam2 - DWORD Identifier of data block to be queried
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block copied into the pointer pointed by
//      the lParam1.  If return value is less or equal to zero then function
//      failed and data block is not copied to diciate the spcified datablock
//      Identifier (lParam2) is not found.
//
//      If CPSUIDATABLOCK pointer (lParam1) is NULL, (lParam1)->cbData or
//      (lParam1)->pbData is NULL then return value is the total bytes required
//      to copy the specified datablock identifier, if return value is less or
//      equal to zero then it indicate the spcified datablock identifier is
//      not found.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DMPUB_HIDEBITS
//
//      This function let the caller hide a set of predefined OPTITEMS in the
//      pages that was created using PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI with pDlgPage equal to
//      CPSUI_PDLGPAGE_DOCPROP or CPSUI_PDLGPAGE_ADVDOCPROP.
//
//      This function MUST called BEFORE the DOCPROP or ADVDOCPROP property
//      sheet pages are added using  PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//  Parameters:
//
//      lParam1 - prdefined bit array masks to specified which DOCPROP item to
//                be hidden.  Each DMPUB item bit can be generate using macro
//                MAKE_DMPUB_HIDEBIT() and all items can be OR together.
//
//      lParam2 - Not used, MUST be 0
//
//
//  Return Value:
//
//      The return value is equal to lParam1 if this function is called before
//      DOCPROP or ADVDOCPROP pages are added. Return value is zero if these
//      pages already added which means failure.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_IGNORE_CPSUI_PSN_APPLY
//
//      This function let caller control how CPSUI process PSN_APPLY messages
//      for pages added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      If this function never called, the Default CPSUI behavior is to process
//      PSN_APPLY messages.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - A non-zero value indicate to IGNORE the PSN_APPLY messages
//                for pages handle of lParam1.
//
//                A zero value to have CPSUI nomally process (not ignored) the
//                PSN_APPLY messages for pages handle of lParam1.
//
//                WARNING: if a PSN_APPLY messages are ignored, the caller must
//                         simulate a PSN_APPLY using CPSFUNC_DO_APPLY_CPSUI
//                         function or all changes WILL NOT applied, this is
//                         true even user hit 'OK' button.
//
//  Return Value:
//
//      the return value is zero if function failed, or non-zero to indicate
//      the function is successful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_DO_APPLY_CPSUI
//
//      This function let caller simulate an apply (PSN_APPLY) to the pages
//      which added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - 32-bit flag to indicate how to do apply, currently only
//
//                  APPLYCPSUI_NO_NEWDEF
//
//                      The APPLYCPSUI_NO_NEWDEF bit specified that after the
//                      apply is done the undo buffer for all OPTITEMs still
//                      remain unchanged, this make next undo still possible.
//
//                      If APPLYCPSUI_NO_NEWDEF bit is clear then undo buffers
//                      are re-initialized after apply is done, the current
//                      changes for all OPTITEMs become the new undo default.
//
//
//                  APPLYCPSUI_OK_CANCEL_BUTTON
//
//                      If bit is set then it specified the apply is simulate
//                      a user hit 'Ok' or 'Cancel' button, if this bit is
//                      clear then it simulate a user hit 'Close' or 'Apply'
//                      button.  If caller getting a PSN_APPLY message, it can
//                      simulated using passed PSHNOTIFY (passed as lParam in
//                      WM_NOTIFY message) structure to determine how to set
//                      this bit as follow.
//
//                          if PSHNOTIFY.lParam == 0, then clear this bit
//                          otherwise set this bit.
//
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and
//      apply failed (the active page will be switch to these pages).
//
//      If return value is greater than zero then changes were applied and
//      function sucessful.
//
// -------------------------------------------------------------------------
//



#define PROPSHEETUI_REASON_INIT             0
#define PROPSHEETUI_REASON_GET_INFO_HEADER  1
#define PROPSHEETUI_REASON_DESTROY          2
#define PROPSHEETUI_REASON_SET_RESULT       3
#define PROPSHEETUI_REASON_GET_ICON         4
#define MAX_PROPSHEETUI_REASON_INDEX        4

#define PROPSHEETUI_INFO_VERSION            0x0100

#define PSUIINFO_UNICODE                    0x0001

typedef struct _PROPSHEETUI_INFO {
    WORD            cbSize;
    WORD            Version;
    WORD            Flags;
    WORD            Reason;
    HANDLE          hComPropSheet;
    PFNCOMPROPSHEET pfnComPropSheet;
    LPARAM          lParamInit;
    ULONG_PTR       UserData;
    ULONG_PTR       Result;
    } PROPSHEETUI_INFO, *PPROPSHEETUI_INFO;


//
// For the PROPSHEETUI_REASON_GET_ICON call which lParam is a pointer to
// PROPSHEETUI_GETICON_INFO
//

typedef struct _PROPSHEETUI_GETICON_INFO {
    WORD    cbSize;
    WORD    Flags;
    WORD    cxIcon;
    WORD    cyIcon;
    HICON   hIcon;
    } PROPSHEETUI_GETICON_INFO, *PPROPSHEETUI_GETICON_INFO;


typedef LONG (FAR *PFNPROPSHEETUI)(PPROPSHEETUI_INFO   pPSUIInfo,
                                   LPARAM              lParam);


//
// PFNPROPSHEETUI
//
//  This function is user defined function which will be called by the common
//  UI when a caller wish to include the executable property sheets.
//
//  pPSUIInfo   - Pointer to PROPSHEETUI_INFO below for description of
//                PROPSHEETUI_INFO.
//
//                If this pointer is NULL then this function is not called from
//                common UI, and lParam should be used to determined the
//                action and outcome of this funciton.
//
//  lParam      - A LPARAM intented for this funciton depends on the reason.
//                If pPSUIInfo is NULL then this function is not called from
//                common UI, the lParam is the parameter which agreed with
//                the caller.
//
//                if pPSUIInfo is not NULL then this function assume the call
//                is from the common UI.  lParam has following meanion depends
//                on the reason field.
//
//                PROPSHEETUI_REASON_INIT
//
//                  The lParam is either passed from CPSFUNC_ADD_PFNPROPSHEETUI
//                  callback function's second parameter (lParam2) or it is
//                  from CommonPropertySheetUI()'s lParam (seccond parameter)
//                  without any modification.
//
//                  The lParam MUST NOT be a variable or a pointer to memory
//                  block which resides on the caller function's stack, since
//                  after this function exit, the lParam will become invalid
//                  and can cause fatal system error.
//
//                  The lParam parameter is copied to the lParamInit field in
//                  PROPSHEETUI_INFO data structure.  The lParamInit field
//                  will be passed to all subsequent pfnPropSheetUI() calls
//                  without any modification.
//
//
//                PROPSHEETUI_REASON_GET_INFO_HEADER:
//
//                  lParam is a pointer to the PROPSHEETUI_INFO_HEADER data
//                  structure. this function must correctly fill this structure
//                  fields before it returned.
//
//
//                PROPSHEETUI_REASON_DESTROY
//
//                  lParam is zero to indicate the destroy is cause either by a
//                  caller calling CPSFUNC_DELETE_HCOMPROPSHEET or failed
//                  in caller's CPSFUNC_ADD_xxxx.
//
//                  lParam is non zero to indicate the destroy is cause by
//                  exiting from the property sheet user interface.
//
//
//                PROPSHEETUI_REASON_SET_RESULT
//
//                  lParam is a pointer to SETRESULT_INFO data structure.
//                  Fields in SETRESULT_INFO data structure is set to following
//
//                      hSetResult: Handle to the common UI property sheet
//                                  pages which added by the CPSFUNC_ADD_xxx
//                                  callback function indices.
//
//                          Result: The result from the hSetResult to be set.
//                                  When return greater than zero then Result
//                                  in this field is set to its parent.
//
//
//                PROPSHEETUI_REASON_GET_ICON
//
//                  lParam is a pointer to PROPSHEETUI_GETICON_INFO data
//                  structure.  Fields in PROPSHEETUI_GETICON_INFO data
//                  structure are set to following
//
//                      cxIcon = cx Icon size in pixel
//                      cyIcon = cy Icon size in pixel
//                      hIcon  = Initial to NULL, and this function must put
//                               the created icon handle in this field before
//                               returned.
//


//
// PROPSHEETUI_INFO
//
//  This structure is used when common UI calling the caller passed function
//  entry point PFNPROPSHEETUI, the pfnPropSheetUI() return a LONG to
//  indicate result of this function.
//
//  When the pfnPropSheetUI() returned, it must also put the required result
//  in the Result field, each PROPSHEETUI_REASON_xxx has different required
//  result as describe below.
//
//
//
//  cbSize          - sizeof this structure (PROPSHEETUI_INFO)
//
//  Version         - the PROPSHEETUI_INFO data structure version. Current
//                    version is set to PROPSHEETUI_INFO_VERSION
//
//  Flags           - One or more following is may be defined
//
//                      PSUIINFO_UNICODE
//
//                          The caller's executable was original compiled was
//                          intented using unicode.
//
//
//  Reason          - Following reasons are defined.
//
//                      PROPSHEETUI_REASON_INIT
//
//                          When first time the pfnPropSheetUI() called, this
//                          reason is used to have the function initialize
//                          itself and use the pfnComPropSheet() function
//                          pointer provided to add new pages to the
//                          hComPropSheet handle passed.   The UserData in this
//                          data structure is initially set equal to zero (0).
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//                      *NOTE*
//
//                          The lParam MUST NOT be a variable or a pointer to
//                          memory block which resides on the caller function's
//                          stack, since after this function exit, the lParam
//                          will become invalid and can cause fatal system
//                          error.
//
//                          If this function reason returned failed ( <= 0),
//                          this function (pfnPropSheetUI) will received a
//                          PROPSHEETUI_REASON_DESTROY function reason right
//                          after this function reason returned.
//
//
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                          It is called after the PROPSHEETUI_REASON_INIT is
//                          successful returned.  This reason is used to asked
//                          the function fill in the PROPSHEETUI_INFO_HEADER
//                          for pop-up the property sheet dialog boxes.
//
//                          lParam in this reason is a pointer to the
//                          PROPSHEETUI_INFO_HEADER data structure, following
//                          fields are requrested to be filled in.
//
//                              Flags       - PSUIHDRF_xxx flags
//                              pTitle      - The property sheet title
//                              hWndParent  - handle to the parent of property
//                                            sheet pages.
//                              hInst       - Instance data handle for this
//                                            function.
//                              hIcon
//                              IconID      - Icon used on the title bar.
//
//                          * Return > 0 to indicate sucesful and pop-up the
//                            property sheet dialog boxes or returned <= 0 to
//                            indicate error (not property sheet UI appeared)
//
//
//                      PROPSHEETUI_REASON_DESTROY
//
//                          When the property sheet ready to dismissed or the
//                          caller is delete the common UI pages added by the
//                          pfnPropSheetUI(), the common UI will call this
//                          entry point to have it de-initialized itself and
//                          free up all the memory used for this function
//                          instance.  The UserData field passed is the
//                          'UserData' field which returned from previous
//                          PROPSHEETUI_REASON_xxxx.
//
//                          When this function called, all hComPropSheet's
//                          children are desotroyed and children's common UI
//                          handles are not longer valid.
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                          The reason is used when an added handle from
//                          CPSFUNC_ADD_xxxx whant to return the result to
//                          this pfnPropSheetUI() caller.
//
//                          The lParam in second parameter is a pointer to a
//                          SETRESULT_INFO data structure.
//
//                              hSetResult: specified the common UI property
//                                          sheet page handle which added by
//                                          this function using
//                                          CPSFUNC_ADD_xxx indicies.
//
//                                  Result: Specified the Result to be set to
//                                          this pfnPropSheetUI() form the
//                                          hSetResult property sheet page
//                                          handle. If return value is greater
//                                          than zero then the value in this
//                                          Result field will be set to its
//                                          parent if one exist, at this case
//                                          this function can alter the Result
//                                          field value for its parent.
//
//                          * Returned greater than zero to continue send to
//                            its parent, else it stop sending the Result filed
//                            value to its parent.
//
//
//                      PROPSHEETUI_REASON_GET_ICON
//
//                          The reason is used to retrived the Icon which
//                          represent this pfnPropSheetUI().
//
//                          lParam is a pointer to PROPSHEETUI_GETICON_INFO '
//                          data structure.  Fields in PROPSHEETUI_GETICON_INFO
//                          data structure are set to following
//
//                              cxIcon = cx Icon size in pixel
//                              cyIcon = cy Icon size in pixel
//                              hIcon  = Initial to NULL, and this function
//                                       must put the created icon handle in
//                                       this field before return.
//
//
//                          * Return > 0 to indicate sucesful (hIcon is the
//                            requested icon handle).   Return = 0 to indicate
//                            no icon available, or return < 0 to indicate an
//                            error.
//
//              *NOTE*
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    user defined DWORD data in the PROPSHEETUI_INFO data
//                    structure's UserData field.
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    pfnPropSheetUI() DWORD result in PROPSHEETUI_INFO data
//                    structure's Result field.
//
//
//  hComPropSheet   - Handle to the COMPROPSHEETPAGE which this function should
//                    used as hComPropSheet parameter when calling
//                    pfnComPropSheet() to add or delete common UI property
//                    sheet pages.  The hComPropSheet is the instance handle to
//                    pfnPropSheetUI() function.
//
//  pfnComPropSheet - Pointer to the common UI callback function which for the
//                    pfnPropSheetUI() to add, delete, set user data, for a
//                    completed set of callback, see CPSFUNC_xxx descriptions
//                    above.
//
//  lParamInit      - The lParam originally passed duning the the first call
//                    reason PROPSHEETUI_REASON_INIT.  The lParamInit will be
//                    passed to each PROPSHEETUI_REASON_xxx calls.
//
//  UserData        - the UserData field is an IN and OUT parameter for each
//                    of the Reason,
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Initial set to zero (0).
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_SET_RESULT
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                           IN: The UserData specified at time when returned
//                               from the previous PROPSHEETUI_REASON_xxx
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
// Result           - The Result field is an IN and OUT parameter for each of
//                    the reason.
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Set to zero (0).
//
//                          OUT: Set to default result of this PropSheetUI()
//                               function.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                           IN: The current 'Result' returned from previous
//                               PROPSHEETUI_REASON_xxx function.
//
//                          OUT: Set the new result of this PropSheetUI()
//                               function.
//
//


#define PSUIHDRF_OBSOLETE       0x0001
#define PSUIHDRF_NOAPPLYNOW     0x0002
#define PSUIHDRF_PROPTITLE      0x0004
#define PSUIHDRF_USEHICON       0x0008
#define PSUIHDRF_DEFTITLE       0x0010
#define PSUIHDRF_EXACT_PTITLE   0x0020

typedef struct _PROPSHEETUI_INFO_HEADER {
    WORD                    cbSize;
    WORD                    Flags;
    LPTSTR                  pTitle;
    HWND                    hWndParent;
    HINSTANCE               hInst;
    union {
        HICON               hIcon;
        ULONG_PTR           IconID;
        } DUMMYUNIONNAME;
    } PROPSHEETUI_INFO_HEADER, *PPROPSHEETUI_INFO_HEADER;

//
// PROPSHEETUI_INFO_HEADER
//
//  This data structure is used when common UI ready to pop-up the property
//  sheet page dialog boxes and it asked caller to provide more information.
//
//  Common property sheet UI passed this data structure as lParam when it call
//  provided pfnPropSheetUI() with PROPSHEETUI_REASON_GET_INFO_HEADER reason.
//
//
//  cbSize      - size of this structure
//
//  Flags       - PSUIHDRF_xxxx flags
//
//                  PSUIHDRF_OBSOLETE
//
//                      Not used, must not set this bit
//
//
//                  PSUIHDRF_NOAPPLYNOW
//
//                      Remove 'Apply Now' button.
//
//
//                  PSUIHDRF_PROPTITLE
//
//                      Automatically include 'Properties' in the title bar
//
//
//                  PSUIHDRF_USEHICON
//
//                      If this bit is specified then hIcon union field is
//                      a valid handle to the icon otherwise the IconID is
//                      the either caller's resource ID or common UI standard
//                      icon ID.
//
//                  PSUIHDRF_DEFTITLE
//
//                      Automatically include 'Default' in the title bar, the
//                      'Default' always added right after pTitle and before
//                      'Properties' if PSUIHDRF_PROPTITLE flag is set.
//
//                  PSUIHDRF_EXACT_PTITLE
//
//                      This flag indicate the pTitle set in this structure
//                      will be use without any modification by the compstui
//                      ie. compstui will not modified pTitle in any way and
//                      it will ignored PSUIHDRF_PROPTITLE, PSUIHDRF_DEFTITLE
//
//
//  pTitle      - Pointer to the NULL terminated caption name for the
//                property sheets.
//
//                  ** See LPTSTR typedef description above
//
//  hWndParent  - The handle of the window which will be parent of the common
//                UI property sheets, if NULL then current active window for
//                the calling thread is used.
//
//  hInst       - the caller's handle to its instance.  Commom UI use this
//                handle to load caller's icon and other resources.
//
//  hIcon
//  IconID      - Specified the icon which put on the title bar, it either a
//                handle to the icon or a icon resource ID depends on the
//                PSUIHDRF_USEHICON flag.
//



//
// LONG
// CommonPropertySheetUI(
//     HWND            hWndOwner,
//     PFNPROPSHEETUI  pfnPropSheetUI,
//     LPARAM          lParam,
//     LPDWORD         pResult
//     );
//
//
// The CommonPropSheetUI is the main entry point for the common property sheet
// user interface.   The original caller that wish to using common UI to pop-up
// property sheet will call this function and passed its own PFNPROPSHEETUI
// function address and a long parameter.
//
// If pfnPropSheetUI function return a LONG number greater than zero (0) then
// common UI will pop-up the property sheet page dialog boxes, when Property
// sheet pages is finished. (either hit Ok or Cancel) it will return the
// result of CPSUI_xxxx back to the caller.
//
// If pfnPropSheetUI function return a LONG number equal or less than zero (0)
// then it will return the CPSUI_CANCEL back to caller without pop-up the
// property sheet page dialog boxes.
//
//
//  Parameters:
//
//      hWndOwner       - Window handle for the owner of this proerty sheet
//                        pages dialog boxes.
//
//      pfnPropSheetUI  - a PFNPROPSHEETUI function pointer which is used by
//                        the caller to add its property sheet pages.
//
//      lParam          - a long parameter will be passed to the pfnPropSheetUI
//                        funciton.  The common UI called the pfnPropSheetUI as
//
//                          PROPSHEETUI_INFO    PSUIInfo;
//
//                          pfnPropSheetUI(&PSUIInfo, lParam);
//
//                        The caller must use pfnComPropSheet() to add/delete
//                        pages.  When it is done adding pages, it retuned
//                        greater than zero to indicate successful, and return
//                        less or equal to zero to indicate failure.
//
//      pResult         - a pointer to DWORD which received the final result
//                        of pfnPropSheetUI() funciton, this result is a copy
//                        from Result field of PROPSHEETUI_INFO data structure
//                        which passed to the pfnPropSheetUI() as the first
//                        parameter.  The pResult only will be set if the
//                        returned value from CommonPropertySheetUI() is not
//                        ERR_CPSUI_xxx.
//
//                        if pResult is NULL then common UI will not return
//                        pfnPropSheetUI()'s result back.
//
//
//  Return Value:
//
//      LONG    - < 0                   - property page does not displayed and
//                                        ERR_CPSUI_xxx is the error code
//                CPSUI_OK              - property page displayed.
//                CPSUI_RESTARTWINDOWS  - property page displayed and need to
//                                        restart window to take effect
//                CPSUI_REBOOTSYSTEM    - property page dispalyed and need
//                                        to reboot system to take effect
//
//


LONG
APIENTRY
CommonPropertySheetUIA(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

LONG
APIENTRY
CommonPropertySheetUIW(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );


#ifdef UNICODE
#define CommonPropertySheetUI   CommonPropertySheetUIW
#else
#define CommonPropertySheetUI   CommonPropertySheetUIA
#endif



//
// GetCPSUIUserData() and SetCPSUIUserData() is used for the pages added
// by the CPSFUNC_ADD_PCOMPROPSHEETUI.  The caller add this function and has
// sub class dialog procedure should not set DWLP_USERDATA but calling these
// function instead, otherwise the system can failed.
//

ULONG_PTR
APIENTRY
GetCPSUIUserData(
    HWND    hDlg
    );

BOOL
APIENTRY
SetCPSUIUserData(
    HWND        hDlg,
    ULONG_PTR   CPSUIUserData
    );


#define CPSUI_CANCEL                        0
#define CPSUI_OK                            1
#define CPSUI_RESTARTWINDOWS                2
#define CPSUI_REBOOTSYSTEM                  3

#define ERR_CPSUI_GETLASTERROR              -1
#define ERR_CPSUI_ALLOCMEM_FAILED           -2
#define ERR_CPSUI_INVALID_PDATA             -3
#define ERR_CPSUI_INVALID_LPARAM            -4
#define ERR_CPSUI_NULL_HINST                -5
#define ERR_CPSUI_NULL_CALLERNAME           -6
#define ERR_CPSUI_NULL_OPTITEMNAME          -7
#define ERR_CPSUI_NO_PROPSHEETPAGE          -8
#define ERR_CPSUI_TOO_MANY_PROPSHEETPAGES   -9
#define ERR_CPSUI_CREATEPROPPAGE_FAILED     -10
#define ERR_CPSUI_MORE_THAN_ONE_TVPAGE      -11
#define ERR_CPSUI_MORE_THAN_ONE_STDPAGE     -12
#define ERR_CPSUI_INVALID_PDLGPAGE          -13
#define ERR_CPSUI_INVALID_DLGPAGE_CBSIZE    -14
#define ERR_CPSUI_TOO_MANY_DLGPAGES         -15
#define ERR_CPSUI_INVALID_DLGPAGEIDX        -16
#define ERR_CPSUI_SUBITEM_DIFF_DLGPAGEIDX   -17
#define ERR_CPSUI_NULL_POPTITEM             -18
#define ERR_CPSUI_INVALID_OPTITEM_CBSIZE    -19
#define ERR_CPSUI_INVALID_OPTTYPE_CBSIZE    -20
#define ERR_CPSUI_INVALID_OPTTYPE_COUNT     -21
#define ERR_CPSUI_NULL_POPTPARAM            -22
#define ERR_CPSUI_INVALID_OPTPARAM_CBSIZE   -23
#define ERR_CPSUI_INVALID_EDITBOX_PSEL      -24
#define ERR_CPSUI_INVALID_EDITBOX_BUF_SIZE  -25
#define ERR_CPSUI_INVALID_ECB_CBSIZE        -26
#define ERR_CPSUI_NULL_ECB_PTITLE           -27
#define ERR_CPSUI_NULL_ECB_PCHECKEDNAME     -28
#define ERR_CPSUI_INVALID_DMPUBID           -29
#define ERR_CPSUI_INVALID_DMPUB_TVOT        -30
#define ERR_CPSUI_CREATE_TRACKBAR_FAILED    -31
#define ERR_CPSUI_CREATE_UDARROW_FAILED     -32
#define ERR_CPSUI_CREATE_IMAGELIST_FAILED   -33
#define ERR_CPSUI_INVALID_TVOT_TYPE         -34
#define ERR_CPSUI_INVALID_LBCB_TYPE         -35
#define ERR_CPSUI_SUBITEM_DIFF_OPTIF_HIDE   -36
#define ERR_CPSUI_INVALID_PUSHBUTTON_TYPE   -38
#define ERR_CPSUI_INVALID_EXTPUSH_CBSIZE    -39
#define ERR_CPSUI_NULL_EXTPUSH_DLGPROC      -40
#define ERR_CPSUI_NO_EXTPUSH_DLGTEMPLATEID  -41
#define ERR_CPSUI_NULL_EXTPUSH_CALLBACK     -42
#define ERR_CPSUI_DMCOPIES_USE_EXTPUSH      -43
#define ERR_CPSUI_ZERO_OPTITEM              -44


#define ERR_CPSUI_FUNCTION_NOT_IMPLEMENTED  -9999
#define ERR_CPSUI_INTERNAL_ERROR            -10000

#endif  // (!defined(RC_INVOKED))



//
//****************************************************************************
//*                                                                          *
//*      Common Property Sheet UI resource ID for the ICONs and STRINGs      *
//*                                                                          *
//* The Resource ID from 64000 to 65535 are reserved for common UI and must  *
//* not used as caller resource ID else the string, icon loading will not be *
//* correct.                                                                 *
//*                                                                          *
//****************************************************************************
//


//
// Common UI standard 32x32, 16x16 color and monochrome Icon IDs
//

#define IDI_CPSUI_ICONID_FIRST          64000

#define IDI_CPSUI_EMPTY                 64000
#define IDI_CPSUI_SEL_NONE              64001
#define IDI_CPSUI_WARNING               64002
#define IDI_CPSUI_NO                    64003
#define IDI_CPSUI_YES                   64004
#define IDI_CPSUI_FALSE                 64005
#define IDI_CPSUI_TRUE                  64006
#define IDI_CPSUI_OFF                   64007
#define IDI_CPSUI_ON                    64008
#define IDI_CPSUI_PAPER_OUTPUT          64009
#define IDI_CPSUI_ENVELOPE              64010
#define IDI_CPSUI_MEM                   64011
#define IDI_CPSUI_FONTCARTHDR           64012
#define IDI_CPSUI_FONTCART              64013
#define IDI_CPSUI_STAPLER_ON            64014
#define IDI_CPSUI_STAPLER_OFF           64015
#define IDI_CPSUI_HT_HOST               64016
#define IDI_CPSUI_HT_DEVICE             64017
#define IDI_CPSUI_TT_PRINTASGRAPHIC     64018
#define IDI_CPSUI_TT_DOWNLOADSOFT       64019
#define IDI_CPSUI_TT_DOWNLOADVECT       64020
#define IDI_CPSUI_TT_SUBDEV             64021
#define IDI_CPSUI_PORTRAIT              64022
#define IDI_CPSUI_LANDSCAPE             64023
#define IDI_CPSUI_ROT_LAND              64024
#define IDI_CPSUI_AUTOSEL               64025
#define IDI_CPSUI_PAPER_TRAY            64026
#define IDI_CPSUI_PAPER_TRAY2           64027
#define IDI_CPSUI_PAPER_TRAY3           64028
#define IDI_CPSUI_TRANSPARENT           64029
#define IDI_CPSUI_COLLATE               64030
#define IDI_CPSUI_DUPLEX_NONE           64031
#define IDI_CPSUI_DUPLEX_HORZ           64032
#define IDI_CPSUI_DUPLEX_VERT           64033
#define IDI_CPSUI_RES_DRAFT             64034
#define IDI_CPSUI_RES_LOW               64035
#define IDI_CPSUI_RES_MEDIUM            64036
#define IDI_CPSUI_RES_HIGH              64037
#define IDI_CPSUI_RES_PRESENTATION      64038
#define IDI_CPSUI_MONO                  64039
#define IDI_CPSUI_COLOR                 64040
#define IDI_CPSUI_DITHER_NONE           64041
#define IDI_CPSUI_DITHER_COARSE         64042
#define IDI_CPSUI_DITHER_FINE           64043
#define IDI_CPSUI_DITHER_LINEART        64044
#define IDI_CPSUI_SCALING               64045
#define IDI_CPSUI_COPY                  64046
#define IDI_CPSUI_HTCLRADJ              64047
#define IDI_CPSUI_HALFTONE_SETUP        64048
#define IDI_CPSUI_WATERMARK             64049
#define IDI_CPSUI_ERROR                 64050
#define IDI_CPSUI_ICM_OPTION            64051
#define IDI_CPSUI_ICM_METHOD            64052
#define IDI_CPSUI_ICM_INTENT            64053
#define IDI_CPSUI_STD_FORM              64054
#define IDI_CPSUI_OUTBIN                64055
#define IDI_CPSUI_OUTPUT                64056
#define IDI_CPSUI_GRAPHIC               64057
#define IDI_CPSUI_ADVANCE               64058
#define IDI_CPSUI_DOCUMENT              64059
#define IDI_CPSUI_DEVICE                64060
#define IDI_CPSUI_DEVICE2               64061
#define IDI_CPSUI_PRINTER               64062
#define IDI_CPSUI_PRINTER2              64063
#define IDI_CPSUI_PRINTER3              64064
#define IDI_CPSUI_PRINTER4              64065
#define IDI_CPSUI_OPTION                64066
#define IDI_CPSUI_OPTION2               64067
#define IDI_CPSUI_STOP                  64068
#define IDI_CPSUI_NOTINSTALLED          64069
#define IDI_CPSUI_WARNING_OVERLAY       64070
#define IDI_CPSUI_STOP_WARNING_OVERLAY  64071
#define IDI_CPSUI_GENERIC_OPTION        64072
#define IDI_CPSUI_GENERIC_ITEM          64073
#define IDI_CPSUI_RUN_DIALOG            64074
#define IDI_CPSUI_QUESTION              64075
#define IDI_CPSUI_FORMTRAYASSIGN        64076
#define IDI_CPSUI_PRINTER_FOLDER        64077
#define IDI_CPSUI_INSTALLABLE_OPTION    64078
#define IDI_CPSUI_PRINTER_FEATURE       64079
#define IDI_CPSUI_DEVICE_FEATURE        64080
#define IDI_CPSUI_FONTSUB               64081
#define IDI_CPSUI_POSTSCRIPT            64082
#define IDI_CPSUI_TELEPHONE             64083
#define IDI_CPSUI_DUPLEX_NONE_L         64084
#define IDI_CPSUI_DUPLEX_HORZ_L         64085
#define IDI_CPSUI_DUPLEX_VERT_L         64086
#define IDI_CPSUI_LF_PEN_PLOTTER        64087
#define IDI_CPSUI_SF_PEN_PLOTTER        64088
#define IDI_CPSUI_LF_RASTER_PLOTTER     64089
#define IDI_CPSUI_SF_RASTER_PLOTTER     64090
#define IDI_CPSUI_ROLL_PAPER            64091
#define IDI_CPSUI_PEN_CARROUSEL         64092
#define IDI_CPSUI_PLOTTER_PEN           64093
#define IDI_CPSUI_MANUAL_FEED           64094
#define IDI_CPSUI_FAX                   64095
#define IDI_CPSUI_PAGE_PROTECT          64096
#define IDI_CPSUI_ENVELOPE_FEED         64097
#define IDI_CPSUI_FONTCART_SLOT         64098
#define IDI_CPSUI_LAYOUT_BMP_PORTRAIT   64099
#define IDI_CPSUI_LAYOUT_BMP_ARROWL     64100
#define IDI_CPSUI_LAYOUT_BMP_ARROWS     64101
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETL   64102
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETP   64103
#define IDI_CPSUI_ICONID_LAST           64103

//
// Common UI standard String IDs
//


#define IDS_CPSUI_STRID_FIRST           64700

#define IDS_CPSUI_SETUP                 64700
#define IDS_CPSUI_MORE                  64701
#define IDS_CPSUI_CHANGE                64702
#define IDS_CPSUI_OPTION                64703
#define IDS_CPSUI_OF                    64704
#define IDS_CPSUI_RANGE_FROM            64705
#define IDS_CPSUI_TO                    64706
#define IDS_CPSUI_COLON_SEP             64707
#define IDS_CPSUI_LEFT_ANGLE            64708
#define IDS_CPSUI_RIGHT_ANGLE           64709
#define IDS_CPSUI_SLASH_SEP             64710
#define IDS_CPSUI_PERCENT               64711
#define IDS_CPSUI_LBCB_NOSEL            64712
#define IDS_CPSUI_PROPERTIES            64713
#define IDS_CPSUI_DEFAULTDOCUMENT       64714
#define IDS_CPSUI_DOCUMENT              64715
#define IDS_CPSUI_ADVANCEDOCUMENT       64716
#define IDS_CPSUI_PRINTER               64717
#define IDS_CPSUI_AUTOSELECT            64718
#define IDS_CPSUI_PAPER_OUTPUT          64719
#define IDS_CPSUI_GRAPHIC               64720
#define IDS_CPSUI_OPTIONS               64721
#define IDS_CPSUI_ADVANCED              64722
#define IDS_CPSUI_STDDOCPROPTAB         64723
#define IDS_CPSUI_STDDOCPROPTVTAB       64724
#define IDS_CPSUI_DEVICEOPTIONS         64725
#define IDS_CPSUI_FALSE                 64726
#define IDS_CPSUI_TRUE                  64727
#define IDS_CPSUI_NO                    64728
#define IDS_CPSUI_YES                   64729
#define IDS_CPSUI_OFF                   64730
#define IDS_CPSUI_ON                    64731
#define IDS_CPSUI_DEFAULT               64732
#define IDS_CPSUI_ERROR                 64733
#define IDS_CPSUI_NONE                  64734
#define IDS_CPSUI_NOT                   64735
#define IDS_CPSUI_EXIST                 64736
#define IDS_CPSUI_NOTINSTALLED          64737
#define IDS_CPSUI_ORIENTATION           64738
#define IDS_CPSUI_SCALING               64739
#define IDS_CPSUI_NUM_OF_COPIES         64740
#define IDS_CPSUI_SOURCE                64741
#define IDS_CPSUI_PRINTQUALITY          64742
#define IDS_CPSUI_RESOLUTION            64743
#define IDS_CPSUI_COLOR_APPERANCE       64744
#define IDS_CPSUI_DUPLEX                64745
#define IDS_CPSUI_TTOPTION              64746
#define IDS_CPSUI_FORMNAME              64747
#define IDS_CPSUI_ICM                   64748
#define IDS_CPSUI_ICMMETHOD             64749
#define IDS_CPSUI_ICMINTENT             64750
#define IDS_CPSUI_MEDIA                 64751
#define IDS_CPSUI_DITHERING             64752
#define IDS_CPSUI_PORTRAIT              64753
#define IDS_CPSUI_LANDSCAPE             64754
#define IDS_CPSUI_ROT_LAND              64755
#define IDS_CPSUI_COLLATE               64756
#define IDS_CPSUI_COLLATED              64757
#define IDS_CPSUI_PRINTFLDSETTING       64758
#define IDS_CPSUI_DRAFT                 64759
#define IDS_CPSUI_LOW                   64760
#define IDS_CPSUI_MEDIUM                64761
#define IDS_CPSUI_HIGH                  64762
#define IDS_CPSUI_PRESENTATION          64763
#define IDS_CPSUI_COLOR                 64764
#define IDS_CPSUI_GRAYSCALE             64765
#define IDS_CPSUI_MONOCHROME            64766
#define IDS_CPSUI_SIMPLEX               64767
#define IDS_CPSUI_HORIZONTAL            64768
#define IDS_CPSUI_VERTICAL              64769
#define IDS_CPSUI_LONG_SIDE             64770
#define IDS_CPSUI_SHORT_SIDE            64771
#define IDS_CPSUI_TT_PRINTASGRAPHIC     64772
#define IDS_CPSUI_TT_DOWNLOADSOFT       64773
#define IDS_CPSUI_TT_DOWNLOADVECT       64774
#define IDS_CPSUI_TT_SUBDEV             64775
#define IDS_CPSUI_ICM_BLACKWHITE        64776
#define IDS_CPSUI_ICM_NO                64777
#define IDS_CPSUI_ICM_YES               64778
#define IDS_CPSUI_ICM_SATURATION        64779
#define IDS_CPSUI_ICM_CONTRAST          64780
#define IDS_CPSUI_ICM_COLORMETRIC       64781
#define IDS_CPSUI_STANDARD              64782
#define IDS_CPSUI_GLOSSY                64783
#define IDS_CPSUI_TRANSPARENCY          64784
#define IDS_CPSUI_REGULAR               64785
#define IDS_CPSUI_BOND                  64786
#define IDS_CPSUI_COARSE                64787
#define IDS_CPSUI_FINE                  64788
#define IDS_CPSUI_LINEART               64789
#define IDS_CPSUI_ERRDIFFUSE            64790
#define IDS_CPSUI_HALFTONE              64791
#define IDS_CPSUI_HTCLRADJ              64792
#define IDS_CPSUI_USE_HOST_HT           64793
#define IDS_CPSUI_USE_DEVICE_HT         64794
#define IDS_CPSUI_USE_PRINTER_HT        64795
#define IDS_CPSUI_OUTBINASSIGN          64796
#define IDS_CPSUI_WATERMARK             64797
#define IDS_CPSUI_FORMTRAYASSIGN        64798
#define IDS_CPSUI_UPPER_TRAY            64799
#define IDS_CPSUI_ONLYONE               64800
#define IDS_CPSUI_LOWER_TRAY            64801
#define IDS_CPSUI_MIDDLE_TRAY           64802
#define IDS_CPSUI_MANUAL_TRAY           64803
#define IDS_CPSUI_ENVELOPE_TRAY         64804
#define IDS_CPSUI_ENVMANUAL_TRAY        64805
#define IDS_CPSUI_TRACTOR_TRAY          64806
#define IDS_CPSUI_SMALLFMT_TRAY         64807
#define IDS_CPSUI_LARGEFMT_TRAY         64808
#define IDS_CPSUI_LARGECAP_TRAY         64809
#define IDS_CPSUI_CASSETTE_TRAY         64810
#define IDS_CPSUI_DEFAULT_TRAY          64811
#define IDS_CPSUI_FORMSOURCE            64812
#define IDS_CPSUI_MANUALFEED            64813
#define IDS_CPSUI_PRINTERMEM_KB         64814
#define IDS_CPSUI_PRINTERMEM_MB         64815
#define IDS_CPSUI_PAGEPROTECT           64816
#define IDS_CPSUI_HALFTONE_SETUP        64817
#define IDS_CPSUI_INSTFONTCART          64818
#define IDS_CPSUI_SLOT1                 64819
#define IDS_CPSUI_SLOT2                 64820
#define IDS_CPSUI_SLOT3                 64821
#define IDS_CPSUI_SLOT4                 64822
#define IDS_CPSUI_LEFT_SLOT             64823
#define IDS_CPSUI_RIGHT_SLOT            64824
#define IDS_CPSUI_STAPLER               64825
#define IDS_CPSUI_STAPLER_ON            64826
#define IDS_CPSUI_STAPLER_OFF           64827
#define IDS_CPSUI_STACKER               64828
#define IDS_CPSUI_MAILBOX               64829
#define IDS_CPSUI_COPY                  64830
#define IDS_CPSUI_COPIES                64831
#define IDS_CPSUI_TOTAL                 64832
#define IDS_CPSUI_MAKE                  64833
#define IDS_CPSUI_PRINT                 64834
#define IDS_CPSUI_FAX                   64835
#define IDS_CPSUI_PLOT                  64836
#define IDS_CPSUI_SLOW                  64837
#define IDS_CPSUI_FAST                  64838
#define IDS_CPSUI_ROTATED               64839
#define IDS_CPSUI_RESET                 64840
#define IDS_CPSUI_ALL                   64841
#define IDS_CPSUI_DEVICE                64842
#define IDS_CPSUI_SETTINGS              64843
#define IDS_CPSUI_REVERT                64844
#define IDS_CPSUI_CHANGES               64845
#define IDS_CPSUI_CHANGED               64846
#define IDS_CPSUI_WARNING               64847
#define IDS_CPSUI_ABOUT                 64848
#define IDS_CPSUI_VERSION               64849
#define IDS_CPSUI_NO_NAME               64850
#define IDS_CPSUI_SETTING               64851
#define IDS_CPSUI_DEVICE_SETTINGS       64852
#define IDS_CPSUI_STDDOCPROPTAB1        64853
#define IDS_CPSUI_STDDOCPROPTAB2        64854
#define IDS_CPSUI_PAGEORDER             64855
#define IDS_CPSUI_FRONTTOBACK           64856
#define IDS_CPSUI_BACKTOFRONT           64857
#define IDS_CPSUI_QUALITY_SETTINGS      64858
#define IDS_CPSUI_QUALITY_DRAFT         64859
#define IDS_CPSUI_QUALITY_BETTER        64860
#define IDS_CPSUI_QUALITY_BEST          64861
#define IDS_CPSUI_QUALITY_CUSTOM        64862
#define IDS_CPSUI_OUTPUTBIN             64863
#define IDS_CPSUI_NUP                   64864
#define IDS_CPSUI_NUP_NORMAL            64865
#define IDS_CPSUI_NUP_TWOUP             64866
#define IDS_CPSUI_NUP_FOURUP            64867
#define IDS_CPSUI_NUP_SIXUP             64868
#define IDS_CPSUI_NUP_NINEUP            64869
#define IDS_CPSUI_NUP_SIXTEENUP         64870
#define IDS_CPSUI_SIDE1                 64871
#define IDS_CPSUI_SIDE2                 64872
#define IDS_CPSUI_BOOKLET               64873

#define IDS_CPSUI_STRID_LAST            64873


#ifdef __cplusplus
}
#endif

#endif      // _COMPSTUI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\gldrv.h ===
/*++ BUILD Version: 0001

Copyright (c) 1985-94, Microsoft Corporation

Module Name:

    gldrv.h

Abstract:

    Private entry points, defines and types for Installable OpenGL DDI.

--*/

#ifndef _GLDRV_
#define _GLDRV_

typedef struct _GLDISPATCHTABLE {
    void      (APIENTRY *glNewList                )( GLuint list, GLenum mode );
    void      (APIENTRY *glEndList                )( void );
    void      (APIENTRY *glCallList               )( GLuint list );
    void      (APIENTRY *glCallLists              )( GLsizei n, GLenum type, const GLvoid *lists );
    void      (APIENTRY *glDeleteLists            )( GLuint list, GLsizei range );
    GLuint    (APIENTRY *glGenLists               )( GLsizei range );
    void      (APIENTRY *glListBase               )( GLuint base );
    void      (APIENTRY *glBegin                  )( GLenum mode );
    void      (APIENTRY *glBitmap                 )( GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap );
    void      (APIENTRY *glColor3b                )( GLbyte red, GLbyte green, GLbyte blue );
    void      (APIENTRY *glColor3bv               )( const GLbyte *v );
    void      (APIENTRY *glColor3d                )( GLdouble red, GLdouble green, GLdouble blue );
    void      (APIENTRY *glColor3dv               )( const GLdouble *v );
    void      (APIENTRY *glColor3f                )( GLfloat red, GLfloat green, GLfloat blue );
    void      (APIENTRY *glColor3fv               )( const GLfloat *v );
    void      (APIENTRY *glColor3i                )( GLint red, GLint green, GLint blue );
    void      (APIENTRY *glColor3iv               )( const GLint *v );
    void      (APIENTRY *glColor3s                )( GLshort red, GLshort green, GLshort blue );
    void      (APIENTRY *glColor3sv               )( const GLshort *v );
    void      (APIENTRY *glColor3ub               )( GLubyte red, GLubyte green, GLubyte blue );
    void      (APIENTRY *glColor3ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor3ui               )( GLuint red, GLuint green, GLuint blue );
    void      (APIENTRY *glColor3uiv              )( const GLuint *v );
    void      (APIENTRY *glColor3us               )( GLushort red, GLushort green, GLushort blue );
    void      (APIENTRY *glColor3usv              )( const GLushort *v );
    void      (APIENTRY *glColor4b                )( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha );
    void      (APIENTRY *glColor4bv               )( const GLbyte *v );
    void      (APIENTRY *glColor4d                )( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha );
    void      (APIENTRY *glColor4dv               )( const GLdouble *v );
    void      (APIENTRY *glColor4f                )( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
    void      (APIENTRY *glColor4fv               )( const GLfloat *v );
    void      (APIENTRY *glColor4i                )( GLint red, GLint green, GLint blue, GLint alpha );
    void      (APIENTRY *glColor4iv               )( const GLint *v );
    void      (APIENTRY *glColor4s                )( GLshort red, GLshort green, GLshort blue, GLshort alpha );
    void      (APIENTRY *glColor4sv               )( const GLshort *v );
    void      (APIENTRY *glColor4ub               )( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha );
    void      (APIENTRY *glColor4ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor4ui               )( GLuint red, GLuint green, GLuint blue, GLuint alpha );
    void      (APIENTRY *glColor4uiv              )( const GLuint *v );
    void      (APIENTRY *glColor4us               )( GLushort red, GLushort green, GLushort blue, GLushort alpha );
    void      (APIENTRY *glColor4usv              )( const GLushort *v );
    void      (APIENTRY *glEdgeFlag               )( GLboolean flag );
    void      (APIENTRY *glEdgeFlagv              )( const GLboolean *flag );
    void      (APIENTRY *glEnd                    )( void );
    void      (APIENTRY *glIndexd                 )( GLdouble c );
    void      (APIENTRY *glIndexdv                )( const GLdouble *c );
    void      (APIENTRY *glIndexf                 )( GLfloat c );
    void      (APIENTRY *glIndexfv                )( const GLfloat *c );
    void      (APIENTRY *glIndexi                 )( GLint c );
    void      (APIENTRY *glIndexiv                )( const GLint *c );
    void      (APIENTRY *glIndexs                 )( GLshort c );
    void      (APIENTRY *glIndexsv                )( const GLshort *c );
    void      (APIENTRY *glNormal3b               )( GLbyte nx, GLbyte ny, GLbyte nz );
    void      (APIENTRY *glNormal3bv              )( const GLbyte *v );
    void      (APIENTRY *glNormal3d               )( GLdouble nx, GLdouble ny, GLdouble nz );
    void      (APIENTRY *glNormal3dv              )( const GLdouble *v );
    void      (APIENTRY *glNormal3f               )( GLfloat nx, GLfloat ny, GLfloat nz );
    void      (APIENTRY *glNormal3fv              )( const GLfloat *v );
    void      (APIENTRY *glNormal3i               )( GLint nx, GLint ny, GLint nz );
    void      (APIENTRY *glNormal3iv              )( const GLint *v );
    void      (APIENTRY *glNormal3s               )( GLshort nx, GLshort ny, GLshort nz );
    void      (APIENTRY *glNormal3sv              )( const GLshort *v );
    void      (APIENTRY *glRasterPos2d            )( GLdouble x, GLdouble y );
    void      (APIENTRY *glRasterPos2dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos2f            )( GLfloat x, GLfloat y );
    void      (APIENTRY *glRasterPos2fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos2i            )( GLint x, GLint y );
    void      (APIENTRY *glRasterPos2iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos2s            )( GLshort x, GLshort y );
    void      (APIENTRY *glRasterPos2sv           )( const GLshort *v );
    void      (APIENTRY *glRasterPos3d            )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glRasterPos3dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos3f            )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glRasterPos3fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos3i            )( GLint x, GLint y, GLint z );
    void      (APIENTRY *glRasterPos3iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos3s            )( GLshort x, GLshort y, GLshort z );
    void      (APIENTRY *glRasterPos3sv           )( const GLshort *v );
    void      (APIENTRY *glRasterPos4d            )( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
    void      (APIENTRY *glRasterPos4dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos4f            )( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
    void      (APIENTRY *glRasterPos4fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos4i            )( GLint x, GLint y, GLint z, GLint w );
    void      (APIENTRY *glRasterPos4iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos4s            )( GLshort x, GLshort y, GLshort z, GLshort w );
    void      (APIENTRY *glRasterPos4sv           )( const GLshort *v );
    void      (APIENTRY *glRectd                  )( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 );
    void      (APIENTRY *glRectdv                 )( const GLdouble *v1, const GLdouble *v2 );
    void      (APIENTRY *glRectf                  )( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 );
    void      (APIENTRY *glRectfv                 )( const GLfloat *v1, const GLfloat *v2 );
    void      (APIENTRY *glRecti                  )( GLint x1, GLint y1, GLint x2, GLint y2 );
    void      (APIENTRY *glRectiv                 )( const GLint *v1, const GLint *v2 );
    void      (APIENTRY *glRects                  )( GLshort x1, GLshort y1, GLshort x2, GLshort y2 );
    void      (APIENTRY *glRectsv                 )( const GLshort *v1, const GLshort *v2 );
    void      (APIENTRY *glTexCoord1d             )( GLdouble s );
    void      (APIENTRY *glTexCoord1dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord1f             )( GLfloat s );
    void      (APIENTRY *glTexCoord1fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord1i             )( GLint s );
    void      (APIENTRY *glTexCoord1iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord1s             )( GLshort s );
    void      (APIENTRY *glTexCoord1sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord2d             )( GLdouble s, GLdouble t );
    void      (APIENTRY *glTexCoord2dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord2f             )( GLfloat s, GLfloat t );
    void      (APIENTRY *glTexCoord2fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord2i             )( GLint s, GLint t );
    void      (APIENTRY *glTexCoord2iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord2s             )( GLshort s, GLshort t );
    void      (APIENTRY *glTexCoord2sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord3d             )( GLdouble s, GLdouble t, GLdouble r );
    void      (APIENTRY *glTexCoord3dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord3f             )( GLfloat s, GLfloat t, GLfloat r );
    void      (APIENTRY *glTexCoord3fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord3i             )( GLint s, GLint t, GLint r );
    void      (APIENTRY *glTexCoord3iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord3s             )( GLshort s, GLshort t, GLshort r );
    void      (APIENTRY *glTexCoord3sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord4d             )( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
    void      (APIENTRY *glTexCoord4dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord4f             )( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
    void      (APIENTRY *glTexCoord4fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord4i             )( GLint s, GLint t, GLint r, GLint q );
    void      (APIENTRY *glTexCoord4iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord4s             )( GLshort s, GLshort t, GLshort r, GLshort q );
    void      (APIENTRY *glTexCoord4sv            )( const GLshort *v );
    void      (APIENTRY *glVertex2d               )( GLdouble x, GLdouble y );
    void      (APIENTRY *glVertex2dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex2f               )( GLfloat x, GLfloat y );
    void      (APIENTRY *glVertex2fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex2i               )( GLint x, GLint y );
    void      (APIENTRY *glVertex2iv              )( const GLint *v );
    void      (APIENTRY *glVertex2s               )( GLshort x, GLshort y );
    void      (APIENTRY *glVertex2sv              )( const GLshort *v );
    void      (APIENTRY *glVertex3d               )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glVertex3dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex3f               )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glVertex3fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex3i               )( GLint x, GLint y, GLint z );
    void      (APIENTRY *glVertex3iv              )( const GLint *v );
    void      (APIENTRY *glVertex3s               )( GLshort x, GLshort y, GLshort z );
    void      (APIENTRY *glVertex3sv              )( const GLshort *v );
    void      (APIENTRY *glVertex4d               )( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
    void      (APIENTRY *glVertex4dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex4f               )( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
    void      (APIENTRY *glVertex4fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex4i               )( GLint x, GLint y, GLint z, GLint w );
    void      (APIENTRY *glVertex4iv              )( const GLint *v );
    void      (APIENTRY *glVertex4s               )( GLshort x, GLshort y, GLshort z, GLshort w );
    void      (APIENTRY *glVertex4sv              )( const GLshort *v );
    void      (APIENTRY *glClipPlane              )( GLenum plane, const GLdouble *equation );
    void      (APIENTRY *glColorMaterial          )( GLenum face, GLenum mode );
    void      (APIENTRY *glCullFace               )( GLenum mode );
    void      (APIENTRY *glFogf                   )( GLenum pname, GLfloat param );
    void      (APIENTRY *glFogfv                  )( GLenum pname, const GLfloat *params );
    void      (APIENTRY *glFogi                   )( GLenum pname, GLint param );
    void      (APIENTRY *glFogiv                  )( GLenum pname, const GLint *params );
    void      (APIENTRY *glFrontFace              )( GLenum mode );
    void      (APIENTRY *glHint                   )( GLenum target, GLenum mode );
    void      (APIENTRY *glLightf                 )( GLenum light, GLenum pname, GLfloat param );
    void      (APIENTRY *glLightfv                )( GLenum light, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glLighti                 )( GLenum light, GLenum pname, GLint param );
    void      (APIENTRY *glLightiv                )( GLenum light, GLenum pname, const GLint *params );
    void      (APIENTRY *glLightModelf            )( GLenum pname, GLfloat param );
    void      (APIENTRY *glLightModelfv           )( GLenum pname, const GLfloat *params );
    void      (APIENTRY *glLightModeli            )( GLenum pname, GLint param );
    void      (APIENTRY *glLightModeliv           )( GLenum pname, const GLint *params );
    void      (APIENTRY *glLineStipple            )( GLint factor, GLushort pattern );
    void      (APIENTRY *glLineWidth              )( GLfloat width );
    void      (APIENTRY *glMaterialf              )( GLenum face, GLenum pname, GLfloat param );
    void      (APIENTRY *glMaterialfv             )( GLenum face, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glMateriali              )( GLenum face, GLenum pname, GLint param );
    void      (APIENTRY *glMaterialiv             )( GLenum face, GLenum pname, const GLint *params );
    void      (APIENTRY *glPointSize              )( GLfloat size );
    void      (APIENTRY *glPolygonMode            )( GLenum face, GLenum mode );
    void      (APIENTRY *glPolygonStipple         )( const GLubyte *mask );
    void      (APIENTRY *glScissor                )( GLint x, GLint y, GLsizei width, GLsizei height );
    void      (APIENTRY *glShadeModel             )( GLenum mode );
    void      (APIENTRY *glTexParameterf          )( GLenum target, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexParameterfv         )( GLenum target, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexParameteri          )( GLenum target, GLenum pname, GLint param );
    void      (APIENTRY *glTexParameteriv         )( GLenum target, GLenum pname, const GLint *params );
    void      (APIENTRY *glTexImage1D             )( GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glTexImage2D             )( GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glTexEnvf                )( GLenum target, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexEnvfv               )( GLenum target, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexEnvi                )( GLenum target, GLenum pname, GLint param );
    void      (APIENTRY *glTexEnviv               )( GLenum target, GLenum pname, const GLint *params );
    void      (APIENTRY *glTexGend                )( GLenum coord, GLenum pname, GLdouble param );
    void      (APIENTRY *glTexGendv               )( GLenum coord, GLenum pname, const GLdouble *params );
    void      (APIENTRY *glTexGenf                )( GLenum coord, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexGenfv               )( GLenum coord, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexGeni                )( GLenum coord, GLenum pname, GLint param );
    void      (APIENTRY *glTexGeniv               )( GLenum coord, GLenum pname, const GLint *params );
    void      (APIENTRY *glFeedbackBuffer         )( GLsizei size, GLenum type, GLfloat *buffer );
    void      (APIENTRY *glSelectBuffer           )( GLsizei size, GLuint *buffer );
    GLint     (APIENTRY *glRenderMode             )( GLenum mode );
    void      (APIENTRY *glInitNames              )( void );
    void      (APIENTRY *glLoadName               )( GLuint name );
    void      (APIENTRY *glPassThrough            )( GLfloat token );
    void      (APIENTRY *glPopName                )( void );
    void      (APIENTRY *glPushName               )( GLuint name );
    void      (APIENTRY *glDrawBuffer             )( GLenum mode );
    void      (APIENTRY *glClear                  )( GLbitfield mask );
    void      (APIENTRY *glClearAccum             )( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
    void      (APIENTRY *glClearIndex             )( GLfloat c );
    void      (APIENTRY *glClearColor             )( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha );
    void      (APIENTRY *glClearStencil           )( GLint s );
    void      (APIENTRY *glClearDepth             )( GLclampd depth );
    void      (APIENTRY *glStencilMask            )( GLuint mask );
    void      (APIENTRY *glColorMask              )( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha );
    void      (APIENTRY *glDepthMask              )( GLboolean flag );
    void      (APIENTRY *glIndexMask              )( GLuint mask );
    void      (APIENTRY *glAccum                  )( GLenum op, GLfloat value );
    void      (APIENTRY *glDisable                )( GLenum cap );
    void      (APIENTRY *glEnable                 )( GLenum cap );
    void      (APIENTRY *glFinish                 )( void );
    void      (APIENTRY *glFlush                  )( void );
    void      (APIENTRY *glPopAttrib              )( void );
    void      (APIENTRY *glPushAttrib             )( GLbitfield mask );
    void      (APIENTRY *glMap1d                  )( GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points );
    void      (APIENTRY *glMap1f                  )( GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points );
    void      (APIENTRY *glMap2d                  )( GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points );
    void      (APIENTRY *glMap2f                  )( GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points );
    void      (APIENTRY *glMapGrid1d              )( GLint un, GLdouble u1, GLdouble u2 );
    void      (APIENTRY *glMapGrid1f              )( GLint un, GLfloat u1, GLfloat u2 );
    void      (APIENTRY *glMapGrid2d              )( GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2 );
    void      (APIENTRY *glMapGrid2f              )( GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2 );
    void      (APIENTRY *glEvalCoord1d            )( GLdouble u );
    void      (APIENTRY *glEvalCoord1dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord1f            )( GLfloat u );
    void      (APIENTRY *glEvalCoord1fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalCoord2d            )( GLdouble u, GLdouble v );
    void      (APIENTRY *glEvalCoord2dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord2f            )( GLfloat u, GLfloat v );
    void      (APIENTRY *glEvalCoord2fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalMesh1              )( GLenum mode, GLint i1, GLint i2 );
    void      (APIENTRY *glEvalPoint1             )( GLint i );
    void      (APIENTRY *glEvalMesh2              )( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );
    void      (APIENTRY *glEvalPoint2             )( GLint i, GLint j );
    void      (APIENTRY *glAlphaFunc              )( GLenum func, GLclampf ref );
    void      (APIENTRY *glBlendFunc              )( GLenum sfactor, GLenum dfactor );
    void      (APIENTRY *glLogicOp                )( GLenum opcode );
    void      (APIENTRY *glStencilFunc            )( GLenum func, GLint ref, GLuint mask );
    void      (APIENTRY *glStencilOp              )( GLenum fail, GLenum zfail, GLenum zpass );
    void      (APIENTRY *glDepthFunc              )( GLenum func );
    void      (APIENTRY *glPixelZoom              )( GLfloat xfactor, GLfloat yfactor );
    void      (APIENTRY *glPixelTransferf         )( GLenum pname, GLfloat param );
    void      (APIENTRY *glPixelTransferi         )( GLenum pname, GLint param );
    void      (APIENTRY *glPixelStoref            )( GLenum pname, GLfloat param );
    void      (APIENTRY *glPixelStorei            )( GLenum pname, GLint param );
    void      (APIENTRY *glPixelMapfv             )( GLenum map, GLint mapsize, const GLfloat *values );
    void      (APIENTRY *glPixelMapuiv            )( GLenum map, GLint mapsize, const GLuint *values );
    void      (APIENTRY *glPixelMapusv            )( GLenum map, GLint mapsize, const GLushort *values );
    void      (APIENTRY *glReadBuffer             )( GLenum mode );
    void      (APIENTRY *glCopyPixels             )( GLint x, GLint y, GLsizei width, GLsizei height, GLenum type );
    void      (APIENTRY *glReadPixels             )( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels );
    void      (APIENTRY *glDrawPixels             )( GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glGetBooleanv            )( GLenum pname, GLboolean *params );
    void      (APIENTRY *glGetClipPlane           )( GLenum plane, GLdouble *equation );
    void      (APIENTRY *glGetDoublev             )( GLenum pname, GLdouble *params );
    GLenum    (APIENTRY *glGetError               )( void );
    void      (APIENTRY *glGetFloatv              )( GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetIntegerv            )( GLenum pname, GLint *params );
    void      (APIENTRY *glGetLightfv             )( GLenum light, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetLightiv             )( GLenum light, GLenum pname, GLint *params );
    void      (APIENTRY *glGetMapdv               )( GLenum target, GLenum query, GLdouble *v );
    void      (APIENTRY *glGetMapfv               )( GLenum target, GLenum query, GLfloat *v );
    void      (APIENTRY *glGetMapiv               )( GLenum target, GLenum query, GLint *v );
    void      (APIENTRY *glGetMaterialfv          )( GLenum face, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetMaterialiv          )( GLenum face, GLenum pname, GLint *params );
    void      (APIENTRY *glGetPixelMapfv          )( GLenum map, GLfloat *values );
    void      (APIENTRY *glGetPixelMapuiv         )( GLenum map, GLuint *values );
    void      (APIENTRY *glGetPixelMapusv         )( GLenum map, GLushort *values );
    void      (APIENTRY *glGetPolygonStipple      )( GLubyte *mask );
    const GLubyte * (APIENTRY *glGetString        )( GLenum name );
    void      (APIENTRY *glGetTexEnvfv            )( GLenum target, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexEnviv            )( GLenum target, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexGendv            )( GLenum coord, GLenum pname, GLdouble *params );
    void      (APIENTRY *glGetTexGenfv            )( GLenum coord, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexGeniv            )( GLenum coord, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexImage            )( GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels );
    void      (APIENTRY *glGetTexParameterfv      )( GLenum target, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexParameteriv      )( GLenum target, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexLevelParameterfv )( GLenum target, GLint level, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexLevelParameteriv )( GLenum target, GLint level, GLenum pname, GLint *params );
    GLboolean (APIENTRY *glIsEnabled              )( GLenum cap );
    GLboolean (APIENTRY *glIsList                 )( GLuint list );
    void      (APIENTRY *glDepthRange             )( GLclampd zNear, GLclampd zFar );
    void      (APIENTRY *glFrustum                )( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar );
    void      (APIENTRY *glLoadIdentity           )( void );
    void      (APIENTRY *glLoadMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glLoadMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glMatrixMode             )( GLenum mode );
    void      (APIENTRY *glMultMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glMultMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glOrtho                  )( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar );
    void      (APIENTRY *glPopMatrix              )( void );
    void      (APIENTRY *glPushMatrix             )( void );
    void      (APIENTRY *glRotated                )( GLdouble angle, GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glRotatef                )( GLfloat angle, GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glScaled                 )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glScalef                 )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glTranslated             )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glTranslatef             )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glViewport               )( GLint x, GLint y, GLsizei width, GLsizei height );
    // OpenGL version 1.0 entries end here

    // OpenGL version 1.1 entries begin here
    void      (APIENTRY *glArrayElement           )(GLint i);
    void      (APIENTRY *glBindTexture            )(GLenum target, GLuint texture);
    void      (APIENTRY *glColorPointer           )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glDisableClientState     )(GLenum array);
    void      (APIENTRY *glDrawArrays             )(GLenum mode, GLint first, GLsizei count);
    void      (APIENTRY *glDrawElements           )(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
    void      (APIENTRY *glEdgeFlagPointer        )(GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glEnableClientState      )(GLenum array);
    void      (APIENTRY *glIndexPointer           )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glIndexub                )(GLubyte c);
    void      (APIENTRY *glIndexubv               )(const GLubyte *c);
    void      (APIENTRY *glInterleavedArrays      )(GLenum format, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glNormalPointer          )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glPolygonOffset          )(GLfloat factor, GLfloat units);
    void      (APIENTRY *glTexCoordPointer        )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glVertexPointer          )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    GLboolean (APIENTRY *glAreTexturesResident    )(GLsizei n, const GLuint *textures, GLboolean *residences);
    void      (APIENTRY *glCopyTexImage1D         )(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
    void      (APIENTRY *glCopyTexImage2D         )(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
    void      (APIENTRY *glCopyTexSubImage1D      )(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    void      (APIENTRY *glCopyTexSubImage2D      )(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
    void      (APIENTRY *glDeleteTextures         )(GLsizei n, const GLuint *textures);
    void      (APIENTRY *glGenTextures            )(GLsizei n, GLuint *textures);
    void      (APIENTRY *glGetPointerv            )(GLenum pname, GLvoid* *params);
    GLboolean (APIENTRY *glIsTexture              )(GLuint texture);
    void      (APIENTRY *glPrioritizeTextures     )(GLsizei n, const GLuint *textures, const GLclampf *priorities);
    void      (APIENTRY *glTexSubImage1D          )(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
    void      (APIENTRY *glTexSubImage2D          )(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
    void      (APIENTRY *glPopClientAttrib        )(void);
    void      (APIENTRY *glPushClientAttrib       )(GLbitfield mask);
} GLDISPATCHTABLE, *PGLDISPATCHTABLE;

// OpenGL Client/Driver Procedure Table.

typedef struct _GLCLTPROCTABLE {
    int             cEntries;           // Number of function entries in table
    GLDISPATCHTABLE glDispatchTable;    // OpenGL function dispatch table
} GLCLTPROCTABLE, *PGLCLTPROCTABLE;

// Number of entries expected for various versions of OpenGL
#define OPENGL_VERSION_100_ENTRIES      306
#define OPENGL_VERSION_110_ENTRIES      336

// Driver GLRC handle.

typedef ULONG DHGLRC;

// SetProcTable function prototype for DrvSetContext.

typedef VOID (APIENTRY *PFN_SETPROCTABLE)(PGLCLTPROCTABLE);

// DrvSetCallbackProcs prototypes
typedef VOID   (APIENTRY *PFN_SETCURRENTVALUE)(VOID *pv);
typedef VOID  *(APIENTRY *PFN_GETCURRENTVALUE)(VOID);
typedef DHGLRC (APIENTRY *PFN_GETDHGLRC)(HGLRC hrc);

// Driver context function prototypes.

BOOL            APIENTRY DrvCopyContext(DHGLRC, DHGLRC, UINT);
DHGLRC          APIENTRY DrvCreateContext(HDC);
DHGLRC          APIENTRY DrvCreateLayerContext(HDC, int);
BOOL            APIENTRY DrvDeleteContext(DHGLRC);
PGLCLTPROCTABLE APIENTRY DrvSetContext(HDC,DHGLRC,PFN_SETPROCTABLE);
BOOL            APIENTRY DrvReleaseContext(DHGLRC);
BOOL            APIENTRY DrvValidateVersion(ULONG);
BOOL		APIENTRY DrvShareLists(DHGLRC, DHGLRC);
PROC            APIENTRY DrvGetProcAddress(LPCSTR);
VOID            APIENTRY DrvSetCallbackProcs(INT, PROC *);
BOOL            APIENTRY DrvDescribeLayerPlane(HDC, INT, INT, UINT,
                                               LPLAYERPLANEDESCRIPTOR);
INT             APIENTRY DrvSetLayerPaletteEntries(HDC, INT, INT, INT,
                                                   CONST COLORREF *);
INT             APIENTRY DrvGetLayerPaletteEntries(HDC, INT, INT, INT,
                                                   COLORREF *);
BOOL            APIENTRY DrvRealizeLayerPalette(HDC, INT, BOOL);
BOOL            APIENTRY DrvSwapLayerBuffers(HDC, UINT);

#if WINVER >= 0x500

typedef struct IDirectDrawSurface *LPDIRECTDRAWSURFACE;
typedef struct _DDSURFACEDESC *LPDDSURFACEDESC;

DHGLRC          APIENTRY DrvCreateDirectDrawContext(HDC, LPDIRECTDRAWSURFACE,
                                                    int);
int             APIENTRY DrvEnumTextureFormats(int, LPDDSURFACEDESC);
BOOL            APIENTRY DrvBindDirectDrawTexture(LPDIRECTDRAWSURFACE);
DWORD           APIENTRY DrvSwapMultipleBuffers(UINT cBuffers,
                                                CONST WGLSWAP *pgswap);

#endif // WINVER >= 0x500

// Input structure for OPENGL_CMD ExtEscape.

typedef struct _WNDOBJ WNDOBJ;
typedef struct _XLATEOBJ XLATEOBJ;

typedef struct _OPENGLCMD
{
    ULONG    ulSubEsc;
    FLONG    fl;
    WNDOBJ   *pwo;
    XLATEOBJ *pxo;
} OPENGLCMD, *POPENGLCMD;

#if WINVER >= 0x500

#define OPENGLCMD_MAXMULTI WGL_SWAPMULTIPLE_MAX

typedef struct _OPENGLCMDMULTI
{
    ULONG ulSubEsc;
    FLONG fl;
    ULONG cMulti;
    XLATEOBJ *pxo;
} OPENGLCMDMULTI, *POPENGLCMDMULTI;

#endif // WINVER >= 0x500

// Flags for OPENGL_CMD ExtEscape.

#define OGLCMD_NEEDWNDOBJ       0x01
#define OGLCMD_NEEDXLATEOBJ     0x02

#if WINVER >= 0x500
#define OGLCMD_MULTIWNDOBJ      0x04
#endif // WINVER >= 0x500

// OPENGL_GETINFO ExtEscape sub-escape numbers.  They are defined by Microsoft.

#define OPENGL_GETINFO_DRVNAME  0

// Input structure for OPENGL_GETINFO ExtEscape.

typedef struct _OPENGLGETINFO
{
    ULONG   ulSubEsc;
} OPENGLGETINFO, *POPENGLGETINFO;

// Input structure for OPENGL_GETINFO_DRVNAME ExtEscape.

typedef struct _GLDRVNAME
{
    OPENGLGETINFO   oglget;
} GLDRVNAME, *PGLDRVNAME;

// Output structure for OPENGL_GETINFO_DRVNAME ExtEscape.

typedef struct _GLDRVNAMERET
{
    ULONG   ulVersion;              // must be 1 for this version
    ULONG   ulDriverVersion;        // driver specific version number
    WCHAR   awch[MAX_PATH+1];
} GLDRVNAMERET, *PGLDRVNAMERET;

#endif /* _GLDRV_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\mcdrv.h ===
/******************************Module*Header*******************************\
* Module Name: mcdrv.h
*
* Server-side data structure for MCD driver interface.  These structures and
* values are used by the MCD driver to process calls made to the driver.
*
* Copyright (c) 1996-1997 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCDRV_H
#define _MCDRV_H

//
// The MCD version is defaulted to the most conservative version number.
// Override these defines if you wish to compile a driver with different
// version information.
//

#ifndef MCD_VER_MAJOR
#define MCD_VER_MAJOR               1
#endif

#ifndef MCD_VER_MINOR
#define MCD_VER_MINOR               0
#endif

#define MCD_MAX_USER_CLIP_PLANES    6

#define MCDRV_MEM_BUSY              1
#define MCDRV_MEM_NOT_BUSY          2

typedef ENUMRECTS MCDENUMRECTS;
typedef HANDLE MCDHANDLE;
typedef float MCDFLOAT;
typedef double MCDDOUBLE;

#define MCDENGDLLNAME	"MCDSRV32.DLL"
#define MCDFUNCS 3076

#define MCDRV_MEM_DMA   0x0001

#define MCDRV_TEXTURE_RESIDENT	0x0001

typedef struct _MCDRIVERINFO {
    ULONG verMajor;
    ULONG verMinor;
    ULONG verDriver;
    CHAR  idStr[200];
    ULONG drvMemFlags;
    ULONG drvBatchMemSizeMax;
} MCDDRIVERINFO;

typedef struct _MCDWINDOW
{
    RECTL clientRect;               // Rectangle describing current window
                                    //   client area
    RECTL clipBoundsRect;           // Bounding rectangle for the individual
                                    //   clipping rectangles
    MCDENUMRECTS *pClip;            // List of rectangles describing the
                                    //   current clip region intersected
                                    //   with the current scissors rectangle
    MCDENUMRECTS *pClipUnscissored; // Unscissored version of above
    VOID *pvUser;
} MCDWINDOW;

// Rendering context

// MCD context createFlags:
//
// MCDCONTEXT_SWAPSYNC          If set, synchronize MCDrvSwap to VSYNC
//                              for a tearless swap (if possible).
//
// MCDCONTEXT_IO_PRIORITY       If set, allow OpenGL to have a higher priority
//                              on the bus (if possible, let OpenGL "hog" the
//                              bus).
//

#define MCDCONTEXT_SWAPSYNC         0x00000001
#define MCDCONTEXT_IO_PRIORITY      0x00000002

typedef struct _MCDRC
{
    LONG iPixelFormat;              // Pixel format for the RC
    LONG iLayerPlane;               // Layer plane for the RC
    ULONG createFlags;              // Creation flags
    ULONG userFlags;                // User-specified flags
    VOID *pvUser;                   // User-specified pointer for expansion
} MCDRC;


#define MCDRCINFO_NOVIEWPORTADJUST   0x0001
#define MCDRCINFO_Y_LOWER_LEFT       0x0002
#define MCDRCINFO_DEVCOLORSCALE      0x0004
#define MCDRCINFO_DEVZSCALE          0x0008

// If set the system provides state updates
// with fine-grained state updates rather
// than through RENDERSTATE.  This is
// required if the driver exports
// MCDrvProcess.
#define MCDRCINFO_FINE_GRAINED_STATE 0x0010

typedef struct _MCRCINFO
{
    ULONG requestFlags;
    MCDFLOAT redScale;
    MCDFLOAT greenScale;
    MCDFLOAT blueScale;
    MCDFLOAT alphaScale;
    MCDDOUBLE zScale;               // This is a double to preserve accuracy
    ULONG depthBufferMax;
    LONG viewportXAdjust;
    LONG viewportYAdjust;
    ULONG reserved[12];
} MCDRCINFO;


// MCD pixel format descriptor

typedef struct _MCDPIXELFORMAT {
    WORD  nSize;
    DWORD dwFlags;                  // Any combination of:
                                    //
                                    //      PFD_DOUBLEBUFFER
                                    //      PFD_NEED_PALETTE
                                    //      PFD_NEED_SYSTEM_PALETTE
                                    //      PFD_SWAP_EXCHANGE
                                    //      PFD_SWAP_COPY
                                    //      PFD_SWAP_LAYER_BUFFERS

    BYTE  iPixelType;               // One of the following:
                                    //
                                    //      PFD_TYPE_RGBA
                                    //      PFD_TYPE_COLORINDEX

    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cDepthBits;               // Number of significant depth bits
    BYTE  cDepthShift;
    BYTE  cDepthBufferBits;         // Element size of depth buffer
                                    // (eg, a depth buffer with cDepthBits = 24
                                    // might have a cDepthBufferBits = 32)
    BYTE  cStencilBits;
    BYTE  cOverlayPlanes;           // Count of up to 15 overlay planes
    BYTE  cUnderlayPlanes;          // Count of up to 15 underlay planes
    DWORD dwTransparentColor;       // If there is an underlay plane, specifies
                                    // transparent color or index.
} MCDPIXELFORMAT;

// MCD layer plane descriptor

typedef struct _MCDLAYERPLANE {
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;                  // Any combination of:
                                    //
                                    //      LPD_SUPPORT_OPENGL
                                    //      LPD_SUPPORT_GDI
                                    //      LPD_DOUBLEBUFFER
                                    //      LPD_STEREO
                                    //      LPD_SWAP_EXCHANGE
                                    //      LPD_SWAP_COPY
                                    //      LPD_TRANSPARANT
                                    //      LPD_SHARE_DEPTH
                                    //      LPD_SHARE_STENCIL
                                    //      LPD_SHARE_ACCUM

    BYTE  iPixelType;               // One of the following:
                                    //
                                    //      LPD_TYPE_RGBA
                                    //      LPD_TYPE_COLORINDEX

    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    COLORREF crTransparent;

} MCDLAYERPLANE;


//
// Basic rendering types:
//

typedef struct _MCDCOLOR {
    MCDFLOAT r, g, b, a;
} MCDCOLOR;

typedef struct _MCDCOORD {
    MCDFLOAT x, y, z, w;
} MCDCOORD;


//
// Texture structures:
//

typedef struct __MCDMIPMAPLEVEL {
    UCHAR *pTexels;                     // pointer to client texture data
    LONG width, height;
    LONG widthImage, heightImage;       // Image dimensions without the border
    MCDFLOAT widthImagef, heightImagef; // Floatin-point versions of above
    LONG widthLog2, heightLog2;         // Log2 of above
    LONG border;                        // Border size
    LONG requestedFormat;               // Requested internal format
    LONG baseFormat;                    // Base format
    LONG internalFormat;                // Actual internal format

    LONG redSize;                       // Component resolution
    LONG greenSize;
    LONG blueSize;
    LONG alphaSize;
    LONG luminanceSize;
    LONG intensitySize;

    ULONG reserved;

} MCDMIPMAPLEVEL;

typedef struct __MCDTEXTURESTATE {

    ULONG sWrapMode;                    // Wrap modes
    ULONG tWrapMode;

    ULONG minFilter;                    // Min/mag filters               
    ULONG magFilter;

    MCDCOLOR borderColor;               // Border color

} MCDTEXTURESTATE;

typedef struct __MCDTEXTUREOBJSTATE {
    ULONG name;                         // "name" of texture object
    MCDFLOAT priority;                  // priority of the texture object
} MCDTEXTUREOBJSTATE;

typedef struct __MCDTEXTUREDATA {
    MCDTEXTURESTATE textureState;
    MCDTEXTUREOBJSTATE textureObjState;
    MCDMIPMAPLEVEL *level;
    ULONG textureDimension;

    // Support for texture palettes:

    ULONG paletteSize;
    RGBQUAD *paletteData;
    ULONG paletteBaseFormat;            // Type of palette data
    ULONG paletteRequestedFormat;

} MCDTEXTUREDATA;

typedef struct _MCDTEXTURE {
    MCDTEXTUREDATA *pMCDTextureData;
    VOID *pSurface;
    ULONG createFlags;
    ULONG_PTR textureKey;       // Must be filled in by the driver
    ULONG userFlags;
    VOID *pvUser;
} MCDTEXTURE;


//
// Memory block.
//

typedef struct _MCDMEM {
    ULONG memSize;
    ULONG createFlags;
    UCHAR *pMemBase;
    ULONG userFlags;
    VOID *pvUser;
} MCDMEM;


//
// Generic description prefix for any state change.
//

typedef struct _MCDSTATE_PREFIX {
    ULONG state;
    ULONG size;
} MCDSTATE_PREFIX;

typedef struct _MCDSTATE {
    ULONG state;
    ULONG size;
    ULONG stateValue;
} MCDSTATE;

#define MCD_RENDER_STATE                0
#define MCD_PIXEL_STATE                 1
#define MCD_SCISSOR_RECT_STATE          2
#define MCD_TEXENV_STATE                3
#define MCD_ENABLE_STATE                4
#define MCD_TEXTURE_ENABLE_STATE        5
#define MCD_FOG_STATE                   6
#define MCD_SHADEMODEL_STATE            7
#define MCD_POINTDRAW_STATE             8
#define MCD_LINEDRAW_STATE              9
#define MCD_POLYDRAW_STATE              10
#define MCD_ALPHATEST_STATE             11
#define MCD_DEPTHTEST_STATE             12
#define MCD_BLEND_STATE                 13
#define MCD_LOGICOP_STATE               14
#define MCD_FRAMEBUF_STATE              15
#define MCD_LIGHT_MODEL_STATE           16
#define MCD_HINT_STATE                  17
#define MCD_CLIP_STATE                  18
#define MCD_STENCILTEST_STATE           19

//
// MCDSTATE_RENDER is derived from the MCDSTATE_PREFIX structure and is used
// to pass all MCD rendering state (MCDRENDERSTATE) in a single command
// via MCDrvState.
//
// State field names are derived from the GLenum constant names by removing
// the GL_ prefix, replacing the "_" separators with case changes, and
// adding the "Enable" suffix to state enables.
//
// For example:
//
//  GL_FOG_COLOR    becomes     fogColor
//  GL_POINT_SMOOTH becomes     pointSmoothEnable
//
// In addition, there are few multiple values that are accessed via a single
// GLenum.  For example, GL_POLYGON_MODE returns both a front and a back
// polygon mode, so:
//
//  GL_POLYGON_MODE becomes     polygonModeFront *and* polygonModeBack
//

// Enable flags for enables field in MCDRENDERSTATE

#define MCD_ALPHA_TEST_ENABLE                  (1 <<  0)
#define MCD_BLEND_ENABLE                       (1 <<  1)
#define MCD_INDEX_LOGIC_OP_ENABLE              (1 <<  2)
#define MCD_DITHER_ENABLE                      (1 <<  3)
#define MCD_DEPTH_TEST_ENABLE                  (1 <<  4)
#define MCD_FOG_ENABLE                         (1 <<  5)
#define MCD_LIGHTING_ENABLE                    (1 <<  6)
#define MCD_COLOR_MATERIAL_ENABLE              (1 <<  7)
#define MCD_LINE_STIPPLE_ENABLE                (1 <<  8)
#define MCD_LINE_SMOOTH_ENABLE                 (1 <<  9)
#define MCD_POINT_SMOOTH_ENABLE                (1 << 10)
#define MCD_POLYGON_SMOOTH_ENABLE              (1 << 11)
#define MCD_CULL_FACE_ENABLE                   (1 << 12)
#define MCD_POLYGON_STIPPLE_ENABLE             (1 << 13)
#define MCD_SCISSOR_TEST_ENABLE                (1 << 14)
#define MCD_STENCIL_TEST_ENABLE                (1 << 15)
#define MCD_TEXTURE_1D_ENABLE                  (1 << 16)
#define MCD_TEXTURE_2D_ENABLE                  (1 << 17)
#define MCD_TEXTURE_GEN_S_ENABLE               (1 << 18)
#define MCD_TEXTURE_GEN_T_ENABLE               (1 << 19)
#define MCD_TEXTURE_GEN_R_ENABLE               (1 << 20)
#define MCD_TEXTURE_GEN_Q_ENABLE               (1 << 21)
#define MCD_NORMALIZE_ENABLE                   (1 << 22)
#define MCD_AUTO_NORMAL_ENABLE                 (1 << 23) // Not currently used
#define MCD_POLYGON_OFFSET_POINT_ENABLE        (1 << 24)
#define MCD_POLYGON_OFFSET_LINE_ENABLE         (1 << 25)
#define MCD_POLYGON_OFFSET_FILL_ENABLE         (1 << 26)
#define MCD_COLOR_LOGIC_OP_ENABLE              (1 << 27)
#define MCD_SPECULAR_FOG_ENABLE                (1 << 29)

typedef struct _MCDRENDERSTATE {

    // state enables

    ULONG enables;

    // texture state

    BOOL textureEnabled;

    // fog state

    MCDCOLOR fogColor;
    MCDFLOAT fogIndex;
    MCDFLOAT fogDensity;
    MCDFLOAT fogStart;
    MCDFLOAT fogEnd;
    ULONG fogMode;

    // shading model state

    ULONG shadeModel;

    // point drawing state

    MCDFLOAT pointSize;

    // line drawing state

    MCDFLOAT lineWidth;
    USHORT lineStipplePattern;
    SHORT lineStippleRepeat;

    // polygon drawing state

    ULONG cullFaceMode;
    ULONG frontFace;
    ULONG polygonModeFront;
    ULONG polygonModeBack;
    BYTE polygonStipple[4*32];
    MCDFLOAT zOffsetFactor;
    MCDFLOAT zOffsetUnits;

    // stencil test state

    BOOL stencilTestFunc;
    USHORT stencilMask;
    USHORT stencilRef;
    ULONG stencilFail;
    ULONG stencilDepthFail;
    ULONG stencilDepthPass;

    // alpha test state

    ULONG alphaTestFunc;
    MCDFLOAT alphaTestRef;

    // depth test state

    ULONG depthTestFunc;

    // blend state

    ULONG blendSrc;
    ULONG blendDst;

    // logic op state

    ULONG logicOpMode;

    // frame buffer control state

    ULONG drawBuffer;
    ULONG indexWritemask;
    BOOL colorWritemask[4];
    BOOL depthWritemask;      // Called mask, but really a write enable
    USHORT stencilWritemask;
    MCDCOLOR colorClearValue;
    MCDFLOAT indexClearValue;
    MCDDOUBLE depthClearValue;
    USHORT stencilClearValue;

    // lighting

    BOOL twoSided;

    // clipping control

    MCDCOORD userClipPlanes[MCD_MAX_USER_CLIP_PLANES];

    // hints

    ULONG perspectiveCorrectionHint;
    ULONG pointSmoothHint;
    ULONG lineSmoothHint;
    ULONG polygonSmoothHint;
    ULONG fogHint;

} MCDRENDERSTATE;

typedef struct _MCDSTATE_RENDER {
    ULONG    state;     // must be MCD_RENDER_STATE
    ULONG    size;      // must be sizeof(MCDSTATE_RENDER)
    MCDRENDERSTATE allState;
} MCDSTATE_RENDER;

//
// MCDSTATEPIXEL is a variant of the MCDSTATE structure that is used
// to pass all pixel state (MCDPIXELSTATE) in a single command
// via MCDrvState.
//
// Note: for MCDrvDrawPixels, the MCDUNPACK structure can be overridden by
// the packed parameter to the function.  If set, the source of the data is
// a display list and the structure of the data for that call may be assumed
// to be:
//
//      swapEndian = FALSE
//      lsbFirst   = FALSE
//      lineLength = width (from MCDrvDrawPixels parameter list)
//      skipLines  = 0
//      skipPixels = 0
//      alignment  = 1
//

typedef struct _MCDPIXELTRANSFER {
    MCDFLOAT redScale, greenScale, blueScale, alphaScale, depthScale;
    MCDFLOAT redbias, greenBias, blueBias, aalphaBias, depthBias;
    MCDFLOAT zoomX;
    MCDFLOAT zoomY;

    LONG indexShift;
    LONG indexOffset;

    BOOL mapColor;
    BOOL mapStencil;
} MCDPIXELTRANSFER;

typedef struct _MCDPIXELPACK {
    BYTE swapEndian;
    BYTE lsbFirst;

    LONG lineLength;
    LONG skipLines;
    LONG skipPixels;
    LONG alignment;
    LONG lReserved;
} MCDPIXELPACK;

typedef struct _MCDPIXELUNPACK {
    BYTE swapEndian;
    BYTE lsbFirst;

    LONG lineLength;
    LONG skipLines;
    LONG skipPixels;
    LONG alignment;
    LONG lReserved;
} MCDPIXELUNPACK;

typedef struct _MCDPIXELSTATE {
    MCDPIXELTRANSFER pixelTransferModes;
    MCDPIXELPACK pixelPackModes;
    MCDPIXELUNPACK pixelUnpackModes;
    ULONG readBuffer;
    MCDCOORD rasterPos;
} MCDPIXELSTATE;

typedef struct _MCDSTATE_PIXEL {
    ULONG    state;     // must be MCD_PIXEL_STATE
    ULONG    size;      // must be sizeof(MCDSTATE_PIXEL)
    MCDPIXELSTATE pixelState;
} MCDSTATE_PIXEL;

//
// MCDSTATE_SCISSOR_RECT is a variant of the MCDSTATE structure
// that is used to pass the scissor rectangle to the MCD driver
// via MCDrvState.
//

typedef struct _MCDSTATE_SCISSOR_RECT {
    ULONG   state;      // must be MCD_SCISSOR_RECT_STATE
    ULONG   size;       // must be sizeof(MCDSTATE_SCISSOR_RECT)
    RECTL   scissorRect;
} MCDSTATE_SCISSOR_RECT;

//
// MCDSTATE_TEXENV is a variant of the MCDSTATE structure that is
// used to pass the texture environment state to the MCD driver
// via MCDrvState.
//

typedef struct _MCDTEXENVSTATE {
    ULONG    texEnvMode;
    MCDCOLOR texEnvColor;
} MCDTEXENVSTATE;

typedef struct _MCDSTATE_TEXENV {
    ULONG   state;      // must be MCD_TEXENV_STATE
    ULONG   size;       // must be sizeof(MCDSTATE_TEXENV)
    MCDTEXENVSTATE texEnvState;
} MCDSTATE_TEXENV;

//
// MCDVIEWPORT is used to pass viewport state to the MCD driver
// via MCDrvViewport.

typedef struct _MCDVIEWPORT {
    MCDFLOAT xScale, xCenter;
    MCDFLOAT yScale, yCenter;
    MCDFLOAT zScale, zCenter;
} MCDVIEWPORT;

//
// Fine-grained state updates.  Sent to a driver only if
// MCDRCINFO_FINE_GRAINED_STATE was returned on context creation.
//

// Enable state.
typedef struct _MCDENABLESTATE {
    ULONG enables;
} MCDENABLESTATE;

// Texture enable state.  Different from plain enables in that it
// indicates whether all texturing state is consistent and ready for
// texturing.
typedef struct _MCDTEXTUREENABLESTATE {
    BOOL textureEnabled;
} MCDTEXTUREENABLESTATE;

// Fog state.
typedef struct _MCDFOGSTATE {
    MCDCOLOR fogColor;
    MCDFLOAT fogIndex;
    MCDFLOAT fogDensity;
    MCDFLOAT fogStart;
    MCDFLOAT fogEnd;
    ULONG fogMode;
} MCDFOGSTATE;

// Shading model state.
typedef struct _MCDSHADELMODELSTATE {
    ULONG shadeModel;
} MCDSHADEMODELSTATE;

// Point drawing state.
typedef struct _MCDPOINTDRAWSTATE {
    MCDFLOAT pointSize;
} MCDPOINTDRAWSTATE;

// Line drawing state.
typedef struct _MCDLINEDRAWSTATE {
    MCDFLOAT lineWidth;
    USHORT lineStipplePattern;
    SHORT lineStippleRepeat;
} MCDLINEDRAWSTATE;

// Polygon drawing state.
typedef struct _MCDPOLYDRAWSTATE {
    ULONG cullFaceMode;
    ULONG frontFace;
    ULONG polygonModeFront;
    ULONG polygonModeBack;
    BYTE polygonStipple[4*32];
    MCDFLOAT zOffsetFactor;
    MCDFLOAT zOffsetUnits;
} MCDPOLYDRAWSTATE;

// Alpha test state.
typedef struct _MCDALPHATESTSTATE {
    ULONG alphaTestFunc;
    MCDFLOAT alphaTestRef;
} MCDALPHATESTSTATE;

// Depth test state.
typedef struct _MCDDEPTHTESTSTATE {
    ULONG depthTestFunc;
} MCDDEPTHTESTSTATE;

// Blend state.
typedef struct _MCDBLENDSTATE {
    ULONG blendSrc;
    ULONG blendDst;
} MCDBLENDSTATE;

// Logic op state.
typedef struct _MCDLOGICOPSTATE {
    ULONG logicOpMode;
} MCDLOGICOPSTATE;

// Frame buffer control state.
typedef struct _MCDFRAMEBUFSTATE {
    ULONG drawBuffer;
    ULONG indexWritemask;
    BOOL colorWritemask[4];
    BOOL depthWritemask;      // Called mask, but really a write enable.
    USHORT stencilWritemask;
    MCDCOLOR colorClearValue;
    MCDFLOAT indexClearValue;
    MCDDOUBLE depthClearValue;
    USHORT stencilClearValue;
} MCDFRAMEBUFSTATE;

// Light model state.
typedef struct _MCDLIGHTMODELSTATE {
    MCDCOLOR ambient;           // Scaled
    BOOL localViewer;
    BOOL twoSided;
} MCDLIGHTMODELSTATE;

// Hint state.
typedef struct _MCDHINTSTATE {
    ULONG perspectiveCorrectionHint;
    ULONG pointSmoothHint;
    ULONG lineSmoothHint;
    ULONG polygonSmoothHint;
    ULONG fogHint;
} MCDHINTSTATE;

// Clipping state.
typedef struct _MCDCLIPSTATE {
    ULONG userClipEnables;
    // Given by program
    MCDCOORD userClipPlanes[MCD_MAX_USER_CLIP_PLANES];
    // userClipPlanes transformed by modelview inverse
    MCDCOORD userClipPlanesInv[MCD_MAX_USER_CLIP_PLANES];
} MCDCLIPSTATE;

// Stencil test state.
typedef struct _MCDSTENCILTESTSTATE {
    BOOL stencilTestFunc;
    USHORT stencilMask;
    USHORT stencilRef;
    ULONG stencilFail;
    ULONG stencilDepthFail;
    ULONG stencilDepthPass;
} MCDSTENCILTESTSTATE;
        

//
// MCDBUF.bufFlags flags:
//
// MCDBUF_ENABLED       If set, direct buffer access is enabled (i.e., the
//                      bufOffset and bufStride values are valid and may
//                      be used to access the buffer).
//
// MCDBUF_NOCLIP        If set, indicates that clipping is not required
//                      for the current state of the window.
//

#define MCDBUF_ENABLED  0x00000001
#define MCDBUF_NOCLIP   0x00000002

typedef struct _MCDBUF {
    ULONG bufFlags;
    LONG  bufOffset;        // offset relative to beginning of framebuffer
    LONG  bufStride;
} MCDBUF;

typedef struct _MCDBUFFERS {
    MCDBUF mcdFrontBuf;
    MCDBUF mcdBackBuf;
    MCDBUF mcdDepthBuf;
} MCDBUFFERS;

//
// MCD surface flags:
//
// MCDSURFACE_HWND

#define MCDSURFACE_HWND             0x00000001

typedef struct _MCDSURFACE {
    MCDWINDOW *pWnd;                // Region support
    SURFOBJ *pso;
    WNDOBJ *pwo;
    ULONG reserved[4];
    ULONG surfaceFlags;
} MCDSURFACE;

#define MCDSPAN_FRONT   1
#define MCDSPAN_BACK    2
#define MCDSPAN_DEPTH   3

typedef struct _MCDSPAN {
    LONG x;
    LONG y;
    LONG numPixels;
    ULONG type;
    VOID *pPixels;
} MCDSPAN;

//
// MCDrvSwap flags
//

#define MCDSWAP_MAIN_PLANE      0x00000001
#define MCDSWAP_OVERLAY1        0x00000002
#define MCDSWAP_OVERLAY2        0x00000004
#define MCDSWAP_OVERLAY3        0x00000008
#define MCDSWAP_OVERLAY4        0x00000010
#define MCDSWAP_OVERLAY5        0x00000020
#define MCDSWAP_OVERLAY6        0x00000040
#define MCDSWAP_OVERLAY7        0x00000080
#define MCDSWAP_OVERLAY8        0x00000100
#define MCDSWAP_OVERLAY9        0x00000200
#define MCDSWAP_OVERLAY10       0x00000400
#define MCDSWAP_OVERLAY11       0x00000800
#define MCDSWAP_OVERLAY12       0x00001000
#define MCDSWAP_OVERLAY13       0x00002000
#define MCDSWAP_OVERLAY14       0x00004000
#define MCDSWAP_OVERLAY15       0x00008000
#define MCDSWAP_UNDERLAY1       0x00010000
#define MCDSWAP_UNDERLAY2       0x00020000
#define MCDSWAP_UNDERLAY3       0x00040000
#define MCDSWAP_UNDERLAY4       0x00080000
#define MCDSWAP_UNDERLAY5       0x00100000
#define MCDSWAP_UNDERLAY6       0x00200000
#define MCDSWAP_UNDERLAY7       0x00400000
#define MCDSWAP_UNDERLAY8       0x00800000
#define MCDSWAP_UNDERLAY9       0x01000000
#define MCDSWAP_UNDERLAY10      0x02000000
#define MCDSWAP_UNDERLAY11      0x04000000
#define MCDSWAP_UNDERLAY12      0x08000000
#define MCDSWAP_UNDERLAY13      0x10000000
#define MCDSWAP_UNDERLAY14      0x20000000
#define MCDSWAP_UNDERLAY15      0x40000000


//
// Clip codes:
//

#define MCD_CLIP_LEFT           0x00000001
#define MCD_CLIP_RIGHT          0x00000002
#define MCD_CLIP_BOTTOM         0x00000004
#define MCD_CLIP_TOP            0x00000008
#define MCD_CLIP_NEAR           0x00000010
#define MCD_CLIP_FAR            0x00000020
#define MCD_CLIP_MASK           0x0000003f

//
// Vertex flags:
//

#define MCDVERTEX_EDGEFLAG              0x00000001

//
// Color indices:
//

#define MCDVERTEX_FRONTFACE     0
#define MCDVERTEX_BACKFACE      1

//
// Note: vertex colors are scaled to the color depths reported in the
// pixel format.
//

typedef struct _MCDVERTEX {

    ULONG flags;                // vertex flags
    MCDCOLOR *pColor;           // pointer to active vertex color
    ULONG clipCode;             // clip code
    MCDFLOAT fog;               // fog value (0..1)
    MCDCOORD clipCoord;         // clip-space coordinate
    MCDCOORD windowCoord;       // window coordinate
    MCDCOORD texCoord;          // texture coordinate
    MCDCOORD normal;            // vertex normal
    MCDCOLOR colors[2];         // front and back vertex colors
    MCDCOORD eyeCoord;          // eye coordinate
} MCDVERTEX;

typedef struct _MCDCOMMAND MCDCOMMAND;

#define MCDCOMMAND_RESET_STIPPLE        0x00004000
#define MCDCOMMAND_RENDER_PRIMITIVE     0x00008000
#define MCDCOMMAND_SAME_COLOR           0x00040000

typedef struct _MCDCOMMAND {
    ULONG flags;                // flags for this command
    MCDVERTEX *pEndVertex;
    ULONG reserved2;
    ULONG reserved3;
    ULONG reserved4;
    ULONG reserved5;
    MCDVERTEX *pStartVertex;
    ULONG reserved7;
    ULONG reserved8;
    MCDVERTEX *pVertexBuffer;
    ULONG reserved10;
    ULONG reserved11;
    ULONG reserved12;
    ULONG reserved13;
    ULONG reserved14;
    ULONG command;              // primitive type or command (GL_TRIANGLES, etc.)
    ULONG clipCodes;
    ULONG reserved17;
    ULONG reserved18;
    MCDCOMMAND *pNextCmd;
    ULONG numIndices;
    UCHAR *pIndices;
    ULONG reserved22;
    ULONG textureKey;
} MCDCOMMAND;


// MCDDRIVER structure containing driver functions

typedef LONG     (*MCDRVDESCRIBEPIXELFORMATFUNC)(MCDSURFACE *pMCDSurface, LONG iPixelFormat,
                                                 ULONG nBytes, MCDPIXELFORMAT *pMCDPixelFmt, ULONG flags);
typedef BOOL     (*MCDRVDESCRIBELAYERPLANEFUNC)(MCDSURFACE *pMCDSurface, LONG iPixelFormat,
                                                LONG iLayerPlane, ULONG nBytes, MCDLAYERPLANE *pMCDLayerPlane,
                                                ULONG flags);
typedef LONG     (*MCDRVSETLAYERPALETTEFUNC)(MCDSURFACE *pMCDSurface, LONG iLayerPlane, BOOL bRealize, LONG cEntries, COLORREF *pcr);
typedef BOOL     (*MCDRVINFOFUNC)(MCDSURFACE *pMCDSurface, MCDDRIVERINFO *pMCDDriverInfo);
typedef ULONG    (*MCDRVCREATECONTEXTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDRCINFO *pDrvRcInfo);
typedef ULONG    (*MCDRVDELETECONTEXTFUNC)(MCDRC *pRc, DHPDEV dhpdev);
typedef ULONG    (*MCDRVCREATETEXTUREFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVUPDATESUBTEXTUREFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex, 
                                              ULONG lod, RECTL *pRect);
typedef ULONG    (*MCDRVUPDATETEXTUREPALETTEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex, 
                                                  ULONG start, ULONG numEntries);
typedef ULONG    (*MCDRVUPDATETEXTUREPRIORITYFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVUPDATETEXTURESTATEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVTEXTURESTATUSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVDELETETEXTUREFUNC)(MCDTEXTURE *pTex, DHPDEV dhpdev);
typedef ULONG    (*MCDRVCREATEMEMFUNC)(MCDSURFACE *pMCDSurface, MCDMEM *pMCDMem);
typedef ULONG    (*MCDRVDELETEMEMFUNC)(MCDMEM *pMCDMem, DHPDEV dhpdev);
typedef ULONG_PTR (*MCDRVDRAWFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *pMCDExecMem, UCHAR *pStart, UCHAR *pEnd);
typedef ULONG    (*MCDRVCLEARFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, ULONG buffers);
typedef ULONG    (*MCDRVSWAPFUNC)(MCDSURFACE *pMCDSurface, ULONG flags);
typedef ULONG    (*MCDRVSTATEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *pMCDMem,
                                   UCHAR *pStart, LONG length, ULONG numStates);
typedef ULONG    (*MCDRVVIEWPORTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDVIEWPORT *pMCDViewport);
typedef HDEV     (*MCDRVGETHDEVFUNC)(MCDSURFACE *pMCDSurface);
typedef ULONG    (*MCDRVSPANFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *pMCDMem,
                                  MCDSPAN *pMCDSpan, BOOL bRead);
typedef VOID     (*MCDRVTRACKWINDOWFUNC)(WNDOBJ *pWndObj, MCDWINDOW *pMCDWnd, ULONG flags);
typedef ULONG    (*MCDRVGETBUFFERSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDBUFFERS *pMCDBuffers);
typedef ULONG    (*MCDRVALLOCBUFFERSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVBINDCONTEXTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVSYNCFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVDRAWPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    ULONG width, ULONG height, ULONG format,
                                    ULONG type, VOID *pPixels, BOOL packed);
typedef ULONG    (*MCDRVREADPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    LONG x, LONG y, ULONG width, ULONG height, ULONG format,
                                    ULONG type, VOID *pPixels);
typedef ULONG    (*MCDRVCOPYPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    LONG x, LONG y, ULONG width, ULONG height, ULONG type);
typedef ULONG    (*MCDRVPIXELMAP)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                  ULONG mapType, ULONG mapSize, VOID *pMap);

#define MCDDRIVER_V10_SIZE      (sizeof(ULONG)+31*sizeof(void *))

typedef struct _MCDDRIVER {
    ULONG                           ulSize;
    MCDRVDESCRIBEPIXELFORMATFUNC    pMCDrvDescribePixelFormat;
    MCDRVDESCRIBELAYERPLANEFUNC     pMCDrvDescribeLayerPlane;
    MCDRVSETLAYERPALETTEFUNC        pMCDrvSetLayerPalette;
    MCDRVINFOFUNC                   pMCDrvInfo;
    MCDRVCREATECONTEXTFUNC          pMCDrvCreateContext;
    MCDRVDELETECONTEXTFUNC          pMCDrvDeleteContext;
    MCDRVBINDCONTEXTFUNC            pMCDrvBindContext;
    MCDRVCREATETEXTUREFUNC          pMCDrvCreateTexture;
    MCDRVDELETETEXTUREFUNC          pMCDrvDeleteTexture;
    MCDRVUPDATESUBTEXTUREFUNC       pMCDrvUpdateSubTexture;
    MCDRVUPDATETEXTUREPALETTEFUNC   pMCDrvUpdateTexturePalette;
    MCDRVUPDATETEXTUREPRIORITYFUNC  pMCDrvUpdateTexturePriority;
    MCDRVUPDATETEXTURESTATEFUNC     pMCDrvUpdateTextureState;
    MCDRVTEXTURESTATUSFUNC          pMCDrvTextureStatus;
    MCDRVCREATEMEMFUNC              pMCDrvCreateMem;
    MCDRVDELETEMEMFUNC              pMCDrvDeleteMem;
    MCDRVDRAWFUNC                   pMCDrvDraw;
    MCDRVCLEARFUNC                  pMCDrvClear;
    MCDRVSWAPFUNC                   pMCDrvSwap;
    MCDRVSTATEFUNC                  pMCDrvState;
    MCDRVVIEWPORTFUNC               pMCDrvViewport;
    MCDRVGETHDEVFUNC                pMCDrvGetHdev;
    MCDRVSPANFUNC                   pMCDrvSpan;
    MCDRVTRACKWINDOWFUNC            pMCDrvTrackWindow;
    MCDRVALLOCBUFFERSFUNC           pMCDrvAllocBuffers;
    MCDRVGETBUFFERSFUNC             pMCDrvGetBuffers;
    MCDRVSYNCFUNC                   pMCDrvSync;
    MCDRVDRAWPIXELS                 pMCDrvDrawPixels;
    MCDRVREADPIXELS                 pMCDrvReadPixels;
    MCDRVCOPYPIXELS                 pMCDrvCopyPixels;
    MCDRVPIXELMAP                   pMCDrvPixelMap;
} MCDDRIVER;


// Top-level (global) driver functions established at DLL initialization time
// through MCD initialization. All other driver functions are obtained through
// the MCDrvGetEntryPoints funtion:

typedef BOOL  (*MCDRVGETENTRYPOINTSFUNC)(MCDSURFACE *pMCDSurface,
                                         MCDDRIVER *pMCDDriver);

typedef struct _MCDGLOBALDRIVERFUNCS {
    ULONG ulSize;
    MCDRVGETENTRYPOINTSFUNC     pMCDrvGetEntryPoints;
} MCDGLOBALDRIVERFUNCS;

// MCD Server engine functions:

#define MCDENGINITFUNCNAME              "MCDEngInit"
#define MCDENGINITEXFUNCNAME            "MCDEngInitEx"
#define MCDENGUNINITFUNCNAME            "MCDEngUninit"
#define MCDENGESCFILTERNAME             "MCDEngEscFilter"
#define MCDENGSETMEMSTATUSNAME          "MCDEngSetMemStatus"

typedef BOOL (WINAPI *MCDENGINITFUNC)(SURFOBJ *pso, 
                                      MCDRVGETENTRYPOINTSFUNC);
typedef BOOL (WINAPI *MCDENGINITEXFUNC)(SURFOBJ *pso,
                                        MCDGLOBALDRIVERFUNCS *pMCDGlobalDriverFuncs,
                                        void *pReserved);

typedef void (WINAPI *MCDENGUNINITFUNC)(SURFOBJ *pso);

typedef BOOL (WINAPI *MCDENGESCFILTERFUNC)(SURFOBJ *pso, ULONG iEsc,
                                           ULONG cjIn, VOID *pvIn,
                                           ULONG cjOut, VOID *pvOut, 
                                           ULONG *pRetVal);

typedef BOOL (WINAPI *MCDENGSETMEMSTATUSFUNC)(MCDMEM *pMCDMem, ULONG status);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\kbd.h ===
/****************************** Module Header ******************************\
* Module Name: kbd.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Keyboard table values that form the basis for languages and keyboard types.
* The basis is US, kbd type 4 - all others are a variation on this.
* This file is included by all kbd**.h files.
*
* History:
* 10-Jan-1991 GregoryW
* 23-Apr-1991 IanJa         VSC_TO_VK _* macros from oemtab.c
\***************************************************************************/

#ifndef _KBD_
#define _KBD_

/****************************************************************************\
*
* Keyboard Layers.   Used in kdb??.dll and in usersrv.dll
*
\****************************************************************************/

/*
 * Key Event (KE) structure
 * Stores a Virtual Key event
 */
typedef struct tagKE {
    union {
        BYTE bScanCode;    // Virtual Scan Code (Set 1)
        WCHAR wchInjected; // Unicode char from SendInput()
    };
    USHORT usFlaggedVk;    // Vk | Flags
    DWORD  dwTime;         // time in milliseconds
} KE, *PKE;

typedef BOOL (* KEPROC)(PKE pKe);

/*
 * KE.usFlaggedVk values, also used in the keyboard layer tables.
 */
#define KBDEXT        (USHORT)0x0100
#define KBDMULTIVK    (USHORT)0x0200
#define KBDSPECIAL    (USHORT)0x0400
#define KBDNUMPAD     (USHORT)0x0800
#define KBDUNICODE    (USHORT)0x1000
#define KBDINJECTEDVK (USHORT)0x2000
#define KBDBREAK      (USHORT)0x8000

/*
 * Key message lParam bits
 */
#define EXTENDED_BIT   0x01000000
#define DONTCARE_BIT   0x02000000
#define FAKE_KEYSTROKE 0x02000000
#define ALTNUMPAD_BIT  0x04000000 // copied from windows\inc\wincon.w

/*
 * Keyboard Shift State defines. These correspond to the bit mask defined
 * by the VkKeyScan() API.
 */
#define KBDBASE        0
#define KBDSHIFT       1
#define KBDCTRL        2
#define KBDALT         4
// three symbols KANA, ROYA, LOYA are for FE
#define KBDKANA        8
#define KBDROYA        0x10
#define KBDLOYA        0x20
#define KBDGRPSELTAP   0x80

/*
 * Handy diacritics
 */
#define GRAVE           0x0300
#define ACUTE           0x0301
#define CIRCUMFLEX      0x0302
#define TILDE           0x0303
#define MACRON          0x0304
#define OVERSCORE       0x0305
#define BREVE           0x0306
#define DOT_ABOVE       0x0307
#define UMLAUT          0x0308
#define DIARESIS        UMLAUT
#define HOOK_ABOVE      0x0309
#define RING            0x030A
#define DOUBLE_ACUTE    0x030B
#define HACEK           0x030C

#define CEDILLA         0x0327
#define OGONEK          0x0328
#define TONOS           0x0384
#define DIARESIS_TONOS  0x0385


#define wszGRAVE           L"\x0300"
#define wszACUTE           L"\x0301"
#define wszCIRCUMFLEX      L"\x0302"
#define wszTILDE           L"\x0303"
#define wszMACRON          L"\x0304"
#define wszOVERSCORE       L"\x0305"
#define wszBREVE           L"\x0306"
#define wszDOT_ABOVE       L"\x0307"
#define wszUMLAUT          L"\x0308"
#define wszHOOK_ABOVE      L"\x0309"
#define wszRING            L"\x030A"
#define wszDOUBLE_ACUTE    L"\x030B"
#define wszHACEK           L"\x030C"

#define wszCEDILLA         L"\x0327"
#define wszOGONEK          L"\x0328"
#define wszTONOS           L"\x0384"
#define wszDIARESIS_TONOS  L"\x0385"

#define IDS_FROM_SCANCODE(prefix, base) \
        (0xc000 + ((0x ## prefix) >= 0xE0 ? 0x100 : 0) + (0x ## base))

/***************************************************************************\
* MODIFIER KEYS
*
* All keyboards have "Modifier" keys which are used to alter the behaviour of
* some of the other keys.  These shifter keys are usually:
*   Shift  (left and/or right Shift key)
*   Ctrl   (left and/or right Ctrl key)
*   Alt    (left and/or right Alt key)
*   AltGr  (right Alt key only)
*
* NOTE:
*   All keyboards use the Shift key.
*   All keyboards use a Ctrl key to generate ASCII control characters.
*   All keyboards with a number pad use the Alt key and the NumPad to
*     generate characters by number.
*   Keyboards using AltGr as a Modifier Key usually translate the Virtual
*     ScanCode to Virtual Keys VK_CTRL + VK_ALT at input time: the Modifier
*     tables should be written to treat Ctrl + Alt as a valid shifter
*     key combination in these cases.
*
* By holding down 0 or more of these Modifier keys, a "shift state" is
* obtained : the shift state may affect the translation of Virtual Scancodes
* to Virtual Keys and/or the translation of Virtuals Key to Characters.
*
* EXAMPLES:
*
* Each key on a particular keyboard may be marked with up to five different
* characters in five different positions:
*
*              .-------.
*             /|       |\
*            : | 2   4 | :
*            | |       | |
*            | |       | |
*            | | 1   3 | |
*            | |_______| |
*            | /       \ |
*            |/    5    \|
*            `-----------'
*
* A key may also be able to generate a character that is not marked on it:
* these are ASCII Control chars, lower-case letters and/or "invisible keys".
*                                                  .-------.
*      An example of an "Invisible Key":          /|       |\
*                                                : | >     | :
*  The German M24 keyboard 2 should produce the  | |       | |
*  '|' character when ALT SHIFT is is held down  | |       | |
*  while the '<' key (shown here) is pressed:    | | <   \ | |
*  This keyboard has four other invisible        | |_______| |
*  characters.  France, Italy and Spain also     | /       \ |
*  support invisible characters on the M24       |/         \|
*  Keyboard 2 with ALT SHIFT depressed.          `-----------'
*
* The keyboard table must list the keys that contribute to it's shift state,
* and indicate which combinations are valid.  This is done with
*    aCharModifiers[]  - convert combinations of Modifier Keys to Bitmasks.
* and
*    aModification[];  - convert Modifier Bitmasks to enumerated Modifications
*
* AN EXAMPLE OF VALID AND INVALID MODIFIER KEY COMBINATIONS
*
*    The US English keyboard has 3 Modifier keys:
*      Shift (left or right); Ctrl (left or right); and Alt (left or right).
*
*    The only valid combinations of these Modifier Keys are:
*      none pressed      : Character at position (1) on the key.
*      Shift             : Character at position (2) on the key.
*      Ctrl              : Ascii Control characters
*      Shift + Ctrl      : Ascii Control characters
*      Alt               : Character-by-number on the numpad
*
*    The invalid combinations (that do not generate any characters) are:
*      Shift + Alt
*      Alt + Ctrl
*      Shift + Alt + Ctrl
*
* Something (???) :
* -----------------
*      Modifier keys              Character produced
*      -------------------------  ------------------
*   0  No shifter key depressed   position 1
*   1  Shift key is depressed     position 2
*   2  AltGr (r.h. Alt) depressed position 4 or 5 (whichever is marked)
*
* However, note that 3 shifter keys (SHIFT, can be combined in a
* characters, depending on the Keyboards
* Consider the following keyboards:
*
*     .-------.            STRANGE KBD         PECULIAR KBD
*    /|       |\           ==================  ==================
*   : | 2   4 | :    1   -
*   | |       | |    2   - SHIFT               SHIFT
*   | |       | |    3   - MENU                MENU
*   | | 1   3 | |    4   - SHIFT + MENU        SHIFT + MENU
*   | |_______| |    5   -    no such keys     CTRL  + MENU
*   | /       \ |
*   |/    5    \|
*   `-----------'
* Both STRANGE and PECULIAR keyboards could have aVkToBits[] =
*   { VK_SHIFT  , KBDSHIFT }, // 0x01
*   { VK_CONTROL, KBDCTRL  }, // 0x02
*   { VK_MENU   , KBDALT   }, // 0x04
*   { 0,          0        }
*
* The STRANGE keyboard has 4 distinct shift states, while the PECULIAR kbd
* has 5.  However, note that 3 shifter bits can be combined in a
* total of 2^3 == 8 ways.  Each such combination must be related to one (or
* none) of the enumerated shift states.
* Each shifter key combination can be represented by three binary bits:
*  Bit 0  is set if VK_SHIFT is down
*  Bit 1  is set if VK_CONTROL is down
*  Bit 2  is set if VK_MENU is down
*
* Example: If the STRANGE keyboard generates no characters in combination
* when just the ALT key is held down, nor when the SHIFT, CTRL and ALT keys
* are all held down, then the tables might look like this:
*
*                                VK_MENU,
*                        VK_CTRL,                    0
*    };
*    aModification[] = {
*        0,            //   0       0       0     = 000  <none>
*        1,            //   0       0       1     = 001  SHIFT
*        SHFT_INVALID, //   0       1       0     = 010  ALT
*        2,            //   0       1       1     = 011  SHIFT ALT
*        3,            //   1       0       0     = 100  CTRL
*        4,            //   1       0       1     = 101  SHIFT CTRL
*        5,            //   1       1       0     = 110  CTRL ALT
*        SHFT_INVALID  //   1       1       1     = 111  SHIFT CTRL ALT
*    };
*
*
\***************************************************************************/

/***************************************************************************\
* VK_TO_BIT - associate a Virtual Key with a Modifier bitmask.
*
* Vk        - the Virtual key (eg: VK_SHIFT, VK_RMENU, VK_CONTROL etc.)
*             Special Values:
*                0        null terminator
* ModBits   - a combination of KBDALT, KBDCTRL, KBDSHIFT and kbd-specific bits
*             Any kbd-specific shift bits must be the lowest-order bits other
*             than KBDSHIFT, KBDCTRL and KBDALT (0, 1 & 2)
*
* Those languages that use AltGr (VK_RMENU) to shift keys convert it to
* CTRL+ALT with the KBDSPECIAL bit in the ausVK[] entry for VK_RMENU
* and by having an entry in aVkToPfnOem[] to simulate the right Vk sequence.
*
\***************************************************************************/
typedef struct {
    BYTE Vk;
    BYTE ModBits;
} VK_TO_BIT, *PVK_TO_BIT;

/***************************************************************************\
* pModNumber  - a table to map shift bits to enumerated shift states
*
* Table attributes: Ordered table
*
* Maps all possible shifter key combinations to an enumerated shift state.
* The size of the table depends on the value of the highest order bit used
* in aCharModifiers[*].ModBits
*
* Special values for aModification[*]
*   SHFT_INVALID - no characters produced with this shift state.
LATER: (ianja) no SHFT_CTRL - control characters encoded in tables like others
*   SHFT_CTRL    - standard control character production (all keyboards must
*                  be able to produce CTRL-C == 0x0003 etc.)
*   Other        - enumerated shift state (not less than 0)
*
* This table is indexed by the Modifier Bits to obtain an Modification Number.
*
*                        CONTROL MENU SHIFT
*
*    aModification[] = {
*        0,            //   0     0     0     = 000  <none>
*        1,            //   0     0     1     = 001  SHIFT
*        SHFT_INVALID, //   0     1     0     = 010  ALT
*        2,            //   0     1     1     = 011  SHIFT ALT
*        3,            //   1     0     0     = 100  CTRL
*        4,            //   1     0     1     = 101  SHIFT CTRL
*        5,            //   1     1     0     = 110  CTRL ALT
*        SHFT_INVALID  //   1     1     1     = 111  SHIFT CTRL ALT
*    };
*
\***************************************************************************/
typedef struct {
    PVK_TO_BIT pVkToBit;     // Virtual Keys -> Mod bits
    WORD       wMaxModBits;  // max Modification bit combination value
    BYTE       ModNumber[];  // Mod bits -> Modification Number
} MODIFIERS, *PMODIFIERS;

WORD GetModifierBits(PMODIFIERS pModifiers, LPBYTE afKeyState);
WORD GetModificationNumber(PMODIFIERS pModifiers, WORD wModBits);

// FE Modifiers_VK
extern PMODIFIERS gpModifiers_VK;
extern MODIFIERS Modifiers_VK_STANDARD;
extern MODIFIERS Modifiers_VK_IBM02;

#define SHFT_INVALID 0x0F

/***************************************************************************\
* apulCvt_VK[] - obtain VK translation table from shift state
*     A VK translation table is used to change the value of the Virtual Key
*     according to the shift state.   OEM only (not locale-specific)
\***************************************************************************/
extern PULONG *gapulCvt_VK;
extern ULONG *gapulCvt_VK_101[];
extern ULONG *gapulCvt_VK_84[];
// gapulCvt_VK_IBM02[] is for FE
extern ULONG *gapulCvt_VK_IBM02[];

/***************************************************************************\
* awNumPadCvt[]   - Translate cursor movement keys to numpad keys
\***************************************************************************/
extern MODIFIERS Modifiers_VK;
extern BYTE aVkNumpad[];

/***************************************************************************\
* VSC_VK     - Associate a Virtual Scancode with a Virtual Key
*  Vsc - Virtual Scancode
*  Vk  - Virtual Key | flags
* Used by VKFromVSC() for scancodes prefixed 0xE0 or 0xE1
\***************************************************************************/
typedef struct _VSC_VK {
    BYTE Vsc;
    USHORT Vk;
} VSC_VK, *PVSC_VK;

/***************************************************************************\
* VK_VSC     - Associate a Virtual Key with a Virtual Scancode
*  Vk  - Virtual Key
*  Vsc - Virtual Scancode
* Used by MapVirtualKey for Virtual Keys not appearing in ausVK[]
\***************************************************************************/
typedef struct _VK_VSC {
    BYTE Vk;
    BYTE Vsc;
} VK_VSC, *PVK_VSC;

/***************************************************************************\
*
* VK_TO_WCHARS<n> - Associate a Virtual Key with <n> UNICODE characters
*
* VirtualKey  - The Virtual Key.
* wch[]       - An array of characters, one for each shift state that
*               applies to the specified Virtual Key.
*
* Special values for VirtualKey:
*    -1        - This entry contains dead chars for the previous entry
*    0         - Terminates a VK_TO_WCHARS[] table
*
* Special values for Attributes:
*    CAPLOK    - The CAPS-LOCK key affects this key like SHIFT
*    SGCAPS    - CapsLock uppercases the unshifted char (Swiss-German)
*
* Special values for wch[*]:
*    WCH_NONE  - No character is generated by pressing this key with the
*                current shift state.
*    WCH_DEAD  - The character is a dead-key: the next VK_TO_WCHARS[] entry
*                will contain the values of the dead characters (diaresis)
*                that can be produced by the Virtual Key.
*    WCH_LGTR  - The character is a ligature.  The characters generated by
*                this keystroke are found in the ligature table.
*
\***************************************************************************/
#define WCH_NONE 0xF000
#define WCH_DEAD 0xF001
#define WCH_LGTR 0xF002

#define CAPLOK      0x01
#define SGCAPS      0x02
#define CAPLOKALTGR 0x04
// KANALOK is for FE
#define KANALOK     0x08
#define GRPSELTAP   0x80

/*
 * Macro for VK to WCHAR with "n" shift states
 */
#define TYPEDEF_VK_TO_WCHARS(n) typedef struct _VK_TO_WCHARS##n {  \
                                    BYTE  VirtualKey;      \
                                    BYTE  Attributes;      \
                                    WCHAR wch[n];          \
                                } VK_TO_WCHARS##n, *PVK_TO_WCHARS##n;

/*
 * To facilitate coding the table scanning routine.
 */

/*
 * Table element types (for various numbers of shift states), used
 * to facilitate static initializations of tables.
 * VK_TO_WCHARS1 and PVK_TO_WCHARS1 may be used as the generic type
 */
TYPEDEF_VK_TO_WCHARS(1) // VK_TO_WCHARS1, *PVK_TO_WCHARS1;
TYPEDEF_VK_TO_WCHARS(2) // VK_TO_WCHARS2, *PVK_TO_WCHARS2;
TYPEDEF_VK_TO_WCHARS(3) // VK_TO_WCHARS3, *PVK_TO_WCHARS3;
TYPEDEF_VK_TO_WCHARS(4) // VK_TO_WCHARS4, *PVK_TO_WCHARS4;
TYPEDEF_VK_TO_WCHARS(5) // VK_TO_WCHARS5, *PVK_TO_WCHARS5;
TYPEDEF_VK_TO_WCHARS(6) // VK_TO_WCHARS6, *PVK_TO_WCHARS5;
TYPEDEF_VK_TO_WCHARS(7) // VK_TO_WCHARS7, *PVK_TO_WCHARS7;
// these three (8,9,10) are for FE
TYPEDEF_VK_TO_WCHARS(8) // VK_TO_WCHARS8, *PVK_TO_WCHARS8;
TYPEDEF_VK_TO_WCHARS(9) // VK_TO_WCHARS9, *PVK_TO_WCHARS9;
TYPEDEF_VK_TO_WCHARS(10) // VK_TO_WCHARS10, *PVK_TO_WCHARS10;

/***************************************************************************\
*
* VK_TO_WCHAR_TABLE - Describe a table of VK_TO_WCHARS1
*
* pVkToWchars     - points to the table.
* nModifications  - the number of shift-states supported by this table.
*                   (this is the number of elements in pVkToWchars[*].wch[])
*
* A keyboard may have several such tables: all keys with the same number of
*    shift-states are grouped together in one table.
*
* Special values for pVktoWchars:
*     NULL     - Terminates a VK_TO_WCHAR_TABLE[] list.
*
\***************************************************************************/

typedef struct _VK_TO_WCHAR_TABLE {
    PVK_TO_WCHARS1 pVkToWchars;
    BYTE           nModifications;
    BYTE           cbSize;
} VK_TO_WCHAR_TABLE, *PVK_TO_WCHAR_TABLE;

/***************************************************************************\
*
* Dead Key (diaresis) tables
*
* LATER IanJa: supplant by an NLS API that composes Diacritic+Base -> WCHAR
*
\***************************************************************************/
typedef struct {
    DWORD  dwBoth;  // diacritic & char
    WCHAR  wchComposed;
    USHORT uFlags;
} DEADKEY, *PDEADKEY;

#define DEADTRANS(ch, accent, comp, flags) { MAKELONG(ch, accent), comp, flags}

/*
 * Bit values for uFlags
 */
#define DKF_DEAD  0x0001

/***************************************************************************\
*
* Ligature table
*
\***************************************************************************/
/*
 * Macro for ligature with "n" characters
 */
#define TYPEDEF_LIGATURE(n) typedef struct _LIGATURE##n {     \
                                    BYTE  VirtualKey;         \
                                    WORD  ModificationNumber; \
                                    WCHAR wch[n];             \
                                } LIGATURE##n, *PLIGATURE##n;

/*
 * To facilitate coding the table scanning routine.
 */

/*
 * Table element types (for various numbers of ligatures), used
 * to facilitate static initializations of tables.
 *
 * LIGATURE1 and PLIGATURE1 are used as the generic type
 */
TYPEDEF_LIGATURE(1) // LIGATURE1, *PLIGATURE1;
TYPEDEF_LIGATURE(2) // LIGATURE2, *PLIGATURE2;
TYPEDEF_LIGATURE(3) // LIGATURE3, *PLIGATURE3;
TYPEDEF_LIGATURE(4) // LIGATURE4, *PLIGATURE4;
TYPEDEF_LIGATURE(5) // LIGATURE5, *PLIGATURE5;

/***************************************************************************\
* VSC_LPWSTR - associate a Virtual Scancode with a Text string
*
* Uses:
*   GetKeyNameText(), aKeyNames[]  Map virtual scancode to name of key
*
\***************************************************************************/
typedef struct {
    BYTE   vsc;
    LPWSTR pwsz;
} VSC_LPWSTR, *PVSC_LPWSTR;

/*
 * Along with ligature support we're adding a proper version number.
 * The previous version number (actually just unused bits...) was
 * always zero.  The version number will live in the high word of
 * fLocaleFlags.
 */
#define KBD_VERSION         1
#define GET_KBD_VERSION(p)  (HIWORD((p)->fLocaleFlags))

/*
 * Attributes such as AltGr, LRM_RLM, ShiftLock are stored in the the low word
 * of fLocaleFlags (layout specific) or in gdwKeyboardAttributes (all layouts)
 */
#define KLLF_ALTGR       0x0001
#define KLLF_SHIFTLOCK   0x0002
#define KLLF_LRM_RLM     0x0004

/*
 * Some attributes are per-layout (specific to an individual layout), some
 * attributes are per-user (apply globally to all layouts).  Some are both.
 */
#define KLLF_LAYOUT_ATTRS (KLLF_SHIFTLOCK | KLLF_ALTGR | KLLF_LRM_RLM)
#define KLLF_GLOBAL_ATTRS (KLLF_SHIFTLOCK)

/*
 * Flags passed in to the KeyboardLayout API (KLF_*) as can be converted to
 * internal (KLLF_*) attributes:
 */
#define KLL_ATTR_FROM_KLF(x)         ((x) >> 15)
#define KLL_LAYOUT_ATTR_FROM_KLF(x)  (KLL_ATTR_FROM_KLF(x) & KLLF_LAYOUT_ATTRS)
#define KLL_GLOBAL_ATTR_FROM_KLF(x)  (KLL_ATTR_FROM_KLF(x) & KLLF_GLOBAL_ATTRS)

/*
 * If KLF_SHIFTLOCK & KLF_LRM_RLM are defined, we can check the KLLF_* values
 */
#ifdef KLF_SHIFTLOCK
#if KLLF_SHIFTLOCK != KLL_ATTR_FROM_KLF(KLF_SHIFTLOCK)
    #error KLLF_SHIFTLOCK != KLL_ATTR_FROM_KLF(KLF_SHIFTLOCK)
#endif
#endif // KLF_SHIFTLOCK
#ifdef KLF_LRM_RLM
#if KLLF_LRM_RLM != KLL_ATTR_FROM_KLF(KLF_LRM_RLM)
    #error KLLF_LRM_RLM != KLL_ATTR_FROM_KLF(KLF_LRM_RLM)
#endif
#endif // KLF_LRM_RLM

/***************************************************************************\
* KBDTABLES
*
* This structure describes all the tables that implement the keyboard layer.
*
* When switching to a new layer, we get a new KBDTABLES structure: all key
* processing tables are accessed indirectly through this structure.
*
\***************************************************************************/

typedef struct tagKbdLayer {
    /*
     * Modifier keys
     */
    PMODIFIERS pCharModifiers;

    /*
     * Characters
     */
    VK_TO_WCHAR_TABLE *pVkToWcharTable;  // ptr to tbl of ptrs to tbl

    /*
     * Diacritics
     */
    PDEADKEY pDeadKey;

    /*
     * Names of Keys
     */
    VSC_LPWSTR *pKeyNames;
    VSC_LPWSTR *pKeyNamesExt;
    LPWSTR     *pKeyNamesDead;

    /*
     * Scan codes to Virtual Keys
     */
    USHORT *pusVSCtoVK;
    BYTE    bMaxVSCtoVK;
    PVSC_VK pVSCtoVK_E0;  // Scancode has E0 prefix
    PVSC_VK pVSCtoVK_E1;  // Scancode has E1 prefix

    /*
     * Locale-specific special processing
     */
    DWORD fLocaleFlags;

    /*
     * Ligatures
     */
    BYTE       nLgMax;
    BYTE       cbLgEntry;
    PLIGATURE1 pLigature;
} KBDTABLES, *PKBDTABLES;

/*
 * OEM-specific special processing (keystroke simulators and filters)
 */
extern KEPROC aKEProcOEM[];

/*
 * FarEast-specific special...
 */
typedef struct _VK_FUNCTION_PARAM {
    BYTE  NLSFEProcIndex;
    ULONG NLSFEProcParam;
} VK_FPARAM, *PVK_FPARAM;

typedef struct _VK_TO_FUNCTION_TABLE {
    BYTE Vk;
    BYTE NLSFEProcType;
    BYTE NLSFEProcCurrent;
    // Index[0] : Base
    // Index[1] : Shift
    // Index[2] : Control
    // Index[3] : Shift+Control
    // Index[4] : Alt
    // Index[5] : Shift+Alt
    // Index[6] : Control+Alt
    // Index[7] : Shift+Control+Alt
    BYTE NLSFEProcSwitch;   // 8 bits
    VK_FPARAM NLSFEProc[8];
    VK_FPARAM NLSFEProcAlt[8];
} VK_F, *PVK_F;

typedef struct tagKbdNlsLayer {
    USHORT OEMIdentifier;
    USHORT LayoutInformation;
    UINT  NumOfVkToF;
    VK_F   *pVkToF;
    //
    // The pusMouseVKey array provides a translation from the virtual key
    // value to an index.  The index is used to select the appropriate
    // routine to process the virtual key, as well as to select extra
    // information that is used by this routine during its processing.
    // If this value is NULL, following default will be used.
    //
    // ausMouseVKey[] = {
    //     VK_CLEAR,           // Numpad 5: Click active button
    //     VK_PRIOR,           // Numpad 9: Up & Right
    //     VK_NEXT,            // Numpad 3: Down & Right
    //     VK_END,             // Numpad 1: Down & Left
    //     VK_HOME,            // Numpad 7: Up & Left
    //     VK_LEFT,            // Numpad 4: Left
    //     VK_UP,              // Numpad 8: Up
    //     VK_RIGHT,           // Numpad 6: Right
    //     VK_DOWN,            // Numpad 2: Down
    //     VK_INSERT,          // Numpad 0: Active button down
    //     VK_DELETE,          // Numpad .: Active button up
    //     VK_MULTIPLY,        // Numpad *: Select both buttons
    //     VK_ADD,             // Numpad +: Double click active button
    //     VK_SUBTRACT,        // Numpad -: Select right button
    //     VK_DEVIDE|KBDEXT,   // Numpad /: Select left button
    //     VK_NUMLOCK|KBDEXT}; // Num Lock
    //
    INT     NumOfMouseVKey;
    USHORT *pusMouseVKey;
} KBDNLSTABLES, *PKBDNLSTABLES;

//
// OEM Ids - KBDNLSTABLES.OEMIdentifier
//
// PSS ID Number: Q130054
// Article last modified on 05-16-1995
//
// 3.10 1.20 | 3.50 1.20
// WINDOWS   | WINDOWS NT
//
// ---------------------------------------------------------------------
// The information in this article applies to:
// - Microsoft Windows Software Development Kit (SDK) for Windows
//   version 3.1
// - Microsoft Win32 Software Development Kit (SDK) version 3.5
// - Microsoft Win32s version 1.2
// ---------------------------------------------------------------------
// SUMMARY
// =======
// Because of the variety of computer manufacturers (NEC, Fujitsu, IBMJ, and
// so on) in Japan, sometimes Windows-based applications need to know which
// OEM (original equipment manufacturer) manufactured the computer that is
// running the application. This article explains how.
//
// MORE INFORMATION
// ================
// There is no documented way to detect the manufacturer of the computer that
// is currently running an application. However, a Windows-based application
// can detect the type of OEM Windows by using the return value of the
// GetKeyboardType() function.
//
// If an application uses the GetKeyboardType API, it can get OEM ID by
// specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
// is listed here:
//
// OEM Windows       OEM ID
// ------------------------------
// Microsoft         00H (DOS/V)
// all AX            01H
// EPSON             04H
// Fujitsu           05H
// IBMJ              07H
// Matsushita        0AH
// NEC               0DH
// Toshiba           12H
//
// Application programs can use these OEM IDs to distinguish the type of OEM
// Windows. Note, however, that this method is not documented, so Microsoft
// may not support it in the future version of Windows.
//
// As a rule, application developers should write hardware-independent code,
// especially when making Windows-based applications. If they need to make a
// hardware-dependent application, they must prepare the separated program
// file for each different hardware architecture.
//
// Additional reference words: 3.10 1.20 3.50 1.20 kbinf
// KBCategory: kbhw
// KBSubcategory: wintldev
// =============================================================================
// Copyright Microsoft Corporation 1995.
//
#define NLSKBD_OEM_MICROSOFT          0x00
#define NLSKBD_OEM_AX                 0x01
#define NLSKBD_OEM_EPSON              0x04
#define NLSKBD_OEM_FUJITSU            0x05
#define NLSKBD_OEM_IBM                0x07
#define NLSKBD_OEM_MATSUSHITA         0x0A
#define NLSKBD_OEM_NEC                0x0D
#define NLSKBD_OEM_TOSHIBA            0x12
#define NLSKBD_OEM_DEC                0x18 // only NT
//
// Microsoft (default) - keyboards hardware/layout
//
#define MICROSOFT_KBD_101_TYPE           0
#define MICROSOFT_KBD_AX_TYPE            1
#define MICROSOFT_KBD_106_TYPE           2
#define MICROSOFT_KBD_002_TYPE           3
#define MICROSOFT_KBD_001_TYPE           4
#define MICROSOFT_KBD_FUNC              12
//
// AX consortium - keyboards hardware/layout
//
#define AX_KBD_DESKTOP_TYPE              1
//
// Fujitsu - keyboards hardware/layout
//
#define FMR_KBD_JIS_TYPE                 0
#define FMR_KBD_OASYS_TYPE               1
#define FMV_KBD_OASYS_TYPE               2
//
// NEC - keyboards hardware/layout
//
#define NEC_KBD_NORMAL_TYPE              1
#define NEC_KBD_N_MODE_TYPE              2
#define NEC_KBD_H_MODE_TYPE              3
#define NEC_KBD_LAPTOP_TYPE              4
#define NEC_KBD_106_TYPE                 5
//
// Toshiba - keyboards hardware/layout
//
#define TOSHIBA_KBD_DESKTOP_TYPE        13
#define TOSHIBA_KBD_LAPTOP_TYPE         15
//
// DEC - keyboards hardware/layout
//
#define DEC_KBD_ANSI_LAYOUT_TYPE         1 // only NT
#define DEC_KBD_JIS_LAYOUT_TYPE          2 // only NT

//
// Keyboard layout information - KBDNLSTABLE.LayoutInformation
//

//
// If this flag is on, System sends notification to keyboard
// drivers (leyout/kernel mode). when IME (Input-Mehod-Editor)
// status become changed.
//
#define NLSKBD_INFO_SEND_IME_NOTIFICATION  0x0001

//
// If this flag is on, System will use VK_HOME/VK_KANA instead of
// VK_NUMLOCK/VK_SCROLL for Accessibility toggle keys.
// + Typically, NEC PC-9800 Series will use this bit, because
//   they does not have 'NumLock' and 'ScrollLock' keys.
//
#define NLSKBD_INFO_ACCESSIBILITY_KEYMAP   0x0002

//
// If this flag is on, System will return 101 or 106 Japanese
// keyboard type/subtype id, when GetKeyboardType() is called.
//
#define NLSKBD_INFO_EMURATE_101_KEYBOARD   0x0010
#define NLSKBD_INFO_EMURATE_106_KEYBOARD   0x0020

//
// Keyboard layout function types
//
// - VK_F.NLSFEProcType
//
#define KBDNLS_TYPE_NULL      0
#define KBDNLS_TYPE_NORMAL    1
#define KBDNLS_TYPE_TOGGLE    2

//
// - VK_F.NLSFEProcCurrent
//
#define KBDNLS_INDEX_NORMAL   1
#define KBDNLS_INDEX_ALT      2

//
// - VK_F.NLSFEProc[]
//
#define KBDNLS_NULL             0 // Invalid function
#define KBDNLS_NOEVENT          1 // Drop keyevent
#define KBDNLS_SEND_BASE_VK     2 // Send Base VK_xxx
#define KBDNLS_SEND_PARAM_VK    3 // Send Parameter VK_xxx
#define KBDNLS_KANALOCK         4 // VK_KANA (with hardware lock)
#define KBDNLS_ALPHANUM         5 // VK_DBE_ALPHANUMERIC
#define KBDNLS_HIRAGANA         6 // VK_DBE_HIRAGANA
#define KBDNLS_KATAKANA         7 // VK_DBE_KATAKANA
#define KBDNLS_SBCSDBCS         8 // VK_DBE_SBCSCHAR/VK_DBE_DBCSCHAR
#define KBDNLS_ROMAN            9 // VK_DBE_ROMAN/VK_DBE_NOROMAN
#define KBDNLS_CODEINPUT       10 // VK_DBE_CODEINPUT/VK_DBE_NOCODEINPUT
#define KBDNLS_HELP_OR_END     11 // VK_HELP or VK_END [NEC PC-9800 Only]
#define KBDNLS_HOME_OR_CLEAR   12 // VK_HOME or VK_CLEAR [NEC PC-9800 Only]
#define KBDNLS_NUMPAD          13 // VK_NUMPAD? for Numpad key [NEC PC-9800 Only]
#define KBDNLS_KANAEVENT       14 // VK_KANA [Fujitsu FMV oyayubi Only]
#define KBDNLS_CONV_OR_NONCONV 15 // VK_CONVERT and VK_NONCONVERT [Fujitsu FMV oyayubi Only]

typedef BOOL (* NLSKEPROC)(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam);
typedef BOOL (* NLSVKFPROC)(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo);

//
// Keyboard Type = 7 : Japanese Keyboard
// Keyboard Type = 8 : Korean Keyboard
//
#define JAPANESE_KEYBOARD(Id)  ((Id).Type == 7)
#define KOREAN_KEYBOARD(Id)    ((Id).Type == 8)

// Fujitsu Oyayubi-shift keyboard
#define FUJITSU_KBD_CONSOLE(Id)  (JAPANESE_KEYBOARD(Id) && \
                                  (Id).Subtype == ((NLSKBD_OEM_FUJITSU<<4)|FMV_KBD_OASYS_TYPE))
        // This number 0x00020002 is registered in registry key as
        // HKLM\System\CurrentControlSet\Control\Terminal Server\KeyboardType Mapping\JPN
#define FUJITSU_KBD_REMOTE(Id)   (JAPANESE_KEYBOARD(Id) && \
                                  (Id).SubType == 0x00020002)

#define KBD_LAYOUT_LANG(hkl)    (LOBYTE(LOWORD(HandleToUlong(hkl))))

#define JAPANESE_KBD_LAYOUT(hkl)    (KBD_LAYOUT_LANG(hkl) == LANG_JAPANESE)
#define KOREAN_KBD_LAYOUT(hkl)      (KBD_LAYOUT_LANG(hkl) == LANG_KOREAN)

//
// NLS Keyboard functions
//
VOID NlsKbdInitializePerSystem(VOID);
VOID NlsKbdSendIMENotification(DWORD dwImeOpen, DWORD dwImeConversion);

// end of FE specific

/***************************************************************************\
* Macros for ausVK[] values (used below)
*
* These macros prefix each argument with VK_ to produce the name of a Virtual
* Key defined in "winuser.h" (eg: ESCAPE becomes VK_ESCAPE).
\***************************************************************************/
#ifndef KBD_TYPE
#define KBD_TYPE 4
#endif

/*
 * _NE() selects the Virtual Key according to keyboard type
 */
#if   (KBD_TYPE == 1)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v1)
#elif (KBD_TYPE == 2)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v2)
#elif (KBD_TYPE == 3)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v3)
#elif (KBD_TYPE == 4)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v4)
#elif (KBD_TYPE == 5)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v5)
#elif (KBD_TYPE == 6)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v6)
#elif (KBD_TYPE == 7)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v7)
#elif (KBD_TYPE == 8)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v8)
#elif (KBD_TYPE == 10)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v10)
#elif (KBD_TYPE == 11)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v11)
#elif (KBD_TYPE == 12)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v12)
#elif (KBD_TYPE == 13)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v13)
#elif (KBD_TYPE == 16)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v16)
#elif (KBD_TYPE == 20)
#define _NE(v20,v21,v22)           (VK_##v20)
#elif (KBD_TYPE == 21)
#define _NE(v20,v21,v22)           (VK_##v21)
#elif (KBD_TYPE == 22)
#define _NE(v20,v21,v22)           (VK_##v22)
#elif (KBD_TYPE == 30)
#define _NE(v30,v33,v34)           (VK_##v30)
#elif (KBD_TYPE == 33)
#define _NE(v30,v33,v34)           (VK_##v33)
#elif (KBD_TYPE == 34)
#define _NE(v30,v33,v34)           (VK_##v34)
#elif (KBD_TYPE == 40)
#define _NE(v40,v41)               (VK_##v40)
#elif (KBD_TYPE == 41)
#define _NE(v40,v41)               (VK_##v41)
#endif

/*
 * _EQ() selects the same Virtual Key for all keyboard types
 */
#if   (KBD_TYPE <= 6)
#define _EQ(         v4      ) (VK_##v4)
#elif (KBD_TYPE >= 7) && (KBD_TYPE <= 16)
#define _EQ(   v8            ) (VK_##v8)
#elif (KBD_TYPE > 20) && (KBD_TYPE <= 22)
#define _EQ(v20              ) (VK_##v20)
#elif (KBD_TYPE >= 30) && (KBD_TYPE <= 34)
#define _EQ(         v30     ) (VK_##v30)
#elif (KBD_TYPE == 37)
#define _EQ(         v37     ) (VK_##v37)
#elif (KBD_TYPE >= 40) && (KBD_TYPE <= 41)
#define _EQ( v40             ) (VK_##v40)
#endif

/*
 * A bit of trickery for virtual key names 'A' to 'Z' and '0' to '9' so
 * that they are not converted to a VK_* name.
 * With this macro, VK_'A' equates to 'A' etc.
 */
#define VK_
#define VK__none_   0xFF
#define VK_ABNT_C1  0xC1
#define VK_ABNT_C2  0xC2

#if (KBD_TYPE <= 6)
/***************************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* These values are for Scancode Set 3 and the USA.
* Other languages substitute their own values where required (files kbd**.h)
*
* Six sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =======================================================
*    1       AT&T '301' & '302'; Olivetti 83-key; PC-XT 84-key; etc.
*    2       Olivetti M24 102-key
*    3       HP Vectra (DIN); Olivetti 86-key; etc.
*    4 *     Enhanced 101/102-key; Olivetti A; etc.
*    5       Nokia (Ericsson) type 5 (1050, etc.)
*    6       Nokia (Ericsson) type 6 (9140)
*
* * If KBD_TYPE is not defined, the default is type 4.
*
* KB3270 comments refers to KB 3270 keyboards in native emulation mode (DIP
* switches all OFF), and the Scancode Map used to convert its scancodes to
* standard scancode set 1.
*    KB3270 <= 57      - this entry is reached by mapping from scancode 0x57
*                        to an arbitrary scancode: the VK is what counts
*    KB3270 => HOME    - this scancode is mapped to the scancode for VK_HOME
*    KB3270            - no mapping involved, a scancode for KB3270 only
*
* _EQ() : all keyboard types have the same virtual key for this scancode
* _NE() : different virtual keys for this scancode, depending on kbd type
*
*     +------+ +--------+--------+--------+--------+--------+--------+
*     | Scan | |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |
*     | code | | type 1 | type 2 | type 3 | type 4 | type 5 | type 6 |
\****+-------+-+--------+--------+--------+--------+--------+--------+******/
#define T00 _EQ(                           _none_                    )
#define T01 _EQ(                           ESCAPE                    )
#define T02 _EQ(                           '1'                       )
#define T03 _EQ(                           '2'                       )
#define T04 _EQ(                           '3'                       )
#define T05 _EQ(                           '4'                       )
#define T06 _EQ(                           '5'                       )
#define T07 _EQ(                           '6'                       )
#define T08 _EQ(                           '7'                       )
#define T09 _EQ(                           '8'                       )
#define T0A _EQ(                           '9'                       )
#define T0B _EQ(                           '0'                       )
#define T0C _EQ(                           OEM_MINUS                 )
#define T0D _NE(OEM_PLUS,OEM_4,   OEM_PLUS,OEM_PLUS,OEM_PLUS,OEM_PLUS)
#define T0E _EQ(                           BACK                      )
#define T0F _EQ(                           TAB                       )
#define T10 _EQ(                           'Q'                       )
#define T11 _EQ(                           'W'                       )
#define T12 _EQ(                           'E'                       )
#define T13 _EQ(                           'R'                       )
#define T14 _EQ(                           'T'                       )
#define T15 _EQ(                           'Y'                       )
#define T16 _EQ(                           'U'                       )
#define T17 _EQ(                           'I'                       )
#define T18 _EQ(                           'O'                       )
#define T19 _EQ(                           'P'                       )
#define T1A _NE(OEM_4,   OEM_6,   OEM_4,   OEM_4,   OEM_4,   OEM_4   )
#define T1B _NE(OEM_6,   OEM_1,   OEM_6,   OEM_6,   OEM_6,   OEM_6   )
#define T1C _EQ(                           RETURN                    )
#define T1D _EQ(                           LCONTROL                  )
#define T1E _EQ(                           'A'                       )
#define T1F _EQ(                           'S'                       )
#define T20 _EQ(                           'D'                       )
#define T21 _EQ(                           'F'                       )
#define T22 _EQ(                           'G'                       )
#define T23 _EQ(                           'H'                       )
#define T24 _EQ(                           'J'                       )
#define T25 _EQ(                           'K'                       )
#define T26 _EQ(                           'L'                       )
#define T27 _NE(OEM_1,   OEM_PLUS,OEM_1,   OEM_1,   OEM_1,   OEM_1   )
#define T28 _NE(OEM_7,   OEM_3,   OEM_7,   OEM_7,   OEM_3,   OEM_3   )
#define T29 _NE(OEM_3,   OEM_7,   OEM_3,   OEM_3,   OEM_7,   OEM_7   )
#define T2A _EQ(                           LSHIFT                    )
#define T2B _EQ(                           OEM_5                     )
#define T2C _EQ(                           'Z'                       )
#define T2D _EQ(                           'X'                       )
#define T2E _EQ(                           'C'                       )
#define T2F _EQ(                           'V'                       )
#define T30 _EQ(                           'B'                       )
#define T31 _EQ(                           'N'                       )
#define T32 _EQ(                           'M'                       )
#define T33 _EQ(                           OEM_COMMA                 )
#define T34 _EQ(                           OEM_PERIOD                )
#define T35 _EQ(                           OEM_2                     )
#define T36 _EQ(                           RSHIFT                    )
#define T37 _EQ(                           MULTIPLY                  )
#define T38 _EQ(                           LMENU                     )
#define T39 _EQ(                           ' '                       )
#define T3A _EQ(                           CAPITAL                   )
#define T3B _EQ(                           F1                        )
#define T3C _EQ(                           F2                        )
#define T3D _EQ(                           F3                        )
#define T3E _EQ(                           F4                        )
#define T3F _EQ(                           F5                        )
#define T40 _EQ(                           F6                        )
#define T41 _EQ(                           F7                        )
#define T42 _EQ(                           F8                        )
#define T43 _EQ(                           F9                        )
#define T44 _EQ(                           F10                       )
#define T45 _EQ(                           NUMLOCK                   )
#define T46 _EQ(                           SCROLL                    )
#define T47 _EQ(                           HOME                      )
#define T48 _EQ(                           UP                        )
#define T49 _EQ(                           PRIOR                     )
#define T4A _EQ(                           SUBTRACT                  )
#define T4B _EQ(                           LEFT                      )
#define T4C _EQ(                           CLEAR                     )
#define T4D _EQ(                           RIGHT                     )
#define T4E _EQ(                           ADD                       )
#define T4F _EQ(                           END                       )
#define T50 _EQ(                           DOWN                      )
#define T51 _EQ(                           NEXT                      )
#define T52 _EQ(                           INSERT                    )
#define T53 _EQ(                           DELETE                    )
#define T54 _EQ(                           SNAPSHOT                  )
#define T55 _EQ(                           _none_                    ) // KB3270 => DOWN
#define T56 _NE(OEM_102, HELP,    OEM_102, OEM_102, _none_,  OEM_PA2 ) // KB3270 => LEFT
#define T57 _NE(F11,     RETURN,  F11,     F11,     _none_,  HELP    ) // KB3270 => ZOOM
#define T58 _NE(F12,     LEFT,    F12,     F12,     _none_,  OEM_102 ) // KB3270 => HELP
#define T59 _EQ(                           CLEAR                     )
#define T5A _EQ(                           OEM_WSCTRL                )// WSCtrl
#define T5B _EQ(                           OEM_FINISH                )// Finish
#define T5C _EQ(                           OEM_JUMP                  )// Jump
#define T5D _EQ(                           EREOF                     )
#define T5E _EQ(                           OEM_BACKTAB               ) // KB3270 <= 7E
#define T5F _EQ(                           OEM_AUTO                  ) // KB3270
#define T60 _EQ(                           _none_                    )
#define T61 _EQ(                           _none_                    )
#define T62 _EQ(                           ZOOM                      ) // KB3270 <= 57
#define T63 _EQ(                           HELP                      ) // KB3270 <= 58
#define T64 _EQ(                           F13                       )
#define T65 _EQ(                           F14                       )
#define T66 _EQ(                           F15                       )
#define T67 _EQ(                           F16                       )
#define T68 _EQ(                           F17                       )
#define T69 _EQ(                           F18                       )
#define T6A _EQ(                           F19                       )
#define T6B _EQ(                           F20                       )
#define T6C _EQ(                           F21                       )
#define T6D _EQ(                           F22                       )
#define T6E _EQ(                           F23                       )
#define T6F _EQ(                           OEM_PA3                   ) // KB3270
#define T70 _EQ(                           _none_                    )
#define T71 _EQ(                           OEM_RESET                 ) // KB3270
#define T72 _EQ(                           _none_                    )
#define T73 _EQ(                           ABNT_C1                   )
#define T74 _EQ(                           _none_                    )
#define T75 _EQ(                           _none_                    ) // KB3270 => RETURN
#define T76 _EQ(                           F24                       )
#define T77 _EQ(                           _none_                    ) // KB3270 => HOME
#define T78 _EQ(                           _none_                    ) // KB3270 => UP
#define T79 _EQ(                           _none_                    ) // KB3270 => DELETE
#define T7A _EQ(                           _none_                    ) // KB3270 => INSERT
#define T7B _EQ(                           OEM_PA1                   ) // KB3270
#define T7C _EQ(                           TAB                       ) // KB3270 => TAB
#define T7D _EQ(                           _none_                    ) // KB3270 => RIGHT
#define T7E _EQ(                           ABNT_C2                   ) // KB3270 => BACKTAB
#define T7F _EQ(                           OEM_PA2                   ) // KB3270

#define X10 _EQ(                           MEDIA_PREV_TRACK          ) // SpeedRacer
#define X19 _EQ(                           MEDIA_NEXT_TRACK          ) // SpeedRacer
#define X1C _EQ(                           RETURN                    )
#define X1D _EQ(                           RCONTROL                  )
#define X20 _EQ(                           VOLUME_MUTE               ) // SpeedRacer
#define X21 _EQ(                           LAUNCH_APP2               ) // SpeedRacer (Calculator?)
#define X22 _EQ(                           MEDIA_PLAY_PAUSE          ) // SpeedRacer
#define X24 _EQ(                           MEDIA_STOP                ) // SpeedRacer
#define X2E _EQ(                           VOLUME_DOWN               ) // SpeedRacer
#define X30 _EQ(                           VOLUME_UP                 ) // SpeedRacer
#define X32 _EQ(                           BROWSER_HOME              ) // SpeedRacer
#define X35 _EQ(                           DIVIDE                    )
#define X37 _EQ(                           SNAPSHOT                  )
#define X38 _EQ(                           RMENU                     )
#define X46 _EQ(                           CANCEL                    )
#define X47 _EQ(                           HOME                      )
#define X48 _EQ(                           UP                        )
#define X49 _EQ(                           PRIOR                     )
#define X4B _EQ(                           LEFT                      )
#define X4D _EQ(                           RIGHT                     )
#define X4F _EQ(                           END                       )
#define X50 _EQ(                           DOWN                      )
#define X51 _NE(NEXT,    F1,      NEXT,    NEXT,    _none_, OEM_PA2  )
#define X52 _EQ(                           INSERT                    )
#define X53 _EQ(                           DELETE                    )
#define X5B _EQ(                           LWIN                      )
#define X5C _EQ(                           RWIN                      )
#define X5D _EQ(                           APPS                      )
#define X5E _EQ(                           POWER                     )
#define X5F _EQ(                           SLEEP                     ) // SpeedRacer
#define X65 _EQ(                           BROWSER_SEARCH            ) // SpeedRacer
#define X66 _EQ(                           BROWSER_FAVORITES         ) // SpeedRacer
#define X67 _EQ(                           BROWSER_REFRESH           ) // SpeedRacer
#define X68 _EQ(                           BROWSER_STOP              ) // SpeedRacer
#define X69 _EQ(                           BROWSER_FORWARD           ) // SpeedRacer
#define X6A _EQ(                           BROWSER_BACK              ) // SpeedRacer
#define X6B _EQ(                           LAUNCH_APP1               ) // SpeedRacer (my computer?)
#define X6C _EQ(                           LAUNCH_MAIL               ) // SpeedRacer
#define X6D _EQ(                           LAUNCH_MEDIA_SELECT       ) // SpeedRacer


        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(                           PAUSE                     )

#elif (KBD_TYPE >= 7) && (KBD_TYPE <= 16)
/***********************************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*    7       Japanese IBM type 002 keyboard.
*    8 *     Japanese OADG (106) keyboard.
*   10       Korean 101 (type A) keyboard.
*   11       Korean 101 (type B) keyboard.
*   12       Korean 101 (type C) keyboard.
*   13       Korean 103 keyboard.
*   16       Japanese AX keyboard.
*
*     +------+ +----------+----------+----------+----------+----------+----------+----------+
*     | Scan | |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |
*     | code | |  type 7  |  type 8  |  type 16 |  type 10 |  type 11 |  type 12 |  type 13 |
\****+-------+-+----------+----------+----------+----------+----------+----------+----------+*/
#define T00 _EQ(           _none_                                                           )
#define T01 _EQ(           ESCAPE                                                           )
#define T02 _EQ(           '1'                                                              )
#define T03 _EQ(           '2'                                                              )
#define T04 _EQ(           '3'                                                              )
#define T05 _EQ(           '4'                                                              )
#define T06 _EQ(           '5'                                                              )
#define T07 _EQ(           '6'                                                              )
#define T08 _EQ(           '7'                                                              )
#define T09 _EQ(           '8'                                                              )
#define T0A _EQ(           '9'                                                              )
#define T0B _EQ(           '0'                                                              )
#define T0C _EQ(           OEM_MINUS                                                        )
#define T0D _NE(OEM_7,     OEM_7,     OEM_PLUS,  OEM_PLUS,  OEM_PLUS,  OEM_PLUS,  OEM_PLUS  )
#define T0E _EQ(           BACK                                                             )
#define T0F _EQ(           TAB                                                              )
#define T10 _EQ(           'Q'                                                              )
#define T11 _EQ(           'W'                                                              )
#define T12 _EQ(           'E'                                                              )
#define T13 _EQ(           'R'                                                              )
#define T14 _EQ(           'T'                                                              )
#define T15 _EQ(           'Y'                                                              )
#define T16 _EQ(           'U'                                                              )
#define T17 _EQ(           'I'                                                              )
#define T18 _EQ(           'O'                                                              )
#define T19 _EQ(           'P'                                                              )
#define T1A _NE(OEM_4,     OEM_3,     OEM_4,     OEM_4,     OEM_4,     OEM_4,     OEM_4     )
#define T1B _NE(OEM_6,     OEM_4,     OEM_6,     OEM_6,     OEM_6,     OEM_6,     OEM_6     )
#define T1C _EQ(           RETURN                                                           )
#define T1D _EQ(           LCONTROL                                                         )
#define T1E _EQ(           'A'                                                              )
#define T1F _EQ(           'S'                                                              )
#define T20 _EQ(           'D'                                                              )
#define T21 _EQ(           'F'                                                              )
#define T22 _EQ(           'G'                                                              )
#define T23 _EQ(           'H'                                                              )
#define T24 _EQ(           'J'                                                              )
#define T25 _EQ(           'K'                                                              )
#define T26 _EQ(           'L'                                                              )
#define T27 _NE(OEM_PLUS,  OEM_PLUS,  OEM_1,     OEM_1,     OEM_1,     OEM_1,     OEM_1     )
#define T28 _NE(OEM_1,     OEM_1,     OEM_7,     OEM_7,     OEM_7,     OEM_7,     OEM_7     )
#define T29 _NE(OEM_3,     DBE_SBCSCHAR,OEM_3,   OEM_3,     OEM_3,     OEM_3,     OEM_3     )
#define T2A _EQ(           LSHIFT                                                           )
#define T2B _NE(OEM_5,     OEM_6,     OEM_5,     OEM_5,     OEM_5,     OEM_5,     OEM_5     )
#define T2C _EQ(           'Z'                                                              )
#define T2D _EQ(           'X'                                                              )
#define T2E _EQ(           'C'                                                              )
#define T2F _EQ(           'V'                                                              )
#define T30 _EQ(           'B'                                                              )
#define T31 _EQ(           'N'                                                              )
#define T32 _EQ(           'M'                                                              )
#define T33 _EQ(           OEM_COMMA                                                        )
#define T34 _EQ(           OEM_PERIOD                                                       )
#define T35 _EQ(           OEM_2                                                            )
#define T36 _EQ(           RSHIFT                                                           )
#define T37 _EQ(           MULTIPLY                                                         )
#define T38 _EQ(           LMENU                                                            )
#define T39 _EQ(           ' '                                                              )
#define T3A _NE(DBE_ALPHANUMERIC,DBE_ALPHANUMERIC,CAPITAL,CAPITAL,CAPITAL,CAPITAL,CAPITAL   )
#define T3B _EQ(           F1                                                               )
#define T3C _EQ(           F2                                                               )
#define T3D _EQ(           F3                                                               )
#define T3E _EQ(           F4                                                               )
#define T3F _EQ(           F5                                                               )
#define T40 _EQ(           F6                                                               )
#define T41 _EQ(           F7                                                               )
#define T42 _EQ(           F8                                                               )
#define T43 _EQ(           F9                                                               )
#define T44 _EQ(           F10                                                              )
#define T45 _EQ(           NUMLOCK                                                          )
#define T46 _EQ(           SCROLL                                                           )
#define T47 _EQ(           HOME                                                             )
#define T48 _EQ(           UP                                                               )
#define T49 _EQ(           PRIOR                                                            )
#define T4A _EQ(           SUBTRACT                                                         )
#define T4B _EQ(           LEFT                                                             )
#define T4C _EQ(           CLEAR                                                            )
#define T4D _EQ(           RIGHT                                                            )
#define T4E _EQ(           ADD                                                              )
#define T4F _EQ(           END                                                              )
#define T50 _EQ(           DOWN                                                             )
#define T51 _EQ(           NEXT                                                             )
#define T52 _EQ(           INSERT                                                           )
#define T53 _EQ(           DELETE                                                           )
#define T54 _EQ(           SNAPSHOT                                                         )
#define T55 _EQ(           _none_                                                           )
#define T56 _NE(_none_,    _none_,    OEM_102,   OEM_102,   OEM_102,   OEM_102,   OEM_102   )
#define T57 _EQ(           F11                                                              )
#define T58 _EQ(           F12                                                              )
#define T59 _EQ(           CLEAR                                                            )
#define T5A _NE(NONAME,    NONAME,    NONCONVERT,OEM_WSCTRL,OEM_WSCTRL,OEM_WSCTRL,OEM_WSCTRL)
#define T5B _NE(NONAME,    NONAME,    CONVERT,   OEM_FINISH,OEM_FINISH,OEM_FINISH,OEM_FINISH)
#define T5C _NE(NONAME,    NONAME,    OEM_AX,    OEM_JUMP,  OEM_JUMP,  OEM_JUMP,  OEM_JUMP  )
#define T5D _EQ(           EREOF                                                            )
#define T5E _NE(_none_,    _none_,    _none_,    OEM_BACKTAB,OEM_BACKTAB,OEM_BACKTAB,OEM_BACKTAB)
#define T5F _NE(NONAME,    NONAME,    NONAME,    OEM_AUTO,  OEM_AUTO,  OEM_AUTO,  OEM_AUTO  )
#define T60 _EQ(           _none_                                                           )
#define T61 _NE(_none_,    _none_,    _none_,    ZOOM,      ZOOM,      ZOOM,      ZOOM      )
#define T62 _NE(_none_,    _none_,    _none_,    HELP,      HELP,      HELP,      HELP      )
#define T63 _EQ(           _none_                                                           )
#define T64 _EQ(           F13                                                              )
#define T65 _EQ(           F14                                                              )
#define T66 _EQ(           F15                                                              )
#define T67 _EQ(           F16                                                              )
#define T68 _EQ(           F17                                                              )
#define T69 _EQ(           F18                                                              )
#define T6A _EQ(           F19                                                              )
#define T6B _EQ(           F20                                                              )
#define T6C _EQ(           F21                                                              )
#define T6D _EQ(           F22                                                              )
#define T6E _EQ(           F23                                                              )
#define T6F _NE(_none_,    _none_,    _none_,    OEM_PA3,   OEM_PA3,   OEM_PA3,   OEM_PA3   )
#define T70 _NE(DBE_KATAKANA,DBE_HIRAGANA,_none_,_none_,    _none_,    _none_,    _none_    )
#define T71 _NE(_none_,    _none_,    _none_,    OEM_RESET, OEM_RESET, OEM_RESET, OEM_RESET )
#define T72 _EQ(           _none_                                                           )
#define T73 _NE(OEM_102,   OEM_102,   _none_,    ABNT_C1,   ABNT_C1,   ABNT_C1,   ABNT_C1   )
#define T74 _EQ(           _none_                                                           )
#define T75 _EQ(           _none_                                                           )
#define T76 _EQ(           F24                                                              )
#define T77 _NE(DBE_SBCSCHAR,_none_,  _none_,    _none_,    _none_,    _none_,    _none_    )
#define T78 _EQ(           _none_                                                           )
#define T79 _NE(CONVERT,   CONVERT,   _none_,    _none_,    _none_,    _none_,    _none_    )
#define T7A _EQ(           _none_                                                           )
#define T7B _NE(NONCONVERT,NONCONVERT,_none_,    OEM_PA1,   OEM_PA1,   OEM_PA1,   OEM_PA1   )
#define T7C _EQ(           TAB                                                              )
#define T7D _NE(_none_,    OEM_5,     _none_,    _none_,    _none_,    _none_,    _none_    )
#define T7E _EQ(           ABNT_C2                                                          )
#define T7F _EQ(           OEM_PA2                                                          )

#define X10 _EQ(           MEDIA_PREV_TRACK                                                 ) // SpeedRacer
#define X19 _EQ(           MEDIA_NEXT_TRACK                                                 ) // SpeedRacer
#define X1C _EQ(           RETURN                                                           )
#define X1D _NE(RCONTROL,  RCONTROL,DBE_KATAKANA,HANJA,     HANGEUL,   RCONTROL,  RCONTROL  )
#define X20 _EQ(           VOLUME_MUTE                                                      ) // SpeedRacer
#define X21 _EQ(           LAUNCH_APP2                                                      ) // SpeedRacer
#define X22 _EQ(           MEDIA_PLAY_PAUSE                                                 ) // SpeedRacer
#define X24 _EQ(           MEDIA_STOP                                                       ) // SpeedRacer
#define X2E _EQ(           VOLUME_DOWN                                                      ) // SpeedRacer
#define X30 _EQ(           VOLUME_UP                                                        ) // SpeedRacer
#define X32 _EQ(           BROWSER_HOME                                                     ) // SpeedRacer
#define X33 _NE(OEM_8,     _none_,    _none_,    _none_,    _none_,    _none_,    _none_    )
#define X35 _EQ(           DIVIDE                                                           )
#define X37 _EQ(           SNAPSHOT                                                         )
#define X38 _NE(DBE_HIRAGANA,RMENU,   KANJI,     HANGEUL,   HANJA,     RMENU,     RMENU     )
#define X42 _EQ(           _none_                                                           )
#define X43 _EQ(           _none_                                                           )
#define X44 _EQ(           _none_                                                           )
#define X46 _EQ(           CANCEL                                                           )
#define X47 _EQ(           HOME                                                             )
#define X48 _EQ(           UP                                                               )
#define X49 _EQ(           PRIOR                                                            )
#define X4B _EQ(           LEFT                                                             )
#define X4D _EQ(           RIGHT                                                            )
#define X4F _EQ(           END                                                              )
#define X50 _EQ(           DOWN                                                             )
#define X51 _EQ(           NEXT                                                             )
#define X52 _EQ(           INSERT                                                           )
#define X53 _EQ(           DELETE                                                           )
#define X5B _EQ(           LWIN                                                             )
#define X5C _EQ(           RWIN                                                             )
#define X5D _EQ(           APPS                                                             )
#define X5E _EQ(           POWER                                                            )
#define X5F _EQ(           SLEEP                                                            )
#define X65 _EQ(           BROWSER_SEARCH                                                   ) // SpeedRacer
#define X66 _EQ(           BROWSER_FAVORITES                                                ) // SpeedRacer
#define X67 _EQ(           BROWSER_REFRESH                                                  ) // SpeedRacer
#define X68 _EQ(           BROWSER_STOP                                                     ) // SpeedRacer
#define X69 _EQ(           BROWSER_FORWARD                                                  ) // SpeedRacer
#define X6A _EQ(           BROWSER_BACK                                                     ) // SpeedRacer
#define X6B _EQ(           LAUNCH_APP1                                                      ) // SpeedRacer
#define X6C _EQ(           LAUNCH_MAIL                                                      ) // SpeedRacer
#define X6D _EQ(           LAUNCH_MEDIA_SELECT                                              ) // SpeedRacer
#define XF1 _NE(_none_,    _none_,    _none_,    HANJA,     HANJA,     HANJA,     HANJA     )
#define XF2 _NE(_none_,    _none_,    _none_,    HANGEUL,   HANGEUL,   HANGEUL,   HANGEUL   )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(           PAUSE                                                            )

#elif (KBD_TYPE > 20) && (KBD_TYPE <= 22)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   20       Fujitsu FMR JIS keyboard.
*   21       Fujitsu FMR OYAYUBI keyboard.
*   22 *     Fujitsu FMV OYAYUBI keyboard.
*
*     +------+ +----------+----------+----------+
*     | Scan | |  kbd     |  kbd     |  kbd     |
*     | code | | type 20  | type 21  | type 22  |
\****+-------+-+----------+----------+----------+***********************/
#define T00 _EQ(                      _none_    )
#define T01 _EQ(                      ESCAPE    )
#define T02 _EQ(                      '1'       )
#define T03 _EQ(                      '2'       )
#define T04 _EQ(                      '3'       )
#define T05 _EQ(                      '4'       )
#define T06 _EQ(                      '5'       )
#define T07 _EQ(                      '6'       )
#define T08 _EQ(                      '7'       )
#define T09 _EQ(                      '8'       )
#define T0A _EQ(                      '9'       )
#define T0B _EQ(                      '0'       )
#define T0C _EQ(                      OEM_MINUS )
#define T0D _EQ(                      OEM_7     )
#define T0E _NE(OEM_5,     OEM_5,     BACK      )
#define T0F _NE(BACK,      BACK,      TAB       )
#define T10 _NE(TAB,       TAB,       'Q'       )
#define T11 _NE('Q',       'Q',       'W'       )
#define T12 _NE('W',       'W',       'E'       )
#define T13 _NE('E',       'E',       'R'       )
#define T14 _NE('R',       'R',       'T'       )
#define T15 _NE('T',       'T',       'Y'       )
#define T16 _NE('Y',       'Y',       'U'       )
#define T17 _NE('U',       'U',       'I'       )
#define T18 _NE('I',       'I',       'O'       )
#define T19 _NE('O',       'O',       'P'       )
#define T1A _NE('P',       'P',       OEM_3     )
#define T1B _NE(OEM_3,     OEM_3,     OEM_4     )
#define T1C _NE(OEM_4,     OEM_4,     RETURN    )
#define T1D _NE(RETURN,    RETURN,    LCONTROL  )
#define T1E _EQ(                      'A'       )
#define T1F _EQ(                      'S'       )
#define T20 _EQ(                      'D'       )
#define T21 _EQ(                      'F'       )
#define T22 _EQ(                      'G'       )
#define T23 _EQ(                      'H'       )
#define T24 _EQ(                      'J'       )
#define T25 _EQ(                      'K'       )
#define T26 _EQ(                      'L'       )
#define T27 _EQ(                      OEM_PLUS  )
#define T28 _EQ(                      OEM_1     )
#define T29 _NE(OEM_6,     OEM_6,     DBE_SBCSCHAR)
#define T2A _NE('Z',       'Z',       LSHIFT    )
#define T2B _NE('X',       'X',       OEM_6     )
#define T2C _NE('C',       'C',       'Z'       )
#define T2D _NE('V',       'V',       'X'       )
#define T2E _NE('B',       'B',       'C'       )
#define T2F _NE('N',       'N',       'V'       )
#define T30 _NE('M',       'M',       'B'       )
#define T31 _NE(OEM_COMMA, OEM_COMMA, 'N'       )
#define T32 _NE(OEM_PERIOD,OEM_PERIOD,'M'       )
#define T33 _NE(OEM_2,     OEM_2,     OEM_COMMA )
#define T34 _NE(OEM_8,     OEM_8,     OEM_PERIOD)
#define T35 _NE(' ',       ' ',       OEM_2     )
#define T36 _NE(MULTIPLY,  MULTIPLY,  RSHIFT    )
#define T37 _NE(DIVIDE,    DIVIDE,    MULTIPLY  )
#define T38 _NE(ADD,       ADD,       LMENU     )
#define T39 _NE(SUBTRACT,  SUBTRACT,  ' '       )
#define T3A _NE(NUMPAD7,   NUMPAD7,   DBE_ALPHANUMERIC)
#define T3B _NE(NUMPAD8,   NUMPAD8,   F1        )
#define T3C _NE(NUMPAD9,   NUMPAD9,   F2        )
#define T3D _NE(EQUAL,     EQUAL,     F3        )
#define T3E _NE(NUMPAD4,   NUMPAD4,   F4        )
#define T3F _NE(NUMPAD5,   NUMPAD5,   F5        )
#define T40 _NE(NUMPAD6,   NUMPAD6,   F6        )
#define T41 _NE(SEPARATOR, SEPARATOR, F7        )
#define T42 _NE(NUMPAD1,   NUMPAD1,   F8        )
#define T43 _NE(NUMPAD2,   NUMPAD2,   F9        )
#define T44 _NE(NUMPAD3,   NUMPAD3,   F10       )
#define T45 _NE(RETURN,    RETURN,    NUMLOCK   )
#define T46 _NE(NUMPAD0,   NUMPAD0,   SCROLL    )
#define T47 _NE(DECIMAL,   DECIMAL,   HOME      )
#define T48 _NE(INSERT,    INSERT,    UP        )
#define T49 _NE(OEM_00,    OEM_00,    PRIOR     )
#define T4A _NE(OEM_000,   OEM_000,   SUBTRACT  )
#define T4B _NE(DELETE,    DELETE,    LEFT      )
#define T4C _NE(_none_,    _none_,    CLEAR     )
#define T4D _NE(UP,        UP,        RIGHT     )
#define T4E _NE(HOME,      HOME,      ADD       )
#define T4F _NE(LEFT,      LEFT,      END       )
#define T50 _EQ(                      DOWN      )
#define T51 _NE(RIGHT,     RIGHT,     NEXT      )
#define T52 _NE(LCONTROL,  LCONTROL,  INSERT    )
#define T53 _NE(LSHIFT,    LSHIFT,    DELETE    )
#define T54 _NE(_none_,    _none_,    SNAPSHOT  )
#define T55 _NE(CAPITAL,   _none_,    _none_    )
#define T56 _NE(DBE_HIRAGANA,_none_,  _none_    )
#define T57 _NE(NONCONVERT,NONCONVERT,F11       )
#define T58 _NE(CONVERT,   CONVERT,   F12       )
#define T59 _NE(KANJI,     KANJI,     CLEAR     )
#define T5A _NE(DBE_KATAKANA,_none_,  NONAME    )
#define T5B _NE(F12,       F12,       NONAME    )
#define T5C _NE(LMENU,     LMENU,     NONAME    )
#define T5D _NE(F1,        F1,        EREOF     )
#define T5E _NE(F2,        F2,        _none_    )
#define T5F _NE(F3,        F3,        NONAME    )
#define T60 _NE(F4,        F4,        _none_    )
#define T61 _NE(F5,        F5,        _none_    )
#define T62 _NE(F6,        F6,        _none_    )
#define T63 _NE(F7,        F7,        _none_    )
#define T64 _NE(F8,        F8,        F13       )
#define T65 _NE(F9,        F9,        F14       )
#define T66 _NE(F10,       F10,       F15       )
#define T67 _NE(_none_,    OEM_LOYA,  F16       )
#define T68 _NE(_none_,    OEM_ROYA,  F17       )
#define T69 _NE(F11,       F11,       F18       )
#define T6A _NE(_none_,    DBE_ALPHANUMERIC,F19 )
#define T6B _NE(OEM_JISHO, OEM_JISHO, F20       )
#define T6C _NE(OEM_MASSHOU,OEM_MASSHOU,F21     )
#define T6D _NE(_none_,    _none_,    F22       )
#define T6E _NE(PRIOR,     PRIOR,     F23       )
#define T6F _NE(_none_,    DBE_KATAKANA,_none_  )
#define T70 _NE(NEXT,      NEXT,      DBE_HIRAGANA)
#define T71 _EQ(                      _none_    )
#define T72 _NE(CANCEL,    CANCEL,    _none_    )
#define T73 _NE(EXECUTE,   EXECUTE,   OEM_102   )
#define T74 _NE(F13,       F13,       _none_    )
#define T75 _NE(F14,       F14,       _none_    )
#define T76 _NE(F15,       F15,       F24       )
#define T77 _NE(F16,       F16,       _none_    )
#define T78 _NE(CLEAR,     CLEAR,     _none_    )
#define T79 _NE(HELP,      HELP,      CONVERT   )
#define T7A _NE(END,       END,       _none_    )
#define T7B _NE(SCROLL,    SCROLL,    NONCONVERT)
#define T7C _NE(PAUSE,     PAUSE,     TAB       )
#define T7D _NE(SNAPSHOT,  SNAPSHOT,  OEM_5     )
#define T7E _NE(_none_,    _none_,    ABNT_C2   )
#define T7F _NE(_none_,    _none_,    OEM_PA2   )

#define X1C _NE(_none_,    _none_,    RETURN    )
#define X1D _NE(_none_,    _none_,    RCONTROL  )
#define X33 _EQ(                      _none_    )
#define X35 _NE(_none_,    _none_,    DIVIDE    )
#define X37 _NE(_none_,    _none_,    SNAPSHOT  )
#define X38 _NE(_none_,    _none_,    RMENU     )
#define X42 _EQ(                      _none_    )
#define X43 _EQ(                      _none_    )
#define X44 _EQ(                      _none_    )
#define X46 _NE(_none_,    _none_,    CANCEL    )
#define X47 _NE(_none_,    _none_,    HOME      )
#define X48 _NE(_none_,    _none_,    UP        )
#define X49 _NE(_none_,    _none_,    PRIOR     )
#define X4B _NE(_none_,    _none_,    LEFT      )
#define X4D _NE(_none_,    _none_,    RIGHT     )
#define X4F _NE(_none_,    _none_,    END       )
#define X50 _NE(_none_,    _none_,    DOWN      )
#define X51 _NE(_none_,    _none_,    NEXT      )
#define X52 _NE(_none_,    _none_,    INSERT    )
#define X53 _NE(_none_,    _none_,    DELETE    )
#define X5B _NE(_none_,    _none_,    LWIN      )
#define X5C _NE(_none_,    _none_,    RWIN      )
#define X5D _NE(_none_,    _none_,    APPS      )
#define X5E _EQ(                      POWER     )
#define X5F _EQ(                      SLEEP     )
#define X60 _NE(SCROLL,    SCROLL,    _none_    )
#define X61 _NE(HOME,      HOME,      _none_    )
#define X62 _NE(END,       END,       _none_    )
#define X63 _EQ(                      _none_    )
#define X64 _EQ(                      _none_    )
#define X65 _EQ(                      _none_    )
#define X66 _EQ(                      _none_    )
#define X6D _NE(OEM_TOUROKU,OEM_TOUROKU,_none_  )
#define X71 _NE(DBE_SBCSCHAR,DBE_SBCSCHAR,_none_)
#define X74 _EQ(                      _none_    )
#define X75 _EQ(                      _none_    )
#define X76 _EQ(                      _none_    )
#define X77 _EQ(                      _none_    )
#define X78 _EQ(                      _none_    )
#define X79 _EQ(                      _none_    )
#define X7A _EQ(                      _none_    )
#define X7B _EQ(                      _none_    )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(              PAUSE             )

#elif (KBD_TYPE >= 30) && (KBD_TYPE <= 34)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   30 *     NEC PC-9800 Normal Keyboard.
*   31       NEC PC-9800 Document processor Keyboard.  - not supported on NT5
*   32       NEC PC-9800 106 Keyboard. - same as KBD_TYPE 8
*   33       NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows NT 5.0.
*            NEC PC-98NX for Hydra: PC-9800 Keyboard on Windows 95/NT.
*   34       NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows NT 3.51/4.0.
*
*     +------+ +----------+----------+----------+
*     | Scan | |   kbd    |   kbd    |   kbd    |
*     | code | |  type 30 |  type 33 |  type 34 |
\****+-------+-+----------+----------+----------+***********************/
#define T00 _EQ(_none_                          )
#define T01 _EQ(ESCAPE                          )
#define T02 _EQ('1'                             )
#define T03 _EQ('2'                             )
#define T04 _EQ('3'                             )
#define T05 _EQ('4'                             )
#define T06 _EQ('5'                             )
#define T07 _EQ('6'                             )
#define T08 _EQ('7'                             )
#define T09 _EQ('8'                             )
#define T0A _EQ('9'                             )
#define T0B _EQ('0'                             )
#define T0C _EQ(OEM_MINUS                       )
#define T0D _NE(OEM_7,     OEM_7,     OEM_PLUS  )
#define T0E _EQ(BACK                            )
#define T0F _EQ(TAB                             )
#define T10 _EQ('Q'                             )
#define T11 _EQ('W'                             )
#define T12 _EQ('E'                             )
#define T13 _EQ('R'                             )
#define T14 _EQ('T'                             )
#define T15 _EQ('Y'                             )
#define T16 _EQ('U'                             )
#define T17 _EQ('I'                             )
#define T18 _EQ('O'                             )
#define T19 _EQ('P'                             )
#define T1A _NE(OEM_3,     OEM_3,     OEM_4     )
#define T1B _NE(OEM_4,     OEM_4,     OEM_6     )
#define T1C _EQ(RETURN                          )
#define T1D _EQ(LCONTROL                        )
#define T1E _EQ('A'                             )
#define T1F _EQ('S'                             )
#define T20 _EQ('D'                             )
#define T21 _EQ('F'                             )
#define T22 _EQ('G'                             )
#define T23 _EQ('H'                             )
#define T24 _EQ('J'                             )
#define T25 _EQ('K'                             )
#define T26 _EQ('L'                             )
#define T27 _NE(OEM_PLUS,  OEM_PLUS,  OEM_1     )
#define T28 _NE(OEM_1,     OEM_1,     OEM_7     )
#define T29 _NE(DBE_SBCSCHAR, \
                           DBE_SBCSCHAR, \
                                      OEM_3     )
#define T2A _EQ(LSHIFT                          )
#define T2B _NE(OEM_6,     OEM_6,     OEM_5     )
#define T2C _EQ('Z'                             )
#define T2D _EQ('X'                             )
#define T2E _EQ('C'                             )
#define T2F _EQ('V'                             )
#define T30 _EQ('B'                             )
#define T31 _EQ('N'                             )
#define T32 _EQ('M'                             )
#define T33 _EQ(OEM_COMMA                       )
#define T34 _EQ(OEM_PERIOD                      )
#define T35 _EQ(OEM_2                           )
#define T36 _EQ(RSHIFT                          )
#define T37 _EQ(MULTIPLY                        )
#define T38 _EQ(LMENU                           )
#define T39 _EQ(' '                             )
#define T3A _EQ(CAPITAL                         )
#define T3B _EQ(F1                              )
#define T3C _EQ(F2                              )
#define T3D _EQ(F3                              )
#define T3E _EQ(F4                              )
#define T3F _EQ(F5                              )
#define T40 _EQ(F6                              )
#define T41 _EQ(F7                              )
#define T42 _EQ(F8                              )
#define T43 _EQ(F9                              )
#define T44 _EQ(F10                             )
#define T45 _EQ(NUMLOCK                         )
#define T46 _EQ(SCROLL                          )
#define T47 _EQ(HOME                            )
#define T48 _EQ(UP                              )
#define T49 _EQ(PRIOR                           )
#define T4A _EQ(SUBTRACT                        )
#define T4B _EQ(LEFT                            )
#define T4C _EQ(CLEAR                           )
#define T4D _EQ(RIGHT                           )
#define T4E _EQ(ADD                             )
#define T4F _EQ(END                             )
#define T50 _EQ(DOWN                            )
#define T51 _EQ(NEXT                            )
#define T52 _EQ(INSERT                          )
#define T53 _EQ(DELETE                          )
#define T54 _EQ(SNAPSHOT                        )
#define T55 _NE(_none_,    _none_,    OEM_8     )
#define T56 _EQ(_none_                          )
#define T57 _EQ(F11                             )
#define T58 _EQ(F12                             )
#define T59 _EQ(OEM_NEC_EQUAL                   )
#define T5A _NE(NONAME,    NONAME,    NONCONVERT)
#define T5B _NE(_none_,    _none_,    NONAME    )
#define T5C _EQ(SEPARATOR                       )
#define T5D _EQ(F13                             )
#define T5E _EQ(F14                             )
#define T5F _EQ(F15                             )
#define T60 _EQ(_none_                          )
#define T61 _EQ(_none_                          )
#define T62 _EQ(_none_                          )
#define T63 _EQ(_none_                          )
#define T64 _NE(_none_,    _none_,    F13       )
#define T65 _NE(_none_,    _none_,    F14       )
#define T66 _NE(_none_,    _none_,    F15       )
#define T67 _NE(_none_,    _none_,    F16       )
#define T68 _NE(_none_,    _none_,    F17       )
#define T69 _NE(_none_,    _none_,    F18       )
#define T6A _NE(_none_,    _none_,    F19       )
#define T6B _NE(_none_,    _none_,    F20       )
#define T6C _NE(_none_,    _none_,    F21       )
#define T6D _NE(_none_,    _none_,    F22       )
#define T6E _NE(_none_,    _none_,    F23       )
#define T6F _EQ(_none_                          )
#define T70 _NE(KANA,      KANA,      DBE_HIRAGANA)
#define T71 _EQ(_none_                          )
#define T72 _EQ(_none_                          )
#define T73 _NE(OEM_8,     OEM_8,     _none_    )
#define T74 _NE(_none_,    OEM_NEC_EQUAL, \
                                      _none_    )
#define T75 _NE(_none_,    SEPARATOR, _none_    )
#define T76 _NE(_none_,    _none_,    F24       )
#define T77 _NE(_none_,    _none_,    DBE_SBCSCHAR)
#define T78 _EQ(_none_                          )
#define T79 _EQ(CONVERT                         )
#define T7A _EQ(_none_                          )
#define T7B _EQ(NONCONVERT                      )
#define T7C _NE(TAB,       _none_,    _none_    )
#define T7D _NE(OEM_5,     OEM_5,     _none_    )
#define T7E _NE(ABNT_C2,   ABNT_C2,   _none_    )
#define T7F _NE(OEM_PA2,   OEM_PA2,   _none_    )

#define X1C _EQ(RETURN                          )
#define X1D _NE(RCONTROL,  RCONTROL,  KANA      )
#define X33 _EQ(_none_                          )
#define X35 _EQ(DIVIDE                          )
#define X37 _EQ(SNAPSHOT                        )
#define X38 _NE(_none_,    _none_,    KANJI     )
#define X42 _NE(_none_,    _none_,    RCONTROL  )
#define X43 _NE(_none_,    _none_,    RMENU     )
#define X44 _EQ(_none_                          )
#define X46 _EQ(CANCEL                          )
#define X47 _EQ(HOME                            )
#define X48 _EQ(UP                              )
#define X49 _EQ(PRIOR                           )
#define X4B _EQ(LEFT                            )
#define X4D _EQ(RIGHT                           )
#define X4F _EQ(END                             )
#define X50 _EQ(DOWN                            )
#define X51 _EQ(NEXT                            )
#define X52 _EQ(INSERT                          )
#define X53 _EQ(DELETE                          )
#define X5B _EQ(LWIN                            )
#define X5C _EQ(RWIN                            )
#define X5D _EQ(APPS                            )
#define X5E _EQ(POWER                           )
#define X5F _EQ(SLEEP                           )
#define X60 _EQ(_none_                          )
#define X61 _EQ(_none_                          )
#define X62 _EQ(_none_                          )
#define X63 _EQ(_none_                          )
#define X64 _EQ(_none_                          )
#define X65 _EQ(_none_                          )
#define X66 _EQ(_none_                          )
#define X6D _EQ(_none_                          )
#define X71 _EQ(_none_                          )
#define X74 _EQ(_none_                          )
#define X75 _EQ(_none_                          )
#define X76 _EQ(_none_                          )
#define X77 _EQ(_none_                          )
#define X78 _EQ(_none_                          )
#define X79 _EQ(_none_                          )
#define X7A _EQ(_none_                          )
#define X7B _EQ(_none_                          )
        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(PAUSE                          )

#elif (KBD_TYPE == 37)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   37 *     NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows 95.
*
*     +------+ +----------+
*     | Scan | |   kbd    |
*     | code | |  type 37 |
\****+-------+-+----------+*********************************************/
#define T00 _EQ(ESCAPE    )
#define T01 _EQ('1'       )
#define T02 _EQ('2'       )
#define T03 _EQ('3'       )
#define T04 _EQ('4'       )
#define T05 _EQ('5'       )
#define T06 _EQ('6'       )
#define T07 _EQ('7'       )
#define T08 _EQ('8'       )
#define T09 _EQ('9'       )
#define T0A _EQ('0'       )
#define T0B _EQ(OEM_MINUS )
#define T0C _EQ(OEM_7     )
#define T0D _EQ(OEM_5     )
#define T0E _EQ(BACK      )
#define T0F _EQ(TAB       )
#define T10 _EQ('Q'       )
#define T11 _EQ('W'       )
#define T12 _EQ('E'       )
#define T13 _EQ('R'       )
#define T14 _EQ('T'       )
#define T15 _EQ('Y'       )
#define T16 _EQ('U'       )
#define T17 _EQ('I'       )
#define T18 _EQ('O'       )
#define T19 _EQ('P'       )
#define T1A _EQ(OEM_3     )
#define T1B _EQ(OEM_4     )
#define T1C _EQ(RETURN    )
#define T1D _EQ('A'       )
#define T1E _EQ('S'       )
#define T1F _EQ('D'       )
#define T20 _EQ('F'       )
#define T21 _EQ('G'       )
#define T22 _EQ('H'       )
#define T23 _EQ('J'       )
#define T24 _EQ('K'       )
#define T25 _EQ('L'       )
#define T26 _EQ(OEM_PLUS  )
#define T27 _EQ(OEM_1     )
#define T28 _EQ(OEM_6     )
#define T29 _EQ('Z'       )
#define T2A _EQ('X'       )
#define T2B _EQ('C'       )
#define T2C _EQ('V'       )
#define T2D _EQ('B'       )
#define T2E _EQ('N'       )
#define T2F _EQ('M'       )
#define T30 _EQ(OEM_COMMA )
#define T31 _EQ(OEM_PERIOD)
#define T32 _EQ(OEM_2     )
#define T33 _EQ(OEM_8     )
#define T34 _EQ(' '       )
#define T35 _EQ(CONVERT   )
#define T36 _EQ(NEXT      )
#define T37 _EQ(PRIOR     )
#define T38 _EQ(INSERT    )
#define T39 _EQ(DELETE    )
#define T3A _EQ(UP        )
#define T3B _EQ(LEFT      )
#define T3C _EQ(RIGHT     )
#define T3D _EQ(DOWN      )
#define T3E _EQ(HOME      )
#define T3F _EQ(END       )
#define T40 _EQ(SUBTRACT  )
#define T41 _EQ(DIVIDE    )
#define T42 _EQ(NUMPAD7   )
#define T43 _EQ(NUMPAD8   )
#define T44 _EQ(NUMPAD9   )
#define T45 _EQ(MULTIPLY  )
#define T46 _EQ(NUMPAD4   )
#define T47 _EQ(NUMPAD5   )
#define T48 _EQ(NUMPAD6   )
#define T49 _EQ(ADD       )
#define T4A _EQ(NUMPAD1   )
#define T4B _EQ(NUMPAD2   )
#define T4C _EQ(NUMPAD3   )
#define T4D _EQ(OEM_NEC_EQUAL)
#define T4E _EQ(NUMPAD0   )
#define T4F _EQ(SEPARATOR )
#define T50 _EQ(DECIMAL   )
#define T51 _EQ(NONCONVERT)
#define T52 _EQ(F11       )
#define T53 _EQ(F12       )
#define T54 _EQ(F13       )
#define T55 _EQ(F14       )
#define T56 _EQ(F15       )
#define T57 _EQ(_none_    )
#define T58 _EQ(_none_    )
#define T59 _EQ(_none_    )
#define T5A _EQ(_none_    )
#define T5B _EQ(_none_    )
#define T5C _EQ(RETURN    )
#define T5D _EQ(_none_    )
#define T5E _EQ(_none_    )
#define T5F _EQ(_none_    )
#define T60 _EQ(CANCEL    )
#define T61 _EQ(SNAPSHOT  )
#define T62 _EQ(F1        )
#define T63 _EQ(F2        )
#define T64 _EQ(F3        )
#define T65 _EQ(F4        )
#define T66 _EQ(F5        )
#define T67 _EQ(F6        )
#define T68 _EQ(F7        )
#define T69 _EQ(F8        )
#define T6A _EQ(F9        )
#define T6B _EQ(F10       )
#define T6C _EQ(_none_    )
#define T6D _EQ(_none_    )
#define T6E _EQ(_none_    )
#define T6F _EQ(_none_    )
#define T70 _EQ(LSHIFT    )
#define T71 _EQ(CAPITAL   )
#define T72 _EQ(KANA      )
#define T73 _EQ(LMENU     )
#define T74 _EQ(LCONTROL  )
#define T75 _EQ(_none_    )
#define T76 _EQ(_none_    )
#define T77 _EQ(LWIN      )
#define T78 _EQ(RWIN      )
#define T79 _EQ(APPS      )
#define T7A _EQ(_none_    )
#define T7B _EQ(_none_    )
#define T7C _EQ(_none_    )
#define T7D _EQ(RSHIFT    )
#define T7E _EQ(ABNT_C2   )
#define T7F _EQ(OEM_PA2   )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must conevrt the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(PAUSE    )

#elif (KBD_TYPE >= 40) && (KBD_TYPE <= 41)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Two sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   40 *     DEC LK411-JJ (JIS  layout) keyboard
*   41       DEC LK411-AJ (ANSI layout) keyboard
*
*     +------+ +-----------+-----------+
*     | Scan | |    kbd    |    kbd    |
*     | code | |  LK411-JJ |  LK411-AJ |
\*****+------+-+-----------+-----------+********************************/
#define T00 _EQ(        _none_            )
#define T01 _EQ(        ESCAPE            )
#define T02 _EQ(        '1'               )
#define T03 _EQ(        '2'               )
#define T04 _EQ(        '3'               )
#define T05 _EQ(        '4'               )
#define T06 _EQ(        '5'               )
#define T07 _EQ(        '6'               )
#define T08 _EQ(        '7'               )
#define T09 _EQ(        '8'               )
#define T0A _EQ(        '9'               )
#define T0B _EQ(        '0'               )
#define T0C _EQ(        OEM_MINUS         )
#define T0D _NE( OEM_7,      OEM_PLUS     ) // "^"/"="
#define T0E _EQ(        BACK              )
#define T0F _EQ(        TAB               )
#define T10 _EQ(        'Q'               )
#define T11 _EQ(        'W'               )
#define T12 _EQ(        'E'               )
#define T13 _EQ(        'R'               )
#define T14 _EQ(        'T'               )
#define T15 _EQ(        'Y'               )
#define T16 _EQ(        'U'               )
#define T17 _EQ(        'I'               )
#define T18 _EQ(        'O'               )
#define T19 _EQ(        'P'               )
#define T1A _NE( OEM_3,      OEM_4        ) // "@"/"["
#define T1B _NE( OEM_4,      OEM_6        ) // "["/"]"
#define T1C _EQ(        RETURN            )
#define T1D _EQ(        LCONTROL          )
#define T1E _EQ(        'A'               )
#define T1F _EQ(        'S'               )
#define T20 _EQ(        'D'               )
#define T21 _EQ(        'F'               )
#define T22 _EQ(        'G'               )
#define T23 _EQ(        'H'               )
#define T24 _EQ(        'J'               )
#define T25 _EQ(        'K'               )
#define T26 _EQ(        'L'               )
#define T27 _NE( OEM_PLUS,   OEM_1        ) // ";"
#define T28 _NE( OEM_1,      OEM_7        ) // ":"/"'"
#define T29 _NE( _none_,     DBE_SBCSCHAR ) // LK411AJ uses "<>" as SBCS/DBCS key
#define T2A _EQ(        LSHIFT            )
#define T2B _NE( OEM_6,      OEM_5        ) // "]"/"\"
#define T2C _EQ(        'Z'               )
#define T2D _EQ(        'X'               )
#define T2E _EQ(        'C'               )
#define T2F _EQ(        'V'               )
#define T30 _EQ(        'B'               )
#define T31 _EQ(        'N'               )
#define T32 _EQ(        'M'               )
#define T33 _EQ(        OEM_COMMA         )
#define T34 _EQ(        OEM_PERIOD        )
#define T35 _EQ(        OEM_2             ) // "/"
#define T36 _EQ(        RSHIFT            )
#define T37 _EQ(        MULTIPLY          ) // PF3 : "*"
#define T38 _EQ(        LMENU             ) // Alt(Left)
#define T39 _EQ(        ' '               ) // Space
#define T3A _EQ(        CAPITAL           ) // LOCK : Caps Lock
#define T3B _EQ(        F1                )
#define T3C _EQ(        F2                )
#define T3D _EQ(        F3                )
#define T3E _EQ(        F4                )
#define T3F _EQ(        F5                )
#define T40 _EQ(        F6                )
#define T41 _EQ(        F7                )
#define T42 _EQ(        F8                )
#define T43 _EQ(        F9                )
#define T44 _EQ(        F10               )
#define T45 _EQ(        NUMLOCK           ) // PF1 : Num Lock
#define T46 _EQ(        SCROLL            ) // F19 : Scroll Lock
#define T47 _EQ(        HOME              ) // KP7 : Home
#define T48 _EQ(        UP                ) // KP8 : Up
#define T49 _EQ(        PRIOR             ) // KP9 : Page Up
#define T4A _EQ(        SUBTRACT          ) // PF4 : "-"
#define T4B _EQ(        LEFT              ) // KP4 : Left
#define T4C _EQ(        CLEAR             ) // KP5 : Clear
#define T4D _EQ(        RIGHT             ) // KP6 : Right
#define T4E _EQ(        ADD               ) // KP, : Add
#define T4F _EQ(        END               ) // KP1 : End
#define T50 _EQ(        DOWN              ) // KP2 : Down
#define T51 _EQ(        NEXT              ) // KP3 : Next
#define T52 _EQ(        INSERT            ) // KP0 : Ins
#define T53 _EQ(        DELETE            ) // KP. : Del
#define T54 _EQ(        SNAPSHOT          )
#define T55 _EQ(        _none_            )
#define T56 _EQ(        _none_            )
#define T57 _EQ(        F11               )
#define T58 _EQ(        F12               )
#define T59 _EQ(        _none_            )
#define T5A _EQ(        _none_            )
#define T5B _EQ(        _none_            )
#define T5C _EQ(        _none_            )
#define T5D _EQ(        _none_            )
#define T5E _EQ(        _none_            )
#define T5F _EQ(        _none_            )
#define T60 _EQ(        _none_            )
#define T61 _EQ(        _none_            )
#define T62 _EQ(        _none_            )
#define T63 _EQ(        _none_            )
#define T64 _EQ(        _none_            )
#define T65 _EQ(        _none_            )
#define T66 _EQ(        _none_            )
#define T67 _EQ(        _none_            )
#define T68 _EQ(        _none_            )
#define T69 _EQ(        _none_            )
#define T6A _EQ(        _none_            )
#define T6B _EQ(        _none_            )
#define T6C _EQ(        _none_            )
#define T6D _EQ(        _none_            )
#define T6E _EQ(        _none_            )
#define T6F _EQ(        _none_            )
#define T70 _EQ(       DBE_HIRAGANA       ) // Hiragana/Katakana
#define T71 _EQ(        _none_            )
#define T72 _EQ(        _none_            )
#define T73 _NE( OEM_102,     _none_      ) // LK411JJ, Katakana "Ro"
#define T74 _EQ(        _none_            )
#define T75 _EQ(        _none_            )
#define T76 _EQ(        _none_            )
#define T77 _EQ(        _none_            )
#define T78 _EQ(        _none_            )
#define T79 _EQ(        CONVERT           ) // Henkan
#define T7A _EQ(        _none_            )
#define T7B _EQ(        NONCONVERT        ) // Mu-Henkan
#define T7C _EQ(        _none_            )
#define T7D _NE( OEM_5,       _none_      ) // LK411JJ, Yen(Back-slash)
#define T7E _EQ(        _none_            )
#define T7F _EQ(        _none_            )

#define X0F _EQ(        KANA              ) // Kana
#define X1C _EQ(        RETURN            ) // Enter
#define X1D _EQ(        RCONTROL          ) // Comp : Right Control
#define X33 _EQ(        _none_            )
#define X35 _EQ(        DIVIDE            ) // PF2: "/"
#define X37 _EQ(        SNAPSHOT          ) // F18: PrintScreen
#define X38 _EQ(        RMENU             ) // Alt(Right)
#define X3D _EQ(        F13               )
#define X3E _EQ(        F14               )
#define X3F _EQ(        F15               ) // Help : F15
#define X40 _EQ(        F16               ) // Do :   F16
#define X41 _EQ(        F17               )
#define X42 _EQ(        _none_            )
#define X43 _EQ(        _none_            )
#define X44 _EQ(        _none_            )
#define X46 _EQ(        CANCEL            )
#define X47 _EQ(        HOME              ) // Find : HOME
#define X48 _EQ(        UP                )
#define X49 _EQ(        PRIOR             ) // Prev : PageUp
#define X4B _EQ(        LEFT              )
#define X4D _EQ(        RIGHT             )
#define X4E _EQ(        ADD               ) // KP- (Minus but "Add")
#define X4F _EQ(        END               ) // Select : END
#define X50 _EQ(        DOWN              )
#define X51 _EQ(        NEXT              ) // Next : PageDown
#define X52 _EQ(        INSERT            )
#define X53 _EQ(        DELETE            ) // Remove
#define X5B _EQ(        _none_            )
#define X5C _EQ(        _none_            )
#define X5D _EQ(        _none_            )
#define X5E _EQ(        POWER             )
#define X5F _EQ(        SLEEP             )
        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(        PAUSE             )

#endif // KBD_TYPE

#define SCANCODE_LSHIFT      0x2A
#define SCANCODE_RSHIFT      0x36
#define SCANCODE_CTRL        0x1D
#define SCANCODE_ALT         0x38
#define SCANCODE_SIMULATED   (FAKE_KEYSTROKE >> 16)

#define SCANCODE_NUMPAD_FIRST 0x47
#define SCANCODE_NUMPAD_LAST  0x52

#define SCANCODE_LWIN         0x5B
#define SCANCODE_RWIN         0x5C

#define SCANCODE_THAI_LAYOUT_TOGGLE 0x29

/*
 * Hydra FarEast
 */

/*
 * Structure for client keyboard information
 */
typedef struct _CLIENTKEYBOARDTYPE {
    ULONG Type;
    ULONG SubType;
    ULONG FunctionKey;
} CLIENTKEYBOARDTYPE, *PCLIENTKEYBOARDTYPE;


#endif // _KBD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\printoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    printoem.h

Abstract:

    Declarations for Windows NT printer driver OEM plugins

--*/


#ifndef _PRINTOEM_
#define _PRINTOEM_

#ifdef __cplusplus
extern "C" {
#endif

//
// Current OEM plugin interface version number
//

#define PRINTER_OEMINTF_VERSION 0x00010000

#define OEM_MODE_PUBLISHER     0x00000001

typedef struct _PUBLISHERINFO {

    DWORD dwMode;           // flags for publisher
    WORD  wMinoutlinePPEM;  // min size to download as Type1
    WORD  wMaxbitmapPPEM;   // max size to download as Type3

} PUBLISHERINFO, *PPUBLISHERINFO;

#define OEMGI_GETSIGNATURE        1
#define OEMGI_GETINTERFACEVERSION 2
#define OEMGI_GETVERSION          3
#define OEMGI_GETPUBLISHERINFO    4

//
// OEMGetInfo
//
BOOL APIENTRY
OEMGetInfo(
    IN  DWORD  dwMode,
    OUT PVOID  pBuffer,
    IN  DWORD  cbSize,
    OUT PDWORD pcbNeeded
    );

BOOL APIENTRY
OEMDriverDMS(
    PVOID    pDevObj,
    PVOID    pBuffer,
    DWORD    cbSize,
    PDWORD   pcbNeeded
    );


//
// OEMDevMode
//

#define OEMDM_SIZE     1
#define OEMDM_DEFAULT  2
#define OEMDM_CONVERT  3
#define OEMDM_MERGE    4

typedef struct _OEMDMPARAM {

    DWORD    cbSize;        // size of OEM_DEVMODEPARAM
    PVOID    pdriverobj;    // reference to driver data structure
    HANDLE   hPrinter;      // PRINTER handle
    HANDLE   hModule;       // OEM module handle
    PDEVMODE pPublicDMIn;   // public devmode in
    PDEVMODE pPublicDMOut;  // public devmode out
    PVOID    pOEMDMIn;      // OEM private devmode in
    PVOID    pOEMDMOut;     // OEM private devmode out
    DWORD    cbBufSize;     // output size of pOEMDMOut buffer

} OEMDMPARAM, *POEMDMPARAM;

typedef struct _OEM_DMEXTRAHEADER {

    DWORD   dwSize;         // size of OEM extra data
    DWORD   dwSignature;    // Unique OEM signature
    DWORD   dwVersion;      // OEM DLL version number

} OEM_DMEXTRAHEADER, *POEM_DMEXTRAHEADER;

//
// USERDATA for OPTITEM.UserData
//

typedef struct _USERDATA {

    DWORD       dwSize;                 // Size of this structure
    ULONG_PTR    dwItemID;               // XXX_ITEM or pointer to FEATURE
    PSTR        pKeyWordName;           // Keyword name
    DWORD       dwReserved[8];
} USERDATA, *PUSERDATA;


BOOL APIENTRY
OEMDevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam
    );

//
// Callback function provided by the driver to
// allow OEM plugins access/set/update to driver private settings
//

typedef BOOL (APIENTRY *PFN_DrvGetDriverSetting)(
        PVOID   pdriverobj,
        PCSTR   Feature,
        PVOID   pOutput,
        DWORD   cbSize,
        PDWORD  pcbNeeded,
        PDWORD  pdwOptionsReturned
        );

//
// Callback function provided by the driver to
// allow OEM plugins upgrade private registry settings. This
// function is called only at OEMDrvUpgradeDriver
//

typedef BOOL (APIENTRY *PFN_DrvUpgradeRegistrySetting)(
        HANDLE   hPrinter,
        PCSTR    pFeature,
        PCSTR    pOption
        );

//
// Callback function provided by the driver UI to
// allow OEM plugins to update the driver UI settings and
// shows constraint. This function is called only when the UI is present.
//

typedef BOOL (APIENTRY *PFN_DrvUpdateUISetting)(
        PVOID    pdriverobj,
        PVOID    pOptItem,
        DWORD    dwPreviousSelection,
        DWORD    dwMode
        );



// Predefined feature indices used for accessing driver private settings

#define OEMGDS_MIN_DOCSTICKY        1
#define OEMGDS_PSDM_FLAGS           1       // DWORD - misc. flag bits
#define OEMGDS_PSDM_DIALECT         2       // INT - PS output option
#define OEMGDS_PSDM_TTDLFMT         3       // INT - TrueType font downloading option
#define OEMGDS_PSDM_NUP             4       // INT - N-up option
#define OEMGDS_PSDM_PSLEVEL         5       // INT - target language level
#define OEMGDS_PSDM_CUSTOMSIZE      6       // 5*DWORD - custom page size parameters

#define OEMGDS_UNIDM_GPDVER         0x4000  // WORD - GPD Version
#define OEMGDS_UNIDM_FLAGS          0x4001  // DWORD - misc flag bits

// Indices for private devmode fields - start at 0x4000

#define OEMGDS_MIN_PRINTERSTICKY    0x8000
#define OEMGDS_PRINTFLAGS           0x8000  // DWORD - misc. flag bits
#define OEMGDS_FREEMEM              0x8001  // DWORD - amount of VM, ps only
#define OEMGDS_JOBTIMEOUT           0x8002  // DWORD - job timeout, ps only
#define OEMGDS_WAITTIMEOUT          0x8003  // DWORD - wait timeout, ps only
#define OEMGDS_PROTOCOL             0x8004  // WORD - output protocol, ps only
#define OEMGDS_MINOUTLINE           0x8005  // WORD - min outline font size, ps only
#define OEMGDS_MAXBITMAP            0x8006  // WORD - max bitmap font size, ps only

#define OEMGDS_MAX                  0x10000


//   dwType  flags for use with     STDMETHOD (DrvGetGPDData)
#define         GPD_OEMCUSTOMDATA       1


/*******************************************************************************
 *
 * Definitions used by kernel-mode rendering module only:
 *  Make sure the macro KERNEL_MODE is defined and
 *  the header file winddi.h is included before this file.
 */

#ifdef KERNEL_MODE

//
// OEMEnableDriver
//

BOOL APIENTRY
OEMEnableDriver(
    DWORD           dwOemIntfVersion,
    DWORD           cbSize,
    PDRVENABLEDATA  pded
    );

typedef struct _DEVOBJ *PDEVOBJ;
typedef PVOID PDEVOEM;

typedef DWORD (APIENTRY *PFN_DrvWriteSpoolBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize
    );

typedef DWORD (APIENTRY *PFN_DrvWriteAbortBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize,
    DWORD       dwWait

    );

typedef INT (APIENTRY *PFN_DrvXMoveTo)(
    PDEVOBJ pdevobj,
    INT     x,
    DWORD   dwFlags
    );

typedef INT (APIENTRY *PFN_DrvYMoveTo)(
    PDEVOBJ pdevobj,
    INT     y,
    DWORD   dwFlags
    );

typedef BOOL (APIENTRY *PFN_DrvGetStandardVariable)(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    );

typedef enum _STDVARIABLEINDEX{

        SVI_NUMDATABYTES,          // "NumOfDataBytes"
        SVI_WIDTHINBYTES,          // "RasterDataWidthInBytes"
        SVI_HEIGHTINPIXELS,        // "RasterDataHeightInPixels"
        SVI_COPIES,                // "NumOfCopies"
        SVI_PRINTDIRECTION,        // "PrintDirInCCDegrees"
        SVI_DESTX,                 // "DestX"
        SVI_DESTY,                 // "DestY"
        SVI_DESTXREL,              // "DestXRel"
        SVI_DESTYREL,              // "DestYRel"
        SVI_LINEFEEDSPACING,       // "LinefeedSpacing"
        SVI_RECTXSIZE,             // "RectXSize"
        SVI_RECTYSIZE,             // "RectYSize"
        SVI_GRAYPERCENT,           // "GrayPercentage"
        SVI_NEXTFONTID,            // "NextFontID"
        SVI_NEXTGLYPH,             // "NextGlyph"
        SVI_PHYSPAPERLENGTH,       // "PhysPaperLength"
        SVI_PHYSPAPERWIDTH,        // "PhysPaperWidth"
        SVI_FONTHEIGHT,            // "FontHeight"
        SVI_FONTWIDTH,             // "FontWidth"
        SVI_FONTMAXWIDTH,             // "FontMaxWidth"
        SVI_FONTBOLD,              // "FontBold"
        SVI_FONTITALIC,            // "FontItalic"
        SVI_FONTUNDERLINE,         // "FontUnderline"
        SVI_FONTSTRIKETHRU,        // "FontStrikeThru"
        SVI_CURRENTFONTID,         // "CurrentFontID"
        SVI_TEXTYRES,              // "TextYRes"
        SVI_TEXTXRES,              // "TextXRes"
// #ifdef  BETA2
        SVI_GRAPHICSYRES,              // "GraphicsYRes"
        SVI_GRAPHICSXRES,              // "GraphicsXRes"
// #endif
        SVI_ROP3,                  // "Rop3"
        SVI_REDVALUE,              // "RedValue"
        SVI_GREENVALUE,            // "GreenValue"
        SVI_BLUEVALUE,             // "BlueValue"
        SVI_PALETTEINDEXTOPROGRAM, // "PaletteIndexToProgram"
        SVI_CURRENTPALETTEINDEX,   // "CurrentPaletteIndex"
        SVI_PATTERNBRUSH_TYPE,     // "PatternBrushType"
        SVI_PATTERNBRUSH_ID,       // "PatternBrushID"
        SVI_PATTERNBRUSH_SIZE,     // "PatternBrushSize"
        SVI_CURSORORIGINX,           //  "CursorOriginX"
        SVI_CURSORORIGINY,           //  "CursorOriginY"
                //  this is in MasterUnits and in the coordinates of the currently selected orientation.
                //  this value is defined as ImageableOrigin - CursorOrigin

        SVI_MAX             //  Just a placeholder do not use.
}STDVARIABLEINDEX;






typedef BOOL (APIENTRY *PFN_DrvUnidriverTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

//
// bit fields defined for dwFlags
//
// Note:  The following Bit values are reserved for an internal use!
//  0x4000
//  0x8000 
// 
//
#define MV_UPDATE       0x0001
#define MV_RELATIVE     0x0002
#define MV_GRAPHICS     0x0004
#define MV_PHYSICAL     0x0008
#define MV_SENDXMOVECMD     0x0010
#define MV_SENDYMOVECMD     0x0020

typedef struct _DRVPROCS {

    PFN_DrvWriteSpoolBuf    DrvWriteSpoolBuf;   // common to both pscript and unidrv
    PFN_DrvXMoveTo          DrvXMoveTo;         // unidrv specific
    PFN_DrvYMoveTo          DrvYMoveTo;         // unidrv specific
    PFN_DrvGetDriverSetting DrvGetDriverSetting;// common to both pscript and unidrv
    PFN_DrvGetStandardVariable BGetStandardVariable; // unidrv specific
    PFN_DrvUnidriverTextOut    DrvUnidriverTextOut;  // unidrv specific
    PFN_DrvWriteAbortBuf    DrvWriteAbortBuf;   // unidrv specific

} DRVPROCS, *PDRVPROCS;

typedef struct _DEVOBJ {

    DWORD       dwSize;       // size of DEVOBJ structure
    PDEVOEM     pdevOEM;      // pointer to OEM's device data
    HANDLE      hEngine;      // GDI handle for current printer
    HANDLE      hPrinter;     // spooler handle for current printer
    HANDLE      hOEM;         // handle to OEM dll
    PDEVMODE    pPublicDM;    // public devmode
    PVOID       pOEMDM;       // OEM private devmode
    PDRVPROCS   pDrvProcs;    // pointer to kernel mode helper function table

} DEVOBJ;

//
// OEMDisableDriver
//

VOID APIENTRY
OEMDisableDriver(
    VOID
    );

//
// OEMEnablePDEV
//

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded
    );

//
// OEMDisablePDEV
//

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    );

//
// OEMResetPDEV
//

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    );

//
// OEMCommand - PSCRIPT only
//

DWORD APIENTRY
OEMCommand(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize
    );

INT APIENTRY
OEMCommandCallback(
    PDEVOBJ         pdevobj,
    DWORD           dwCallbackID,
    DWORD           dwCount,
    PDWORD          pdwParams
    );

//
// OEMImageProcessing - UNIDRV only
//

typedef struct {
    DWORD dwSize;
    POINT ptOffset;
    PSTR  pHalftoneOption;
    BOOL  bBanding;
    BOOL  bBlankBand;
} IPPARAMS, *PIPPARAMS;

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ     pdevobj,
    PBYTE       pSrcBitmap,
    PBITMAPINFOHEADER pBitmapInfoHeader,
    PBYTE       pColorTable,
    DWORD       dwCallbackID,
    PIPPARAMS   pIPParams
    );

//
// OEMFilterGraphics - UNIDRV only
//

BOOL APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    );

//
// OEMCompression - UNIDRV only
//
INT APIENTRY
OEMCompression(
    PDEVOBJ pdevobj,
    PBYTE   pInBuf,
    PBYTE   pOutBuf,
    DWORD   dwInLen,
    DWORD   dwOutLen
    );

//
// OEMHalftone - UNIDRV only
//

BOOL APIENTRY
OEMHalftonePattern(
    PDEVOBJ pdevobj,
    PBYTE   pHTPattern,
    DWORD   dwHTPatternX,
    DWORD   dwHTPatternY,
    DWORD   dwHTNumPatterns,
    DWORD   dwCallbackID,
    PBYTE   pResource,
    DWORD   dwResourceSize
    );

//
// OEMMemoryUsage - UNIDRV only
//

typedef struct {
    DWORD   dwFixedMemoryUsage;
    DWORD   dwPercentMemoryUsage;
    DWORD   dwMaxBandSize;
} OEMMEMORYUSAGE, *POEMMEMORYUSAGE;

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    );

//
// OEMTTYGetInfo - UNIDRV only
//
INT APIENTRY
OEMTTYGetInfo(
    PDEVOBJ pdevobj,
    DWORD   dwInfoIndex,
    PVOID   pOutputBuf,
    DWORD   dwSize,
    DWORD   *pcbcNeeded
    );

#define OEMTTY_INFO_MARGINS     1
#define OEMTTY_INFO_CODEPAGE    2
#define OEMTTY_INFO_NUM_UFMS    3
#define OEMTTY_INFO_UFM_IDS     4

//
// UNIDRV font callback
//

typedef BOOL (*PFNGETINFO)(struct _UNIFONTOBJ*, DWORD, PVOID, DWORD, PDWORD);

typedef struct _UNIFONTOBJ {
    ULONG       ulFontID;
    DWORD       dwFlags;     // General flags
    IFIMETRICS *pIFIMetrics; // Pointer to IFIMETRICS
    PFNGETINFO  pfnGetInfo;  // Pointer to UNIFONTOBJ_GetInfo callback
} UNIFONTOBJ, *PUNIFONTOBJ;

//
// UNIFONTOBJ.dwFlags
//

#define UFOFLAG_TTFONT               0x00000001
#define UFOFLAG_TTDOWNLOAD_BITMAP    0x00000002
#define UFOFLAG_TTDOWNLOAD_TTOUTLINE 0x00000004

//
// UNIFONTOBJ callback ID
//

#define UFO_GETINFO_FONTOBJ     1
#define UFO_GETINFO_GLYPHSTRING 2
#define UFO_GETINFO_GLYPHBITMAP 3
#define UFO_GETINFO_GLYPHWIDTH  4
#define UFO_GETINFO_MEMORY      5
#define UFO_GETINFO_STDVARIABLE 6

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_FONTOBJ {
    DWORD    dwSize;   // Size of this structure
    FONTOBJ *pFontObj; // Pointer to the FONTOBJ
} GETINFO_FONTOBJ, *PGETINFO_FONTOBJ;

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_GLYPHSTRING {
    DWORD dwSize;    // Size of this structure
    DWORD dwCount;   // Count of glyphs in pGlyphIn
    DWORD dwTypeIn;  // Glyph type of pGlyphIn, TYPE_GLYPHID/TYPE_HANDLE.
    PVOID pGlyphIn;  // Pointer to the input glyph string
    DWORD dwTypeOut; // Glyph type of pGlyphOut, TYPE_UNICODE/TYPE_TRANSDATA.
    PVOID pGlyphOut; // Pointer to the output glyph string
    DWORD dwGlyphOutSize; // The size of pGlyphOut buffer
} GETINFO_GLYPHSTRING, *PGETINFO_GLYPHSTRING;

//
// UFO_GETINFO_GLYPHBITMAP
//

typedef struct _GETINFO_GLYPHBITMAP {
    DWORD       dwSize;    // Size of this structure
    HGLYPH      hGlyph;    // Glyph hangle passed in OEMDownloadCharGlyph
    GLYPHDATA *pGlyphData; // Pointer to the GLYPHDATA data structure
} GETINFO_GLYPHBITMAP, *PGETINFO_GLYPHBITMAP;

//
// UFO_GETINFO_GLYPHWIDTH
//

typedef struct _GETINFO_GLYPHWIDTH {
    DWORD dwSize;  // Size of this structure
    DWORD dwType;  // Type of glyph stirng in pGlyph, TYPE_GLYPHHANDLE/GLYPHID.
    DWORD dwCount; // Count of glyph in pGlyph
    PVOID pGlyph;  // Pointer to a glyph string
    PLONG plWidth; // Pointer to the buffer of width table.
                   // Minidriver has to prepare this.
} GETINFO_GLYPHWIDTH, *PGETINFO_GLYPHWIDTH;

//
// UFO_GETINFO_MEMORY
//

typedef struct _GETINFO_MEMORY {
    DWORD dwSize;
    DWORD dwRemainingMemory;
} GETINFO_MEMORY, PGETINFO_MEMROY;

//
// UFO_GETINFO_STDVARIABLE
//
// OEM DLL has to prepare all StdVar buffer and set ID in dwStdVarID.
//

typedef struct _GETINFO_STDVAR {
    DWORD dwSize;
    DWORD dwNumOfVariable;
    struct {
        DWORD dwStdVarID;
        LONG  lStdVariable;
    } StdVar[1];
} GETINFO_STDVAR, *PGETINFO_STDVAR;


#define FNT_INFO_PRINTDIRINCCDEGREES  0 // PrintDirInCCDegrees
#define FNT_INFO_GRAYPERCENTAGE       1 // GrayPercentage
#define FNT_INFO_NEXTFONTID           2 // NextfontID
#define FNT_INFO_NEXTGLYPH            3 // NextGlyph
#define FNT_INFO_FONTHEIGHT           4 // FontHeight
#define FNT_INFO_FONTWIDTH            5 // FontWidth
#define FNT_INFO_FONTBOLD             6 // FontBold
#define FNT_INFO_FONTITALIC           7 // FontItalic
#define FNT_INFO_FONTUNDERLINE        8 // FontUnderline
#define FNT_INFO_FONTSTRIKETHRU       9 // FontStrikeThru
#define FNT_INFO_CURRENTFONTID       10 // Current
#define FNT_INFO_TEXTYRES            11 // TextYRes
#define FNT_INFO_TEXTXRES            12 // TextXRes
#define FNT_INFO_FONTMAXWIDTH        13 // FontMaxWidth
#define FNT_INFO_MAX                 14

//
// OEMDownloadFontheader - UNIDRV only
//

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

//
// OEMDownloadCharGlyph - UNIDRV only
//

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    );

//
// OEMTTDownloadMethod - UNIDRV only
//

DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

#define TTDOWNLOAD_DONTCARE  0
#define TTDOWNLOAD_GRAPHICS  1
#define TTDOWNLOAD_BITMAP    2
#define TTDOWNLOAD_TTOUTLINE 3

//
// OEMOutputCharStr - UNIDRV only
//

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph
    );

#define TYPE_UNICODE      1
#define TYPE_TRANSDATA    2
#define TYPE_GLYPHHANDLE  3
#define TYPE_GLYPHID      4

//
// OEMSendFontCmd - UNIDRV only
//

typedef struct _FINVOCATION {
    DWORD dwCount;    // Size of command
    PBYTE pubCommand; // Pointer to font selection command
} FINVOCATION, *PFINVOCATION;

VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv
    );

//
// OEMTextOutAsBitmap - UNIDRV only
//
BOOL APIENTRY
OEMTextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    );

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    );

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    );

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG      *pid
    );

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG      *pid
    );

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    );

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#ifndef WINNT_40

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    );

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    );

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    );

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    );

//
// OEMIcmCreateTransform
//

HANDLE APIENTRY
OEMIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    );

//
// OEMIcmDeleteTransform
//

BOOL APIENTRY
OEMIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    );

//
// OEMQueryDeviceSupport
//

BOOL APIENTRY
OEMQueryDeviceSupport(
    SURFOBJ    *pso,
    XLATEOBJ   *pxlo,
    XFORMOBJ   *pxo,
    ULONG      iType,
    ULONG      cjIn,
    PVOID      pvIn,
    ULONG      cjOut,
    PVOID      pvOut
    );

//
// OEMTransparentBlt
//

BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    );

#endif // !WINNT_40

//
// Function prototype define's for the driver hooks.
//
// NOTE: These are only needed for NT4. For NT5, they are defined in winddi.h.
//

#ifdef WINNT_40

typedef BOOL (APIENTRY  *LPFNDLLINITIALIZE)(
    ULONG           ulReason
    );

typedef BOOL (APIENTRY *PFN_DrvBitBlt)(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

typedef BOOL (APIENTRY *PFN_DrvStretchBlt)(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

typedef BOOL (APIENTRY *PFN_DrvCopyBits)(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

typedef BOOL (APIENTRY *PFN_DrvTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvStrokePath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvStrokeAndFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvRealizeBrush)(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

typedef BOOL (APIENTRY *PFN_DrvStartPage)(
    SURFOBJ    *pso
    );

typedef BOOL (APIENTRY *PFN_DrvSendPage)(
    SURFOBJ    *pso
    );

typedef ULONG (APIENTRY *PFN_DrvEscape)(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef BOOL (APIENTRY *PFN_DrvStartDoc)(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

typedef BOOL (APIENTRY *PFN_DrvEndDoc)(
    SURFOBJ    *pso,
    FLONG       fl
    );

typedef PIFIMETRICS (APIENTRY *PFN_DrvQueryFont)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG      *pid
    );

typedef PVOID (APIENTRY *PFN_DrvQueryFontTree)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG      *pid
    );

typedef LONG (APIENTRY *PFN_DrvQueryFontData)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

typedef BOOL (APIENTRY *PFN_DrvQueryAdvanceWidths)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

typedef ULONG (APIENTRY *PFN_DrvFontManagement)(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef ULONG (APIENTRY *PFN_DrvGetGlyphMode)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

typedef BOOL (APIENTRY *PFN_DrvNextBand)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef BOOL (APIENTRY *PFN_DrvStartBanding)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef ULONG (APIENTRY *PFN_DrvDitherColor)(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

typedef BOOL (APIENTRY *PFN_DrvPaint)(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

typedef BOOL (APIENTRY *PFN_DrvLineTo)(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#endif // WINNT_40

#endif // KERNEL_MODE


/*******************************************************************************
 *
 * Definitions used by user-mode UI module only:
 *  Make sure the macro KERNEL_MODE is NOT defined and
 *  the header file winddiui.h is included before this file.
 *
 */

#ifndef KERNEL_MODE

//
// Reference to driver data structure. This is passed to
// most of the OEM UI DLL entrypoints.
//

typedef struct _OEMUIPROCS {

    PFN_DrvGetDriverSetting DrvGetDriverSetting;
    PFN_DrvUpdateUISetting  DrvUpdateUISetting;

} OEMUIPROCS, *POEMUIPROCS;

typedef struct _OEMUIOBJ {

    DWORD       cbSize;             // size of this structure
    POEMUIPROCS pOemUIProcs;        // pointer to user mode helper function table

} OEMUIOBJ, *POEMUIOBJ;


//
// OEMCommonUIProp
//

typedef struct _OEMCUIPPARAM *POEMCUIPPARAM;
typedef LONG (APIENTRY *OEMCUIPCALLBACK)(PCPSUICBPARAM, POEMCUIPPARAM);

typedef struct _OEMCUIPPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    DWORD           dwFlags;        // misc. flag bits
    POPTITEM        pDrvOptItems;   // pointer to driver items
    DWORD           cDrvOptItems;   // number of driver items
    POPTITEM        pOEMOptItems;   // pointer to OEM items
    DWORD           cOEMOptItems;   // number of OEM items
    PVOID           pOEMUserData;   // pointer to OEM private data
    OEMCUIPCALLBACK  OEMCUIPCallback; // address of callback function

} OEMCUIPPARAM;

BOOL APIENTRY
OEMCommonUIProp(
    DWORD           dwMode,
    POEMCUIPPARAM   pOemCUIPParam
    );

//
// OEMCommonUIProp dwMode parameter value
//
#define OEMCUIP_DOCPROP       1
#define OEMCUIP_PRNPROP       2

//
// OEMDocumentPropertySheets
//

LRESULT APIENTRY
OEMDocumentPropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// OEMDevicePropertySheets
//

LRESULT APIENTRY
OEMDevicePropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// pPSUIInfo->lParamInit is a pointer to _OEMUIPSPARAM structure defined below.
//
typedef struct _OEMUIPSPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    PVOID           pOEMUserData;   // pointer to OEM private data
    DWORD           dwFlags;        // misc. flag bits
    PVOID           pOemEntry;

} OEMUIPSPARAM, *POEMUIPSPARAM;

//
// OEMDevQueryPrintEx
//

BOOL APIENTRY
OEMDevQueryPrintEx(
    POEMUIOBJ           poemuiobj,
    PDEVQUERYPRINT_INFO pDQPInfo,
    PDEVMODE            pPublicDM,
    PVOID               pOEMDM
    );

//
// OEMDeviceCapabilities
//

DWORD APIENTRY
OEMDeviceCapabilities(
    POEMUIOBJ   poemuiobj,
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    DWORD       dwLastResult
    );

//
// OEMUpgradePrinter
//

BOOL APIENTRY
OEMUpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo
    );

//
// OEMUpgradeRegistry
//

BOOL APIENTRY
OEMUpgradeRegistry(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo,
    PFN_DrvUpgradeRegistrySetting pfnUpgrade
    );


//
// OEMPrinterEvent
//

BOOL APIENTRY
OEMPrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam
    );

//
// OEMDriverEvent
//

BOOL APIENTRY
OEMPDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
    );


//
// OEMQueryColorProfile
//

BOOL APIENTRY
OEMQueryColorProfile(
    HANDLE      hPrinter,
    POEMUIOBJ   poemuiobj,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    );

//
// Font Installer dialog proc
//

INT_PTR CALLBACK
OEMFontInstallerDlgProc(
    HWND    hWnd,
    UINT    usMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );


BOOL CALLBACK
OEMUpdateExternalFonts(
    HANDLE  hPrinter,
    HANDLE  hHeap,
    PWSTR   pwstrCartridges
   );


#endif // !KERNEL_MODE

#ifdef __cplusplus
}
#endif

#endif  // !_PRINTOEM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\prntfont.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    prntfont.h

Abstract:

    Declarations for Windows NT printer driver font metrics and glyphset data
    *.UFF, *.UFM and *.GTT file data structure definition

--*/

#ifndef _PRNTFONT_H_
#define _PRNTFONT_H_



//
//
// F O N T  M E T R I C S  ( U F M )
//
//

//
// NOTE: To include this header file, it is necessary to include 
//       winddi.h, that has a definition of IFIMETRICS, FD_KERNINGPAIR
//
//


//
// UNIFM
//
// Universal printer driver (UNIDRV) font file header.
//

#define UNIFM_VERSION_1_0 0x00010000

typedef struct _UNIFM_HDR
{
    DWORD      dwSize;             // a total size of this font file
    DWORD      dwVersion;          // a version number of this font file
    ULONG      ulDefaultCodepage;  // this font's default codepage
    LONG       lGlyphSetDataRCID;  // a resource ID of GLYPHDATA
    DWORD      loUnidrvInfo;       // offset to UNIDRVINFO
    DWORD      loIFIMetrics;       // offset to IFIMETRICS
    DWORD      loExtTextMetric;    // offset to EXTTEXTMETRIC
    DWORD      loWidthTable;       // offset to WIDTHTABLE
    DWORD      loKernPair;         // offset to KERNPAIR
    DWORD      dwReserved[2];
} UNIFM_HDR, *PUNIFM_HDR;

#define GET_UNIDRVINFO(pUFM)    \
        ((PUNIDRVINFO)((PBYTE)(pUFM) + (pUFM)->loUnidrvInfo))
#define GET_IFIMETRICS(pUFM)    \
        ((IFIMETRICS*)((PBYTE)(pUFM) + (pUFM)->loIFIMetrics))
#define GET_EXTTEXTMETRIC(pUFM) \
        ((EXTTEXTMETRIC*)((PBYTE)(pUFM) + (pUFM)->loExtTextMetric))
#define GET_WIDTHTABLE(pUFM)    \
        ((PWIDTHTABLE)((PBYTE)(pUFM) + (pUFM)->loWidthTable))
#define GET_KERNDATA(pUFM)      \
        ((PKERNDATA)((PBYTE)(pUFM) + (pUFM)->loKernPair))

//
// UNIDRVINFO
//
// UNIDRVINFO is used to define printer specific information.
//

typedef struct _INVOC {
        DWORD  dwCount;     // the number of bytes in the invocation string
        DWORD  loOffset;    // byte-offset to the beginning of the array
} INVOC, *PINVOC;

typedef struct _UNIDRVINFO
{
    DWORD   dwSize;
    DWORD   flGenFlags;
    WORD    wType;
    WORD    fCaps;
    WORD    wXRes;
    WORD    wYRes;
    short   sYAdjust;
    short   sYMoved;
    WORD    wPrivateData; 
    short   sShift; 
    INVOC   SelectFont;
    INVOC   UnSelectFont;
    WORD    wReserved[4];
}  UNIDRVINFO, *PUNIDRVINFO;

#define GET_SELECT_CMD(pUni)    \
        ((PCHAR)(pUni) + (pUni)->SelectFont.loOffset)
#define GET_UNSELECT_CMD(pUni)  \
        ((PCHAR)(pUni) + (pUni)->UnSelectFont.loOffset)

//
// flGenFlags
//

#define UFM_SOFT        0x00000001 // Softfont, thus needs downloading 
#define UFM_CART        0x00000002 // This is a cartridge font
#define UFM_SCALABLE    0x00000004 // Font is scalable

//
// wType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2

//
// fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline via 
                                        // FONTSIMU ATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec 
                                        // for details

//
// EXTTEXTMETRIC
//
// The EXTTEXTMETRIC structure provides extended-metric information for a font. 
// All the measurements are given in the specified units, 
// regardless of the current mapping mode of the display context.
//

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

typedef struct _EXTTEXTMETRIC
    {
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC, *PEXTTEXTMETRIC;

#endif // _EXTTEXTMETRIC_


//
// WIDTHTABLE
//
// This data structure represents the character width table. 
// This width table is a continuous GLYPHHANDLE base, 
// not Unicode nor codepage/character code base. 
// GLYPHANDLE information is in the GLYPHDATA.
//

typedef struct _WIDTHRUN
{
    WORD    wStartGlyph;       // index of the first glyph handle
    WORD    wGlyphCount;       // number of glyphs covered
    DWORD   loCharWidthOffset; // glyph width table
} WIDTHRUN, *PWIDTHRUN;

typedef struct _WIDTHTABLE
{
    DWORD   dwSize;        // the size of this structure including every run
    DWORD   dwRunNum;      // the number of widthrun
    WIDTHRUN WidthRun[1];  // width run array
} WIDTHTABLE, *PWIDTHTABLE;

//
// The array has wGlyphCount elements and each element is the char width 
// for a single glyph. The first width corresponds to glyph index wStartGlyph 
// and so on. The byte offset is relative to the beginning of WIDTHTABLE
// structure and must be WORD-aligned.
// In case of Western device font, proportional font has all varibal pitch
// characters. This means that dwRunNum is set to 1 and loCharWidthOffset
// would be an offset from the top of WIDTHTABLE to a width vector of all 
// characters.
// In case of Far Eastern device font, basically IFIMETRICS.fwdAveCharWidth and
// IFIMETRICS.fwdMaxCharWidth are used for single byte and double byte character
// width. If a font is proportional, a UFM has a WIDTHTABLE which represents
// only the proportional pitch characters. Other characters use fdwAveCharWidth
// and fwdMaxCharInc for single and double byte characters.
//

//
// KERNDATA
// This data structure represents kerning pair information.
// This kerning pair table is a Unicode base.
//

typedef struct _KERNDATA
{
    DWORD dwSize;               // the size of this structure including array
    DWORD dwKernPairNum;        // the number of kerning pair
    FD_KERNINGPAIR KernPair[1]; // FD_KERNINGPAIR array
} KERNDATA, *PKERNDATA;



//
//
// G L Y P H  S E T D A T A  ( G T T )
//
//

//
// UNI_GLYPHSETDATA
//
// GLYPHSETDATA data structure represents a character encoding information 
// of printer device font. 
//

typedef struct _UNI_GLYPHSETDATA {
        DWORD   dwSize;
        DWORD   dwVersion;
        DWORD   dwFlags;
        LONG    lPredefinedID;
        DWORD   dwGlyphCount;
        DWORD   dwRunCount;
        DWORD   loRunOffset;
        DWORD   dwCodePageCount;
        DWORD   loCodePageOffset;
        DWORD   loMapTableOffset;
        DWORD   dwReserved[2];
} UNI_GLYPHSETDATA, *PUNI_GLYPHSETDATA;

#define UNI_GLYPHSETDATA_VERSION_1_0    0x00010000

#define GET_GLYPHRUN(pGTT)     \
    ((PGLYPHRUN) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loRunOffset))
#define GET_CODEPAGEINFO(pGTT) \
    ((PUNI_CODEPAGEINFO) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loCodePageOffset))
#define GET_MAPTABLE(pGTT) \
    ((PMAPTABLE) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loMapTableOffset))

//
// UNI_CODEPAGEINFO
//
// This UNI_CODEPAGEINFO dats structure has a list of Codepage values 
// which are supported by this UNI_GLYPHSETDATA.
//

typedef struct _UNI_CODEPAGEINFO {
    DWORD dwCodePage;
    INVOC SelectSymbolSet;
    INVOC UnSelectSymbolSet;
} UNI_CODEPAGEINFO, *PUNI_CODEPAGEINFO;

//
// GLYPHRUN
//
// GLYPHRUN dats structure represents the conversion table from Unicode to 
// UNI_GLYPHSETDATA specific glyph handle. Glyph handle is continuous number 
// starting from zero.
//

typedef struct _GLYPHRUN {
    WCHAR   wcLow;
    WORD    wGlyphCount;
} GLYPHRUN, *PGLYPHRUN;


//
// MAPTABLE and TRANSDATA
//
// This MAPTABLE data structure represents a conversion table fron glyph handle
// to codepage/character code.
//

typedef struct _TRANSDATA {
    BYTE  ubCodePageID; // Codepage index to CODEPAGENFO data structure array
    BYTE  ubType;       // a type of TRANSDATA
    union
    {
        SHORT   sCode;
        BYTE    ubCode;
        BYTE    ubPairs[2];
    } uCode;
} TRANSDATA, *PTRANSDATA;

typedef struct _MAPTABLE {
    DWORD     dwSize;     // the size of MAPTABLE including TRANSDATA array
    DWORD     dwGlyphNum; // the number of glyphs supported in MAPTABLE
    TRANSDATA Trans[1];   // an array of TRANSDATA
} MAPTABLE, *PMAPTABLE;

//
// ubType flags
//
// One of following three can be specified for the type of uCode.
//

#define MTYPE_FORMAT_MASK 0x07
#define MTYPE_COMPOSE   0x01 // wCode is an array of 16-bit offsets from the
                             // beginning of the MAPTABLE pointing to the
                             // strings to use for translation.
                             // bData representes thelength of the translated
                             // string.
#define MTYPE_DIRECT    0x02 // wCode is a byte data of one-to-one translation
#define MTYPE_PAIRED    0x04 // wCode contains a word data to emit.

//
// One of following tow can be specified for Far East multibyte character.
//

#define MTYPE_DOUBLEBYTECHAR_MASK   0x18
#define MTYPE_SINGLE    0x08 // wCode contains a single byte character code in
                             // multi byte character string.
#define MTYPE_DOUBLE    0x10 // wCode contains a double byte character code in
                             // multi byte character string.
//
// One of following three can be specified for replace/add/disable system 
// predefined GTT.
//

#define MTYPE_PREDEFIN_MASK   0xe0
#define MTYPE_REPLACE   0x20 // wCode contains a data to replace predefined one.
#define MTYPE_ADD       0x40 // wCode contains a data to add to predefiend one.
#define MTYPE_DISABLE   0x80 // wCode contains a data to remove from predefined.


//
// System predefined character conversion
//
// UNIDRV is going to support  following system predefined character conversion.
// By speciffying these number in UNIFM.dwGlyphSetDataRCID;
//

#define CC_NOPRECNV 0x0000FFFF // Not use predefined

//
// ANSI
//

#define CC_CP437   -1 // Unicode to IBM Codepage 437
#define CC_CP850   -2 // Unicode to IBM Codepage 850
#define CC_CP863   -3 // Unicode to IBM Codepage 863

//
// Far East
//

#define CC_BIG5     -10 // Unicode to Chinese Big 5. Codepage 950.
#define CC_ISC      -11 // Unicode to Korean Industrial Standard. Codepage 949.
#define CC_JIS      -12 // Unicode to JIS X0208. Codepage 932.
#define CC_JIS_ANK  -13 // Unicode to JIS X0208 except ANK. Codepage 932.
#define CC_NS86     -14 // Big-5 to National Standstand conversion. Codepage 950
#define CC_TCA      -15 // Big-5 to Taipei Computer Association. Codepage 950.
#define CC_GB2312   -16 // Unicode to GB2312. Codepage 936
#define CC_SJIS     -17 // Unicode to Shift-JIS. Codepage 932.
#define CC_WANSUNG  -18 // Unicode to Extented Wansung. Codepage 949.


//
//
// U N I V E R S A L  F O N T  F O R M A T  ( U F F )
//
//

//
// Font file header
//

typedef struct _UFF_FILEHEADER {
    DWORD       dwSignature;            // File magic number
    DWORD       dwVersion;              // UFF file format version number
    DWORD       dwSize;                 // Size of this structure

    DWORD       nFonts;                 // Count of fonts in directory
    DWORD       nGlyphSets;             // Count of glyph set data
    DWORD       nVarData;               // Count of variable data

    DWORD       offFontDir;             // Offset of font directory
    DWORD       dwFlags;                // Miscellaneous flags
    DWORD       dwReserved[4];          // Reserved, set to zero
} UFF_FILEHEADER, *PUFF_FILEHEADER;

//
// Values used in the file header
//

#define UFF_FILE_MAGIC      '1FFU'
#define UFF_VERSION_NUMBER  0x00010001

#define FONT_DIR_SORTED     0x00000001

//
// Font directory structure
//

typedef struct _UFF_FONTDIRECTORY {
    DWORD       dwSignature;            // Signature of font metrics record
    WORD        wSize;                  // Size of this structure
    WORD        wFontID;                // Unique font ID
    SHORT       sGlyphID;               // Associated glyph ID. 0 is default.
                                        // -ve values are predefined IDs
    WORD        wFlags;                 // Miscellaneous flags
    DWORD       dwInstallerSig;         // Signature of installer that installed this font
    DWORD       offFontName;            // Offset to name of font
    DWORD       offCartridgeName;       // Offset to name of font cartridge
    DWORD       offFontData;            // Offset to font data record
    DWORD       offGlyphData;           // Offset to glyph set data
    DWORD       offVarData;             // Offset to softfont data
} UFF_FONTDIRECTORY, *PUFF_FONTDIRECTORY;

#define FONT_REC_SIG            'CERF'  // font metrics record signature

#define WINNT_INSTALLER_SIG     'IFTN'  // NT font installer

//
// Flags used in font directory
//

#define FONT_FL_UFM             0x0001
#define FONT_FL_IFI             0x0002
#define FONT_FL_SOFTFONT        0x0004
#define FONT_FL_PERMANENT_SF    0x0008
#define FONT_FL_DEVICEFONT      0x0010
#define FONT_FL_GLYPHSET_GTT    0x0020
#define FONT_FL_GLYPHSET_RLE    0x0040
#define FONT_FL_RESERVED        0x8000

//
// Data header
//

typedef struct _DATA_HEADER {
    DWORD       dwSignature;            // Signature of data type
    WORD        wSize;                  // Size of this structure
    WORD        wDataID;                // Identifier number for data
    DWORD       dwDataSize;             // Size of data excluding structure
    DWORD       dwReserved;             // Reserved, set to zero
} DATA_HEADER, *PDATA_HEADER;

//
// Data signatures
//

#define DATA_UFM_SIG        'MFUD'
#define DATA_IFI_SIG        'IFID'
#define DATA_GTT_SIG        'TTGD'
#define DATA_CTT_SIG        'TTCD'
#define DATA_VAR_SIG        'RAVD'

//
// Structure passed to font installer dialog proc through LPARAM
//

typedef struct _OEMFONTINSTPARAM {
    DWORD   cbSize;
    HANDLE  hPrinter;
    HANDLE  hModule;
    HANDLE  hHeap;
    DWORD   dwFlags;
    PWSTR   pFontInstallerName;
} OEMFONTINSTPARAM, *POEMFONTINSTPARAM;

#define FG_CANCHANGE        0x00080    // Have access to change data

#define WM_FI_FILENAME      900        // To get the font installer name.



#endif //_PRNTFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\minidrv.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    minidrv.h

Abstract:

    Common header file for Plug-in minidrivers.

Environment:

    Windows NT printer drivers

Revision History:


--*/


#ifndef _MINIDRV_H_
#define _MINIDRV_H_

#include <stddef.h>
#include <stdlib.h>

#include <objbase.h>

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>

//
// defined(KERNEL_MODE) Rendering module DLL in either kernel mode or user mode.
// defined(KERNEL_MODE) & defined(USERMODE_DRIVER) User mode rendering DLL
// !defined(KERNEL_MODE) UI module
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
// Kernel mode rendering DLL
#include "winsplkm.h"
#else
// User mode DLL
#include <winspool.h>
#endif

#if !defined(KERNEL_MODE)
// UI DLL
#include <windows.h>
#include <compstui.h>
#include <winddiui.h>
#endif

#if defined(USERMODE_DRIVER) || !defined(KERNEL_MODE)
// UI DLL or User mode rendering DLL
#include <stdio.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifdef WINNT_40
//
// The LONG_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. ULONG_PTR is
//

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;


#define HandleToUlong( h ) ((ULONG) (h) )
#define PtrToUlong( p )    ((ULONG) (p) )
#define PtrToLong( p )     ((LONG) (p) )
#define PtrToUshort( p )   ((unsigned short) (p) )
#define PtrToShort( p )    ((short) (p) )

#define GWLP_USERDATA       GWL_USERDATA
#define DWLP_USER           DWL_USER
#define DWLP_MSGRESULT      0
#define SetWindowLongPtr    SetWindowLong
#define GetWindowLongPtr    GetWindowLong

#endif // WINNT_40

#include <printoem.h>
#include <prntfont.h>

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5

#if DBG

extern INT giDebugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

extern VOID DbgPrint(PCSTR, ...);
#define DbgBreakPoint EngDebugBreak

#else

extern ULONG _cdecl DbgPrint(PCSTR, ...);
extern VOID DbgBreakPoint(VOID);

#endif

#define DBGMSG(level, prefix, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, __FILE__, __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint msg; \
            } \
        }

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)
#define ERR(msg) DBGMSG(DBG_ERROR, "ERR", msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond) { \
            if (! (cond)) { \
                RIP(("\n")); \
            } \
        }
#endif

#define ASSERTMSG(cond, msg) { \
            if (! (cond)) { \
                RIP(msg); \
            } \
        }

#define RIP(msg) { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DbgBreakPoint(); \
        }


#else // !DBG

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)
#define ERR(msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond)
#endif

#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg)
#define DBGPRINT(level, msg)

#endif

//
// The following macros let you enable tracing on per-file and per-function level.
// To use these macros in a file, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  Define a bit constant for each function you want to trace
//  Add the following line
//      DEFINE_FUNCTION_TRACE_FLAGS(flags);
//  where flags is a bit-wise OR of the functions you want to trace, e.g.
//      TRACE_FLAG_FUNC1 | TRACE_FLAG_FUNC2 | ...
//
//  To generate trace inside each function you want to trace, use:
//      FUNCTION_TRACE(FunctionTraceFlag, (args));
//

#if DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags) \
        static DWORD gdwFunctionTraceFlags = (flags)

#define FUNCTION_TRACE(flag, args) { \
            if (gdwFunctionTraceFlags & (flag)) { \
                DbgPrint args; \
            } \
        }

#else // !DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags)
#define FUNCTION_TRACE(flag, args)

#endif // !DBG


//
// Memory allocation function macros
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }


//
// DBCS CharSet handling macros
//
//
// 128: SHIFTJIS_CHARSET
// 129: HANGEUL_CHARSET
// 130: JOHAB_CHARSET (defined if WINVER >= 0x0400)
// 134: GB2312_CHARSET
// 136: CHINESEBIG5_CHARSET

#define IS_DBCSCHARSET(j) \
    (((j) == SHIFTJIS_CHARSET)    || \
    ((j) == HANGEUL_CHARSET)     || \
    ((j) == JOHAB_CHARSET)       || \
    ((j) == GB2312_CHARSET)      || \
    ((j) == CHINESEBIG5_CHARSET))

//  932: Japan
//  936: Chinese (PRC, Singapore)
//  949: Korean
//  950: Chinese (Taiwan Region, Hong Kong S.A.R., P.R.C.)
// 1361: Korean (Johab)

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
    ((j) == 936)   || \
    ((j) == 949)   || \
    ((j) == 950)   || \
    ((j) == 1361))


//
//  The following are the resource types used in minidrivers and
//  used in the .rc file.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// 5.0 resource types
//

#define RC_UFM         260
#define RC_GTT         261
#define RC_HTPATTERN   264
//
// Internal resource type
//

#define RC_FD_GLYPHSET 262

#ifdef __cplusplus
}
#endif

#endif //_MINIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\oak\inc\prcomoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    prcomoem.h

Abstract:

    Interface declaration for Windows NT printer driver OEM plugins

--*/


#ifndef _PRCOMOEM_H_
#define _PRCOMOEM_H_


//
// This file has to be included after printoem.h. We also need to inlude
// objbase.h or comcat.h from sdk\inc.
//

//
// Each dll/exe must initialize the GUIDs once.If you are not using precompiled
// headers for the file(s) which initializes the GUIDs, define INITGUID before
// including objbase.h.
//

//
// Class ID for OEM rendering component. All OEM rendering plugin need to use this ID.
//
// {6d6abf26-9f38-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMRENDER, 0x6d6abf26, 0x9f38, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Class ID for OEM UI component. All OEM UI plugin need to use this ID.
//
// {abce80d7-9f46-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMUI, 0xabce80d7, 0x9f46, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemCommon Interface
//
// {7f42285e-91d5-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemCommon, 0x7f42285e, 0x91d5, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemEngine Interface
//
// {63d17590-91d8-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemEngine, 0x63d17590, 0x91d8, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUI Interface
//
// {C6A7A9D0-774C-11d1-947F-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUI, 0xc6a7a9d0, 0x774c, 0x11d1, 0x94, 0x7f, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemDriverUI interface
//
// {92B05D50-78BC-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUI, 0x92b05d50, 0x78bc, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemPS Interface
//
// {688342b5-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemPS, 0x688342b5, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemDriverPS interface
//
// {d90060c7-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemDriverPS, 0xd90060c7, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUni Interface
//
// {D67EBBF0-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUni, 0xd67ebbf0, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemDriverUni interface
//
// {D67EBBF1-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUni, 0xd67ebbf1, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

#undef IUnknown

#ifdef __cplusplus
extern "C" {
#endif

//
//****************************************************************************
//  IPrintOemCommon interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemCommon
DECLARE_INTERFACE_(IPrintOemCommon, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;
};

#ifndef KERNEL_MODE

//
// Definitions used by user interface module only.
// Make sure the macro KERNEL_MODE is not defined.
//

//
//****************************************************************************
//  IPrintOemUI interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemUI
DECLARE_INTERFACE_(IPrintOemUI, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;


};


//
//****************************************************************************
//  IPrintOemDriverUI interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemDriverUI
DECLARE_INTERFACE_(IPrintOemDriverUI, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helpder function to allow OEM plugins upgrade private registry
    // settings. This function should be called only by OEM's UpgradePrinter()
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI
    // settings and show constraints. This function should be called only when
    // the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;

};

#else   // KERNEL_MODE

//
// Definitions used by rendering module only.
// Make sure the macro KERNEL_MODE is defined.
//

//
//****************************************************************************
//  IPrintOemEngine interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemEngine
DECLARE_INTERFACE_(IPrintOemEngine, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;
};

//
//****************************************************************************
//  IPrintOemPS interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemPS
DECLARE_INTERFACE_(IPrintOemPS, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverPS interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemDriverPS
DECLARE_INTERFACE_(IPrintOemDriverPS, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverPS methods
    //

    //
    // Method for OEM to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Method for OEM to write to spooler buffer
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;
};


//
//****************************************************************************
//  IPrintOemUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni
DECLARE_INTERFACE_(IPrintOemUni, IPrintOemEngine)
{

    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUni
DECLARE_INTERFACE_(IPrintOemDriverUni, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverUni methods
    //

    //
    // Function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Common to both Unidrv & Pscript
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                           